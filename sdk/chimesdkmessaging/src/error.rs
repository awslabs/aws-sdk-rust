// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchCreateChannelMembershipError {
    pub kind: BatchCreateChannelMembershipErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchCreateChannelMembershipErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchCreateChannelMembershipError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchCreateChannelMembershipErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            BatchCreateChannelMembershipErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            BatchCreateChannelMembershipErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            BatchCreateChannelMembershipErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            BatchCreateChannelMembershipErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            BatchCreateChannelMembershipErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            BatchCreateChannelMembershipErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchCreateChannelMembershipError {
    fn code(&self) -> Option<&str> {
        BatchCreateChannelMembershipError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchCreateChannelMembershipError {
    pub fn new(kind: BatchCreateChannelMembershipErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchCreateChannelMembershipErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchCreateChannelMembershipErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateChannelMembershipErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateChannelMembershipErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateChannelMembershipErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateChannelMembershipErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateChannelMembershipErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateChannelMembershipErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for BatchCreateChannelMembershipError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchCreateChannelMembershipErrorKind::BadRequestException(_inner) => Some(_inner),
            BatchCreateChannelMembershipErrorKind::ForbiddenException(_inner) => Some(_inner),
            BatchCreateChannelMembershipErrorKind::ServiceFailureException(_inner) => Some(_inner),
            BatchCreateChannelMembershipErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            BatchCreateChannelMembershipErrorKind::ThrottledClientException(_inner) => Some(_inner),
            BatchCreateChannelMembershipErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            BatchCreateChannelMembershipErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateChannelError {
    pub kind: CreateChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateChannelError {
    fn code(&self) -> Option<&str> {
        CreateChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateChannelError {
    pub fn new(kind: CreateChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateChannelErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateChannelErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateChannelErrorKind::ConflictException(_inner) => Some(_inner),
            CreateChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateChannelErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateChannelErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateChannelErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateChannelErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateChannelErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateChannelBanError {
    pub kind: CreateChannelBanErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateChannelBanErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateChannelBanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateChannelBanErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateChannelBanErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateChannelBanErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateChannelBanErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CreateChannelBanErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateChannelBanErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateChannelBanErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateChannelBanErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateChannelBanErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateChannelBanError {
    fn code(&self) -> Option<&str> {
        CreateChannelBanError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateChannelBanError {
    pub fn new(kind: CreateChannelBanErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateChannelBanErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateChannelBanErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelBanErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateChannelBanErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateChannelBanErrorKind::ForbiddenException(_))
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelBanErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelBanErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelBanErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelBanErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelBanErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateChannelBanError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateChannelBanErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateChannelBanErrorKind::ConflictException(_inner) => Some(_inner),
            CreateChannelBanErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateChannelBanErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateChannelBanErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateChannelBanErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateChannelBanErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateChannelBanErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateChannelBanErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateChannelMembershipError {
    pub kind: CreateChannelMembershipErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateChannelMembershipErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateChannelMembershipError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateChannelMembershipErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateChannelMembershipErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateChannelMembershipErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateChannelMembershipErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateChannelMembershipErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateChannelMembershipErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateChannelMembershipErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateChannelMembershipErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateChannelMembershipErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateChannelMembershipError {
    fn code(&self) -> Option<&str> {
        CreateChannelMembershipError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateChannelMembershipError {
    pub fn new(kind: CreateChannelMembershipErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateChannelMembershipErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateChannelMembershipErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelMembershipErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelMembershipErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelMembershipErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelMembershipErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelMembershipErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelMembershipErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelMembershipErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelMembershipErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateChannelMembershipError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateChannelMembershipErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateChannelMembershipErrorKind::ConflictException(_inner) => Some(_inner),
            CreateChannelMembershipErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateChannelMembershipErrorKind::ResourceLimitExceededException(_inner) => {
                Some(_inner)
            }
            CreateChannelMembershipErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateChannelMembershipErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateChannelMembershipErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateChannelMembershipErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateChannelMembershipErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateChannelModeratorError {
    pub kind: CreateChannelModeratorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateChannelModeratorErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateChannelModeratorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateChannelModeratorErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateChannelModeratorErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateChannelModeratorErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateChannelModeratorErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateChannelModeratorErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateChannelModeratorErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateChannelModeratorErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateChannelModeratorErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateChannelModeratorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateChannelModeratorError {
    fn code(&self) -> Option<&str> {
        CreateChannelModeratorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateChannelModeratorError {
    pub fn new(kind: CreateChannelModeratorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateChannelModeratorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateChannelModeratorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelModeratorErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelModeratorErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelModeratorErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelModeratorErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelModeratorErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelModeratorErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelModeratorErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelModeratorErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateChannelModeratorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateChannelModeratorErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateChannelModeratorErrorKind::ConflictException(_inner) => Some(_inner),
            CreateChannelModeratorErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateChannelModeratorErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateChannelModeratorErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateChannelModeratorErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateChannelModeratorErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateChannelModeratorErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateChannelModeratorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteChannelError {
    pub kind: DeleteChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteChannelError {
    fn code(&self) -> Option<&str> {
        DeleteChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteChannelError {
    pub fn new(kind: DeleteChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteChannelErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteChannelErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteChannelErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteChannelErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteChannelErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteChannelBanError {
    pub kind: DeleteChannelBanErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteChannelBanErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteChannelBanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteChannelBanErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteChannelBanErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteChannelBanErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteChannelBanErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteChannelBanErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteChannelBanErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteChannelBanErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteChannelBanError {
    fn code(&self) -> Option<&str> {
        DeleteChannelBanError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteChannelBanError {
    pub fn new(kind: DeleteChannelBanErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteChannelBanErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteChannelBanErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelBanErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteChannelBanErrorKind::ForbiddenException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelBanErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelBanErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelBanErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelBanErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteChannelBanError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteChannelBanErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteChannelBanErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteChannelBanErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteChannelBanErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteChannelBanErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteChannelBanErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteChannelBanErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteChannelMembershipError {
    pub kind: DeleteChannelMembershipErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteChannelMembershipErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteChannelMembershipError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteChannelMembershipErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteChannelMembershipErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteChannelMembershipErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteChannelMembershipErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteChannelMembershipErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteChannelMembershipErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteChannelMembershipErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteChannelMembershipErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteChannelMembershipError {
    fn code(&self) -> Option<&str> {
        DeleteChannelMembershipError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteChannelMembershipError {
    pub fn new(kind: DeleteChannelMembershipErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteChannelMembershipErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteChannelMembershipErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelMembershipErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelMembershipErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelMembershipErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelMembershipErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelMembershipErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelMembershipErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelMembershipErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteChannelMembershipError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteChannelMembershipErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteChannelMembershipErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteChannelMembershipErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteChannelMembershipErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteChannelMembershipErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteChannelMembershipErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteChannelMembershipErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteChannelMembershipErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteChannelMessageError {
    pub kind: DeleteChannelMessageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteChannelMessageErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteChannelMessageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteChannelMessageErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteChannelMessageErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteChannelMessageErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteChannelMessageErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteChannelMessageErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteChannelMessageErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteChannelMessageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteChannelMessageError {
    fn code(&self) -> Option<&str> {
        DeleteChannelMessageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteChannelMessageError {
    pub fn new(kind: DeleteChannelMessageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteChannelMessageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteChannelMessageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelMessageErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelMessageErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelMessageErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelMessageErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelMessageErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelMessageErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteChannelMessageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteChannelMessageErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteChannelMessageErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteChannelMessageErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteChannelMessageErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteChannelMessageErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteChannelMessageErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteChannelMessageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteChannelModeratorError {
    pub kind: DeleteChannelModeratorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteChannelModeratorErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteChannelModeratorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteChannelModeratorErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteChannelModeratorErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteChannelModeratorErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteChannelModeratorErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteChannelModeratorErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteChannelModeratorErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteChannelModeratorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteChannelModeratorError {
    fn code(&self) -> Option<&str> {
        DeleteChannelModeratorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteChannelModeratorError {
    pub fn new(kind: DeleteChannelModeratorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteChannelModeratorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteChannelModeratorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelModeratorErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelModeratorErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelModeratorErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelModeratorErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelModeratorErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelModeratorErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteChannelModeratorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteChannelModeratorErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteChannelModeratorErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteChannelModeratorErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteChannelModeratorErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteChannelModeratorErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteChannelModeratorErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteChannelModeratorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeChannelError {
    pub kind: DescribeChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeChannelError {
    fn code(&self) -> Option<&str> {
        DescribeChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeChannelError {
    pub fn new(kind: DescribeChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DescribeChannelErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DescribeChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DescribeChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeChannelErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DescribeChannelErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeChannelErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DescribeChannelErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DescribeChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeChannelBanError {
    pub kind: DescribeChannelBanErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeChannelBanErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeChannelBanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeChannelBanErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeChannelBanErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeChannelBanErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeChannelBanErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DescribeChannelBanErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeChannelBanErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DescribeChannelBanErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DescribeChannelBanErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeChannelBanError {
    fn code(&self) -> Option<&str> {
        DescribeChannelBanError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeChannelBanError {
    pub fn new(kind: DescribeChannelBanErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeChannelBanErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeChannelBanErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelBanErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelBanErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelBanErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelBanErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelBanErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelBanErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelBanErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DescribeChannelBanError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeChannelBanErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeChannelBanErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeChannelBanErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeChannelBanErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DescribeChannelBanErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeChannelBanErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DescribeChannelBanErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DescribeChannelBanErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeChannelMembershipError {
    pub kind: DescribeChannelMembershipErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeChannelMembershipErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeChannelMembershipError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeChannelMembershipErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeChannelMembershipErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeChannelMembershipErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeChannelMembershipErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DescribeChannelMembershipErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DescribeChannelMembershipErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DescribeChannelMembershipErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            DescribeChannelMembershipErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeChannelMembershipError {
    fn code(&self) -> Option<&str> {
        DescribeChannelMembershipError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeChannelMembershipError {
    pub fn new(kind: DescribeChannelMembershipErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeChannelMembershipErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeChannelMembershipErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelMembershipErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelMembershipErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelMembershipErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelMembershipErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelMembershipErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelMembershipErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelMembershipErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DescribeChannelMembershipError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeChannelMembershipErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeChannelMembershipErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeChannelMembershipErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeChannelMembershipErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DescribeChannelMembershipErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeChannelMembershipErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DescribeChannelMembershipErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DescribeChannelMembershipErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeChannelMembershipForAppInstanceUserError {
    pub kind: DescribeChannelMembershipForAppInstanceUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeChannelMembershipForAppInstanceUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeChannelMembershipForAppInstanceUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeChannelMembershipForAppInstanceUserErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeChannelMembershipForAppInstanceUserErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            DescribeChannelMembershipForAppInstanceUserErrorKind::ServiceFailureException(
                _inner,
            ) => _inner.fmt(f),
            DescribeChannelMembershipForAppInstanceUserErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            DescribeChannelMembershipForAppInstanceUserErrorKind::ThrottledClientException(
                _inner,
            ) => _inner.fmt(f),
            DescribeChannelMembershipForAppInstanceUserErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            DescribeChannelMembershipForAppInstanceUserErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeChannelMembershipForAppInstanceUserError {
    fn code(&self) -> Option<&str> {
        DescribeChannelMembershipForAppInstanceUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeChannelMembershipForAppInstanceUserError {
    pub fn new(
        kind: DescribeChannelMembershipForAppInstanceUserErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeChannelMembershipForAppInstanceUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeChannelMembershipForAppInstanceUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelMembershipForAppInstanceUserErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelMembershipForAppInstanceUserErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelMembershipForAppInstanceUserErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelMembershipForAppInstanceUserErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelMembershipForAppInstanceUserErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelMembershipForAppInstanceUserErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DescribeChannelMembershipForAppInstanceUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeChannelMembershipForAppInstanceUserErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            DescribeChannelMembershipForAppInstanceUserErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            DescribeChannelMembershipForAppInstanceUserErrorKind::ServiceFailureException(
                _inner,
            ) => Some(_inner),
            DescribeChannelMembershipForAppInstanceUserErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            DescribeChannelMembershipForAppInstanceUserErrorKind::ThrottledClientException(
                _inner,
            ) => Some(_inner),
            DescribeChannelMembershipForAppInstanceUserErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            DescribeChannelMembershipForAppInstanceUserErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeChannelModeratedByAppInstanceUserError {
    pub kind: DescribeChannelModeratedByAppInstanceUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeChannelModeratedByAppInstanceUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeChannelModeratedByAppInstanceUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeChannelModeratedByAppInstanceUserErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeChannelModeratedByAppInstanceUserErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            DescribeChannelModeratedByAppInstanceUserErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            DescribeChannelModeratedByAppInstanceUserErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            DescribeChannelModeratedByAppInstanceUserErrorKind::ThrottledClientException(
                _inner,
            ) => _inner.fmt(f),
            DescribeChannelModeratedByAppInstanceUserErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            DescribeChannelModeratedByAppInstanceUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeChannelModeratedByAppInstanceUserError {
    fn code(&self) -> Option<&str> {
        DescribeChannelModeratedByAppInstanceUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeChannelModeratedByAppInstanceUserError {
    pub fn new(
        kind: DescribeChannelModeratedByAppInstanceUserErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeChannelModeratedByAppInstanceUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeChannelModeratedByAppInstanceUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelModeratedByAppInstanceUserErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelModeratedByAppInstanceUserErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelModeratedByAppInstanceUserErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelModeratedByAppInstanceUserErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelModeratedByAppInstanceUserErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelModeratedByAppInstanceUserErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DescribeChannelModeratedByAppInstanceUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeChannelModeratedByAppInstanceUserErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            DescribeChannelModeratedByAppInstanceUserErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            DescribeChannelModeratedByAppInstanceUserErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            DescribeChannelModeratedByAppInstanceUserErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            DescribeChannelModeratedByAppInstanceUserErrorKind::ThrottledClientException(
                _inner,
            ) => Some(_inner),
            DescribeChannelModeratedByAppInstanceUserErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            DescribeChannelModeratedByAppInstanceUserErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeChannelModeratorError {
    pub kind: DescribeChannelModeratorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeChannelModeratorErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeChannelModeratorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeChannelModeratorErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeChannelModeratorErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeChannelModeratorErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeChannelModeratorErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DescribeChannelModeratorErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeChannelModeratorErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DescribeChannelModeratorErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DescribeChannelModeratorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeChannelModeratorError {
    fn code(&self) -> Option<&str> {
        DescribeChannelModeratorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeChannelModeratorError {
    pub fn new(kind: DescribeChannelModeratorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeChannelModeratorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeChannelModeratorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelModeratorErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelModeratorErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelModeratorErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelModeratorErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelModeratorErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelModeratorErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelModeratorErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DescribeChannelModeratorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeChannelModeratorErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeChannelModeratorErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeChannelModeratorErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeChannelModeratorErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DescribeChannelModeratorErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeChannelModeratorErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DescribeChannelModeratorErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DescribeChannelModeratorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetChannelMessageError {
    pub kind: GetChannelMessageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetChannelMessageErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetChannelMessageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetChannelMessageErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetChannelMessageErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetChannelMessageErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetChannelMessageErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetChannelMessageErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetChannelMessageErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetChannelMessageErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetChannelMessageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetChannelMessageError {
    fn code(&self) -> Option<&str> {
        GetChannelMessageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetChannelMessageError {
    pub fn new(kind: GetChannelMessageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetChannelMessageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetChannelMessageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetChannelMessageErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetChannelMessageErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetChannelMessageErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetChannelMessageErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetChannelMessageErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetChannelMessageErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetChannelMessageErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetChannelMessageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetChannelMessageErrorKind::BadRequestException(_inner) => Some(_inner),
            GetChannelMessageErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetChannelMessageErrorKind::NotFoundException(_inner) => Some(_inner),
            GetChannelMessageErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetChannelMessageErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetChannelMessageErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetChannelMessageErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetChannelMessageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMessagingSessionEndpointError {
    pub kind: GetMessagingSessionEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMessagingSessionEndpointErrorKind {
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMessagingSessionEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMessagingSessionEndpointErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetMessagingSessionEndpointErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetMessagingSessionEndpointErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetMessagingSessionEndpointErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetMessagingSessionEndpointErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            GetMessagingSessionEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMessagingSessionEndpointError {
    fn code(&self) -> Option<&str> {
        GetMessagingSessionEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMessagingSessionEndpointError {
    pub fn new(kind: GetMessagingSessionEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMessagingSessionEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMessagingSessionEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMessagingSessionEndpointErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMessagingSessionEndpointErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMessagingSessionEndpointErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMessagingSessionEndpointErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMessagingSessionEndpointErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetMessagingSessionEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMessagingSessionEndpointErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetMessagingSessionEndpointErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetMessagingSessionEndpointErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            GetMessagingSessionEndpointErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetMessagingSessionEndpointErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            GetMessagingSessionEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListChannelBansError {
    pub kind: ListChannelBansErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListChannelBansErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListChannelBansError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListChannelBansErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListChannelBansErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListChannelBansErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListChannelBansErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListChannelBansErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListChannelBansErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListChannelBansErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListChannelBansError {
    fn code(&self) -> Option<&str> {
        ListChannelBansError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListChannelBansError {
    pub fn new(kind: ListChannelBansErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListChannelBansErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListChannelBansErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListChannelBansErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListChannelBansErrorKind::ForbiddenException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelBansErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelBansErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelBansErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelBansErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListChannelBansError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListChannelBansErrorKind::BadRequestException(_inner) => Some(_inner),
            ListChannelBansErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListChannelBansErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListChannelBansErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListChannelBansErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListChannelBansErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListChannelBansErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListChannelMembershipsError {
    pub kind: ListChannelMembershipsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListChannelMembershipsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListChannelMembershipsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListChannelMembershipsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListChannelMembershipsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListChannelMembershipsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListChannelMembershipsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListChannelMembershipsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListChannelMembershipsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListChannelMembershipsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListChannelMembershipsError {
    fn code(&self) -> Option<&str> {
        ListChannelMembershipsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListChannelMembershipsError {
    pub fn new(kind: ListChannelMembershipsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListChannelMembershipsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListChannelMembershipsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMembershipsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMembershipsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMembershipsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMembershipsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMembershipsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMembershipsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListChannelMembershipsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListChannelMembershipsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListChannelMembershipsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListChannelMembershipsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListChannelMembershipsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListChannelMembershipsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListChannelMembershipsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListChannelMembershipsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListChannelMembershipsForAppInstanceUserError {
    pub kind: ListChannelMembershipsForAppInstanceUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListChannelMembershipsForAppInstanceUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListChannelMembershipsForAppInstanceUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListChannelMembershipsForAppInstanceUserErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListChannelMembershipsForAppInstanceUserErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            ListChannelMembershipsForAppInstanceUserErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListChannelMembershipsForAppInstanceUserErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            ListChannelMembershipsForAppInstanceUserErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            ListChannelMembershipsForAppInstanceUserErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            ListChannelMembershipsForAppInstanceUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListChannelMembershipsForAppInstanceUserError {
    fn code(&self) -> Option<&str> {
        ListChannelMembershipsForAppInstanceUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListChannelMembershipsForAppInstanceUserError {
    pub fn new(
        kind: ListChannelMembershipsForAppInstanceUserErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListChannelMembershipsForAppInstanceUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListChannelMembershipsForAppInstanceUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMembershipsForAppInstanceUserErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMembershipsForAppInstanceUserErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMembershipsForAppInstanceUserErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMembershipsForAppInstanceUserErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMembershipsForAppInstanceUserErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMembershipsForAppInstanceUserErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListChannelMembershipsForAppInstanceUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListChannelMembershipsForAppInstanceUserErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            ListChannelMembershipsForAppInstanceUserErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            ListChannelMembershipsForAppInstanceUserErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            ListChannelMembershipsForAppInstanceUserErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            ListChannelMembershipsForAppInstanceUserErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            ListChannelMembershipsForAppInstanceUserErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            ListChannelMembershipsForAppInstanceUserErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListChannelMessagesError {
    pub kind: ListChannelMessagesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListChannelMessagesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListChannelMessagesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListChannelMessagesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListChannelMessagesErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListChannelMessagesErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListChannelMessagesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListChannelMessagesErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListChannelMessagesErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListChannelMessagesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListChannelMessagesError {
    fn code(&self) -> Option<&str> {
        ListChannelMessagesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListChannelMessagesError {
    pub fn new(kind: ListChannelMessagesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListChannelMessagesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListChannelMessagesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMessagesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMessagesErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMessagesErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMessagesErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMessagesErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMessagesErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListChannelMessagesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListChannelMessagesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListChannelMessagesErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListChannelMessagesErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListChannelMessagesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListChannelMessagesErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListChannelMessagesErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListChannelMessagesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListChannelModeratorsError {
    pub kind: ListChannelModeratorsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListChannelModeratorsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListChannelModeratorsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListChannelModeratorsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListChannelModeratorsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListChannelModeratorsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListChannelModeratorsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListChannelModeratorsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListChannelModeratorsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListChannelModeratorsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListChannelModeratorsError {
    fn code(&self) -> Option<&str> {
        ListChannelModeratorsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListChannelModeratorsError {
    pub fn new(kind: ListChannelModeratorsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListChannelModeratorsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListChannelModeratorsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelModeratorsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelModeratorsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelModeratorsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelModeratorsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelModeratorsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelModeratorsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListChannelModeratorsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListChannelModeratorsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListChannelModeratorsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListChannelModeratorsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListChannelModeratorsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListChannelModeratorsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListChannelModeratorsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListChannelModeratorsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListChannelsError {
    pub kind: ListChannelsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListChannelsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListChannelsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListChannelsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListChannelsError {
    fn code(&self) -> Option<&str> {
        ListChannelsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListChannelsError {
    pub fn new(kind: ListChannelsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListChannelsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListChannelsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListChannelsErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListChannelsErrorKind::ForbiddenException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListChannelsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListChannelsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListChannelsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListChannelsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListChannelsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListChannelsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListChannelsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListChannelsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListChannelsModeratedByAppInstanceUserError {
    pub kind: ListChannelsModeratedByAppInstanceUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListChannelsModeratedByAppInstanceUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListChannelsModeratedByAppInstanceUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListChannelsModeratedByAppInstanceUserErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListChannelsModeratedByAppInstanceUserErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            ListChannelsModeratedByAppInstanceUserErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListChannelsModeratedByAppInstanceUserErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            ListChannelsModeratedByAppInstanceUserErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            ListChannelsModeratedByAppInstanceUserErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            ListChannelsModeratedByAppInstanceUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListChannelsModeratedByAppInstanceUserError {
    fn code(&self) -> Option<&str> {
        ListChannelsModeratedByAppInstanceUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListChannelsModeratedByAppInstanceUserError {
    pub fn new(
        kind: ListChannelsModeratedByAppInstanceUserErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListChannelsModeratedByAppInstanceUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListChannelsModeratedByAppInstanceUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsModeratedByAppInstanceUserErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsModeratedByAppInstanceUserErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsModeratedByAppInstanceUserErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsModeratedByAppInstanceUserErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsModeratedByAppInstanceUserErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsModeratedByAppInstanceUserErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListChannelsModeratedByAppInstanceUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListChannelsModeratedByAppInstanceUserErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            ListChannelsModeratedByAppInstanceUserErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            ListChannelsModeratedByAppInstanceUserErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            ListChannelsModeratedByAppInstanceUserErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            ListChannelsModeratedByAppInstanceUserErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            ListChannelsModeratedByAppInstanceUserErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            ListChannelsModeratedByAppInstanceUserErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RedactChannelMessageError {
    pub kind: RedactChannelMessageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RedactChannelMessageErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RedactChannelMessageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RedactChannelMessageErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            RedactChannelMessageErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            RedactChannelMessageErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            RedactChannelMessageErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            RedactChannelMessageErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            RedactChannelMessageErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            RedactChannelMessageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RedactChannelMessageError {
    fn code(&self) -> Option<&str> {
        RedactChannelMessageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RedactChannelMessageError {
    pub fn new(kind: RedactChannelMessageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RedactChannelMessageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RedactChannelMessageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RedactChannelMessageErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            RedactChannelMessageErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RedactChannelMessageErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            RedactChannelMessageErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            RedactChannelMessageErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            RedactChannelMessageErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for RedactChannelMessageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RedactChannelMessageErrorKind::BadRequestException(_inner) => Some(_inner),
            RedactChannelMessageErrorKind::ForbiddenException(_inner) => Some(_inner),
            RedactChannelMessageErrorKind::ServiceFailureException(_inner) => Some(_inner),
            RedactChannelMessageErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            RedactChannelMessageErrorKind::ThrottledClientException(_inner) => Some(_inner),
            RedactChannelMessageErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            RedactChannelMessageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SendChannelMessageError {
    pub kind: SendChannelMessageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SendChannelMessageErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SendChannelMessageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SendChannelMessageErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            SendChannelMessageErrorKind::ConflictException(_inner) => _inner.fmt(f),
            SendChannelMessageErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            SendChannelMessageErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            SendChannelMessageErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            SendChannelMessageErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            SendChannelMessageErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            SendChannelMessageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SendChannelMessageError {
    fn code(&self) -> Option<&str> {
        SendChannelMessageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SendChannelMessageError {
    pub fn new(kind: SendChannelMessageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SendChannelMessageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SendChannelMessageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendChannelMessageErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendChannelMessageErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendChannelMessageErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendChannelMessageErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendChannelMessageErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendChannelMessageErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendChannelMessageErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for SendChannelMessageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SendChannelMessageErrorKind::BadRequestException(_inner) => Some(_inner),
            SendChannelMessageErrorKind::ConflictException(_inner) => Some(_inner),
            SendChannelMessageErrorKind::ForbiddenException(_inner) => Some(_inner),
            SendChannelMessageErrorKind::ServiceFailureException(_inner) => Some(_inner),
            SendChannelMessageErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            SendChannelMessageErrorKind::ThrottledClientException(_inner) => Some(_inner),
            SendChannelMessageErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            SendChannelMessageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateChannelError {
    pub kind: UpdateChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateChannelError {
    fn code(&self) -> Option<&str> {
        UpdateChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateChannelError {
    pub fn new(kind: UpdateChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateChannelErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateChannelErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateChannelErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateChannelErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateChannelErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateChannelErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateChannelErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateChannelMessageError {
    pub kind: UpdateChannelMessageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateChannelMessageErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateChannelMessageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateChannelMessageErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateChannelMessageErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateChannelMessageErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateChannelMessageErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateChannelMessageErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateChannelMessageErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateChannelMessageErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdateChannelMessageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateChannelMessageError {
    fn code(&self) -> Option<&str> {
        UpdateChannelMessageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateChannelMessageError {
    pub fn new(kind: UpdateChannelMessageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateChannelMessageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateChannelMessageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelMessageErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelMessageErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelMessageErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelMessageErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelMessageErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelMessageErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelMessageErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateChannelMessageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateChannelMessageErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateChannelMessageErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateChannelMessageErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateChannelMessageErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateChannelMessageErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateChannelMessageErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateChannelMessageErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateChannelMessageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateChannelReadMarkerError {
    pub kind: UpdateChannelReadMarkerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateChannelReadMarkerErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateChannelReadMarkerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateChannelReadMarkerErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateChannelReadMarkerErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateChannelReadMarkerErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateChannelReadMarkerErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateChannelReadMarkerErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateChannelReadMarkerErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateChannelReadMarkerErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdateChannelReadMarkerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateChannelReadMarkerError {
    fn code(&self) -> Option<&str> {
        UpdateChannelReadMarkerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateChannelReadMarkerError {
    pub fn new(kind: UpdateChannelReadMarkerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateChannelReadMarkerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateChannelReadMarkerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelReadMarkerErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelReadMarkerErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelReadMarkerErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelReadMarkerErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelReadMarkerErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelReadMarkerErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelReadMarkerErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateChannelReadMarkerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateChannelReadMarkerErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateChannelReadMarkerErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateChannelReadMarkerErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateChannelReadMarkerErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateChannelReadMarkerErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateChannelReadMarkerErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateChannelReadMarkerErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateChannelReadMarkerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The client is not currently authorized to make the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnauthorizedClientException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnauthorizedClientException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnauthorizedClientException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnauthorizedClientException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnauthorizedClientException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnauthorizedClientException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnauthorizedClientException {}
/// See [`UnauthorizedClientException`](crate::error::UnauthorizedClientException)
pub mod unauthorized_client_exception {
    /// A builder for [`UnauthorizedClientException`](crate::error::UnauthorizedClientException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnauthorizedClientException`](crate::error::UnauthorizedClientException)
        pub fn build(self) -> crate::error::UnauthorizedClientException {
            crate::error::UnauthorizedClientException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl UnauthorizedClientException {
    /// Creates a new builder-style object to manufacture [`UnauthorizedClientException`](crate::error::UnauthorizedClientException)
    pub fn builder() -> crate::error::unauthorized_client_exception::Builder {
        crate::error::unauthorized_client_exception::Builder::default()
    }
}

/// <p>The client exceeded its request rate limit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ThrottledClientException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ThrottledClientException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ThrottledClientException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ThrottledClientException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ThrottledClientException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottledClientException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ThrottledClientException {}
/// See [`ThrottledClientException`](crate::error::ThrottledClientException)
pub mod throttled_client_exception {
    /// A builder for [`ThrottledClientException`](crate::error::ThrottledClientException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ThrottledClientException`](crate::error::ThrottledClientException)
        pub fn build(self) -> crate::error::ThrottledClientException {
            crate::error::ThrottledClientException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ThrottledClientException {
    /// Creates a new builder-style object to manufacture [`ThrottledClientException`](crate::error::ThrottledClientException)
    pub fn builder() -> crate::error::throttled_client_exception::Builder {
        crate::error::throttled_client_exception::Builder::default()
    }
}

/// <p>The service is currently unavailable.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceUnavailableException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceUnavailableException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceUnavailableException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceUnavailableException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceUnavailableException {}
/// See [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
pub mod service_unavailable_exception {
    /// A builder for [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
        pub fn build(self) -> crate::error::ServiceUnavailableException {
            crate::error::ServiceUnavailableException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ServiceUnavailableException {
    /// Creates a new builder-style object to manufacture [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
    pub fn builder() -> crate::error::service_unavailable_exception::Builder {
        crate::error::service_unavailable_exception::Builder::default()
    }
}

/// <p>The service encountered an unexpected error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceFailureException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceFailureException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceFailureException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceFailureException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceFailureException {}
/// See [`ServiceFailureException`](crate::error::ServiceFailureException)
pub mod service_failure_exception {
    /// A builder for [`ServiceFailureException`](crate::error::ServiceFailureException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceFailureException`](crate::error::ServiceFailureException)
        pub fn build(self) -> crate::error::ServiceFailureException {
            crate::error::ServiceFailureException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ServiceFailureException {
    /// Creates a new builder-style object to manufacture [`ServiceFailureException`](crate::error::ServiceFailureException)
    pub fn builder() -> crate::error::service_failure_exception::Builder {
        crate::error::service_failure_exception::Builder::default()
    }
}

/// <p>The client is permanently forbidden from making the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ForbiddenException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ForbiddenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ForbiddenException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ForbiddenException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ForbiddenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ForbiddenException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for ForbiddenException {}
/// See [`ForbiddenException`](crate::error::ForbiddenException)
pub mod forbidden_exception {
    /// A builder for [`ForbiddenException`](crate::error::ForbiddenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ForbiddenException`](crate::error::ForbiddenException)
        pub fn build(self) -> crate::error::ForbiddenException {
            crate::error::ForbiddenException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ForbiddenException {
    /// Creates a new builder-style object to manufacture [`ForbiddenException`](crate::error::ForbiddenException)
    pub fn builder() -> crate::error::forbidden_exception::Builder {
        crate::error::forbidden_exception::Builder::default()
    }
}

/// <p>The request could not be processed because of conflict in the current state of the
/// resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// <p>The input parameters don't match the service's restrictions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BadRequestException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BadRequestException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BadRequestException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BadRequestException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for BadRequestException {}
/// See [`BadRequestException`](crate::error::BadRequestException)
pub mod bad_request_exception {
    /// A builder for [`BadRequestException`](crate::error::BadRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BadRequestException`](crate::error::BadRequestException)
        pub fn build(self) -> crate::error::BadRequestException {
            crate::error::BadRequestException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl BadRequestException {
    /// Creates a new builder-style object to manufacture [`BadRequestException`](crate::error::BadRequestException)
    pub fn builder() -> crate::error::bad_request_exception::Builder {
        crate::error::bad_request_exception::Builder::default()
    }
}

/// <p>One or more of the resources in the request does not exist in the system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotFoundException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotFoundException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotFoundException {}
/// See [`NotFoundException`](crate::error::NotFoundException)
pub mod not_found_exception {
    /// A builder for [`NotFoundException`](crate::error::NotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NotFoundException`](crate::error::NotFoundException)
        pub fn build(self) -> crate::error::NotFoundException {
            crate::error::NotFoundException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl NotFoundException {
    /// Creates a new builder-style object to manufacture [`NotFoundException`](crate::error::NotFoundException)
    pub fn builder() -> crate::error::not_found_exception::Builder {
        crate::error::not_found_exception::Builder::default()
    }
}

/// <p>The request exceeds the resource limit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceLimitExceededException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceLimitExceededException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceLimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceLimitExceededException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceLimitExceededException {}
/// See [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException)
pub mod resource_limit_exceeded_exception {
    /// A builder for [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException)
        pub fn build(self) -> crate::error::ResourceLimitExceededException {
            crate::error::ResourceLimitExceededException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ResourceLimitExceededException {
    /// Creates a new builder-style object to manufacture [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException)
    pub fn builder() -> crate::error::resource_limit_exceeded_exception::Builder {
        crate::error::resource_limit_exceeded_exception::Builder::default()
    }
}
