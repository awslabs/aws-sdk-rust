// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Activates a partner event source that has been deactivated. Once activated, your matching
/// event bus will start receiving events from the event source.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ActivateEventSource {
    _private: (),
}
impl ActivateEventSource {
    /// Creates a new builder-style object to manufacture [`ActivateEventSourceInput`](crate::input::ActivateEventSourceInput)
    pub fn builder() -> crate::input::activate_event_source_input::Builder {
        crate::input::activate_event_source_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ActivateEventSource {
    type Output = std::result::Result<
        crate::output::ActivateEventSourceOutput,
        crate::error::ActivateEventSourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_activate_event_source_error(response)
        } else {
            crate::operation_deser::parse_activate_event_source_response(response)
        }
    }
}

/// <p>Cancels the specified replay.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CancelReplay {
    _private: (),
}
impl CancelReplay {
    /// Creates a new builder-style object to manufacture [`CancelReplayInput`](crate::input::CancelReplayInput)
    pub fn builder() -> crate::input::cancel_replay_input::Builder {
        crate::input::cancel_replay_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CancelReplay {
    type Output =
        std::result::Result<crate::output::CancelReplayOutput, crate::error::CancelReplayError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_cancel_replay_error(response)
        } else {
            crate::operation_deser::parse_cancel_replay_response(response)
        }
    }
}

/// <p>Creates an API destination, which is an HTTP invocation endpoint configured as a target
/// for events.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateApiDestination {
    _private: (),
}
impl CreateApiDestination {
    /// Creates a new builder-style object to manufacture [`CreateApiDestinationInput`](crate::input::CreateApiDestinationInput)
    pub fn builder() -> crate::input::create_api_destination_input::Builder {
        crate::input::create_api_destination_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateApiDestination {
    type Output = std::result::Result<
        crate::output::CreateApiDestinationOutput,
        crate::error::CreateApiDestinationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_api_destination_error(response)
        } else {
            crate::operation_deser::parse_create_api_destination_response(response)
        }
    }
}

/// <p>Creates an archive of events with the specified settings. When you create an archive,
/// incoming events might not immediately start being sent to the archive. Allow a short period of
/// time for changes to take effect. If you do not specify a pattern to filter events sent to the
/// archive, all events are sent to the archive except replayed events. Replayed events are not
/// sent to an archive.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateArchive {
    _private: (),
}
impl CreateArchive {
    /// Creates a new builder-style object to manufacture [`CreateArchiveInput`](crate::input::CreateArchiveInput)
    pub fn builder() -> crate::input::create_archive_input::Builder {
        crate::input::create_archive_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateArchive {
    type Output =
        std::result::Result<crate::output::CreateArchiveOutput, crate::error::CreateArchiveError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_archive_error(response)
        } else {
            crate::operation_deser::parse_create_archive_response(response)
        }
    }
}

/// <p>Creates a connection. A connection defines the authorization type and credentials to use
/// for authorization with an API destination HTTP endpoint.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateConnection {
    _private: (),
}
impl CreateConnection {
    /// Creates a new builder-style object to manufacture [`CreateConnectionInput`](crate::input::CreateConnectionInput)
    pub fn builder() -> crate::input::create_connection_input::Builder {
        crate::input::create_connection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateConnection {
    type Output = std::result::Result<
        crate::output::CreateConnectionOutput,
        crate::error::CreateConnectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_connection_error(response)
        } else {
            crate::operation_deser::parse_create_connection_response(response)
        }
    }
}

/// <p>Creates a new event bus within your account. This can be a custom event bus which you can
/// use to receive events from your custom applications and services, or it can be a partner event
/// bus which can be matched to a partner event source.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateEventBus {
    _private: (),
}
impl CreateEventBus {
    /// Creates a new builder-style object to manufacture [`CreateEventBusInput`](crate::input::CreateEventBusInput)
    pub fn builder() -> crate::input::create_event_bus_input::Builder {
        crate::input::create_event_bus_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateEventBus {
    type Output =
        std::result::Result<crate::output::CreateEventBusOutput, crate::error::CreateEventBusError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_event_bus_error(response)
        } else {
            crate::operation_deser::parse_create_event_bus_response(response)
        }
    }
}

/// <p>Called by an SaaS partner to create a partner event source. This operation is not used by
/// AWS customers.</p>
/// <p>Each partner event source can be used by one AWS account to create a matching partner
/// event bus in that AWS account. A SaaS partner must create one partner event source for each
/// AWS account that wants to receive those event types. </p>
/// <p>A partner event source creates events based on resources within the SaaS partner's service
/// or application.</p>
/// <p>An AWS account that creates a partner event bus that matches the partner event source can
/// use that event bus to receive events from the partner, and then process them using AWS Events
/// rules and targets.</p>
/// <p>Partner event source names follow this format:</p>
/// <p>
/// <code>
/// <i>partner_name</i>/<i>event_namespace</i>/<i>event_name</i>
/// </code>
/// </p>
/// <p>
/// <i>partner_name</i> is determined during partner registration and identifies
/// the partner to AWS customers. <i>event_namespace</i> is determined by the
/// partner and is a way for the partner to categorize their events.
/// <i>event_name</i> is determined by the partner, and should uniquely identify
/// an event-generating resource within the partner system. The combination of
/// <i>event_namespace</i> and <i>event_name</i> should help AWS
/// customers decide whether to create an event bus to receive these events.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreatePartnerEventSource {
    _private: (),
}
impl CreatePartnerEventSource {
    /// Creates a new builder-style object to manufacture [`CreatePartnerEventSourceInput`](crate::input::CreatePartnerEventSourceInput)
    pub fn builder() -> crate::input::create_partner_event_source_input::Builder {
        crate::input::create_partner_event_source_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreatePartnerEventSource {
    type Output = std::result::Result<
        crate::output::CreatePartnerEventSourceOutput,
        crate::error::CreatePartnerEventSourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_partner_event_source_error(response)
        } else {
            crate::operation_deser::parse_create_partner_event_source_response(response)
        }
    }
}

/// <p>You can use this operation to temporarily stop receiving events from the specified partner
/// event source. The matching event bus is not deleted. </p>
/// <p>When you deactivate a partner event source, the source goes into PENDING state. If it
/// remains in PENDING state for more than two weeks, it is deleted.</p>
/// <p>To activate a deactivated partner event source, use <a>ActivateEventSource</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeactivateEventSource {
    _private: (),
}
impl DeactivateEventSource {
    /// Creates a new builder-style object to manufacture [`DeactivateEventSourceInput`](crate::input::DeactivateEventSourceInput)
    pub fn builder() -> crate::input::deactivate_event_source_input::Builder {
        crate::input::deactivate_event_source_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeactivateEventSource {
    type Output = std::result::Result<
        crate::output::DeactivateEventSourceOutput,
        crate::error::DeactivateEventSourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_deactivate_event_source_error(response)
        } else {
            crate::operation_deser::parse_deactivate_event_source_response(response)
        }
    }
}

/// <p>Removes all authorization parameters from the connection. This lets you remove the secret
/// from the connection so you can reuse it without having to create a new connection.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeauthorizeConnection {
    _private: (),
}
impl DeauthorizeConnection {
    /// Creates a new builder-style object to manufacture [`DeauthorizeConnectionInput`](crate::input::DeauthorizeConnectionInput)
    pub fn builder() -> crate::input::deauthorize_connection_input::Builder {
        crate::input::deauthorize_connection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeauthorizeConnection {
    type Output = std::result::Result<
        crate::output::DeauthorizeConnectionOutput,
        crate::error::DeauthorizeConnectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_deauthorize_connection_error(response)
        } else {
            crate::operation_deser::parse_deauthorize_connection_response(response)
        }
    }
}

/// <p>Deletes the specified API destination.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteApiDestination {
    _private: (),
}
impl DeleteApiDestination {
    /// Creates a new builder-style object to manufacture [`DeleteApiDestinationInput`](crate::input::DeleteApiDestinationInput)
    pub fn builder() -> crate::input::delete_api_destination_input::Builder {
        crate::input::delete_api_destination_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteApiDestination {
    type Output = std::result::Result<
        crate::output::DeleteApiDestinationOutput,
        crate::error::DeleteApiDestinationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_api_destination_error(response)
        } else {
            crate::operation_deser::parse_delete_api_destination_response(response)
        }
    }
}

/// <p>Deletes the specified archive.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteArchive {
    _private: (),
}
impl DeleteArchive {
    /// Creates a new builder-style object to manufacture [`DeleteArchiveInput`](crate::input::DeleteArchiveInput)
    pub fn builder() -> crate::input::delete_archive_input::Builder {
        crate::input::delete_archive_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteArchive {
    type Output =
        std::result::Result<crate::output::DeleteArchiveOutput, crate::error::DeleteArchiveError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_archive_error(response)
        } else {
            crate::operation_deser::parse_delete_archive_response(response)
        }
    }
}

/// <p>Deletes a connection.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteConnection {
    _private: (),
}
impl DeleteConnection {
    /// Creates a new builder-style object to manufacture [`DeleteConnectionInput`](crate::input::DeleteConnectionInput)
    pub fn builder() -> crate::input::delete_connection_input::Builder {
        crate::input::delete_connection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteConnection {
    type Output = std::result::Result<
        crate::output::DeleteConnectionOutput,
        crate::error::DeleteConnectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_connection_error(response)
        } else {
            crate::operation_deser::parse_delete_connection_response(response)
        }
    }
}

/// <p>Deletes the specified custom event bus or partner event bus. All rules associated with
/// this event bus need to be deleted. You can't delete your account's default event bus.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteEventBus {
    _private: (),
}
impl DeleteEventBus {
    /// Creates a new builder-style object to manufacture [`DeleteEventBusInput`](crate::input::DeleteEventBusInput)
    pub fn builder() -> crate::input::delete_event_bus_input::Builder {
        crate::input::delete_event_bus_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteEventBus {
    type Output =
        std::result::Result<crate::output::DeleteEventBusOutput, crate::error::DeleteEventBusError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_event_bus_error(response)
        } else {
            crate::operation_deser::parse_delete_event_bus_response(response)
        }
    }
}

/// <p>This operation is used by SaaS partners to delete a partner event source. This operation
/// is not used by AWS customers.</p>
/// <p>When you delete an event source, the status of the corresponding partner event bus in the
/// AWS customer account becomes DELETED.</p>
/// <p></p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeletePartnerEventSource {
    _private: (),
}
impl DeletePartnerEventSource {
    /// Creates a new builder-style object to manufacture [`DeletePartnerEventSourceInput`](crate::input::DeletePartnerEventSourceInput)
    pub fn builder() -> crate::input::delete_partner_event_source_input::Builder {
        crate::input::delete_partner_event_source_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeletePartnerEventSource {
    type Output = std::result::Result<
        crate::output::DeletePartnerEventSourceOutput,
        crate::error::DeletePartnerEventSourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_partner_event_source_error(response)
        } else {
            crate::operation_deser::parse_delete_partner_event_source_response(response)
        }
    }
}

/// <p>Deletes the specified rule.</p>
/// <p>Before you can delete the rule, you must remove all targets, using <a>RemoveTargets</a>.</p>
/// <p>When you delete a rule, incoming events might continue to match to the deleted rule. Allow
/// a short period of time for changes to take effect.</p>
/// <p>If you call delete rule multiple times for the same rule, all calls will succeed. When you
/// call delete rule for a non-existent custom eventbus, <code>ResourceNotFoundException</code> is
/// returned.</p>
/// <p>Managed rules are rules created and managed by another AWS service on your behalf. These
/// rules are created by those other AWS services to support functionality in those services. You
/// can delete these rules using the <code>Force</code> option, but you should do so only if you
/// are sure the other service is not still using that rule.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteRule {
    _private: (),
}
impl DeleteRule {
    /// Creates a new builder-style object to manufacture [`DeleteRuleInput`](crate::input::DeleteRuleInput)
    pub fn builder() -> crate::input::delete_rule_input::Builder {
        crate::input::delete_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteRule {
    type Output =
        std::result::Result<crate::output::DeleteRuleOutput, crate::error::DeleteRuleError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_rule_error(response)
        } else {
            crate::operation_deser::parse_delete_rule_response(response)
        }
    }
}

/// <p>Retrieves details about an API destination.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeApiDestination {
    _private: (),
}
impl DescribeApiDestination {
    /// Creates a new builder-style object to manufacture [`DescribeApiDestinationInput`](crate::input::DescribeApiDestinationInput)
    pub fn builder() -> crate::input::describe_api_destination_input::Builder {
        crate::input::describe_api_destination_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeApiDestination {
    type Output = std::result::Result<
        crate::output::DescribeApiDestinationOutput,
        crate::error::DescribeApiDestinationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_api_destination_error(response)
        } else {
            crate::operation_deser::parse_describe_api_destination_response(response)
        }
    }
}

/// <p>Retrieves details about an archive.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeArchive {
    _private: (),
}
impl DescribeArchive {
    /// Creates a new builder-style object to manufacture [`DescribeArchiveInput`](crate::input::DescribeArchiveInput)
    pub fn builder() -> crate::input::describe_archive_input::Builder {
        crate::input::describe_archive_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeArchive {
    type Output = std::result::Result<
        crate::output::DescribeArchiveOutput,
        crate::error::DescribeArchiveError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_archive_error(response)
        } else {
            crate::operation_deser::parse_describe_archive_response(response)
        }
    }
}

/// <p>Retrieves details about a connection.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeConnection {
    _private: (),
}
impl DescribeConnection {
    /// Creates a new builder-style object to manufacture [`DescribeConnectionInput`](crate::input::DescribeConnectionInput)
    pub fn builder() -> crate::input::describe_connection_input::Builder {
        crate::input::describe_connection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeConnection {
    type Output = std::result::Result<
        crate::output::DescribeConnectionOutput,
        crate::error::DescribeConnectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_connection_error(response)
        } else {
            crate::operation_deser::parse_describe_connection_response(response)
        }
    }
}

/// <p>Displays details about an event bus in your account. This can include the external AWS
/// accounts that are permitted to write events to your default event bus, and the associated
/// policy. For custom event buses and partner event buses, it displays the name, ARN, policy,
/// state, and creation time.</p>
/// <p> To enable your account to receive events from other accounts on its default event bus,
/// use <a>PutPermission</a>.</p>
/// <p>For more information about partner event buses, see <a>CreateEventBus</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeEventBus {
    _private: (),
}
impl DescribeEventBus {
    /// Creates a new builder-style object to manufacture [`DescribeEventBusInput`](crate::input::DescribeEventBusInput)
    pub fn builder() -> crate::input::describe_event_bus_input::Builder {
        crate::input::describe_event_bus_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeEventBus {
    type Output = std::result::Result<
        crate::output::DescribeEventBusOutput,
        crate::error::DescribeEventBusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_event_bus_error(response)
        } else {
            crate::operation_deser::parse_describe_event_bus_response(response)
        }
    }
}

/// <p>This operation lists details about a partner event source that is shared with your
/// account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeEventSource {
    _private: (),
}
impl DescribeEventSource {
    /// Creates a new builder-style object to manufacture [`DescribeEventSourceInput`](crate::input::DescribeEventSourceInput)
    pub fn builder() -> crate::input::describe_event_source_input::Builder {
        crate::input::describe_event_source_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeEventSource {
    type Output = std::result::Result<
        crate::output::DescribeEventSourceOutput,
        crate::error::DescribeEventSourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_event_source_error(response)
        } else {
            crate::operation_deser::parse_describe_event_source_response(response)
        }
    }
}

/// <p>An SaaS partner can use this operation to list details about a partner event source that
/// they have created. AWS customers do not use this operation. Instead, AWS customers can use
/// <a>DescribeEventSource</a> to see details about a partner event source that is
/// shared with them.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribePartnerEventSource {
    _private: (),
}
impl DescribePartnerEventSource {
    /// Creates a new builder-style object to manufacture [`DescribePartnerEventSourceInput`](crate::input::DescribePartnerEventSourceInput)
    pub fn builder() -> crate::input::describe_partner_event_source_input::Builder {
        crate::input::describe_partner_event_source_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribePartnerEventSource {
    type Output = std::result::Result<
        crate::output::DescribePartnerEventSourceOutput,
        crate::error::DescribePartnerEventSourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_partner_event_source_error(response)
        } else {
            crate::operation_deser::parse_describe_partner_event_source_response(response)
        }
    }
}

/// <p>Retrieves details about a replay. Use <code>DescribeReplay</code> to determine the
/// progress of a running replay. A replay processes events to replay based on the time in the
/// event, and replays them using 1 minute intervals. If you use <code>StartReplay</code> and
/// specify an <code>EventStartTime</code> and an <code>EventEndTime</code> that covers a 20
/// minute time range, the events are replayed from the first minute of that 20 minute range
/// first. Then the events from the second minute are replayed. You can use
/// <code>DescribeReplay</code> to determine the progress of a replay. The value returned for
/// <code>EventLastReplayedTime</code> indicates the time within the specified time range
/// associated with the last event replayed.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeReplay {
    _private: (),
}
impl DescribeReplay {
    /// Creates a new builder-style object to manufacture [`DescribeReplayInput`](crate::input::DescribeReplayInput)
    pub fn builder() -> crate::input::describe_replay_input::Builder {
        crate::input::describe_replay_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeReplay {
    type Output =
        std::result::Result<crate::output::DescribeReplayOutput, crate::error::DescribeReplayError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_replay_error(response)
        } else {
            crate::operation_deser::parse_describe_replay_response(response)
        }
    }
}

/// <p>Describes the specified rule.</p>
/// <p>DescribeRule does not list the targets of a rule. To see the targets associated with a
/// rule, use <a>ListTargetsByRule</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeRule {
    _private: (),
}
impl DescribeRule {
    /// Creates a new builder-style object to manufacture [`DescribeRuleInput`](crate::input::DescribeRuleInput)
    pub fn builder() -> crate::input::describe_rule_input::Builder {
        crate::input::describe_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeRule {
    type Output =
        std::result::Result<crate::output::DescribeRuleOutput, crate::error::DescribeRuleError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_rule_error(response)
        } else {
            crate::operation_deser::parse_describe_rule_response(response)
        }
    }
}

/// <p>Disables the specified rule. A disabled rule won't match any events, and won't
/// self-trigger if it has a schedule expression.</p>
/// <p>When you disable a rule, incoming events might continue to match to the disabled rule.
/// Allow a short period of time for changes to take effect.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisableRule {
    _private: (),
}
impl DisableRule {
    /// Creates a new builder-style object to manufacture [`DisableRuleInput`](crate::input::DisableRuleInput)
    pub fn builder() -> crate::input::disable_rule_input::Builder {
        crate::input::disable_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisableRule {
    type Output =
        std::result::Result<crate::output::DisableRuleOutput, crate::error::DisableRuleError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_disable_rule_error(response)
        } else {
            crate::operation_deser::parse_disable_rule_response(response)
        }
    }
}

/// <p>Enables the specified rule. If the rule does not exist, the operation fails.</p>
/// <p>When you enable a rule, incoming events might not immediately start matching to a newly
/// enabled rule. Allow a short period of time for changes to take effect.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct EnableRule {
    _private: (),
}
impl EnableRule {
    /// Creates a new builder-style object to manufacture [`EnableRuleInput`](crate::input::EnableRuleInput)
    pub fn builder() -> crate::input::enable_rule_input::Builder {
        crate::input::enable_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for EnableRule {
    type Output =
        std::result::Result<crate::output::EnableRuleOutput, crate::error::EnableRuleError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_enable_rule_error(response)
        } else {
            crate::operation_deser::parse_enable_rule_response(response)
        }
    }
}

/// <p>Retrieves a list of API destination in the account in the current Region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListApiDestinations {
    _private: (),
}
impl ListApiDestinations {
    /// Creates a new builder-style object to manufacture [`ListApiDestinationsInput`](crate::input::ListApiDestinationsInput)
    pub fn builder() -> crate::input::list_api_destinations_input::Builder {
        crate::input::list_api_destinations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListApiDestinations {
    type Output = std::result::Result<
        crate::output::ListApiDestinationsOutput,
        crate::error::ListApiDestinationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_api_destinations_error(response)
        } else {
            crate::operation_deser::parse_list_api_destinations_response(response)
        }
    }
}

/// <p>Lists your archives. You can either list all the archives or you can provide a prefix to
/// match to the archive names. Filter parameters are exclusive.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListArchives {
    _private: (),
}
impl ListArchives {
    /// Creates a new builder-style object to manufacture [`ListArchivesInput`](crate::input::ListArchivesInput)
    pub fn builder() -> crate::input::list_archives_input::Builder {
        crate::input::list_archives_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListArchives {
    type Output =
        std::result::Result<crate::output::ListArchivesOutput, crate::error::ListArchivesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_archives_error(response)
        } else {
            crate::operation_deser::parse_list_archives_response(response)
        }
    }
}

/// <p>Retrieves a list of connections from the account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListConnections {
    _private: (),
}
impl ListConnections {
    /// Creates a new builder-style object to manufacture [`ListConnectionsInput`](crate::input::ListConnectionsInput)
    pub fn builder() -> crate::input::list_connections_input::Builder {
        crate::input::list_connections_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListConnections {
    type Output = std::result::Result<
        crate::output::ListConnectionsOutput,
        crate::error::ListConnectionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_connections_error(response)
        } else {
            crate::operation_deser::parse_list_connections_response(response)
        }
    }
}

/// <p>Lists all the event buses in your account, including the default event bus, custom event
/// buses, and partner event buses.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListEventBuses {
    _private: (),
}
impl ListEventBuses {
    /// Creates a new builder-style object to manufacture [`ListEventBusesInput`](crate::input::ListEventBusesInput)
    pub fn builder() -> crate::input::list_event_buses_input::Builder {
        crate::input::list_event_buses_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListEventBuses {
    type Output =
        std::result::Result<crate::output::ListEventBusesOutput, crate::error::ListEventBusesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_event_buses_error(response)
        } else {
            crate::operation_deser::parse_list_event_buses_response(response)
        }
    }
}

/// <p>You can use this to see all the partner event sources that have been shared with your AWS
/// account. For more information about partner event sources, see <a>CreateEventBus</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListEventSources {
    _private: (),
}
impl ListEventSources {
    /// Creates a new builder-style object to manufacture [`ListEventSourcesInput`](crate::input::ListEventSourcesInput)
    pub fn builder() -> crate::input::list_event_sources_input::Builder {
        crate::input::list_event_sources_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListEventSources {
    type Output = std::result::Result<
        crate::output::ListEventSourcesOutput,
        crate::error::ListEventSourcesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_event_sources_error(response)
        } else {
            crate::operation_deser::parse_list_event_sources_response(response)
        }
    }
}

/// <p>An SaaS partner can use this operation to display the AWS account ID that a particular
/// partner event source name is associated with. This operation is not used by AWS
/// customers.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListPartnerEventSourceAccounts {
    _private: (),
}
impl ListPartnerEventSourceAccounts {
    /// Creates a new builder-style object to manufacture [`ListPartnerEventSourceAccountsInput`](crate::input::ListPartnerEventSourceAccountsInput)
    pub fn builder() -> crate::input::list_partner_event_source_accounts_input::Builder {
        crate::input::list_partner_event_source_accounts_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListPartnerEventSourceAccounts {
    type Output = std::result::Result<
        crate::output::ListPartnerEventSourceAccountsOutput,
        crate::error::ListPartnerEventSourceAccountsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_partner_event_source_accounts_error(response)
        } else {
            crate::operation_deser::parse_list_partner_event_source_accounts_response(response)
        }
    }
}

/// <p>An SaaS partner can use this operation to list all the partner event source names that
/// they have created. This operation is not used by AWS customers.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListPartnerEventSources {
    _private: (),
}
impl ListPartnerEventSources {
    /// Creates a new builder-style object to manufacture [`ListPartnerEventSourcesInput`](crate::input::ListPartnerEventSourcesInput)
    pub fn builder() -> crate::input::list_partner_event_sources_input::Builder {
        crate::input::list_partner_event_sources_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListPartnerEventSources {
    type Output = std::result::Result<
        crate::output::ListPartnerEventSourcesOutput,
        crate::error::ListPartnerEventSourcesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_partner_event_sources_error(response)
        } else {
            crate::operation_deser::parse_list_partner_event_sources_response(response)
        }
    }
}

/// <p>Lists your replays. You can either list all the replays or you can provide a prefix to
/// match to the replay names. Filter parameters are exclusive.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListReplays {
    _private: (),
}
impl ListReplays {
    /// Creates a new builder-style object to manufacture [`ListReplaysInput`](crate::input::ListReplaysInput)
    pub fn builder() -> crate::input::list_replays_input::Builder {
        crate::input::list_replays_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListReplays {
    type Output =
        std::result::Result<crate::output::ListReplaysOutput, crate::error::ListReplaysError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_replays_error(response)
        } else {
            crate::operation_deser::parse_list_replays_response(response)
        }
    }
}

/// <p>Lists the rules for the specified target. You can see which of the rules in Amazon
/// EventBridge can invoke a specific target in your account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListRuleNamesByTarget {
    _private: (),
}
impl ListRuleNamesByTarget {
    /// Creates a new builder-style object to manufacture [`ListRuleNamesByTargetInput`](crate::input::ListRuleNamesByTargetInput)
    pub fn builder() -> crate::input::list_rule_names_by_target_input::Builder {
        crate::input::list_rule_names_by_target_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListRuleNamesByTarget {
    type Output = std::result::Result<
        crate::output::ListRuleNamesByTargetOutput,
        crate::error::ListRuleNamesByTargetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_rule_names_by_target_error(response)
        } else {
            crate::operation_deser::parse_list_rule_names_by_target_response(response)
        }
    }
}

/// <p>Lists your Amazon EventBridge rules. You can either list all the rules or you can provide
/// a prefix to match to the rule names.</p>
/// <p>ListRules does not list the targets of a rule. To see the targets associated with a rule,
/// use <a>ListTargetsByRule</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListRules {
    _private: (),
}
impl ListRules {
    /// Creates a new builder-style object to manufacture [`ListRulesInput`](crate::input::ListRulesInput)
    pub fn builder() -> crate::input::list_rules_input::Builder {
        crate::input::list_rules_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListRules {
    type Output = std::result::Result<crate::output::ListRulesOutput, crate::error::ListRulesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_rules_error(response)
        } else {
            crate::operation_deser::parse_list_rules_response(response)
        }
    }
}

/// <p>Displays the tags associated with an EventBridge resource. In EventBridge, rules and event
/// buses can be tagged.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Lists the targets assigned to the specified rule.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTargetsByRule {
    _private: (),
}
impl ListTargetsByRule {
    /// Creates a new builder-style object to manufacture [`ListTargetsByRuleInput`](crate::input::ListTargetsByRuleInput)
    pub fn builder() -> crate::input::list_targets_by_rule_input::Builder {
        crate::input::list_targets_by_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTargetsByRule {
    type Output = std::result::Result<
        crate::output::ListTargetsByRuleOutput,
        crate::error::ListTargetsByRuleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_targets_by_rule_error(response)
        } else {
            crate::operation_deser::parse_list_targets_by_rule_response(response)
        }
    }
}

/// <p>Sends custom events to Amazon EventBridge so that they can be matched to rules.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutEvents {
    _private: (),
}
impl PutEvents {
    /// Creates a new builder-style object to manufacture [`PutEventsInput`](crate::input::PutEventsInput)
    pub fn builder() -> crate::input::put_events_input::Builder {
        crate::input::put_events_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutEvents {
    type Output = std::result::Result<crate::output::PutEventsOutput, crate::error::PutEventsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_events_error(response)
        } else {
            crate::operation_deser::parse_put_events_response(response)
        }
    }
}

/// <p>This is used by SaaS partners to write events to a customer's partner event bus. AWS
/// customers do not use this operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutPartnerEvents {
    _private: (),
}
impl PutPartnerEvents {
    /// Creates a new builder-style object to manufacture [`PutPartnerEventsInput`](crate::input::PutPartnerEventsInput)
    pub fn builder() -> crate::input::put_partner_events_input::Builder {
        crate::input::put_partner_events_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutPartnerEvents {
    type Output = std::result::Result<
        crate::output::PutPartnerEventsOutput,
        crate::error::PutPartnerEventsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_partner_events_error(response)
        } else {
            crate::operation_deser::parse_put_partner_events_response(response)
        }
    }
}

/// <p>Running <code>PutPermission</code> permits the specified AWS account or AWS organization
/// to put events to the specified <i>event bus</i>. Amazon EventBridge (CloudWatch
/// Events) rules in your account are triggered by these events arriving to an event bus in your
/// account. </p>
/// <p>For another account to send events to your account, that external account must have an
/// EventBridge rule with your account's event bus as a target.</p>
/// <p>To enable multiple AWS accounts to put events to your event bus, run
/// <code>PutPermission</code> once for each of these accounts. Or, if all the accounts are
/// members of the same AWS organization, you can run <code>PutPermission</code> once specifying
/// <code>Principal</code> as "*" and specifying the AWS organization ID in
/// <code>Condition</code>, to grant permissions to all accounts in that organization.</p>
/// <p>If you grant permissions using an organization, then accounts in that organization must
/// specify a <code>RoleArn</code> with proper permissions when they use <code>PutTarget</code> to
/// add your account's event bus as a target. For more information, see <a href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eventbridge-cross-account-event-delivery.html">Sending and
/// Receiving Events Between AWS Accounts</a> in the <i>Amazon EventBridge User
/// Guide</i>.</p>
/// <p>The permission policy on the default event bus cannot exceed 10 KB in size.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutPermission {
    _private: (),
}
impl PutPermission {
    /// Creates a new builder-style object to manufacture [`PutPermissionInput`](crate::input::PutPermissionInput)
    pub fn builder() -> crate::input::put_permission_input::Builder {
        crate::input::put_permission_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutPermission {
    type Output =
        std::result::Result<crate::output::PutPermissionOutput, crate::error::PutPermissionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_permission_error(response)
        } else {
            crate::operation_deser::parse_put_permission_response(response)
        }
    }
}

/// <p>Creates or updates the specified rule. Rules are enabled by default, or based on value of
/// the state. You can disable a rule using <a>DisableRule</a>.</p>
/// <p>A single rule watches for events from a single event bus. Events generated by AWS services
/// go to your account's default event bus. Events generated by SaaS partner services or
/// applications go to the matching partner event bus. If you have custom applications or
/// services, you can specify whether their events go to your default event bus or a custom event
/// bus that you have created. For more information, see <a>CreateEventBus</a>.</p>
/// <p>If you are updating an existing rule, the rule is replaced with what you specify in this
/// <code>PutRule</code> command. If you omit arguments in <code>PutRule</code>, the old values
/// for those arguments are not kept. Instead, they are replaced with null values.</p>
/// <p>When you create or update a rule, incoming events might not immediately start matching to
/// new or updated rules. Allow a short period of time for changes to take effect.</p>
/// <p>A rule must contain at least an EventPattern or ScheduleExpression. Rules with
/// EventPatterns are triggered when a matching event is observed. Rules with ScheduleExpressions
/// self-trigger based on the given schedule. A rule can have both an EventPattern and a
/// ScheduleExpression, in which case the rule triggers on matching events as well as on a
/// schedule.</p>
/// <p>When you initially create a rule, you can optionally assign one or more tags to the rule.
/// Tags can help you organize and categorize your resources. You can also use them to scope user
/// permissions, by granting a user permission to access or change only rules with certain tag
/// values. To use the <code>PutRule</code> operation and assign tags, you must have both the
/// <code>events:PutRule</code> and <code>events:TagResource</code> permissions.</p>
/// <p>If you are updating an existing rule, any tags you specify in the <code>PutRule</code>
/// operation are ignored. To update the tags of an existing rule, use <a>TagResource</a> and <a>UntagResource</a>.</p>
/// <p>Most services in AWS treat : or / as the same character in Amazon Resource Names (ARNs).
/// However, EventBridge uses an exact match in event patterns and rules. Be sure to use the
/// correct ARN characters when creating event patterns so that they match the ARN syntax in the
/// event you want to match.</p>
/// <p>In EventBridge, it is possible to create rules that lead to infinite loops, where a rule
/// is fired repeatedly. For example, a rule might detect that ACLs have changed on an S3 bucket,
/// and trigger software to change them to the desired state. If the rule is not written
/// carefully, the subsequent change to the ACLs fires the rule again, creating an infinite
/// loop.</p>
/// <p>To prevent this, write the rules so that the triggered actions do not re-fire the same
/// rule. For example, your rule could fire only if ACLs are found to be in a bad state, instead
/// of after any change. </p>
/// <p>An infinite loop can quickly cause higher than expected charges. We recommend that you use
/// budgeting, which alerts you when charges exceed your specified limit. For more information,
/// see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/budgets-managing-costs.html">Managing Your Costs with
/// Budgets</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutRule {
    _private: (),
}
impl PutRule {
    /// Creates a new builder-style object to manufacture [`PutRuleInput`](crate::input::PutRuleInput)
    pub fn builder() -> crate::input::put_rule_input::Builder {
        crate::input::put_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutRule {
    type Output = std::result::Result<crate::output::PutRuleOutput, crate::error::PutRuleError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_rule_error(response)
        } else {
            crate::operation_deser::parse_put_rule_response(response)
        }
    }
}

/// <p>Adds the specified targets to the specified rule, or updates the targets if they are
/// already associated with the rule.</p>
/// <p>Targets are the resources that are invoked when a rule is triggered.</p>
/// <p>You can configure the following as targets for Events:</p>
/// <ul>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-api-destinations.html">API
/// destination</a>
/// </p>
/// </li>
/// <li>
/// <p>Amazon API Gateway REST API endpoints</p>
/// </li>
/// <li>
/// <p>API Gateway</p>
/// </li>
/// <li>
/// <p>AWS Batch job queue</p>
/// </li>
/// <li>
/// <p>CloudWatch Logs group</p>
/// </li>
/// <li>
/// <p>CodeBuild project</p>
/// </li>
/// <li>
/// <p>CodePineline</p>
/// </li>
/// <li>
/// <p>Amazon EC2 <code>CreateSnapshot</code> API call</p>
/// </li>
/// <li>
/// <p>Amazon EC2 <code>RebootInstances</code> API call</p>
/// </li>
/// <li>
/// <p>Amazon EC2 <code>StopInstances</code> API call</p>
/// </li>
/// <li>
/// <p>Amazon EC2 <code>TerminateInstances</code> API call</p>
/// </li>
/// <li>
/// <p>Amazon ECS tasks</p>
/// </li>
/// <li>
/// <p>Event bus in a different AWS account or Region.</p>
/// <p>You can use an event bus in the US East (N. Virginia) us-east-1, US West (Oregon)
/// us-west-2, or Europe (Ireland) eu-west-1 Regions as a target for a rule.</p>
/// </li>
/// <li>
/// <p>Firehose delivery stream (Kinesis Data Firehose)</p>
/// </li>
/// <li>
/// <p>Inspector assessment template (Amazon Inspector)</p>
/// </li>
/// <li>
/// <p>Kinesis stream (Kinesis Data Stream)</p>
/// </li>
/// <li>
/// <p>AWS Lambda function</p>
/// </li>
/// <li>
/// <p>Redshift clusters (Data API statement execution)</p>
/// </li>
/// <li>
/// <p>Amazon SNS topic</p>
/// </li>
/// <li>
/// <p>Amazon SQS queues (includes FIFO queues</p>
/// </li>
/// <li>
/// <p>SSM Automation</p>
/// </li>
/// <li>
/// <p>SSM OpsItem</p>
/// </li>
/// <li>
/// <p>SSM Run Command</p>
/// </li>
/// <li>
/// <p>Step Functions state machines</p>
/// </li>
/// </ul>
/// <p>Creating rules with built-in targets is supported only in the AWS Management Console. The
/// built-in targets are <code>EC2 CreateSnapshot API call</code>, <code>EC2 RebootInstances API
/// call</code>, <code>EC2 StopInstances API call</code>, and <code>EC2 TerminateInstances API
/// call</code>. </p>
/// <p>For some target types, <code>PutTargets</code> provides target-specific parameters. If the
/// target is a Kinesis data stream, you can optionally specify which shard the event goes to by
/// using the <code>KinesisParameters</code> argument. To invoke a command on multiple EC2
/// instances with one rule, you can use the <code>RunCommandParameters</code> field.</p>
/// <p>To be able to make API calls against the resources that you own, Amazon EventBridge
/// (CloudWatch Events) needs the appropriate permissions. For AWS Lambda and Amazon SNS
/// resources, EventBridge relies on resource-based policies. For EC2 instances, Kinesis data
/// streams, AWS Step Functions state machines and API Gateway REST APIs, EventBridge relies on
/// IAM roles that you specify in the <code>RoleARN</code> argument in <code>PutTargets</code>.
/// For more information, see <a href="https://docs.aws.amazon.com/eventbridge/latest/userguide/auth-and-access-control-eventbridge.html">Authentication
/// and Access Control</a> in the <i>Amazon EventBridge User Guide</i>.</p>
/// <p>If another AWS account is in the same region and has granted you permission (using
/// <code>PutPermission</code>), you can send events to that account. Set that account's event
/// bus as a target of the rules in your account. To send the matched events to the other account,
/// specify that account's event bus as the <code>Arn</code> value when you run
/// <code>PutTargets</code>. If your account sends events to another account, your account is
/// charged for each sent event. Each event sent to another account is charged as a custom event.
/// The account receiving the event is not charged. For more information, see <a href="https://aws.amazon.com/eventbridge/pricing/">Amazon EventBridge (CloudWatch Events)
/// Pricing</a>.</p>
/// <note>
/// <p>
/// <code>Input</code>, <code>InputPath</code>, and <code>InputTransformer</code> are not
/// available with <code>PutTarget</code> if the target is an event bus of a different AWS
/// account.</p>
/// </note>
/// <p>If you are setting the event bus of another account as the target, and that account
/// granted permission to your account through an organization instead of directly by the account
/// ID, then you must specify a <code>RoleArn</code> with proper permissions in the
/// <code>Target</code> structure. For more information, see <a href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eventbridge-cross-account-event-delivery.html">Sending and
/// Receiving Events Between AWS Accounts</a> in the <i>Amazon EventBridge User
/// Guide</i>.</p>
/// <p>For more information about enabling cross-account events, see <a>PutPermission</a>.</p>
/// <p>
/// <b>Input</b>, <b>InputPath</b>, and
/// <b>InputTransformer</b> are mutually exclusive and optional
/// parameters of a target. When a rule is triggered due to a matched event:</p>
/// <ul>
/// <li>
/// <p>If none of the following arguments are specified for a target, then the entire event
/// is passed to the target in JSON format (unless the target is Amazon EC2 Run Command or
/// Amazon ECS task, in which case nothing from the event is passed to the target).</p>
/// </li>
/// <li>
/// <p>If <b>Input</b> is specified in the form of valid JSON, then
/// the matched event is overridden with this constant.</p>
/// </li>
/// <li>
/// <p>If <b>InputPath</b> is specified in the form of JSONPath
/// (for example, <code>$.detail</code>), then only the part of the event specified in the
/// path is passed to the target (for example, only the detail part of the event is
/// passed).</p>
/// </li>
/// <li>
/// <p>If <b>InputTransformer</b> is specified, then one or more
/// specified JSONPaths are extracted from the event and used as values in a template that you
/// specify as the input to the target.</p>
/// </li>
/// </ul>
/// <p>When you specify <code>InputPath</code> or <code>InputTransformer</code>, you must use
/// JSON dot notation, not bracket notation.</p>
/// <p>When you add targets to a rule and the associated rule triggers soon after, new or updated
/// targets might not be immediately invoked. Allow a short period of time for changes to take
/// effect.</p>
/// <p>This action can partially fail if too many requests are made at the same time. If that
/// happens, <code>FailedEntryCount</code> is non-zero in the response and each entry in
/// <code>FailedEntries</code> provides the ID of the failed target and the error code.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutTargets {
    _private: (),
}
impl PutTargets {
    /// Creates a new builder-style object to manufacture [`PutTargetsInput`](crate::input::PutTargetsInput)
    pub fn builder() -> crate::input::put_targets_input::Builder {
        crate::input::put_targets_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutTargets {
    type Output =
        std::result::Result<crate::output::PutTargetsOutput, crate::error::PutTargetsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_targets_error(response)
        } else {
            crate::operation_deser::parse_put_targets_response(response)
        }
    }
}

/// <p>Revokes the permission of another AWS account to be able to put events to the specified
/// event bus. Specify the account to revoke by the <code>StatementId</code> value that you
/// associated with the account when you granted it permission with <code>PutPermission</code>.
/// You can find the <code>StatementId</code> by using <a>DescribeEventBus</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RemovePermission {
    _private: (),
}
impl RemovePermission {
    /// Creates a new builder-style object to manufacture [`RemovePermissionInput`](crate::input::RemovePermissionInput)
    pub fn builder() -> crate::input::remove_permission_input::Builder {
        crate::input::remove_permission_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RemovePermission {
    type Output = std::result::Result<
        crate::output::RemovePermissionOutput,
        crate::error::RemovePermissionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_remove_permission_error(response)
        } else {
            crate::operation_deser::parse_remove_permission_response(response)
        }
    }
}

/// <p>Removes the specified targets from the specified rule. When the rule is triggered, those
/// targets are no longer be invoked.</p>
/// <p>When you remove a target, when the associated rule triggers, removed targets might
/// continue to be invoked. Allow a short period of time for changes to take effect.</p>
/// <p>This action can partially fail if too many requests are made at the same time. If that
/// happens, <code>FailedEntryCount</code> is non-zero in the response and each entry in
/// <code>FailedEntries</code> provides the ID of the failed target and the error code.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RemoveTargets {
    _private: (),
}
impl RemoveTargets {
    /// Creates a new builder-style object to manufacture [`RemoveTargetsInput`](crate::input::RemoveTargetsInput)
    pub fn builder() -> crate::input::remove_targets_input::Builder {
        crate::input::remove_targets_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RemoveTargets {
    type Output =
        std::result::Result<crate::output::RemoveTargetsOutput, crate::error::RemoveTargetsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_remove_targets_error(response)
        } else {
            crate::operation_deser::parse_remove_targets_response(response)
        }
    }
}

/// <p>Starts the specified replay. Events are not necessarily replayed in the exact same order
/// that they were added to the archive. A replay processes events to replay based on the time in
/// the event, and replays them using 1 minute intervals. If you specify an
/// <code>EventStartTime</code> and an <code>EventEndTime</code> that covers a 20 minute time
/// range, the events are replayed from the first minute of that 20 minute range first. Then the
/// events from the second minute are replayed. You can use <code>DescribeReplay</code> to
/// determine the progress of a replay. The value returned for <code>EventLastReplayedTime</code>
/// indicates the time within the specified time range associated with the last event
/// replayed.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartReplay {
    _private: (),
}
impl StartReplay {
    /// Creates a new builder-style object to manufacture [`StartReplayInput`](crate::input::StartReplayInput)
    pub fn builder() -> crate::input::start_replay_input::Builder {
        crate::input::start_replay_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartReplay {
    type Output =
        std::result::Result<crate::output::StartReplayOutput, crate::error::StartReplayError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_replay_error(response)
        } else {
            crate::operation_deser::parse_start_replay_response(response)
        }
    }
}

/// <p>Assigns one or more tags (key-value pairs) to the specified EventBridge resource. Tags can
/// help you organize and categorize your resources. You can also use them to scope user
/// permissions by granting a user permission to access or change only resources with certain tag
/// values. In EventBridge, rules and event buses can be tagged.</p>
/// <p>Tags don't have any semantic meaning to AWS and are interpreted strictly as strings of
/// characters.</p>
/// <p>You can use the <code>TagResource</code> action with a resource that already has tags. If
/// you specify a new tag key, this tag is appended to the list of tags associated with the
/// resource. If you specify a tag key that is already associated with the resource, the new tag
/// value that you specify replaces the previous value for that tag.</p>
/// <p>You can associate as many as 50 tags with a resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Tests whether the specified event pattern matches the provided event.</p>
/// <p>Most services in AWS treat : or / as the same character in Amazon Resource Names (ARNs).
/// However, EventBridge uses an exact match in event patterns and rules. Be sure to use the
/// correct ARN characters when creating event patterns so that they match the ARN syntax in the
/// event you want to match.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TestEventPattern {
    _private: (),
}
impl TestEventPattern {
    /// Creates a new builder-style object to manufacture [`TestEventPatternInput`](crate::input::TestEventPatternInput)
    pub fn builder() -> crate::input::test_event_pattern_input::Builder {
        crate::input::test_event_pattern_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TestEventPattern {
    type Output = std::result::Result<
        crate::output::TestEventPatternOutput,
        crate::error::TestEventPatternError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_test_event_pattern_error(response)
        } else {
            crate::operation_deser::parse_test_event_pattern_response(response)
        }
    }
}

/// <p>Removes one or more tags from the specified EventBridge resource. In Amazon EventBridge
/// (CloudWatch Events), rules and event buses can be tagged.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Updates an API destination.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateApiDestination {
    _private: (),
}
impl UpdateApiDestination {
    /// Creates a new builder-style object to manufacture [`UpdateApiDestinationInput`](crate::input::UpdateApiDestinationInput)
    pub fn builder() -> crate::input::update_api_destination_input::Builder {
        crate::input::update_api_destination_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateApiDestination {
    type Output = std::result::Result<
        crate::output::UpdateApiDestinationOutput,
        crate::error::UpdateApiDestinationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_api_destination_error(response)
        } else {
            crate::operation_deser::parse_update_api_destination_response(response)
        }
    }
}

/// <p>Updates the specified archive.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateArchive {
    _private: (),
}
impl UpdateArchive {
    /// Creates a new builder-style object to manufacture [`UpdateArchiveInput`](crate::input::UpdateArchiveInput)
    pub fn builder() -> crate::input::update_archive_input::Builder {
        crate::input::update_archive_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateArchive {
    type Output =
        std::result::Result<crate::output::UpdateArchiveOutput, crate::error::UpdateArchiveError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_archive_error(response)
        } else {
            crate::operation_deser::parse_update_archive_response(response)
        }
    }
}

/// <p>Updates settings for a connection.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateConnection {
    _private: (),
}
impl UpdateConnection {
    /// Creates a new builder-style object to manufacture [`UpdateConnectionInput`](crate::input::UpdateConnectionInput)
    pub fn builder() -> crate::input::update_connection_input::Builder {
        crate::input::update_connection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateConnection {
    type Output = std::result::Result<
        crate::output::UpdateConnectionOutput,
        crate::error::UpdateConnectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_connection_error(response)
        } else {
            crate::operation_deser::parse_update_connection_response(response)
        }
    }
}
