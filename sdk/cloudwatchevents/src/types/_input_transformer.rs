// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Contains the parameters needed for you to provide custom input to a target based on one or more pieces of data extracted from the event.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InputTransformer  {
    /// <p>Map of JSON paths to be extracted from the event. You can then insert these in the template in <code>InputTemplate</code> to produce the output you want to be sent to the target.</p> 
    /// <p> <code>InputPathsMap</code> is an array key-value pairs, where each value is a valid JSON path. You can have as many as 100 key-value pairs. You must use JSON dot notation, not bracket notation.</p> 
    /// <p>The keys cannot start with "Amazon Web Services." </p>
    #[doc(hidden)]
    pub input_paths_map: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Input template where you specify placeholders that will be filled with the values of the keys from <code>InputPathsMap</code> to customize the data sent to the target. Enclose each <code>InputPathsMaps</code> value in brackets: &lt;<i>value</i>&gt; The InputTemplate must be valid JSON.</p> 
    /// <p>If <code>InputTemplate</code> is a JSON object (surrounded by curly braces), the following restrictions apply:</p> 
    /// <ul> 
    /// <li> <p>The placeholder cannot be used as an object key.</p> </li> 
    /// </ul> 
    /// <p>The following example shows the syntax for using <code>InputPathsMap</code> and <code>InputTemplate</code>.</p> 
    /// <p> <code> "InputTransformer":</code> </p> 
    /// <p> <code>{</code> </p> 
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p> 
    /// <p> <code>"InputTemplate": "
    /// <instance>
    /// is in state 
    /// <status>
    /// "
    /// </status>
    /// </instance></code> </p> 
    /// <p> <code>}</code> </p> 
    /// <p>To have the <code>InputTemplate</code> include quote marks within a JSON string, escape each quote marks with a slash, as in the following example:</p> 
    /// <p> <code> "InputTransformer":</code> </p> 
    /// <p> <code>{</code> </p> 
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p> 
    /// <p> <code>"InputTemplate": "
    /// <instance>
    /// is in state \"
    /// <status>
    /// \""
    /// </status>
    /// </instance></code> </p> 
    /// <p> <code>}</code> </p> 
    /// <p>The <code>InputTemplate</code> can also be valid JSON with varibles in quotes or out, as in the following example:</p> 
    /// <p> <code> "InputTransformer":</code> </p> 
    /// <p> <code>{</code> </p> 
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p> 
    /// <p> <code>"InputTemplate": '{"myInstance": 
    /// <instance>
    /// ,"myStatus": "
    /// <instance>
    /// is in state \"
    /// <status>
    /// \""}'
    /// </status>
    /// </instance>
    /// </instance></code> </p> 
    /// <p> <code>}</code> </p>
    #[doc(hidden)]
    pub input_template: std::option::Option<std::string::String>,
}
impl InputTransformer {
    /// <p>Map of JSON paths to be extracted from the event. You can then insert these in the template in <code>InputTemplate</code> to produce the output you want to be sent to the target.</p> 
    /// <p> <code>InputPathsMap</code> is an array key-value pairs, where each value is a valid JSON path. You can have as many as 100 key-value pairs. You must use JSON dot notation, not bracket notation.</p> 
    /// <p>The keys cannot start with "Amazon Web Services." </p>
    pub fn input_paths_map(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.input_paths_map.as_ref()
    }
    /// <p>Input template where you specify placeholders that will be filled with the values of the keys from <code>InputPathsMap</code> to customize the data sent to the target. Enclose each <code>InputPathsMaps</code> value in brackets: &lt;<i>value</i>&gt; The InputTemplate must be valid JSON.</p> 
    /// <p>If <code>InputTemplate</code> is a JSON object (surrounded by curly braces), the following restrictions apply:</p> 
    /// <ul> 
    /// <li> <p>The placeholder cannot be used as an object key.</p> </li> 
    /// </ul> 
    /// <p>The following example shows the syntax for using <code>InputPathsMap</code> and <code>InputTemplate</code>.</p> 
    /// <p> <code> "InputTransformer":</code> </p> 
    /// <p> <code>{</code> </p> 
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p> 
    /// <p> <code>"InputTemplate": "
    /// <instance>
    /// is in state 
    /// <status>
    /// "
    /// </status>
    /// </instance></code> </p> 
    /// <p> <code>}</code> </p> 
    /// <p>To have the <code>InputTemplate</code> include quote marks within a JSON string, escape each quote marks with a slash, as in the following example:</p> 
    /// <p> <code> "InputTransformer":</code> </p> 
    /// <p> <code>{</code> </p> 
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p> 
    /// <p> <code>"InputTemplate": "
    /// <instance>
    /// is in state \"
    /// <status>
    /// \""
    /// </status>
    /// </instance></code> </p> 
    /// <p> <code>}</code> </p> 
    /// <p>The <code>InputTemplate</code> can also be valid JSON with varibles in quotes or out, as in the following example:</p> 
    /// <p> <code> "InputTransformer":</code> </p> 
    /// <p> <code>{</code> </p> 
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p> 
    /// <p> <code>"InputTemplate": '{"myInstance": 
    /// <instance>
    /// ,"myStatus": "
    /// <instance>
    /// is in state \"
    /// <status>
    /// \""}'
    /// </status>
    /// </instance>
    /// </instance></code> </p> 
    /// <p> <code>}</code> </p>
    pub fn input_template(&self) -> std::option::Option<& str> {
        self.input_template.as_deref()
    }
}
impl InputTransformer {
    /// Creates a new builder-style object to manufacture [`InputTransformer`](crate::types::InputTransformer).
    pub fn builder() -> crate::types::builders::InputTransformerBuilder {
        crate::types::builders::InputTransformerBuilder::default()
    }
}

/// A builder for [`InputTransformer`](crate::types::InputTransformer).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct InputTransformerBuilder {
    pub(crate) input_paths_map: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    pub(crate) input_template: std::option::Option<std::string::String>,
}
impl InputTransformerBuilder {
    /// Adds a key-value pair to `input_paths_map`.
    ///
    /// To override the contents of this collection use [`set_input_paths_map`](Self::set_input_paths_map).
    ///
    /// <p>Map of JSON paths to be extracted from the event. You can then insert these in the template in <code>InputTemplate</code> to produce the output you want to be sent to the target.</p> 
    /// <p> <code>InputPathsMap</code> is an array key-value pairs, where each value is a valid JSON path. You can have as many as 100 key-value pairs. You must use JSON dot notation, not bracket notation.</p> 
    /// <p>The keys cannot start with "Amazon Web Services." </p>
    pub fn input_paths_map(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
        let mut hash_map = self.input_paths_map.unwrap_or_default();
                        hash_map.insert(k.into(), v.into());
                        self.input_paths_map = Some(hash_map);
                        self
    }
    /// <p>Map of JSON paths to be extracted from the event. You can then insert these in the template in <code>InputTemplate</code> to produce the output you want to be sent to the target.</p> 
    /// <p> <code>InputPathsMap</code> is an array key-value pairs, where each value is a valid JSON path. You can have as many as 100 key-value pairs. You must use JSON dot notation, not bracket notation.</p> 
    /// <p>The keys cannot start with "Amazon Web Services." </p>
    pub fn set_input_paths_map(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
        self.input_paths_map = input; self
    }
    /// <p>Input template where you specify placeholders that will be filled with the values of the keys from <code>InputPathsMap</code> to customize the data sent to the target. Enclose each <code>InputPathsMaps</code> value in brackets: &lt;<i>value</i>&gt; The InputTemplate must be valid JSON.</p> 
    /// <p>If <code>InputTemplate</code> is a JSON object (surrounded by curly braces), the following restrictions apply:</p> 
    /// <ul> 
    /// <li> <p>The placeholder cannot be used as an object key.</p> </li> 
    /// </ul> 
    /// <p>The following example shows the syntax for using <code>InputPathsMap</code> and <code>InputTemplate</code>.</p> 
    /// <p> <code> "InputTransformer":</code> </p> 
    /// <p> <code>{</code> </p> 
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p> 
    /// <p> <code>"InputTemplate": "
    /// <instance>
    /// is in state 
    /// <status>
    /// "
    /// </status>
    /// </instance></code> </p> 
    /// <p> <code>}</code> </p> 
    /// <p>To have the <code>InputTemplate</code> include quote marks within a JSON string, escape each quote marks with a slash, as in the following example:</p> 
    /// <p> <code> "InputTransformer":</code> </p> 
    /// <p> <code>{</code> </p> 
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p> 
    /// <p> <code>"InputTemplate": "
    /// <instance>
    /// is in state \"
    /// <status>
    /// \""
    /// </status>
    /// </instance></code> </p> 
    /// <p> <code>}</code> </p> 
    /// <p>The <code>InputTemplate</code> can also be valid JSON with varibles in quotes or out, as in the following example:</p> 
    /// <p> <code> "InputTransformer":</code> </p> 
    /// <p> <code>{</code> </p> 
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p> 
    /// <p> <code>"InputTemplate": '{"myInstance": 
    /// <instance>
    /// ,"myStatus": "
    /// <instance>
    /// is in state \"
    /// <status>
    /// \""}'
    /// </status>
    /// </instance>
    /// </instance></code> </p> 
    /// <p> <code>}</code> </p>
    pub fn input_template(mut self, input: impl Into<std::string::String>) -> Self {
        self.input_template = Some(input.into());
        self
    }
    /// <p>Input template where you specify placeholders that will be filled with the values of the keys from <code>InputPathsMap</code> to customize the data sent to the target. Enclose each <code>InputPathsMaps</code> value in brackets: &lt;<i>value</i>&gt; The InputTemplate must be valid JSON.</p> 
    /// <p>If <code>InputTemplate</code> is a JSON object (surrounded by curly braces), the following restrictions apply:</p> 
    /// <ul> 
    /// <li> <p>The placeholder cannot be used as an object key.</p> </li> 
    /// </ul> 
    /// <p>The following example shows the syntax for using <code>InputPathsMap</code> and <code>InputTemplate</code>.</p> 
    /// <p> <code> "InputTransformer":</code> </p> 
    /// <p> <code>{</code> </p> 
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p> 
    /// <p> <code>"InputTemplate": "
    /// <instance>
    /// is in state 
    /// <status>
    /// "
    /// </status>
    /// </instance></code> </p> 
    /// <p> <code>}</code> </p> 
    /// <p>To have the <code>InputTemplate</code> include quote marks within a JSON string, escape each quote marks with a slash, as in the following example:</p> 
    /// <p> <code> "InputTransformer":</code> </p> 
    /// <p> <code>{</code> </p> 
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p> 
    /// <p> <code>"InputTemplate": "
    /// <instance>
    /// is in state \"
    /// <status>
    /// \""
    /// </status>
    /// </instance></code> </p> 
    /// <p> <code>}</code> </p> 
    /// <p>The <code>InputTemplate</code> can also be valid JSON with varibles in quotes or out, as in the following example:</p> 
    /// <p> <code> "InputTransformer":</code> </p> 
    /// <p> <code>{</code> </p> 
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p> 
    /// <p> <code>"InputTemplate": '{"myInstance": 
    /// <instance>
    /// ,"myStatus": "
    /// <instance>
    /// is in state \"
    /// <status>
    /// \""}'
    /// </status>
    /// </instance>
    /// </instance></code> </p> 
    /// <p> <code>}</code> </p>
    pub fn set_input_template(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.input_template = input; self
    }
    /// Consumes the builder and constructs a [`InputTransformer`](crate::types::InputTransformer).
    pub fn build(self) -> crate::types::InputTransformer {
        crate::types::InputTransformer {
            input_paths_map: self.input_paths_map
            ,
            input_template: self.input_template
            ,
        }
    }
}

