// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(Debug)]
pub(crate) struct Handle<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    client: smithy_client::Client<C, M, R>,
    conf: crate::Config,
}

/// An ergonomic service client for `CertificateManager`.
///
/// This client allows ergonomic access to a `CertificateManager`-shaped service.
/// Each method corresponds to an endpoint defined in the service's Smithy model,
/// and the request and response shapes are auto-generated from that same model.
///
/// # Using a Client
///
/// Once you have a client set up, you can access the service's endpoints
/// by calling the appropriate method on [`Client`]. Each such method
/// returns a request builder for that endpoint, with methods for setting
/// the various fields of the request. Once your request is complete, use
/// the `send` method to send the request. `send` returns a future, which
/// you then have to `.await` to get the service's response.
///
/// [builder pattern]: https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder
/// [SigV4-signed requests]: https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html
#[derive(std::fmt::Debug)]
pub struct Client<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    handle: std::sync::Arc<Handle<C, M, R>>,
}

impl<C, M, R> std::clone::Clone for Client<C, M, R> {
    fn clone(&self) -> Self {
        Self {
            handle: self.handle.clone(),
        }
    }
}

#[doc(inline)]
pub use smithy_client::Builder;

impl<C, M, R> From<smithy_client::Client<C, M, R>> for Client<C, M, R> {
    fn from(client: smithy_client::Client<C, M, R>) -> Self {
        Self::with_config(client, crate::Config::builder().build())
    }
}

impl<C, M, R> Client<C, M, R> {
    pub fn with_config(client: smithy_client::Client<C, M, R>, conf: crate::Config) -> Self {
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl<C, M, R> Client<C, M, R>
where
    C: smithy_client::bounds::SmithyConnector,
    M: smithy_client::bounds::SmithyMiddleware<C>,
    R: smithy_client::retry::NewRequestPolicy,
{
    pub fn add_tags_to_certificate(&self) -> fluent_builders::AddTagsToCertificate<C, M, R> {
        fluent_builders::AddTagsToCertificate::new(self.handle.clone())
    }
    pub fn delete_certificate(&self) -> fluent_builders::DeleteCertificate<C, M, R> {
        fluent_builders::DeleteCertificate::new(self.handle.clone())
    }
    pub fn describe_certificate(&self) -> fluent_builders::DescribeCertificate<C, M, R> {
        fluent_builders::DescribeCertificate::new(self.handle.clone())
    }
    pub fn export_certificate(&self) -> fluent_builders::ExportCertificate<C, M, R> {
        fluent_builders::ExportCertificate::new(self.handle.clone())
    }
    pub fn get_account_configuration(&self) -> fluent_builders::GetAccountConfiguration<C, M, R> {
        fluent_builders::GetAccountConfiguration::new(self.handle.clone())
    }
    pub fn get_certificate(&self) -> fluent_builders::GetCertificate<C, M, R> {
        fluent_builders::GetCertificate::new(self.handle.clone())
    }
    pub fn import_certificate(&self) -> fluent_builders::ImportCertificate<C, M, R> {
        fluent_builders::ImportCertificate::new(self.handle.clone())
    }
    pub fn list_certificates(&self) -> fluent_builders::ListCertificates<C, M, R> {
        fluent_builders::ListCertificates::new(self.handle.clone())
    }
    pub fn list_tags_for_certificate(&self) -> fluent_builders::ListTagsForCertificate<C, M, R> {
        fluent_builders::ListTagsForCertificate::new(self.handle.clone())
    }
    pub fn put_account_configuration(&self) -> fluent_builders::PutAccountConfiguration<C, M, R> {
        fluent_builders::PutAccountConfiguration::new(self.handle.clone())
    }
    pub fn remove_tags_from_certificate(
        &self,
    ) -> fluent_builders::RemoveTagsFromCertificate<C, M, R> {
        fluent_builders::RemoveTagsFromCertificate::new(self.handle.clone())
    }
    pub fn renew_certificate(&self) -> fluent_builders::RenewCertificate<C, M, R> {
        fluent_builders::RenewCertificate::new(self.handle.clone())
    }
    pub fn request_certificate(&self) -> fluent_builders::RequestCertificate<C, M, R> {
        fluent_builders::RequestCertificate::new(self.handle.clone())
    }
    pub fn resend_validation_email(&self) -> fluent_builders::ResendValidationEmail<C, M, R> {
        fluent_builders::ResendValidationEmail::new(self.handle.clone())
    }
    pub fn update_certificate_options(&self) -> fluent_builders::UpdateCertificateOptions<C, M, R> {
        fluent_builders::UpdateCertificateOptions::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AddTagsToCertificate<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::add_tags_to_certificate_input::Builder,
    }
    impl<C, M, R> AddTagsToCertificate<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddTagsToCertificateOutput,
            smithy_http::result::SdkError<crate::error::AddTagsToCertificateError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::AddTagsToCertificateInputOperationOutputAlias,
                crate::output::AddTagsToCertificateOutput,
                crate::error::AddTagsToCertificateError,
                crate::input::AddTagsToCertificateInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>String that contains the ARN of the ACM certificate to which the tag is to be applied.
        /// This must be of the form:</p>
        /// <p>
        /// <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a>.</p>
        pub fn certificate_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(inp);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The key-value pair that defines the tag. The tag value is optional.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteCertificate<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_certificate_input::Builder,
    }
    impl<C, M, R> DeleteCertificate<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteCertificateOutput,
            smithy_http::result::SdkError<crate::error::DeleteCertificateError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteCertificateInputOperationOutputAlias,
                crate::output::DeleteCertificateOutput,
                crate::error::DeleteCertificateError,
                crate::input::DeleteCertificateInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>String that contains the ARN of the ACM certificate to be deleted. This must be of the
        /// form:</p>
        /// <p>
        /// <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a>.</p>
        pub fn certificate_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(inp);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeCertificate<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_certificate_input::Builder,
    }
    impl<C, M, R> DescribeCertificate<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeCertificateOutput,
            smithy_http::result::SdkError<crate::error::DescribeCertificateError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeCertificateInputOperationOutputAlias,
                crate::output::DescribeCertificateOutput,
                crate::error::DescribeCertificateError,
                crate::input::DescribeCertificateInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the ACM certificate. The ARN must have the following
        /// form:</p>
        /// <p>
        /// <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a>.</p>
        pub fn certificate_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(inp);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ExportCertificate<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::export_certificate_input::Builder,
    }
    impl<C, M, R> ExportCertificate<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ExportCertificateOutput,
            smithy_http::result::SdkError<crate::error::ExportCertificateError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ExportCertificateInputOperationOutputAlias,
                crate::output::ExportCertificateOutput,
                crate::error::ExportCertificateError,
                crate::input::ExportCertificateInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An Amazon Resource Name (ARN) of the issued certificate. This must be of the form:</p>
        /// <p>
        /// <code>arn:aws:acm:region:account:certificate/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        pub fn certificate_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(inp);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
        /// <p>Passphrase to associate with the encrypted exported private key. If you want to later
        /// decrypt the private key, you must have the passphrase. You can use the following OpenSSL
        /// command to decrypt a private key: </p>
        /// <p>
        /// <code>openssl rsa -in encrypted_key.pem -out decrypted_key.pem</code>
        /// </p>
        pub fn passphrase(mut self, inp: smithy_types::Blob) -> Self {
            self.inner = self.inner.passphrase(inp);
            self
        }
        pub fn set_passphrase(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_passphrase(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAccountConfiguration<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_account_configuration_input::Builder,
    }
    impl<C, M, R> GetAccountConfiguration<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetAccountConfigurationOutput,
            smithy_http::result::SdkError<crate::error::GetAccountConfigurationError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetAccountConfigurationInputOperationOutputAlias,
                crate::output::GetAccountConfigurationOutput,
                crate::error::GetAccountConfigurationError,
                crate::input::GetAccountConfigurationInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCertificate<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_certificate_input::Builder,
    }
    impl<C, M, R> GetCertificate<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCertificateOutput,
            smithy_http::result::SdkError<crate::error::GetCertificateError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetCertificateInputOperationOutputAlias,
                crate::output::GetCertificateOutput,
                crate::error::GetCertificateError,
                crate::input::GetCertificateInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>String that contains a certificate ARN in the following format:</p>
        /// <p>
        /// <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a>.</p>
        pub fn certificate_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(inp);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ImportCertificate<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::import_certificate_input::Builder,
    }
    impl<C, M, R> ImportCertificate<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ImportCertificateOutput,
            smithy_http::result::SdkError<crate::error::ImportCertificateError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ImportCertificateInputOperationOutputAlias,
                crate::output::ImportCertificateOutput,
                crate::error::ImportCertificateError,
                crate::input::ImportCertificateInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Name
        /// (ARN)</a> of an imported certificate to replace. To import a new certificate, omit this
        /// field. </p>
        pub fn certificate_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(inp);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
        /// <p>The certificate to import.</p>
        pub fn certificate(mut self, inp: smithy_types::Blob) -> Self {
            self.inner = self.inner.certificate(inp);
            self
        }
        pub fn set_certificate(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_certificate(input);
            self
        }
        /// <p>The private key that matches the public key in the certificate.</p>
        pub fn private_key(mut self, inp: smithy_types::Blob) -> Self {
            self.inner = self.inner.private_key(inp);
            self
        }
        pub fn set_private_key(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_private_key(input);
            self
        }
        /// <p>The PEM encoded certificate chain.</p>
        pub fn certificate_chain(mut self, inp: smithy_types::Blob) -> Self {
            self.inner = self.inner.certificate_chain(inp);
            self
        }
        pub fn set_certificate_chain(
            mut self,
            input: std::option::Option<smithy_types::Blob>,
        ) -> Self {
            self.inner = self.inner.set_certificate_chain(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>One or more resource tags to associate with the imported certificate. </p>
        /// <p>Note: You cannot apply tags when reimporting a certificate.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListCertificates<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_certificates_input::Builder,
    }
    impl<C, M, R> ListCertificates<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListCertificatesOutput,
            smithy_http::result::SdkError<crate::error::ListCertificatesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListCertificatesInputOperationOutputAlias,
                crate::output::ListCertificatesOutput,
                crate::error::ListCertificatesError,
                crate::input::ListCertificatesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Appends an item to `CertificateStatuses`.
        ///
        /// To override the contents of this collection use [`set_certificate_statuses`](Self::set_certificate_statuses).
        /// <p>Filter the certificate list by status value.</p>
        pub fn certificate_statuses(
            mut self,
            inp: impl Into<crate::model::CertificateStatus>,
        ) -> Self {
            self.inner = self.inner.certificate_statuses(inp);
            self
        }
        pub fn set_certificate_statuses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CertificateStatus>>,
        ) -> Self {
            self.inner = self.inner.set_certificate_statuses(input);
            self
        }
        /// <p>Filter the certificate list. For more information, see the <a>Filters</a>
        /// structure.</p>
        pub fn includes(mut self, inp: crate::model::Filters) -> Self {
            self.inner = self.inner.includes(inp);
            self
        }
        pub fn set_includes(mut self, input: std::option::Option<crate::model::Filters>) -> Self {
            self.inner = self.inner.set_includes(input);
            self
        }
        /// <p>Use this parameter only when paginating results and only in a subsequent request after you
        /// receive a response with truncated results. Set it to the value of <code>NextToken</code> from
        /// the response you just received.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Use this parameter when paginating results to specify the maximum number of items to
        /// return in the response. If additional items exist beyond the number you specify, the
        /// <code>NextToken</code> element is sent in the response. Use this <code>NextToken</code>
        /// value in a subsequent request to retrieve additional items.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForCertificate<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_tags_for_certificate_input::Builder,
    }
    impl<C, M, R> ListTagsForCertificate<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForCertificateOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForCertificateError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListTagsForCertificateInputOperationOutputAlias,
                crate::output::ListTagsForCertificateOutput,
                crate::error::ListTagsForCertificateError,
                crate::input::ListTagsForCertificateInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>String that contains the ARN of the ACM certificate for which you want to list the tags.
        /// This must have the following form:</p>
        /// <p>
        /// <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a>.</p>
        pub fn certificate_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(inp);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutAccountConfiguration<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::put_account_configuration_input::Builder,
    }
    impl<C, M, R> PutAccountConfiguration<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutAccountConfigurationOutput,
            smithy_http::result::SdkError<crate::error::PutAccountConfigurationError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::PutAccountConfigurationInputOperationOutputAlias,
                crate::output::PutAccountConfigurationOutput,
                crate::error::PutAccountConfigurationError,
                crate::input::PutAccountConfigurationInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies expiration
        /// events associated with an account.</p>
        pub fn expiry_events(mut self, inp: crate::model::ExpiryEventsConfiguration) -> Self {
            self.inner = self.inner.expiry_events(inp);
            self
        }
        pub fn set_expiry_events(
            mut self,
            input: std::option::Option<crate::model::ExpiryEventsConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_expiry_events(input);
            self
        }
        /// <p>Customer-chosen string
        /// used to distinguish between calls to <code>PutAccountConfiguration</code>. Idempotency tokens
        /// time out after one hour. If you call <code>PutAccountConfiguration</code> multiple times with
        /// the same unexpired idempotency token, ACM treats it as the same request and returns the
        /// original result. If you change the idempotency token for each call, ACM treats each call as
        /// a new request.</p>
        pub fn idempotency_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.idempotency_token(inp);
            self
        }
        pub fn set_idempotency_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_idempotency_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveTagsFromCertificate<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::remove_tags_from_certificate_input::Builder,
    }
    impl<C, M, R> RemoveTagsFromCertificate<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RemoveTagsFromCertificateOutput,
            smithy_http::result::SdkError<crate::error::RemoveTagsFromCertificateError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RemoveTagsFromCertificateInputOperationOutputAlias,
                crate::output::RemoveTagsFromCertificateOutput,
                crate::error::RemoveTagsFromCertificateError,
                crate::input::RemoveTagsFromCertificateInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>String that contains the ARN of the ACM Certificate with one or more tags that you want
        /// to remove. This must be of the form:</p>
        /// <p>
        /// <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a>.</p>
        pub fn certificate_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(inp);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The key-value pair that defines the tag to remove.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RenewCertificate<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::renew_certificate_input::Builder,
    }
    impl<C, M, R> RenewCertificate<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RenewCertificateOutput,
            smithy_http::result::SdkError<crate::error::RenewCertificateError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RenewCertificateInputOperationOutputAlias,
                crate::output::RenewCertificateOutput,
                crate::error::RenewCertificateError,
                crate::input::RenewCertificateInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>String that contains the ARN of the ACM certificate to be renewed. This must be of the
        /// form:</p>
        /// <p>
        /// <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a>.</p>
        pub fn certificate_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(inp);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RequestCertificate<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::request_certificate_input::Builder,
    }
    impl<C, M, R> RequestCertificate<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RequestCertificateOutput,
            smithy_http::result::SdkError<crate::error::RequestCertificateError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RequestCertificateInputOperationOutputAlias,
                crate::output::RequestCertificateOutput,
                crate::error::RequestCertificateError,
                crate::input::RequestCertificateInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> Fully qualified domain name (FQDN), such as www.example.com, that you want to secure with
        /// an ACM certificate. Use an asterisk (*) to create a wildcard certificate that protects
        /// several sites in the same domain. For example, *.example.com protects www.example.com,
        /// site.example.com, and images.example.com. </p>
        /// <p> The first domain name you enter cannot exceed 64 octets, including periods. Each
        /// subsequent Subject Alternative Name (SAN), however, can be up to 253 octets in length. </p>
        pub fn domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(inp);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>The method you want to use if you are requesting a public certificate to validate that you
        /// own or control domain. You can <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-validate-dns.html">validate with DNS</a> or <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-validate-email.html">validate with
        /// email</a>. We recommend that you use DNS validation. </p>
        pub fn validation_method(mut self, inp: crate::model::ValidationMethod) -> Self {
            self.inner = self.inner.validation_method(inp);
            self
        }
        pub fn set_validation_method(
            mut self,
            input: std::option::Option<crate::model::ValidationMethod>,
        ) -> Self {
            self.inner = self.inner.set_validation_method(input);
            self
        }
        /// Appends an item to `SubjectAlternativeNames`.
        ///
        /// To override the contents of this collection use [`set_subject_alternative_names`](Self::set_subject_alternative_names).
        /// <p>Additional FQDNs to be included in the Subject Alternative Name extension of the ACM
        /// certificate. For example, add the name www.example.net to a certificate for which the
        /// <code>DomainName</code> field is www.example.com if users can reach your site by using
        /// either name. The maximum number of domain names that you can add to an ACM certificate is
        /// 100. However, the initial quota is 10 domain names. If you need more than 10 names, you must
        /// request a quota increase. For more information, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-limits.html">Quotas</a>.</p>
        /// <p> The maximum length of a SAN DNS name is 253 octets. The name is made up of multiple
        /// labels separated by periods. No label can be longer than 63 octets. Consider the following
        /// examples: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>(63 octets).(63 octets).(63 octets).(61 octets)</code> is legal because the
        /// total length is 253 octets (63+1+63+1+63+1+61) and no label exceeds 63 octets.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>(64 octets).(63 octets).(63 octets).(61 octets)</code> is not legal because the
        /// total length exceeds 253 octets (64+1+63+1+63+1+61) and the first label exceeds 63
        /// octets.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>(63 octets).(63 octets).(63 octets).(62 octets)</code> is not legal because the
        /// total length of the DNS name (63+1+63+1+63+1+62) exceeds 253 octets.</p>
        /// </li>
        /// </ul>
        pub fn subject_alternative_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subject_alternative_names(inp);
            self
        }
        pub fn set_subject_alternative_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subject_alternative_names(input);
            self
        }
        /// <p>Customer chosen string that can be used to distinguish between calls to
        /// <code>RequestCertificate</code>. Idempotency tokens time out after one hour. Therefore, if
        /// you call <code>RequestCertificate</code> multiple times with the same idempotency token within
        /// one hour, ACM recognizes that you are requesting only one certificate and will issue only
        /// one. If you change the idempotency token for each call, ACM recognizes that you are
        /// requesting multiple certificates.</p>
        pub fn idempotency_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.idempotency_token(inp);
            self
        }
        pub fn set_idempotency_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_idempotency_token(input);
            self
        }
        /// Appends an item to `DomainValidationOptions`.
        ///
        /// To override the contents of this collection use [`set_domain_validation_options`](Self::set_domain_validation_options).
        /// <p>The domain name that you want ACM to use to send you emails so that you can validate
        /// domain ownership.</p>
        pub fn domain_validation_options(
            mut self,
            inp: impl Into<crate::model::DomainValidationOption>,
        ) -> Self {
            self.inner = self.inner.domain_validation_options(inp);
            self
        }
        pub fn set_domain_validation_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DomainValidationOption>>,
        ) -> Self {
            self.inner = self.inner.set_domain_validation_options(input);
            self
        }
        /// <p>Currently, you can use this parameter to specify whether to add the certificate to a
        /// certificate transparency log. Certificate transparency makes it possible to detect SSL/TLS
        /// certificates that have been mistakenly or maliciously issued. Certificates that have not been
        /// logged typically produce an error message in a browser. For more information, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-bestpractices.html#best-practices-transparency">Opting Out of Certificate Transparency Logging</a>.</p>
        pub fn options(mut self, inp: crate::model::CertificateOptions) -> Self {
            self.inner = self.inner.options(inp);
            self
        }
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::CertificateOptions>,
        ) -> Self {
            self.inner = self.inner.set_options(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the private certificate authority (CA) that will be used
        /// to issue the certificate. If you do not provide an ARN and you are trying to request a private
        /// certificate, ACM will attempt to issue a public certificate. For more information about
        /// private CAs, see the <a href="https://docs.aws.amazon.com/acm-pca/latest/userguide/PcaWelcome.html">Amazon Web Services Certificate Manager Private Certificate Authority (PCA)</a> user guide. The ARN must have the following form: </p>
        /// <p>
        /// <code>arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        pub fn certificate_authority_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_authority_arn(inp);
            self
        }
        pub fn set_certificate_authority_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_authority_arn(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>One or more resource tags to associate with the certificate.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ResendValidationEmail<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::resend_validation_email_input::Builder,
    }
    impl<C, M, R> ResendValidationEmail<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ResendValidationEmailOutput,
            smithy_http::result::SdkError<crate::error::ResendValidationEmailError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ResendValidationEmailInputOperationOutputAlias,
                crate::output::ResendValidationEmailOutput,
                crate::error::ResendValidationEmailError,
                crate::input::ResendValidationEmailInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>String that contains the ARN of the requested certificate. The certificate ARN is
        /// generated and returned by the <a>RequestCertificate</a> action as soon as the
        /// request is made. By default, using this parameter causes email to be sent to all top-level
        /// domains you specified in the certificate request. The ARN must be of the form: </p>
        /// <p>
        /// <code>arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        pub fn certificate_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(inp);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
        /// <p>The fully qualified domain name (FQDN) of the certificate that needs to be
        /// validated.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The base validation domain that will act as the suffix of the email addresses that are
        /// used to send the emails. This must be the same as the <code>Domain</code> value or a
        /// superdomain of the <code>Domain</code> value. For example, if you requested a certificate for
        /// <code>site.subdomain.example.com</code> and specify a <b>ValidationDomain</b> of <code>subdomain.example.com</code>, ACM sends email to the
        /// domain registrant, technical contact, and administrative contact in WHOIS and the following
        /// five addresses:</p>
        /// <ul>
        /// <li>
        /// <p>admin@subdomain.example.com</p>
        /// </li>
        /// <li>
        /// <p>administrator@subdomain.example.com</p>
        /// </li>
        /// <li>
        /// <p>hostmaster@subdomain.example.com</p>
        /// </li>
        /// <li>
        /// <p>postmaster@subdomain.example.com</p>
        /// </li>
        /// <li>
        /// <p>webmaster@subdomain.example.com</p>
        /// </li>
        /// </ul>
        pub fn validation_domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.validation_domain(inp);
            self
        }
        pub fn set_validation_domain(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_validation_domain(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateCertificateOptions<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_certificate_options_input::Builder,
    }
    impl<C, M, R> UpdateCertificateOptions<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateCertificateOptionsOutput,
            smithy_http::result::SdkError<crate::error::UpdateCertificateOptionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateCertificateOptionsInputOperationOutputAlias,
                crate::output::UpdateCertificateOptionsOutput,
                crate::error::UpdateCertificateOptionsError,
                crate::input::UpdateCertificateOptionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>ARN of the requested certificate to update. This must be of the form:</p>
        /// <p>
        /// <code>arn:aws:acm:us-east-1:<i>account</i>:certificate/<i>12345678-1234-1234-1234-123456789012</i>
        /// </code>
        /// </p>
        pub fn certificate_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(inp);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
        /// <p>Use to update the options for your certificate. Currently, you can specify whether to add
        /// your certificate to a transparency log. Certificate transparency makes it possible to detect
        /// SSL/TLS certificates that have been mistakenly or maliciously issued. Certificates that have
        /// not been logged typically produce an error message in a browser. </p>
        pub fn options(mut self, inp: crate::model::CertificateOptions) -> Self {
            self.inner = self.inner.options(inp);
            self
        }
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::CertificateOptions>,
        ) -> Self {
            self.inner = self.inner.set_options(input);
            self
        }
    }
}
impl<C> Client<C, aws_hyper::AwsMiddleware, smithy_client::retry::Standard> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let retry_config = conf.retry_config.as_ref().cloned().unwrap_or_default();
        let client = aws_hyper::Client::new(conn).with_retry_config(retry_config.into());
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl
    Client<
        smithy_client::erase::DynConnector,
        aws_hyper::AwsMiddleware,
        smithy_client::retry::Standard,
    >
{
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn new(config: &aws_types::config::Config) -> Self {
        Self::from_conf(config.into())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let retry_config = conf.retry_config.as_ref().cloned().unwrap_or_default();
        let client = aws_hyper::Client::https().with_retry_config(retry_config.into());
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
