// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn add_tags_to_certificate(&self) -> fluent_builders::AddTagsToCertificate<C> {
        fluent_builders::AddTagsToCertificate::new(self.handle.clone())
    }
    pub fn delete_certificate(&self) -> fluent_builders::DeleteCertificate<C> {
        fluent_builders::DeleteCertificate::new(self.handle.clone())
    }
    pub fn describe_certificate(&self) -> fluent_builders::DescribeCertificate<C> {
        fluent_builders::DescribeCertificate::new(self.handle.clone())
    }
    pub fn export_certificate(&self) -> fluent_builders::ExportCertificate<C> {
        fluent_builders::ExportCertificate::new(self.handle.clone())
    }
    pub fn get_account_configuration(&self) -> fluent_builders::GetAccountConfiguration<C> {
        fluent_builders::GetAccountConfiguration::new(self.handle.clone())
    }
    pub fn get_certificate(&self) -> fluent_builders::GetCertificate<C> {
        fluent_builders::GetCertificate::new(self.handle.clone())
    }
    pub fn import_certificate(&self) -> fluent_builders::ImportCertificate<C> {
        fluent_builders::ImportCertificate::new(self.handle.clone())
    }
    pub fn list_certificates(&self) -> fluent_builders::ListCertificates<C> {
        fluent_builders::ListCertificates::new(self.handle.clone())
    }
    pub fn list_tags_for_certificate(&self) -> fluent_builders::ListTagsForCertificate<C> {
        fluent_builders::ListTagsForCertificate::new(self.handle.clone())
    }
    pub fn put_account_configuration(&self) -> fluent_builders::PutAccountConfiguration<C> {
        fluent_builders::PutAccountConfiguration::new(self.handle.clone())
    }
    pub fn remove_tags_from_certificate(&self) -> fluent_builders::RemoveTagsFromCertificate<C> {
        fluent_builders::RemoveTagsFromCertificate::new(self.handle.clone())
    }
    pub fn renew_certificate(&self) -> fluent_builders::RenewCertificate<C> {
        fluent_builders::RenewCertificate::new(self.handle.clone())
    }
    pub fn request_certificate(&self) -> fluent_builders::RequestCertificate<C> {
        fluent_builders::RequestCertificate::new(self.handle.clone())
    }
    pub fn resend_validation_email(&self) -> fluent_builders::ResendValidationEmail<C> {
        fluent_builders::ResendValidationEmail::new(self.handle.clone())
    }
    pub fn update_certificate_options(&self) -> fluent_builders::UpdateCertificateOptions<C> {
        fluent_builders::UpdateCertificateOptions::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AddTagsToCertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_tags_to_certificate_input::Builder,
    }
    impl<C> AddTagsToCertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddTagsToCertificateOutput,
            smithy_http::result::SdkError<crate::error::AddTagsToCertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>String that contains the ARN of the ACM certificate to which the tag is to be applied.
        /// This must be of the form:</p>
        /// <p>
        /// <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a>.</p>
        pub fn certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(input);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
        /// <p>The key-value pair that defines the tag. The tag value is optional.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteCertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_certificate_input::Builder,
    }
    impl<C> DeleteCertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteCertificateOutput,
            smithy_http::result::SdkError<crate::error::DeleteCertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>String that contains the ARN of the ACM certificate to be deleted. This must be of the
        /// form:</p>
        /// <p>
        /// <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a>.</p>
        pub fn certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(input);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeCertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_certificate_input::Builder,
    }
    impl<C> DescribeCertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeCertificateOutput,
            smithy_http::result::SdkError<crate::error::DescribeCertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the ACM certificate. The ARN must have the following
        /// form:</p>
        /// <p>
        /// <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a>.</p>
        pub fn certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(input);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ExportCertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::export_certificate_input::Builder,
    }
    impl<C> ExportCertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ExportCertificateOutput,
            smithy_http::result::SdkError<crate::error::ExportCertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An Amazon Resource Name (ARN) of the issued certificate. This must be of the form:</p>
        /// <p>
        /// <code>arn:aws:acm:region:account:certificate/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        pub fn certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(input);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
        /// <p>Passphrase to associate with the encrypted exported private key. If you want to later
        /// decrypt the private key, you must have the passphrase. You can use the following OpenSSL
        /// command to decrypt a private key: </p>
        /// <p>
        /// <code>openssl rsa -in encrypted_key.pem -out decrypted_key.pem</code>
        /// </p>
        pub fn passphrase(mut self, input: smithy_types::Blob) -> Self {
            self.inner = self.inner.passphrase(input);
            self
        }
        pub fn set_passphrase(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_passphrase(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAccountConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_account_configuration_input::Builder,
    }
    impl<C> GetAccountConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetAccountConfigurationOutput,
            smithy_http::result::SdkError<crate::error::GetAccountConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_certificate_input::Builder,
    }
    impl<C> GetCertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCertificateOutput,
            smithy_http::result::SdkError<crate::error::GetCertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>String that contains a certificate ARN in the following format:</p>
        /// <p>
        /// <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a>.</p>
        pub fn certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(input);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ImportCertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::import_certificate_input::Builder,
    }
    impl<C> ImportCertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ImportCertificateOutput,
            smithy_http::result::SdkError<crate::error::ImportCertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Name
        /// (ARN)</a> of an imported certificate to replace. To import a new certificate, omit this
        /// field. </p>
        pub fn certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(input);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
        /// <p>The certificate to import.</p>
        pub fn certificate(mut self, input: smithy_types::Blob) -> Self {
            self.inner = self.inner.certificate(input);
            self
        }
        pub fn set_certificate(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_certificate(input);
            self
        }
        /// <p>The private key that matches the public key in the certificate.</p>
        pub fn private_key(mut self, input: smithy_types::Blob) -> Self {
            self.inner = self.inner.private_key(input);
            self
        }
        pub fn set_private_key(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_private_key(input);
            self
        }
        /// <p>The PEM encoded certificate chain.</p>
        pub fn certificate_chain(mut self, input: smithy_types::Blob) -> Self {
            self.inner = self.inner.certificate_chain(input);
            self
        }
        pub fn set_certificate_chain(
            mut self,
            input: std::option::Option<smithy_types::Blob>,
        ) -> Self {
            self.inner = self.inner.set_certificate_chain(input);
            self
        }
        /// <p>One or more resource tags to associate with the imported certificate. </p>
        /// <p>Note: You cannot apply tags when reimporting a certificate.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListCertificates<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_certificates_input::Builder,
    }
    impl<C> ListCertificates<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListCertificatesOutput,
            smithy_http::result::SdkError<crate::error::ListCertificatesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Filter the certificate list by status value.</p>
        pub fn certificate_statuses(
            mut self,
            inp: impl Into<crate::model::CertificateStatus>,
        ) -> Self {
            self.inner = self.inner.certificate_statuses(inp);
            self
        }
        pub fn set_certificate_statuses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CertificateStatus>>,
        ) -> Self {
            self.inner = self.inner.set_certificate_statuses(input);
            self
        }
        /// <p>Filter the certificate list. For more information, see the <a>Filters</a>
        /// structure.</p>
        pub fn includes(mut self, input: crate::model::Filters) -> Self {
            self.inner = self.inner.includes(input);
            self
        }
        pub fn set_includes(mut self, input: std::option::Option<crate::model::Filters>) -> Self {
            self.inner = self.inner.set_includes(input);
            self
        }
        /// <p>Use this parameter only when paginating results and only in a subsequent request after you
        /// receive a response with truncated results. Set it to the value of <code>NextToken</code> from
        /// the response you just received.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Use this parameter when paginating results to specify the maximum number of items to
        /// return in the response. If additional items exist beyond the number you specify, the
        /// <code>NextToken</code> element is sent in the response. Use this <code>NextToken</code>
        /// value in a subsequent request to retrieve additional items.</p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForCertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_certificate_input::Builder,
    }
    impl<C> ListTagsForCertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForCertificateOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForCertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>String that contains the ARN of the ACM certificate for which you want to list the tags.
        /// This must have the following form:</p>
        /// <p>
        /// <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a>.</p>
        pub fn certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(input);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutAccountConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_account_configuration_input::Builder,
    }
    impl<C> PutAccountConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutAccountConfigurationOutput,
            smithy_http::result::SdkError<crate::error::PutAccountConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies expiration
        /// events associated with an account.</p>
        pub fn expiry_events(mut self, input: crate::model::ExpiryEventsConfiguration) -> Self {
            self.inner = self.inner.expiry_events(input);
            self
        }
        pub fn set_expiry_events(
            mut self,
            input: std::option::Option<crate::model::ExpiryEventsConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_expiry_events(input);
            self
        }
        /// <p>Customer-chosen string
        /// used to distinguish between calls to <code>PutAccountConfiguration</code>. Idempotency tokens
        /// time out after one hour. If you call <code>PutAccountConfiguration</code> multiple times with
        /// the same unexpired idempotency token, ACM treats it as the same request and returns the
        /// original result. If you change the idempotency token for each call, ACM treats each call as
        /// a new request.</p>
        pub fn idempotency_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.idempotency_token(input);
            self
        }
        pub fn set_idempotency_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_idempotency_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveTagsFromCertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::remove_tags_from_certificate_input::Builder,
    }
    impl<C> RemoveTagsFromCertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RemoveTagsFromCertificateOutput,
            smithy_http::result::SdkError<crate::error::RemoveTagsFromCertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>String that contains the ARN of the ACM Certificate with one or more tags that you want
        /// to remove. This must be of the form:</p>
        /// <p>
        /// <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a>.</p>
        pub fn certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(input);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
        /// <p>The key-value pair that defines the tag to remove.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RenewCertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::renew_certificate_input::Builder,
    }
    impl<C> RenewCertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RenewCertificateOutput,
            smithy_http::result::SdkError<crate::error::RenewCertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>String that contains the ARN of the ACM certificate to be renewed. This must be of the
        /// form:</p>
        /// <p>
        /// <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a>.</p>
        pub fn certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(input);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RequestCertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::request_certificate_input::Builder,
    }
    impl<C> RequestCertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RequestCertificateOutput,
            smithy_http::result::SdkError<crate::error::RequestCertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> Fully qualified domain name (FQDN), such as www.example.com, that you want to secure with
        /// an ACM certificate. Use an asterisk (*) to create a wildcard certificate that protects
        /// several sites in the same domain. For example, *.example.com protects www.example.com,
        /// site.example.com, and images.example.com. </p>
        /// <p> The first domain name you enter cannot exceed 64 octets, including periods. Each
        /// subsequent Subject Alternative Name (SAN), however, can be up to 253 octets in length. </p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>The method you want to use if you are requesting a public certificate to validate that you
        /// own or control domain. You can <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-validate-dns.html">validate with DNS</a> or <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-validate-email.html">validate with
        /// email</a>. We recommend that you use DNS validation. </p>
        pub fn validation_method(mut self, input: crate::model::ValidationMethod) -> Self {
            self.inner = self.inner.validation_method(input);
            self
        }
        pub fn set_validation_method(
            mut self,
            input: std::option::Option<crate::model::ValidationMethod>,
        ) -> Self {
            self.inner = self.inner.set_validation_method(input);
            self
        }
        /// <p>Additional FQDNs to be included in the Subject Alternative Name extension of the ACM
        /// certificate. For example, add the name www.example.net to a certificate for which the
        /// <code>DomainName</code> field is www.example.com if users can reach your site by using
        /// either name. The maximum number of domain names that you can add to an ACM certificate is
        /// 100. However, the initial quota is 10 domain names. If you need more than 10 names, you must
        /// request a quota increase. For more information, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-limits.html">Quotas</a>.</p>
        /// <p> The maximum length of a SAN DNS name is 253 octets. The name is made up of multiple
        /// labels separated by periods. No label can be longer than 63 octets. Consider the following
        /// examples: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>(63 octets).(63 octets).(63 octets).(61 octets)</code> is legal because the
        /// total length is 253 octets (63+1+63+1+63+1+61) and no label exceeds 63 octets.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>(64 octets).(63 octets).(63 octets).(61 octets)</code> is not legal because the
        /// total length exceeds 253 octets (64+1+63+1+63+1+61) and the first label exceeds 63
        /// octets.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>(63 octets).(63 octets).(63 octets).(62 octets)</code> is not legal because the
        /// total length of the DNS name (63+1+63+1+63+1+62) exceeds 253 octets.</p>
        /// </li>
        /// </ul>
        pub fn subject_alternative_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subject_alternative_names(inp);
            self
        }
        pub fn set_subject_alternative_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subject_alternative_names(input);
            self
        }
        /// <p>Customer chosen string that can be used to distinguish between calls to
        /// <code>RequestCertificate</code>. Idempotency tokens time out after one hour. Therefore, if
        /// you call <code>RequestCertificate</code> multiple times with the same idempotency token within
        /// one hour, ACM recognizes that you are requesting only one certificate and will issue only
        /// one. If you change the idempotency token for each call, ACM recognizes that you are
        /// requesting multiple certificates.</p>
        pub fn idempotency_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.idempotency_token(input);
            self
        }
        pub fn set_idempotency_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_idempotency_token(input);
            self
        }
        /// <p>The domain name that you want ACM to use to send you emails so that you can validate
        /// domain ownership.</p>
        pub fn domain_validation_options(
            mut self,
            inp: impl Into<crate::model::DomainValidationOption>,
        ) -> Self {
            self.inner = self.inner.domain_validation_options(inp);
            self
        }
        pub fn set_domain_validation_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DomainValidationOption>>,
        ) -> Self {
            self.inner = self.inner.set_domain_validation_options(input);
            self
        }
        /// <p>Currently, you can use this parameter to specify whether to add the certificate to a
        /// certificate transparency log. Certificate transparency makes it possible to detect SSL/TLS
        /// certificates that have been mistakenly or maliciously issued. Certificates that have not been
        /// logged typically produce an error message in a browser. For more information, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-bestpractices.html#best-practices-transparency">Opting Out of Certificate Transparency Logging</a>.</p>
        pub fn options(mut self, input: crate::model::CertificateOptions) -> Self {
            self.inner = self.inner.options(input);
            self
        }
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::CertificateOptions>,
        ) -> Self {
            self.inner = self.inner.set_options(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the private certificate authority (CA) that will be used
        /// to issue the certificate. If you do not provide an ARN and you are trying to request a private
        /// certificate, ACM will attempt to issue a public certificate. For more information about
        /// private CAs, see the <a href="https://docs.aws.amazon.com/acm-pca/latest/userguide/PcaWelcome.html">AWS Certificate Manager Private Certificate Authority (PCA)</a> user guide. The ARN must have the following form: </p>
        /// <p>
        /// <code>arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        pub fn certificate_authority_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_authority_arn(input);
            self
        }
        pub fn set_certificate_authority_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_authority_arn(input);
            self
        }
        /// <p>One or more resource tags to associate with the certificate.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ResendValidationEmail<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::resend_validation_email_input::Builder,
    }
    impl<C> ResendValidationEmail<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ResendValidationEmailOutput,
            smithy_http::result::SdkError<crate::error::ResendValidationEmailError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>String that contains the ARN of the requested certificate. The certificate ARN is
        /// generated and returned by the <a>RequestCertificate</a> action as soon as the
        /// request is made. By default, using this parameter causes email to be sent to all top-level
        /// domains you specified in the certificate request. The ARN must be of the form: </p>
        /// <p>
        /// <code>arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        pub fn certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(input);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
        /// <p>The fully qualified domain name (FQDN) of the certificate that needs to be
        /// validated.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The base validation domain that will act as the suffix of the email addresses that are
        /// used to send the emails. This must be the same as the <code>Domain</code> value or a
        /// superdomain of the <code>Domain</code> value. For example, if you requested a certificate for
        /// <code>site.subdomain.example.com</code> and specify a <b>ValidationDomain</b> of <code>subdomain.example.com</code>, ACM sends email to the
        /// domain registrant, technical contact, and administrative contact in WHOIS and the following
        /// five addresses:</p>
        /// <ul>
        /// <li>
        /// <p>admin@subdomain.example.com</p>
        /// </li>
        /// <li>
        /// <p>administrator@subdomain.example.com</p>
        /// </li>
        /// <li>
        /// <p>hostmaster@subdomain.example.com</p>
        /// </li>
        /// <li>
        /// <p>postmaster@subdomain.example.com</p>
        /// </li>
        /// <li>
        /// <p>webmaster@subdomain.example.com</p>
        /// </li>
        /// </ul>
        pub fn validation_domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.validation_domain(input);
            self
        }
        pub fn set_validation_domain(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_validation_domain(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateCertificateOptions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_certificate_options_input::Builder,
    }
    impl<C> UpdateCertificateOptions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateCertificateOptionsOutput,
            smithy_http::result::SdkError<crate::error::UpdateCertificateOptionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>ARN of the requested certificate to update. This must be of the form:</p>
        /// <p>
        /// <code>arn:aws:acm:us-east-1:<i>account</i>:certificate/<i>12345678-1234-1234-1234-123456789012</i>
        /// </code>
        /// </p>
        pub fn certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(input);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
        /// <p>Use to update the options for your certificate. Currently, you can specify whether to add
        /// your certificate to a transparency log. Certificate transparency makes it possible to detect
        /// SSL/TLS certificates that have been mistakenly or maliciously issued. Certificates that have
        /// not been logged typically produce an error message in a browser. </p>
        pub fn options(mut self, input: crate::model::CertificateOptions) -> Self {
            self.inner = self.inner.options(input);
            self
        }
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::CertificateOptions>,
        ) -> Self {
            self.inner = self.inner.set_options(input);
            self
        }
    }
}
