// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Contains information about the health checks that are conducted on the load balancer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AwsElbLoadBalancerHealthCheck {
    /// <p>The number of consecutive health check successes required before the instance is moved to the Healthy state.</p>
    #[doc(hidden)]
    pub healthy_threshold: i32,
    /// <p>The approximate interval, in seconds, between health checks of an individual instance.</p>
    #[doc(hidden)]
    pub interval: i32,
    /// <p>The instance that is being checked. The target specifies the protocol and port. The available protocols are TCP, SSL, HTTP, and HTTPS. The range of valid ports is 1 through 65535.</p>
    /// <p>For the HTTP and HTTPS protocols, the target also specifies the ping path.</p>
    /// <p>For the TCP protocol, the target is specified as <code>TCP: <i>
    /// <port></port></i> </code>.</p>
    /// <p>For the SSL protocol, the target is specified as <code>SSL.<i>
    /// <port></port></i> </code>.</p>
    /// <p>For the HTTP and HTTPS protocols, the target is specified as <code> <i>
    /// <protocol></protocol></i>:<i>
    /// <port></port></i>/<i>
    /// <path to ping></path></i> </code>.</p>
    #[doc(hidden)]
    pub target: std::option::Option<std::string::String>,
    /// <p>The amount of time, in seconds, during which no response means a failed health check.</p>
    #[doc(hidden)]
    pub timeout: i32,
    /// <p>The number of consecutive health check failures that must occur before the instance is moved to the Unhealthy state.</p>
    #[doc(hidden)]
    pub unhealthy_threshold: i32,
}
impl AwsElbLoadBalancerHealthCheck {
    /// <p>The number of consecutive health check successes required before the instance is moved to the Healthy state.</p>
    pub fn healthy_threshold(&self) -> i32 {
        self.healthy_threshold
    }
    /// <p>The approximate interval, in seconds, between health checks of an individual instance.</p>
    pub fn interval(&self) -> i32 {
        self.interval
    }
    /// <p>The instance that is being checked. The target specifies the protocol and port. The available protocols are TCP, SSL, HTTP, and HTTPS. The range of valid ports is 1 through 65535.</p>
    /// <p>For the HTTP and HTTPS protocols, the target also specifies the ping path.</p>
    /// <p>For the TCP protocol, the target is specified as <code>TCP: <i>
    /// <port></port></i> </code>.</p>
    /// <p>For the SSL protocol, the target is specified as <code>SSL.<i>
    /// <port></port></i> </code>.</p>
    /// <p>For the HTTP and HTTPS protocols, the target is specified as <code> <i>
    /// <protocol></protocol></i>:<i>
    /// <port></port></i>/<i>
    /// <path to ping></path></i> </code>.</p>
    pub fn target(&self) -> std::option::Option<&str> {
        self.target.as_deref()
    }
    /// <p>The amount of time, in seconds, during which no response means a failed health check.</p>
    pub fn timeout(&self) -> i32 {
        self.timeout
    }
    /// <p>The number of consecutive health check failures that must occur before the instance is moved to the Unhealthy state.</p>
    pub fn unhealthy_threshold(&self) -> i32 {
        self.unhealthy_threshold
    }
}
impl AwsElbLoadBalancerHealthCheck {
    /// Creates a new builder-style object to manufacture [`AwsElbLoadBalancerHealthCheck`](crate::types::AwsElbLoadBalancerHealthCheck).
    pub fn builder() -> crate::types::builders::AwsElbLoadBalancerHealthCheckBuilder {
        crate::types::builders::AwsElbLoadBalancerHealthCheckBuilder::default()
    }
}

/// A builder for [`AwsElbLoadBalancerHealthCheck`](crate::types::AwsElbLoadBalancerHealthCheck).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct AwsElbLoadBalancerHealthCheckBuilder {
    pub(crate) healthy_threshold: std::option::Option<i32>,
    pub(crate) interval: std::option::Option<i32>,
    pub(crate) target: std::option::Option<std::string::String>,
    pub(crate) timeout: std::option::Option<i32>,
    pub(crate) unhealthy_threshold: std::option::Option<i32>,
}
impl AwsElbLoadBalancerHealthCheckBuilder {
    /// <p>The number of consecutive health check successes required before the instance is moved to the Healthy state.</p>
    pub fn healthy_threshold(mut self, input: i32) -> Self {
        self.healthy_threshold = Some(input);
        self
    }
    /// <p>The number of consecutive health check successes required before the instance is moved to the Healthy state.</p>
    pub fn set_healthy_threshold(mut self, input: std::option::Option<i32>) -> Self {
        self.healthy_threshold = input;
        self
    }
    /// <p>The approximate interval, in seconds, between health checks of an individual instance.</p>
    pub fn interval(mut self, input: i32) -> Self {
        self.interval = Some(input);
        self
    }
    /// <p>The approximate interval, in seconds, between health checks of an individual instance.</p>
    pub fn set_interval(mut self, input: std::option::Option<i32>) -> Self {
        self.interval = input;
        self
    }
    /// <p>The instance that is being checked. The target specifies the protocol and port. The available protocols are TCP, SSL, HTTP, and HTTPS. The range of valid ports is 1 through 65535.</p>
    /// <p>For the HTTP and HTTPS protocols, the target also specifies the ping path.</p>
    /// <p>For the TCP protocol, the target is specified as <code>TCP: <i>
    /// <port></port></i> </code>.</p>
    /// <p>For the SSL protocol, the target is specified as <code>SSL.<i>
    /// <port></port></i> </code>.</p>
    /// <p>For the HTTP and HTTPS protocols, the target is specified as <code> <i>
    /// <protocol></protocol></i>:<i>
    /// <port></port></i>/<i>
    /// <path to ping></path></i> </code>.</p>
    pub fn target(mut self, input: impl Into<std::string::String>) -> Self {
        self.target = Some(input.into());
        self
    }
    /// <p>The instance that is being checked. The target specifies the protocol and port. The available protocols are TCP, SSL, HTTP, and HTTPS. The range of valid ports is 1 through 65535.</p>
    /// <p>For the HTTP and HTTPS protocols, the target also specifies the ping path.</p>
    /// <p>For the TCP protocol, the target is specified as <code>TCP: <i>
    /// <port></port></i> </code>.</p>
    /// <p>For the SSL protocol, the target is specified as <code>SSL.<i>
    /// <port></port></i> </code>.</p>
    /// <p>For the HTTP and HTTPS protocols, the target is specified as <code> <i>
    /// <protocol></protocol></i>:<i>
    /// <port></port></i>/<i>
    /// <path to ping></path></i> </code>.</p>
    pub fn set_target(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.target = input;
        self
    }
    /// <p>The amount of time, in seconds, during which no response means a failed health check.</p>
    pub fn timeout(mut self, input: i32) -> Self {
        self.timeout = Some(input);
        self
    }
    /// <p>The amount of time, in seconds, during which no response means a failed health check.</p>
    pub fn set_timeout(mut self, input: std::option::Option<i32>) -> Self {
        self.timeout = input;
        self
    }
    /// <p>The number of consecutive health check failures that must occur before the instance is moved to the Unhealthy state.</p>
    pub fn unhealthy_threshold(mut self, input: i32) -> Self {
        self.unhealthy_threshold = Some(input);
        self
    }
    /// <p>The number of consecutive health check failures that must occur before the instance is moved to the Unhealthy state.</p>
    pub fn set_unhealthy_threshold(mut self, input: std::option::Option<i32>) -> Self {
        self.unhealthy_threshold = input;
        self
    }
    /// Consumes the builder and constructs a [`AwsElbLoadBalancerHealthCheck`](crate::types::AwsElbLoadBalancerHealthCheck).
    pub fn build(self) -> crate::types::AwsElbLoadBalancerHealthCheck {
        crate::types::AwsElbLoadBalancerHealthCheck {
            healthy_threshold: self.healthy_threshold.unwrap_or_default(),
            interval: self.interval.unwrap_or_default(),
            target: self.target,
            timeout: self.timeout.unwrap_or_default(),
            unhealthy_threshold: self.unhealthy_threshold.unwrap_or_default(),
        }
    }
}
