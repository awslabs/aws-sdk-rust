// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Specifies an alarm and associates it with the specified metric or metric math expression. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AwsCloudWatchAlarmDetails {
    /// <p>Indicates whether actions should be executed during any changes to the alarm state. </p>
    #[doc(hidden)]
    pub actions_enabled: bool,
    /// <p>The list of actions, specified as Amazon Resource Names (ARNs) to execute when this alarm transitions into an <code>ALARM</code> state from any other state. </p>
    #[doc(hidden)]
    pub alarm_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ARN of the alarm. </p>
    #[doc(hidden)]
    pub alarm_arn: std::option::Option<std::string::String>,
    /// <p>The time stamp of the last update to the alarm configuration. </p>
    #[doc(hidden)]
    pub alarm_configuration_updated_timestamp: std::option::Option<std::string::String>,
    /// <p>The description of the alarm. </p>
    #[doc(hidden)]
    pub alarm_description: std::option::Option<std::string::String>,
    /// <p>The name of the alarm. If you don't specify a name, CloudFront generates a unique physical ID and uses that ID for the alarm name. </p>
    #[doc(hidden)]
    pub alarm_name: std::option::Option<std::string::String>,
    /// <p>The arithmetic operation to use when comparing the specified statistic and threshold. The specified statistic value is used as the first operand. </p>
    #[doc(hidden)]
    pub comparison_operator: std::option::Option<std::string::String>,
    /// <p>The number of datapoints that must be breaching to trigger the alarm. </p>
    #[doc(hidden)]
    pub datapoints_to_alarm: i32,
    /// <p>The dimensions for the metric associated with the alarm. </p>
    #[doc(hidden)]
    pub dimensions:
        std::option::Option<std::vec::Vec<crate::types::AwsCloudWatchAlarmDimensionsDetails>>,
    /// <p>Used only for alarms based on percentiles. If <code>ignore</code>, the alarm state does not change during periods with too few data points to be statistically significant. If <code>evaluate</code> or this parameter is not used, the alarm is always evaluated and possibly changes state no matter how many data points are available. </p>
    #[doc(hidden)]
    pub evaluate_low_sample_count_percentile: std::option::Option<std::string::String>,
    /// <p>The number of periods over which data is compared to the specified threshold. </p>
    #[doc(hidden)]
    pub evaluation_periods: i32,
    /// <p>The percentile statistic for the metric associated with the alarm. </p>
    #[doc(hidden)]
    pub extended_statistic: std::option::Option<std::string::String>,
    /// <p>The actions to execute when this alarm transitions to the <code>INSUFFICIENT_DATA</code> state from any other state. Each action is specified as an ARN. </p>
    #[doc(hidden)]
    pub insufficient_data_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you use <code>Metrics</code> instead and you can't specify <code>MetricName</code>. </p>
    #[doc(hidden)]
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>The namespace of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you can't specify <code>Namespace</code> and you use <code>Metrics</code> instead. </p>
    #[doc(hidden)]
    pub namespace: std::option::Option<std::string::String>,
    /// <p>The actions to execute when this alarm transitions to the <code>OK</code> state from any other state. Each action is specified as an ARN. </p>
    #[doc(hidden)]
    pub ok_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The period, in seconds, over which the statistic is applied. This is required for an alarm based on a metric. </p>
    #[doc(hidden)]
    pub period: i32,
    /// <p>The statistic for the metric associated with the alarm, other than percentile. For percentile statistics, use <code>ExtendedStatistic</code>.</p>
    /// <p>For an alarm based on a metric, you must specify either <code>Statistic</code> or <code>ExtendedStatistic</code> but not both.</p>
    /// <p>For an alarm based on a math expression, you can't specify <code>Statistic</code>. Instead, you use <code>Metrics</code>.</p>
    #[doc(hidden)]
    pub statistic: std::option::Option<std::string::String>,
    /// <p>The value to compare with the specified statistic. </p>
    #[doc(hidden)]
    pub threshold: f64,
    /// <p>n an alarm based on an anomaly detection model, this is the ID of the <code>ANOMALY_DETECTION_BAND</code> function used as the threshold for the alarm. </p>
    #[doc(hidden)]
    pub threshold_metric_id: std::option::Option<std::string::String>,
    /// <p>Sets how this alarm is to handle missing data points. </p>
    #[doc(hidden)]
    pub treat_missing_data: std::option::Option<std::string::String>,
    /// <p>The unit of the metric associated with the alarm. </p>
    #[doc(hidden)]
    pub unit: std::option::Option<std::string::String>,
}
impl AwsCloudWatchAlarmDetails {
    /// <p>Indicates whether actions should be executed during any changes to the alarm state. </p>
    pub fn actions_enabled(&self) -> bool {
        self.actions_enabled
    }
    /// <p>The list of actions, specified as Amazon Resource Names (ARNs) to execute when this alarm transitions into an <code>ALARM</code> state from any other state. </p>
    pub fn alarm_actions(&self) -> std::option::Option<&[std::string::String]> {
        self.alarm_actions.as_deref()
    }
    /// <p>The ARN of the alarm. </p>
    pub fn alarm_arn(&self) -> std::option::Option<&str> {
        self.alarm_arn.as_deref()
    }
    /// <p>The time stamp of the last update to the alarm configuration. </p>
    pub fn alarm_configuration_updated_timestamp(&self) -> std::option::Option<&str> {
        self.alarm_configuration_updated_timestamp.as_deref()
    }
    /// <p>The description of the alarm. </p>
    pub fn alarm_description(&self) -> std::option::Option<&str> {
        self.alarm_description.as_deref()
    }
    /// <p>The name of the alarm. If you don't specify a name, CloudFront generates a unique physical ID and uses that ID for the alarm name. </p>
    pub fn alarm_name(&self) -> std::option::Option<&str> {
        self.alarm_name.as_deref()
    }
    /// <p>The arithmetic operation to use when comparing the specified statistic and threshold. The specified statistic value is used as the first operand. </p>
    pub fn comparison_operator(&self) -> std::option::Option<&str> {
        self.comparison_operator.as_deref()
    }
    /// <p>The number of datapoints that must be breaching to trigger the alarm. </p>
    pub fn datapoints_to_alarm(&self) -> i32 {
        self.datapoints_to_alarm
    }
    /// <p>The dimensions for the metric associated with the alarm. </p>
    pub fn dimensions(
        &self,
    ) -> std::option::Option<&[crate::types::AwsCloudWatchAlarmDimensionsDetails]> {
        self.dimensions.as_deref()
    }
    /// <p>Used only for alarms based on percentiles. If <code>ignore</code>, the alarm state does not change during periods with too few data points to be statistically significant. If <code>evaluate</code> or this parameter is not used, the alarm is always evaluated and possibly changes state no matter how many data points are available. </p>
    pub fn evaluate_low_sample_count_percentile(&self) -> std::option::Option<&str> {
        self.evaluate_low_sample_count_percentile.as_deref()
    }
    /// <p>The number of periods over which data is compared to the specified threshold. </p>
    pub fn evaluation_periods(&self) -> i32 {
        self.evaluation_periods
    }
    /// <p>The percentile statistic for the metric associated with the alarm. </p>
    pub fn extended_statistic(&self) -> std::option::Option<&str> {
        self.extended_statistic.as_deref()
    }
    /// <p>The actions to execute when this alarm transitions to the <code>INSUFFICIENT_DATA</code> state from any other state. Each action is specified as an ARN. </p>
    pub fn insufficient_data_actions(&self) -> std::option::Option<&[std::string::String]> {
        self.insufficient_data_actions.as_deref()
    }
    /// <p>The name of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you use <code>Metrics</code> instead and you can't specify <code>MetricName</code>. </p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
    /// <p>The namespace of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you can't specify <code>Namespace</code> and you use <code>Metrics</code> instead. </p>
    pub fn namespace(&self) -> std::option::Option<&str> {
        self.namespace.as_deref()
    }
    /// <p>The actions to execute when this alarm transitions to the <code>OK</code> state from any other state. Each action is specified as an ARN. </p>
    pub fn ok_actions(&self) -> std::option::Option<&[std::string::String]> {
        self.ok_actions.as_deref()
    }
    /// <p>The period, in seconds, over which the statistic is applied. This is required for an alarm based on a metric. </p>
    pub fn period(&self) -> i32 {
        self.period
    }
    /// <p>The statistic for the metric associated with the alarm, other than percentile. For percentile statistics, use <code>ExtendedStatistic</code>.</p>
    /// <p>For an alarm based on a metric, you must specify either <code>Statistic</code> or <code>ExtendedStatistic</code> but not both.</p>
    /// <p>For an alarm based on a math expression, you can't specify <code>Statistic</code>. Instead, you use <code>Metrics</code>.</p>
    pub fn statistic(&self) -> std::option::Option<&str> {
        self.statistic.as_deref()
    }
    /// <p>The value to compare with the specified statistic. </p>
    pub fn threshold(&self) -> f64 {
        self.threshold
    }
    /// <p>n an alarm based on an anomaly detection model, this is the ID of the <code>ANOMALY_DETECTION_BAND</code> function used as the threshold for the alarm. </p>
    pub fn threshold_metric_id(&self) -> std::option::Option<&str> {
        self.threshold_metric_id.as_deref()
    }
    /// <p>Sets how this alarm is to handle missing data points. </p>
    pub fn treat_missing_data(&self) -> std::option::Option<&str> {
        self.treat_missing_data.as_deref()
    }
    /// <p>The unit of the metric associated with the alarm. </p>
    pub fn unit(&self) -> std::option::Option<&str> {
        self.unit.as_deref()
    }
}
impl AwsCloudWatchAlarmDetails {
    /// Creates a new builder-style object to manufacture [`AwsCloudWatchAlarmDetails`](crate::types::AwsCloudWatchAlarmDetails).
    pub fn builder() -> crate::types::builders::AwsCloudWatchAlarmDetailsBuilder {
        crate::types::builders::AwsCloudWatchAlarmDetailsBuilder::default()
    }
}

/// A builder for [`AwsCloudWatchAlarmDetails`](crate::types::AwsCloudWatchAlarmDetails).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct AwsCloudWatchAlarmDetailsBuilder {
    pub(crate) actions_enabled: std::option::Option<bool>,
    pub(crate) alarm_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) alarm_arn: std::option::Option<std::string::String>,
    pub(crate) alarm_configuration_updated_timestamp: std::option::Option<std::string::String>,
    pub(crate) alarm_description: std::option::Option<std::string::String>,
    pub(crate) alarm_name: std::option::Option<std::string::String>,
    pub(crate) comparison_operator: std::option::Option<std::string::String>,
    pub(crate) datapoints_to_alarm: std::option::Option<i32>,
    pub(crate) dimensions:
        std::option::Option<std::vec::Vec<crate::types::AwsCloudWatchAlarmDimensionsDetails>>,
    pub(crate) evaluate_low_sample_count_percentile: std::option::Option<std::string::String>,
    pub(crate) evaluation_periods: std::option::Option<i32>,
    pub(crate) extended_statistic: std::option::Option<std::string::String>,
    pub(crate) insufficient_data_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) metric_name: std::option::Option<std::string::String>,
    pub(crate) namespace: std::option::Option<std::string::String>,
    pub(crate) ok_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) period: std::option::Option<i32>,
    pub(crate) statistic: std::option::Option<std::string::String>,
    pub(crate) threshold: std::option::Option<f64>,
    pub(crate) threshold_metric_id: std::option::Option<std::string::String>,
    pub(crate) treat_missing_data: std::option::Option<std::string::String>,
    pub(crate) unit: std::option::Option<std::string::String>,
}
impl AwsCloudWatchAlarmDetailsBuilder {
    /// <p>Indicates whether actions should be executed during any changes to the alarm state. </p>
    pub fn actions_enabled(mut self, input: bool) -> Self {
        self.actions_enabled = Some(input);
        self
    }
    /// <p>Indicates whether actions should be executed during any changes to the alarm state. </p>
    pub fn set_actions_enabled(mut self, input: std::option::Option<bool>) -> Self {
        self.actions_enabled = input;
        self
    }
    /// Appends an item to `alarm_actions`.
    ///
    /// To override the contents of this collection use [`set_alarm_actions`](Self::set_alarm_actions).
    ///
    /// <p>The list of actions, specified as Amazon Resource Names (ARNs) to execute when this alarm transitions into an <code>ALARM</code> state from any other state. </p>
    pub fn alarm_actions(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.alarm_actions.unwrap_or_default();
        v.push(input.into());
        self.alarm_actions = Some(v);
        self
    }
    /// <p>The list of actions, specified as Amazon Resource Names (ARNs) to execute when this alarm transitions into an <code>ALARM</code> state from any other state. </p>
    pub fn set_alarm_actions(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.alarm_actions = input;
        self
    }
    /// <p>The ARN of the alarm. </p>
    pub fn alarm_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.alarm_arn = Some(input.into());
        self
    }
    /// <p>The ARN of the alarm. </p>
    pub fn set_alarm_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.alarm_arn = input;
        self
    }
    /// <p>The time stamp of the last update to the alarm configuration. </p>
    pub fn alarm_configuration_updated_timestamp(
        mut self,
        input: impl Into<std::string::String>,
    ) -> Self {
        self.alarm_configuration_updated_timestamp = Some(input.into());
        self
    }
    /// <p>The time stamp of the last update to the alarm configuration. </p>
    pub fn set_alarm_configuration_updated_timestamp(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.alarm_configuration_updated_timestamp = input;
        self
    }
    /// <p>The description of the alarm. </p>
    pub fn alarm_description(mut self, input: impl Into<std::string::String>) -> Self {
        self.alarm_description = Some(input.into());
        self
    }
    /// <p>The description of the alarm. </p>
    pub fn set_alarm_description(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.alarm_description = input;
        self
    }
    /// <p>The name of the alarm. If you don't specify a name, CloudFront generates a unique physical ID and uses that ID for the alarm name. </p>
    pub fn alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.alarm_name = Some(input.into());
        self
    }
    /// <p>The name of the alarm. If you don't specify a name, CloudFront generates a unique physical ID and uses that ID for the alarm name. </p>
    pub fn set_alarm_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.alarm_name = input;
        self
    }
    /// <p>The arithmetic operation to use when comparing the specified statistic and threshold. The specified statistic value is used as the first operand. </p>
    pub fn comparison_operator(mut self, input: impl Into<std::string::String>) -> Self {
        self.comparison_operator = Some(input.into());
        self
    }
    /// <p>The arithmetic operation to use when comparing the specified statistic and threshold. The specified statistic value is used as the first operand. </p>
    pub fn set_comparison_operator(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.comparison_operator = input;
        self
    }
    /// <p>The number of datapoints that must be breaching to trigger the alarm. </p>
    pub fn datapoints_to_alarm(mut self, input: i32) -> Self {
        self.datapoints_to_alarm = Some(input);
        self
    }
    /// <p>The number of datapoints that must be breaching to trigger the alarm. </p>
    pub fn set_datapoints_to_alarm(mut self, input: std::option::Option<i32>) -> Self {
        self.datapoints_to_alarm = input;
        self
    }
    /// Appends an item to `dimensions`.
    ///
    /// To override the contents of this collection use [`set_dimensions`](Self::set_dimensions).
    ///
    /// <p>The dimensions for the metric associated with the alarm. </p>
    pub fn dimensions(mut self, input: crate::types::AwsCloudWatchAlarmDimensionsDetails) -> Self {
        let mut v = self.dimensions.unwrap_or_default();
        v.push(input);
        self.dimensions = Some(v);
        self
    }
    /// <p>The dimensions for the metric associated with the alarm. </p>
    pub fn set_dimensions(
        mut self,
        input: std::option::Option<
            std::vec::Vec<crate::types::AwsCloudWatchAlarmDimensionsDetails>,
        >,
    ) -> Self {
        self.dimensions = input;
        self
    }
    /// <p>Used only for alarms based on percentiles. If <code>ignore</code>, the alarm state does not change during periods with too few data points to be statistically significant. If <code>evaluate</code> or this parameter is not used, the alarm is always evaluated and possibly changes state no matter how many data points are available. </p>
    pub fn evaluate_low_sample_count_percentile(
        mut self,
        input: impl Into<std::string::String>,
    ) -> Self {
        self.evaluate_low_sample_count_percentile = Some(input.into());
        self
    }
    /// <p>Used only for alarms based on percentiles. If <code>ignore</code>, the alarm state does not change during periods with too few data points to be statistically significant. If <code>evaluate</code> or this parameter is not used, the alarm is always evaluated and possibly changes state no matter how many data points are available. </p>
    pub fn set_evaluate_low_sample_count_percentile(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.evaluate_low_sample_count_percentile = input;
        self
    }
    /// <p>The number of periods over which data is compared to the specified threshold. </p>
    pub fn evaluation_periods(mut self, input: i32) -> Self {
        self.evaluation_periods = Some(input);
        self
    }
    /// <p>The number of periods over which data is compared to the specified threshold. </p>
    pub fn set_evaluation_periods(mut self, input: std::option::Option<i32>) -> Self {
        self.evaluation_periods = input;
        self
    }
    /// <p>The percentile statistic for the metric associated with the alarm. </p>
    pub fn extended_statistic(mut self, input: impl Into<std::string::String>) -> Self {
        self.extended_statistic = Some(input.into());
        self
    }
    /// <p>The percentile statistic for the metric associated with the alarm. </p>
    pub fn set_extended_statistic(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.extended_statistic = input;
        self
    }
    /// Appends an item to `insufficient_data_actions`.
    ///
    /// To override the contents of this collection use [`set_insufficient_data_actions`](Self::set_insufficient_data_actions).
    ///
    /// <p>The actions to execute when this alarm transitions to the <code>INSUFFICIENT_DATA</code> state from any other state. Each action is specified as an ARN. </p>
    pub fn insufficient_data_actions(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.insufficient_data_actions.unwrap_or_default();
        v.push(input.into());
        self.insufficient_data_actions = Some(v);
        self
    }
    /// <p>The actions to execute when this alarm transitions to the <code>INSUFFICIENT_DATA</code> state from any other state. Each action is specified as an ARN. </p>
    pub fn set_insufficient_data_actions(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.insufficient_data_actions = input;
        self
    }
    /// <p>The name of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you use <code>Metrics</code> instead and you can't specify <code>MetricName</code>. </p>
    pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.metric_name = Some(input.into());
        self
    }
    /// <p>The name of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you use <code>Metrics</code> instead and you can't specify <code>MetricName</code>. </p>
    pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.metric_name = input;
        self
    }
    /// <p>The namespace of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you can't specify <code>Namespace</code> and you use <code>Metrics</code> instead. </p>
    pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
        self.namespace = Some(input.into());
        self
    }
    /// <p>The namespace of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you can't specify <code>Namespace</code> and you use <code>Metrics</code> instead. </p>
    pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.namespace = input;
        self
    }
    /// Appends an item to `ok_actions`.
    ///
    /// To override the contents of this collection use [`set_ok_actions`](Self::set_ok_actions).
    ///
    /// <p>The actions to execute when this alarm transitions to the <code>OK</code> state from any other state. Each action is specified as an ARN. </p>
    pub fn ok_actions(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.ok_actions.unwrap_or_default();
        v.push(input.into());
        self.ok_actions = Some(v);
        self
    }
    /// <p>The actions to execute when this alarm transitions to the <code>OK</code> state from any other state. Each action is specified as an ARN. </p>
    pub fn set_ok_actions(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.ok_actions = input;
        self
    }
    /// <p>The period, in seconds, over which the statistic is applied. This is required for an alarm based on a metric. </p>
    pub fn period(mut self, input: i32) -> Self {
        self.period = Some(input);
        self
    }
    /// <p>The period, in seconds, over which the statistic is applied. This is required for an alarm based on a metric. </p>
    pub fn set_period(mut self, input: std::option::Option<i32>) -> Self {
        self.period = input;
        self
    }
    /// <p>The statistic for the metric associated with the alarm, other than percentile. For percentile statistics, use <code>ExtendedStatistic</code>.</p>
    /// <p>For an alarm based on a metric, you must specify either <code>Statistic</code> or <code>ExtendedStatistic</code> but not both.</p>
    /// <p>For an alarm based on a math expression, you can't specify <code>Statistic</code>. Instead, you use <code>Metrics</code>.</p>
    pub fn statistic(mut self, input: impl Into<std::string::String>) -> Self {
        self.statistic = Some(input.into());
        self
    }
    /// <p>The statistic for the metric associated with the alarm, other than percentile. For percentile statistics, use <code>ExtendedStatistic</code>.</p>
    /// <p>For an alarm based on a metric, you must specify either <code>Statistic</code> or <code>ExtendedStatistic</code> but not both.</p>
    /// <p>For an alarm based on a math expression, you can't specify <code>Statistic</code>. Instead, you use <code>Metrics</code>.</p>
    pub fn set_statistic(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.statistic = input;
        self
    }
    /// <p>The value to compare with the specified statistic. </p>
    pub fn threshold(mut self, input: f64) -> Self {
        self.threshold = Some(input);
        self
    }
    /// <p>The value to compare with the specified statistic. </p>
    pub fn set_threshold(mut self, input: std::option::Option<f64>) -> Self {
        self.threshold = input;
        self
    }
    /// <p>n an alarm based on an anomaly detection model, this is the ID of the <code>ANOMALY_DETECTION_BAND</code> function used as the threshold for the alarm. </p>
    pub fn threshold_metric_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.threshold_metric_id = Some(input.into());
        self
    }
    /// <p>n an alarm based on an anomaly detection model, this is the ID of the <code>ANOMALY_DETECTION_BAND</code> function used as the threshold for the alarm. </p>
    pub fn set_threshold_metric_id(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.threshold_metric_id = input;
        self
    }
    /// <p>Sets how this alarm is to handle missing data points. </p>
    pub fn treat_missing_data(mut self, input: impl Into<std::string::String>) -> Self {
        self.treat_missing_data = Some(input.into());
        self
    }
    /// <p>Sets how this alarm is to handle missing data points. </p>
    pub fn set_treat_missing_data(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.treat_missing_data = input;
        self
    }
    /// <p>The unit of the metric associated with the alarm. </p>
    pub fn unit(mut self, input: impl Into<std::string::String>) -> Self {
        self.unit = Some(input.into());
        self
    }
    /// <p>The unit of the metric associated with the alarm. </p>
    pub fn set_unit(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.unit = input;
        self
    }
    /// Consumes the builder and constructs a [`AwsCloudWatchAlarmDetails`](crate::types::AwsCloudWatchAlarmDetails).
    pub fn build(self) -> crate::types::AwsCloudWatchAlarmDetails {
        crate::types::AwsCloudWatchAlarmDetails {
            actions_enabled: self.actions_enabled.unwrap_or_default(),
            alarm_actions: self.alarm_actions,
            alarm_arn: self.alarm_arn,
            alarm_configuration_updated_timestamp: self.alarm_configuration_updated_timestamp,
            alarm_description: self.alarm_description,
            alarm_name: self.alarm_name,
            comparison_operator: self.comparison_operator,
            datapoints_to_alarm: self.datapoints_to_alarm.unwrap_or_default(),
            dimensions: self.dimensions,
            evaluate_low_sample_count_percentile: self.evaluate_low_sample_count_percentile,
            evaluation_periods: self.evaluation_periods.unwrap_or_default(),
            extended_statistic: self.extended_statistic,
            insufficient_data_actions: self.insufficient_data_actions,
            metric_name: self.metric_name,
            namespace: self.namespace,
            ok_actions: self.ok_actions,
            period: self.period.unwrap_or_default(),
            statistic: self.statistic,
            threshold: self.threshold.unwrap_or_default(),
            threshold_metric_id: self.threshold_metric_id,
            treat_missing_data: self.treat_missing_data,
            unit: self.unit,
        }
    }
}
