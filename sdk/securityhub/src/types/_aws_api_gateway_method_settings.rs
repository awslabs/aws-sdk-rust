// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Defines settings for a method for the stage.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AwsApiGatewayMethodSettings {
    /// <p>Indicates whether CloudWatch metrics are enabled for the method. </p>
    #[doc(hidden)]
    pub metrics_enabled: bool,
    /// <p>The logging level for this method. The logging level affects the log entries that are pushed to CloudWatch Logs.</p>
    /// <p>If the logging level is <code>ERROR</code>, then the logs only include error-level entries.</p>
    /// <p>If the logging level is <code>INFO</code>, then the logs include both <code>ERROR</code> events and extra informational events.</p>
    /// <p>Valid values: <code>OFF</code> | <code>ERROR</code> | <code>INFO</code> </p>
    #[doc(hidden)]
    pub logging_level: std::option::Option<std::string::String>,
    /// <p>Indicates whether data trace logging is enabled for the method. Data trace logging affects the log entries that are pushed to CloudWatch Logs.</p>
    #[doc(hidden)]
    pub data_trace_enabled: bool,
    /// <p>The throttling burst limit for the method.</p>
    #[doc(hidden)]
    pub throttling_burst_limit: i32,
    /// <p>The throttling rate limit for the method.</p>
    #[doc(hidden)]
    pub throttling_rate_limit: f64,
    /// <p>Indicates whether responses are cached and returned for requests. For responses to be cached, a cache cluster must be enabled on the stage.</p>
    #[doc(hidden)]
    pub caching_enabled: bool,
    /// <p>Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response is cached.</p>
    #[doc(hidden)]
    pub cache_ttl_in_seconds: i32,
    /// <p>Indicates whether the cached responses are encrypted. </p>
    #[doc(hidden)]
    pub cache_data_encrypted: bool,
    /// <p>Indicates whether authorization is required for a cache invalidation request.</p>
    #[doc(hidden)]
    pub require_authorization_for_cache_control: bool,
    /// <p>Indicates how to handle unauthorized requests for cache invalidation.</p>
    /// <p>Valid values: <code>FAIL_WITH_403</code> | <code>SUCCEED_WITH_RESPONSE_HEADER</code> | <code>SUCCEED_WITHOUT_RESPONSE_HEADER</code> </p>
    #[doc(hidden)]
    pub unauthorized_cache_control_header_strategy: std::option::Option<std::string::String>,
    /// <p>The HTTP method. You can use an asterisk (*) as a wildcard to apply method settings to multiple methods.</p>
    #[doc(hidden)]
    pub http_method: std::option::Option<std::string::String>,
    /// <p>The resource path for this method. Forward slashes (/) are encoded as ~1 . The initial slash must include a forward slash.</p>
    /// <p>For example, the path value <code>/resource/subresource</code> must be encoded as <code>/~1resource~1subresource</code>.</p>
    /// <p>To specify the root path, use only a slash (/). You can use an asterisk (*) as a wildcard to apply method settings to multiple methods.</p>
    #[doc(hidden)]
    pub resource_path: std::option::Option<std::string::String>,
}
impl AwsApiGatewayMethodSettings {
    /// <p>Indicates whether CloudWatch metrics are enabled for the method. </p>
    pub fn metrics_enabled(&self) -> bool {
        self.metrics_enabled
    }
    /// <p>The logging level for this method. The logging level affects the log entries that are pushed to CloudWatch Logs.</p>
    /// <p>If the logging level is <code>ERROR</code>, then the logs only include error-level entries.</p>
    /// <p>If the logging level is <code>INFO</code>, then the logs include both <code>ERROR</code> events and extra informational events.</p>
    /// <p>Valid values: <code>OFF</code> | <code>ERROR</code> | <code>INFO</code> </p>
    pub fn logging_level(&self) -> std::option::Option<&str> {
        self.logging_level.as_deref()
    }
    /// <p>Indicates whether data trace logging is enabled for the method. Data trace logging affects the log entries that are pushed to CloudWatch Logs.</p>
    pub fn data_trace_enabled(&self) -> bool {
        self.data_trace_enabled
    }
    /// <p>The throttling burst limit for the method.</p>
    pub fn throttling_burst_limit(&self) -> i32 {
        self.throttling_burst_limit
    }
    /// <p>The throttling rate limit for the method.</p>
    pub fn throttling_rate_limit(&self) -> f64 {
        self.throttling_rate_limit
    }
    /// <p>Indicates whether responses are cached and returned for requests. For responses to be cached, a cache cluster must be enabled on the stage.</p>
    pub fn caching_enabled(&self) -> bool {
        self.caching_enabled
    }
    /// <p>Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response is cached.</p>
    pub fn cache_ttl_in_seconds(&self) -> i32 {
        self.cache_ttl_in_seconds
    }
    /// <p>Indicates whether the cached responses are encrypted. </p>
    pub fn cache_data_encrypted(&self) -> bool {
        self.cache_data_encrypted
    }
    /// <p>Indicates whether authorization is required for a cache invalidation request.</p>
    pub fn require_authorization_for_cache_control(&self) -> bool {
        self.require_authorization_for_cache_control
    }
    /// <p>Indicates how to handle unauthorized requests for cache invalidation.</p>
    /// <p>Valid values: <code>FAIL_WITH_403</code> | <code>SUCCEED_WITH_RESPONSE_HEADER</code> | <code>SUCCEED_WITHOUT_RESPONSE_HEADER</code> </p>
    pub fn unauthorized_cache_control_header_strategy(&self) -> std::option::Option<&str> {
        self.unauthorized_cache_control_header_strategy.as_deref()
    }
    /// <p>The HTTP method. You can use an asterisk (*) as a wildcard to apply method settings to multiple methods.</p>
    pub fn http_method(&self) -> std::option::Option<&str> {
        self.http_method.as_deref()
    }
    /// <p>The resource path for this method. Forward slashes (/) are encoded as ~1 . The initial slash must include a forward slash.</p>
    /// <p>For example, the path value <code>/resource/subresource</code> must be encoded as <code>/~1resource~1subresource</code>.</p>
    /// <p>To specify the root path, use only a slash (/). You can use an asterisk (*) as a wildcard to apply method settings to multiple methods.</p>
    pub fn resource_path(&self) -> std::option::Option<&str> {
        self.resource_path.as_deref()
    }
}
impl AwsApiGatewayMethodSettings {
    /// Creates a new builder-style object to manufacture [`AwsApiGatewayMethodSettings`](crate::types::AwsApiGatewayMethodSettings).
    pub fn builder() -> crate::types::builders::AwsApiGatewayMethodSettingsBuilder {
        crate::types::builders::AwsApiGatewayMethodSettingsBuilder::default()
    }
}

/// A builder for [`AwsApiGatewayMethodSettings`](crate::types::AwsApiGatewayMethodSettings).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct AwsApiGatewayMethodSettingsBuilder {
    pub(crate) metrics_enabled: std::option::Option<bool>,
    pub(crate) logging_level: std::option::Option<std::string::String>,
    pub(crate) data_trace_enabled: std::option::Option<bool>,
    pub(crate) throttling_burst_limit: std::option::Option<i32>,
    pub(crate) throttling_rate_limit: std::option::Option<f64>,
    pub(crate) caching_enabled: std::option::Option<bool>,
    pub(crate) cache_ttl_in_seconds: std::option::Option<i32>,
    pub(crate) cache_data_encrypted: std::option::Option<bool>,
    pub(crate) require_authorization_for_cache_control: std::option::Option<bool>,
    pub(crate) unauthorized_cache_control_header_strategy: std::option::Option<std::string::String>,
    pub(crate) http_method: std::option::Option<std::string::String>,
    pub(crate) resource_path: std::option::Option<std::string::String>,
}
impl AwsApiGatewayMethodSettingsBuilder {
    /// <p>Indicates whether CloudWatch metrics are enabled for the method. </p>
    pub fn metrics_enabled(mut self, input: bool) -> Self {
        self.metrics_enabled = Some(input);
        self
    }
    /// <p>Indicates whether CloudWatch metrics are enabled for the method. </p>
    pub fn set_metrics_enabled(mut self, input: std::option::Option<bool>) -> Self {
        self.metrics_enabled = input;
        self
    }
    /// <p>The logging level for this method. The logging level affects the log entries that are pushed to CloudWatch Logs.</p>
    /// <p>If the logging level is <code>ERROR</code>, then the logs only include error-level entries.</p>
    /// <p>If the logging level is <code>INFO</code>, then the logs include both <code>ERROR</code> events and extra informational events.</p>
    /// <p>Valid values: <code>OFF</code> | <code>ERROR</code> | <code>INFO</code> </p>
    pub fn logging_level(mut self, input: impl Into<std::string::String>) -> Self {
        self.logging_level = Some(input.into());
        self
    }
    /// <p>The logging level for this method. The logging level affects the log entries that are pushed to CloudWatch Logs.</p>
    /// <p>If the logging level is <code>ERROR</code>, then the logs only include error-level entries.</p>
    /// <p>If the logging level is <code>INFO</code>, then the logs include both <code>ERROR</code> events and extra informational events.</p>
    /// <p>Valid values: <code>OFF</code> | <code>ERROR</code> | <code>INFO</code> </p>
    pub fn set_logging_level(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.logging_level = input;
        self
    }
    /// <p>Indicates whether data trace logging is enabled for the method. Data trace logging affects the log entries that are pushed to CloudWatch Logs.</p>
    pub fn data_trace_enabled(mut self, input: bool) -> Self {
        self.data_trace_enabled = Some(input);
        self
    }
    /// <p>Indicates whether data trace logging is enabled for the method. Data trace logging affects the log entries that are pushed to CloudWatch Logs.</p>
    pub fn set_data_trace_enabled(mut self, input: std::option::Option<bool>) -> Self {
        self.data_trace_enabled = input;
        self
    }
    /// <p>The throttling burst limit for the method.</p>
    pub fn throttling_burst_limit(mut self, input: i32) -> Self {
        self.throttling_burst_limit = Some(input);
        self
    }
    /// <p>The throttling burst limit for the method.</p>
    pub fn set_throttling_burst_limit(mut self, input: std::option::Option<i32>) -> Self {
        self.throttling_burst_limit = input;
        self
    }
    /// <p>The throttling rate limit for the method.</p>
    pub fn throttling_rate_limit(mut self, input: f64) -> Self {
        self.throttling_rate_limit = Some(input);
        self
    }
    /// <p>The throttling rate limit for the method.</p>
    pub fn set_throttling_rate_limit(mut self, input: std::option::Option<f64>) -> Self {
        self.throttling_rate_limit = input;
        self
    }
    /// <p>Indicates whether responses are cached and returned for requests. For responses to be cached, a cache cluster must be enabled on the stage.</p>
    pub fn caching_enabled(mut self, input: bool) -> Self {
        self.caching_enabled = Some(input);
        self
    }
    /// <p>Indicates whether responses are cached and returned for requests. For responses to be cached, a cache cluster must be enabled on the stage.</p>
    pub fn set_caching_enabled(mut self, input: std::option::Option<bool>) -> Self {
        self.caching_enabled = input;
        self
    }
    /// <p>Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response is cached.</p>
    pub fn cache_ttl_in_seconds(mut self, input: i32) -> Self {
        self.cache_ttl_in_seconds = Some(input);
        self
    }
    /// <p>Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response is cached.</p>
    pub fn set_cache_ttl_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
        self.cache_ttl_in_seconds = input;
        self
    }
    /// <p>Indicates whether the cached responses are encrypted. </p>
    pub fn cache_data_encrypted(mut self, input: bool) -> Self {
        self.cache_data_encrypted = Some(input);
        self
    }
    /// <p>Indicates whether the cached responses are encrypted. </p>
    pub fn set_cache_data_encrypted(mut self, input: std::option::Option<bool>) -> Self {
        self.cache_data_encrypted = input;
        self
    }
    /// <p>Indicates whether authorization is required for a cache invalidation request.</p>
    pub fn require_authorization_for_cache_control(mut self, input: bool) -> Self {
        self.require_authorization_for_cache_control = Some(input);
        self
    }
    /// <p>Indicates whether authorization is required for a cache invalidation request.</p>
    pub fn set_require_authorization_for_cache_control(
        mut self,
        input: std::option::Option<bool>,
    ) -> Self {
        self.require_authorization_for_cache_control = input;
        self
    }
    /// <p>Indicates how to handle unauthorized requests for cache invalidation.</p>
    /// <p>Valid values: <code>FAIL_WITH_403</code> | <code>SUCCEED_WITH_RESPONSE_HEADER</code> | <code>SUCCEED_WITHOUT_RESPONSE_HEADER</code> </p>
    pub fn unauthorized_cache_control_header_strategy(
        mut self,
        input: impl Into<std::string::String>,
    ) -> Self {
        self.unauthorized_cache_control_header_strategy = Some(input.into());
        self
    }
    /// <p>Indicates how to handle unauthorized requests for cache invalidation.</p>
    /// <p>Valid values: <code>FAIL_WITH_403</code> | <code>SUCCEED_WITH_RESPONSE_HEADER</code> | <code>SUCCEED_WITHOUT_RESPONSE_HEADER</code> </p>
    pub fn set_unauthorized_cache_control_header_strategy(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.unauthorized_cache_control_header_strategy = input;
        self
    }
    /// <p>The HTTP method. You can use an asterisk (*) as a wildcard to apply method settings to multiple methods.</p>
    pub fn http_method(mut self, input: impl Into<std::string::String>) -> Self {
        self.http_method = Some(input.into());
        self
    }
    /// <p>The HTTP method. You can use an asterisk (*) as a wildcard to apply method settings to multiple methods.</p>
    pub fn set_http_method(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.http_method = input;
        self
    }
    /// <p>The resource path for this method. Forward slashes (/) are encoded as ~1 . The initial slash must include a forward slash.</p>
    /// <p>For example, the path value <code>/resource/subresource</code> must be encoded as <code>/~1resource~1subresource</code>.</p>
    /// <p>To specify the root path, use only a slash (/). You can use an asterisk (*) as a wildcard to apply method settings to multiple methods.</p>
    pub fn resource_path(mut self, input: impl Into<std::string::String>) -> Self {
        self.resource_path = Some(input.into());
        self
    }
    /// <p>The resource path for this method. Forward slashes (/) are encoded as ~1 . The initial slash must include a forward slash.</p>
    /// <p>For example, the path value <code>/resource/subresource</code> must be encoded as <code>/~1resource~1subresource</code>.</p>
    /// <p>To specify the root path, use only a slash (/). You can use an asterisk (*) as a wildcard to apply method settings to multiple methods.</p>
    pub fn set_resource_path(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.resource_path = input;
        self
    }
    /// Consumes the builder and constructs a [`AwsApiGatewayMethodSettings`](crate::types::AwsApiGatewayMethodSettings).
    pub fn build(self) -> crate::types::AwsApiGatewayMethodSettings {
        crate::types::AwsApiGatewayMethodSettings {
            metrics_enabled: self.metrics_enabled.unwrap_or_default(),
            logging_level: self.logging_level,
            data_trace_enabled: self.data_trace_enabled.unwrap_or_default(),
            throttling_burst_limit: self.throttling_burst_limit.unwrap_or_default(),
            throttling_rate_limit: self.throttling_rate_limit.unwrap_or_default(),
            caching_enabled: self.caching_enabled.unwrap_or_default(),
            cache_ttl_in_seconds: self.cache_ttl_in_seconds.unwrap_or_default(),
            cache_data_encrypted: self.cache_data_encrypted.unwrap_or_default(),
            require_authorization_for_cache_control: self
                .require_authorization_for_cache_control
                .unwrap_or_default(),
            unauthorized_cache_control_header_strategy: self
                .unauthorized_cache_control_header_strategy,
            http_method: self.http_method,
            resource_path: self.resource_path,
        }
    }
}
