// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Provides the details about the compliance status for a patch.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AwsSsmComplianceSummary {
    /// <p>The current patch compliance status. Valid values are as follows:</p>
    /// <ul>
    /// <li> <p> <code>COMPLIANT</code> </p> </li>
    /// <li> <p> <code>NON_COMPLIANT</code> </p> </li>
    /// <li> <p> <code>UNSPECIFIED_DATA</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<std::string::String>,
    /// <p>For the patches that are compliant, the number that have a severity of <code>CRITICAL</code>.</p>
    #[doc(hidden)]
    pub compliant_critical_count: i32,
    /// <p>For the patches that are compliant, the number that have a severity of <code>HIGH</code>.</p>
    #[doc(hidden)]
    pub compliant_high_count: i32,
    /// <p>For the patches that are compliant, the number that have a severity of <code>MEDIUM</code>.</p>
    #[doc(hidden)]
    pub compliant_medium_count: i32,
    /// <p>The type of execution that was used determine compliance.</p>
    #[doc(hidden)]
    pub execution_type: std::option::Option<std::string::String>,
    /// <p>For the patch items that are noncompliant, the number of items that have a severity of <code>CRITICAL</code>.</p>
    #[doc(hidden)]
    pub non_compliant_critical_count: i32,
    /// <p>For the patches that are compliant, the number that have a severity of <code>INFORMATIONAL</code>.</p>
    #[doc(hidden)]
    pub compliant_informational_count: i32,
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>INFORMATIONAL</code>.</p>
    #[doc(hidden)]
    pub non_compliant_informational_count: i32,
    /// <p>For the patches that are compliant, the number that have a severity of <code>UNSPECIFIED</code>.</p>
    #[doc(hidden)]
    pub compliant_unspecified_count: i32,
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>LOW</code>.</p>
    #[doc(hidden)]
    pub non_compliant_low_count: i32,
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>HIGH</code>.</p>
    #[doc(hidden)]
    pub non_compliant_high_count: i32,
    /// <p>For the patches that are compliant, the number that have a severity of <code>LOW</code>.</p>
    #[doc(hidden)]
    pub compliant_low_count: i32,
    /// <p>The type of resource for which the compliance was determined. For <code>AwsSsmPatchCompliance</code>, <code>ComplianceType</code> is <code>Patch</code>. </p>
    #[doc(hidden)]
    pub compliance_type: std::option::Option<std::string::String>,
    /// <p>The identifier of the patch baseline. The patch baseline lists the patches that are approved for installation.</p>
    #[doc(hidden)]
    pub patch_baseline_id: std::option::Option<std::string::String>,
    /// <p>The highest severity for the patches. Valid values are as follows:</p>
    /// <ul>
    /// <li> <p> <code>CRITICAL</code> </p> </li>
    /// <li> <p> <code>HIGH</code> </p> </li>
    /// <li> <p> <code>MEDIUM</code> </p> </li>
    /// <li> <p> <code>LOW</code> </p> </li>
    /// <li> <p> <code>INFORMATIONAL</code> </p> </li>
    /// <li> <p> <code>UNSPECIFIED</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub overall_severity: std::option::Option<std::string::String>,
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>MEDIUM</code>.</p>
    #[doc(hidden)]
    pub non_compliant_medium_count: i32,
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>UNSPECIFIED</code>.</p>
    #[doc(hidden)]
    pub non_compliant_unspecified_count: i32,
    /// <p>The identifier of the patch group for which compliance was determined. A patch group uses tags to group EC2 instances that should have the same patch compliance.</p>
    #[doc(hidden)]
    pub patch_group: std::option::Option<std::string::String>,
}
impl AwsSsmComplianceSummary {
    /// <p>The current patch compliance status. Valid values are as follows:</p>
    /// <ul>
    /// <li> <p> <code>COMPLIANT</code> </p> </li>
    /// <li> <p> <code>NON_COMPLIANT</code> </p> </li>
    /// <li> <p> <code>UNSPECIFIED_DATA</code> </p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>For the patches that are compliant, the number that have a severity of <code>CRITICAL</code>.</p>
    pub fn compliant_critical_count(&self) -> i32 {
        self.compliant_critical_count
    }
    /// <p>For the patches that are compliant, the number that have a severity of <code>HIGH</code>.</p>
    pub fn compliant_high_count(&self) -> i32 {
        self.compliant_high_count
    }
    /// <p>For the patches that are compliant, the number that have a severity of <code>MEDIUM</code>.</p>
    pub fn compliant_medium_count(&self) -> i32 {
        self.compliant_medium_count
    }
    /// <p>The type of execution that was used determine compliance.</p>
    pub fn execution_type(&self) -> std::option::Option<&str> {
        self.execution_type.as_deref()
    }
    /// <p>For the patch items that are noncompliant, the number of items that have a severity of <code>CRITICAL</code>.</p>
    pub fn non_compliant_critical_count(&self) -> i32 {
        self.non_compliant_critical_count
    }
    /// <p>For the patches that are compliant, the number that have a severity of <code>INFORMATIONAL</code>.</p>
    pub fn compliant_informational_count(&self) -> i32 {
        self.compliant_informational_count
    }
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>INFORMATIONAL</code>.</p>
    pub fn non_compliant_informational_count(&self) -> i32 {
        self.non_compliant_informational_count
    }
    /// <p>For the patches that are compliant, the number that have a severity of <code>UNSPECIFIED</code>.</p>
    pub fn compliant_unspecified_count(&self) -> i32 {
        self.compliant_unspecified_count
    }
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>LOW</code>.</p>
    pub fn non_compliant_low_count(&self) -> i32 {
        self.non_compliant_low_count
    }
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>HIGH</code>.</p>
    pub fn non_compliant_high_count(&self) -> i32 {
        self.non_compliant_high_count
    }
    /// <p>For the patches that are compliant, the number that have a severity of <code>LOW</code>.</p>
    pub fn compliant_low_count(&self) -> i32 {
        self.compliant_low_count
    }
    /// <p>The type of resource for which the compliance was determined. For <code>AwsSsmPatchCompliance</code>, <code>ComplianceType</code> is <code>Patch</code>. </p>
    pub fn compliance_type(&self) -> std::option::Option<&str> {
        self.compliance_type.as_deref()
    }
    /// <p>The identifier of the patch baseline. The patch baseline lists the patches that are approved for installation.</p>
    pub fn patch_baseline_id(&self) -> std::option::Option<&str> {
        self.patch_baseline_id.as_deref()
    }
    /// <p>The highest severity for the patches. Valid values are as follows:</p>
    /// <ul>
    /// <li> <p> <code>CRITICAL</code> </p> </li>
    /// <li> <p> <code>HIGH</code> </p> </li>
    /// <li> <p> <code>MEDIUM</code> </p> </li>
    /// <li> <p> <code>LOW</code> </p> </li>
    /// <li> <p> <code>INFORMATIONAL</code> </p> </li>
    /// <li> <p> <code>UNSPECIFIED</code> </p> </li>
    /// </ul>
    pub fn overall_severity(&self) -> std::option::Option<&str> {
        self.overall_severity.as_deref()
    }
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>MEDIUM</code>.</p>
    pub fn non_compliant_medium_count(&self) -> i32 {
        self.non_compliant_medium_count
    }
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>UNSPECIFIED</code>.</p>
    pub fn non_compliant_unspecified_count(&self) -> i32 {
        self.non_compliant_unspecified_count
    }
    /// <p>The identifier of the patch group for which compliance was determined. A patch group uses tags to group EC2 instances that should have the same patch compliance.</p>
    pub fn patch_group(&self) -> std::option::Option<&str> {
        self.patch_group.as_deref()
    }
}
impl AwsSsmComplianceSummary {
    /// Creates a new builder-style object to manufacture [`AwsSsmComplianceSummary`](crate::types::AwsSsmComplianceSummary).
    pub fn builder() -> crate::types::builders::AwsSsmComplianceSummaryBuilder {
        crate::types::builders::AwsSsmComplianceSummaryBuilder::default()
    }
}

/// A builder for [`AwsSsmComplianceSummary`](crate::types::AwsSsmComplianceSummary).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct AwsSsmComplianceSummaryBuilder {
    pub(crate) status: std::option::Option<std::string::String>,
    pub(crate) compliant_critical_count: std::option::Option<i32>,
    pub(crate) compliant_high_count: std::option::Option<i32>,
    pub(crate) compliant_medium_count: std::option::Option<i32>,
    pub(crate) execution_type: std::option::Option<std::string::String>,
    pub(crate) non_compliant_critical_count: std::option::Option<i32>,
    pub(crate) compliant_informational_count: std::option::Option<i32>,
    pub(crate) non_compliant_informational_count: std::option::Option<i32>,
    pub(crate) compliant_unspecified_count: std::option::Option<i32>,
    pub(crate) non_compliant_low_count: std::option::Option<i32>,
    pub(crate) non_compliant_high_count: std::option::Option<i32>,
    pub(crate) compliant_low_count: std::option::Option<i32>,
    pub(crate) compliance_type: std::option::Option<std::string::String>,
    pub(crate) patch_baseline_id: std::option::Option<std::string::String>,
    pub(crate) overall_severity: std::option::Option<std::string::String>,
    pub(crate) non_compliant_medium_count: std::option::Option<i32>,
    pub(crate) non_compliant_unspecified_count: std::option::Option<i32>,
    pub(crate) patch_group: std::option::Option<std::string::String>,
}
impl AwsSsmComplianceSummaryBuilder {
    /// <p>The current patch compliance status. Valid values are as follows:</p>
    /// <ul>
    /// <li> <p> <code>COMPLIANT</code> </p> </li>
    /// <li> <p> <code>NON_COMPLIANT</code> </p> </li>
    /// <li> <p> <code>UNSPECIFIED_DATA</code> </p> </li>
    /// </ul>
    pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
        self.status = Some(input.into());
        self
    }
    /// <p>The current patch compliance status. Valid values are as follows:</p>
    /// <ul>
    /// <li> <p> <code>COMPLIANT</code> </p> </li>
    /// <li> <p> <code>NON_COMPLIANT</code> </p> </li>
    /// <li> <p> <code>UNSPECIFIED_DATA</code> </p> </li>
    /// </ul>
    pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.status = input;
        self
    }
    /// <p>For the patches that are compliant, the number that have a severity of <code>CRITICAL</code>.</p>
    pub fn compliant_critical_count(mut self, input: i32) -> Self {
        self.compliant_critical_count = Some(input);
        self
    }
    /// <p>For the patches that are compliant, the number that have a severity of <code>CRITICAL</code>.</p>
    pub fn set_compliant_critical_count(mut self, input: std::option::Option<i32>) -> Self {
        self.compliant_critical_count = input;
        self
    }
    /// <p>For the patches that are compliant, the number that have a severity of <code>HIGH</code>.</p>
    pub fn compliant_high_count(mut self, input: i32) -> Self {
        self.compliant_high_count = Some(input);
        self
    }
    /// <p>For the patches that are compliant, the number that have a severity of <code>HIGH</code>.</p>
    pub fn set_compliant_high_count(mut self, input: std::option::Option<i32>) -> Self {
        self.compliant_high_count = input;
        self
    }
    /// <p>For the patches that are compliant, the number that have a severity of <code>MEDIUM</code>.</p>
    pub fn compliant_medium_count(mut self, input: i32) -> Self {
        self.compliant_medium_count = Some(input);
        self
    }
    /// <p>For the patches that are compliant, the number that have a severity of <code>MEDIUM</code>.</p>
    pub fn set_compliant_medium_count(mut self, input: std::option::Option<i32>) -> Self {
        self.compliant_medium_count = input;
        self
    }
    /// <p>The type of execution that was used determine compliance.</p>
    pub fn execution_type(mut self, input: impl Into<std::string::String>) -> Self {
        self.execution_type = Some(input.into());
        self
    }
    /// <p>The type of execution that was used determine compliance.</p>
    pub fn set_execution_type(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.execution_type = input;
        self
    }
    /// <p>For the patch items that are noncompliant, the number of items that have a severity of <code>CRITICAL</code>.</p>
    pub fn non_compliant_critical_count(mut self, input: i32) -> Self {
        self.non_compliant_critical_count = Some(input);
        self
    }
    /// <p>For the patch items that are noncompliant, the number of items that have a severity of <code>CRITICAL</code>.</p>
    pub fn set_non_compliant_critical_count(mut self, input: std::option::Option<i32>) -> Self {
        self.non_compliant_critical_count = input;
        self
    }
    /// <p>For the patches that are compliant, the number that have a severity of <code>INFORMATIONAL</code>.</p>
    pub fn compliant_informational_count(mut self, input: i32) -> Self {
        self.compliant_informational_count = Some(input);
        self
    }
    /// <p>For the patches that are compliant, the number that have a severity of <code>INFORMATIONAL</code>.</p>
    pub fn set_compliant_informational_count(mut self, input: std::option::Option<i32>) -> Self {
        self.compliant_informational_count = input;
        self
    }
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>INFORMATIONAL</code>.</p>
    pub fn non_compliant_informational_count(mut self, input: i32) -> Self {
        self.non_compliant_informational_count = Some(input);
        self
    }
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>INFORMATIONAL</code>.</p>
    pub fn set_non_compliant_informational_count(
        mut self,
        input: std::option::Option<i32>,
    ) -> Self {
        self.non_compliant_informational_count = input;
        self
    }
    /// <p>For the patches that are compliant, the number that have a severity of <code>UNSPECIFIED</code>.</p>
    pub fn compliant_unspecified_count(mut self, input: i32) -> Self {
        self.compliant_unspecified_count = Some(input);
        self
    }
    /// <p>For the patches that are compliant, the number that have a severity of <code>UNSPECIFIED</code>.</p>
    pub fn set_compliant_unspecified_count(mut self, input: std::option::Option<i32>) -> Self {
        self.compliant_unspecified_count = input;
        self
    }
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>LOW</code>.</p>
    pub fn non_compliant_low_count(mut self, input: i32) -> Self {
        self.non_compliant_low_count = Some(input);
        self
    }
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>LOW</code>.</p>
    pub fn set_non_compliant_low_count(mut self, input: std::option::Option<i32>) -> Self {
        self.non_compliant_low_count = input;
        self
    }
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>HIGH</code>.</p>
    pub fn non_compliant_high_count(mut self, input: i32) -> Self {
        self.non_compliant_high_count = Some(input);
        self
    }
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>HIGH</code>.</p>
    pub fn set_non_compliant_high_count(mut self, input: std::option::Option<i32>) -> Self {
        self.non_compliant_high_count = input;
        self
    }
    /// <p>For the patches that are compliant, the number that have a severity of <code>LOW</code>.</p>
    pub fn compliant_low_count(mut self, input: i32) -> Self {
        self.compliant_low_count = Some(input);
        self
    }
    /// <p>For the patches that are compliant, the number that have a severity of <code>LOW</code>.</p>
    pub fn set_compliant_low_count(mut self, input: std::option::Option<i32>) -> Self {
        self.compliant_low_count = input;
        self
    }
    /// <p>The type of resource for which the compliance was determined. For <code>AwsSsmPatchCompliance</code>, <code>ComplianceType</code> is <code>Patch</code>. </p>
    pub fn compliance_type(mut self, input: impl Into<std::string::String>) -> Self {
        self.compliance_type = Some(input.into());
        self
    }
    /// <p>The type of resource for which the compliance was determined. For <code>AwsSsmPatchCompliance</code>, <code>ComplianceType</code> is <code>Patch</code>. </p>
    pub fn set_compliance_type(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.compliance_type = input;
        self
    }
    /// <p>The identifier of the patch baseline. The patch baseline lists the patches that are approved for installation.</p>
    pub fn patch_baseline_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.patch_baseline_id = Some(input.into());
        self
    }
    /// <p>The identifier of the patch baseline. The patch baseline lists the patches that are approved for installation.</p>
    pub fn set_patch_baseline_id(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.patch_baseline_id = input;
        self
    }
    /// <p>The highest severity for the patches. Valid values are as follows:</p>
    /// <ul>
    /// <li> <p> <code>CRITICAL</code> </p> </li>
    /// <li> <p> <code>HIGH</code> </p> </li>
    /// <li> <p> <code>MEDIUM</code> </p> </li>
    /// <li> <p> <code>LOW</code> </p> </li>
    /// <li> <p> <code>INFORMATIONAL</code> </p> </li>
    /// <li> <p> <code>UNSPECIFIED</code> </p> </li>
    /// </ul>
    pub fn overall_severity(mut self, input: impl Into<std::string::String>) -> Self {
        self.overall_severity = Some(input.into());
        self
    }
    /// <p>The highest severity for the patches. Valid values are as follows:</p>
    /// <ul>
    /// <li> <p> <code>CRITICAL</code> </p> </li>
    /// <li> <p> <code>HIGH</code> </p> </li>
    /// <li> <p> <code>MEDIUM</code> </p> </li>
    /// <li> <p> <code>LOW</code> </p> </li>
    /// <li> <p> <code>INFORMATIONAL</code> </p> </li>
    /// <li> <p> <code>UNSPECIFIED</code> </p> </li>
    /// </ul>
    pub fn set_overall_severity(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.overall_severity = input;
        self
    }
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>MEDIUM</code>.</p>
    pub fn non_compliant_medium_count(mut self, input: i32) -> Self {
        self.non_compliant_medium_count = Some(input);
        self
    }
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>MEDIUM</code>.</p>
    pub fn set_non_compliant_medium_count(mut self, input: std::option::Option<i32>) -> Self {
        self.non_compliant_medium_count = input;
        self
    }
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>UNSPECIFIED</code>.</p>
    pub fn non_compliant_unspecified_count(mut self, input: i32) -> Self {
        self.non_compliant_unspecified_count = Some(input);
        self
    }
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>UNSPECIFIED</code>.</p>
    pub fn set_non_compliant_unspecified_count(mut self, input: std::option::Option<i32>) -> Self {
        self.non_compliant_unspecified_count = input;
        self
    }
    /// <p>The identifier of the patch group for which compliance was determined. A patch group uses tags to group EC2 instances that should have the same patch compliance.</p>
    pub fn patch_group(mut self, input: impl Into<std::string::String>) -> Self {
        self.patch_group = Some(input.into());
        self
    }
    /// <p>The identifier of the patch group for which compliance was determined. A patch group uses tags to group EC2 instances that should have the same patch compliance.</p>
    pub fn set_patch_group(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.patch_group = input;
        self
    }
    /// Consumes the builder and constructs a [`AwsSsmComplianceSummary`](crate::types::AwsSsmComplianceSummary).
    pub fn build(self) -> crate::types::AwsSsmComplianceSummary {
        crate::types::AwsSsmComplianceSummary {
            status: self.status,
            compliant_critical_count: self.compliant_critical_count.unwrap_or_default(),
            compliant_high_count: self.compliant_high_count.unwrap_or_default(),
            compliant_medium_count: self.compliant_medium_count.unwrap_or_default(),
            execution_type: self.execution_type,
            non_compliant_critical_count: self.non_compliant_critical_count.unwrap_or_default(),
            compliant_informational_count: self.compliant_informational_count.unwrap_or_default(),
            non_compliant_informational_count: self
                .non_compliant_informational_count
                .unwrap_or_default(),
            compliant_unspecified_count: self.compliant_unspecified_count.unwrap_or_default(),
            non_compliant_low_count: self.non_compliant_low_count.unwrap_or_default(),
            non_compliant_high_count: self.non_compliant_high_count.unwrap_or_default(),
            compliant_low_count: self.compliant_low_count.unwrap_or_default(),
            compliance_type: self.compliance_type,
            patch_baseline_id: self.patch_baseline_id,
            overall_severity: self.overall_severity,
            non_compliant_medium_count: self.non_compliant_medium_count.unwrap_or_default(),
            non_compliant_unspecified_count: self
                .non_compliant_unspecified_count
                .unwrap_or_default(),
            patch_group: self.patch_group,
        }
    }
}
