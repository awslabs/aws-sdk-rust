// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Provides details about a service within an ECS cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AwsEcsServiceDetails {
    /// <p>The capacity provider strategy that the service uses.</p>
    #[doc(hidden)]
    pub capacity_provider_strategy: std::option::Option<
        std::vec::Vec<crate::types::AwsEcsServiceCapacityProviderStrategyDetails>,
    >,
    /// <p>The ARN of the cluster that hosts the service.</p>
    #[doc(hidden)]
    pub cluster: std::option::Option<std::string::String>,
    /// <p>Deployment parameters for the service. Includes the number of tasks that run and the order in which to start and stop tasks.</p>
    #[doc(hidden)]
    pub deployment_configuration:
        std::option::Option<crate::types::AwsEcsServiceDeploymentConfigurationDetails>,
    /// <p>Contains the deployment controller type that the service uses.</p>
    #[doc(hidden)]
    pub deployment_controller:
        std::option::Option<crate::types::AwsEcsServiceDeploymentControllerDetails>,
    /// <p>The number of instantiations of the task definition to run on the service.</p>
    #[doc(hidden)]
    pub desired_count: i32,
    /// <p>Whether to enable Amazon ECS managed tags for the tasks in the service.</p>
    #[doc(hidden)]
    pub enable_ecs_managed_tags: bool,
    /// <p>Whether the execute command functionality is enabled for the service.</p>
    #[doc(hidden)]
    pub enable_execute_command: bool,
    /// <p>After a task starts, the amount of time in seconds that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks.</p>
    #[doc(hidden)]
    pub health_check_grace_period_seconds: i32,
    /// <p>The launch type that the service uses.</p>
    /// <p>Valid values: <code>EC2</code> | <code>FARGATE</code> | <code>EXTERNAL</code> </p>
    #[doc(hidden)]
    pub launch_type: std::option::Option<std::string::String>,
    /// <p>Information about the load balancers that the service uses.</p>
    #[doc(hidden)]
    pub load_balancers:
        std::option::Option<std::vec::Vec<crate::types::AwsEcsServiceLoadBalancersDetails>>,
    /// <p>The name of the service.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>For tasks that use the <code>awsvpc</code> networking mode, the VPC subnet and security group configuration.</p>
    #[doc(hidden)]
    pub network_configuration:
        std::option::Option<crate::types::AwsEcsServiceNetworkConfigurationDetails>,
    /// <p>The placement constraints for the tasks in the service.</p>
    #[doc(hidden)]
    pub placement_constraints:
        std::option::Option<std::vec::Vec<crate::types::AwsEcsServicePlacementConstraintsDetails>>,
    /// <p>Information about how tasks for the service are placed.</p>
    #[doc(hidden)]
    pub placement_strategies:
        std::option::Option<std::vec::Vec<crate::types::AwsEcsServicePlacementStrategiesDetails>>,
    /// <p>The platform version on which to run the service. Only specified for tasks that are hosted on Fargate. If a platform version is not specified, the <code>LATEST</code> platform version is used by default.</p>
    #[doc(hidden)]
    pub platform_version: std::option::Option<std::string::String>,
    /// <p>Indicates whether to propagate the tags from the task definition to the task or from the service to the task. If no value is provided, then tags are not propagated.</p>
    /// <p>Valid values: <code>TASK_DEFINITION</code> | <code>SERVICE</code> </p>
    #[doc(hidden)]
    pub propagate_tags: std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM role that is associated with the service. The role allows the Amazon ECS container agent to register container instances with an Elastic Load Balancing load balancer.</p>
    #[doc(hidden)]
    pub role: std::option::Option<std::string::String>,
    /// <p>The scheduling strategy to use for the service.</p>
    /// <p>The <code>REPLICA</code> scheduling strategy places and maintains the desired number of tasks across the cluster. By default, the service scheduler spreads tasks across Availability Zones. Task placement strategies and constraints are used to customize task placement decisions.</p>
    /// <p>The <code>DAEMON</code> scheduling strategy deploys exactly one task on each active container instance that meets all of the task placement constraints that are specified in the cluster. The service scheduler also evaluates the task placement constraints for running tasks and stops tasks that do not meet the placement constraints.</p>
    /// <p>Valid values: <code>REPLICA</code> | <code>DAEMON</code> </p>
    #[doc(hidden)]
    pub scheduling_strategy: std::option::Option<std::string::String>,
    /// <p>The ARN of the service.</p>
    #[doc(hidden)]
    pub service_arn: std::option::Option<std::string::String>,
    /// <p>The name of the service.</p>
    /// <p>The name can contain up to 255 characters. It can use letters, numbers, underscores, and hyphens.</p>
    #[doc(hidden)]
    pub service_name: std::option::Option<std::string::String>,
    /// <p>Information about the service discovery registries to assign to the service.</p>
    #[doc(hidden)]
    pub service_registries:
        std::option::Option<std::vec::Vec<crate::types::AwsEcsServiceServiceRegistriesDetails>>,
    /// <p>The task definition to use for tasks in the service.</p>
    #[doc(hidden)]
    pub task_definition: std::option::Option<std::string::String>,
}
impl AwsEcsServiceDetails {
    /// <p>The capacity provider strategy that the service uses.</p>
    pub fn capacity_provider_strategy(
        &self,
    ) -> std::option::Option<&[crate::types::AwsEcsServiceCapacityProviderStrategyDetails]> {
        self.capacity_provider_strategy.as_deref()
    }
    /// <p>The ARN of the cluster that hosts the service.</p>
    pub fn cluster(&self) -> std::option::Option<&str> {
        self.cluster.as_deref()
    }
    /// <p>Deployment parameters for the service. Includes the number of tasks that run and the order in which to start and stop tasks.</p>
    pub fn deployment_configuration(
        &self,
    ) -> std::option::Option<&crate::types::AwsEcsServiceDeploymentConfigurationDetails> {
        self.deployment_configuration.as_ref()
    }
    /// <p>Contains the deployment controller type that the service uses.</p>
    pub fn deployment_controller(
        &self,
    ) -> std::option::Option<&crate::types::AwsEcsServiceDeploymentControllerDetails> {
        self.deployment_controller.as_ref()
    }
    /// <p>The number of instantiations of the task definition to run on the service.</p>
    pub fn desired_count(&self) -> i32 {
        self.desired_count
    }
    /// <p>Whether to enable Amazon ECS managed tags for the tasks in the service.</p>
    pub fn enable_ecs_managed_tags(&self) -> bool {
        self.enable_ecs_managed_tags
    }
    /// <p>Whether the execute command functionality is enabled for the service.</p>
    pub fn enable_execute_command(&self) -> bool {
        self.enable_execute_command
    }
    /// <p>After a task starts, the amount of time in seconds that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks.</p>
    pub fn health_check_grace_period_seconds(&self) -> i32 {
        self.health_check_grace_period_seconds
    }
    /// <p>The launch type that the service uses.</p>
    /// <p>Valid values: <code>EC2</code> | <code>FARGATE</code> | <code>EXTERNAL</code> </p>
    pub fn launch_type(&self) -> std::option::Option<&str> {
        self.launch_type.as_deref()
    }
    /// <p>Information about the load balancers that the service uses.</p>
    pub fn load_balancers(
        &self,
    ) -> std::option::Option<&[crate::types::AwsEcsServiceLoadBalancersDetails]> {
        self.load_balancers.as_deref()
    }
    /// <p>The name of the service.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>For tasks that use the <code>awsvpc</code> networking mode, the VPC subnet and security group configuration.</p>
    pub fn network_configuration(
        &self,
    ) -> std::option::Option<&crate::types::AwsEcsServiceNetworkConfigurationDetails> {
        self.network_configuration.as_ref()
    }
    /// <p>The placement constraints for the tasks in the service.</p>
    pub fn placement_constraints(
        &self,
    ) -> std::option::Option<&[crate::types::AwsEcsServicePlacementConstraintsDetails]> {
        self.placement_constraints.as_deref()
    }
    /// <p>Information about how tasks for the service are placed.</p>
    pub fn placement_strategies(
        &self,
    ) -> std::option::Option<&[crate::types::AwsEcsServicePlacementStrategiesDetails]> {
        self.placement_strategies.as_deref()
    }
    /// <p>The platform version on which to run the service. Only specified for tasks that are hosted on Fargate. If a platform version is not specified, the <code>LATEST</code> platform version is used by default.</p>
    pub fn platform_version(&self) -> std::option::Option<&str> {
        self.platform_version.as_deref()
    }
    /// <p>Indicates whether to propagate the tags from the task definition to the task or from the service to the task. If no value is provided, then tags are not propagated.</p>
    /// <p>Valid values: <code>TASK_DEFINITION</code> | <code>SERVICE</code> </p>
    pub fn propagate_tags(&self) -> std::option::Option<&str> {
        self.propagate_tags.as_deref()
    }
    /// <p>The ARN of the IAM role that is associated with the service. The role allows the Amazon ECS container agent to register container instances with an Elastic Load Balancing load balancer.</p>
    pub fn role(&self) -> std::option::Option<&str> {
        self.role.as_deref()
    }
    /// <p>The scheduling strategy to use for the service.</p>
    /// <p>The <code>REPLICA</code> scheduling strategy places and maintains the desired number of tasks across the cluster. By default, the service scheduler spreads tasks across Availability Zones. Task placement strategies and constraints are used to customize task placement decisions.</p>
    /// <p>The <code>DAEMON</code> scheduling strategy deploys exactly one task on each active container instance that meets all of the task placement constraints that are specified in the cluster. The service scheduler also evaluates the task placement constraints for running tasks and stops tasks that do not meet the placement constraints.</p>
    /// <p>Valid values: <code>REPLICA</code> | <code>DAEMON</code> </p>
    pub fn scheduling_strategy(&self) -> std::option::Option<&str> {
        self.scheduling_strategy.as_deref()
    }
    /// <p>The ARN of the service.</p>
    pub fn service_arn(&self) -> std::option::Option<&str> {
        self.service_arn.as_deref()
    }
    /// <p>The name of the service.</p>
    /// <p>The name can contain up to 255 characters. It can use letters, numbers, underscores, and hyphens.</p>
    pub fn service_name(&self) -> std::option::Option<&str> {
        self.service_name.as_deref()
    }
    /// <p>Information about the service discovery registries to assign to the service.</p>
    pub fn service_registries(
        &self,
    ) -> std::option::Option<&[crate::types::AwsEcsServiceServiceRegistriesDetails]> {
        self.service_registries.as_deref()
    }
    /// <p>The task definition to use for tasks in the service.</p>
    pub fn task_definition(&self) -> std::option::Option<&str> {
        self.task_definition.as_deref()
    }
}
impl AwsEcsServiceDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsServiceDetails`](crate::types::AwsEcsServiceDetails).
    pub fn builder() -> crate::types::builders::AwsEcsServiceDetailsBuilder {
        crate::types::builders::AwsEcsServiceDetailsBuilder::default()
    }
}

/// A builder for [`AwsEcsServiceDetails`](crate::types::AwsEcsServiceDetails).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct AwsEcsServiceDetailsBuilder {
    pub(crate) capacity_provider_strategy: std::option::Option<
        std::vec::Vec<crate::types::AwsEcsServiceCapacityProviderStrategyDetails>,
    >,
    pub(crate) cluster: std::option::Option<std::string::String>,
    pub(crate) deployment_configuration:
        std::option::Option<crate::types::AwsEcsServiceDeploymentConfigurationDetails>,
    pub(crate) deployment_controller:
        std::option::Option<crate::types::AwsEcsServiceDeploymentControllerDetails>,
    pub(crate) desired_count: std::option::Option<i32>,
    pub(crate) enable_ecs_managed_tags: std::option::Option<bool>,
    pub(crate) enable_execute_command: std::option::Option<bool>,
    pub(crate) health_check_grace_period_seconds: std::option::Option<i32>,
    pub(crate) launch_type: std::option::Option<std::string::String>,
    pub(crate) load_balancers:
        std::option::Option<std::vec::Vec<crate::types::AwsEcsServiceLoadBalancersDetails>>,
    pub(crate) name: std::option::Option<std::string::String>,
    pub(crate) network_configuration:
        std::option::Option<crate::types::AwsEcsServiceNetworkConfigurationDetails>,
    pub(crate) placement_constraints:
        std::option::Option<std::vec::Vec<crate::types::AwsEcsServicePlacementConstraintsDetails>>,
    pub(crate) placement_strategies:
        std::option::Option<std::vec::Vec<crate::types::AwsEcsServicePlacementStrategiesDetails>>,
    pub(crate) platform_version: std::option::Option<std::string::String>,
    pub(crate) propagate_tags: std::option::Option<std::string::String>,
    pub(crate) role: std::option::Option<std::string::String>,
    pub(crate) scheduling_strategy: std::option::Option<std::string::String>,
    pub(crate) service_arn: std::option::Option<std::string::String>,
    pub(crate) service_name: std::option::Option<std::string::String>,
    pub(crate) service_registries:
        std::option::Option<std::vec::Vec<crate::types::AwsEcsServiceServiceRegistriesDetails>>,
    pub(crate) task_definition: std::option::Option<std::string::String>,
}
impl AwsEcsServiceDetailsBuilder {
    /// Appends an item to `capacity_provider_strategy`.
    ///
    /// To override the contents of this collection use [`set_capacity_provider_strategy`](Self::set_capacity_provider_strategy).
    ///
    /// <p>The capacity provider strategy that the service uses.</p>
    pub fn capacity_provider_strategy(
        mut self,
        input: crate::types::AwsEcsServiceCapacityProviderStrategyDetails,
    ) -> Self {
        let mut v = self.capacity_provider_strategy.unwrap_or_default();
        v.push(input);
        self.capacity_provider_strategy = Some(v);
        self
    }
    /// <p>The capacity provider strategy that the service uses.</p>
    pub fn set_capacity_provider_strategy(
        mut self,
        input: std::option::Option<
            std::vec::Vec<crate::types::AwsEcsServiceCapacityProviderStrategyDetails>,
        >,
    ) -> Self {
        self.capacity_provider_strategy = input;
        self
    }
    /// <p>The ARN of the cluster that hosts the service.</p>
    pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
        self.cluster = Some(input.into());
        self
    }
    /// <p>The ARN of the cluster that hosts the service.</p>
    pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.cluster = input;
        self
    }
    /// <p>Deployment parameters for the service. Includes the number of tasks that run and the order in which to start and stop tasks.</p>
    pub fn deployment_configuration(
        mut self,
        input: crate::types::AwsEcsServiceDeploymentConfigurationDetails,
    ) -> Self {
        self.deployment_configuration = Some(input);
        self
    }
    /// <p>Deployment parameters for the service. Includes the number of tasks that run and the order in which to start and stop tasks.</p>
    pub fn set_deployment_configuration(
        mut self,
        input: std::option::Option<crate::types::AwsEcsServiceDeploymentConfigurationDetails>,
    ) -> Self {
        self.deployment_configuration = input;
        self
    }
    /// <p>Contains the deployment controller type that the service uses.</p>
    pub fn deployment_controller(
        mut self,
        input: crate::types::AwsEcsServiceDeploymentControllerDetails,
    ) -> Self {
        self.deployment_controller = Some(input);
        self
    }
    /// <p>Contains the deployment controller type that the service uses.</p>
    pub fn set_deployment_controller(
        mut self,
        input: std::option::Option<crate::types::AwsEcsServiceDeploymentControllerDetails>,
    ) -> Self {
        self.deployment_controller = input;
        self
    }
    /// <p>The number of instantiations of the task definition to run on the service.</p>
    pub fn desired_count(mut self, input: i32) -> Self {
        self.desired_count = Some(input);
        self
    }
    /// <p>The number of instantiations of the task definition to run on the service.</p>
    pub fn set_desired_count(mut self, input: std::option::Option<i32>) -> Self {
        self.desired_count = input;
        self
    }
    /// <p>Whether to enable Amazon ECS managed tags for the tasks in the service.</p>
    pub fn enable_ecs_managed_tags(mut self, input: bool) -> Self {
        self.enable_ecs_managed_tags = Some(input);
        self
    }
    /// <p>Whether to enable Amazon ECS managed tags for the tasks in the service.</p>
    pub fn set_enable_ecs_managed_tags(mut self, input: std::option::Option<bool>) -> Self {
        self.enable_ecs_managed_tags = input;
        self
    }
    /// <p>Whether the execute command functionality is enabled for the service.</p>
    pub fn enable_execute_command(mut self, input: bool) -> Self {
        self.enable_execute_command = Some(input);
        self
    }
    /// <p>Whether the execute command functionality is enabled for the service.</p>
    pub fn set_enable_execute_command(mut self, input: std::option::Option<bool>) -> Self {
        self.enable_execute_command = input;
        self
    }
    /// <p>After a task starts, the amount of time in seconds that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks.</p>
    pub fn health_check_grace_period_seconds(mut self, input: i32) -> Self {
        self.health_check_grace_period_seconds = Some(input);
        self
    }
    /// <p>After a task starts, the amount of time in seconds that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks.</p>
    pub fn set_health_check_grace_period_seconds(
        mut self,
        input: std::option::Option<i32>,
    ) -> Self {
        self.health_check_grace_period_seconds = input;
        self
    }
    /// <p>The launch type that the service uses.</p>
    /// <p>Valid values: <code>EC2</code> | <code>FARGATE</code> | <code>EXTERNAL</code> </p>
    pub fn launch_type(mut self, input: impl Into<std::string::String>) -> Self {
        self.launch_type = Some(input.into());
        self
    }
    /// <p>The launch type that the service uses.</p>
    /// <p>Valid values: <code>EC2</code> | <code>FARGATE</code> | <code>EXTERNAL</code> </p>
    pub fn set_launch_type(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.launch_type = input;
        self
    }
    /// Appends an item to `load_balancers`.
    ///
    /// To override the contents of this collection use [`set_load_balancers`](Self::set_load_balancers).
    ///
    /// <p>Information about the load balancers that the service uses.</p>
    pub fn load_balancers(
        mut self,
        input: crate::types::AwsEcsServiceLoadBalancersDetails,
    ) -> Self {
        let mut v = self.load_balancers.unwrap_or_default();
        v.push(input);
        self.load_balancers = Some(v);
        self
    }
    /// <p>Information about the load balancers that the service uses.</p>
    pub fn set_load_balancers(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::AwsEcsServiceLoadBalancersDetails>>,
    ) -> Self {
        self.load_balancers = input;
        self
    }
    /// <p>The name of the service.</p>
    pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
        self.name = Some(input.into());
        self
    }
    /// <p>The name of the service.</p>
    pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>For tasks that use the <code>awsvpc</code> networking mode, the VPC subnet and security group configuration.</p>
    pub fn network_configuration(
        mut self,
        input: crate::types::AwsEcsServiceNetworkConfigurationDetails,
    ) -> Self {
        self.network_configuration = Some(input);
        self
    }
    /// <p>For tasks that use the <code>awsvpc</code> networking mode, the VPC subnet and security group configuration.</p>
    pub fn set_network_configuration(
        mut self,
        input: std::option::Option<crate::types::AwsEcsServiceNetworkConfigurationDetails>,
    ) -> Self {
        self.network_configuration = input;
        self
    }
    /// Appends an item to `placement_constraints`.
    ///
    /// To override the contents of this collection use [`set_placement_constraints`](Self::set_placement_constraints).
    ///
    /// <p>The placement constraints for the tasks in the service.</p>
    pub fn placement_constraints(
        mut self,
        input: crate::types::AwsEcsServicePlacementConstraintsDetails,
    ) -> Self {
        let mut v = self.placement_constraints.unwrap_or_default();
        v.push(input);
        self.placement_constraints = Some(v);
        self
    }
    /// <p>The placement constraints for the tasks in the service.</p>
    pub fn set_placement_constraints(
        mut self,
        input: std::option::Option<
            std::vec::Vec<crate::types::AwsEcsServicePlacementConstraintsDetails>,
        >,
    ) -> Self {
        self.placement_constraints = input;
        self
    }
    /// Appends an item to `placement_strategies`.
    ///
    /// To override the contents of this collection use [`set_placement_strategies`](Self::set_placement_strategies).
    ///
    /// <p>Information about how tasks for the service are placed.</p>
    pub fn placement_strategies(
        mut self,
        input: crate::types::AwsEcsServicePlacementStrategiesDetails,
    ) -> Self {
        let mut v = self.placement_strategies.unwrap_or_default();
        v.push(input);
        self.placement_strategies = Some(v);
        self
    }
    /// <p>Information about how tasks for the service are placed.</p>
    pub fn set_placement_strategies(
        mut self,
        input: std::option::Option<
            std::vec::Vec<crate::types::AwsEcsServicePlacementStrategiesDetails>,
        >,
    ) -> Self {
        self.placement_strategies = input;
        self
    }
    /// <p>The platform version on which to run the service. Only specified for tasks that are hosted on Fargate. If a platform version is not specified, the <code>LATEST</code> platform version is used by default.</p>
    pub fn platform_version(mut self, input: impl Into<std::string::String>) -> Self {
        self.platform_version = Some(input.into());
        self
    }
    /// <p>The platform version on which to run the service. Only specified for tasks that are hosted on Fargate. If a platform version is not specified, the <code>LATEST</code> platform version is used by default.</p>
    pub fn set_platform_version(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.platform_version = input;
        self
    }
    /// <p>Indicates whether to propagate the tags from the task definition to the task or from the service to the task. If no value is provided, then tags are not propagated.</p>
    /// <p>Valid values: <code>TASK_DEFINITION</code> | <code>SERVICE</code> </p>
    pub fn propagate_tags(mut self, input: impl Into<std::string::String>) -> Self {
        self.propagate_tags = Some(input.into());
        self
    }
    /// <p>Indicates whether to propagate the tags from the task definition to the task or from the service to the task. If no value is provided, then tags are not propagated.</p>
    /// <p>Valid values: <code>TASK_DEFINITION</code> | <code>SERVICE</code> </p>
    pub fn set_propagate_tags(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.propagate_tags = input;
        self
    }
    /// <p>The ARN of the IAM role that is associated with the service. The role allows the Amazon ECS container agent to register container instances with an Elastic Load Balancing load balancer.</p>
    pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
        self.role = Some(input.into());
        self
    }
    /// <p>The ARN of the IAM role that is associated with the service. The role allows the Amazon ECS container agent to register container instances with an Elastic Load Balancing load balancer.</p>
    pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.role = input;
        self
    }
    /// <p>The scheduling strategy to use for the service.</p>
    /// <p>The <code>REPLICA</code> scheduling strategy places and maintains the desired number of tasks across the cluster. By default, the service scheduler spreads tasks across Availability Zones. Task placement strategies and constraints are used to customize task placement decisions.</p>
    /// <p>The <code>DAEMON</code> scheduling strategy deploys exactly one task on each active container instance that meets all of the task placement constraints that are specified in the cluster. The service scheduler also evaluates the task placement constraints for running tasks and stops tasks that do not meet the placement constraints.</p>
    /// <p>Valid values: <code>REPLICA</code> | <code>DAEMON</code> </p>
    pub fn scheduling_strategy(mut self, input: impl Into<std::string::String>) -> Self {
        self.scheduling_strategy = Some(input.into());
        self
    }
    /// <p>The scheduling strategy to use for the service.</p>
    /// <p>The <code>REPLICA</code> scheduling strategy places and maintains the desired number of tasks across the cluster. By default, the service scheduler spreads tasks across Availability Zones. Task placement strategies and constraints are used to customize task placement decisions.</p>
    /// <p>The <code>DAEMON</code> scheduling strategy deploys exactly one task on each active container instance that meets all of the task placement constraints that are specified in the cluster. The service scheduler also evaluates the task placement constraints for running tasks and stops tasks that do not meet the placement constraints.</p>
    /// <p>Valid values: <code>REPLICA</code> | <code>DAEMON</code> </p>
    pub fn set_scheduling_strategy(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.scheduling_strategy = input;
        self
    }
    /// <p>The ARN of the service.</p>
    pub fn service_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.service_arn = Some(input.into());
        self
    }
    /// <p>The ARN of the service.</p>
    pub fn set_service_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.service_arn = input;
        self
    }
    /// <p>The name of the service.</p>
    /// <p>The name can contain up to 255 characters. It can use letters, numbers, underscores, and hyphens.</p>
    pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.service_name = Some(input.into());
        self
    }
    /// <p>The name of the service.</p>
    /// <p>The name can contain up to 255 characters. It can use letters, numbers, underscores, and hyphens.</p>
    pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.service_name = input;
        self
    }
    /// Appends an item to `service_registries`.
    ///
    /// To override the contents of this collection use [`set_service_registries`](Self::set_service_registries).
    ///
    /// <p>Information about the service discovery registries to assign to the service.</p>
    pub fn service_registries(
        mut self,
        input: crate::types::AwsEcsServiceServiceRegistriesDetails,
    ) -> Self {
        let mut v = self.service_registries.unwrap_or_default();
        v.push(input);
        self.service_registries = Some(v);
        self
    }
    /// <p>Information about the service discovery registries to assign to the service.</p>
    pub fn set_service_registries(
        mut self,
        input: std::option::Option<
            std::vec::Vec<crate::types::AwsEcsServiceServiceRegistriesDetails>,
        >,
    ) -> Self {
        self.service_registries = input;
        self
    }
    /// <p>The task definition to use for tasks in the service.</p>
    pub fn task_definition(mut self, input: impl Into<std::string::String>) -> Self {
        self.task_definition = Some(input.into());
        self
    }
    /// <p>The task definition to use for tasks in the service.</p>
    pub fn set_task_definition(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.task_definition = input;
        self
    }
    /// Consumes the builder and constructs a [`AwsEcsServiceDetails`](crate::types::AwsEcsServiceDetails).
    pub fn build(self) -> crate::types::AwsEcsServiceDetails {
        crate::types::AwsEcsServiceDetails {
            capacity_provider_strategy: self.capacity_provider_strategy,
            cluster: self.cluster,
            deployment_configuration: self.deployment_configuration,
            deployment_controller: self.deployment_controller,
            desired_count: self.desired_count.unwrap_or_default(),
            enable_ecs_managed_tags: self.enable_ecs_managed_tags.unwrap_or_default(),
            enable_execute_command: self.enable_execute_command.unwrap_or_default(),
            health_check_grace_period_seconds: self
                .health_check_grace_period_seconds
                .unwrap_or_default(),
            launch_type: self.launch_type,
            load_balancers: self.load_balancers,
            name: self.name,
            network_configuration: self.network_configuration,
            placement_constraints: self.placement_constraints,
            placement_strategies: self.placement_strategies,
            platform_version: self.platform_version,
            propagate_tags: self.propagate_tags,
            role: self.role,
            scheduling_strategy: self.scheduling_strategy,
            service_arn: self.service_arn,
            service_name: self.service_name,
            service_registries: self.service_registries,
            task_definition: self.task_definition,
        }
    }
}
