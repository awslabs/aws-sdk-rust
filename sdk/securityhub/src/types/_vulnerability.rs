// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A vulnerability associated with a finding.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Vulnerability {
    /// <p>The identifier of the vulnerability.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>List of software packages that have the vulnerability.</p>
    #[doc(hidden)]
    pub vulnerable_packages: std::option::Option<std::vec::Vec<crate::types::SoftwarePackage>>,
    /// <p>CVSS scores from the advisory related to the vulnerability.</p>
    #[doc(hidden)]
    pub cvss: std::option::Option<std::vec::Vec<crate::types::Cvss>>,
    /// <p>List of vulnerabilities that are related to this vulnerability.</p>
    #[doc(hidden)]
    pub related_vulnerabilities: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Information about the vendor that generates the vulnerability report.</p>
    #[doc(hidden)]
    pub vendor: std::option::Option<crate::types::VulnerabilityVendor>,
    /// <p>A list of URLs that provide additional information about the vulnerability.</p>
    #[doc(hidden)]
    pub reference_urls: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies if all vulnerable packages in a finding have a value for <code>FixedInVersion</code> and <code>Remediation</code>. This field is evaluated for each vulnerability <code>Id</code> based on the number of vulnerable packages that have a value for both <code>FixedInVersion</code> and <code>Remediation</code>. Valid values are as follows:</p>
    /// <ul>
    /// <li> <p> <code>YES</code> if all vulnerable packages have a value for both <code>FixedInVersion</code> and <code>Remediation</code> </p> </li>
    /// <li> <p> <code>NO</code> if no vulnerable packages have a value for <code>FixedInVersion</code> and <code>Remediation</code> </p> </li>
    /// <li> <p> <code>PARTIAL</code> otherwise</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub fix_available: std::option::Option<crate::types::VulnerabilityFixAvailable>,
}
impl Vulnerability {
    /// <p>The identifier of the vulnerability.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>List of software packages that have the vulnerability.</p>
    pub fn vulnerable_packages(&self) -> std::option::Option<&[crate::types::SoftwarePackage]> {
        self.vulnerable_packages.as_deref()
    }
    /// <p>CVSS scores from the advisory related to the vulnerability.</p>
    pub fn cvss(&self) -> std::option::Option<&[crate::types::Cvss]> {
        self.cvss.as_deref()
    }
    /// <p>List of vulnerabilities that are related to this vulnerability.</p>
    pub fn related_vulnerabilities(&self) -> std::option::Option<&[std::string::String]> {
        self.related_vulnerabilities.as_deref()
    }
    /// <p>Information about the vendor that generates the vulnerability report.</p>
    pub fn vendor(&self) -> std::option::Option<&crate::types::VulnerabilityVendor> {
        self.vendor.as_ref()
    }
    /// <p>A list of URLs that provide additional information about the vulnerability.</p>
    pub fn reference_urls(&self) -> std::option::Option<&[std::string::String]> {
        self.reference_urls.as_deref()
    }
    /// <p>Specifies if all vulnerable packages in a finding have a value for <code>FixedInVersion</code> and <code>Remediation</code>. This field is evaluated for each vulnerability <code>Id</code> based on the number of vulnerable packages that have a value for both <code>FixedInVersion</code> and <code>Remediation</code>. Valid values are as follows:</p>
    /// <ul>
    /// <li> <p> <code>YES</code> if all vulnerable packages have a value for both <code>FixedInVersion</code> and <code>Remediation</code> </p> </li>
    /// <li> <p> <code>NO</code> if no vulnerable packages have a value for <code>FixedInVersion</code> and <code>Remediation</code> </p> </li>
    /// <li> <p> <code>PARTIAL</code> otherwise</p> </li>
    /// </ul>
    pub fn fix_available(&self) -> std::option::Option<&crate::types::VulnerabilityFixAvailable> {
        self.fix_available.as_ref()
    }
}
impl Vulnerability {
    /// Creates a new builder-style object to manufacture [`Vulnerability`](crate::types::Vulnerability).
    pub fn builder() -> crate::types::builders::VulnerabilityBuilder {
        crate::types::builders::VulnerabilityBuilder::default()
    }
}

/// A builder for [`Vulnerability`](crate::types::Vulnerability).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct VulnerabilityBuilder {
    pub(crate) id: std::option::Option<std::string::String>,
    pub(crate) vulnerable_packages:
        std::option::Option<std::vec::Vec<crate::types::SoftwarePackage>>,
    pub(crate) cvss: std::option::Option<std::vec::Vec<crate::types::Cvss>>,
    pub(crate) related_vulnerabilities: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) vendor: std::option::Option<crate::types::VulnerabilityVendor>,
    pub(crate) reference_urls: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) fix_available: std::option::Option<crate::types::VulnerabilityFixAvailable>,
}
impl VulnerabilityBuilder {
    /// <p>The identifier of the vulnerability.</p>
    pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
        self.id = Some(input.into());
        self
    }
    /// <p>The identifier of the vulnerability.</p>
    pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.id = input;
        self
    }
    /// Appends an item to `vulnerable_packages`.
    ///
    /// To override the contents of this collection use [`set_vulnerable_packages`](Self::set_vulnerable_packages).
    ///
    /// <p>List of software packages that have the vulnerability.</p>
    pub fn vulnerable_packages(mut self, input: crate::types::SoftwarePackage) -> Self {
        let mut v = self.vulnerable_packages.unwrap_or_default();
        v.push(input);
        self.vulnerable_packages = Some(v);
        self
    }
    /// <p>List of software packages that have the vulnerability.</p>
    pub fn set_vulnerable_packages(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::SoftwarePackage>>,
    ) -> Self {
        self.vulnerable_packages = input;
        self
    }
    /// Appends an item to `cvss`.
    ///
    /// To override the contents of this collection use [`set_cvss`](Self::set_cvss).
    ///
    /// <p>CVSS scores from the advisory related to the vulnerability.</p>
    pub fn cvss(mut self, input: crate::types::Cvss) -> Self {
        let mut v = self.cvss.unwrap_or_default();
        v.push(input);
        self.cvss = Some(v);
        self
    }
    /// <p>CVSS scores from the advisory related to the vulnerability.</p>
    pub fn set_cvss(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::Cvss>>,
    ) -> Self {
        self.cvss = input;
        self
    }
    /// Appends an item to `related_vulnerabilities`.
    ///
    /// To override the contents of this collection use [`set_related_vulnerabilities`](Self::set_related_vulnerabilities).
    ///
    /// <p>List of vulnerabilities that are related to this vulnerability.</p>
    pub fn related_vulnerabilities(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.related_vulnerabilities.unwrap_or_default();
        v.push(input.into());
        self.related_vulnerabilities = Some(v);
        self
    }
    /// <p>List of vulnerabilities that are related to this vulnerability.</p>
    pub fn set_related_vulnerabilities(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.related_vulnerabilities = input;
        self
    }
    /// <p>Information about the vendor that generates the vulnerability report.</p>
    pub fn vendor(mut self, input: crate::types::VulnerabilityVendor) -> Self {
        self.vendor = Some(input);
        self
    }
    /// <p>Information about the vendor that generates the vulnerability report.</p>
    pub fn set_vendor(
        mut self,
        input: std::option::Option<crate::types::VulnerabilityVendor>,
    ) -> Self {
        self.vendor = input;
        self
    }
    /// Appends an item to `reference_urls`.
    ///
    /// To override the contents of this collection use [`set_reference_urls`](Self::set_reference_urls).
    ///
    /// <p>A list of URLs that provide additional information about the vulnerability.</p>
    pub fn reference_urls(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.reference_urls.unwrap_or_default();
        v.push(input.into());
        self.reference_urls = Some(v);
        self
    }
    /// <p>A list of URLs that provide additional information about the vulnerability.</p>
    pub fn set_reference_urls(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.reference_urls = input;
        self
    }
    /// <p>Specifies if all vulnerable packages in a finding have a value for <code>FixedInVersion</code> and <code>Remediation</code>. This field is evaluated for each vulnerability <code>Id</code> based on the number of vulnerable packages that have a value for both <code>FixedInVersion</code> and <code>Remediation</code>. Valid values are as follows:</p>
    /// <ul>
    /// <li> <p> <code>YES</code> if all vulnerable packages have a value for both <code>FixedInVersion</code> and <code>Remediation</code> </p> </li>
    /// <li> <p> <code>NO</code> if no vulnerable packages have a value for <code>FixedInVersion</code> and <code>Remediation</code> </p> </li>
    /// <li> <p> <code>PARTIAL</code> otherwise</p> </li>
    /// </ul>
    pub fn fix_available(mut self, input: crate::types::VulnerabilityFixAvailable) -> Self {
        self.fix_available = Some(input);
        self
    }
    /// <p>Specifies if all vulnerable packages in a finding have a value for <code>FixedInVersion</code> and <code>Remediation</code>. This field is evaluated for each vulnerability <code>Id</code> based on the number of vulnerable packages that have a value for both <code>FixedInVersion</code> and <code>Remediation</code>. Valid values are as follows:</p>
    /// <ul>
    /// <li> <p> <code>YES</code> if all vulnerable packages have a value for both <code>FixedInVersion</code> and <code>Remediation</code> </p> </li>
    /// <li> <p> <code>NO</code> if no vulnerable packages have a value for <code>FixedInVersion</code> and <code>Remediation</code> </p> </li>
    /// <li> <p> <code>PARTIAL</code> otherwise</p> </li>
    /// </ul>
    pub fn set_fix_available(
        mut self,
        input: std::option::Option<crate::types::VulnerabilityFixAvailable>,
    ) -> Self {
        self.fix_available = input;
        self
    }
    /// Consumes the builder and constructs a [`Vulnerability`](crate::types::Vulnerability).
    pub fn build(self) -> crate::types::Vulnerability {
        crate::types::Vulnerability {
            id: self.id,
            vulnerable_packages: self.vulnerable_packages,
            cvss: self.cvss,
            related_vulnerabilities: self.related_vulnerabilities,
            vendor: self.vendor,
            reference_urls: self.reference_urls,
            fix_available: self.fix_available,
        }
    }
}
