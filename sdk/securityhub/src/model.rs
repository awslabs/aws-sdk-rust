// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ControlStatus {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ControlStatus {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => ControlStatus::Disabled,
            "ENABLED" => ControlStatus::Enabled,
            other => ControlStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ControlStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ControlStatus::from(s))
    }
}
impl ControlStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ControlStatus::Disabled => "DISABLED",
            ControlStatus::Enabled => "ENABLED",
            ControlStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for ControlStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoEnableStandards {
    #[allow(missing_docs)] // documentation missing in model
    Default,
    #[allow(missing_docs)] // documentation missing in model
    None,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutoEnableStandards {
    fn from(s: &str) -> Self {
        match s {
            "DEFAULT" => AutoEnableStandards::Default,
            "NONE" => AutoEnableStandards::None,
            other => AutoEnableStandards::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutoEnableStandards {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoEnableStandards::from(s))
    }
}
impl AutoEnableStandards {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AutoEnableStandards::Default => "DEFAULT",
            AutoEnableStandards::None => "NONE",
            AutoEnableStandards::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["DEFAULT", "NONE"]
    }
}
impl AsRef<str> for AutoEnableStandards {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A collection of attributes that are applied to all active Security Hub-aggregated findings and that result in a subset of findings that are included in this insight.</p>
/// <p>You can filter by up to 10 finding attributes. For each attribute, you can provide up to 20 filter values.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsSecurityFindingFilters {
    /// <p>The ARN generated by Security Hub that uniquely identifies a third-party company (security findings provider) after this provider's product (solution that generates findings) is registered with Security Hub.</p>
    pub product_arn: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The Amazon Web Services account ID that a finding is generated in.</p>
    pub aws_account_id: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The security findings provider-specific identifier for a finding.</p>
    pub id: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. In various security-findings providers' solutions, this generator can be called a rule, a check, a detector, a plugin, etc.</p>
    pub generator_id: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The Region from which the finding was generated.</p>
    pub region: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>A finding type in the format of <code>namespace/category/classifier</code> that classifies a finding.</p>
    pub r#type: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>An ISO8601-formatted timestamp that indicates when the security-findings provider first observed the potential security issue that a finding captured.</p>
    pub first_observed_at: std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
    /// <p>An ISO8601-formatted timestamp that indicates when the security-findings provider most recently observed the potential security issue that a finding captured.</p>
    pub last_observed_at: std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
    /// <p>An ISO8601-formatted timestamp that indicates when the security-findings provider captured the potential security issue that a finding captured.</p>
    pub created_at: std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
    /// <p>An ISO8601-formatted timestamp that indicates when the security-findings provider last updated the finding record. </p>
    pub updated_at: std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
    /// <p>The native severity as defined by the security-findings provider's solution that generated the finding.</p>
    pub severity_product: std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
    /// <p>The normalized severity of a finding.</p>
    pub severity_normalized: std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
    /// <p>The label of a finding's severity.</p>
    pub severity_label: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify.</p>
    /// <p>Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.</p>
    pub confidence: std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
    /// <p>The level of importance assigned to the resources associated with the finding.</p>
    /// <p>A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.</p>
    pub criticality: std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
    /// <p>A finding's title.</p>
    pub title: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>A finding's description.</p>
    pub description: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The recommendation of what to do about the issue described in a finding.</p>
    pub recommendation_text: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>A URL that links to a page about the current finding in the security-findings provider's solution.</p>
    pub source_url: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>A data type where security-findings providers can include additional solution-specific details that aren't part of the defined <code>AwsSecurityFinding</code> format.</p>
    pub product_fields: std::option::Option<std::vec::Vec<crate::model::MapFilter>>,
    /// <p>The name of the solution (product) that generates findings.</p>
    pub product_name: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The name of the findings provider (company) that owns the solution (product) that generates findings.</p>
    pub company_name: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding. </p>
    pub user_defined_fields: std::option::Option<std::vec::Vec<crate::model::MapFilter>>,
    /// <p>The name of the malware that was observed.</p>
    pub malware_name: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The type of the malware that was observed.</p>
    pub malware_type: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The filesystem path of the malware that was observed.</p>
    pub malware_path: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The state of the malware that was observed.</p>
    pub malware_state: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>Indicates the direction of network traffic associated with a finding.</p>
    pub network_direction: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The protocol of network-related information about a finding.</p>
    pub network_protocol: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The source IPv4 address of network-related information about a finding.</p>
    pub network_source_ip_v4: std::option::Option<std::vec::Vec<crate::model::IpFilter>>,
    /// <p>The source IPv6 address of network-related information about a finding.</p>
    pub network_source_ip_v6: std::option::Option<std::vec::Vec<crate::model::IpFilter>>,
    /// <p>The source port of network-related information about a finding.</p>
    pub network_source_port: std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
    /// <p>The source domain of network-related information about a finding.</p>
    pub network_source_domain: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The source media access control (MAC) address of network-related information about a finding.</p>
    pub network_source_mac: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The destination IPv4 address of network-related information about a finding.</p>
    pub network_destination_ip_v4: std::option::Option<std::vec::Vec<crate::model::IpFilter>>,
    /// <p>The destination IPv6 address of network-related information about a finding.</p>
    pub network_destination_ip_v6: std::option::Option<std::vec::Vec<crate::model::IpFilter>>,
    /// <p>The destination port of network-related information about a finding.</p>
    pub network_destination_port: std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
    /// <p>The destination domain of network-related information about a finding.</p>
    pub network_destination_domain: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The name of the process.</p>
    pub process_name: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The path to the process executable.</p>
    pub process_path: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The process ID.</p>
    pub process_pid: std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
    /// <p>The parent process ID.</p>
    pub process_parent_pid: std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
    /// <p>The date/time that the process was launched.</p>
    pub process_launched_at: std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
    /// <p>The date/time that the process was terminated.</p>
    pub process_terminated_at: std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
    /// <p>The type of a threat intelligence indicator.</p>
    pub threat_intel_indicator_type: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The value of a threat intelligence indicator.</p>
    pub threat_intel_indicator_value:
        std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The category of a threat intelligence indicator.</p>
    pub threat_intel_indicator_category:
        std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The date/time of the last observation of a threat intelligence indicator.</p>
    pub threat_intel_indicator_last_observed_at:
        std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
    /// <p>The source of the threat intelligence.</p>
    pub threat_intel_indicator_source:
        std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The URL for more details from the source of the threat intelligence.</p>
    pub threat_intel_indicator_source_url:
        std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>Specifies the type of the resource that details are provided for.</p>
    pub resource_type: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The canonical identifier for the given resource type.</p>
    pub resource_id: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The canonical Amazon Web Services partition name that the Region is assigned to.</p>
    pub resource_partition: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The canonical Amazon Web Services external Region name where this resource is located.</p>
    pub resource_region: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>A list of Amazon Web Services tags associated with a resource at the time the finding was processed.</p>
    pub resource_tags: std::option::Option<std::vec::Vec<crate::model::MapFilter>>,
    /// <p>The instance type of the instance.</p>
    pub resource_aws_ec2_instance_type:
        std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The Amazon Machine Image (AMI) ID of the instance.</p>
    pub resource_aws_ec2_instance_image_id:
        std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The IPv4 addresses associated with the instance.</p>
    pub resource_aws_ec2_instance_ip_v4_addresses:
        std::option::Option<std::vec::Vec<crate::model::IpFilter>>,
    /// <p>The IPv6 addresses associated with the instance.</p>
    pub resource_aws_ec2_instance_ip_v6_addresses:
        std::option::Option<std::vec::Vec<crate::model::IpFilter>>,
    /// <p>The key name associated with the instance.</p>
    pub resource_aws_ec2_instance_key_name:
        std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The IAM profile ARN of the instance.</p>
    pub resource_aws_ec2_instance_iam_instance_profile_arn:
        std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The identifier of the VPC that the instance was launched in.</p>
    pub resource_aws_ec2_instance_vpc_id:
        std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The identifier of the subnet that the instance was launched in.</p>
    pub resource_aws_ec2_instance_subnet_id:
        std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The date and time the instance was launched.</p>
    pub resource_aws_ec2_instance_launched_at:
        std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
    /// <p>The canonical user ID of the owner of the S3 bucket.</p>
    pub resource_aws_s3_bucket_owner_id:
        std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The display name of the owner of the S3 bucket.</p>
    pub resource_aws_s3_bucket_owner_name:
        std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The user associated with the IAM access key related to a finding.</p>
    pub resource_aws_iam_access_key_user_name:
        std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The name of the principal that is associated with an IAM access key.</p>
    pub resource_aws_iam_access_key_principal_name:
        std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The status of the IAM access key related to a finding.</p>
    pub resource_aws_iam_access_key_status:
        std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The creation date/time of the IAM access key related to a finding.</p>
    pub resource_aws_iam_access_key_created_at:
        std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
    /// <p>The name of an IAM user.</p>
    pub resource_aws_iam_user_user_name:
        std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The name of the container related to a finding.</p>
    pub resource_container_name: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The identifier of the image related to a finding.</p>
    pub resource_container_image_id: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The name of the image related to a finding.</p>
    pub resource_container_image_name:
        std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The date/time that the container was started.</p>
    pub resource_container_launched_at:
        std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
    /// <p>The details of a resource that doesn't have a specific subfield for the resource type defined.</p>
    pub resource_details_other: std::option::Option<std::vec::Vec<crate::model::MapFilter>>,
    /// <p>Exclusive to findings that are generated as the result of a check run against a specific rule in a supported standard, such as CIS Amazon Web Services Foundations. Contains security standard-related finding details.</p>
    pub compliance_status: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The veracity of a finding.</p>
    pub verification_state: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The workflow state of a finding.</p>
    /// <p>Note that this field is deprecated. To search for a finding based on its workflow status, use <code>WorkflowStatus</code>.</p>
    pub workflow_state: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The status of the investigation into a finding. Allowed values are the following.</p>
    /// <ul>
    /// <li> <p> <code>NEW</code> - The initial state of a finding, before it is reviewed.</p> <p>Security Hub also resets the workflow status from <code>NOTIFIED</code> or <code>RESOLVED</code> to <code>NEW</code> in the following cases:</p>
    /// <ul>
    /// <li> <p> <code>RecordState</code> changes from <code>ARCHIVED</code> to <code>ACTIVE</code>.</p> </li>
    /// <li> <p> <code>Compliance.Status</code> changes from <code>PASSED</code> to either <code>WARNING</code>, <code>FAILED</code>, or <code>NOT_AVAILABLE</code>.</p> </li>
    /// </ul> </li>
    /// <li> <p> <code>NOTIFIED</code> - Indicates that the resource owner has been notified about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner.</p> <p>If one of the following occurs, the workflow status is changed automatically from <code>NOTIFIED</code> to <code>NEW</code>:</p>
    /// <ul>
    /// <li> <p> <code>RecordState</code> changes from <code>ARCHIVED</code> to <code>ACTIVE</code>.</p> </li>
    /// <li> <p> <code>Compliance.Status</code> changes from <code>PASSED</code> to <code>FAILED</code>, <code>WARNING</code>, or <code>NOT_AVAILABLE</code>.</p> </li>
    /// </ul> </li>
    /// <li> <p> <code>SUPPRESSED</code> - Indicates that you reviewed the finding and do not believe that any action is needed.</p> <p>The workflow status of a <code>SUPPRESSED</code> finding does not change if <code>RecordState</code> changes from <code>ARCHIVED</code> to <code>ACTIVE</code>.</p> </li>
    /// <li> <p> <code>RESOLVED</code> - The finding was reviewed and remediated and is now considered resolved. </p> <p>The finding remains <code>RESOLVED</code> unless one of the following occurs:</p>
    /// <ul>
    /// <li> <p> <code>RecordState</code> changes from <code>ARCHIVED</code> to <code>ACTIVE</code>.</p> </li>
    /// <li> <p> <code>Compliance.Status</code> changes from <code>PASSED</code> to <code>FAILED</code>, <code>WARNING</code>, or <code>NOT_AVAILABLE</code>.</p> </li>
    /// </ul> <p>In those cases, the workflow status is automatically reset to <code>NEW</code>.</p> <p>For findings from controls, if <code>Compliance.Status</code> is <code>PASSED</code>, then Security Hub automatically sets the workflow status to <code>RESOLVED</code>.</p> </li>
    /// </ul>
    pub workflow_status: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The updated record state for the finding.</p>
    pub record_state: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The ARN of the solution that generated a related finding.</p>
    pub related_findings_product_arn:
        std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The solution-generated identifier for a related finding.</p>
    pub related_findings_id: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The text of a note.</p>
    pub note_text: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The timestamp of when the note was updated.</p>
    pub note_updated_at: std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
    /// <p>The principal that created a note.</p>
    pub note_updated_by: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>A keyword for a finding.</p>
    pub keyword: std::option::Option<std::vec::Vec<crate::model::KeywordFilter>>,
    /// <p>The finding provider value for the finding confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify.</p>
    /// <p>Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.</p>
    pub finding_provider_fields_confidence:
        std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
    /// <p>The finding provider value for the level of importance assigned to the resources associated with the findings.</p>
    /// <p>A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. </p>
    pub finding_provider_fields_criticality:
        std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
    /// <p>The finding identifier of a related finding that is identified by the finding provider.</p>
    pub finding_provider_fields_related_findings_id:
        std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The ARN of the solution that generated a related finding that is identified by the finding provider.</p>
    pub finding_provider_fields_related_findings_product_arn:
        std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The finding provider value for the severity label.</p>
    pub finding_provider_fields_severity_label:
        std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>The finding provider's original value for the severity.</p>
    pub finding_provider_fields_severity_original:
        std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>One or more finding types that the finding provider assigned to the finding. Uses the format of <code>namespace/category/classifier</code> that classify a finding.</p>
    /// <p>Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual Behaviors | Sensitive Data Identifications</p>
    pub finding_provider_fields_types:
        std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
    /// <p>Indicates whether or not sample findings are included in the filter results.</p>
    pub sample: std::option::Option<std::vec::Vec<crate::model::BooleanFilter>>,
}
impl AwsSecurityFindingFilters {
    /// <p>The ARN generated by Security Hub that uniquely identifies a third-party company (security findings provider) after this provider's product (solution that generates findings) is registered with Security Hub.</p>
    pub fn product_arn(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.product_arn.as_deref()
    }
    /// <p>The Amazon Web Services account ID that a finding is generated in.</p>
    pub fn aws_account_id(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.aws_account_id.as_deref()
    }
    /// <p>The security findings provider-specific identifier for a finding.</p>
    pub fn id(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.id.as_deref()
    }
    /// <p>The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. In various security-findings providers' solutions, this generator can be called a rule, a check, a detector, a plugin, etc.</p>
    pub fn generator_id(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.generator_id.as_deref()
    }
    /// <p>The Region from which the finding was generated.</p>
    pub fn region(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.region.as_deref()
    }
    /// <p>A finding type in the format of <code>namespace/category/classifier</code> that classifies a finding.</p>
    pub fn r#type(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.r#type.as_deref()
    }
    /// <p>An ISO8601-formatted timestamp that indicates when the security-findings provider first observed the potential security issue that a finding captured.</p>
    pub fn first_observed_at(&self) -> std::option::Option<&[crate::model::DateFilter]> {
        self.first_observed_at.as_deref()
    }
    /// <p>An ISO8601-formatted timestamp that indicates when the security-findings provider most recently observed the potential security issue that a finding captured.</p>
    pub fn last_observed_at(&self) -> std::option::Option<&[crate::model::DateFilter]> {
        self.last_observed_at.as_deref()
    }
    /// <p>An ISO8601-formatted timestamp that indicates when the security-findings provider captured the potential security issue that a finding captured.</p>
    pub fn created_at(&self) -> std::option::Option<&[crate::model::DateFilter]> {
        self.created_at.as_deref()
    }
    /// <p>An ISO8601-formatted timestamp that indicates when the security-findings provider last updated the finding record. </p>
    pub fn updated_at(&self) -> std::option::Option<&[crate::model::DateFilter]> {
        self.updated_at.as_deref()
    }
    /// <p>The native severity as defined by the security-findings provider's solution that generated the finding.</p>
    pub fn severity_product(&self) -> std::option::Option<&[crate::model::NumberFilter]> {
        self.severity_product.as_deref()
    }
    /// <p>The normalized severity of a finding.</p>
    pub fn severity_normalized(&self) -> std::option::Option<&[crate::model::NumberFilter]> {
        self.severity_normalized.as_deref()
    }
    /// <p>The label of a finding's severity.</p>
    pub fn severity_label(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.severity_label.as_deref()
    }
    /// <p>A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify.</p>
    /// <p>Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.</p>
    pub fn confidence(&self) -> std::option::Option<&[crate::model::NumberFilter]> {
        self.confidence.as_deref()
    }
    /// <p>The level of importance assigned to the resources associated with the finding.</p>
    /// <p>A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.</p>
    pub fn criticality(&self) -> std::option::Option<&[crate::model::NumberFilter]> {
        self.criticality.as_deref()
    }
    /// <p>A finding's title.</p>
    pub fn title(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.title.as_deref()
    }
    /// <p>A finding's description.</p>
    pub fn description(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.description.as_deref()
    }
    /// <p>The recommendation of what to do about the issue described in a finding.</p>
    pub fn recommendation_text(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.recommendation_text.as_deref()
    }
    /// <p>A URL that links to a page about the current finding in the security-findings provider's solution.</p>
    pub fn source_url(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.source_url.as_deref()
    }
    /// <p>A data type where security-findings providers can include additional solution-specific details that aren't part of the defined <code>AwsSecurityFinding</code> format.</p>
    pub fn product_fields(&self) -> std::option::Option<&[crate::model::MapFilter]> {
        self.product_fields.as_deref()
    }
    /// <p>The name of the solution (product) that generates findings.</p>
    pub fn product_name(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.product_name.as_deref()
    }
    /// <p>The name of the findings provider (company) that owns the solution (product) that generates findings.</p>
    pub fn company_name(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.company_name.as_deref()
    }
    /// <p>A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding. </p>
    pub fn user_defined_fields(&self) -> std::option::Option<&[crate::model::MapFilter]> {
        self.user_defined_fields.as_deref()
    }
    /// <p>The name of the malware that was observed.</p>
    pub fn malware_name(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.malware_name.as_deref()
    }
    /// <p>The type of the malware that was observed.</p>
    pub fn malware_type(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.malware_type.as_deref()
    }
    /// <p>The filesystem path of the malware that was observed.</p>
    pub fn malware_path(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.malware_path.as_deref()
    }
    /// <p>The state of the malware that was observed.</p>
    pub fn malware_state(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.malware_state.as_deref()
    }
    /// <p>Indicates the direction of network traffic associated with a finding.</p>
    pub fn network_direction(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.network_direction.as_deref()
    }
    /// <p>The protocol of network-related information about a finding.</p>
    pub fn network_protocol(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.network_protocol.as_deref()
    }
    /// <p>The source IPv4 address of network-related information about a finding.</p>
    pub fn network_source_ip_v4(&self) -> std::option::Option<&[crate::model::IpFilter]> {
        self.network_source_ip_v4.as_deref()
    }
    /// <p>The source IPv6 address of network-related information about a finding.</p>
    pub fn network_source_ip_v6(&self) -> std::option::Option<&[crate::model::IpFilter]> {
        self.network_source_ip_v6.as_deref()
    }
    /// <p>The source port of network-related information about a finding.</p>
    pub fn network_source_port(&self) -> std::option::Option<&[crate::model::NumberFilter]> {
        self.network_source_port.as_deref()
    }
    /// <p>The source domain of network-related information about a finding.</p>
    pub fn network_source_domain(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.network_source_domain.as_deref()
    }
    /// <p>The source media access control (MAC) address of network-related information about a finding.</p>
    pub fn network_source_mac(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.network_source_mac.as_deref()
    }
    /// <p>The destination IPv4 address of network-related information about a finding.</p>
    pub fn network_destination_ip_v4(&self) -> std::option::Option<&[crate::model::IpFilter]> {
        self.network_destination_ip_v4.as_deref()
    }
    /// <p>The destination IPv6 address of network-related information about a finding.</p>
    pub fn network_destination_ip_v6(&self) -> std::option::Option<&[crate::model::IpFilter]> {
        self.network_destination_ip_v6.as_deref()
    }
    /// <p>The destination port of network-related information about a finding.</p>
    pub fn network_destination_port(&self) -> std::option::Option<&[crate::model::NumberFilter]> {
        self.network_destination_port.as_deref()
    }
    /// <p>The destination domain of network-related information about a finding.</p>
    pub fn network_destination_domain(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.network_destination_domain.as_deref()
    }
    /// <p>The name of the process.</p>
    pub fn process_name(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.process_name.as_deref()
    }
    /// <p>The path to the process executable.</p>
    pub fn process_path(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.process_path.as_deref()
    }
    /// <p>The process ID.</p>
    pub fn process_pid(&self) -> std::option::Option<&[crate::model::NumberFilter]> {
        self.process_pid.as_deref()
    }
    /// <p>The parent process ID.</p>
    pub fn process_parent_pid(&self) -> std::option::Option<&[crate::model::NumberFilter]> {
        self.process_parent_pid.as_deref()
    }
    /// <p>The date/time that the process was launched.</p>
    pub fn process_launched_at(&self) -> std::option::Option<&[crate::model::DateFilter]> {
        self.process_launched_at.as_deref()
    }
    /// <p>The date/time that the process was terminated.</p>
    pub fn process_terminated_at(&self) -> std::option::Option<&[crate::model::DateFilter]> {
        self.process_terminated_at.as_deref()
    }
    /// <p>The type of a threat intelligence indicator.</p>
    pub fn threat_intel_indicator_type(
        &self,
    ) -> std::option::Option<&[crate::model::StringFilter]> {
        self.threat_intel_indicator_type.as_deref()
    }
    /// <p>The value of a threat intelligence indicator.</p>
    pub fn threat_intel_indicator_value(
        &self,
    ) -> std::option::Option<&[crate::model::StringFilter]> {
        self.threat_intel_indicator_value.as_deref()
    }
    /// <p>The category of a threat intelligence indicator.</p>
    pub fn threat_intel_indicator_category(
        &self,
    ) -> std::option::Option<&[crate::model::StringFilter]> {
        self.threat_intel_indicator_category.as_deref()
    }
    /// <p>The date/time of the last observation of a threat intelligence indicator.</p>
    pub fn threat_intel_indicator_last_observed_at(
        &self,
    ) -> std::option::Option<&[crate::model::DateFilter]> {
        self.threat_intel_indicator_last_observed_at.as_deref()
    }
    /// <p>The source of the threat intelligence.</p>
    pub fn threat_intel_indicator_source(
        &self,
    ) -> std::option::Option<&[crate::model::StringFilter]> {
        self.threat_intel_indicator_source.as_deref()
    }
    /// <p>The URL for more details from the source of the threat intelligence.</p>
    pub fn threat_intel_indicator_source_url(
        &self,
    ) -> std::option::Option<&[crate::model::StringFilter]> {
        self.threat_intel_indicator_source_url.as_deref()
    }
    /// <p>Specifies the type of the resource that details are provided for.</p>
    pub fn resource_type(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.resource_type.as_deref()
    }
    /// <p>The canonical identifier for the given resource type.</p>
    pub fn resource_id(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.resource_id.as_deref()
    }
    /// <p>The canonical Amazon Web Services partition name that the Region is assigned to.</p>
    pub fn resource_partition(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.resource_partition.as_deref()
    }
    /// <p>The canonical Amazon Web Services external Region name where this resource is located.</p>
    pub fn resource_region(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.resource_region.as_deref()
    }
    /// <p>A list of Amazon Web Services tags associated with a resource at the time the finding was processed.</p>
    pub fn resource_tags(&self) -> std::option::Option<&[crate::model::MapFilter]> {
        self.resource_tags.as_deref()
    }
    /// <p>The instance type of the instance.</p>
    pub fn resource_aws_ec2_instance_type(
        &self,
    ) -> std::option::Option<&[crate::model::StringFilter]> {
        self.resource_aws_ec2_instance_type.as_deref()
    }
    /// <p>The Amazon Machine Image (AMI) ID of the instance.</p>
    pub fn resource_aws_ec2_instance_image_id(
        &self,
    ) -> std::option::Option<&[crate::model::StringFilter]> {
        self.resource_aws_ec2_instance_image_id.as_deref()
    }
    /// <p>The IPv4 addresses associated with the instance.</p>
    pub fn resource_aws_ec2_instance_ip_v4_addresses(
        &self,
    ) -> std::option::Option<&[crate::model::IpFilter]> {
        self.resource_aws_ec2_instance_ip_v4_addresses.as_deref()
    }
    /// <p>The IPv6 addresses associated with the instance.</p>
    pub fn resource_aws_ec2_instance_ip_v6_addresses(
        &self,
    ) -> std::option::Option<&[crate::model::IpFilter]> {
        self.resource_aws_ec2_instance_ip_v6_addresses.as_deref()
    }
    /// <p>The key name associated with the instance.</p>
    pub fn resource_aws_ec2_instance_key_name(
        &self,
    ) -> std::option::Option<&[crate::model::StringFilter]> {
        self.resource_aws_ec2_instance_key_name.as_deref()
    }
    /// <p>The IAM profile ARN of the instance.</p>
    pub fn resource_aws_ec2_instance_iam_instance_profile_arn(
        &self,
    ) -> std::option::Option<&[crate::model::StringFilter]> {
        self.resource_aws_ec2_instance_iam_instance_profile_arn
            .as_deref()
    }
    /// <p>The identifier of the VPC that the instance was launched in.</p>
    pub fn resource_aws_ec2_instance_vpc_id(
        &self,
    ) -> std::option::Option<&[crate::model::StringFilter]> {
        self.resource_aws_ec2_instance_vpc_id.as_deref()
    }
    /// <p>The identifier of the subnet that the instance was launched in.</p>
    pub fn resource_aws_ec2_instance_subnet_id(
        &self,
    ) -> std::option::Option<&[crate::model::StringFilter]> {
        self.resource_aws_ec2_instance_subnet_id.as_deref()
    }
    /// <p>The date and time the instance was launched.</p>
    pub fn resource_aws_ec2_instance_launched_at(
        &self,
    ) -> std::option::Option<&[crate::model::DateFilter]> {
        self.resource_aws_ec2_instance_launched_at.as_deref()
    }
    /// <p>The canonical user ID of the owner of the S3 bucket.</p>
    pub fn resource_aws_s3_bucket_owner_id(
        &self,
    ) -> std::option::Option<&[crate::model::StringFilter]> {
        self.resource_aws_s3_bucket_owner_id.as_deref()
    }
    /// <p>The display name of the owner of the S3 bucket.</p>
    pub fn resource_aws_s3_bucket_owner_name(
        &self,
    ) -> std::option::Option<&[crate::model::StringFilter]> {
        self.resource_aws_s3_bucket_owner_name.as_deref()
    }
    /// <p>The user associated with the IAM access key related to a finding.</p>
    pub fn resource_aws_iam_access_key_user_name(
        &self,
    ) -> std::option::Option<&[crate::model::StringFilter]> {
        self.resource_aws_iam_access_key_user_name.as_deref()
    }
    /// <p>The name of the principal that is associated with an IAM access key.</p>
    pub fn resource_aws_iam_access_key_principal_name(
        &self,
    ) -> std::option::Option<&[crate::model::StringFilter]> {
        self.resource_aws_iam_access_key_principal_name.as_deref()
    }
    /// <p>The status of the IAM access key related to a finding.</p>
    pub fn resource_aws_iam_access_key_status(
        &self,
    ) -> std::option::Option<&[crate::model::StringFilter]> {
        self.resource_aws_iam_access_key_status.as_deref()
    }
    /// <p>The creation date/time of the IAM access key related to a finding.</p>
    pub fn resource_aws_iam_access_key_created_at(
        &self,
    ) -> std::option::Option<&[crate::model::DateFilter]> {
        self.resource_aws_iam_access_key_created_at.as_deref()
    }
    /// <p>The name of an IAM user.</p>
    pub fn resource_aws_iam_user_user_name(
        &self,
    ) -> std::option::Option<&[crate::model::StringFilter]> {
        self.resource_aws_iam_user_user_name.as_deref()
    }
    /// <p>The name of the container related to a finding.</p>
    pub fn resource_container_name(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.resource_container_name.as_deref()
    }
    /// <p>The identifier of the image related to a finding.</p>
    pub fn resource_container_image_id(
        &self,
    ) -> std::option::Option<&[crate::model::StringFilter]> {
        self.resource_container_image_id.as_deref()
    }
    /// <p>The name of the image related to a finding.</p>
    pub fn resource_container_image_name(
        &self,
    ) -> std::option::Option<&[crate::model::StringFilter]> {
        self.resource_container_image_name.as_deref()
    }
    /// <p>The date/time that the container was started.</p>
    pub fn resource_container_launched_at(
        &self,
    ) -> std::option::Option<&[crate::model::DateFilter]> {
        self.resource_container_launched_at.as_deref()
    }
    /// <p>The details of a resource that doesn't have a specific subfield for the resource type defined.</p>
    pub fn resource_details_other(&self) -> std::option::Option<&[crate::model::MapFilter]> {
        self.resource_details_other.as_deref()
    }
    /// <p>Exclusive to findings that are generated as the result of a check run against a specific rule in a supported standard, such as CIS Amazon Web Services Foundations. Contains security standard-related finding details.</p>
    pub fn compliance_status(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.compliance_status.as_deref()
    }
    /// <p>The veracity of a finding.</p>
    pub fn verification_state(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.verification_state.as_deref()
    }
    /// <p>The workflow state of a finding.</p>
    /// <p>Note that this field is deprecated. To search for a finding based on its workflow status, use <code>WorkflowStatus</code>.</p>
    pub fn workflow_state(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.workflow_state.as_deref()
    }
    /// <p>The status of the investigation into a finding. Allowed values are the following.</p>
    /// <ul>
    /// <li> <p> <code>NEW</code> - The initial state of a finding, before it is reviewed.</p> <p>Security Hub also resets the workflow status from <code>NOTIFIED</code> or <code>RESOLVED</code> to <code>NEW</code> in the following cases:</p>
    /// <ul>
    /// <li> <p> <code>RecordState</code> changes from <code>ARCHIVED</code> to <code>ACTIVE</code>.</p> </li>
    /// <li> <p> <code>Compliance.Status</code> changes from <code>PASSED</code> to either <code>WARNING</code>, <code>FAILED</code>, or <code>NOT_AVAILABLE</code>.</p> </li>
    /// </ul> </li>
    /// <li> <p> <code>NOTIFIED</code> - Indicates that the resource owner has been notified about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner.</p> <p>If one of the following occurs, the workflow status is changed automatically from <code>NOTIFIED</code> to <code>NEW</code>:</p>
    /// <ul>
    /// <li> <p> <code>RecordState</code> changes from <code>ARCHIVED</code> to <code>ACTIVE</code>.</p> </li>
    /// <li> <p> <code>Compliance.Status</code> changes from <code>PASSED</code> to <code>FAILED</code>, <code>WARNING</code>, or <code>NOT_AVAILABLE</code>.</p> </li>
    /// </ul> </li>
    /// <li> <p> <code>SUPPRESSED</code> - Indicates that you reviewed the finding and do not believe that any action is needed.</p> <p>The workflow status of a <code>SUPPRESSED</code> finding does not change if <code>RecordState</code> changes from <code>ARCHIVED</code> to <code>ACTIVE</code>.</p> </li>
    /// <li> <p> <code>RESOLVED</code> - The finding was reviewed and remediated and is now considered resolved. </p> <p>The finding remains <code>RESOLVED</code> unless one of the following occurs:</p>
    /// <ul>
    /// <li> <p> <code>RecordState</code> changes from <code>ARCHIVED</code> to <code>ACTIVE</code>.</p> </li>
    /// <li> <p> <code>Compliance.Status</code> changes from <code>PASSED</code> to <code>FAILED</code>, <code>WARNING</code>, or <code>NOT_AVAILABLE</code>.</p> </li>
    /// </ul> <p>In those cases, the workflow status is automatically reset to <code>NEW</code>.</p> <p>For findings from controls, if <code>Compliance.Status</code> is <code>PASSED</code>, then Security Hub automatically sets the workflow status to <code>RESOLVED</code>.</p> </li>
    /// </ul>
    pub fn workflow_status(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.workflow_status.as_deref()
    }
    /// <p>The updated record state for the finding.</p>
    pub fn record_state(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.record_state.as_deref()
    }
    /// <p>The ARN of the solution that generated a related finding.</p>
    pub fn related_findings_product_arn(
        &self,
    ) -> std::option::Option<&[crate::model::StringFilter]> {
        self.related_findings_product_arn.as_deref()
    }
    /// <p>The solution-generated identifier for a related finding.</p>
    pub fn related_findings_id(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.related_findings_id.as_deref()
    }
    /// <p>The text of a note.</p>
    pub fn note_text(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.note_text.as_deref()
    }
    /// <p>The timestamp of when the note was updated.</p>
    pub fn note_updated_at(&self) -> std::option::Option<&[crate::model::DateFilter]> {
        self.note_updated_at.as_deref()
    }
    /// <p>The principal that created a note.</p>
    pub fn note_updated_by(&self) -> std::option::Option<&[crate::model::StringFilter]> {
        self.note_updated_by.as_deref()
    }
    /// <p>A keyword for a finding.</p>
    pub fn keyword(&self) -> std::option::Option<&[crate::model::KeywordFilter]> {
        self.keyword.as_deref()
    }
    /// <p>The finding provider value for the finding confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify.</p>
    /// <p>Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.</p>
    pub fn finding_provider_fields_confidence(
        &self,
    ) -> std::option::Option<&[crate::model::NumberFilter]> {
        self.finding_provider_fields_confidence.as_deref()
    }
    /// <p>The finding provider value for the level of importance assigned to the resources associated with the findings.</p>
    /// <p>A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. </p>
    pub fn finding_provider_fields_criticality(
        &self,
    ) -> std::option::Option<&[crate::model::NumberFilter]> {
        self.finding_provider_fields_criticality.as_deref()
    }
    /// <p>The finding identifier of a related finding that is identified by the finding provider.</p>
    pub fn finding_provider_fields_related_findings_id(
        &self,
    ) -> std::option::Option<&[crate::model::StringFilter]> {
        self.finding_provider_fields_related_findings_id.as_deref()
    }
    /// <p>The ARN of the solution that generated a related finding that is identified by the finding provider.</p>
    pub fn finding_provider_fields_related_findings_product_arn(
        &self,
    ) -> std::option::Option<&[crate::model::StringFilter]> {
        self.finding_provider_fields_related_findings_product_arn
            .as_deref()
    }
    /// <p>The finding provider value for the severity label.</p>
    pub fn finding_provider_fields_severity_label(
        &self,
    ) -> std::option::Option<&[crate::model::StringFilter]> {
        self.finding_provider_fields_severity_label.as_deref()
    }
    /// <p>The finding provider's original value for the severity.</p>
    pub fn finding_provider_fields_severity_original(
        &self,
    ) -> std::option::Option<&[crate::model::StringFilter]> {
        self.finding_provider_fields_severity_original.as_deref()
    }
    /// <p>One or more finding types that the finding provider assigned to the finding. Uses the format of <code>namespace/category/classifier</code> that classify a finding.</p>
    /// <p>Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual Behaviors | Sensitive Data Identifications</p>
    pub fn finding_provider_fields_types(
        &self,
    ) -> std::option::Option<&[crate::model::StringFilter]> {
        self.finding_provider_fields_types.as_deref()
    }
    /// <p>Indicates whether or not sample findings are included in the filter results.</p>
    pub fn sample(&self) -> std::option::Option<&[crate::model::BooleanFilter]> {
        self.sample.as_deref()
    }
}
impl std::fmt::Debug for AwsSecurityFindingFilters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsSecurityFindingFilters");
        formatter.field("product_arn", &self.product_arn);
        formatter.field("aws_account_id", &self.aws_account_id);
        formatter.field("id", &self.id);
        formatter.field("generator_id", &self.generator_id);
        formatter.field("region", &self.region);
        formatter.field("r#type", &self.r#type);
        formatter.field("first_observed_at", &self.first_observed_at);
        formatter.field("last_observed_at", &self.last_observed_at);
        formatter.field("created_at", &self.created_at);
        formatter.field("updated_at", &self.updated_at);
        formatter.field("severity_product", &self.severity_product);
        formatter.field("severity_normalized", &self.severity_normalized);
        formatter.field("severity_label", &self.severity_label);
        formatter.field("confidence", &self.confidence);
        formatter.field("criticality", &self.criticality);
        formatter.field("title", &self.title);
        formatter.field("description", &self.description);
        formatter.field("recommendation_text", &self.recommendation_text);
        formatter.field("source_url", &self.source_url);
        formatter.field("product_fields", &self.product_fields);
        formatter.field("product_name", &self.product_name);
        formatter.field("company_name", &self.company_name);
        formatter.field("user_defined_fields", &self.user_defined_fields);
        formatter.field("malware_name", &self.malware_name);
        formatter.field("malware_type", &self.malware_type);
        formatter.field("malware_path", &self.malware_path);
        formatter.field("malware_state", &self.malware_state);
        formatter.field("network_direction", &self.network_direction);
        formatter.field("network_protocol", &self.network_protocol);
        formatter.field("network_source_ip_v4", &self.network_source_ip_v4);
        formatter.field("network_source_ip_v6", &self.network_source_ip_v6);
        formatter.field("network_source_port", &self.network_source_port);
        formatter.field("network_source_domain", &self.network_source_domain);
        formatter.field("network_source_mac", &self.network_source_mac);
        formatter.field("network_destination_ip_v4", &self.network_destination_ip_v4);
        formatter.field("network_destination_ip_v6", &self.network_destination_ip_v6);
        formatter.field("network_destination_port", &self.network_destination_port);
        formatter.field(
            "network_destination_domain",
            &self.network_destination_domain,
        );
        formatter.field("process_name", &self.process_name);
        formatter.field("process_path", &self.process_path);
        formatter.field("process_pid", &self.process_pid);
        formatter.field("process_parent_pid", &self.process_parent_pid);
        formatter.field("process_launched_at", &self.process_launched_at);
        formatter.field("process_terminated_at", &self.process_terminated_at);
        formatter.field(
            "threat_intel_indicator_type",
            &self.threat_intel_indicator_type,
        );
        formatter.field(
            "threat_intel_indicator_value",
            &self.threat_intel_indicator_value,
        );
        formatter.field(
            "threat_intel_indicator_category",
            &self.threat_intel_indicator_category,
        );
        formatter.field(
            "threat_intel_indicator_last_observed_at",
            &self.threat_intel_indicator_last_observed_at,
        );
        formatter.field(
            "threat_intel_indicator_source",
            &self.threat_intel_indicator_source,
        );
        formatter.field(
            "threat_intel_indicator_source_url",
            &self.threat_intel_indicator_source_url,
        );
        formatter.field("resource_type", &self.resource_type);
        formatter.field("resource_id", &self.resource_id);
        formatter.field("resource_partition", &self.resource_partition);
        formatter.field("resource_region", &self.resource_region);
        formatter.field("resource_tags", &self.resource_tags);
        formatter.field(
            "resource_aws_ec2_instance_type",
            &self.resource_aws_ec2_instance_type,
        );
        formatter.field(
            "resource_aws_ec2_instance_image_id",
            &self.resource_aws_ec2_instance_image_id,
        );
        formatter.field(
            "resource_aws_ec2_instance_ip_v4_addresses",
            &self.resource_aws_ec2_instance_ip_v4_addresses,
        );
        formatter.field(
            "resource_aws_ec2_instance_ip_v6_addresses",
            &self.resource_aws_ec2_instance_ip_v6_addresses,
        );
        formatter.field(
            "resource_aws_ec2_instance_key_name",
            &self.resource_aws_ec2_instance_key_name,
        );
        formatter.field(
            "resource_aws_ec2_instance_iam_instance_profile_arn",
            &self.resource_aws_ec2_instance_iam_instance_profile_arn,
        );
        formatter.field(
            "resource_aws_ec2_instance_vpc_id",
            &self.resource_aws_ec2_instance_vpc_id,
        );
        formatter.field(
            "resource_aws_ec2_instance_subnet_id",
            &self.resource_aws_ec2_instance_subnet_id,
        );
        formatter.field(
            "resource_aws_ec2_instance_launched_at",
            &self.resource_aws_ec2_instance_launched_at,
        );
        formatter.field(
            "resource_aws_s3_bucket_owner_id",
            &self.resource_aws_s3_bucket_owner_id,
        );
        formatter.field(
            "resource_aws_s3_bucket_owner_name",
            &self.resource_aws_s3_bucket_owner_name,
        );
        formatter.field(
            "resource_aws_iam_access_key_user_name",
            &self.resource_aws_iam_access_key_user_name,
        );
        formatter.field(
            "resource_aws_iam_access_key_principal_name",
            &self.resource_aws_iam_access_key_principal_name,
        );
        formatter.field(
            "resource_aws_iam_access_key_status",
            &self.resource_aws_iam_access_key_status,
        );
        formatter.field(
            "resource_aws_iam_access_key_created_at",
            &self.resource_aws_iam_access_key_created_at,
        );
        formatter.field(
            "resource_aws_iam_user_user_name",
            &self.resource_aws_iam_user_user_name,
        );
        formatter.field("resource_container_name", &self.resource_container_name);
        formatter.field(
            "resource_container_image_id",
            &self.resource_container_image_id,
        );
        formatter.field(
            "resource_container_image_name",
            &self.resource_container_image_name,
        );
        formatter.field(
            "resource_container_launched_at",
            &self.resource_container_launched_at,
        );
        formatter.field("resource_details_other", &self.resource_details_other);
        formatter.field("compliance_status", &self.compliance_status);
        formatter.field("verification_state", &self.verification_state);
        formatter.field("workflow_state", &self.workflow_state);
        formatter.field("workflow_status", &self.workflow_status);
        formatter.field("record_state", &self.record_state);
        formatter.field(
            "related_findings_product_arn",
            &self.related_findings_product_arn,
        );
        formatter.field("related_findings_id", &self.related_findings_id);
        formatter.field("note_text", &self.note_text);
        formatter.field("note_updated_at", &self.note_updated_at);
        formatter.field("note_updated_by", &self.note_updated_by);
        formatter.field("keyword", &self.keyword);
        formatter.field(
            "finding_provider_fields_confidence",
            &self.finding_provider_fields_confidence,
        );
        formatter.field(
            "finding_provider_fields_criticality",
            &self.finding_provider_fields_criticality,
        );
        formatter.field(
            "finding_provider_fields_related_findings_id",
            &self.finding_provider_fields_related_findings_id,
        );
        formatter.field(
            "finding_provider_fields_related_findings_product_arn",
            &self.finding_provider_fields_related_findings_product_arn,
        );
        formatter.field(
            "finding_provider_fields_severity_label",
            &self.finding_provider_fields_severity_label,
        );
        formatter.field(
            "finding_provider_fields_severity_original",
            &self.finding_provider_fields_severity_original,
        );
        formatter.field(
            "finding_provider_fields_types",
            &self.finding_provider_fields_types,
        );
        formatter.field("sample", &self.sample);
        formatter.finish()
    }
}
/// See [`AwsSecurityFindingFilters`](crate::model::AwsSecurityFindingFilters)
pub mod aws_security_finding_filters {

    /// A builder for [`AwsSecurityFindingFilters`](crate::model::AwsSecurityFindingFilters)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) product_arn: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) aws_account_id: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) id: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) generator_id: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) region: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) r#type: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) first_observed_at: std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
        pub(crate) last_observed_at: std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
        pub(crate) created_at: std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
        pub(crate) updated_at: std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
        pub(crate) severity_product: std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
        pub(crate) severity_normalized:
            std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
        pub(crate) severity_label: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) confidence: std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
        pub(crate) criticality: std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
        pub(crate) title: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) description: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) recommendation_text:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) source_url: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) product_fields: std::option::Option<std::vec::Vec<crate::model::MapFilter>>,
        pub(crate) product_name: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) company_name: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) user_defined_fields: std::option::Option<std::vec::Vec<crate::model::MapFilter>>,
        pub(crate) malware_name: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) malware_type: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) malware_path: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) malware_state: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) network_direction:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) network_protocol: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) network_source_ip_v4: std::option::Option<std::vec::Vec<crate::model::IpFilter>>,
        pub(crate) network_source_ip_v6: std::option::Option<std::vec::Vec<crate::model::IpFilter>>,
        pub(crate) network_source_port:
            std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
        pub(crate) network_source_domain:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) network_source_mac:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) network_destination_ip_v4:
            std::option::Option<std::vec::Vec<crate::model::IpFilter>>,
        pub(crate) network_destination_ip_v6:
            std::option::Option<std::vec::Vec<crate::model::IpFilter>>,
        pub(crate) network_destination_port:
            std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
        pub(crate) network_destination_domain:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) process_name: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) process_path: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) process_pid: std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
        pub(crate) process_parent_pid:
            std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
        pub(crate) process_launched_at:
            std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
        pub(crate) process_terminated_at:
            std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
        pub(crate) threat_intel_indicator_type:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) threat_intel_indicator_value:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) threat_intel_indicator_category:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) threat_intel_indicator_last_observed_at:
            std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
        pub(crate) threat_intel_indicator_source:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) threat_intel_indicator_source_url:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) resource_type: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) resource_id: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) resource_partition:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) resource_region: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) resource_tags: std::option::Option<std::vec::Vec<crate::model::MapFilter>>,
        pub(crate) resource_aws_ec2_instance_type:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) resource_aws_ec2_instance_image_id:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) resource_aws_ec2_instance_ip_v4_addresses:
            std::option::Option<std::vec::Vec<crate::model::IpFilter>>,
        pub(crate) resource_aws_ec2_instance_ip_v6_addresses:
            std::option::Option<std::vec::Vec<crate::model::IpFilter>>,
        pub(crate) resource_aws_ec2_instance_key_name:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) resource_aws_ec2_instance_iam_instance_profile_arn:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) resource_aws_ec2_instance_vpc_id:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) resource_aws_ec2_instance_subnet_id:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) resource_aws_ec2_instance_launched_at:
            std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
        pub(crate) resource_aws_s3_bucket_owner_id:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) resource_aws_s3_bucket_owner_name:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) resource_aws_iam_access_key_user_name:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) resource_aws_iam_access_key_principal_name:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) resource_aws_iam_access_key_status:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) resource_aws_iam_access_key_created_at:
            std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
        pub(crate) resource_aws_iam_user_user_name:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) resource_container_name:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) resource_container_image_id:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) resource_container_image_name:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) resource_container_launched_at:
            std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
        pub(crate) resource_details_other:
            std::option::Option<std::vec::Vec<crate::model::MapFilter>>,
        pub(crate) compliance_status:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) verification_state:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) workflow_state: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) workflow_status: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) record_state: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) related_findings_product_arn:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) related_findings_id:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) note_text: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) note_updated_at: std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
        pub(crate) note_updated_by: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) keyword: std::option::Option<std::vec::Vec<crate::model::KeywordFilter>>,
        pub(crate) finding_provider_fields_confidence:
            std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
        pub(crate) finding_provider_fields_criticality:
            std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
        pub(crate) finding_provider_fields_related_findings_id:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) finding_provider_fields_related_findings_product_arn:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) finding_provider_fields_severity_label:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) finding_provider_fields_severity_original:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) finding_provider_fields_types:
            std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        pub(crate) sample: std::option::Option<std::vec::Vec<crate::model::BooleanFilter>>,
    }
    impl Builder {
        /// Appends an item to `product_arn`.
        ///
        /// To override the contents of this collection use [`set_product_arn`](Self::set_product_arn).
        ///
        /// <p>The ARN generated by Security Hub that uniquely identifies a third-party company (security findings provider) after this provider's product (solution that generates findings) is registered with Security Hub.</p>
        pub fn product_arn(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.product_arn.unwrap_or_default();
            v.push(input);
            self.product_arn = Some(v);
            self
        }
        /// <p>The ARN generated by Security Hub that uniquely identifies a third-party company (security findings provider) after this provider's product (solution that generates findings) is registered with Security Hub.</p>
        pub fn set_product_arn(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.product_arn = input;
            self
        }
        /// Appends an item to `aws_account_id`.
        ///
        /// To override the contents of this collection use [`set_aws_account_id`](Self::set_aws_account_id).
        ///
        /// <p>The Amazon Web Services account ID that a finding is generated in.</p>
        pub fn aws_account_id(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.aws_account_id.unwrap_or_default();
            v.push(input);
            self.aws_account_id = Some(v);
            self
        }
        /// <p>The Amazon Web Services account ID that a finding is generated in.</p>
        pub fn set_aws_account_id(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.aws_account_id = input;
            self
        }
        /// Appends an item to `id`.
        ///
        /// To override the contents of this collection use [`set_id`](Self::set_id).
        ///
        /// <p>The security findings provider-specific identifier for a finding.</p>
        pub fn id(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.id.unwrap_or_default();
            v.push(input);
            self.id = Some(v);
            self
        }
        /// <p>The security findings provider-specific identifier for a finding.</p>
        pub fn set_id(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.id = input;
            self
        }
        /// Appends an item to `generator_id`.
        ///
        /// To override the contents of this collection use [`set_generator_id`](Self::set_generator_id).
        ///
        /// <p>The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. In various security-findings providers' solutions, this generator can be called a rule, a check, a detector, a plugin, etc.</p>
        pub fn generator_id(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.generator_id.unwrap_or_default();
            v.push(input);
            self.generator_id = Some(v);
            self
        }
        /// <p>The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. In various security-findings providers' solutions, this generator can be called a rule, a check, a detector, a plugin, etc.</p>
        pub fn set_generator_id(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.generator_id = input;
            self
        }
        /// Appends an item to `region`.
        ///
        /// To override the contents of this collection use [`set_region`](Self::set_region).
        ///
        /// <p>The Region from which the finding was generated.</p>
        pub fn region(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.region.unwrap_or_default();
            v.push(input);
            self.region = Some(v);
            self
        }
        /// <p>The Region from which the finding was generated.</p>
        pub fn set_region(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.region = input;
            self
        }
        /// Appends an item to `r#type`.
        ///
        /// To override the contents of this collection use [`set_type`](Self::set_type).
        ///
        /// <p>A finding type in the format of <code>namespace/category/classifier</code> that classifies a finding.</p>
        pub fn r#type(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.r#type.unwrap_or_default();
            v.push(input);
            self.r#type = Some(v);
            self
        }
        /// <p>A finding type in the format of <code>namespace/category/classifier</code> that classifies a finding.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Appends an item to `first_observed_at`.
        ///
        /// To override the contents of this collection use [`set_first_observed_at`](Self::set_first_observed_at).
        ///
        /// <p>An ISO8601-formatted timestamp that indicates when the security-findings provider first observed the potential security issue that a finding captured.</p>
        pub fn first_observed_at(mut self, input: crate::model::DateFilter) -> Self {
            let mut v = self.first_observed_at.unwrap_or_default();
            v.push(input);
            self.first_observed_at = Some(v);
            self
        }
        /// <p>An ISO8601-formatted timestamp that indicates when the security-findings provider first observed the potential security issue that a finding captured.</p>
        pub fn set_first_observed_at(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
        ) -> Self {
            self.first_observed_at = input;
            self
        }
        /// Appends an item to `last_observed_at`.
        ///
        /// To override the contents of this collection use [`set_last_observed_at`](Self::set_last_observed_at).
        ///
        /// <p>An ISO8601-formatted timestamp that indicates when the security-findings provider most recently observed the potential security issue that a finding captured.</p>
        pub fn last_observed_at(mut self, input: crate::model::DateFilter) -> Self {
            let mut v = self.last_observed_at.unwrap_or_default();
            v.push(input);
            self.last_observed_at = Some(v);
            self
        }
        /// <p>An ISO8601-formatted timestamp that indicates when the security-findings provider most recently observed the potential security issue that a finding captured.</p>
        pub fn set_last_observed_at(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
        ) -> Self {
            self.last_observed_at = input;
            self
        }
        /// Appends an item to `created_at`.
        ///
        /// To override the contents of this collection use [`set_created_at`](Self::set_created_at).
        ///
        /// <p>An ISO8601-formatted timestamp that indicates when the security-findings provider captured the potential security issue that a finding captured.</p>
        pub fn created_at(mut self, input: crate::model::DateFilter) -> Self {
            let mut v = self.created_at.unwrap_or_default();
            v.push(input);
            self.created_at = Some(v);
            self
        }
        /// <p>An ISO8601-formatted timestamp that indicates when the security-findings provider captured the potential security issue that a finding captured.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// Appends an item to `updated_at`.
        ///
        /// To override the contents of this collection use [`set_updated_at`](Self::set_updated_at).
        ///
        /// <p>An ISO8601-formatted timestamp that indicates when the security-findings provider last updated the finding record. </p>
        pub fn updated_at(mut self, input: crate::model::DateFilter) -> Self {
            let mut v = self.updated_at.unwrap_or_default();
            v.push(input);
            self.updated_at = Some(v);
            self
        }
        /// <p>An ISO8601-formatted timestamp that indicates when the security-findings provider last updated the finding record. </p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// Appends an item to `severity_product`.
        ///
        /// To override the contents of this collection use [`set_severity_product`](Self::set_severity_product).
        ///
        /// <p>The native severity as defined by the security-findings provider's solution that generated the finding.</p>
        pub fn severity_product(mut self, input: crate::model::NumberFilter) -> Self {
            let mut v = self.severity_product.unwrap_or_default();
            v.push(input);
            self.severity_product = Some(v);
            self
        }
        /// <p>The native severity as defined by the security-findings provider's solution that generated the finding.</p>
        pub fn set_severity_product(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
        ) -> Self {
            self.severity_product = input;
            self
        }
        /// Appends an item to `severity_normalized`.
        ///
        /// To override the contents of this collection use [`set_severity_normalized`](Self::set_severity_normalized).
        ///
        /// <p>The normalized severity of a finding.</p>
        pub fn severity_normalized(mut self, input: crate::model::NumberFilter) -> Self {
            let mut v = self.severity_normalized.unwrap_or_default();
            v.push(input);
            self.severity_normalized = Some(v);
            self
        }
        /// <p>The normalized severity of a finding.</p>
        pub fn set_severity_normalized(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
        ) -> Self {
            self.severity_normalized = input;
            self
        }
        /// Appends an item to `severity_label`.
        ///
        /// To override the contents of this collection use [`set_severity_label`](Self::set_severity_label).
        ///
        /// <p>The label of a finding's severity.</p>
        pub fn severity_label(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.severity_label.unwrap_or_default();
            v.push(input);
            self.severity_label = Some(v);
            self
        }
        /// <p>The label of a finding's severity.</p>
        pub fn set_severity_label(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.severity_label = input;
            self
        }
        /// Appends an item to `confidence`.
        ///
        /// To override the contents of this collection use [`set_confidence`](Self::set_confidence).
        ///
        /// <p>A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify.</p>
        /// <p>Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.</p>
        pub fn confidence(mut self, input: crate::model::NumberFilter) -> Self {
            let mut v = self.confidence.unwrap_or_default();
            v.push(input);
            self.confidence = Some(v);
            self
        }
        /// <p>A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify.</p>
        /// <p>Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.</p>
        pub fn set_confidence(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
        ) -> Self {
            self.confidence = input;
            self
        }
        /// Appends an item to `criticality`.
        ///
        /// To override the contents of this collection use [`set_criticality`](Self::set_criticality).
        ///
        /// <p>The level of importance assigned to the resources associated with the finding.</p>
        /// <p>A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.</p>
        pub fn criticality(mut self, input: crate::model::NumberFilter) -> Self {
            let mut v = self.criticality.unwrap_or_default();
            v.push(input);
            self.criticality = Some(v);
            self
        }
        /// <p>The level of importance assigned to the resources associated with the finding.</p>
        /// <p>A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.</p>
        pub fn set_criticality(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
        ) -> Self {
            self.criticality = input;
            self
        }
        /// Appends an item to `title`.
        ///
        /// To override the contents of this collection use [`set_title`](Self::set_title).
        ///
        /// <p>A finding's title.</p>
        pub fn title(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.title.unwrap_or_default();
            v.push(input);
            self.title = Some(v);
            self
        }
        /// <p>A finding's title.</p>
        pub fn set_title(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.title = input;
            self
        }
        /// Appends an item to `description`.
        ///
        /// To override the contents of this collection use [`set_description`](Self::set_description).
        ///
        /// <p>A finding's description.</p>
        pub fn description(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.description.unwrap_or_default();
            v.push(input);
            self.description = Some(v);
            self
        }
        /// <p>A finding's description.</p>
        pub fn set_description(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `recommendation_text`.
        ///
        /// To override the contents of this collection use [`set_recommendation_text`](Self::set_recommendation_text).
        ///
        /// <p>The recommendation of what to do about the issue described in a finding.</p>
        pub fn recommendation_text(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.recommendation_text.unwrap_or_default();
            v.push(input);
            self.recommendation_text = Some(v);
            self
        }
        /// <p>The recommendation of what to do about the issue described in a finding.</p>
        pub fn set_recommendation_text(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.recommendation_text = input;
            self
        }
        /// Appends an item to `source_url`.
        ///
        /// To override the contents of this collection use [`set_source_url`](Self::set_source_url).
        ///
        /// <p>A URL that links to a page about the current finding in the security-findings provider's solution.</p>
        pub fn source_url(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.source_url.unwrap_or_default();
            v.push(input);
            self.source_url = Some(v);
            self
        }
        /// <p>A URL that links to a page about the current finding in the security-findings provider's solution.</p>
        pub fn set_source_url(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.source_url = input;
            self
        }
        /// Appends an item to `product_fields`.
        ///
        /// To override the contents of this collection use [`set_product_fields`](Self::set_product_fields).
        ///
        /// <p>A data type where security-findings providers can include additional solution-specific details that aren't part of the defined <code>AwsSecurityFinding</code> format.</p>
        pub fn product_fields(mut self, input: crate::model::MapFilter) -> Self {
            let mut v = self.product_fields.unwrap_or_default();
            v.push(input);
            self.product_fields = Some(v);
            self
        }
        /// <p>A data type where security-findings providers can include additional solution-specific details that aren't part of the defined <code>AwsSecurityFinding</code> format.</p>
        pub fn set_product_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MapFilter>>,
        ) -> Self {
            self.product_fields = input;
            self
        }
        /// Appends an item to `product_name`.
        ///
        /// To override the contents of this collection use [`set_product_name`](Self::set_product_name).
        ///
        /// <p>The name of the solution (product) that generates findings.</p>
        pub fn product_name(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.product_name.unwrap_or_default();
            v.push(input);
            self.product_name = Some(v);
            self
        }
        /// <p>The name of the solution (product) that generates findings.</p>
        pub fn set_product_name(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.product_name = input;
            self
        }
        /// Appends an item to `company_name`.
        ///
        /// To override the contents of this collection use [`set_company_name`](Self::set_company_name).
        ///
        /// <p>The name of the findings provider (company) that owns the solution (product) that generates findings.</p>
        pub fn company_name(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.company_name.unwrap_or_default();
            v.push(input);
            self.company_name = Some(v);
            self
        }
        /// <p>The name of the findings provider (company) that owns the solution (product) that generates findings.</p>
        pub fn set_company_name(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.company_name = input;
            self
        }
        /// Appends an item to `user_defined_fields`.
        ///
        /// To override the contents of this collection use [`set_user_defined_fields`](Self::set_user_defined_fields).
        ///
        /// <p>A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding. </p>
        pub fn user_defined_fields(mut self, input: crate::model::MapFilter) -> Self {
            let mut v = self.user_defined_fields.unwrap_or_default();
            v.push(input);
            self.user_defined_fields = Some(v);
            self
        }
        /// <p>A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding. </p>
        pub fn set_user_defined_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MapFilter>>,
        ) -> Self {
            self.user_defined_fields = input;
            self
        }
        /// Appends an item to `malware_name`.
        ///
        /// To override the contents of this collection use [`set_malware_name`](Self::set_malware_name).
        ///
        /// <p>The name of the malware that was observed.</p>
        pub fn malware_name(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.malware_name.unwrap_or_default();
            v.push(input);
            self.malware_name = Some(v);
            self
        }
        /// <p>The name of the malware that was observed.</p>
        pub fn set_malware_name(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.malware_name = input;
            self
        }
        /// Appends an item to `malware_type`.
        ///
        /// To override the contents of this collection use [`set_malware_type`](Self::set_malware_type).
        ///
        /// <p>The type of the malware that was observed.</p>
        pub fn malware_type(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.malware_type.unwrap_or_default();
            v.push(input);
            self.malware_type = Some(v);
            self
        }
        /// <p>The type of the malware that was observed.</p>
        pub fn set_malware_type(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.malware_type = input;
            self
        }
        /// Appends an item to `malware_path`.
        ///
        /// To override the contents of this collection use [`set_malware_path`](Self::set_malware_path).
        ///
        /// <p>The filesystem path of the malware that was observed.</p>
        pub fn malware_path(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.malware_path.unwrap_or_default();
            v.push(input);
            self.malware_path = Some(v);
            self
        }
        /// <p>The filesystem path of the malware that was observed.</p>
        pub fn set_malware_path(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.malware_path = input;
            self
        }
        /// Appends an item to `malware_state`.
        ///
        /// To override the contents of this collection use [`set_malware_state`](Self::set_malware_state).
        ///
        /// <p>The state of the malware that was observed.</p>
        pub fn malware_state(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.malware_state.unwrap_or_default();
            v.push(input);
            self.malware_state = Some(v);
            self
        }
        /// <p>The state of the malware that was observed.</p>
        pub fn set_malware_state(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.malware_state = input;
            self
        }
        /// Appends an item to `network_direction`.
        ///
        /// To override the contents of this collection use [`set_network_direction`](Self::set_network_direction).
        ///
        /// <p>Indicates the direction of network traffic associated with a finding.</p>
        pub fn network_direction(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.network_direction.unwrap_or_default();
            v.push(input);
            self.network_direction = Some(v);
            self
        }
        /// <p>Indicates the direction of network traffic associated with a finding.</p>
        pub fn set_network_direction(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.network_direction = input;
            self
        }
        /// Appends an item to `network_protocol`.
        ///
        /// To override the contents of this collection use [`set_network_protocol`](Self::set_network_protocol).
        ///
        /// <p>The protocol of network-related information about a finding.</p>
        pub fn network_protocol(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.network_protocol.unwrap_or_default();
            v.push(input);
            self.network_protocol = Some(v);
            self
        }
        /// <p>The protocol of network-related information about a finding.</p>
        pub fn set_network_protocol(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.network_protocol = input;
            self
        }
        /// Appends an item to `network_source_ip_v4`.
        ///
        /// To override the contents of this collection use [`set_network_source_ip_v4`](Self::set_network_source_ip_v4).
        ///
        /// <p>The source IPv4 address of network-related information about a finding.</p>
        pub fn network_source_ip_v4(mut self, input: crate::model::IpFilter) -> Self {
            let mut v = self.network_source_ip_v4.unwrap_or_default();
            v.push(input);
            self.network_source_ip_v4 = Some(v);
            self
        }
        /// <p>The source IPv4 address of network-related information about a finding.</p>
        pub fn set_network_source_ip_v4(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IpFilter>>,
        ) -> Self {
            self.network_source_ip_v4 = input;
            self
        }
        /// Appends an item to `network_source_ip_v6`.
        ///
        /// To override the contents of this collection use [`set_network_source_ip_v6`](Self::set_network_source_ip_v6).
        ///
        /// <p>The source IPv6 address of network-related information about a finding.</p>
        pub fn network_source_ip_v6(mut self, input: crate::model::IpFilter) -> Self {
            let mut v = self.network_source_ip_v6.unwrap_or_default();
            v.push(input);
            self.network_source_ip_v6 = Some(v);
            self
        }
        /// <p>The source IPv6 address of network-related information about a finding.</p>
        pub fn set_network_source_ip_v6(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IpFilter>>,
        ) -> Self {
            self.network_source_ip_v6 = input;
            self
        }
        /// Appends an item to `network_source_port`.
        ///
        /// To override the contents of this collection use [`set_network_source_port`](Self::set_network_source_port).
        ///
        /// <p>The source port of network-related information about a finding.</p>
        pub fn network_source_port(mut self, input: crate::model::NumberFilter) -> Self {
            let mut v = self.network_source_port.unwrap_or_default();
            v.push(input);
            self.network_source_port = Some(v);
            self
        }
        /// <p>The source port of network-related information about a finding.</p>
        pub fn set_network_source_port(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
        ) -> Self {
            self.network_source_port = input;
            self
        }
        /// Appends an item to `network_source_domain`.
        ///
        /// To override the contents of this collection use [`set_network_source_domain`](Self::set_network_source_domain).
        ///
        /// <p>The source domain of network-related information about a finding.</p>
        pub fn network_source_domain(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.network_source_domain.unwrap_or_default();
            v.push(input);
            self.network_source_domain = Some(v);
            self
        }
        /// <p>The source domain of network-related information about a finding.</p>
        pub fn set_network_source_domain(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.network_source_domain = input;
            self
        }
        /// Appends an item to `network_source_mac`.
        ///
        /// To override the contents of this collection use [`set_network_source_mac`](Self::set_network_source_mac).
        ///
        /// <p>The source media access control (MAC) address of network-related information about a finding.</p>
        pub fn network_source_mac(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.network_source_mac.unwrap_or_default();
            v.push(input);
            self.network_source_mac = Some(v);
            self
        }
        /// <p>The source media access control (MAC) address of network-related information about a finding.</p>
        pub fn set_network_source_mac(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.network_source_mac = input;
            self
        }
        /// Appends an item to `network_destination_ip_v4`.
        ///
        /// To override the contents of this collection use [`set_network_destination_ip_v4`](Self::set_network_destination_ip_v4).
        ///
        /// <p>The destination IPv4 address of network-related information about a finding.</p>
        pub fn network_destination_ip_v4(mut self, input: crate::model::IpFilter) -> Self {
            let mut v = self.network_destination_ip_v4.unwrap_or_default();
            v.push(input);
            self.network_destination_ip_v4 = Some(v);
            self
        }
        /// <p>The destination IPv4 address of network-related information about a finding.</p>
        pub fn set_network_destination_ip_v4(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IpFilter>>,
        ) -> Self {
            self.network_destination_ip_v4 = input;
            self
        }
        /// Appends an item to `network_destination_ip_v6`.
        ///
        /// To override the contents of this collection use [`set_network_destination_ip_v6`](Self::set_network_destination_ip_v6).
        ///
        /// <p>The destination IPv6 address of network-related information about a finding.</p>
        pub fn network_destination_ip_v6(mut self, input: crate::model::IpFilter) -> Self {
            let mut v = self.network_destination_ip_v6.unwrap_or_default();
            v.push(input);
            self.network_destination_ip_v6 = Some(v);
            self
        }
        /// <p>The destination IPv6 address of network-related information about a finding.</p>
        pub fn set_network_destination_ip_v6(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IpFilter>>,
        ) -> Self {
            self.network_destination_ip_v6 = input;
            self
        }
        /// Appends an item to `network_destination_port`.
        ///
        /// To override the contents of this collection use [`set_network_destination_port`](Self::set_network_destination_port).
        ///
        /// <p>The destination port of network-related information about a finding.</p>
        pub fn network_destination_port(mut self, input: crate::model::NumberFilter) -> Self {
            let mut v = self.network_destination_port.unwrap_or_default();
            v.push(input);
            self.network_destination_port = Some(v);
            self
        }
        /// <p>The destination port of network-related information about a finding.</p>
        pub fn set_network_destination_port(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
        ) -> Self {
            self.network_destination_port = input;
            self
        }
        /// Appends an item to `network_destination_domain`.
        ///
        /// To override the contents of this collection use [`set_network_destination_domain`](Self::set_network_destination_domain).
        ///
        /// <p>The destination domain of network-related information about a finding.</p>
        pub fn network_destination_domain(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.network_destination_domain.unwrap_or_default();
            v.push(input);
            self.network_destination_domain = Some(v);
            self
        }
        /// <p>The destination domain of network-related information about a finding.</p>
        pub fn set_network_destination_domain(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.network_destination_domain = input;
            self
        }
        /// Appends an item to `process_name`.
        ///
        /// To override the contents of this collection use [`set_process_name`](Self::set_process_name).
        ///
        /// <p>The name of the process.</p>
        pub fn process_name(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.process_name.unwrap_or_default();
            v.push(input);
            self.process_name = Some(v);
            self
        }
        /// <p>The name of the process.</p>
        pub fn set_process_name(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.process_name = input;
            self
        }
        /// Appends an item to `process_path`.
        ///
        /// To override the contents of this collection use [`set_process_path`](Self::set_process_path).
        ///
        /// <p>The path to the process executable.</p>
        pub fn process_path(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.process_path.unwrap_or_default();
            v.push(input);
            self.process_path = Some(v);
            self
        }
        /// <p>The path to the process executable.</p>
        pub fn set_process_path(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.process_path = input;
            self
        }
        /// Appends an item to `process_pid`.
        ///
        /// To override the contents of this collection use [`set_process_pid`](Self::set_process_pid).
        ///
        /// <p>The process ID.</p>
        pub fn process_pid(mut self, input: crate::model::NumberFilter) -> Self {
            let mut v = self.process_pid.unwrap_or_default();
            v.push(input);
            self.process_pid = Some(v);
            self
        }
        /// <p>The process ID.</p>
        pub fn set_process_pid(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
        ) -> Self {
            self.process_pid = input;
            self
        }
        /// Appends an item to `process_parent_pid`.
        ///
        /// To override the contents of this collection use [`set_process_parent_pid`](Self::set_process_parent_pid).
        ///
        /// <p>The parent process ID.</p>
        pub fn process_parent_pid(mut self, input: crate::model::NumberFilter) -> Self {
            let mut v = self.process_parent_pid.unwrap_or_default();
            v.push(input);
            self.process_parent_pid = Some(v);
            self
        }
        /// <p>The parent process ID.</p>
        pub fn set_process_parent_pid(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
        ) -> Self {
            self.process_parent_pid = input;
            self
        }
        /// Appends an item to `process_launched_at`.
        ///
        /// To override the contents of this collection use [`set_process_launched_at`](Self::set_process_launched_at).
        ///
        /// <p>The date/time that the process was launched.</p>
        pub fn process_launched_at(mut self, input: crate::model::DateFilter) -> Self {
            let mut v = self.process_launched_at.unwrap_or_default();
            v.push(input);
            self.process_launched_at = Some(v);
            self
        }
        /// <p>The date/time that the process was launched.</p>
        pub fn set_process_launched_at(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
        ) -> Self {
            self.process_launched_at = input;
            self
        }
        /// Appends an item to `process_terminated_at`.
        ///
        /// To override the contents of this collection use [`set_process_terminated_at`](Self::set_process_terminated_at).
        ///
        /// <p>The date/time that the process was terminated.</p>
        pub fn process_terminated_at(mut self, input: crate::model::DateFilter) -> Self {
            let mut v = self.process_terminated_at.unwrap_or_default();
            v.push(input);
            self.process_terminated_at = Some(v);
            self
        }
        /// <p>The date/time that the process was terminated.</p>
        pub fn set_process_terminated_at(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
        ) -> Self {
            self.process_terminated_at = input;
            self
        }
        /// Appends an item to `threat_intel_indicator_type`.
        ///
        /// To override the contents of this collection use [`set_threat_intel_indicator_type`](Self::set_threat_intel_indicator_type).
        ///
        /// <p>The type of a threat intelligence indicator.</p>
        pub fn threat_intel_indicator_type(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.threat_intel_indicator_type.unwrap_or_default();
            v.push(input);
            self.threat_intel_indicator_type = Some(v);
            self
        }
        /// <p>The type of a threat intelligence indicator.</p>
        pub fn set_threat_intel_indicator_type(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.threat_intel_indicator_type = input;
            self
        }
        /// Appends an item to `threat_intel_indicator_value`.
        ///
        /// To override the contents of this collection use [`set_threat_intel_indicator_value`](Self::set_threat_intel_indicator_value).
        ///
        /// <p>The value of a threat intelligence indicator.</p>
        pub fn threat_intel_indicator_value(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.threat_intel_indicator_value.unwrap_or_default();
            v.push(input);
            self.threat_intel_indicator_value = Some(v);
            self
        }
        /// <p>The value of a threat intelligence indicator.</p>
        pub fn set_threat_intel_indicator_value(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.threat_intel_indicator_value = input;
            self
        }
        /// Appends an item to `threat_intel_indicator_category`.
        ///
        /// To override the contents of this collection use [`set_threat_intel_indicator_category`](Self::set_threat_intel_indicator_category).
        ///
        /// <p>The category of a threat intelligence indicator.</p>
        pub fn threat_intel_indicator_category(
            mut self,
            input: crate::model::StringFilter,
        ) -> Self {
            let mut v = self.threat_intel_indicator_category.unwrap_or_default();
            v.push(input);
            self.threat_intel_indicator_category = Some(v);
            self
        }
        /// <p>The category of a threat intelligence indicator.</p>
        pub fn set_threat_intel_indicator_category(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.threat_intel_indicator_category = input;
            self
        }
        /// Appends an item to `threat_intel_indicator_last_observed_at`.
        ///
        /// To override the contents of this collection use [`set_threat_intel_indicator_last_observed_at`](Self::set_threat_intel_indicator_last_observed_at).
        ///
        /// <p>The date/time of the last observation of a threat intelligence indicator.</p>
        pub fn threat_intel_indicator_last_observed_at(
            mut self,
            input: crate::model::DateFilter,
        ) -> Self {
            let mut v = self
                .threat_intel_indicator_last_observed_at
                .unwrap_or_default();
            v.push(input);
            self.threat_intel_indicator_last_observed_at = Some(v);
            self
        }
        /// <p>The date/time of the last observation of a threat intelligence indicator.</p>
        pub fn set_threat_intel_indicator_last_observed_at(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
        ) -> Self {
            self.threat_intel_indicator_last_observed_at = input;
            self
        }
        /// Appends an item to `threat_intel_indicator_source`.
        ///
        /// To override the contents of this collection use [`set_threat_intel_indicator_source`](Self::set_threat_intel_indicator_source).
        ///
        /// <p>The source of the threat intelligence.</p>
        pub fn threat_intel_indicator_source(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.threat_intel_indicator_source.unwrap_or_default();
            v.push(input);
            self.threat_intel_indicator_source = Some(v);
            self
        }
        /// <p>The source of the threat intelligence.</p>
        pub fn set_threat_intel_indicator_source(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.threat_intel_indicator_source = input;
            self
        }
        /// Appends an item to `threat_intel_indicator_source_url`.
        ///
        /// To override the contents of this collection use [`set_threat_intel_indicator_source_url`](Self::set_threat_intel_indicator_source_url).
        ///
        /// <p>The URL for more details from the source of the threat intelligence.</p>
        pub fn threat_intel_indicator_source_url(
            mut self,
            input: crate::model::StringFilter,
        ) -> Self {
            let mut v = self.threat_intel_indicator_source_url.unwrap_or_default();
            v.push(input);
            self.threat_intel_indicator_source_url = Some(v);
            self
        }
        /// <p>The URL for more details from the source of the threat intelligence.</p>
        pub fn set_threat_intel_indicator_source_url(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.threat_intel_indicator_source_url = input;
            self
        }
        /// Appends an item to `resource_type`.
        ///
        /// To override the contents of this collection use [`set_resource_type`](Self::set_resource_type).
        ///
        /// <p>Specifies the type of the resource that details are provided for.</p>
        pub fn resource_type(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.resource_type.unwrap_or_default();
            v.push(input);
            self.resource_type = Some(v);
            self
        }
        /// <p>Specifies the type of the resource that details are provided for.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// Appends an item to `resource_id`.
        ///
        /// To override the contents of this collection use [`set_resource_id`](Self::set_resource_id).
        ///
        /// <p>The canonical identifier for the given resource type.</p>
        pub fn resource_id(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.resource_id.unwrap_or_default();
            v.push(input);
            self.resource_id = Some(v);
            self
        }
        /// <p>The canonical identifier for the given resource type.</p>
        pub fn set_resource_id(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.resource_id = input;
            self
        }
        /// Appends an item to `resource_partition`.
        ///
        /// To override the contents of this collection use [`set_resource_partition`](Self::set_resource_partition).
        ///
        /// <p>The canonical Amazon Web Services partition name that the Region is assigned to.</p>
        pub fn resource_partition(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.resource_partition.unwrap_or_default();
            v.push(input);
            self.resource_partition = Some(v);
            self
        }
        /// <p>The canonical Amazon Web Services partition name that the Region is assigned to.</p>
        pub fn set_resource_partition(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.resource_partition = input;
            self
        }
        /// Appends an item to `resource_region`.
        ///
        /// To override the contents of this collection use [`set_resource_region`](Self::set_resource_region).
        ///
        /// <p>The canonical Amazon Web Services external Region name where this resource is located.</p>
        pub fn resource_region(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.resource_region.unwrap_or_default();
            v.push(input);
            self.resource_region = Some(v);
            self
        }
        /// <p>The canonical Amazon Web Services external Region name where this resource is located.</p>
        pub fn set_resource_region(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.resource_region = input;
            self
        }
        /// Appends an item to `resource_tags`.
        ///
        /// To override the contents of this collection use [`set_resource_tags`](Self::set_resource_tags).
        ///
        /// <p>A list of Amazon Web Services tags associated with a resource at the time the finding was processed.</p>
        pub fn resource_tags(mut self, input: crate::model::MapFilter) -> Self {
            let mut v = self.resource_tags.unwrap_or_default();
            v.push(input);
            self.resource_tags = Some(v);
            self
        }
        /// <p>A list of Amazon Web Services tags associated with a resource at the time the finding was processed.</p>
        pub fn set_resource_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MapFilter>>,
        ) -> Self {
            self.resource_tags = input;
            self
        }
        /// Appends an item to `resource_aws_ec2_instance_type`.
        ///
        /// To override the contents of this collection use [`set_resource_aws_ec2_instance_type`](Self::set_resource_aws_ec2_instance_type).
        ///
        /// <p>The instance type of the instance.</p>
        pub fn resource_aws_ec2_instance_type(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.resource_aws_ec2_instance_type.unwrap_or_default();
            v.push(input);
            self.resource_aws_ec2_instance_type = Some(v);
            self
        }
        /// <p>The instance type of the instance.</p>
        pub fn set_resource_aws_ec2_instance_type(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.resource_aws_ec2_instance_type = input;
            self
        }
        /// Appends an item to `resource_aws_ec2_instance_image_id`.
        ///
        /// To override the contents of this collection use [`set_resource_aws_ec2_instance_image_id`](Self::set_resource_aws_ec2_instance_image_id).
        ///
        /// <p>The Amazon Machine Image (AMI) ID of the instance.</p>
        pub fn resource_aws_ec2_instance_image_id(
            mut self,
            input: crate::model::StringFilter,
        ) -> Self {
            let mut v = self.resource_aws_ec2_instance_image_id.unwrap_or_default();
            v.push(input);
            self.resource_aws_ec2_instance_image_id = Some(v);
            self
        }
        /// <p>The Amazon Machine Image (AMI) ID of the instance.</p>
        pub fn set_resource_aws_ec2_instance_image_id(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.resource_aws_ec2_instance_image_id = input;
            self
        }
        /// Appends an item to `resource_aws_ec2_instance_ip_v4_addresses`.
        ///
        /// To override the contents of this collection use [`set_resource_aws_ec2_instance_ip_v4_addresses`](Self::set_resource_aws_ec2_instance_ip_v4_addresses).
        ///
        /// <p>The IPv4 addresses associated with the instance.</p>
        pub fn resource_aws_ec2_instance_ip_v4_addresses(
            mut self,
            input: crate::model::IpFilter,
        ) -> Self {
            let mut v = self
                .resource_aws_ec2_instance_ip_v4_addresses
                .unwrap_or_default();
            v.push(input);
            self.resource_aws_ec2_instance_ip_v4_addresses = Some(v);
            self
        }
        /// <p>The IPv4 addresses associated with the instance.</p>
        pub fn set_resource_aws_ec2_instance_ip_v4_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IpFilter>>,
        ) -> Self {
            self.resource_aws_ec2_instance_ip_v4_addresses = input;
            self
        }
        /// Appends an item to `resource_aws_ec2_instance_ip_v6_addresses`.
        ///
        /// To override the contents of this collection use [`set_resource_aws_ec2_instance_ip_v6_addresses`](Self::set_resource_aws_ec2_instance_ip_v6_addresses).
        ///
        /// <p>The IPv6 addresses associated with the instance.</p>
        pub fn resource_aws_ec2_instance_ip_v6_addresses(
            mut self,
            input: crate::model::IpFilter,
        ) -> Self {
            let mut v = self
                .resource_aws_ec2_instance_ip_v6_addresses
                .unwrap_or_default();
            v.push(input);
            self.resource_aws_ec2_instance_ip_v6_addresses = Some(v);
            self
        }
        /// <p>The IPv6 addresses associated with the instance.</p>
        pub fn set_resource_aws_ec2_instance_ip_v6_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IpFilter>>,
        ) -> Self {
            self.resource_aws_ec2_instance_ip_v6_addresses = input;
            self
        }
        /// Appends an item to `resource_aws_ec2_instance_key_name`.
        ///
        /// To override the contents of this collection use [`set_resource_aws_ec2_instance_key_name`](Self::set_resource_aws_ec2_instance_key_name).
        ///
        /// <p>The key name associated with the instance.</p>
        pub fn resource_aws_ec2_instance_key_name(
            mut self,
            input: crate::model::StringFilter,
        ) -> Self {
            let mut v = self.resource_aws_ec2_instance_key_name.unwrap_or_default();
            v.push(input);
            self.resource_aws_ec2_instance_key_name = Some(v);
            self
        }
        /// <p>The key name associated with the instance.</p>
        pub fn set_resource_aws_ec2_instance_key_name(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.resource_aws_ec2_instance_key_name = input;
            self
        }
        /// Appends an item to `resource_aws_ec2_instance_iam_instance_profile_arn`.
        ///
        /// To override the contents of this collection use [`set_resource_aws_ec2_instance_iam_instance_profile_arn`](Self::set_resource_aws_ec2_instance_iam_instance_profile_arn).
        ///
        /// <p>The IAM profile ARN of the instance.</p>
        pub fn resource_aws_ec2_instance_iam_instance_profile_arn(
            mut self,
            input: crate::model::StringFilter,
        ) -> Self {
            let mut v = self
                .resource_aws_ec2_instance_iam_instance_profile_arn
                .unwrap_or_default();
            v.push(input);
            self.resource_aws_ec2_instance_iam_instance_profile_arn = Some(v);
            self
        }
        /// <p>The IAM profile ARN of the instance.</p>
        pub fn set_resource_aws_ec2_instance_iam_instance_profile_arn(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.resource_aws_ec2_instance_iam_instance_profile_arn = input;
            self
        }
        /// Appends an item to `resource_aws_ec2_instance_vpc_id`.
        ///
        /// To override the contents of this collection use [`set_resource_aws_ec2_instance_vpc_id`](Self::set_resource_aws_ec2_instance_vpc_id).
        ///
        /// <p>The identifier of the VPC that the instance was launched in.</p>
        pub fn resource_aws_ec2_instance_vpc_id(
            mut self,
            input: crate::model::StringFilter,
        ) -> Self {
            let mut v = self.resource_aws_ec2_instance_vpc_id.unwrap_or_default();
            v.push(input);
            self.resource_aws_ec2_instance_vpc_id = Some(v);
            self
        }
        /// <p>The identifier of the VPC that the instance was launched in.</p>
        pub fn set_resource_aws_ec2_instance_vpc_id(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.resource_aws_ec2_instance_vpc_id = input;
            self
        }
        /// Appends an item to `resource_aws_ec2_instance_subnet_id`.
        ///
        /// To override the contents of this collection use [`set_resource_aws_ec2_instance_subnet_id`](Self::set_resource_aws_ec2_instance_subnet_id).
        ///
        /// <p>The identifier of the subnet that the instance was launched in.</p>
        pub fn resource_aws_ec2_instance_subnet_id(
            mut self,
            input: crate::model::StringFilter,
        ) -> Self {
            let mut v = self.resource_aws_ec2_instance_subnet_id.unwrap_or_default();
            v.push(input);
            self.resource_aws_ec2_instance_subnet_id = Some(v);
            self
        }
        /// <p>The identifier of the subnet that the instance was launched in.</p>
        pub fn set_resource_aws_ec2_instance_subnet_id(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.resource_aws_ec2_instance_subnet_id = input;
            self
        }
        /// Appends an item to `resource_aws_ec2_instance_launched_at`.
        ///
        /// To override the contents of this collection use [`set_resource_aws_ec2_instance_launched_at`](Self::set_resource_aws_ec2_instance_launched_at).
        ///
        /// <p>The date and time the instance was launched.</p>
        pub fn resource_aws_ec2_instance_launched_at(
            mut self,
            input: crate::model::DateFilter,
        ) -> Self {
            let mut v = self
                .resource_aws_ec2_instance_launched_at
                .unwrap_or_default();
            v.push(input);
            self.resource_aws_ec2_instance_launched_at = Some(v);
            self
        }
        /// <p>The date and time the instance was launched.</p>
        pub fn set_resource_aws_ec2_instance_launched_at(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
        ) -> Self {
            self.resource_aws_ec2_instance_launched_at = input;
            self
        }
        /// Appends an item to `resource_aws_s3_bucket_owner_id`.
        ///
        /// To override the contents of this collection use [`set_resource_aws_s3_bucket_owner_id`](Self::set_resource_aws_s3_bucket_owner_id).
        ///
        /// <p>The canonical user ID of the owner of the S3 bucket.</p>
        pub fn resource_aws_s3_bucket_owner_id(
            mut self,
            input: crate::model::StringFilter,
        ) -> Self {
            let mut v = self.resource_aws_s3_bucket_owner_id.unwrap_or_default();
            v.push(input);
            self.resource_aws_s3_bucket_owner_id = Some(v);
            self
        }
        /// <p>The canonical user ID of the owner of the S3 bucket.</p>
        pub fn set_resource_aws_s3_bucket_owner_id(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.resource_aws_s3_bucket_owner_id = input;
            self
        }
        /// Appends an item to `resource_aws_s3_bucket_owner_name`.
        ///
        /// To override the contents of this collection use [`set_resource_aws_s3_bucket_owner_name`](Self::set_resource_aws_s3_bucket_owner_name).
        ///
        /// <p>The display name of the owner of the S3 bucket.</p>
        pub fn resource_aws_s3_bucket_owner_name(
            mut self,
            input: crate::model::StringFilter,
        ) -> Self {
            let mut v = self.resource_aws_s3_bucket_owner_name.unwrap_or_default();
            v.push(input);
            self.resource_aws_s3_bucket_owner_name = Some(v);
            self
        }
        /// <p>The display name of the owner of the S3 bucket.</p>
        pub fn set_resource_aws_s3_bucket_owner_name(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.resource_aws_s3_bucket_owner_name = input;
            self
        }
        /// Appends an item to `resource_aws_iam_access_key_user_name`.
        ///
        /// To override the contents of this collection use [`set_resource_aws_iam_access_key_user_name`](Self::set_resource_aws_iam_access_key_user_name).
        ///
        /// <p>The user associated with the IAM access key related to a finding.</p>
        pub fn resource_aws_iam_access_key_user_name(
            mut self,
            input: crate::model::StringFilter,
        ) -> Self {
            let mut v = self
                .resource_aws_iam_access_key_user_name
                .unwrap_or_default();
            v.push(input);
            self.resource_aws_iam_access_key_user_name = Some(v);
            self
        }
        /// <p>The user associated with the IAM access key related to a finding.</p>
        pub fn set_resource_aws_iam_access_key_user_name(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.resource_aws_iam_access_key_user_name = input;
            self
        }
        /// Appends an item to `resource_aws_iam_access_key_principal_name`.
        ///
        /// To override the contents of this collection use [`set_resource_aws_iam_access_key_principal_name`](Self::set_resource_aws_iam_access_key_principal_name).
        ///
        /// <p>The name of the principal that is associated with an IAM access key.</p>
        pub fn resource_aws_iam_access_key_principal_name(
            mut self,
            input: crate::model::StringFilter,
        ) -> Self {
            let mut v = self
                .resource_aws_iam_access_key_principal_name
                .unwrap_or_default();
            v.push(input);
            self.resource_aws_iam_access_key_principal_name = Some(v);
            self
        }
        /// <p>The name of the principal that is associated with an IAM access key.</p>
        pub fn set_resource_aws_iam_access_key_principal_name(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.resource_aws_iam_access_key_principal_name = input;
            self
        }
        /// Appends an item to `resource_aws_iam_access_key_status`.
        ///
        /// To override the contents of this collection use [`set_resource_aws_iam_access_key_status`](Self::set_resource_aws_iam_access_key_status).
        ///
        /// <p>The status of the IAM access key related to a finding.</p>
        pub fn resource_aws_iam_access_key_status(
            mut self,
            input: crate::model::StringFilter,
        ) -> Self {
            let mut v = self.resource_aws_iam_access_key_status.unwrap_or_default();
            v.push(input);
            self.resource_aws_iam_access_key_status = Some(v);
            self
        }
        /// <p>The status of the IAM access key related to a finding.</p>
        pub fn set_resource_aws_iam_access_key_status(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.resource_aws_iam_access_key_status = input;
            self
        }
        /// Appends an item to `resource_aws_iam_access_key_created_at`.
        ///
        /// To override the contents of this collection use [`set_resource_aws_iam_access_key_created_at`](Self::set_resource_aws_iam_access_key_created_at).
        ///
        /// <p>The creation date/time of the IAM access key related to a finding.</p>
        pub fn resource_aws_iam_access_key_created_at(
            mut self,
            input: crate::model::DateFilter,
        ) -> Self {
            let mut v = self
                .resource_aws_iam_access_key_created_at
                .unwrap_or_default();
            v.push(input);
            self.resource_aws_iam_access_key_created_at = Some(v);
            self
        }
        /// <p>The creation date/time of the IAM access key related to a finding.</p>
        pub fn set_resource_aws_iam_access_key_created_at(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
        ) -> Self {
            self.resource_aws_iam_access_key_created_at = input;
            self
        }
        /// Appends an item to `resource_aws_iam_user_user_name`.
        ///
        /// To override the contents of this collection use [`set_resource_aws_iam_user_user_name`](Self::set_resource_aws_iam_user_user_name).
        ///
        /// <p>The name of an IAM user.</p>
        pub fn resource_aws_iam_user_user_name(
            mut self,
            input: crate::model::StringFilter,
        ) -> Self {
            let mut v = self.resource_aws_iam_user_user_name.unwrap_or_default();
            v.push(input);
            self.resource_aws_iam_user_user_name = Some(v);
            self
        }
        /// <p>The name of an IAM user.</p>
        pub fn set_resource_aws_iam_user_user_name(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.resource_aws_iam_user_user_name = input;
            self
        }
        /// Appends an item to `resource_container_name`.
        ///
        /// To override the contents of this collection use [`set_resource_container_name`](Self::set_resource_container_name).
        ///
        /// <p>The name of the container related to a finding.</p>
        pub fn resource_container_name(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.resource_container_name.unwrap_or_default();
            v.push(input);
            self.resource_container_name = Some(v);
            self
        }
        /// <p>The name of the container related to a finding.</p>
        pub fn set_resource_container_name(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.resource_container_name = input;
            self
        }
        /// Appends an item to `resource_container_image_id`.
        ///
        /// To override the contents of this collection use [`set_resource_container_image_id`](Self::set_resource_container_image_id).
        ///
        /// <p>The identifier of the image related to a finding.</p>
        pub fn resource_container_image_id(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.resource_container_image_id.unwrap_or_default();
            v.push(input);
            self.resource_container_image_id = Some(v);
            self
        }
        /// <p>The identifier of the image related to a finding.</p>
        pub fn set_resource_container_image_id(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.resource_container_image_id = input;
            self
        }
        /// Appends an item to `resource_container_image_name`.
        ///
        /// To override the contents of this collection use [`set_resource_container_image_name`](Self::set_resource_container_image_name).
        ///
        /// <p>The name of the image related to a finding.</p>
        pub fn resource_container_image_name(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.resource_container_image_name.unwrap_or_default();
            v.push(input);
            self.resource_container_image_name = Some(v);
            self
        }
        /// <p>The name of the image related to a finding.</p>
        pub fn set_resource_container_image_name(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.resource_container_image_name = input;
            self
        }
        /// Appends an item to `resource_container_launched_at`.
        ///
        /// To override the contents of this collection use [`set_resource_container_launched_at`](Self::set_resource_container_launched_at).
        ///
        /// <p>The date/time that the container was started.</p>
        pub fn resource_container_launched_at(mut self, input: crate::model::DateFilter) -> Self {
            let mut v = self.resource_container_launched_at.unwrap_or_default();
            v.push(input);
            self.resource_container_launched_at = Some(v);
            self
        }
        /// <p>The date/time that the container was started.</p>
        pub fn set_resource_container_launched_at(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
        ) -> Self {
            self.resource_container_launched_at = input;
            self
        }
        /// Appends an item to `resource_details_other`.
        ///
        /// To override the contents of this collection use [`set_resource_details_other`](Self::set_resource_details_other).
        ///
        /// <p>The details of a resource that doesn't have a specific subfield for the resource type defined.</p>
        pub fn resource_details_other(mut self, input: crate::model::MapFilter) -> Self {
            let mut v = self.resource_details_other.unwrap_or_default();
            v.push(input);
            self.resource_details_other = Some(v);
            self
        }
        /// <p>The details of a resource that doesn't have a specific subfield for the resource type defined.</p>
        pub fn set_resource_details_other(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MapFilter>>,
        ) -> Self {
            self.resource_details_other = input;
            self
        }
        /// Appends an item to `compliance_status`.
        ///
        /// To override the contents of this collection use [`set_compliance_status`](Self::set_compliance_status).
        ///
        /// <p>Exclusive to findings that are generated as the result of a check run against a specific rule in a supported standard, such as CIS Amazon Web Services Foundations. Contains security standard-related finding details.</p>
        pub fn compliance_status(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.compliance_status.unwrap_or_default();
            v.push(input);
            self.compliance_status = Some(v);
            self
        }
        /// <p>Exclusive to findings that are generated as the result of a check run against a specific rule in a supported standard, such as CIS Amazon Web Services Foundations. Contains security standard-related finding details.</p>
        pub fn set_compliance_status(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.compliance_status = input;
            self
        }
        /// Appends an item to `verification_state`.
        ///
        /// To override the contents of this collection use [`set_verification_state`](Self::set_verification_state).
        ///
        /// <p>The veracity of a finding.</p>
        pub fn verification_state(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.verification_state.unwrap_or_default();
            v.push(input);
            self.verification_state = Some(v);
            self
        }
        /// <p>The veracity of a finding.</p>
        pub fn set_verification_state(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.verification_state = input;
            self
        }
        /// Appends an item to `workflow_state`.
        ///
        /// To override the contents of this collection use [`set_workflow_state`](Self::set_workflow_state).
        ///
        /// <p>The workflow state of a finding.</p>
        /// <p>Note that this field is deprecated. To search for a finding based on its workflow status, use <code>WorkflowStatus</code>.</p>
        pub fn workflow_state(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.workflow_state.unwrap_or_default();
            v.push(input);
            self.workflow_state = Some(v);
            self
        }
        /// <p>The workflow state of a finding.</p>
        /// <p>Note that this field is deprecated. To search for a finding based on its workflow status, use <code>WorkflowStatus</code>.</p>
        pub fn set_workflow_state(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.workflow_state = input;
            self
        }
        /// Appends an item to `workflow_status`.
        ///
        /// To override the contents of this collection use [`set_workflow_status`](Self::set_workflow_status).
        ///
        /// <p>The status of the investigation into a finding. Allowed values are the following.</p>
        /// <ul>
        /// <li> <p> <code>NEW</code> - The initial state of a finding, before it is reviewed.</p> <p>Security Hub also resets the workflow status from <code>NOTIFIED</code> or <code>RESOLVED</code> to <code>NEW</code> in the following cases:</p>
        /// <ul>
        /// <li> <p> <code>RecordState</code> changes from <code>ARCHIVED</code> to <code>ACTIVE</code>.</p> </li>
        /// <li> <p> <code>Compliance.Status</code> changes from <code>PASSED</code> to either <code>WARNING</code>, <code>FAILED</code>, or <code>NOT_AVAILABLE</code>.</p> </li>
        /// </ul> </li>
        /// <li> <p> <code>NOTIFIED</code> - Indicates that the resource owner has been notified about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner.</p> <p>If one of the following occurs, the workflow status is changed automatically from <code>NOTIFIED</code> to <code>NEW</code>:</p>
        /// <ul>
        /// <li> <p> <code>RecordState</code> changes from <code>ARCHIVED</code> to <code>ACTIVE</code>.</p> </li>
        /// <li> <p> <code>Compliance.Status</code> changes from <code>PASSED</code> to <code>FAILED</code>, <code>WARNING</code>, or <code>NOT_AVAILABLE</code>.</p> </li>
        /// </ul> </li>
        /// <li> <p> <code>SUPPRESSED</code> - Indicates that you reviewed the finding and do not believe that any action is needed.</p> <p>The workflow status of a <code>SUPPRESSED</code> finding does not change if <code>RecordState</code> changes from <code>ARCHIVED</code> to <code>ACTIVE</code>.</p> </li>
        /// <li> <p> <code>RESOLVED</code> - The finding was reviewed and remediated and is now considered resolved. </p> <p>The finding remains <code>RESOLVED</code> unless one of the following occurs:</p>
        /// <ul>
        /// <li> <p> <code>RecordState</code> changes from <code>ARCHIVED</code> to <code>ACTIVE</code>.</p> </li>
        /// <li> <p> <code>Compliance.Status</code> changes from <code>PASSED</code> to <code>FAILED</code>, <code>WARNING</code>, or <code>NOT_AVAILABLE</code>.</p> </li>
        /// </ul> <p>In those cases, the workflow status is automatically reset to <code>NEW</code>.</p> <p>For findings from controls, if <code>Compliance.Status</code> is <code>PASSED</code>, then Security Hub automatically sets the workflow status to <code>RESOLVED</code>.</p> </li>
        /// </ul>
        pub fn workflow_status(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.workflow_status.unwrap_or_default();
            v.push(input);
            self.workflow_status = Some(v);
            self
        }
        /// <p>The status of the investigation into a finding. Allowed values are the following.</p>
        /// <ul>
        /// <li> <p> <code>NEW</code> - The initial state of a finding, before it is reviewed.</p> <p>Security Hub also resets the workflow status from <code>NOTIFIED</code> or <code>RESOLVED</code> to <code>NEW</code> in the following cases:</p>
        /// <ul>
        /// <li> <p> <code>RecordState</code> changes from <code>ARCHIVED</code> to <code>ACTIVE</code>.</p> </li>
        /// <li> <p> <code>Compliance.Status</code> changes from <code>PASSED</code> to either <code>WARNING</code>, <code>FAILED</code>, or <code>NOT_AVAILABLE</code>.</p> </li>
        /// </ul> </li>
        /// <li> <p> <code>NOTIFIED</code> - Indicates that the resource owner has been notified about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner.</p> <p>If one of the following occurs, the workflow status is changed automatically from <code>NOTIFIED</code> to <code>NEW</code>:</p>
        /// <ul>
        /// <li> <p> <code>RecordState</code> changes from <code>ARCHIVED</code> to <code>ACTIVE</code>.</p> </li>
        /// <li> <p> <code>Compliance.Status</code> changes from <code>PASSED</code> to <code>FAILED</code>, <code>WARNING</code>, or <code>NOT_AVAILABLE</code>.</p> </li>
        /// </ul> </li>
        /// <li> <p> <code>SUPPRESSED</code> - Indicates that you reviewed the finding and do not believe that any action is needed.</p> <p>The workflow status of a <code>SUPPRESSED</code> finding does not change if <code>RecordState</code> changes from <code>ARCHIVED</code> to <code>ACTIVE</code>.</p> </li>
        /// <li> <p> <code>RESOLVED</code> - The finding was reviewed and remediated and is now considered resolved. </p> <p>The finding remains <code>RESOLVED</code> unless one of the following occurs:</p>
        /// <ul>
        /// <li> <p> <code>RecordState</code> changes from <code>ARCHIVED</code> to <code>ACTIVE</code>.</p> </li>
        /// <li> <p> <code>Compliance.Status</code> changes from <code>PASSED</code> to <code>FAILED</code>, <code>WARNING</code>, or <code>NOT_AVAILABLE</code>.</p> </li>
        /// </ul> <p>In those cases, the workflow status is automatically reset to <code>NEW</code>.</p> <p>For findings from controls, if <code>Compliance.Status</code> is <code>PASSED</code>, then Security Hub automatically sets the workflow status to <code>RESOLVED</code>.</p> </li>
        /// </ul>
        pub fn set_workflow_status(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.workflow_status = input;
            self
        }
        /// Appends an item to `record_state`.
        ///
        /// To override the contents of this collection use [`set_record_state`](Self::set_record_state).
        ///
        /// <p>The updated record state for the finding.</p>
        pub fn record_state(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.record_state.unwrap_or_default();
            v.push(input);
            self.record_state = Some(v);
            self
        }
        /// <p>The updated record state for the finding.</p>
        pub fn set_record_state(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.record_state = input;
            self
        }
        /// Appends an item to `related_findings_product_arn`.
        ///
        /// To override the contents of this collection use [`set_related_findings_product_arn`](Self::set_related_findings_product_arn).
        ///
        /// <p>The ARN of the solution that generated a related finding.</p>
        pub fn related_findings_product_arn(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.related_findings_product_arn.unwrap_or_default();
            v.push(input);
            self.related_findings_product_arn = Some(v);
            self
        }
        /// <p>The ARN of the solution that generated a related finding.</p>
        pub fn set_related_findings_product_arn(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.related_findings_product_arn = input;
            self
        }
        /// Appends an item to `related_findings_id`.
        ///
        /// To override the contents of this collection use [`set_related_findings_id`](Self::set_related_findings_id).
        ///
        /// <p>The solution-generated identifier for a related finding.</p>
        pub fn related_findings_id(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.related_findings_id.unwrap_or_default();
            v.push(input);
            self.related_findings_id = Some(v);
            self
        }
        /// <p>The solution-generated identifier for a related finding.</p>
        pub fn set_related_findings_id(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.related_findings_id = input;
            self
        }
        /// Appends an item to `note_text`.
        ///
        /// To override the contents of this collection use [`set_note_text`](Self::set_note_text).
        ///
        /// <p>The text of a note.</p>
        pub fn note_text(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.note_text.unwrap_or_default();
            v.push(input);
            self.note_text = Some(v);
            self
        }
        /// <p>The text of a note.</p>
        pub fn set_note_text(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.note_text = input;
            self
        }
        /// Appends an item to `note_updated_at`.
        ///
        /// To override the contents of this collection use [`set_note_updated_at`](Self::set_note_updated_at).
        ///
        /// <p>The timestamp of when the note was updated.</p>
        pub fn note_updated_at(mut self, input: crate::model::DateFilter) -> Self {
            let mut v = self.note_updated_at.unwrap_or_default();
            v.push(input);
            self.note_updated_at = Some(v);
            self
        }
        /// <p>The timestamp of when the note was updated.</p>
        pub fn set_note_updated_at(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DateFilter>>,
        ) -> Self {
            self.note_updated_at = input;
            self
        }
        /// Appends an item to `note_updated_by`.
        ///
        /// To override the contents of this collection use [`set_note_updated_by`](Self::set_note_updated_by).
        ///
        /// <p>The principal that created a note.</p>
        pub fn note_updated_by(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.note_updated_by.unwrap_or_default();
            v.push(input);
            self.note_updated_by = Some(v);
            self
        }
        /// <p>The principal that created a note.</p>
        pub fn set_note_updated_by(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.note_updated_by = input;
            self
        }
        /// Appends an item to `keyword`.
        ///
        /// To override the contents of this collection use [`set_keyword`](Self::set_keyword).
        ///
        /// <p>A keyword for a finding.</p>
        pub fn keyword(mut self, input: crate::model::KeywordFilter) -> Self {
            let mut v = self.keyword.unwrap_or_default();
            v.push(input);
            self.keyword = Some(v);
            self
        }
        /// <p>A keyword for a finding.</p>
        pub fn set_keyword(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::KeywordFilter>>,
        ) -> Self {
            self.keyword = input;
            self
        }
        /// Appends an item to `finding_provider_fields_confidence`.
        ///
        /// To override the contents of this collection use [`set_finding_provider_fields_confidence`](Self::set_finding_provider_fields_confidence).
        ///
        /// <p>The finding provider value for the finding confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify.</p>
        /// <p>Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.</p>
        pub fn finding_provider_fields_confidence(
            mut self,
            input: crate::model::NumberFilter,
        ) -> Self {
            let mut v = self.finding_provider_fields_confidence.unwrap_or_default();
            v.push(input);
            self.finding_provider_fields_confidence = Some(v);
            self
        }
        /// <p>The finding provider value for the finding confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify.</p>
        /// <p>Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.</p>
        pub fn set_finding_provider_fields_confidence(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
        ) -> Self {
            self.finding_provider_fields_confidence = input;
            self
        }
        /// Appends an item to `finding_provider_fields_criticality`.
        ///
        /// To override the contents of this collection use [`set_finding_provider_fields_criticality`](Self::set_finding_provider_fields_criticality).
        ///
        /// <p>The finding provider value for the level of importance assigned to the resources associated with the findings.</p>
        /// <p>A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. </p>
        pub fn finding_provider_fields_criticality(
            mut self,
            input: crate::model::NumberFilter,
        ) -> Self {
            let mut v = self.finding_provider_fields_criticality.unwrap_or_default();
            v.push(input);
            self.finding_provider_fields_criticality = Some(v);
            self
        }
        /// <p>The finding provider value for the level of importance assigned to the resources associated with the findings.</p>
        /// <p>A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. </p>
        pub fn set_finding_provider_fields_criticality(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NumberFilter>>,
        ) -> Self {
            self.finding_provider_fields_criticality = input;
            self
        }
        /// Appends an item to `finding_provider_fields_related_findings_id`.
        ///
        /// To override the contents of this collection use [`set_finding_provider_fields_related_findings_id`](Self::set_finding_provider_fields_related_findings_id).
        ///
        /// <p>The finding identifier of a related finding that is identified by the finding provider.</p>
        pub fn finding_provider_fields_related_findings_id(
            mut self,
            input: crate::model::StringFilter,
        ) -> Self {
            let mut v = self
                .finding_provider_fields_related_findings_id
                .unwrap_or_default();
            v.push(input);
            self.finding_provider_fields_related_findings_id = Some(v);
            self
        }
        /// <p>The finding identifier of a related finding that is identified by the finding provider.</p>
        pub fn set_finding_provider_fields_related_findings_id(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.finding_provider_fields_related_findings_id = input;
            self
        }
        /// Appends an item to `finding_provider_fields_related_findings_product_arn`.
        ///
        /// To override the contents of this collection use [`set_finding_provider_fields_related_findings_product_arn`](Self::set_finding_provider_fields_related_findings_product_arn).
        ///
        /// <p>The ARN of the solution that generated a related finding that is identified by the finding provider.</p>
        pub fn finding_provider_fields_related_findings_product_arn(
            mut self,
            input: crate::model::StringFilter,
        ) -> Self {
            let mut v = self
                .finding_provider_fields_related_findings_product_arn
                .unwrap_or_default();
            v.push(input);
            self.finding_provider_fields_related_findings_product_arn = Some(v);
            self
        }
        /// <p>The ARN of the solution that generated a related finding that is identified by the finding provider.</p>
        pub fn set_finding_provider_fields_related_findings_product_arn(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.finding_provider_fields_related_findings_product_arn = input;
            self
        }
        /// Appends an item to `finding_provider_fields_severity_label`.
        ///
        /// To override the contents of this collection use [`set_finding_provider_fields_severity_label`](Self::set_finding_provider_fields_severity_label).
        ///
        /// <p>The finding provider value for the severity label.</p>
        pub fn finding_provider_fields_severity_label(
            mut self,
            input: crate::model::StringFilter,
        ) -> Self {
            let mut v = self
                .finding_provider_fields_severity_label
                .unwrap_or_default();
            v.push(input);
            self.finding_provider_fields_severity_label = Some(v);
            self
        }
        /// <p>The finding provider value for the severity label.</p>
        pub fn set_finding_provider_fields_severity_label(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.finding_provider_fields_severity_label = input;
            self
        }
        /// Appends an item to `finding_provider_fields_severity_original`.
        ///
        /// To override the contents of this collection use [`set_finding_provider_fields_severity_original`](Self::set_finding_provider_fields_severity_original).
        ///
        /// <p>The finding provider's original value for the severity.</p>
        pub fn finding_provider_fields_severity_original(
            mut self,
            input: crate::model::StringFilter,
        ) -> Self {
            let mut v = self
                .finding_provider_fields_severity_original
                .unwrap_or_default();
            v.push(input);
            self.finding_provider_fields_severity_original = Some(v);
            self
        }
        /// <p>The finding provider's original value for the severity.</p>
        pub fn set_finding_provider_fields_severity_original(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.finding_provider_fields_severity_original = input;
            self
        }
        /// Appends an item to `finding_provider_fields_types`.
        ///
        /// To override the contents of this collection use [`set_finding_provider_fields_types`](Self::set_finding_provider_fields_types).
        ///
        /// <p>One or more finding types that the finding provider assigned to the finding. Uses the format of <code>namespace/category/classifier</code> that classify a finding.</p>
        /// <p>Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual Behaviors | Sensitive Data Identifications</p>
        pub fn finding_provider_fields_types(mut self, input: crate::model::StringFilter) -> Self {
            let mut v = self.finding_provider_fields_types.unwrap_or_default();
            v.push(input);
            self.finding_provider_fields_types = Some(v);
            self
        }
        /// <p>One or more finding types that the finding provider assigned to the finding. Uses the format of <code>namespace/category/classifier</code> that classify a finding.</p>
        /// <p>Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual Behaviors | Sensitive Data Identifications</p>
        pub fn set_finding_provider_fields_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringFilter>>,
        ) -> Self {
            self.finding_provider_fields_types = input;
            self
        }
        /// Appends an item to `sample`.
        ///
        /// To override the contents of this collection use [`set_sample`](Self::set_sample).
        ///
        /// <p>Indicates whether or not sample findings are included in the filter results.</p>
        pub fn sample(mut self, input: crate::model::BooleanFilter) -> Self {
            let mut v = self.sample.unwrap_or_default();
            v.push(input);
            self.sample = Some(v);
            self
        }
        /// <p>Indicates whether or not sample findings are included in the filter results.</p>
        pub fn set_sample(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BooleanFilter>>,
        ) -> Self {
            self.sample = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsSecurityFindingFilters`](crate::model::AwsSecurityFindingFilters)
        pub fn build(self) -> crate::model::AwsSecurityFindingFilters {
            crate::model::AwsSecurityFindingFilters {
                product_arn: self.product_arn,
                aws_account_id: self.aws_account_id,
                id: self.id,
                generator_id: self.generator_id,
                region: self.region,
                r#type: self.r#type,
                first_observed_at: self.first_observed_at,
                last_observed_at: self.last_observed_at,
                created_at: self.created_at,
                updated_at: self.updated_at,
                severity_product: self.severity_product,
                severity_normalized: self.severity_normalized,
                severity_label: self.severity_label,
                confidence: self.confidence,
                criticality: self.criticality,
                title: self.title,
                description: self.description,
                recommendation_text: self.recommendation_text,
                source_url: self.source_url,
                product_fields: self.product_fields,
                product_name: self.product_name,
                company_name: self.company_name,
                user_defined_fields: self.user_defined_fields,
                malware_name: self.malware_name,
                malware_type: self.malware_type,
                malware_path: self.malware_path,
                malware_state: self.malware_state,
                network_direction: self.network_direction,
                network_protocol: self.network_protocol,
                network_source_ip_v4: self.network_source_ip_v4,
                network_source_ip_v6: self.network_source_ip_v6,
                network_source_port: self.network_source_port,
                network_source_domain: self.network_source_domain,
                network_source_mac: self.network_source_mac,
                network_destination_ip_v4: self.network_destination_ip_v4,
                network_destination_ip_v6: self.network_destination_ip_v6,
                network_destination_port: self.network_destination_port,
                network_destination_domain: self.network_destination_domain,
                process_name: self.process_name,
                process_path: self.process_path,
                process_pid: self.process_pid,
                process_parent_pid: self.process_parent_pid,
                process_launched_at: self.process_launched_at,
                process_terminated_at: self.process_terminated_at,
                threat_intel_indicator_type: self.threat_intel_indicator_type,
                threat_intel_indicator_value: self.threat_intel_indicator_value,
                threat_intel_indicator_category: self.threat_intel_indicator_category,
                threat_intel_indicator_last_observed_at: self
                    .threat_intel_indicator_last_observed_at,
                threat_intel_indicator_source: self.threat_intel_indicator_source,
                threat_intel_indicator_source_url: self.threat_intel_indicator_source_url,
                resource_type: self.resource_type,
                resource_id: self.resource_id,
                resource_partition: self.resource_partition,
                resource_region: self.resource_region,
                resource_tags: self.resource_tags,
                resource_aws_ec2_instance_type: self.resource_aws_ec2_instance_type,
                resource_aws_ec2_instance_image_id: self.resource_aws_ec2_instance_image_id,
                resource_aws_ec2_instance_ip_v4_addresses: self
                    .resource_aws_ec2_instance_ip_v4_addresses,
                resource_aws_ec2_instance_ip_v6_addresses: self
                    .resource_aws_ec2_instance_ip_v6_addresses,
                resource_aws_ec2_instance_key_name: self.resource_aws_ec2_instance_key_name,
                resource_aws_ec2_instance_iam_instance_profile_arn: self
                    .resource_aws_ec2_instance_iam_instance_profile_arn,
                resource_aws_ec2_instance_vpc_id: self.resource_aws_ec2_instance_vpc_id,
                resource_aws_ec2_instance_subnet_id: self.resource_aws_ec2_instance_subnet_id,
                resource_aws_ec2_instance_launched_at: self.resource_aws_ec2_instance_launched_at,
                resource_aws_s3_bucket_owner_id: self.resource_aws_s3_bucket_owner_id,
                resource_aws_s3_bucket_owner_name: self.resource_aws_s3_bucket_owner_name,
                resource_aws_iam_access_key_user_name: self.resource_aws_iam_access_key_user_name,
                resource_aws_iam_access_key_principal_name: self
                    .resource_aws_iam_access_key_principal_name,
                resource_aws_iam_access_key_status: self.resource_aws_iam_access_key_status,
                resource_aws_iam_access_key_created_at: self.resource_aws_iam_access_key_created_at,
                resource_aws_iam_user_user_name: self.resource_aws_iam_user_user_name,
                resource_container_name: self.resource_container_name,
                resource_container_image_id: self.resource_container_image_id,
                resource_container_image_name: self.resource_container_image_name,
                resource_container_launched_at: self.resource_container_launched_at,
                resource_details_other: self.resource_details_other,
                compliance_status: self.compliance_status,
                verification_state: self.verification_state,
                workflow_state: self.workflow_state,
                workflow_status: self.workflow_status,
                record_state: self.record_state,
                related_findings_product_arn: self.related_findings_product_arn,
                related_findings_id: self.related_findings_id,
                note_text: self.note_text,
                note_updated_at: self.note_updated_at,
                note_updated_by: self.note_updated_by,
                keyword: self.keyword,
                finding_provider_fields_confidence: self.finding_provider_fields_confidence,
                finding_provider_fields_criticality: self.finding_provider_fields_criticality,
                finding_provider_fields_related_findings_id: self
                    .finding_provider_fields_related_findings_id,
                finding_provider_fields_related_findings_product_arn: self
                    .finding_provider_fields_related_findings_product_arn,
                finding_provider_fields_severity_label: self.finding_provider_fields_severity_label,
                finding_provider_fields_severity_original: self
                    .finding_provider_fields_severity_original,
                finding_provider_fields_types: self.finding_provider_fields_types,
                sample: self.sample,
            }
        }
    }
}
impl AwsSecurityFindingFilters {
    /// Creates a new builder-style object to manufacture [`AwsSecurityFindingFilters`](crate::model::AwsSecurityFindingFilters)
    pub fn builder() -> crate::model::aws_security_finding_filters::Builder {
        crate::model::aws_security_finding_filters::Builder::default()
    }
}

/// <p>Boolean filter for querying findings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BooleanFilter {
    /// <p>The value of the boolean.</p>
    pub value: bool,
}
impl BooleanFilter {
    /// <p>The value of the boolean.</p>
    pub fn value(&self) -> bool {
        self.value
    }
}
impl std::fmt::Debug for BooleanFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BooleanFilter");
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`BooleanFilter`](crate::model::BooleanFilter)
pub mod boolean_filter {

    /// A builder for [`BooleanFilter`](crate::model::BooleanFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The value of the boolean.</p>
        pub fn value(mut self, input: bool) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of the boolean.</p>
        pub fn set_value(mut self, input: std::option::Option<bool>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`BooleanFilter`](crate::model::BooleanFilter)
        pub fn build(self) -> crate::model::BooleanFilter {
            crate::model::BooleanFilter {
                value: self.value.unwrap_or_default(),
            }
        }
    }
}
impl BooleanFilter {
    /// Creates a new builder-style object to manufacture [`BooleanFilter`](crate::model::BooleanFilter)
    pub fn builder() -> crate::model::boolean_filter::Builder {
        crate::model::boolean_filter::Builder::default()
    }
}

/// <p>A string filter for querying findings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StringFilter {
    /// <p>The string filter value. Filter values are case sensitive. For example, the product name for control-based findings is <code>Security Hub</code>. If you provide <code>security hub</code> as the filter text, then there is no match.</p>
    pub value: std::option::Option<std::string::String>,
    /// <p>The condition to apply to a string value when querying for findings. To search for values that contain the filter criteria value, use one of the following comparison operators:</p>
    /// <ul>
    /// <li> <p>To search for values that exactly match the filter value, use <code>EQUALS</code>.</p> <p>For example, the filter <code>ResourceType EQUALS AwsEc2SecurityGroup</code> only matches findings that have a resource type of <code>AwsEc2SecurityGroup</code>.</p> </li>
    /// <li> <p>To search for values that start with the filter value, use <code>PREFIX</code>.</p> <p>For example, the filter <code>ResourceType PREFIX AwsIam</code> matches findings that have a resource type that starts with <code>AwsIam</code>. Findings with a resource type of <code>AwsIamPolicy</code>, <code>AwsIamRole</code>, or <code>AwsIamUser</code> would all match.</p> </li>
    /// </ul>
    /// <p> <code>EQUALS</code> and <code>PREFIX</code> filters on the same field are joined by <code>OR</code>. A finding matches if it matches any one of those filters.</p>
    /// <p>To search for values that do not contain the filter criteria value, use one of the following comparison operators:</p>
    /// <ul>
    /// <li> <p>To search for values that do not exactly match the filter value, use <code>NOT_EQUALS</code>.</p> <p>For example, the filter <code>ResourceType NOT_EQUALS AwsIamPolicy</code> matches findings that have a resource type other than <code>AwsIamPolicy</code>.</p> </li>
    /// <li> <p>To search for values that do not start with the filter value, use <code>PREFIX_NOT_EQUALS</code>.</p> <p>For example, the filter <code>ResourceType PREFIX_NOT_EQUALS AwsIam</code> matches findings that have a resource type that does not start with <code>AwsIam</code>. Findings with a resource type of <code>AwsIamPolicy</code>, <code>AwsIamRole</code>, or <code>AwsIamUser</code> would all be excluded from the results.</p> </li>
    /// </ul>
    /// <p> <code>NOT_EQUALS</code> and <code>PREFIX_NOT_EQUALS</code> filters on the same field are joined by <code>AND</code>. A finding matches only if it matches all of those filters.</p>
    /// <p>For filters on the same field, you cannot provide both an <code>EQUALS</code> filter and a <code>NOT_EQUALS</code> or <code>PREFIX_NOT_EQUALS</code> filter. Combining filters in this way always returns an error, even if the provided filter values would return valid results.</p>
    /// <p>You can combine <code>PREFIX</code> filters with <code>NOT_EQUALS</code> or <code>PREFIX_NOT_EQUALS</code> filters for the same field. Security Hub first processes the <code>PREFIX</code> filters, then the <code>NOT_EQUALS</code> or <code>PREFIX_NOT_EQUALS</code> filters.</p>
    /// <p> For example, for the following filter, Security Hub first identifies findings that have resource types that start with either <code>AwsIAM</code> or <code>AwsEc2</code>. It then excludes findings that have a resource type of <code>AwsIamPolicy</code> and findings that have a resource type of <code>AwsEc2NetworkInterface</code>.</p>
    /// <ul>
    /// <li> <p> <code>ResourceType PREFIX AwsIam</code> </p> </li>
    /// <li> <p> <code>ResourceType PREFIX AwsEc2</code> </p> </li>
    /// <li> <p> <code>ResourceType NOT_EQUALS AwsIamPolicy</code> </p> </li>
    /// <li> <p> <code>ResourceType NOT_EQUALS AwsEc2NetworkInterface</code> </p> </li>
    /// </ul>
    pub comparison: std::option::Option<crate::model::StringFilterComparison>,
}
impl StringFilter {
    /// <p>The string filter value. Filter values are case sensitive. For example, the product name for control-based findings is <code>Security Hub</code>. If you provide <code>security hub</code> as the filter text, then there is no match.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>The condition to apply to a string value when querying for findings. To search for values that contain the filter criteria value, use one of the following comparison operators:</p>
    /// <ul>
    /// <li> <p>To search for values that exactly match the filter value, use <code>EQUALS</code>.</p> <p>For example, the filter <code>ResourceType EQUALS AwsEc2SecurityGroup</code> only matches findings that have a resource type of <code>AwsEc2SecurityGroup</code>.</p> </li>
    /// <li> <p>To search for values that start with the filter value, use <code>PREFIX</code>.</p> <p>For example, the filter <code>ResourceType PREFIX AwsIam</code> matches findings that have a resource type that starts with <code>AwsIam</code>. Findings with a resource type of <code>AwsIamPolicy</code>, <code>AwsIamRole</code>, or <code>AwsIamUser</code> would all match.</p> </li>
    /// </ul>
    /// <p> <code>EQUALS</code> and <code>PREFIX</code> filters on the same field are joined by <code>OR</code>. A finding matches if it matches any one of those filters.</p>
    /// <p>To search for values that do not contain the filter criteria value, use one of the following comparison operators:</p>
    /// <ul>
    /// <li> <p>To search for values that do not exactly match the filter value, use <code>NOT_EQUALS</code>.</p> <p>For example, the filter <code>ResourceType NOT_EQUALS AwsIamPolicy</code> matches findings that have a resource type other than <code>AwsIamPolicy</code>.</p> </li>
    /// <li> <p>To search for values that do not start with the filter value, use <code>PREFIX_NOT_EQUALS</code>.</p> <p>For example, the filter <code>ResourceType PREFIX_NOT_EQUALS AwsIam</code> matches findings that have a resource type that does not start with <code>AwsIam</code>. Findings with a resource type of <code>AwsIamPolicy</code>, <code>AwsIamRole</code>, or <code>AwsIamUser</code> would all be excluded from the results.</p> </li>
    /// </ul>
    /// <p> <code>NOT_EQUALS</code> and <code>PREFIX_NOT_EQUALS</code> filters on the same field are joined by <code>AND</code>. A finding matches only if it matches all of those filters.</p>
    /// <p>For filters on the same field, you cannot provide both an <code>EQUALS</code> filter and a <code>NOT_EQUALS</code> or <code>PREFIX_NOT_EQUALS</code> filter. Combining filters in this way always returns an error, even if the provided filter values would return valid results.</p>
    /// <p>You can combine <code>PREFIX</code> filters with <code>NOT_EQUALS</code> or <code>PREFIX_NOT_EQUALS</code> filters for the same field. Security Hub first processes the <code>PREFIX</code> filters, then the <code>NOT_EQUALS</code> or <code>PREFIX_NOT_EQUALS</code> filters.</p>
    /// <p> For example, for the following filter, Security Hub first identifies findings that have resource types that start with either <code>AwsIAM</code> or <code>AwsEc2</code>. It then excludes findings that have a resource type of <code>AwsIamPolicy</code> and findings that have a resource type of <code>AwsEc2NetworkInterface</code>.</p>
    /// <ul>
    /// <li> <p> <code>ResourceType PREFIX AwsIam</code> </p> </li>
    /// <li> <p> <code>ResourceType PREFIX AwsEc2</code> </p> </li>
    /// <li> <p> <code>ResourceType NOT_EQUALS AwsIamPolicy</code> </p> </li>
    /// <li> <p> <code>ResourceType NOT_EQUALS AwsEc2NetworkInterface</code> </p> </li>
    /// </ul>
    pub fn comparison(&self) -> std::option::Option<&crate::model::StringFilterComparison> {
        self.comparison.as_ref()
    }
}
impl std::fmt::Debug for StringFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StringFilter");
        formatter.field("value", &self.value);
        formatter.field("comparison", &self.comparison);
        formatter.finish()
    }
}
/// See [`StringFilter`](crate::model::StringFilter)
pub mod string_filter {

    /// A builder for [`StringFilter`](crate::model::StringFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) comparison: std::option::Option<crate::model::StringFilterComparison>,
    }
    impl Builder {
        /// <p>The string filter value. Filter values are case sensitive. For example, the product name for control-based findings is <code>Security Hub</code>. If you provide <code>security hub</code> as the filter text, then there is no match.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The string filter value. Filter values are case sensitive. For example, the product name for control-based findings is <code>Security Hub</code>. If you provide <code>security hub</code> as the filter text, then there is no match.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>The condition to apply to a string value when querying for findings. To search for values that contain the filter criteria value, use one of the following comparison operators:</p>
        /// <ul>
        /// <li> <p>To search for values that exactly match the filter value, use <code>EQUALS</code>.</p> <p>For example, the filter <code>ResourceType EQUALS AwsEc2SecurityGroup</code> only matches findings that have a resource type of <code>AwsEc2SecurityGroup</code>.</p> </li>
        /// <li> <p>To search for values that start with the filter value, use <code>PREFIX</code>.</p> <p>For example, the filter <code>ResourceType PREFIX AwsIam</code> matches findings that have a resource type that starts with <code>AwsIam</code>. Findings with a resource type of <code>AwsIamPolicy</code>, <code>AwsIamRole</code>, or <code>AwsIamUser</code> would all match.</p> </li>
        /// </ul>
        /// <p> <code>EQUALS</code> and <code>PREFIX</code> filters on the same field are joined by <code>OR</code>. A finding matches if it matches any one of those filters.</p>
        /// <p>To search for values that do not contain the filter criteria value, use one of the following comparison operators:</p>
        /// <ul>
        /// <li> <p>To search for values that do not exactly match the filter value, use <code>NOT_EQUALS</code>.</p> <p>For example, the filter <code>ResourceType NOT_EQUALS AwsIamPolicy</code> matches findings that have a resource type other than <code>AwsIamPolicy</code>.</p> </li>
        /// <li> <p>To search for values that do not start with the filter value, use <code>PREFIX_NOT_EQUALS</code>.</p> <p>For example, the filter <code>ResourceType PREFIX_NOT_EQUALS AwsIam</code> matches findings that have a resource type that does not start with <code>AwsIam</code>. Findings with a resource type of <code>AwsIamPolicy</code>, <code>AwsIamRole</code>, or <code>AwsIamUser</code> would all be excluded from the results.</p> </li>
        /// </ul>
        /// <p> <code>NOT_EQUALS</code> and <code>PREFIX_NOT_EQUALS</code> filters on the same field are joined by <code>AND</code>. A finding matches only if it matches all of those filters.</p>
        /// <p>For filters on the same field, you cannot provide both an <code>EQUALS</code> filter and a <code>NOT_EQUALS</code> or <code>PREFIX_NOT_EQUALS</code> filter. Combining filters in this way always returns an error, even if the provided filter values would return valid results.</p>
        /// <p>You can combine <code>PREFIX</code> filters with <code>NOT_EQUALS</code> or <code>PREFIX_NOT_EQUALS</code> filters for the same field. Security Hub first processes the <code>PREFIX</code> filters, then the <code>NOT_EQUALS</code> or <code>PREFIX_NOT_EQUALS</code> filters.</p>
        /// <p> For example, for the following filter, Security Hub first identifies findings that have resource types that start with either <code>AwsIAM</code> or <code>AwsEc2</code>. It then excludes findings that have a resource type of <code>AwsIamPolicy</code> and findings that have a resource type of <code>AwsEc2NetworkInterface</code>.</p>
        /// <ul>
        /// <li> <p> <code>ResourceType PREFIX AwsIam</code> </p> </li>
        /// <li> <p> <code>ResourceType PREFIX AwsEc2</code> </p> </li>
        /// <li> <p> <code>ResourceType NOT_EQUALS AwsIamPolicy</code> </p> </li>
        /// <li> <p> <code>ResourceType NOT_EQUALS AwsEc2NetworkInterface</code> </p> </li>
        /// </ul>
        pub fn comparison(mut self, input: crate::model::StringFilterComparison) -> Self {
            self.comparison = Some(input);
            self
        }
        /// <p>The condition to apply to a string value when querying for findings. To search for values that contain the filter criteria value, use one of the following comparison operators:</p>
        /// <ul>
        /// <li> <p>To search for values that exactly match the filter value, use <code>EQUALS</code>.</p> <p>For example, the filter <code>ResourceType EQUALS AwsEc2SecurityGroup</code> only matches findings that have a resource type of <code>AwsEc2SecurityGroup</code>.</p> </li>
        /// <li> <p>To search for values that start with the filter value, use <code>PREFIX</code>.</p> <p>For example, the filter <code>ResourceType PREFIX AwsIam</code> matches findings that have a resource type that starts with <code>AwsIam</code>. Findings with a resource type of <code>AwsIamPolicy</code>, <code>AwsIamRole</code>, or <code>AwsIamUser</code> would all match.</p> </li>
        /// </ul>
        /// <p> <code>EQUALS</code> and <code>PREFIX</code> filters on the same field are joined by <code>OR</code>. A finding matches if it matches any one of those filters.</p>
        /// <p>To search for values that do not contain the filter criteria value, use one of the following comparison operators:</p>
        /// <ul>
        /// <li> <p>To search for values that do not exactly match the filter value, use <code>NOT_EQUALS</code>.</p> <p>For example, the filter <code>ResourceType NOT_EQUALS AwsIamPolicy</code> matches findings that have a resource type other than <code>AwsIamPolicy</code>.</p> </li>
        /// <li> <p>To search for values that do not start with the filter value, use <code>PREFIX_NOT_EQUALS</code>.</p> <p>For example, the filter <code>ResourceType PREFIX_NOT_EQUALS AwsIam</code> matches findings that have a resource type that does not start with <code>AwsIam</code>. Findings with a resource type of <code>AwsIamPolicy</code>, <code>AwsIamRole</code>, or <code>AwsIamUser</code> would all be excluded from the results.</p> </li>
        /// </ul>
        /// <p> <code>NOT_EQUALS</code> and <code>PREFIX_NOT_EQUALS</code> filters on the same field are joined by <code>AND</code>. A finding matches only if it matches all of those filters.</p>
        /// <p>For filters on the same field, you cannot provide both an <code>EQUALS</code> filter and a <code>NOT_EQUALS</code> or <code>PREFIX_NOT_EQUALS</code> filter. Combining filters in this way always returns an error, even if the provided filter values would return valid results.</p>
        /// <p>You can combine <code>PREFIX</code> filters with <code>NOT_EQUALS</code> or <code>PREFIX_NOT_EQUALS</code> filters for the same field. Security Hub first processes the <code>PREFIX</code> filters, then the <code>NOT_EQUALS</code> or <code>PREFIX_NOT_EQUALS</code> filters.</p>
        /// <p> For example, for the following filter, Security Hub first identifies findings that have resource types that start with either <code>AwsIAM</code> or <code>AwsEc2</code>. It then excludes findings that have a resource type of <code>AwsIamPolicy</code> and findings that have a resource type of <code>AwsEc2NetworkInterface</code>.</p>
        /// <ul>
        /// <li> <p> <code>ResourceType PREFIX AwsIam</code> </p> </li>
        /// <li> <p> <code>ResourceType PREFIX AwsEc2</code> </p> </li>
        /// <li> <p> <code>ResourceType NOT_EQUALS AwsIamPolicy</code> </p> </li>
        /// <li> <p> <code>ResourceType NOT_EQUALS AwsEc2NetworkInterface</code> </p> </li>
        /// </ul>
        pub fn set_comparison(
            mut self,
            input: std::option::Option<crate::model::StringFilterComparison>,
        ) -> Self {
            self.comparison = input;
            self
        }
        /// Consumes the builder and constructs a [`StringFilter`](crate::model::StringFilter)
        pub fn build(self) -> crate::model::StringFilter {
            crate::model::StringFilter {
                value: self.value,
                comparison: self.comparison,
            }
        }
    }
}
impl StringFilter {
    /// Creates a new builder-style object to manufacture [`StringFilter`](crate::model::StringFilter)
    pub fn builder() -> crate::model::string_filter::Builder {
        crate::model::string_filter::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StringFilterComparison {
    #[allow(missing_docs)] // documentation missing in model
    Equals,
    #[allow(missing_docs)] // documentation missing in model
    NotEquals,
    #[allow(missing_docs)] // documentation missing in model
    Prefix,
    #[allow(missing_docs)] // documentation missing in model
    PrefixNotEquals,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StringFilterComparison {
    fn from(s: &str) -> Self {
        match s {
            "EQUALS" => StringFilterComparison::Equals,
            "NOT_EQUALS" => StringFilterComparison::NotEquals,
            "PREFIX" => StringFilterComparison::Prefix,
            "PREFIX_NOT_EQUALS" => StringFilterComparison::PrefixNotEquals,
            other => StringFilterComparison::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StringFilterComparison {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StringFilterComparison::from(s))
    }
}
impl StringFilterComparison {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StringFilterComparison::Equals => "EQUALS",
            StringFilterComparison::NotEquals => "NOT_EQUALS",
            StringFilterComparison::Prefix => "PREFIX",
            StringFilterComparison::PrefixNotEquals => "PREFIX_NOT_EQUALS",
            StringFilterComparison::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["EQUALS", "NOT_EQUALS", "PREFIX", "PREFIX_NOT_EQUALS"]
    }
}
impl AsRef<str> for StringFilterComparison {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A number filter for querying findings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NumberFilter {
    /// <p>The greater-than-equal condition to be applied to a single field when querying for findings. </p>
    pub gte: f64,
    /// <p>The less-than-equal condition to be applied to a single field when querying for findings. </p>
    pub lte: f64,
    /// <p>The equal-to condition to be applied to a single field when querying for findings.</p>
    pub eq: f64,
}
impl NumberFilter {
    /// <p>The greater-than-equal condition to be applied to a single field when querying for findings. </p>
    pub fn gte(&self) -> f64 {
        self.gte
    }
    /// <p>The less-than-equal condition to be applied to a single field when querying for findings. </p>
    pub fn lte(&self) -> f64 {
        self.lte
    }
    /// <p>The equal-to condition to be applied to a single field when querying for findings.</p>
    pub fn eq(&self) -> f64 {
        self.eq
    }
}
impl std::fmt::Debug for NumberFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NumberFilter");
        formatter.field("gte", &self.gte);
        formatter.field("lte", &self.lte);
        formatter.field("eq", &self.eq);
        formatter.finish()
    }
}
/// See [`NumberFilter`](crate::model::NumberFilter)
pub mod number_filter {

    /// A builder for [`NumberFilter`](crate::model::NumberFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) gte: std::option::Option<f64>,
        pub(crate) lte: std::option::Option<f64>,
        pub(crate) eq: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The greater-than-equal condition to be applied to a single field when querying for findings. </p>
        pub fn gte(mut self, input: f64) -> Self {
            self.gte = Some(input);
            self
        }
        /// <p>The greater-than-equal condition to be applied to a single field when querying for findings. </p>
        pub fn set_gte(mut self, input: std::option::Option<f64>) -> Self {
            self.gte = input;
            self
        }
        /// <p>The less-than-equal condition to be applied to a single field when querying for findings. </p>
        pub fn lte(mut self, input: f64) -> Self {
            self.lte = Some(input);
            self
        }
        /// <p>The less-than-equal condition to be applied to a single field when querying for findings. </p>
        pub fn set_lte(mut self, input: std::option::Option<f64>) -> Self {
            self.lte = input;
            self
        }
        /// <p>The equal-to condition to be applied to a single field when querying for findings.</p>
        pub fn eq(mut self, input: f64) -> Self {
            self.eq = Some(input);
            self
        }
        /// <p>The equal-to condition to be applied to a single field when querying for findings.</p>
        pub fn set_eq(mut self, input: std::option::Option<f64>) -> Self {
            self.eq = input;
            self
        }
        /// Consumes the builder and constructs a [`NumberFilter`](crate::model::NumberFilter)
        pub fn build(self) -> crate::model::NumberFilter {
            crate::model::NumberFilter {
                gte: self.gte.unwrap_or_default(),
                lte: self.lte.unwrap_or_default(),
                eq: self.eq.unwrap_or_default(),
            }
        }
    }
}
impl NumberFilter {
    /// Creates a new builder-style object to manufacture [`NumberFilter`](crate::model::NumberFilter)
    pub fn builder() -> crate::model::number_filter::Builder {
        crate::model::number_filter::Builder::default()
    }
}

/// <p>A keyword filter for querying findings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KeywordFilter {
    /// <p>A value for the keyword.</p>
    pub value: std::option::Option<std::string::String>,
}
impl KeywordFilter {
    /// <p>A value for the keyword.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for KeywordFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KeywordFilter");
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`KeywordFilter`](crate::model::KeywordFilter)
pub mod keyword_filter {

    /// A builder for [`KeywordFilter`](crate::model::KeywordFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A value for the keyword.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>A value for the keyword.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`KeywordFilter`](crate::model::KeywordFilter)
        pub fn build(self) -> crate::model::KeywordFilter {
            crate::model::KeywordFilter { value: self.value }
        }
    }
}
impl KeywordFilter {
    /// Creates a new builder-style object to manufacture [`KeywordFilter`](crate::model::KeywordFilter)
    pub fn builder() -> crate::model::keyword_filter::Builder {
        crate::model::keyword_filter::Builder::default()
    }
}

/// <p>A date filter for querying findings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DateFilter {
    /// <p>A start date for the date filter.</p>
    pub start: std::option::Option<std::string::String>,
    /// <p>An end date for the date filter.</p>
    pub end: std::option::Option<std::string::String>,
    /// <p>A date range for the date filter.</p>
    pub date_range: std::option::Option<crate::model::DateRange>,
}
impl DateFilter {
    /// <p>A start date for the date filter.</p>
    pub fn start(&self) -> std::option::Option<&str> {
        self.start.as_deref()
    }
    /// <p>An end date for the date filter.</p>
    pub fn end(&self) -> std::option::Option<&str> {
        self.end.as_deref()
    }
    /// <p>A date range for the date filter.</p>
    pub fn date_range(&self) -> std::option::Option<&crate::model::DateRange> {
        self.date_range.as_ref()
    }
}
impl std::fmt::Debug for DateFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DateFilter");
        formatter.field("start", &self.start);
        formatter.field("end", &self.end);
        formatter.field("date_range", &self.date_range);
        formatter.finish()
    }
}
/// See [`DateFilter`](crate::model::DateFilter)
pub mod date_filter {

    /// A builder for [`DateFilter`](crate::model::DateFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start: std::option::Option<std::string::String>,
        pub(crate) end: std::option::Option<std::string::String>,
        pub(crate) date_range: std::option::Option<crate::model::DateRange>,
    }
    impl Builder {
        /// <p>A start date for the date filter.</p>
        pub fn start(mut self, input: impl Into<std::string::String>) -> Self {
            self.start = Some(input.into());
            self
        }
        /// <p>A start date for the date filter.</p>
        pub fn set_start(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.start = input;
            self
        }
        /// <p>An end date for the date filter.</p>
        pub fn end(mut self, input: impl Into<std::string::String>) -> Self {
            self.end = Some(input.into());
            self
        }
        /// <p>An end date for the date filter.</p>
        pub fn set_end(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.end = input;
            self
        }
        /// <p>A date range for the date filter.</p>
        pub fn date_range(mut self, input: crate::model::DateRange) -> Self {
            self.date_range = Some(input);
            self
        }
        /// <p>A date range for the date filter.</p>
        pub fn set_date_range(
            mut self,
            input: std::option::Option<crate::model::DateRange>,
        ) -> Self {
            self.date_range = input;
            self
        }
        /// Consumes the builder and constructs a [`DateFilter`](crate::model::DateFilter)
        pub fn build(self) -> crate::model::DateFilter {
            crate::model::DateFilter {
                start: self.start,
                end: self.end,
                date_range: self.date_range,
            }
        }
    }
}
impl DateFilter {
    /// Creates a new builder-style object to manufacture [`DateFilter`](crate::model::DateFilter)
    pub fn builder() -> crate::model::date_filter::Builder {
        crate::model::date_filter::Builder::default()
    }
}

/// <p>A date range for the date filter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DateRange {
    /// <p>A date range value for the date filter.</p>
    pub value: i32,
    /// <p>A date range unit for the date filter.</p>
    pub unit: std::option::Option<crate::model::DateRangeUnit>,
}
impl DateRange {
    /// <p>A date range value for the date filter.</p>
    pub fn value(&self) -> i32 {
        self.value
    }
    /// <p>A date range unit for the date filter.</p>
    pub fn unit(&self) -> std::option::Option<&crate::model::DateRangeUnit> {
        self.unit.as_ref()
    }
}
impl std::fmt::Debug for DateRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DateRange");
        formatter.field("value", &self.value);
        formatter.field("unit", &self.unit);
        formatter.finish()
    }
}
/// See [`DateRange`](crate::model::DateRange)
pub mod date_range {

    /// A builder for [`DateRange`](crate::model::DateRange)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<i32>,
        pub(crate) unit: std::option::Option<crate::model::DateRangeUnit>,
    }
    impl Builder {
        /// <p>A date range value for the date filter.</p>
        pub fn value(mut self, input: i32) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>A date range value for the date filter.</p>
        pub fn set_value(mut self, input: std::option::Option<i32>) -> Self {
            self.value = input;
            self
        }
        /// <p>A date range unit for the date filter.</p>
        pub fn unit(mut self, input: crate::model::DateRangeUnit) -> Self {
            self.unit = Some(input);
            self
        }
        /// <p>A date range unit for the date filter.</p>
        pub fn set_unit(mut self, input: std::option::Option<crate::model::DateRangeUnit>) -> Self {
            self.unit = input;
            self
        }
        /// Consumes the builder and constructs a [`DateRange`](crate::model::DateRange)
        pub fn build(self) -> crate::model::DateRange {
            crate::model::DateRange {
                value: self.value.unwrap_or_default(),
                unit: self.unit,
            }
        }
    }
}
impl DateRange {
    /// Creates a new builder-style object to manufacture [`DateRange`](crate::model::DateRange)
    pub fn builder() -> crate::model::date_range::Builder {
        crate::model::date_range::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DateRangeUnit {
    #[allow(missing_docs)] // documentation missing in model
    Days,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DateRangeUnit {
    fn from(s: &str) -> Self {
        match s {
            "DAYS" => DateRangeUnit::Days,
            other => DateRangeUnit::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DateRangeUnit {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DateRangeUnit::from(s))
    }
}
impl DateRangeUnit {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DateRangeUnit::Days => "DAYS",
            DateRangeUnit::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["DAYS"]
    }
}
impl AsRef<str> for DateRangeUnit {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A map filter for querying findings. Each map filter provides the field to check, the value to look for, and the comparison operator.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MapFilter {
    /// <p>The key of the map filter. For example, for <code>ResourceTags</code>, <code>Key</code> identifies the name of the tag. For <code>UserDefinedFields</code>, <code>Key</code> is the name of the field.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The value for the key in the map filter. Filter values are case sensitive. For example, one of the values for a tag called <code>Department</code> might be <code>Security</code>. If you provide <code>security</code> as the filter value, then there is no match.</p>
    pub value: std::option::Option<std::string::String>,
    /// <p>The condition to apply to the key value when querying for findings with a map filter.</p>
    /// <p>To search for values that exactly match the filter value, use <code>EQUALS</code>. For example, for the <code>ResourceTags</code> field, the filter <code>Department EQUALS Security</code> matches findings that have the value <code>Security</code> for the tag <code>Department</code>.</p>
    /// <p>To search for values other than the filter value, use <code>NOT_EQUALS</code>. For example, for the <code>ResourceTags</code> field, the filter <code>Department NOT_EQUALS Finance</code> matches findings that do not have the value <code>Finance</code> for the tag <code>Department</code>.</p>
    /// <p> <code>EQUALS</code> filters on the same field are joined by <code>OR</code>. A finding matches if it matches any one of those filters.</p>
    /// <p> <code>NOT_EQUALS</code> filters on the same field are joined by <code>AND</code>. A finding matches only if it matches all of those filters.</p>
    /// <p>You cannot have both an <code>EQUALS</code> filter and a <code>NOT_EQUALS</code> filter on the same field.</p>
    pub comparison: std::option::Option<crate::model::MapFilterComparison>,
}
impl MapFilter {
    /// <p>The key of the map filter. For example, for <code>ResourceTags</code>, <code>Key</code> identifies the name of the tag. For <code>UserDefinedFields</code>, <code>Key</code> is the name of the field.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The value for the key in the map filter. Filter values are case sensitive. For example, one of the values for a tag called <code>Department</code> might be <code>Security</code>. If you provide <code>security</code> as the filter value, then there is no match.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>The condition to apply to the key value when querying for findings with a map filter.</p>
    /// <p>To search for values that exactly match the filter value, use <code>EQUALS</code>. For example, for the <code>ResourceTags</code> field, the filter <code>Department EQUALS Security</code> matches findings that have the value <code>Security</code> for the tag <code>Department</code>.</p>
    /// <p>To search for values other than the filter value, use <code>NOT_EQUALS</code>. For example, for the <code>ResourceTags</code> field, the filter <code>Department NOT_EQUALS Finance</code> matches findings that do not have the value <code>Finance</code> for the tag <code>Department</code>.</p>
    /// <p> <code>EQUALS</code> filters on the same field are joined by <code>OR</code>. A finding matches if it matches any one of those filters.</p>
    /// <p> <code>NOT_EQUALS</code> filters on the same field are joined by <code>AND</code>. A finding matches only if it matches all of those filters.</p>
    /// <p>You cannot have both an <code>EQUALS</code> filter and a <code>NOT_EQUALS</code> filter on the same field.</p>
    pub fn comparison(&self) -> std::option::Option<&crate::model::MapFilterComparison> {
        self.comparison.as_ref()
    }
}
impl std::fmt::Debug for MapFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MapFilter");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.field("comparison", &self.comparison);
        formatter.finish()
    }
}
/// See [`MapFilter`](crate::model::MapFilter)
pub mod map_filter {

    /// A builder for [`MapFilter`](crate::model::MapFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) comparison: std::option::Option<crate::model::MapFilterComparison>,
    }
    impl Builder {
        /// <p>The key of the map filter. For example, for <code>ResourceTags</code>, <code>Key</code> identifies the name of the tag. For <code>UserDefinedFields</code>, <code>Key</code> is the name of the field.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The key of the map filter. For example, for <code>ResourceTags</code>, <code>Key</code> identifies the name of the tag. For <code>UserDefinedFields</code>, <code>Key</code> is the name of the field.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value for the key in the map filter. Filter values are case sensitive. For example, one of the values for a tag called <code>Department</code> might be <code>Security</code>. If you provide <code>security</code> as the filter value, then there is no match.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value for the key in the map filter. Filter values are case sensitive. For example, one of the values for a tag called <code>Department</code> might be <code>Security</code>. If you provide <code>security</code> as the filter value, then there is no match.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>The condition to apply to the key value when querying for findings with a map filter.</p>
        /// <p>To search for values that exactly match the filter value, use <code>EQUALS</code>. For example, for the <code>ResourceTags</code> field, the filter <code>Department EQUALS Security</code> matches findings that have the value <code>Security</code> for the tag <code>Department</code>.</p>
        /// <p>To search for values other than the filter value, use <code>NOT_EQUALS</code>. For example, for the <code>ResourceTags</code> field, the filter <code>Department NOT_EQUALS Finance</code> matches findings that do not have the value <code>Finance</code> for the tag <code>Department</code>.</p>
        /// <p> <code>EQUALS</code> filters on the same field are joined by <code>OR</code>. A finding matches if it matches any one of those filters.</p>
        /// <p> <code>NOT_EQUALS</code> filters on the same field are joined by <code>AND</code>. A finding matches only if it matches all of those filters.</p>
        /// <p>You cannot have both an <code>EQUALS</code> filter and a <code>NOT_EQUALS</code> filter on the same field.</p>
        pub fn comparison(mut self, input: crate::model::MapFilterComparison) -> Self {
            self.comparison = Some(input);
            self
        }
        /// <p>The condition to apply to the key value when querying for findings with a map filter.</p>
        /// <p>To search for values that exactly match the filter value, use <code>EQUALS</code>. For example, for the <code>ResourceTags</code> field, the filter <code>Department EQUALS Security</code> matches findings that have the value <code>Security</code> for the tag <code>Department</code>.</p>
        /// <p>To search for values other than the filter value, use <code>NOT_EQUALS</code>. For example, for the <code>ResourceTags</code> field, the filter <code>Department NOT_EQUALS Finance</code> matches findings that do not have the value <code>Finance</code> for the tag <code>Department</code>.</p>
        /// <p> <code>EQUALS</code> filters on the same field are joined by <code>OR</code>. A finding matches if it matches any one of those filters.</p>
        /// <p> <code>NOT_EQUALS</code> filters on the same field are joined by <code>AND</code>. A finding matches only if it matches all of those filters.</p>
        /// <p>You cannot have both an <code>EQUALS</code> filter and a <code>NOT_EQUALS</code> filter on the same field.</p>
        pub fn set_comparison(
            mut self,
            input: std::option::Option<crate::model::MapFilterComparison>,
        ) -> Self {
            self.comparison = input;
            self
        }
        /// Consumes the builder and constructs a [`MapFilter`](crate::model::MapFilter)
        pub fn build(self) -> crate::model::MapFilter {
            crate::model::MapFilter {
                key: self.key,
                value: self.value,
                comparison: self.comparison,
            }
        }
    }
}
impl MapFilter {
    /// Creates a new builder-style object to manufacture [`MapFilter`](crate::model::MapFilter)
    pub fn builder() -> crate::model::map_filter::Builder {
        crate::model::map_filter::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MapFilterComparison {
    #[allow(missing_docs)] // documentation missing in model
    Equals,
    #[allow(missing_docs)] // documentation missing in model
    NotEquals,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MapFilterComparison {
    fn from(s: &str) -> Self {
        match s {
            "EQUALS" => MapFilterComparison::Equals,
            "NOT_EQUALS" => MapFilterComparison::NotEquals,
            other => MapFilterComparison::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MapFilterComparison {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MapFilterComparison::from(s))
    }
}
impl MapFilterComparison {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MapFilterComparison::Equals => "EQUALS",
            MapFilterComparison::NotEquals => "NOT_EQUALS",
            MapFilterComparison::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["EQUALS", "NOT_EQUALS"]
    }
}
impl AsRef<str> for MapFilterComparison {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The IP filter for querying findings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IpFilter {
    /// <p>A finding's CIDR value.</p>
    pub cidr: std::option::Option<std::string::String>,
}
impl IpFilter {
    /// <p>A finding's CIDR value.</p>
    pub fn cidr(&self) -> std::option::Option<&str> {
        self.cidr.as_deref()
    }
}
impl std::fmt::Debug for IpFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IpFilter");
        formatter.field("cidr", &self.cidr);
        formatter.finish()
    }
}
/// See [`IpFilter`](crate::model::IpFilter)
pub mod ip_filter {

    /// A builder for [`IpFilter`](crate::model::IpFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cidr: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A finding's CIDR value.</p>
        pub fn cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr = Some(input.into());
            self
        }
        /// <p>A finding's CIDR value.</p>
        pub fn set_cidr(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr = input;
            self
        }
        /// Consumes the builder and constructs a [`IpFilter`](crate::model::IpFilter)
        pub fn build(self) -> crate::model::IpFilter {
            crate::model::IpFilter { cidr: self.cidr }
        }
    }
}
impl IpFilter {
    /// Creates a new builder-style object to manufacture [`IpFilter`](crate::model::IpFilter)
    pub fn builder() -> crate::model::ip_filter::Builder {
        crate::model::ip_filter::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RecordState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Archived,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RecordState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => RecordState::Active,
            "ARCHIVED" => RecordState::Archived,
            other => RecordState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RecordState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RecordState::from(s))
    }
}
impl RecordState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RecordState::Active => "ACTIVE",
            RecordState::Archived => "ARCHIVED",
            RecordState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ACTIVE", "ARCHIVED"]
    }
}
impl AsRef<str> for RecordState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The updated note.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoteUpdate {
    /// <p>The updated note text.</p>
    pub text: std::option::Option<std::string::String>,
    /// <p>The principal that updated the note.</p>
    pub updated_by: std::option::Option<std::string::String>,
}
impl NoteUpdate {
    /// <p>The updated note text.</p>
    pub fn text(&self) -> std::option::Option<&str> {
        self.text.as_deref()
    }
    /// <p>The principal that updated the note.</p>
    pub fn updated_by(&self) -> std::option::Option<&str> {
        self.updated_by.as_deref()
    }
}
impl std::fmt::Debug for NoteUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoteUpdate");
        formatter.field("text", &self.text);
        formatter.field("updated_by", &self.updated_by);
        formatter.finish()
    }
}
/// See [`NoteUpdate`](crate::model::NoteUpdate)
pub mod note_update {

    /// A builder for [`NoteUpdate`](crate::model::NoteUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) text: std::option::Option<std::string::String>,
        pub(crate) updated_by: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The updated note text.</p>
        pub fn text(mut self, input: impl Into<std::string::String>) -> Self {
            self.text = Some(input.into());
            self
        }
        /// <p>The updated note text.</p>
        pub fn set_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.text = input;
            self
        }
        /// <p>The principal that updated the note.</p>
        pub fn updated_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.updated_by = Some(input.into());
            self
        }
        /// <p>The principal that updated the note.</p>
        pub fn set_updated_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.updated_by = input;
            self
        }
        /// Consumes the builder and constructs a [`NoteUpdate`](crate::model::NoteUpdate)
        pub fn build(self) -> crate::model::NoteUpdate {
            crate::model::NoteUpdate {
                text: self.text,
                updated_by: self.updated_by,
            }
        }
    }
}
impl NoteUpdate {
    /// Creates a new builder-style object to manufacture [`NoteUpdate`](crate::model::NoteUpdate)
    pub fn builder() -> crate::model::note_update::Builder {
        crate::model::note_update::Builder::default()
    }
}

/// <p>Represents a Security Hub administrator account designated by an organization management account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AdminAccount {
    /// <p>The Amazon Web Services account identifier of the Security Hub administrator account.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The current status of the Security Hub administrator account. Indicates whether the account is currently enabled as a Security Hub administrator.</p>
    pub status: std::option::Option<crate::model::AdminStatus>,
}
impl AdminAccount {
    /// <p>The Amazon Web Services account identifier of the Security Hub administrator account.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The current status of the Security Hub administrator account. Indicates whether the account is currently enabled as a Security Hub administrator.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::AdminStatus> {
        self.status.as_ref()
    }
}
impl std::fmt::Debug for AdminAccount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AdminAccount");
        formatter.field("account_id", &self.account_id);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`AdminAccount`](crate::model::AdminAccount)
pub mod admin_account {

    /// A builder for [`AdminAccount`](crate::model::AdminAccount)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::AdminStatus>,
    }
    impl Builder {
        /// <p>The Amazon Web Services account identifier of the Security Hub administrator account.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account identifier of the Security Hub administrator account.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The current status of the Security Hub administrator account. Indicates whether the account is currently enabled as a Security Hub administrator.</p>
        pub fn status(mut self, input: crate::model::AdminStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the Security Hub administrator account. Indicates whether the account is currently enabled as a Security Hub administrator.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::AdminStatus>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AdminAccount`](crate::model::AdminAccount)
        pub fn build(self) -> crate::model::AdminAccount {
            crate::model::AdminAccount {
                account_id: self.account_id,
                status: self.status,
            }
        }
    }
}
impl AdminAccount {
    /// Creates a new builder-style object to manufacture [`AdminAccount`](crate::model::AdminAccount)
    pub fn builder() -> crate::model::admin_account::Builder {
        crate::model::admin_account::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AdminStatus {
    #[allow(missing_docs)] // documentation missing in model
    DisableInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AdminStatus {
    fn from(s: &str) -> Self {
        match s {
            "DISABLE_IN_PROGRESS" => AdminStatus::DisableInProgress,
            "ENABLED" => AdminStatus::Enabled,
            other => AdminStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AdminStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AdminStatus::from(s))
    }
}
impl AdminStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AdminStatus::DisableInProgress => "DISABLE_IN_PROGRESS",
            AdminStatus::Enabled => "ENABLED",
            AdminStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["DISABLE_IN_PROGRESS", "ENABLED"]
    }
}
impl AsRef<str> for AdminStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The details about a member account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Member {
    /// <p>The Amazon Web Services account ID of the member account.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The email address of the member account.</p>
    pub email: std::option::Option<std::string::String>,
    /// <p>This is replaced by <code>AdministratorID</code>.</p>
    /// <p>The Amazon Web Services account ID of the Security Hub administrator account associated with this member account.</p>
    pub master_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID of the Security Hub administrator account associated with this member account.</p>
    pub administrator_id: std::option::Option<std::string::String>,
    /// <p>The status of the relationship between the member account and its administrator account. </p>
    /// <p>The status can have one of the following values:</p>
    /// <ul>
    /// <li> <p> <code>CREATED</code> - Indicates that the administrator account added the member account, but has not yet invited the member account.</p> </li>
    /// <li> <p> <code>INVITED</code> - Indicates that the administrator account invited the member account. The member account has not yet responded to the invitation.</p> </li>
    /// <li> <p> <code>ENABLED</code> - Indicates that the member account is currently active. For manually invited member accounts, indicates that the member account accepted the invitation.</p> </li>
    /// <li> <p> <code>REMOVED</code> - Indicates that the administrator account disassociated the member account.</p> </li>
    /// <li> <p> <code>RESIGNED</code> - Indicates that the member account disassociated themselves from the administrator account.</p> </li>
    /// <li> <p> <code>DELETED</code> - Indicates that the administrator account deleted the member account.</p> </li>
    /// <li> <p> <code>ACCOUNT_SUSPENDED</code> - Indicates that an organization account was suspended from Amazon Web Services at the same time that the administrator account tried to enable the organization account as a member account.</p> </li>
    /// </ul>
    pub member_status: std::option::Option<std::string::String>,
    /// <p>A timestamp for the date and time when the invitation was sent to the member account.</p>
    pub invited_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp for the date and time when the member account was updated.</p>
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl Member {
    /// <p>The Amazon Web Services account ID of the member account.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The email address of the member account.</p>
    pub fn email(&self) -> std::option::Option<&str> {
        self.email.as_deref()
    }
    /// <p>This is replaced by <code>AdministratorID</code>.</p>
    /// <p>The Amazon Web Services account ID of the Security Hub administrator account associated with this member account.</p>
    pub fn master_id(&self) -> std::option::Option<&str> {
        self.master_id.as_deref()
    }
    /// <p>The Amazon Web Services account ID of the Security Hub administrator account associated with this member account.</p>
    pub fn administrator_id(&self) -> std::option::Option<&str> {
        self.administrator_id.as_deref()
    }
    /// <p>The status of the relationship between the member account and its administrator account. </p>
    /// <p>The status can have one of the following values:</p>
    /// <ul>
    /// <li> <p> <code>CREATED</code> - Indicates that the administrator account added the member account, but has not yet invited the member account.</p> </li>
    /// <li> <p> <code>INVITED</code> - Indicates that the administrator account invited the member account. The member account has not yet responded to the invitation.</p> </li>
    /// <li> <p> <code>ENABLED</code> - Indicates that the member account is currently active. For manually invited member accounts, indicates that the member account accepted the invitation.</p> </li>
    /// <li> <p> <code>REMOVED</code> - Indicates that the administrator account disassociated the member account.</p> </li>
    /// <li> <p> <code>RESIGNED</code> - Indicates that the member account disassociated themselves from the administrator account.</p> </li>
    /// <li> <p> <code>DELETED</code> - Indicates that the administrator account deleted the member account.</p> </li>
    /// <li> <p> <code>ACCOUNT_SUSPENDED</code> - Indicates that an organization account was suspended from Amazon Web Services at the same time that the administrator account tried to enable the organization account as a member account.</p> </li>
    /// </ul>
    pub fn member_status(&self) -> std::option::Option<&str> {
        self.member_status.as_deref()
    }
    /// <p>A timestamp for the date and time when the invitation was sent to the member account.</p>
    pub fn invited_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.invited_at.as_ref()
    }
    /// <p>The timestamp for the date and time when the member account was updated.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
}
impl std::fmt::Debug for Member {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Member");
        formatter.field("account_id", &self.account_id);
        formatter.field("email", &self.email);
        formatter.field("master_id", &self.master_id);
        formatter.field("administrator_id", &self.administrator_id);
        formatter.field("member_status", &self.member_status);
        formatter.field("invited_at", &self.invited_at);
        formatter.field("updated_at", &self.updated_at);
        formatter.finish()
    }
}
/// See [`Member`](crate::model::Member)
pub mod member {

    /// A builder for [`Member`](crate::model::Member)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) email: std::option::Option<std::string::String>,
        pub(crate) master_id: std::option::Option<std::string::String>,
        pub(crate) administrator_id: std::option::Option<std::string::String>,
        pub(crate) member_status: std::option::Option<std::string::String>,
        pub(crate) invited_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Web Services account ID of the member account.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID of the member account.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The email address of the member account.</p>
        pub fn email(mut self, input: impl Into<std::string::String>) -> Self {
            self.email = Some(input.into());
            self
        }
        /// <p>The email address of the member account.</p>
        pub fn set_email(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.email = input;
            self
        }
        /// <p>This is replaced by <code>AdministratorID</code>.</p>
        /// <p>The Amazon Web Services account ID of the Security Hub administrator account associated with this member account.</p>
        pub fn master_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_id = Some(input.into());
            self
        }
        /// <p>This is replaced by <code>AdministratorID</code>.</p>
        /// <p>The Amazon Web Services account ID of the Security Hub administrator account associated with this member account.</p>
        pub fn set_master_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.master_id = input;
            self
        }
        /// <p>The Amazon Web Services account ID of the Security Hub administrator account associated with this member account.</p>
        pub fn administrator_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.administrator_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID of the Security Hub administrator account associated with this member account.</p>
        pub fn set_administrator_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.administrator_id = input;
            self
        }
        /// <p>The status of the relationship between the member account and its administrator account. </p>
        /// <p>The status can have one of the following values:</p>
        /// <ul>
        /// <li> <p> <code>CREATED</code> - Indicates that the administrator account added the member account, but has not yet invited the member account.</p> </li>
        /// <li> <p> <code>INVITED</code> - Indicates that the administrator account invited the member account. The member account has not yet responded to the invitation.</p> </li>
        /// <li> <p> <code>ENABLED</code> - Indicates that the member account is currently active. For manually invited member accounts, indicates that the member account accepted the invitation.</p> </li>
        /// <li> <p> <code>REMOVED</code> - Indicates that the administrator account disassociated the member account.</p> </li>
        /// <li> <p> <code>RESIGNED</code> - Indicates that the member account disassociated themselves from the administrator account.</p> </li>
        /// <li> <p> <code>DELETED</code> - Indicates that the administrator account deleted the member account.</p> </li>
        /// <li> <p> <code>ACCOUNT_SUSPENDED</code> - Indicates that an organization account was suspended from Amazon Web Services at the same time that the administrator account tried to enable the organization account as a member account.</p> </li>
        /// </ul>
        pub fn member_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.member_status = Some(input.into());
            self
        }
        /// <p>The status of the relationship between the member account and its administrator account. </p>
        /// <p>The status can have one of the following values:</p>
        /// <ul>
        /// <li> <p> <code>CREATED</code> - Indicates that the administrator account added the member account, but has not yet invited the member account.</p> </li>
        /// <li> <p> <code>INVITED</code> - Indicates that the administrator account invited the member account. The member account has not yet responded to the invitation.</p> </li>
        /// <li> <p> <code>ENABLED</code> - Indicates that the member account is currently active. For manually invited member accounts, indicates that the member account accepted the invitation.</p> </li>
        /// <li> <p> <code>REMOVED</code> - Indicates that the administrator account disassociated the member account.</p> </li>
        /// <li> <p> <code>RESIGNED</code> - Indicates that the member account disassociated themselves from the administrator account.</p> </li>
        /// <li> <p> <code>DELETED</code> - Indicates that the administrator account deleted the member account.</p> </li>
        /// <li> <p> <code>ACCOUNT_SUSPENDED</code> - Indicates that an organization account was suspended from Amazon Web Services at the same time that the administrator account tried to enable the organization account as a member account.</p> </li>
        /// </ul>
        pub fn set_member_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.member_status = input;
            self
        }
        /// <p>A timestamp for the date and time when the invitation was sent to the member account.</p>
        pub fn invited_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.invited_at = Some(input);
            self
        }
        /// <p>A timestamp for the date and time when the invitation was sent to the member account.</p>
        pub fn set_invited_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.invited_at = input;
            self
        }
        /// <p>The timestamp for the date and time when the member account was updated.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The timestamp for the date and time when the member account was updated.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// Consumes the builder and constructs a [`Member`](crate::model::Member)
        pub fn build(self) -> crate::model::Member {
            crate::model::Member {
                account_id: self.account_id,
                email: self.email,
                master_id: self.master_id,
                administrator_id: self.administrator_id,
                member_status: self.member_status,
                invited_at: self.invited_at,
                updated_at: self.updated_at,
            }
        }
    }
}
impl Member {
    /// Creates a new builder-style object to manufacture [`Member`](crate::model::Member)
    pub fn builder() -> crate::model::member::Builder {
        crate::model::member::Builder::default()
    }
}

/// <p>Details about an invitation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Invitation {
    /// <p>The account ID of the Security Hub administrator account that the invitation was sent from.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The ID of the invitation sent to the member account.</p>
    pub invitation_id: std::option::Option<std::string::String>,
    /// <p>The timestamp of when the invitation was sent.</p>
    pub invited_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The current status of the association between the member and administrator accounts.</p>
    pub member_status: std::option::Option<std::string::String>,
}
impl Invitation {
    /// <p>The account ID of the Security Hub administrator account that the invitation was sent from.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The ID of the invitation sent to the member account.</p>
    pub fn invitation_id(&self) -> std::option::Option<&str> {
        self.invitation_id.as_deref()
    }
    /// <p>The timestamp of when the invitation was sent.</p>
    pub fn invited_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.invited_at.as_ref()
    }
    /// <p>The current status of the association between the member and administrator accounts.</p>
    pub fn member_status(&self) -> std::option::Option<&str> {
        self.member_status.as_deref()
    }
}
impl std::fmt::Debug for Invitation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Invitation");
        formatter.field("account_id", &self.account_id);
        formatter.field("invitation_id", &self.invitation_id);
        formatter.field("invited_at", &self.invited_at);
        formatter.field("member_status", &self.member_status);
        formatter.finish()
    }
}
/// See [`Invitation`](crate::model::Invitation)
pub mod invitation {

    /// A builder for [`Invitation`](crate::model::Invitation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) invitation_id: std::option::Option<std::string::String>,
        pub(crate) invited_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) member_status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The account ID of the Security Hub administrator account that the invitation was sent from.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The account ID of the Security Hub administrator account that the invitation was sent from.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The ID of the invitation sent to the member account.</p>
        pub fn invitation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.invitation_id = Some(input.into());
            self
        }
        /// <p>The ID of the invitation sent to the member account.</p>
        pub fn set_invitation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.invitation_id = input;
            self
        }
        /// <p>The timestamp of when the invitation was sent.</p>
        pub fn invited_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.invited_at = Some(input);
            self
        }
        /// <p>The timestamp of when the invitation was sent.</p>
        pub fn set_invited_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.invited_at = input;
            self
        }
        /// <p>The current status of the association between the member and administrator accounts.</p>
        pub fn member_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.member_status = Some(input.into());
            self
        }
        /// <p>The current status of the association between the member and administrator accounts.</p>
        pub fn set_member_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.member_status = input;
            self
        }
        /// Consumes the builder and constructs a [`Invitation`](crate::model::Invitation)
        pub fn build(self) -> crate::model::Invitation {
            crate::model::Invitation {
                account_id: self.account_id,
                invitation_id: self.invitation_id,
                invited_at: self.invited_at,
                member_status: self.member_status,
            }
        }
    }
}
impl Invitation {
    /// Creates a new builder-style object to manufacture [`Invitation`](crate::model::Invitation)
    pub fn builder() -> crate::model::invitation::Builder {
        crate::model::invitation::Builder::default()
    }
}

/// <p>A finding aggregator. A finding aggregator contains the configuration for finding aggregation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FindingAggregator {
    /// <p>The ARN of the finding aggregator. You use the finding aggregator ARN to retrieve details for, update, and delete the finding aggregator.</p>
    pub finding_aggregator_arn: std::option::Option<std::string::String>,
}
impl FindingAggregator {
    /// <p>The ARN of the finding aggregator. You use the finding aggregator ARN to retrieve details for, update, and delete the finding aggregator.</p>
    pub fn finding_aggregator_arn(&self) -> std::option::Option<&str> {
        self.finding_aggregator_arn.as_deref()
    }
}
impl std::fmt::Debug for FindingAggregator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FindingAggregator");
        formatter.field("finding_aggregator_arn", &self.finding_aggregator_arn);
        formatter.finish()
    }
}
/// See [`FindingAggregator`](crate::model::FindingAggregator)
pub mod finding_aggregator {

    /// A builder for [`FindingAggregator`](crate::model::FindingAggregator)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) finding_aggregator_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the finding aggregator. You use the finding aggregator ARN to retrieve details for, update, and delete the finding aggregator.</p>
        pub fn finding_aggregator_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.finding_aggregator_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the finding aggregator. You use the finding aggregator ARN to retrieve details for, update, and delete the finding aggregator.</p>
        pub fn set_finding_aggregator_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.finding_aggregator_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`FindingAggregator`](crate::model::FindingAggregator)
        pub fn build(self) -> crate::model::FindingAggregator {
            crate::model::FindingAggregator {
                finding_aggregator_arn: self.finding_aggregator_arn,
            }
        }
    }
}
impl FindingAggregator {
    /// Creates a new builder-style object to manufacture [`FindingAggregator`](crate::model::FindingAggregator)
    pub fn builder() -> crate::model::finding_aggregator::Builder {
        crate::model::finding_aggregator::Builder::default()
    }
}

/// <p>Details about the account that was not processed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Result {
    /// <p>An Amazon Web Services account ID of the account that was not processed.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The reason that the account was not processed.</p>
    pub processing_result: std::option::Option<std::string::String>,
}
impl Result {
    /// <p>An Amazon Web Services account ID of the account that was not processed.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The reason that the account was not processed.</p>
    pub fn processing_result(&self) -> std::option::Option<&str> {
        self.processing_result.as_deref()
    }
}
impl std::fmt::Debug for Result {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Result");
        formatter.field("account_id", &self.account_id);
        formatter.field("processing_result", &self.processing_result);
        formatter.finish()
    }
}
/// See [`Result`](crate::model::Result)
pub mod result {

    /// A builder for [`Result`](crate::model::Result)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) processing_result: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An Amazon Web Services account ID of the account that was not processed.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>An Amazon Web Services account ID of the account that was not processed.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The reason that the account was not processed.</p>
        pub fn processing_result(mut self, input: impl Into<std::string::String>) -> Self {
            self.processing_result = Some(input.into());
            self
        }
        /// <p>The reason that the account was not processed.</p>
        pub fn set_processing_result(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.processing_result = input;
            self
        }
        /// Consumes the builder and constructs a [`Result`](crate::model::Result)
        pub fn build(self) -> crate::model::Result {
            crate::model::Result {
                account_id: self.account_id,
                processing_result: self.processing_result,
            }
        }
    }
}
impl Result {
    /// Creates a new builder-style object to manufacture [`Result`](crate::model::Result)
    pub fn builder() -> crate::model::result::Builder {
        crate::model::result::Builder::default()
    }
}

/// <p>Contains information about a Security Hub insight.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Insight {
    /// <p>The ARN of a Security Hub insight.</p>
    pub insight_arn: std::option::Option<std::string::String>,
    /// <p>The name of a Security Hub insight.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>One or more attributes used to filter the findings included in the insight. The insight only includes findings that match the criteria defined in the filters.</p>
    pub filters: std::option::Option<crate::model::AwsSecurityFindingFilters>,
    /// <p>The grouping attribute for the insight's findings. Indicates how to group the matching findings, and identifies the type of item that the insight applies to. For example, if an insight is grouped by resource identifier, then the insight produces a list of resource identifiers.</p>
    pub group_by_attribute: std::option::Option<std::string::String>,
}
impl Insight {
    /// <p>The ARN of a Security Hub insight.</p>
    pub fn insight_arn(&self) -> std::option::Option<&str> {
        self.insight_arn.as_deref()
    }
    /// <p>The name of a Security Hub insight.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>One or more attributes used to filter the findings included in the insight. The insight only includes findings that match the criteria defined in the filters.</p>
    pub fn filters(&self) -> std::option::Option<&crate::model::AwsSecurityFindingFilters> {
        self.filters.as_ref()
    }
    /// <p>The grouping attribute for the insight's findings. Indicates how to group the matching findings, and identifies the type of item that the insight applies to. For example, if an insight is grouped by resource identifier, then the insight produces a list of resource identifiers.</p>
    pub fn group_by_attribute(&self) -> std::option::Option<&str> {
        self.group_by_attribute.as_deref()
    }
}
impl std::fmt::Debug for Insight {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Insight");
        formatter.field("insight_arn", &self.insight_arn);
        formatter.field("name", &self.name);
        formatter.field("filters", &self.filters);
        formatter.field("group_by_attribute", &self.group_by_attribute);
        formatter.finish()
    }
}
/// See [`Insight`](crate::model::Insight)
pub mod insight {

    /// A builder for [`Insight`](crate::model::Insight)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) insight_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) filters: std::option::Option<crate::model::AwsSecurityFindingFilters>,
        pub(crate) group_by_attribute: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of a Security Hub insight.</p>
        pub fn insight_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.insight_arn = Some(input.into());
            self
        }
        /// <p>The ARN of a Security Hub insight.</p>
        pub fn set_insight_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.insight_arn = input;
            self
        }
        /// <p>The name of a Security Hub insight.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of a Security Hub insight.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>One or more attributes used to filter the findings included in the insight. The insight only includes findings that match the criteria defined in the filters.</p>
        pub fn filters(mut self, input: crate::model::AwsSecurityFindingFilters) -> Self {
            self.filters = Some(input);
            self
        }
        /// <p>One or more attributes used to filter the findings included in the insight. The insight only includes findings that match the criteria defined in the filters.</p>
        pub fn set_filters(
            mut self,
            input: std::option::Option<crate::model::AwsSecurityFindingFilters>,
        ) -> Self {
            self.filters = input;
            self
        }
        /// <p>The grouping attribute for the insight's findings. Indicates how to group the matching findings, and identifies the type of item that the insight applies to. For example, if an insight is grouped by resource identifier, then the insight produces a list of resource identifiers.</p>
        pub fn group_by_attribute(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_by_attribute = Some(input.into());
            self
        }
        /// <p>The grouping attribute for the insight's findings. Indicates how to group the matching findings, and identifies the type of item that the insight applies to. For example, if an insight is grouped by resource identifier, then the insight produces a list of resource identifiers.</p>
        pub fn set_group_by_attribute(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.group_by_attribute = input;
            self
        }
        /// Consumes the builder and constructs a [`Insight`](crate::model::Insight)
        pub fn build(self) -> crate::model::Insight {
            crate::model::Insight {
                insight_arn: self.insight_arn,
                name: self.name,
                filters: self.filters,
                group_by_attribute: self.group_by_attribute,
            }
        }
    }
}
impl Insight {
    /// Creates a new builder-style object to manufacture [`Insight`](crate::model::Insight)
    pub fn builder() -> crate::model::insight::Builder {
        crate::model::insight::Builder::default()
    }
}

/// <p>The insight results returned by the <code>GetInsightResults</code> operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InsightResults {
    /// <p>The ARN of the insight whose results are returned by the <code>GetInsightResults</code> operation.</p>
    pub insight_arn: std::option::Option<std::string::String>,
    /// <p>The attribute that the findings are grouped by for the insight whose results are returned by the <code>GetInsightResults</code> operation.</p>
    pub group_by_attribute: std::option::Option<std::string::String>,
    /// <p>The list of insight result values returned by the <code>GetInsightResults</code> operation.</p>
    pub result_values: std::option::Option<std::vec::Vec<crate::model::InsightResultValue>>,
}
impl InsightResults {
    /// <p>The ARN of the insight whose results are returned by the <code>GetInsightResults</code> operation.</p>
    pub fn insight_arn(&self) -> std::option::Option<&str> {
        self.insight_arn.as_deref()
    }
    /// <p>The attribute that the findings are grouped by for the insight whose results are returned by the <code>GetInsightResults</code> operation.</p>
    pub fn group_by_attribute(&self) -> std::option::Option<&str> {
        self.group_by_attribute.as_deref()
    }
    /// <p>The list of insight result values returned by the <code>GetInsightResults</code> operation.</p>
    pub fn result_values(&self) -> std::option::Option<&[crate::model::InsightResultValue]> {
        self.result_values.as_deref()
    }
}
impl std::fmt::Debug for InsightResults {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InsightResults");
        formatter.field("insight_arn", &self.insight_arn);
        formatter.field("group_by_attribute", &self.group_by_attribute);
        formatter.field("result_values", &self.result_values);
        formatter.finish()
    }
}
/// See [`InsightResults`](crate::model::InsightResults)
pub mod insight_results {

    /// A builder for [`InsightResults`](crate::model::InsightResults)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) insight_arn: std::option::Option<std::string::String>,
        pub(crate) group_by_attribute: std::option::Option<std::string::String>,
        pub(crate) result_values:
            std::option::Option<std::vec::Vec<crate::model::InsightResultValue>>,
    }
    impl Builder {
        /// <p>The ARN of the insight whose results are returned by the <code>GetInsightResults</code> operation.</p>
        pub fn insight_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.insight_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the insight whose results are returned by the <code>GetInsightResults</code> operation.</p>
        pub fn set_insight_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.insight_arn = input;
            self
        }
        /// <p>The attribute that the findings are grouped by for the insight whose results are returned by the <code>GetInsightResults</code> operation.</p>
        pub fn group_by_attribute(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_by_attribute = Some(input.into());
            self
        }
        /// <p>The attribute that the findings are grouped by for the insight whose results are returned by the <code>GetInsightResults</code> operation.</p>
        pub fn set_group_by_attribute(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.group_by_attribute = input;
            self
        }
        /// Appends an item to `result_values`.
        ///
        /// To override the contents of this collection use [`set_result_values`](Self::set_result_values).
        ///
        /// <p>The list of insight result values returned by the <code>GetInsightResults</code> operation.</p>
        pub fn result_values(mut self, input: crate::model::InsightResultValue) -> Self {
            let mut v = self.result_values.unwrap_or_default();
            v.push(input);
            self.result_values = Some(v);
            self
        }
        /// <p>The list of insight result values returned by the <code>GetInsightResults</code> operation.</p>
        pub fn set_result_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InsightResultValue>>,
        ) -> Self {
            self.result_values = input;
            self
        }
        /// Consumes the builder and constructs a [`InsightResults`](crate::model::InsightResults)
        pub fn build(self) -> crate::model::InsightResults {
            crate::model::InsightResults {
                insight_arn: self.insight_arn,
                group_by_attribute: self.group_by_attribute,
                result_values: self.result_values,
            }
        }
    }
}
impl InsightResults {
    /// Creates a new builder-style object to manufacture [`InsightResults`](crate::model::InsightResults)
    pub fn builder() -> crate::model::insight_results::Builder {
        crate::model::insight_results::Builder::default()
    }
}

/// <p>The insight result values returned by the <code>GetInsightResults</code> operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InsightResultValue {
    /// <p>The value of the attribute that the findings are grouped by for the insight whose results are returned by the <code>GetInsightResults</code> operation.</p>
    pub group_by_attribute_value: std::option::Option<std::string::String>,
    /// <p>The number of findings returned for each <code>GroupByAttributeValue</code>.</p>
    pub count: i32,
}
impl InsightResultValue {
    /// <p>The value of the attribute that the findings are grouped by for the insight whose results are returned by the <code>GetInsightResults</code> operation.</p>
    pub fn group_by_attribute_value(&self) -> std::option::Option<&str> {
        self.group_by_attribute_value.as_deref()
    }
    /// <p>The number of findings returned for each <code>GroupByAttributeValue</code>.</p>
    pub fn count(&self) -> i32 {
        self.count
    }
}
impl std::fmt::Debug for InsightResultValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InsightResultValue");
        formatter.field("group_by_attribute_value", &self.group_by_attribute_value);
        formatter.field("count", &self.count);
        formatter.finish()
    }
}
/// See [`InsightResultValue`](crate::model::InsightResultValue)
pub mod insight_result_value {

    /// A builder for [`InsightResultValue`](crate::model::InsightResultValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_by_attribute_value: std::option::Option<std::string::String>,
        pub(crate) count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The value of the attribute that the findings are grouped by for the insight whose results are returned by the <code>GetInsightResults</code> operation.</p>
        pub fn group_by_attribute_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_by_attribute_value = Some(input.into());
            self
        }
        /// <p>The value of the attribute that the findings are grouped by for the insight whose results are returned by the <code>GetInsightResults</code> operation.</p>
        pub fn set_group_by_attribute_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.group_by_attribute_value = input;
            self
        }
        /// <p>The number of findings returned for each <code>GroupByAttributeValue</code>.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>The number of findings returned for each <code>GroupByAttributeValue</code>.</p>
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// Consumes the builder and constructs a [`InsightResultValue`](crate::model::InsightResultValue)
        pub fn build(self) -> crate::model::InsightResultValue {
            crate::model::InsightResultValue {
                group_by_attribute_value: self.group_by_attribute_value,
                count: self.count.unwrap_or_default(),
            }
        }
    }
}
impl InsightResultValue {
    /// Creates a new builder-style object to manufacture [`InsightResultValue`](crate::model::InsightResultValue)
    pub fn builder() -> crate::model::insight_result_value::Builder {
        crate::model::insight_result_value::Builder::default()
    }
}

/// <p>Provides consistent format for the contents of the Security Hub-aggregated findings. <code>AwsSecurityFinding</code> format enables you to share findings between Amazon Web Services security services and third-party solutions, and security standards checks.</p> <note>
/// <p>A finding is a potential security issue generated either by Amazon Web Services services or by the integrated third-party solutions and standards checks.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsSecurityFinding {
    /// <p>The schema version that a finding is formatted for.</p>
    pub schema_version: std::option::Option<std::string::String>,
    /// <p>The security findings provider-specific identifier for a finding.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The ARN generated by Security Hub that uniquely identifies a product that generates findings. This can be the ARN for a third-party product that is integrated with Security Hub, or the ARN for a custom integration.</p>
    pub product_arn: std::option::Option<std::string::String>,
    /// <p>The name of the product that generated the finding.</p>
    /// <p>Security Hub populates this attribute automatically for each finding. You cannot update this attribute with <code>BatchImportFindings</code> or <code>BatchUpdateFindings</code>. The exception to this is a custom integration.</p>
    /// <p>When you use the Security Hub console or API to filter findings by product name, you use this attribute.</p>
    pub product_name: std::option::Option<std::string::String>,
    /// <p>The name of the company for the product that generated the finding.</p>
    /// <p>Security Hub populates this attribute automatically for each finding. You cannot update this attribute with <code>BatchImportFindings</code> or <code>BatchUpdateFindings</code>. The exception to this is a custom integration.</p>
    /// <p>When you use the Security Hub console or API to filter findings by company name, you use this attribute.</p>
    pub company_name: std::option::Option<std::string::String>,
    /// <p>The Region from which the finding was generated.</p>
    /// <p>Security Hub populates this attribute automatically for each finding. You cannot update it using <code>BatchImportFindings</code> or <code>BatchUpdateFindings</code>.</p>
    pub region: std::option::Option<std::string::String>,
    /// <p>The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. In various security-findings providers' solutions, this generator can be called a rule, a check, a detector, a plugin, etc. </p>
    pub generator_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID that a finding is generated in.</p>
    pub aws_account_id: std::option::Option<std::string::String>,
    /// <p>One or more finding types in the format of <code>namespace/category/classifier</code> that classify a finding.</p>
    /// <p>Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual Behaviors | Sensitive Data Identifications</p>
    pub types: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Indicates when the security-findings provider first observed the potential security issue that a finding captured.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub first_observed_at: std::option::Option<std::string::String>,
    /// <p>Indicates when the security-findings provider most recently observed the potential security issue that a finding captured.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub last_observed_at: std::option::Option<std::string::String>,
    /// <p>Indicates when the security-findings provider created the potential security issue that a finding captured.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub created_at: std::option::Option<std::string::String>,
    /// <p>Indicates when the security-findings provider last updated the finding record.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub updated_at: std::option::Option<std::string::String>,
    /// <p>A finding's severity.</p>
    pub severity: std::option::Option<crate::model::Severity>,
    /// <p>A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify.</p>
    /// <p>Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.</p>
    pub confidence: i32,
    /// <p>The level of importance assigned to the resources associated with the finding.</p>
    /// <p>A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.</p>
    pub criticality: i32,
    /// <p>A finding's title.</p> <note>
    /// <p>In this release, <code>Title</code> is a required property.</p>
    /// </note>
    pub title: std::option::Option<std::string::String>,
    /// <p>A finding's description.</p> <note>
    /// <p>In this release, <code>Description</code> is a required property.</p>
    /// </note>
    pub description: std::option::Option<std::string::String>,
    /// <p>A data type that describes the remediation options for a finding.</p>
    pub remediation: std::option::Option<crate::model::Remediation>,
    /// <p>A URL that links to a page about the current finding in the security-findings provider's solution.</p>
    pub source_url: std::option::Option<std::string::String>,
    /// <p>A data type where security-findings providers can include additional solution-specific details that aren't part of the defined <code>AwsSecurityFinding</code> format.</p>
    /// <p>Can contain up to 50 key-value pairs. For each key-value pair, the key can contain up to 128 characters, and the value can contain up to 2048 characters.</p>
    pub product_fields:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding. </p>
    pub user_defined_fields:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A list of malware related to a finding.</p>
    pub malware: std::option::Option<std::vec::Vec<crate::model::Malware>>,
    /// <p>The details of network-related information about a finding.</p>
    pub network: std::option::Option<crate::model::Network>,
    /// <p>Provides information about a network path that is relevant to a finding. Each entry under <code>NetworkPath</code> represents a component of that path.</p>
    pub network_path: std::option::Option<std::vec::Vec<crate::model::NetworkPathComponent>>,
    /// <p>The details of process-related information about a finding.</p>
    pub process: std::option::Option<crate::model::ProcessDetails>,
    /// <p>Details about the threat detected in a security finding and the file paths that were affected by the threat. </p>
    pub threats: std::option::Option<std::vec::Vec<crate::model::Threat>>,
    /// <p>Threat intelligence details related to a finding.</p>
    pub threat_intel_indicators:
        std::option::Option<std::vec::Vec<crate::model::ThreatIntelIndicator>>,
    /// <p>A set of resource data types that describe the resources that the finding refers to.</p>
    pub resources: std::option::Option<std::vec::Vec<crate::model::Resource>>,
    /// <p>This data type is exclusive to findings that are generated as the result of a check run against a specific rule in a supported security standard, such as CIS Amazon Web Services Foundations. Contains security standard-related finding details.</p>
    pub compliance: std::option::Option<crate::model::Compliance>,
    /// <p>Indicates the veracity of a finding. </p>
    pub verification_state: std::option::Option<crate::model::VerificationState>,
    /// <p>The workflow state of a finding. </p>
    pub workflow_state: std::option::Option<crate::model::WorkflowState>,
    /// <p>Provides information about the status of the investigation into a finding.</p>
    pub workflow: std::option::Option<crate::model::Workflow>,
    /// <p>The record state of a finding.</p>
    pub record_state: std::option::Option<crate::model::RecordState>,
    /// <p>A list of related findings.</p>
    pub related_findings: std::option::Option<std::vec::Vec<crate::model::RelatedFinding>>,
    /// <p>A user-defined note added to a finding.</p>
    pub note: std::option::Option<crate::model::Note>,
    /// <p>Provides a list of vulnerabilities associated with the findings.</p>
    pub vulnerabilities: std::option::Option<std::vec::Vec<crate::model::Vulnerability>>,
    /// <p>Provides an overview of the patch compliance status for an instance against a selected compliance standard.</p>
    pub patch_summary: std::option::Option<crate::model::PatchSummary>,
    /// <p>Provides details about an action that affects or that was taken on a resource.</p>
    pub action: std::option::Option<crate::model::Action>,
    /// <p>In a <code>BatchImportFindings</code> request, finding providers use <code>FindingProviderFields</code> to provide and update their own values for confidence, criticality, related findings, severity, and types.</p>
    pub finding_provider_fields: std::option::Option<crate::model::FindingProviderFields>,
    /// <p>Indicates whether the finding is a sample finding.</p>
    pub sample: bool,
}
impl AwsSecurityFinding {
    /// <p>The schema version that a finding is formatted for.</p>
    pub fn schema_version(&self) -> std::option::Option<&str> {
        self.schema_version.as_deref()
    }
    /// <p>The security findings provider-specific identifier for a finding.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The ARN generated by Security Hub that uniquely identifies a product that generates findings. This can be the ARN for a third-party product that is integrated with Security Hub, or the ARN for a custom integration.</p>
    pub fn product_arn(&self) -> std::option::Option<&str> {
        self.product_arn.as_deref()
    }
    /// <p>The name of the product that generated the finding.</p>
    /// <p>Security Hub populates this attribute automatically for each finding. You cannot update this attribute with <code>BatchImportFindings</code> or <code>BatchUpdateFindings</code>. The exception to this is a custom integration.</p>
    /// <p>When you use the Security Hub console or API to filter findings by product name, you use this attribute.</p>
    pub fn product_name(&self) -> std::option::Option<&str> {
        self.product_name.as_deref()
    }
    /// <p>The name of the company for the product that generated the finding.</p>
    /// <p>Security Hub populates this attribute automatically for each finding. You cannot update this attribute with <code>BatchImportFindings</code> or <code>BatchUpdateFindings</code>. The exception to this is a custom integration.</p>
    /// <p>When you use the Security Hub console or API to filter findings by company name, you use this attribute.</p>
    pub fn company_name(&self) -> std::option::Option<&str> {
        self.company_name.as_deref()
    }
    /// <p>The Region from which the finding was generated.</p>
    /// <p>Security Hub populates this attribute automatically for each finding. You cannot update it using <code>BatchImportFindings</code> or <code>BatchUpdateFindings</code>.</p>
    pub fn region(&self) -> std::option::Option<&str> {
        self.region.as_deref()
    }
    /// <p>The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. In various security-findings providers' solutions, this generator can be called a rule, a check, a detector, a plugin, etc. </p>
    pub fn generator_id(&self) -> std::option::Option<&str> {
        self.generator_id.as_deref()
    }
    /// <p>The Amazon Web Services account ID that a finding is generated in.</p>
    pub fn aws_account_id(&self) -> std::option::Option<&str> {
        self.aws_account_id.as_deref()
    }
    /// <p>One or more finding types in the format of <code>namespace/category/classifier</code> that classify a finding.</p>
    /// <p>Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual Behaviors | Sensitive Data Identifications</p>
    pub fn types(&self) -> std::option::Option<&[std::string::String]> {
        self.types.as_deref()
    }
    /// <p>Indicates when the security-findings provider first observed the potential security issue that a finding captured.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn first_observed_at(&self) -> std::option::Option<&str> {
        self.first_observed_at.as_deref()
    }
    /// <p>Indicates when the security-findings provider most recently observed the potential security issue that a finding captured.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn last_observed_at(&self) -> std::option::Option<&str> {
        self.last_observed_at.as_deref()
    }
    /// <p>Indicates when the security-findings provider created the potential security issue that a finding captured.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn created_at(&self) -> std::option::Option<&str> {
        self.created_at.as_deref()
    }
    /// <p>Indicates when the security-findings provider last updated the finding record.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn updated_at(&self) -> std::option::Option<&str> {
        self.updated_at.as_deref()
    }
    /// <p>A finding's severity.</p>
    pub fn severity(&self) -> std::option::Option<&crate::model::Severity> {
        self.severity.as_ref()
    }
    /// <p>A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify.</p>
    /// <p>Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.</p>
    pub fn confidence(&self) -> i32 {
        self.confidence
    }
    /// <p>The level of importance assigned to the resources associated with the finding.</p>
    /// <p>A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.</p>
    pub fn criticality(&self) -> i32 {
        self.criticality
    }
    /// <p>A finding's title.</p> <note>
    /// <p>In this release, <code>Title</code> is a required property.</p>
    /// </note>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>A finding's description.</p> <note>
    /// <p>In this release, <code>Description</code> is a required property.</p>
    /// </note>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>A data type that describes the remediation options for a finding.</p>
    pub fn remediation(&self) -> std::option::Option<&crate::model::Remediation> {
        self.remediation.as_ref()
    }
    /// <p>A URL that links to a page about the current finding in the security-findings provider's solution.</p>
    pub fn source_url(&self) -> std::option::Option<&str> {
        self.source_url.as_deref()
    }
    /// <p>A data type where security-findings providers can include additional solution-specific details that aren't part of the defined <code>AwsSecurityFinding</code> format.</p>
    /// <p>Can contain up to 50 key-value pairs. For each key-value pair, the key can contain up to 128 characters, and the value can contain up to 2048 characters.</p>
    pub fn product_fields(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.product_fields.as_ref()
    }
    /// <p>A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding. </p>
    pub fn user_defined_fields(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.user_defined_fields.as_ref()
    }
    /// <p>A list of malware related to a finding.</p>
    pub fn malware(&self) -> std::option::Option<&[crate::model::Malware]> {
        self.malware.as_deref()
    }
    /// <p>The details of network-related information about a finding.</p>
    pub fn network(&self) -> std::option::Option<&crate::model::Network> {
        self.network.as_ref()
    }
    /// <p>Provides information about a network path that is relevant to a finding. Each entry under <code>NetworkPath</code> represents a component of that path.</p>
    pub fn network_path(&self) -> std::option::Option<&[crate::model::NetworkPathComponent]> {
        self.network_path.as_deref()
    }
    /// <p>The details of process-related information about a finding.</p>
    pub fn process(&self) -> std::option::Option<&crate::model::ProcessDetails> {
        self.process.as_ref()
    }
    /// <p>Details about the threat detected in a security finding and the file paths that were affected by the threat. </p>
    pub fn threats(&self) -> std::option::Option<&[crate::model::Threat]> {
        self.threats.as_deref()
    }
    /// <p>Threat intelligence details related to a finding.</p>
    pub fn threat_intel_indicators(
        &self,
    ) -> std::option::Option<&[crate::model::ThreatIntelIndicator]> {
        self.threat_intel_indicators.as_deref()
    }
    /// <p>A set of resource data types that describe the resources that the finding refers to.</p>
    pub fn resources(&self) -> std::option::Option<&[crate::model::Resource]> {
        self.resources.as_deref()
    }
    /// <p>This data type is exclusive to findings that are generated as the result of a check run against a specific rule in a supported security standard, such as CIS Amazon Web Services Foundations. Contains security standard-related finding details.</p>
    pub fn compliance(&self) -> std::option::Option<&crate::model::Compliance> {
        self.compliance.as_ref()
    }
    /// <p>Indicates the veracity of a finding. </p>
    pub fn verification_state(&self) -> std::option::Option<&crate::model::VerificationState> {
        self.verification_state.as_ref()
    }
    /// <p>The workflow state of a finding. </p>
    pub fn workflow_state(&self) -> std::option::Option<&crate::model::WorkflowState> {
        self.workflow_state.as_ref()
    }
    /// <p>Provides information about the status of the investigation into a finding.</p>
    pub fn workflow(&self) -> std::option::Option<&crate::model::Workflow> {
        self.workflow.as_ref()
    }
    /// <p>The record state of a finding.</p>
    pub fn record_state(&self) -> std::option::Option<&crate::model::RecordState> {
        self.record_state.as_ref()
    }
    /// <p>A list of related findings.</p>
    pub fn related_findings(&self) -> std::option::Option<&[crate::model::RelatedFinding]> {
        self.related_findings.as_deref()
    }
    /// <p>A user-defined note added to a finding.</p>
    pub fn note(&self) -> std::option::Option<&crate::model::Note> {
        self.note.as_ref()
    }
    /// <p>Provides a list of vulnerabilities associated with the findings.</p>
    pub fn vulnerabilities(&self) -> std::option::Option<&[crate::model::Vulnerability]> {
        self.vulnerabilities.as_deref()
    }
    /// <p>Provides an overview of the patch compliance status for an instance against a selected compliance standard.</p>
    pub fn patch_summary(&self) -> std::option::Option<&crate::model::PatchSummary> {
        self.patch_summary.as_ref()
    }
    /// <p>Provides details about an action that affects or that was taken on a resource.</p>
    pub fn action(&self) -> std::option::Option<&crate::model::Action> {
        self.action.as_ref()
    }
    /// <p>In a <code>BatchImportFindings</code> request, finding providers use <code>FindingProviderFields</code> to provide and update their own values for confidence, criticality, related findings, severity, and types.</p>
    pub fn finding_provider_fields(
        &self,
    ) -> std::option::Option<&crate::model::FindingProviderFields> {
        self.finding_provider_fields.as_ref()
    }
    /// <p>Indicates whether the finding is a sample finding.</p>
    pub fn sample(&self) -> bool {
        self.sample
    }
}
impl std::fmt::Debug for AwsSecurityFinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsSecurityFinding");
        formatter.field("schema_version", &self.schema_version);
        formatter.field("id", &self.id);
        formatter.field("product_arn", &self.product_arn);
        formatter.field("product_name", &self.product_name);
        formatter.field("company_name", &self.company_name);
        formatter.field("region", &self.region);
        formatter.field("generator_id", &self.generator_id);
        formatter.field("aws_account_id", &self.aws_account_id);
        formatter.field("types", &self.types);
        formatter.field("first_observed_at", &self.first_observed_at);
        formatter.field("last_observed_at", &self.last_observed_at);
        formatter.field("created_at", &self.created_at);
        formatter.field("updated_at", &self.updated_at);
        formatter.field("severity", &self.severity);
        formatter.field("confidence", &self.confidence);
        formatter.field("criticality", &self.criticality);
        formatter.field("title", &self.title);
        formatter.field("description", &self.description);
        formatter.field("remediation", &self.remediation);
        formatter.field("source_url", &self.source_url);
        formatter.field("product_fields", &self.product_fields);
        formatter.field("user_defined_fields", &self.user_defined_fields);
        formatter.field("malware", &self.malware);
        formatter.field("network", &self.network);
        formatter.field("network_path", &self.network_path);
        formatter.field("process", &self.process);
        formatter.field("threats", &self.threats);
        formatter.field("threat_intel_indicators", &self.threat_intel_indicators);
        formatter.field("resources", &self.resources);
        formatter.field("compliance", &self.compliance);
        formatter.field("verification_state", &self.verification_state);
        formatter.field("workflow_state", &self.workflow_state);
        formatter.field("workflow", &self.workflow);
        formatter.field("record_state", &self.record_state);
        formatter.field("related_findings", &self.related_findings);
        formatter.field("note", &self.note);
        formatter.field("vulnerabilities", &self.vulnerabilities);
        formatter.field("patch_summary", &self.patch_summary);
        formatter.field("action", &self.action);
        formatter.field("finding_provider_fields", &self.finding_provider_fields);
        formatter.field("sample", &self.sample);
        formatter.finish()
    }
}
/// See [`AwsSecurityFinding`](crate::model::AwsSecurityFinding)
pub mod aws_security_finding {

    /// A builder for [`AwsSecurityFinding`](crate::model::AwsSecurityFinding)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) schema_version: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) product_arn: std::option::Option<std::string::String>,
        pub(crate) product_name: std::option::Option<std::string::String>,
        pub(crate) company_name: std::option::Option<std::string::String>,
        pub(crate) region: std::option::Option<std::string::String>,
        pub(crate) generator_id: std::option::Option<std::string::String>,
        pub(crate) aws_account_id: std::option::Option<std::string::String>,
        pub(crate) types: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) first_observed_at: std::option::Option<std::string::String>,
        pub(crate) last_observed_at: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<std::string::String>,
        pub(crate) updated_at: std::option::Option<std::string::String>,
        pub(crate) severity: std::option::Option<crate::model::Severity>,
        pub(crate) confidence: std::option::Option<i32>,
        pub(crate) criticality: std::option::Option<i32>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) remediation: std::option::Option<crate::model::Remediation>,
        pub(crate) source_url: std::option::Option<std::string::String>,
        pub(crate) product_fields: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) user_defined_fields: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) malware: std::option::Option<std::vec::Vec<crate::model::Malware>>,
        pub(crate) network: std::option::Option<crate::model::Network>,
        pub(crate) network_path:
            std::option::Option<std::vec::Vec<crate::model::NetworkPathComponent>>,
        pub(crate) process: std::option::Option<crate::model::ProcessDetails>,
        pub(crate) threats: std::option::Option<std::vec::Vec<crate::model::Threat>>,
        pub(crate) threat_intel_indicators:
            std::option::Option<std::vec::Vec<crate::model::ThreatIntelIndicator>>,
        pub(crate) resources: std::option::Option<std::vec::Vec<crate::model::Resource>>,
        pub(crate) compliance: std::option::Option<crate::model::Compliance>,
        pub(crate) verification_state: std::option::Option<crate::model::VerificationState>,
        pub(crate) workflow_state: std::option::Option<crate::model::WorkflowState>,
        pub(crate) workflow: std::option::Option<crate::model::Workflow>,
        pub(crate) record_state: std::option::Option<crate::model::RecordState>,
        pub(crate) related_findings:
            std::option::Option<std::vec::Vec<crate::model::RelatedFinding>>,
        pub(crate) note: std::option::Option<crate::model::Note>,
        pub(crate) vulnerabilities: std::option::Option<std::vec::Vec<crate::model::Vulnerability>>,
        pub(crate) patch_summary: std::option::Option<crate::model::PatchSummary>,
        pub(crate) action: std::option::Option<crate::model::Action>,
        pub(crate) finding_provider_fields:
            std::option::Option<crate::model::FindingProviderFields>,
        pub(crate) sample: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The schema version that a finding is formatted for.</p>
        pub fn schema_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.schema_version = Some(input.into());
            self
        }
        /// <p>The schema version that a finding is formatted for.</p>
        pub fn set_schema_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.schema_version = input;
            self
        }
        /// <p>The security findings provider-specific identifier for a finding.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The security findings provider-specific identifier for a finding.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The ARN generated by Security Hub that uniquely identifies a product that generates findings. This can be the ARN for a third-party product that is integrated with Security Hub, or the ARN for a custom integration.</p>
        pub fn product_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.product_arn = Some(input.into());
            self
        }
        /// <p>The ARN generated by Security Hub that uniquely identifies a product that generates findings. This can be the ARN for a third-party product that is integrated with Security Hub, or the ARN for a custom integration.</p>
        pub fn set_product_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product_arn = input;
            self
        }
        /// <p>The name of the product that generated the finding.</p>
        /// <p>Security Hub populates this attribute automatically for each finding. You cannot update this attribute with <code>BatchImportFindings</code> or <code>BatchUpdateFindings</code>. The exception to this is a custom integration.</p>
        /// <p>When you use the Security Hub console or API to filter findings by product name, you use this attribute.</p>
        pub fn product_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.product_name = Some(input.into());
            self
        }
        /// <p>The name of the product that generated the finding.</p>
        /// <p>Security Hub populates this attribute automatically for each finding. You cannot update this attribute with <code>BatchImportFindings</code> or <code>BatchUpdateFindings</code>. The exception to this is a custom integration.</p>
        /// <p>When you use the Security Hub console or API to filter findings by product name, you use this attribute.</p>
        pub fn set_product_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product_name = input;
            self
        }
        /// <p>The name of the company for the product that generated the finding.</p>
        /// <p>Security Hub populates this attribute automatically for each finding. You cannot update this attribute with <code>BatchImportFindings</code> or <code>BatchUpdateFindings</code>. The exception to this is a custom integration.</p>
        /// <p>When you use the Security Hub console or API to filter findings by company name, you use this attribute.</p>
        pub fn company_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.company_name = Some(input.into());
            self
        }
        /// <p>The name of the company for the product that generated the finding.</p>
        /// <p>Security Hub populates this attribute automatically for each finding. You cannot update this attribute with <code>BatchImportFindings</code> or <code>BatchUpdateFindings</code>. The exception to this is a custom integration.</p>
        /// <p>When you use the Security Hub console or API to filter findings by company name, you use this attribute.</p>
        pub fn set_company_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.company_name = input;
            self
        }
        /// <p>The Region from which the finding was generated.</p>
        /// <p>Security Hub populates this attribute automatically for each finding. You cannot update it using <code>BatchImportFindings</code> or <code>BatchUpdateFindings</code>.</p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        /// <p>The Region from which the finding was generated.</p>
        /// <p>Security Hub populates this attribute automatically for each finding. You cannot update it using <code>BatchImportFindings</code> or <code>BatchUpdateFindings</code>.</p>
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// <p>The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. In various security-findings providers' solutions, this generator can be called a rule, a check, a detector, a plugin, etc. </p>
        pub fn generator_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.generator_id = Some(input.into());
            self
        }
        /// <p>The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. In various security-findings providers' solutions, this generator can be called a rule, a check, a detector, a plugin, etc. </p>
        pub fn set_generator_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.generator_id = input;
            self
        }
        /// <p>The Amazon Web Services account ID that a finding is generated in.</p>
        pub fn aws_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID that a finding is generated in.</p>
        pub fn set_aws_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.aws_account_id = input;
            self
        }
        /// Appends an item to `types`.
        ///
        /// To override the contents of this collection use [`set_types`](Self::set_types).
        ///
        /// <p>One or more finding types in the format of <code>namespace/category/classifier</code> that classify a finding.</p>
        /// <p>Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual Behaviors | Sensitive Data Identifications</p>
        pub fn types(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.types.unwrap_or_default();
            v.push(input.into());
            self.types = Some(v);
            self
        }
        /// <p>One or more finding types in the format of <code>namespace/category/classifier</code> that classify a finding.</p>
        /// <p>Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual Behaviors | Sensitive Data Identifications</p>
        pub fn set_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.types = input;
            self
        }
        /// <p>Indicates when the security-findings provider first observed the potential security issue that a finding captured.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn first_observed_at(mut self, input: impl Into<std::string::String>) -> Self {
            self.first_observed_at = Some(input.into());
            self
        }
        /// <p>Indicates when the security-findings provider first observed the potential security issue that a finding captured.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_first_observed_at(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.first_observed_at = input;
            self
        }
        /// <p>Indicates when the security-findings provider most recently observed the potential security issue that a finding captured.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn last_observed_at(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_observed_at = Some(input.into());
            self
        }
        /// <p>Indicates when the security-findings provider most recently observed the potential security issue that a finding captured.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_last_observed_at(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_observed_at = input;
            self
        }
        /// <p>Indicates when the security-findings provider created the potential security issue that a finding captured.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn created_at(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_at = Some(input.into());
            self
        }
        /// <p>Indicates when the security-findings provider created the potential security issue that a finding captured.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_created_at(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_at = input;
            self
        }
        /// <p>Indicates when the security-findings provider last updated the finding record.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn updated_at(mut self, input: impl Into<std::string::String>) -> Self {
            self.updated_at = Some(input.into());
            self
        }
        /// <p>Indicates when the security-findings provider last updated the finding record.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_updated_at(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>A finding's severity.</p>
        pub fn severity(mut self, input: crate::model::Severity) -> Self {
            self.severity = Some(input);
            self
        }
        /// <p>A finding's severity.</p>
        pub fn set_severity(mut self, input: std::option::Option<crate::model::Severity>) -> Self {
            self.severity = input;
            self
        }
        /// <p>A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify.</p>
        /// <p>Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.</p>
        pub fn confidence(mut self, input: i32) -> Self {
            self.confidence = Some(input);
            self
        }
        /// <p>A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify.</p>
        /// <p>Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.</p>
        pub fn set_confidence(mut self, input: std::option::Option<i32>) -> Self {
            self.confidence = input;
            self
        }
        /// <p>The level of importance assigned to the resources associated with the finding.</p>
        /// <p>A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.</p>
        pub fn criticality(mut self, input: i32) -> Self {
            self.criticality = Some(input);
            self
        }
        /// <p>The level of importance assigned to the resources associated with the finding.</p>
        /// <p>A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.</p>
        pub fn set_criticality(mut self, input: std::option::Option<i32>) -> Self {
            self.criticality = input;
            self
        }
        /// <p>A finding's title.</p> <note>
        /// <p>In this release, <code>Title</code> is a required property.</p>
        /// </note>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>A finding's title.</p> <note>
        /// <p>In this release, <code>Title</code> is a required property.</p>
        /// </note>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>A finding's description.</p> <note>
        /// <p>In this release, <code>Description</code> is a required property.</p>
        /// </note>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A finding's description.</p> <note>
        /// <p>In this release, <code>Description</code> is a required property.</p>
        /// </note>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>A data type that describes the remediation options for a finding.</p>
        pub fn remediation(mut self, input: crate::model::Remediation) -> Self {
            self.remediation = Some(input);
            self
        }
        /// <p>A data type that describes the remediation options for a finding.</p>
        pub fn set_remediation(
            mut self,
            input: std::option::Option<crate::model::Remediation>,
        ) -> Self {
            self.remediation = input;
            self
        }
        /// <p>A URL that links to a page about the current finding in the security-findings provider's solution.</p>
        pub fn source_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_url = Some(input.into());
            self
        }
        /// <p>A URL that links to a page about the current finding in the security-findings provider's solution.</p>
        pub fn set_source_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_url = input;
            self
        }
        /// Adds a key-value pair to `product_fields`.
        ///
        /// To override the contents of this collection use [`set_product_fields`](Self::set_product_fields).
        ///
        /// <p>A data type where security-findings providers can include additional solution-specific details that aren't part of the defined <code>AwsSecurityFinding</code> format.</p>
        /// <p>Can contain up to 50 key-value pairs. For each key-value pair, the key can contain up to 128 characters, and the value can contain up to 2048 characters.</p>
        pub fn product_fields(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.product_fields.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.product_fields = Some(hash_map);
            self
        }
        /// <p>A data type where security-findings providers can include additional solution-specific details that aren't part of the defined <code>AwsSecurityFinding</code> format.</p>
        /// <p>Can contain up to 50 key-value pairs. For each key-value pair, the key can contain up to 128 characters, and the value can contain up to 2048 characters.</p>
        pub fn set_product_fields(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.product_fields = input;
            self
        }
        /// Adds a key-value pair to `user_defined_fields`.
        ///
        /// To override the contents of this collection use [`set_user_defined_fields`](Self::set_user_defined_fields).
        ///
        /// <p>A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding. </p>
        pub fn user_defined_fields(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.user_defined_fields.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.user_defined_fields = Some(hash_map);
            self
        }
        /// <p>A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding. </p>
        pub fn set_user_defined_fields(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.user_defined_fields = input;
            self
        }
        /// Appends an item to `malware`.
        ///
        /// To override the contents of this collection use [`set_malware`](Self::set_malware).
        ///
        /// <p>A list of malware related to a finding.</p>
        pub fn malware(mut self, input: crate::model::Malware) -> Self {
            let mut v = self.malware.unwrap_or_default();
            v.push(input);
            self.malware = Some(v);
            self
        }
        /// <p>A list of malware related to a finding.</p>
        pub fn set_malware(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Malware>>,
        ) -> Self {
            self.malware = input;
            self
        }
        /// <p>The details of network-related information about a finding.</p>
        pub fn network(mut self, input: crate::model::Network) -> Self {
            self.network = Some(input);
            self
        }
        /// <p>The details of network-related information about a finding.</p>
        pub fn set_network(mut self, input: std::option::Option<crate::model::Network>) -> Self {
            self.network = input;
            self
        }
        /// Appends an item to `network_path`.
        ///
        /// To override the contents of this collection use [`set_network_path`](Self::set_network_path).
        ///
        /// <p>Provides information about a network path that is relevant to a finding. Each entry under <code>NetworkPath</code> represents a component of that path.</p>
        pub fn network_path(mut self, input: crate::model::NetworkPathComponent) -> Self {
            let mut v = self.network_path.unwrap_or_default();
            v.push(input);
            self.network_path = Some(v);
            self
        }
        /// <p>Provides information about a network path that is relevant to a finding. Each entry under <code>NetworkPath</code> represents a component of that path.</p>
        pub fn set_network_path(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NetworkPathComponent>>,
        ) -> Self {
            self.network_path = input;
            self
        }
        /// <p>The details of process-related information about a finding.</p>
        pub fn process(mut self, input: crate::model::ProcessDetails) -> Self {
            self.process = Some(input);
            self
        }
        /// <p>The details of process-related information about a finding.</p>
        pub fn set_process(
            mut self,
            input: std::option::Option<crate::model::ProcessDetails>,
        ) -> Self {
            self.process = input;
            self
        }
        /// Appends an item to `threats`.
        ///
        /// To override the contents of this collection use [`set_threats`](Self::set_threats).
        ///
        /// <p>Details about the threat detected in a security finding and the file paths that were affected by the threat. </p>
        pub fn threats(mut self, input: crate::model::Threat) -> Self {
            let mut v = self.threats.unwrap_or_default();
            v.push(input);
            self.threats = Some(v);
            self
        }
        /// <p>Details about the threat detected in a security finding and the file paths that were affected by the threat. </p>
        pub fn set_threats(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Threat>>,
        ) -> Self {
            self.threats = input;
            self
        }
        /// Appends an item to `threat_intel_indicators`.
        ///
        /// To override the contents of this collection use [`set_threat_intel_indicators`](Self::set_threat_intel_indicators).
        ///
        /// <p>Threat intelligence details related to a finding.</p>
        pub fn threat_intel_indicators(
            mut self,
            input: crate::model::ThreatIntelIndicator,
        ) -> Self {
            let mut v = self.threat_intel_indicators.unwrap_or_default();
            v.push(input);
            self.threat_intel_indicators = Some(v);
            self
        }
        /// <p>Threat intelligence details related to a finding.</p>
        pub fn set_threat_intel_indicators(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ThreatIntelIndicator>>,
        ) -> Self {
            self.threat_intel_indicators = input;
            self
        }
        /// Appends an item to `resources`.
        ///
        /// To override the contents of this collection use [`set_resources`](Self::set_resources).
        ///
        /// <p>A set of resource data types that describe the resources that the finding refers to.</p>
        pub fn resources(mut self, input: crate::model::Resource) -> Self {
            let mut v = self.resources.unwrap_or_default();
            v.push(input);
            self.resources = Some(v);
            self
        }
        /// <p>A set of resource data types that describe the resources that the finding refers to.</p>
        pub fn set_resources(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Resource>>,
        ) -> Self {
            self.resources = input;
            self
        }
        /// <p>This data type is exclusive to findings that are generated as the result of a check run against a specific rule in a supported security standard, such as CIS Amazon Web Services Foundations. Contains security standard-related finding details.</p>
        pub fn compliance(mut self, input: crate::model::Compliance) -> Self {
            self.compliance = Some(input);
            self
        }
        /// <p>This data type is exclusive to findings that are generated as the result of a check run against a specific rule in a supported security standard, such as CIS Amazon Web Services Foundations. Contains security standard-related finding details.</p>
        pub fn set_compliance(
            mut self,
            input: std::option::Option<crate::model::Compliance>,
        ) -> Self {
            self.compliance = input;
            self
        }
        /// <p>Indicates the veracity of a finding. </p>
        pub fn verification_state(mut self, input: crate::model::VerificationState) -> Self {
            self.verification_state = Some(input);
            self
        }
        /// <p>Indicates the veracity of a finding. </p>
        pub fn set_verification_state(
            mut self,
            input: std::option::Option<crate::model::VerificationState>,
        ) -> Self {
            self.verification_state = input;
            self
        }
        /// <p>The workflow state of a finding. </p>
        pub fn workflow_state(mut self, input: crate::model::WorkflowState) -> Self {
            self.workflow_state = Some(input);
            self
        }
        /// <p>The workflow state of a finding. </p>
        pub fn set_workflow_state(
            mut self,
            input: std::option::Option<crate::model::WorkflowState>,
        ) -> Self {
            self.workflow_state = input;
            self
        }
        /// <p>Provides information about the status of the investigation into a finding.</p>
        pub fn workflow(mut self, input: crate::model::Workflow) -> Self {
            self.workflow = Some(input);
            self
        }
        /// <p>Provides information about the status of the investigation into a finding.</p>
        pub fn set_workflow(mut self, input: std::option::Option<crate::model::Workflow>) -> Self {
            self.workflow = input;
            self
        }
        /// <p>The record state of a finding.</p>
        pub fn record_state(mut self, input: crate::model::RecordState) -> Self {
            self.record_state = Some(input);
            self
        }
        /// <p>The record state of a finding.</p>
        pub fn set_record_state(
            mut self,
            input: std::option::Option<crate::model::RecordState>,
        ) -> Self {
            self.record_state = input;
            self
        }
        /// Appends an item to `related_findings`.
        ///
        /// To override the contents of this collection use [`set_related_findings`](Self::set_related_findings).
        ///
        /// <p>A list of related findings.</p>
        pub fn related_findings(mut self, input: crate::model::RelatedFinding) -> Self {
            let mut v = self.related_findings.unwrap_or_default();
            v.push(input);
            self.related_findings = Some(v);
            self
        }
        /// <p>A list of related findings.</p>
        pub fn set_related_findings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RelatedFinding>>,
        ) -> Self {
            self.related_findings = input;
            self
        }
        /// <p>A user-defined note added to a finding.</p>
        pub fn note(mut self, input: crate::model::Note) -> Self {
            self.note = Some(input);
            self
        }
        /// <p>A user-defined note added to a finding.</p>
        pub fn set_note(mut self, input: std::option::Option<crate::model::Note>) -> Self {
            self.note = input;
            self
        }
        /// Appends an item to `vulnerabilities`.
        ///
        /// To override the contents of this collection use [`set_vulnerabilities`](Self::set_vulnerabilities).
        ///
        /// <p>Provides a list of vulnerabilities associated with the findings.</p>
        pub fn vulnerabilities(mut self, input: crate::model::Vulnerability) -> Self {
            let mut v = self.vulnerabilities.unwrap_or_default();
            v.push(input);
            self.vulnerabilities = Some(v);
            self
        }
        /// <p>Provides a list of vulnerabilities associated with the findings.</p>
        pub fn set_vulnerabilities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Vulnerability>>,
        ) -> Self {
            self.vulnerabilities = input;
            self
        }
        /// <p>Provides an overview of the patch compliance status for an instance against a selected compliance standard.</p>
        pub fn patch_summary(mut self, input: crate::model::PatchSummary) -> Self {
            self.patch_summary = Some(input);
            self
        }
        /// <p>Provides an overview of the patch compliance status for an instance against a selected compliance standard.</p>
        pub fn set_patch_summary(
            mut self,
            input: std::option::Option<crate::model::PatchSummary>,
        ) -> Self {
            self.patch_summary = input;
            self
        }
        /// <p>Provides details about an action that affects or that was taken on a resource.</p>
        pub fn action(mut self, input: crate::model::Action) -> Self {
            self.action = Some(input);
            self
        }
        /// <p>Provides details about an action that affects or that was taken on a resource.</p>
        pub fn set_action(mut self, input: std::option::Option<crate::model::Action>) -> Self {
            self.action = input;
            self
        }
        /// <p>In a <code>BatchImportFindings</code> request, finding providers use <code>FindingProviderFields</code> to provide and update their own values for confidence, criticality, related findings, severity, and types.</p>
        pub fn finding_provider_fields(
            mut self,
            input: crate::model::FindingProviderFields,
        ) -> Self {
            self.finding_provider_fields = Some(input);
            self
        }
        /// <p>In a <code>BatchImportFindings</code> request, finding providers use <code>FindingProviderFields</code> to provide and update their own values for confidence, criticality, related findings, severity, and types.</p>
        pub fn set_finding_provider_fields(
            mut self,
            input: std::option::Option<crate::model::FindingProviderFields>,
        ) -> Self {
            self.finding_provider_fields = input;
            self
        }
        /// <p>Indicates whether the finding is a sample finding.</p>
        pub fn sample(mut self, input: bool) -> Self {
            self.sample = Some(input);
            self
        }
        /// <p>Indicates whether the finding is a sample finding.</p>
        pub fn set_sample(mut self, input: std::option::Option<bool>) -> Self {
            self.sample = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsSecurityFinding`](crate::model::AwsSecurityFinding)
        pub fn build(self) -> crate::model::AwsSecurityFinding {
            crate::model::AwsSecurityFinding {
                schema_version: self.schema_version,
                id: self.id,
                product_arn: self.product_arn,
                product_name: self.product_name,
                company_name: self.company_name,
                region: self.region,
                generator_id: self.generator_id,
                aws_account_id: self.aws_account_id,
                types: self.types,
                first_observed_at: self.first_observed_at,
                last_observed_at: self.last_observed_at,
                created_at: self.created_at,
                updated_at: self.updated_at,
                severity: self.severity,
                confidence: self.confidence.unwrap_or_default(),
                criticality: self.criticality.unwrap_or_default(),
                title: self.title,
                description: self.description,
                remediation: self.remediation,
                source_url: self.source_url,
                product_fields: self.product_fields,
                user_defined_fields: self.user_defined_fields,
                malware: self.malware,
                network: self.network,
                network_path: self.network_path,
                process: self.process,
                threats: self.threats,
                threat_intel_indicators: self.threat_intel_indicators,
                resources: self.resources,
                compliance: self.compliance,
                verification_state: self.verification_state,
                workflow_state: self.workflow_state,
                workflow: self.workflow,
                record_state: self.record_state,
                related_findings: self.related_findings,
                note: self.note,
                vulnerabilities: self.vulnerabilities,
                patch_summary: self.patch_summary,
                action: self.action,
                finding_provider_fields: self.finding_provider_fields,
                sample: self.sample.unwrap_or_default(),
            }
        }
    }
}
impl AwsSecurityFinding {
    /// Creates a new builder-style object to manufacture [`AwsSecurityFinding`](crate::model::AwsSecurityFinding)
    pub fn builder() -> crate::model::aws_security_finding::Builder {
        crate::model::aws_security_finding::Builder::default()
    }
}

/// <p>In a <code>BatchImportFindings</code> request, finding providers use <code>FindingProviderFields</code> to provide and update values for confidence, criticality, related findings, severity, and types.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FindingProviderFields {
    /// <p>A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify.</p>
    /// <p>Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.</p>
    pub confidence: i32,
    /// <p>The level of importance assigned to the resources associated with the finding.</p>
    /// <p>A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.</p>
    pub criticality: i32,
    /// <p>A list of findings that are related to the current finding.</p>
    pub related_findings: std::option::Option<std::vec::Vec<crate::model::RelatedFinding>>,
    /// <p>The severity of a finding.</p>
    pub severity: std::option::Option<crate::model::FindingProviderSeverity>,
    /// <p>One or more finding types in the format of <code>namespace/category/classifier</code> that classify a finding.</p>
    /// <p>Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual Behaviors | Sensitive Data Identifications</p>
    pub types: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl FindingProviderFields {
    /// <p>A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify.</p>
    /// <p>Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.</p>
    pub fn confidence(&self) -> i32 {
        self.confidence
    }
    /// <p>The level of importance assigned to the resources associated with the finding.</p>
    /// <p>A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.</p>
    pub fn criticality(&self) -> i32 {
        self.criticality
    }
    /// <p>A list of findings that are related to the current finding.</p>
    pub fn related_findings(&self) -> std::option::Option<&[crate::model::RelatedFinding]> {
        self.related_findings.as_deref()
    }
    /// <p>The severity of a finding.</p>
    pub fn severity(&self) -> std::option::Option<&crate::model::FindingProviderSeverity> {
        self.severity.as_ref()
    }
    /// <p>One or more finding types in the format of <code>namespace/category/classifier</code> that classify a finding.</p>
    /// <p>Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual Behaviors | Sensitive Data Identifications</p>
    pub fn types(&self) -> std::option::Option<&[std::string::String]> {
        self.types.as_deref()
    }
}
impl std::fmt::Debug for FindingProviderFields {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FindingProviderFields");
        formatter.field("confidence", &self.confidence);
        formatter.field("criticality", &self.criticality);
        formatter.field("related_findings", &self.related_findings);
        formatter.field("severity", &self.severity);
        formatter.field("types", &self.types);
        formatter.finish()
    }
}
/// See [`FindingProviderFields`](crate::model::FindingProviderFields)
pub mod finding_provider_fields {

    /// A builder for [`FindingProviderFields`](crate::model::FindingProviderFields)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) confidence: std::option::Option<i32>,
        pub(crate) criticality: std::option::Option<i32>,
        pub(crate) related_findings:
            std::option::Option<std::vec::Vec<crate::model::RelatedFinding>>,
        pub(crate) severity: std::option::Option<crate::model::FindingProviderSeverity>,
        pub(crate) types: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify.</p>
        /// <p>Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.</p>
        pub fn confidence(mut self, input: i32) -> Self {
            self.confidence = Some(input);
            self
        }
        /// <p>A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify.</p>
        /// <p>Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.</p>
        pub fn set_confidence(mut self, input: std::option::Option<i32>) -> Self {
            self.confidence = input;
            self
        }
        /// <p>The level of importance assigned to the resources associated with the finding.</p>
        /// <p>A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.</p>
        pub fn criticality(mut self, input: i32) -> Self {
            self.criticality = Some(input);
            self
        }
        /// <p>The level of importance assigned to the resources associated with the finding.</p>
        /// <p>A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.</p>
        pub fn set_criticality(mut self, input: std::option::Option<i32>) -> Self {
            self.criticality = input;
            self
        }
        /// Appends an item to `related_findings`.
        ///
        /// To override the contents of this collection use [`set_related_findings`](Self::set_related_findings).
        ///
        /// <p>A list of findings that are related to the current finding.</p>
        pub fn related_findings(mut self, input: crate::model::RelatedFinding) -> Self {
            let mut v = self.related_findings.unwrap_or_default();
            v.push(input);
            self.related_findings = Some(v);
            self
        }
        /// <p>A list of findings that are related to the current finding.</p>
        pub fn set_related_findings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RelatedFinding>>,
        ) -> Self {
            self.related_findings = input;
            self
        }
        /// <p>The severity of a finding.</p>
        pub fn severity(mut self, input: crate::model::FindingProviderSeverity) -> Self {
            self.severity = Some(input);
            self
        }
        /// <p>The severity of a finding.</p>
        pub fn set_severity(
            mut self,
            input: std::option::Option<crate::model::FindingProviderSeverity>,
        ) -> Self {
            self.severity = input;
            self
        }
        /// Appends an item to `types`.
        ///
        /// To override the contents of this collection use [`set_types`](Self::set_types).
        ///
        /// <p>One or more finding types in the format of <code>namespace/category/classifier</code> that classify a finding.</p>
        /// <p>Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual Behaviors | Sensitive Data Identifications</p>
        pub fn types(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.types.unwrap_or_default();
            v.push(input.into());
            self.types = Some(v);
            self
        }
        /// <p>One or more finding types in the format of <code>namespace/category/classifier</code> that classify a finding.</p>
        /// <p>Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual Behaviors | Sensitive Data Identifications</p>
        pub fn set_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.types = input;
            self
        }
        /// Consumes the builder and constructs a [`FindingProviderFields`](crate::model::FindingProviderFields)
        pub fn build(self) -> crate::model::FindingProviderFields {
            crate::model::FindingProviderFields {
                confidence: self.confidence.unwrap_or_default(),
                criticality: self.criticality.unwrap_or_default(),
                related_findings: self.related_findings,
                severity: self.severity,
                types: self.types,
            }
        }
    }
}
impl FindingProviderFields {
    /// Creates a new builder-style object to manufacture [`FindingProviderFields`](crate::model::FindingProviderFields)
    pub fn builder() -> crate::model::finding_provider_fields::Builder {
        crate::model::finding_provider_fields::Builder::default()
    }
}

/// <p>The severity assigned to the finding by the finding provider.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FindingProviderSeverity {
    /// <p>The severity label assigned to the finding by the finding provider.</p>
    pub label: std::option::Option<crate::model::SeverityLabel>,
    /// <p>The finding provider's original value for the severity.</p>
    pub original: std::option::Option<std::string::String>,
}
impl FindingProviderSeverity {
    /// <p>The severity label assigned to the finding by the finding provider.</p>
    pub fn label(&self) -> std::option::Option<&crate::model::SeverityLabel> {
        self.label.as_ref()
    }
    /// <p>The finding provider's original value for the severity.</p>
    pub fn original(&self) -> std::option::Option<&str> {
        self.original.as_deref()
    }
}
impl std::fmt::Debug for FindingProviderSeverity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FindingProviderSeverity");
        formatter.field("label", &self.label);
        formatter.field("original", &self.original);
        formatter.finish()
    }
}
/// See [`FindingProviderSeverity`](crate::model::FindingProviderSeverity)
pub mod finding_provider_severity {

    /// A builder for [`FindingProviderSeverity`](crate::model::FindingProviderSeverity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) label: std::option::Option<crate::model::SeverityLabel>,
        pub(crate) original: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The severity label assigned to the finding by the finding provider.</p>
        pub fn label(mut self, input: crate::model::SeverityLabel) -> Self {
            self.label = Some(input);
            self
        }
        /// <p>The severity label assigned to the finding by the finding provider.</p>
        pub fn set_label(
            mut self,
            input: std::option::Option<crate::model::SeverityLabel>,
        ) -> Self {
            self.label = input;
            self
        }
        /// <p>The finding provider's original value for the severity.</p>
        pub fn original(mut self, input: impl Into<std::string::String>) -> Self {
            self.original = Some(input.into());
            self
        }
        /// <p>The finding provider's original value for the severity.</p>
        pub fn set_original(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.original = input;
            self
        }
        /// Consumes the builder and constructs a [`FindingProviderSeverity`](crate::model::FindingProviderSeverity)
        pub fn build(self) -> crate::model::FindingProviderSeverity {
            crate::model::FindingProviderSeverity {
                label: self.label,
                original: self.original,
            }
        }
    }
}
impl FindingProviderSeverity {
    /// Creates a new builder-style object to manufacture [`FindingProviderSeverity`](crate::model::FindingProviderSeverity)
    pub fn builder() -> crate::model::finding_provider_severity::Builder {
        crate::model::finding_provider_severity::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SeverityLabel {
    #[allow(missing_docs)] // documentation missing in model
    Critical,
    #[allow(missing_docs)] // documentation missing in model
    High,
    #[allow(missing_docs)] // documentation missing in model
    Informational,
    #[allow(missing_docs)] // documentation missing in model
    Low,
    #[allow(missing_docs)] // documentation missing in model
    Medium,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SeverityLabel {
    fn from(s: &str) -> Self {
        match s {
            "CRITICAL" => SeverityLabel::Critical,
            "HIGH" => SeverityLabel::High,
            "INFORMATIONAL" => SeverityLabel::Informational,
            "LOW" => SeverityLabel::Low,
            "MEDIUM" => SeverityLabel::Medium,
            other => SeverityLabel::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SeverityLabel {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SeverityLabel::from(s))
    }
}
impl SeverityLabel {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SeverityLabel::Critical => "CRITICAL",
            SeverityLabel::High => "HIGH",
            SeverityLabel::Informational => "INFORMATIONAL",
            SeverityLabel::Low => "LOW",
            SeverityLabel::Medium => "MEDIUM",
            SeverityLabel::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CRITICAL", "HIGH", "INFORMATIONAL", "LOW", "MEDIUM"]
    }
}
impl AsRef<str> for SeverityLabel {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Details about a related finding.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RelatedFinding {
    /// <p>The ARN of the product that generated a related finding.</p>
    pub product_arn: std::option::Option<std::string::String>,
    /// <p>The product-generated identifier for a related finding.</p>
    pub id: std::option::Option<std::string::String>,
}
impl RelatedFinding {
    /// <p>The ARN of the product that generated a related finding.</p>
    pub fn product_arn(&self) -> std::option::Option<&str> {
        self.product_arn.as_deref()
    }
    /// <p>The product-generated identifier for a related finding.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
}
impl std::fmt::Debug for RelatedFinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RelatedFinding");
        formatter.field("product_arn", &self.product_arn);
        formatter.field("id", &self.id);
        formatter.finish()
    }
}
/// See [`RelatedFinding`](crate::model::RelatedFinding)
pub mod related_finding {

    /// A builder for [`RelatedFinding`](crate::model::RelatedFinding)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) product_arn: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the product that generated a related finding.</p>
        pub fn product_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.product_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the product that generated a related finding.</p>
        pub fn set_product_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product_arn = input;
            self
        }
        /// <p>The product-generated identifier for a related finding.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The product-generated identifier for a related finding.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`RelatedFinding`](crate::model::RelatedFinding)
        pub fn build(self) -> crate::model::RelatedFinding {
            crate::model::RelatedFinding {
                product_arn: self.product_arn,
                id: self.id,
            }
        }
    }
}
impl RelatedFinding {
    /// Creates a new builder-style object to manufacture [`RelatedFinding`](crate::model::RelatedFinding)
    pub fn builder() -> crate::model::related_finding::Builder {
        crate::model::related_finding::Builder::default()
    }
}

/// <p>Provides details about one of the following actions that affects or that was taken on a resource:</p>
/// <ul>
/// <li> <p>A remote IP address issued an Amazon Web Services API call</p> </li>
/// <li> <p>A DNS request was received</p> </li>
/// <li> <p>A remote IP address attempted to connect to an EC2 instance</p> </li>
/// <li> <p>A remote IP address attempted a port probe on an EC2 instance</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Action {
    /// <p>The type of action that was detected. The possible action types are:</p>
    /// <ul>
    /// <li> <p> <code>NETWORK_CONNECTION</code> </p> </li>
    /// <li> <p> <code>AWS_API_CALL</code> </p> </li>
    /// <li> <p> <code>DNS_REQUEST</code> </p> </li>
    /// <li> <p> <code>PORT_PROBE</code> </p> </li>
    /// </ul>
    pub action_type: std::option::Option<std::string::String>,
    /// <p>Included if <code>ActionType</code> is <code>NETWORK_CONNECTION</code>. Provides details about the network connection that was detected.</p>
    pub network_connection_action: std::option::Option<crate::model::NetworkConnectionAction>,
    /// <p>Included if <code>ActionType</code> is <code>AWS_API_CALL</code>. Provides details about the API call that was detected. </p>
    pub aws_api_call_action: std::option::Option<crate::model::AwsApiCallAction>,
    /// <p>Included if <code>ActionType</code> is <code>DNS_REQUEST</code>. Provides details about the DNS request that was detected. </p>
    pub dns_request_action: std::option::Option<crate::model::DnsRequestAction>,
    /// <p>Included if <code>ActionType</code> is <code>PORT_PROBE</code>. Provides details about the port probe that was detected. </p>
    pub port_probe_action: std::option::Option<crate::model::PortProbeAction>,
}
impl Action {
    /// <p>The type of action that was detected. The possible action types are:</p>
    /// <ul>
    /// <li> <p> <code>NETWORK_CONNECTION</code> </p> </li>
    /// <li> <p> <code>AWS_API_CALL</code> </p> </li>
    /// <li> <p> <code>DNS_REQUEST</code> </p> </li>
    /// <li> <p> <code>PORT_PROBE</code> </p> </li>
    /// </ul>
    pub fn action_type(&self) -> std::option::Option<&str> {
        self.action_type.as_deref()
    }
    /// <p>Included if <code>ActionType</code> is <code>NETWORK_CONNECTION</code>. Provides details about the network connection that was detected.</p>
    pub fn network_connection_action(
        &self,
    ) -> std::option::Option<&crate::model::NetworkConnectionAction> {
        self.network_connection_action.as_ref()
    }
    /// <p>Included if <code>ActionType</code> is <code>AWS_API_CALL</code>. Provides details about the API call that was detected. </p>
    pub fn aws_api_call_action(&self) -> std::option::Option<&crate::model::AwsApiCallAction> {
        self.aws_api_call_action.as_ref()
    }
    /// <p>Included if <code>ActionType</code> is <code>DNS_REQUEST</code>. Provides details about the DNS request that was detected. </p>
    pub fn dns_request_action(&self) -> std::option::Option<&crate::model::DnsRequestAction> {
        self.dns_request_action.as_ref()
    }
    /// <p>Included if <code>ActionType</code> is <code>PORT_PROBE</code>. Provides details about the port probe that was detected. </p>
    pub fn port_probe_action(&self) -> std::option::Option<&crate::model::PortProbeAction> {
        self.port_probe_action.as_ref()
    }
}
impl std::fmt::Debug for Action {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Action");
        formatter.field("action_type", &self.action_type);
        formatter.field("network_connection_action", &self.network_connection_action);
        formatter.field("aws_api_call_action", &self.aws_api_call_action);
        formatter.field("dns_request_action", &self.dns_request_action);
        formatter.field("port_probe_action", &self.port_probe_action);
        formatter.finish()
    }
}
/// See [`Action`](crate::model::Action)
pub mod action {

    /// A builder for [`Action`](crate::model::Action)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action_type: std::option::Option<std::string::String>,
        pub(crate) network_connection_action:
            std::option::Option<crate::model::NetworkConnectionAction>,
        pub(crate) aws_api_call_action: std::option::Option<crate::model::AwsApiCallAction>,
        pub(crate) dns_request_action: std::option::Option<crate::model::DnsRequestAction>,
        pub(crate) port_probe_action: std::option::Option<crate::model::PortProbeAction>,
    }
    impl Builder {
        /// <p>The type of action that was detected. The possible action types are:</p>
        /// <ul>
        /// <li> <p> <code>NETWORK_CONNECTION</code> </p> </li>
        /// <li> <p> <code>AWS_API_CALL</code> </p> </li>
        /// <li> <p> <code>DNS_REQUEST</code> </p> </li>
        /// <li> <p> <code>PORT_PROBE</code> </p> </li>
        /// </ul>
        pub fn action_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_type = Some(input.into());
            self
        }
        /// <p>The type of action that was detected. The possible action types are:</p>
        /// <ul>
        /// <li> <p> <code>NETWORK_CONNECTION</code> </p> </li>
        /// <li> <p> <code>AWS_API_CALL</code> </p> </li>
        /// <li> <p> <code>DNS_REQUEST</code> </p> </li>
        /// <li> <p> <code>PORT_PROBE</code> </p> </li>
        /// </ul>
        pub fn set_action_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_type = input;
            self
        }
        /// <p>Included if <code>ActionType</code> is <code>NETWORK_CONNECTION</code>. Provides details about the network connection that was detected.</p>
        pub fn network_connection_action(
            mut self,
            input: crate::model::NetworkConnectionAction,
        ) -> Self {
            self.network_connection_action = Some(input);
            self
        }
        /// <p>Included if <code>ActionType</code> is <code>NETWORK_CONNECTION</code>. Provides details about the network connection that was detected.</p>
        pub fn set_network_connection_action(
            mut self,
            input: std::option::Option<crate::model::NetworkConnectionAction>,
        ) -> Self {
            self.network_connection_action = input;
            self
        }
        /// <p>Included if <code>ActionType</code> is <code>AWS_API_CALL</code>. Provides details about the API call that was detected. </p>
        pub fn aws_api_call_action(mut self, input: crate::model::AwsApiCallAction) -> Self {
            self.aws_api_call_action = Some(input);
            self
        }
        /// <p>Included if <code>ActionType</code> is <code>AWS_API_CALL</code>. Provides details about the API call that was detected. </p>
        pub fn set_aws_api_call_action(
            mut self,
            input: std::option::Option<crate::model::AwsApiCallAction>,
        ) -> Self {
            self.aws_api_call_action = input;
            self
        }
        /// <p>Included if <code>ActionType</code> is <code>DNS_REQUEST</code>. Provides details about the DNS request that was detected. </p>
        pub fn dns_request_action(mut self, input: crate::model::DnsRequestAction) -> Self {
            self.dns_request_action = Some(input);
            self
        }
        /// <p>Included if <code>ActionType</code> is <code>DNS_REQUEST</code>. Provides details about the DNS request that was detected. </p>
        pub fn set_dns_request_action(
            mut self,
            input: std::option::Option<crate::model::DnsRequestAction>,
        ) -> Self {
            self.dns_request_action = input;
            self
        }
        /// <p>Included if <code>ActionType</code> is <code>PORT_PROBE</code>. Provides details about the port probe that was detected. </p>
        pub fn port_probe_action(mut self, input: crate::model::PortProbeAction) -> Self {
            self.port_probe_action = Some(input);
            self
        }
        /// <p>Included if <code>ActionType</code> is <code>PORT_PROBE</code>. Provides details about the port probe that was detected. </p>
        pub fn set_port_probe_action(
            mut self,
            input: std::option::Option<crate::model::PortProbeAction>,
        ) -> Self {
            self.port_probe_action = input;
            self
        }
        /// Consumes the builder and constructs a [`Action`](crate::model::Action)
        pub fn build(self) -> crate::model::Action {
            crate::model::Action {
                action_type: self.action_type,
                network_connection_action: self.network_connection_action,
                aws_api_call_action: self.aws_api_call_action,
                dns_request_action: self.dns_request_action,
                port_probe_action: self.port_probe_action,
            }
        }
    }
}
impl Action {
    /// Creates a new builder-style object to manufacture [`Action`](crate::model::Action)
    pub fn builder() -> crate::model::action::Builder {
        crate::model::action::Builder::default()
    }
}

/// <p>Provided if <code>ActionType</code> is <code>PORT_PROBE</code>. It provides details about the attempted port probe that was detected.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PortProbeAction {
    /// <p>Information about the ports affected by the port probe.</p>
    pub port_probe_details: std::option::Option<std::vec::Vec<crate::model::PortProbeDetail>>,
    /// <p>Indicates whether the port probe was blocked.</p>
    pub blocked: bool,
}
impl PortProbeAction {
    /// <p>Information about the ports affected by the port probe.</p>
    pub fn port_probe_details(&self) -> std::option::Option<&[crate::model::PortProbeDetail]> {
        self.port_probe_details.as_deref()
    }
    /// <p>Indicates whether the port probe was blocked.</p>
    pub fn blocked(&self) -> bool {
        self.blocked
    }
}
impl std::fmt::Debug for PortProbeAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PortProbeAction");
        formatter.field("port_probe_details", &self.port_probe_details);
        formatter.field("blocked", &self.blocked);
        formatter.finish()
    }
}
/// See [`PortProbeAction`](crate::model::PortProbeAction)
pub mod port_probe_action {

    /// A builder for [`PortProbeAction`](crate::model::PortProbeAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) port_probe_details:
            std::option::Option<std::vec::Vec<crate::model::PortProbeDetail>>,
        pub(crate) blocked: std::option::Option<bool>,
    }
    impl Builder {
        /// Appends an item to `port_probe_details`.
        ///
        /// To override the contents of this collection use [`set_port_probe_details`](Self::set_port_probe_details).
        ///
        /// <p>Information about the ports affected by the port probe.</p>
        pub fn port_probe_details(mut self, input: crate::model::PortProbeDetail) -> Self {
            let mut v = self.port_probe_details.unwrap_or_default();
            v.push(input);
            self.port_probe_details = Some(v);
            self
        }
        /// <p>Information about the ports affected by the port probe.</p>
        pub fn set_port_probe_details(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PortProbeDetail>>,
        ) -> Self {
            self.port_probe_details = input;
            self
        }
        /// <p>Indicates whether the port probe was blocked.</p>
        pub fn blocked(mut self, input: bool) -> Self {
            self.blocked = Some(input);
            self
        }
        /// <p>Indicates whether the port probe was blocked.</p>
        pub fn set_blocked(mut self, input: std::option::Option<bool>) -> Self {
            self.blocked = input;
            self
        }
        /// Consumes the builder and constructs a [`PortProbeAction`](crate::model::PortProbeAction)
        pub fn build(self) -> crate::model::PortProbeAction {
            crate::model::PortProbeAction {
                port_probe_details: self.port_probe_details,
                blocked: self.blocked.unwrap_or_default(),
            }
        }
    }
}
impl PortProbeAction {
    /// Creates a new builder-style object to manufacture [`PortProbeAction`](crate::model::PortProbeAction)
    pub fn builder() -> crate::model::port_probe_action::Builder {
        crate::model::port_probe_action::Builder::default()
    }
}

/// <p>A port scan that was part of the port probe. For each scan, PortProbeDetails provides information about the local IP address and port that were scanned, and the remote IP address that the scan originated from.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PortProbeDetail {
    /// <p>Provides information about the port that was scanned.</p>
    pub local_port_details: std::option::Option<crate::model::ActionLocalPortDetails>,
    /// <p>Provides information about the IP address where the scanned port is located.</p>
    pub local_ip_details: std::option::Option<crate::model::ActionLocalIpDetails>,
    /// <p>Provides information about the remote IP address that performed the scan.</p>
    pub remote_ip_details: std::option::Option<crate::model::ActionRemoteIpDetails>,
}
impl PortProbeDetail {
    /// <p>Provides information about the port that was scanned.</p>
    pub fn local_port_details(&self) -> std::option::Option<&crate::model::ActionLocalPortDetails> {
        self.local_port_details.as_ref()
    }
    /// <p>Provides information about the IP address where the scanned port is located.</p>
    pub fn local_ip_details(&self) -> std::option::Option<&crate::model::ActionLocalIpDetails> {
        self.local_ip_details.as_ref()
    }
    /// <p>Provides information about the remote IP address that performed the scan.</p>
    pub fn remote_ip_details(&self) -> std::option::Option<&crate::model::ActionRemoteIpDetails> {
        self.remote_ip_details.as_ref()
    }
}
impl std::fmt::Debug for PortProbeDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PortProbeDetail");
        formatter.field("local_port_details", &self.local_port_details);
        formatter.field("local_ip_details", &self.local_ip_details);
        formatter.field("remote_ip_details", &self.remote_ip_details);
        formatter.finish()
    }
}
/// See [`PortProbeDetail`](crate::model::PortProbeDetail)
pub mod port_probe_detail {

    /// A builder for [`PortProbeDetail`](crate::model::PortProbeDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) local_port_details: std::option::Option<crate::model::ActionLocalPortDetails>,
        pub(crate) local_ip_details: std::option::Option<crate::model::ActionLocalIpDetails>,
        pub(crate) remote_ip_details: std::option::Option<crate::model::ActionRemoteIpDetails>,
    }
    impl Builder {
        /// <p>Provides information about the port that was scanned.</p>
        pub fn local_port_details(mut self, input: crate::model::ActionLocalPortDetails) -> Self {
            self.local_port_details = Some(input);
            self
        }
        /// <p>Provides information about the port that was scanned.</p>
        pub fn set_local_port_details(
            mut self,
            input: std::option::Option<crate::model::ActionLocalPortDetails>,
        ) -> Self {
            self.local_port_details = input;
            self
        }
        /// <p>Provides information about the IP address where the scanned port is located.</p>
        pub fn local_ip_details(mut self, input: crate::model::ActionLocalIpDetails) -> Self {
            self.local_ip_details = Some(input);
            self
        }
        /// <p>Provides information about the IP address where the scanned port is located.</p>
        pub fn set_local_ip_details(
            mut self,
            input: std::option::Option<crate::model::ActionLocalIpDetails>,
        ) -> Self {
            self.local_ip_details = input;
            self
        }
        /// <p>Provides information about the remote IP address that performed the scan.</p>
        pub fn remote_ip_details(mut self, input: crate::model::ActionRemoteIpDetails) -> Self {
            self.remote_ip_details = Some(input);
            self
        }
        /// <p>Provides information about the remote IP address that performed the scan.</p>
        pub fn set_remote_ip_details(
            mut self,
            input: std::option::Option<crate::model::ActionRemoteIpDetails>,
        ) -> Self {
            self.remote_ip_details = input;
            self
        }
        /// Consumes the builder and constructs a [`PortProbeDetail`](crate::model::PortProbeDetail)
        pub fn build(self) -> crate::model::PortProbeDetail {
            crate::model::PortProbeDetail {
                local_port_details: self.local_port_details,
                local_ip_details: self.local_ip_details,
                remote_ip_details: self.remote_ip_details,
            }
        }
    }
}
impl PortProbeDetail {
    /// Creates a new builder-style object to manufacture [`PortProbeDetail`](crate::model::PortProbeDetail)
    pub fn builder() -> crate::model::port_probe_detail::Builder {
        crate::model::port_probe_detail::Builder::default()
    }
}

/// <p>For <code>AwsApiAction</code>, <code>NetworkConnectionAction</code>, and <code>PortProbeAction</code>, <code>RemoteIpDetails</code> provides information about the remote IP address that was involved in the action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ActionRemoteIpDetails {
    /// <p>The IP address.</p>
    pub ip_address_v4: std::option::Option<std::string::String>,
    /// <p>The internet service provider (ISP) organization associated with the remote IP address.</p>
    pub organization: std::option::Option<crate::model::IpOrganizationDetails>,
    /// <p>The country where the remote IP address is located.</p>
    pub country: std::option::Option<crate::model::Country>,
    /// <p>The city where the remote IP address is located.</p>
    pub city: std::option::Option<crate::model::City>,
    /// <p>The coordinates of the location of the remote IP address.</p>
    pub geo_location: std::option::Option<crate::model::GeoLocation>,
}
impl ActionRemoteIpDetails {
    /// <p>The IP address.</p>
    pub fn ip_address_v4(&self) -> std::option::Option<&str> {
        self.ip_address_v4.as_deref()
    }
    /// <p>The internet service provider (ISP) organization associated with the remote IP address.</p>
    pub fn organization(&self) -> std::option::Option<&crate::model::IpOrganizationDetails> {
        self.organization.as_ref()
    }
    /// <p>The country where the remote IP address is located.</p>
    pub fn country(&self) -> std::option::Option<&crate::model::Country> {
        self.country.as_ref()
    }
    /// <p>The city where the remote IP address is located.</p>
    pub fn city(&self) -> std::option::Option<&crate::model::City> {
        self.city.as_ref()
    }
    /// <p>The coordinates of the location of the remote IP address.</p>
    pub fn geo_location(&self) -> std::option::Option<&crate::model::GeoLocation> {
        self.geo_location.as_ref()
    }
}
impl std::fmt::Debug for ActionRemoteIpDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ActionRemoteIpDetails");
        formatter.field("ip_address_v4", &self.ip_address_v4);
        formatter.field("organization", &self.organization);
        formatter.field("country", &self.country);
        formatter.field("city", &self.city);
        formatter.field("geo_location", &self.geo_location);
        formatter.finish()
    }
}
/// See [`ActionRemoteIpDetails`](crate::model::ActionRemoteIpDetails)
pub mod action_remote_ip_details {

    /// A builder for [`ActionRemoteIpDetails`](crate::model::ActionRemoteIpDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ip_address_v4: std::option::Option<std::string::String>,
        pub(crate) organization: std::option::Option<crate::model::IpOrganizationDetails>,
        pub(crate) country: std::option::Option<crate::model::Country>,
        pub(crate) city: std::option::Option<crate::model::City>,
        pub(crate) geo_location: std::option::Option<crate::model::GeoLocation>,
    }
    impl Builder {
        /// <p>The IP address.</p>
        pub fn ip_address_v4(mut self, input: impl Into<std::string::String>) -> Self {
            self.ip_address_v4 = Some(input.into());
            self
        }
        /// <p>The IP address.</p>
        pub fn set_ip_address_v4(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ip_address_v4 = input;
            self
        }
        /// <p>The internet service provider (ISP) organization associated with the remote IP address.</p>
        pub fn organization(mut self, input: crate::model::IpOrganizationDetails) -> Self {
            self.organization = Some(input);
            self
        }
        /// <p>The internet service provider (ISP) organization associated with the remote IP address.</p>
        pub fn set_organization(
            mut self,
            input: std::option::Option<crate::model::IpOrganizationDetails>,
        ) -> Self {
            self.organization = input;
            self
        }
        /// <p>The country where the remote IP address is located.</p>
        pub fn country(mut self, input: crate::model::Country) -> Self {
            self.country = Some(input);
            self
        }
        /// <p>The country where the remote IP address is located.</p>
        pub fn set_country(mut self, input: std::option::Option<crate::model::Country>) -> Self {
            self.country = input;
            self
        }
        /// <p>The city where the remote IP address is located.</p>
        pub fn city(mut self, input: crate::model::City) -> Self {
            self.city = Some(input);
            self
        }
        /// <p>The city where the remote IP address is located.</p>
        pub fn set_city(mut self, input: std::option::Option<crate::model::City>) -> Self {
            self.city = input;
            self
        }
        /// <p>The coordinates of the location of the remote IP address.</p>
        pub fn geo_location(mut self, input: crate::model::GeoLocation) -> Self {
            self.geo_location = Some(input);
            self
        }
        /// <p>The coordinates of the location of the remote IP address.</p>
        pub fn set_geo_location(
            mut self,
            input: std::option::Option<crate::model::GeoLocation>,
        ) -> Self {
            self.geo_location = input;
            self
        }
        /// Consumes the builder and constructs a [`ActionRemoteIpDetails`](crate::model::ActionRemoteIpDetails)
        pub fn build(self) -> crate::model::ActionRemoteIpDetails {
            crate::model::ActionRemoteIpDetails {
                ip_address_v4: self.ip_address_v4,
                organization: self.organization,
                country: self.country,
                city: self.city,
                geo_location: self.geo_location,
            }
        }
    }
}
impl ActionRemoteIpDetails {
    /// Creates a new builder-style object to manufacture [`ActionRemoteIpDetails`](crate::model::ActionRemoteIpDetails)
    pub fn builder() -> crate::model::action_remote_ip_details::Builder {
        crate::model::action_remote_ip_details::Builder::default()
    }
}

/// <p>Provides the latitude and longitude coordinates of a location.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GeoLocation {
    /// <p>The longitude of the location.</p>
    pub lon: f64,
    /// <p>The latitude of the location.</p>
    pub lat: f64,
}
impl GeoLocation {
    /// <p>The longitude of the location.</p>
    pub fn lon(&self) -> f64 {
        self.lon
    }
    /// <p>The latitude of the location.</p>
    pub fn lat(&self) -> f64 {
        self.lat
    }
}
impl std::fmt::Debug for GeoLocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GeoLocation");
        formatter.field("lon", &self.lon);
        formatter.field("lat", &self.lat);
        formatter.finish()
    }
}
/// See [`GeoLocation`](crate::model::GeoLocation)
pub mod geo_location {

    /// A builder for [`GeoLocation`](crate::model::GeoLocation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lon: std::option::Option<f64>,
        pub(crate) lat: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The longitude of the location.</p>
        pub fn lon(mut self, input: f64) -> Self {
            self.lon = Some(input);
            self
        }
        /// <p>The longitude of the location.</p>
        pub fn set_lon(mut self, input: std::option::Option<f64>) -> Self {
            self.lon = input;
            self
        }
        /// <p>The latitude of the location.</p>
        pub fn lat(mut self, input: f64) -> Self {
            self.lat = Some(input);
            self
        }
        /// <p>The latitude of the location.</p>
        pub fn set_lat(mut self, input: std::option::Option<f64>) -> Self {
            self.lat = input;
            self
        }
        /// Consumes the builder and constructs a [`GeoLocation`](crate::model::GeoLocation)
        pub fn build(self) -> crate::model::GeoLocation {
            crate::model::GeoLocation {
                lon: self.lon.unwrap_or_default(),
                lat: self.lat.unwrap_or_default(),
            }
        }
    }
}
impl GeoLocation {
    /// Creates a new builder-style object to manufacture [`GeoLocation`](crate::model::GeoLocation)
    pub fn builder() -> crate::model::geo_location::Builder {
        crate::model::geo_location::Builder::default()
    }
}

/// <p>Information about a city.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct City {
    /// <p>The name of the city.</p>
    pub city_name: std::option::Option<std::string::String>,
}
impl City {
    /// <p>The name of the city.</p>
    pub fn city_name(&self) -> std::option::Option<&str> {
        self.city_name.as_deref()
    }
}
impl std::fmt::Debug for City {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("City");
        formatter.field("city_name", &self.city_name);
        formatter.finish()
    }
}
/// See [`City`](crate::model::City)
pub mod city {

    /// A builder for [`City`](crate::model::City)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) city_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the city.</p>
        pub fn city_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.city_name = Some(input.into());
            self
        }
        /// <p>The name of the city.</p>
        pub fn set_city_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.city_name = input;
            self
        }
        /// Consumes the builder and constructs a [`City`](crate::model::City)
        pub fn build(self) -> crate::model::City {
            crate::model::City {
                city_name: self.city_name,
            }
        }
    }
}
impl City {
    /// Creates a new builder-style object to manufacture [`City`](crate::model::City)
    pub fn builder() -> crate::model::city::Builder {
        crate::model::city::Builder::default()
    }
}

/// <p>Information about a country.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Country {
    /// <p>The 2-letter ISO 3166 country code for the country.</p>
    pub country_code: std::option::Option<std::string::String>,
    /// <p>The name of the country.</p>
    pub country_name: std::option::Option<std::string::String>,
}
impl Country {
    /// <p>The 2-letter ISO 3166 country code for the country.</p>
    pub fn country_code(&self) -> std::option::Option<&str> {
        self.country_code.as_deref()
    }
    /// <p>The name of the country.</p>
    pub fn country_name(&self) -> std::option::Option<&str> {
        self.country_name.as_deref()
    }
}
impl std::fmt::Debug for Country {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Country");
        formatter.field("country_code", &self.country_code);
        formatter.field("country_name", &self.country_name);
        formatter.finish()
    }
}
/// See [`Country`](crate::model::Country)
pub mod country {

    /// A builder for [`Country`](crate::model::Country)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) country_code: std::option::Option<std::string::String>,
        pub(crate) country_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The 2-letter ISO 3166 country code for the country.</p>
        pub fn country_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.country_code = Some(input.into());
            self
        }
        /// <p>The 2-letter ISO 3166 country code for the country.</p>
        pub fn set_country_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.country_code = input;
            self
        }
        /// <p>The name of the country.</p>
        pub fn country_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.country_name = Some(input.into());
            self
        }
        /// <p>The name of the country.</p>
        pub fn set_country_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.country_name = input;
            self
        }
        /// Consumes the builder and constructs a [`Country`](crate::model::Country)
        pub fn build(self) -> crate::model::Country {
            crate::model::Country {
                country_code: self.country_code,
                country_name: self.country_name,
            }
        }
    }
}
impl Country {
    /// Creates a new builder-style object to manufacture [`Country`](crate::model::Country)
    pub fn builder() -> crate::model::country::Builder {
        crate::model::country::Builder::default()
    }
}

/// <p>Provides information about an internet provider.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IpOrganizationDetails {
    /// <p>The Autonomous System Number (ASN) of the internet provider</p>
    pub asn: i32,
    /// <p>The name of the organization that registered the ASN.</p>
    pub asn_org: std::option::Option<std::string::String>,
    /// <p>The ISP information for the internet provider.</p>
    pub isp: std::option::Option<std::string::String>,
    /// <p>The name of the internet provider.</p>
    pub org: std::option::Option<std::string::String>,
}
impl IpOrganizationDetails {
    /// <p>The Autonomous System Number (ASN) of the internet provider</p>
    pub fn asn(&self) -> i32 {
        self.asn
    }
    /// <p>The name of the organization that registered the ASN.</p>
    pub fn asn_org(&self) -> std::option::Option<&str> {
        self.asn_org.as_deref()
    }
    /// <p>The ISP information for the internet provider.</p>
    pub fn isp(&self) -> std::option::Option<&str> {
        self.isp.as_deref()
    }
    /// <p>The name of the internet provider.</p>
    pub fn org(&self) -> std::option::Option<&str> {
        self.org.as_deref()
    }
}
impl std::fmt::Debug for IpOrganizationDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IpOrganizationDetails");
        formatter.field("asn", &self.asn);
        formatter.field("asn_org", &self.asn_org);
        formatter.field("isp", &self.isp);
        formatter.field("org", &self.org);
        formatter.finish()
    }
}
/// See [`IpOrganizationDetails`](crate::model::IpOrganizationDetails)
pub mod ip_organization_details {

    /// A builder for [`IpOrganizationDetails`](crate::model::IpOrganizationDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) asn: std::option::Option<i32>,
        pub(crate) asn_org: std::option::Option<std::string::String>,
        pub(crate) isp: std::option::Option<std::string::String>,
        pub(crate) org: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Autonomous System Number (ASN) of the internet provider</p>
        pub fn asn(mut self, input: i32) -> Self {
            self.asn = Some(input);
            self
        }
        /// <p>The Autonomous System Number (ASN) of the internet provider</p>
        pub fn set_asn(mut self, input: std::option::Option<i32>) -> Self {
            self.asn = input;
            self
        }
        /// <p>The name of the organization that registered the ASN.</p>
        pub fn asn_org(mut self, input: impl Into<std::string::String>) -> Self {
            self.asn_org = Some(input.into());
            self
        }
        /// <p>The name of the organization that registered the ASN.</p>
        pub fn set_asn_org(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asn_org = input;
            self
        }
        /// <p>The ISP information for the internet provider.</p>
        pub fn isp(mut self, input: impl Into<std::string::String>) -> Self {
            self.isp = Some(input.into());
            self
        }
        /// <p>The ISP information for the internet provider.</p>
        pub fn set_isp(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.isp = input;
            self
        }
        /// <p>The name of the internet provider.</p>
        pub fn org(mut self, input: impl Into<std::string::String>) -> Self {
            self.org = Some(input.into());
            self
        }
        /// <p>The name of the internet provider.</p>
        pub fn set_org(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.org = input;
            self
        }
        /// Consumes the builder and constructs a [`IpOrganizationDetails`](crate::model::IpOrganizationDetails)
        pub fn build(self) -> crate::model::IpOrganizationDetails {
            crate::model::IpOrganizationDetails {
                asn: self.asn.unwrap_or_default(),
                asn_org: self.asn_org,
                isp: self.isp,
                org: self.org,
            }
        }
    }
}
impl IpOrganizationDetails {
    /// Creates a new builder-style object to manufacture [`IpOrganizationDetails`](crate::model::IpOrganizationDetails)
    pub fn builder() -> crate::model::ip_organization_details::Builder {
        crate::model::ip_organization_details::Builder::default()
    }
}

/// <p>Provides information about the IP address where the scanned port is located.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ActionLocalIpDetails {
    /// <p>The IP address.</p>
    pub ip_address_v4: std::option::Option<std::string::String>,
}
impl ActionLocalIpDetails {
    /// <p>The IP address.</p>
    pub fn ip_address_v4(&self) -> std::option::Option<&str> {
        self.ip_address_v4.as_deref()
    }
}
impl std::fmt::Debug for ActionLocalIpDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ActionLocalIpDetails");
        formatter.field("ip_address_v4", &self.ip_address_v4);
        formatter.finish()
    }
}
/// See [`ActionLocalIpDetails`](crate::model::ActionLocalIpDetails)
pub mod action_local_ip_details {

    /// A builder for [`ActionLocalIpDetails`](crate::model::ActionLocalIpDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ip_address_v4: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IP address.</p>
        pub fn ip_address_v4(mut self, input: impl Into<std::string::String>) -> Self {
            self.ip_address_v4 = Some(input.into());
            self
        }
        /// <p>The IP address.</p>
        pub fn set_ip_address_v4(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ip_address_v4 = input;
            self
        }
        /// Consumes the builder and constructs a [`ActionLocalIpDetails`](crate::model::ActionLocalIpDetails)
        pub fn build(self) -> crate::model::ActionLocalIpDetails {
            crate::model::ActionLocalIpDetails {
                ip_address_v4: self.ip_address_v4,
            }
        }
    }
}
impl ActionLocalIpDetails {
    /// Creates a new builder-style object to manufacture [`ActionLocalIpDetails`](crate::model::ActionLocalIpDetails)
    pub fn builder() -> crate::model::action_local_ip_details::Builder {
        crate::model::action_local_ip_details::Builder::default()
    }
}

/// <p>For <code>NetworkConnectionAction</code> and <code>PortProbeDetails</code>, <code>LocalPortDetails</code> provides information about the local port that was involved in the action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ActionLocalPortDetails {
    /// <p>The number of the port.</p>
    pub port: i32,
    /// <p>The port name of the local connection.</p>
    pub port_name: std::option::Option<std::string::String>,
}
impl ActionLocalPortDetails {
    /// <p>The number of the port.</p>
    pub fn port(&self) -> i32 {
        self.port
    }
    /// <p>The port name of the local connection.</p>
    pub fn port_name(&self) -> std::option::Option<&str> {
        self.port_name.as_deref()
    }
}
impl std::fmt::Debug for ActionLocalPortDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ActionLocalPortDetails");
        formatter.field("port", &self.port);
        formatter.field("port_name", &self.port_name);
        formatter.finish()
    }
}
/// See [`ActionLocalPortDetails`](crate::model::ActionLocalPortDetails)
pub mod action_local_port_details {

    /// A builder for [`ActionLocalPortDetails`](crate::model::ActionLocalPortDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) port: std::option::Option<i32>,
        pub(crate) port_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The number of the port.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>The number of the port.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// <p>The port name of the local connection.</p>
        pub fn port_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.port_name = Some(input.into());
            self
        }
        /// <p>The port name of the local connection.</p>
        pub fn set_port_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.port_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ActionLocalPortDetails`](crate::model::ActionLocalPortDetails)
        pub fn build(self) -> crate::model::ActionLocalPortDetails {
            crate::model::ActionLocalPortDetails {
                port: self.port.unwrap_or_default(),
                port_name: self.port_name,
            }
        }
    }
}
impl ActionLocalPortDetails {
    /// Creates a new builder-style object to manufacture [`ActionLocalPortDetails`](crate::model::ActionLocalPortDetails)
    pub fn builder() -> crate::model::action_local_port_details::Builder {
        crate::model::action_local_port_details::Builder::default()
    }
}

/// <p>Provided if <code>ActionType</code> is <code>DNS_REQUEST</code>. It provides details about the DNS request that was detected.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DnsRequestAction {
    /// <p>The DNS domain that is associated with the DNS request.</p>
    pub domain: std::option::Option<std::string::String>,
    /// <p>The protocol that was used for the DNS request.</p>
    pub protocol: std::option::Option<std::string::String>,
    /// <p>Indicates whether the DNS request was blocked.</p>
    pub blocked: bool,
}
impl DnsRequestAction {
    /// <p>The DNS domain that is associated with the DNS request.</p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p>The protocol that was used for the DNS request.</p>
    pub fn protocol(&self) -> std::option::Option<&str> {
        self.protocol.as_deref()
    }
    /// <p>Indicates whether the DNS request was blocked.</p>
    pub fn blocked(&self) -> bool {
        self.blocked
    }
}
impl std::fmt::Debug for DnsRequestAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DnsRequestAction");
        formatter.field("domain", &self.domain);
        formatter.field("protocol", &self.protocol);
        formatter.field("blocked", &self.blocked);
        formatter.finish()
    }
}
/// See [`DnsRequestAction`](crate::model::DnsRequestAction)
pub mod dns_request_action {

    /// A builder for [`DnsRequestAction`](crate::model::DnsRequestAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) protocol: std::option::Option<std::string::String>,
        pub(crate) blocked: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The DNS domain that is associated with the DNS request.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p>The DNS domain that is associated with the DNS request.</p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p>The protocol that was used for the DNS request.</p>
        pub fn protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.protocol = Some(input.into());
            self
        }
        /// <p>The protocol that was used for the DNS request.</p>
        pub fn set_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.protocol = input;
            self
        }
        /// <p>Indicates whether the DNS request was blocked.</p>
        pub fn blocked(mut self, input: bool) -> Self {
            self.blocked = Some(input);
            self
        }
        /// <p>Indicates whether the DNS request was blocked.</p>
        pub fn set_blocked(mut self, input: std::option::Option<bool>) -> Self {
            self.blocked = input;
            self
        }
        /// Consumes the builder and constructs a [`DnsRequestAction`](crate::model::DnsRequestAction)
        pub fn build(self) -> crate::model::DnsRequestAction {
            crate::model::DnsRequestAction {
                domain: self.domain,
                protocol: self.protocol,
                blocked: self.blocked.unwrap_or_default(),
            }
        }
    }
}
impl DnsRequestAction {
    /// Creates a new builder-style object to manufacture [`DnsRequestAction`](crate::model::DnsRequestAction)
    pub fn builder() -> crate::model::dns_request_action::Builder {
        crate::model::dns_request_action::Builder::default()
    }
}

/// <p>Provided if <code>ActionType</code> is <code>AWS_API_CALL</code>. It provides details about the API call that was detected.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsApiCallAction {
    /// <p>The name of the API method that was issued.</p>
    pub api: std::option::Option<std::string::String>,
    /// <p>The name of the Amazon Web Services service that the API method belongs to.</p>
    pub service_name: std::option::Option<std::string::String>,
    /// <p>Indicates whether the API call originated from a remote IP address (<code>remoteip</code>) or from a DNS domain (<code>domain</code>).</p>
    pub caller_type: std::option::Option<std::string::String>,
    /// <p>Provided if <code>CallerType</code> is <code>remoteIp</code>. Provides information about the remote IP address that the API call originated from.</p>
    pub remote_ip_details: std::option::Option<crate::model::ActionRemoteIpDetails>,
    /// <p>Provided if <code>CallerType</code> is <code>domain</code>. Provides information about the DNS domain that the API call originated from.</p>
    pub domain_details: std::option::Option<crate::model::AwsApiCallActionDomainDetails>,
    /// <p>Identifies the resources that were affected by the API call.</p>
    pub affected_resources:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>An ISO8601-formatted timestamp that indicates when the API call was first observed.</p>
    pub first_seen: std::option::Option<std::string::String>,
    /// <p>An ISO8601-formatted timestamp that indicates when the API call was most recently observed.</p>
    pub last_seen: std::option::Option<std::string::String>,
}
impl AwsApiCallAction {
    /// <p>The name of the API method that was issued.</p>
    pub fn api(&self) -> std::option::Option<&str> {
        self.api.as_deref()
    }
    /// <p>The name of the Amazon Web Services service that the API method belongs to.</p>
    pub fn service_name(&self) -> std::option::Option<&str> {
        self.service_name.as_deref()
    }
    /// <p>Indicates whether the API call originated from a remote IP address (<code>remoteip</code>) or from a DNS domain (<code>domain</code>).</p>
    pub fn caller_type(&self) -> std::option::Option<&str> {
        self.caller_type.as_deref()
    }
    /// <p>Provided if <code>CallerType</code> is <code>remoteIp</code>. Provides information about the remote IP address that the API call originated from.</p>
    pub fn remote_ip_details(&self) -> std::option::Option<&crate::model::ActionRemoteIpDetails> {
        self.remote_ip_details.as_ref()
    }
    /// <p>Provided if <code>CallerType</code> is <code>domain</code>. Provides information about the DNS domain that the API call originated from.</p>
    pub fn domain_details(
        &self,
    ) -> std::option::Option<&crate::model::AwsApiCallActionDomainDetails> {
        self.domain_details.as_ref()
    }
    /// <p>Identifies the resources that were affected by the API call.</p>
    pub fn affected_resources(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.affected_resources.as_ref()
    }
    /// <p>An ISO8601-formatted timestamp that indicates when the API call was first observed.</p>
    pub fn first_seen(&self) -> std::option::Option<&str> {
        self.first_seen.as_deref()
    }
    /// <p>An ISO8601-formatted timestamp that indicates when the API call was most recently observed.</p>
    pub fn last_seen(&self) -> std::option::Option<&str> {
        self.last_seen.as_deref()
    }
}
impl std::fmt::Debug for AwsApiCallAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsApiCallAction");
        formatter.field("api", &self.api);
        formatter.field("service_name", &self.service_name);
        formatter.field("caller_type", &self.caller_type);
        formatter.field("remote_ip_details", &self.remote_ip_details);
        formatter.field("domain_details", &self.domain_details);
        formatter.field("affected_resources", &self.affected_resources);
        formatter.field("first_seen", &self.first_seen);
        formatter.field("last_seen", &self.last_seen);
        formatter.finish()
    }
}
/// See [`AwsApiCallAction`](crate::model::AwsApiCallAction)
pub mod aws_api_call_action {

    /// A builder for [`AwsApiCallAction`](crate::model::AwsApiCallAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) api: std::option::Option<std::string::String>,
        pub(crate) service_name: std::option::Option<std::string::String>,
        pub(crate) caller_type: std::option::Option<std::string::String>,
        pub(crate) remote_ip_details: std::option::Option<crate::model::ActionRemoteIpDetails>,
        pub(crate) domain_details: std::option::Option<crate::model::AwsApiCallActionDomainDetails>,
        pub(crate) affected_resources: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) first_seen: std::option::Option<std::string::String>,
        pub(crate) last_seen: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the API method that was issued.</p>
        pub fn api(mut self, input: impl Into<std::string::String>) -> Self {
            self.api = Some(input.into());
            self
        }
        /// <p>The name of the API method that was issued.</p>
        pub fn set_api(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.api = input;
            self
        }
        /// <p>The name of the Amazon Web Services service that the API method belongs to.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_name = Some(input.into());
            self
        }
        /// <p>The name of the Amazon Web Services service that the API method belongs to.</p>
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_name = input;
            self
        }
        /// <p>Indicates whether the API call originated from a remote IP address (<code>remoteip</code>) or from a DNS domain (<code>domain</code>).</p>
        pub fn caller_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.caller_type = Some(input.into());
            self
        }
        /// <p>Indicates whether the API call originated from a remote IP address (<code>remoteip</code>) or from a DNS domain (<code>domain</code>).</p>
        pub fn set_caller_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.caller_type = input;
            self
        }
        /// <p>Provided if <code>CallerType</code> is <code>remoteIp</code>. Provides information about the remote IP address that the API call originated from.</p>
        pub fn remote_ip_details(mut self, input: crate::model::ActionRemoteIpDetails) -> Self {
            self.remote_ip_details = Some(input);
            self
        }
        /// <p>Provided if <code>CallerType</code> is <code>remoteIp</code>. Provides information about the remote IP address that the API call originated from.</p>
        pub fn set_remote_ip_details(
            mut self,
            input: std::option::Option<crate::model::ActionRemoteIpDetails>,
        ) -> Self {
            self.remote_ip_details = input;
            self
        }
        /// <p>Provided if <code>CallerType</code> is <code>domain</code>. Provides information about the DNS domain that the API call originated from.</p>
        pub fn domain_details(
            mut self,
            input: crate::model::AwsApiCallActionDomainDetails,
        ) -> Self {
            self.domain_details = Some(input);
            self
        }
        /// <p>Provided if <code>CallerType</code> is <code>domain</code>. Provides information about the DNS domain that the API call originated from.</p>
        pub fn set_domain_details(
            mut self,
            input: std::option::Option<crate::model::AwsApiCallActionDomainDetails>,
        ) -> Self {
            self.domain_details = input;
            self
        }
        /// Adds a key-value pair to `affected_resources`.
        ///
        /// To override the contents of this collection use [`set_affected_resources`](Self::set_affected_resources).
        ///
        /// <p>Identifies the resources that were affected by the API call.</p>
        pub fn affected_resources(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.affected_resources.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.affected_resources = Some(hash_map);
            self
        }
        /// <p>Identifies the resources that were affected by the API call.</p>
        pub fn set_affected_resources(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.affected_resources = input;
            self
        }
        /// <p>An ISO8601-formatted timestamp that indicates when the API call was first observed.</p>
        pub fn first_seen(mut self, input: impl Into<std::string::String>) -> Self {
            self.first_seen = Some(input.into());
            self
        }
        /// <p>An ISO8601-formatted timestamp that indicates when the API call was first observed.</p>
        pub fn set_first_seen(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.first_seen = input;
            self
        }
        /// <p>An ISO8601-formatted timestamp that indicates when the API call was most recently observed.</p>
        pub fn last_seen(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_seen = Some(input.into());
            self
        }
        /// <p>An ISO8601-formatted timestamp that indicates when the API call was most recently observed.</p>
        pub fn set_last_seen(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.last_seen = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsApiCallAction`](crate::model::AwsApiCallAction)
        pub fn build(self) -> crate::model::AwsApiCallAction {
            crate::model::AwsApiCallAction {
                api: self.api,
                service_name: self.service_name,
                caller_type: self.caller_type,
                remote_ip_details: self.remote_ip_details,
                domain_details: self.domain_details,
                affected_resources: self.affected_resources,
                first_seen: self.first_seen,
                last_seen: self.last_seen,
            }
        }
    }
}
impl AwsApiCallAction {
    /// Creates a new builder-style object to manufacture [`AwsApiCallAction`](crate::model::AwsApiCallAction)
    pub fn builder() -> crate::model::aws_api_call_action::Builder {
        crate::model::aws_api_call_action::Builder::default()
    }
}

/// <p>Provided if <code>CallerType</code> is <code>domain</code>. It provides information about the DNS domain that issued the API call.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsApiCallActionDomainDetails {
    /// <p>The name of the DNS domain that issued the API call.</p>
    pub domain: std::option::Option<std::string::String>,
}
impl AwsApiCallActionDomainDetails {
    /// <p>The name of the DNS domain that issued the API call.</p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
}
impl std::fmt::Debug for AwsApiCallActionDomainDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsApiCallActionDomainDetails");
        formatter.field("domain", &self.domain);
        formatter.finish()
    }
}
/// See [`AwsApiCallActionDomainDetails`](crate::model::AwsApiCallActionDomainDetails)
pub mod aws_api_call_action_domain_details {

    /// A builder for [`AwsApiCallActionDomainDetails`](crate::model::AwsApiCallActionDomainDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the DNS domain that issued the API call.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p>The name of the DNS domain that issued the API call.</p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsApiCallActionDomainDetails`](crate::model::AwsApiCallActionDomainDetails)
        pub fn build(self) -> crate::model::AwsApiCallActionDomainDetails {
            crate::model::AwsApiCallActionDomainDetails {
                domain: self.domain,
            }
        }
    }
}
impl AwsApiCallActionDomainDetails {
    /// Creates a new builder-style object to manufacture [`AwsApiCallActionDomainDetails`](crate::model::AwsApiCallActionDomainDetails)
    pub fn builder() -> crate::model::aws_api_call_action_domain_details::Builder {
        crate::model::aws_api_call_action_domain_details::Builder::default()
    }
}

/// <p>Provided if <code>ActionType</code> is <code>NETWORK_CONNECTION</code>. It provides details about the attempted network connection that was detected.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkConnectionAction {
    /// <p>The direction of the network connection request (<code>IN</code> or <code>OUT</code>).</p>
    pub connection_direction: std::option::Option<std::string::String>,
    /// <p>Information about the remote IP address that issued the network connection request.</p>
    pub remote_ip_details: std::option::Option<crate::model::ActionRemoteIpDetails>,
    /// <p>Information about the port on the remote IP address.</p>
    pub remote_port_details: std::option::Option<crate::model::ActionRemotePortDetails>,
    /// <p>Information about the port on the EC2 instance.</p>
    pub local_port_details: std::option::Option<crate::model::ActionLocalPortDetails>,
    /// <p>The protocol used to make the network connection request.</p>
    pub protocol: std::option::Option<std::string::String>,
    /// <p>Indicates whether the network connection attempt was blocked.</p>
    pub blocked: bool,
}
impl NetworkConnectionAction {
    /// <p>The direction of the network connection request (<code>IN</code> or <code>OUT</code>).</p>
    pub fn connection_direction(&self) -> std::option::Option<&str> {
        self.connection_direction.as_deref()
    }
    /// <p>Information about the remote IP address that issued the network connection request.</p>
    pub fn remote_ip_details(&self) -> std::option::Option<&crate::model::ActionRemoteIpDetails> {
        self.remote_ip_details.as_ref()
    }
    /// <p>Information about the port on the remote IP address.</p>
    pub fn remote_port_details(
        &self,
    ) -> std::option::Option<&crate::model::ActionRemotePortDetails> {
        self.remote_port_details.as_ref()
    }
    /// <p>Information about the port on the EC2 instance.</p>
    pub fn local_port_details(&self) -> std::option::Option<&crate::model::ActionLocalPortDetails> {
        self.local_port_details.as_ref()
    }
    /// <p>The protocol used to make the network connection request.</p>
    pub fn protocol(&self) -> std::option::Option<&str> {
        self.protocol.as_deref()
    }
    /// <p>Indicates whether the network connection attempt was blocked.</p>
    pub fn blocked(&self) -> bool {
        self.blocked
    }
}
impl std::fmt::Debug for NetworkConnectionAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkConnectionAction");
        formatter.field("connection_direction", &self.connection_direction);
        formatter.field("remote_ip_details", &self.remote_ip_details);
        formatter.field("remote_port_details", &self.remote_port_details);
        formatter.field("local_port_details", &self.local_port_details);
        formatter.field("protocol", &self.protocol);
        formatter.field("blocked", &self.blocked);
        formatter.finish()
    }
}
/// See [`NetworkConnectionAction`](crate::model::NetworkConnectionAction)
pub mod network_connection_action {

    /// A builder for [`NetworkConnectionAction`](crate::model::NetworkConnectionAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connection_direction: std::option::Option<std::string::String>,
        pub(crate) remote_ip_details: std::option::Option<crate::model::ActionRemoteIpDetails>,
        pub(crate) remote_port_details: std::option::Option<crate::model::ActionRemotePortDetails>,
        pub(crate) local_port_details: std::option::Option<crate::model::ActionLocalPortDetails>,
        pub(crate) protocol: std::option::Option<std::string::String>,
        pub(crate) blocked: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The direction of the network connection request (<code>IN</code> or <code>OUT</code>).</p>
        pub fn connection_direction(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_direction = Some(input.into());
            self
        }
        /// <p>The direction of the network connection request (<code>IN</code> or <code>OUT</code>).</p>
        pub fn set_connection_direction(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_direction = input;
            self
        }
        /// <p>Information about the remote IP address that issued the network connection request.</p>
        pub fn remote_ip_details(mut self, input: crate::model::ActionRemoteIpDetails) -> Self {
            self.remote_ip_details = Some(input);
            self
        }
        /// <p>Information about the remote IP address that issued the network connection request.</p>
        pub fn set_remote_ip_details(
            mut self,
            input: std::option::Option<crate::model::ActionRemoteIpDetails>,
        ) -> Self {
            self.remote_ip_details = input;
            self
        }
        /// <p>Information about the port on the remote IP address.</p>
        pub fn remote_port_details(mut self, input: crate::model::ActionRemotePortDetails) -> Self {
            self.remote_port_details = Some(input);
            self
        }
        /// <p>Information about the port on the remote IP address.</p>
        pub fn set_remote_port_details(
            mut self,
            input: std::option::Option<crate::model::ActionRemotePortDetails>,
        ) -> Self {
            self.remote_port_details = input;
            self
        }
        /// <p>Information about the port on the EC2 instance.</p>
        pub fn local_port_details(mut self, input: crate::model::ActionLocalPortDetails) -> Self {
            self.local_port_details = Some(input);
            self
        }
        /// <p>Information about the port on the EC2 instance.</p>
        pub fn set_local_port_details(
            mut self,
            input: std::option::Option<crate::model::ActionLocalPortDetails>,
        ) -> Self {
            self.local_port_details = input;
            self
        }
        /// <p>The protocol used to make the network connection request.</p>
        pub fn protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.protocol = Some(input.into());
            self
        }
        /// <p>The protocol used to make the network connection request.</p>
        pub fn set_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.protocol = input;
            self
        }
        /// <p>Indicates whether the network connection attempt was blocked.</p>
        pub fn blocked(mut self, input: bool) -> Self {
            self.blocked = Some(input);
            self
        }
        /// <p>Indicates whether the network connection attempt was blocked.</p>
        pub fn set_blocked(mut self, input: std::option::Option<bool>) -> Self {
            self.blocked = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkConnectionAction`](crate::model::NetworkConnectionAction)
        pub fn build(self) -> crate::model::NetworkConnectionAction {
            crate::model::NetworkConnectionAction {
                connection_direction: self.connection_direction,
                remote_ip_details: self.remote_ip_details,
                remote_port_details: self.remote_port_details,
                local_port_details: self.local_port_details,
                protocol: self.protocol,
                blocked: self.blocked.unwrap_or_default(),
            }
        }
    }
}
impl NetworkConnectionAction {
    /// Creates a new builder-style object to manufacture [`NetworkConnectionAction`](crate::model::NetworkConnectionAction)
    pub fn builder() -> crate::model::network_connection_action::Builder {
        crate::model::network_connection_action::Builder::default()
    }
}

/// <p>Provides information about the remote port that was involved in an attempted network connection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ActionRemotePortDetails {
    /// <p>The number of the port.</p>
    pub port: i32,
    /// <p>The port name of the remote connection.</p>
    pub port_name: std::option::Option<std::string::String>,
}
impl ActionRemotePortDetails {
    /// <p>The number of the port.</p>
    pub fn port(&self) -> i32 {
        self.port
    }
    /// <p>The port name of the remote connection.</p>
    pub fn port_name(&self) -> std::option::Option<&str> {
        self.port_name.as_deref()
    }
}
impl std::fmt::Debug for ActionRemotePortDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ActionRemotePortDetails");
        formatter.field("port", &self.port);
        formatter.field("port_name", &self.port_name);
        formatter.finish()
    }
}
/// See [`ActionRemotePortDetails`](crate::model::ActionRemotePortDetails)
pub mod action_remote_port_details {

    /// A builder for [`ActionRemotePortDetails`](crate::model::ActionRemotePortDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) port: std::option::Option<i32>,
        pub(crate) port_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The number of the port.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>The number of the port.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// <p>The port name of the remote connection.</p>
        pub fn port_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.port_name = Some(input.into());
            self
        }
        /// <p>The port name of the remote connection.</p>
        pub fn set_port_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.port_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ActionRemotePortDetails`](crate::model::ActionRemotePortDetails)
        pub fn build(self) -> crate::model::ActionRemotePortDetails {
            crate::model::ActionRemotePortDetails {
                port: self.port.unwrap_or_default(),
                port_name: self.port_name,
            }
        }
    }
}
impl ActionRemotePortDetails {
    /// Creates a new builder-style object to manufacture [`ActionRemotePortDetails`](crate::model::ActionRemotePortDetails)
    pub fn builder() -> crate::model::action_remote_port_details::Builder {
        crate::model::action_remote_port_details::Builder::default()
    }
}

/// <p>Provides an overview of the patch compliance status for an instance against a selected compliance standard.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PatchSummary {
    /// <p>The identifier of the compliance standard that was used to determine the patch compliance status.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The number of patches from the compliance standard that were installed successfully.</p>
    pub installed_count: i32,
    /// <p>The number of patches that are part of the compliance standard but are not installed. The count includes patches that failed to install.</p>
    pub missing_count: i32,
    /// <p>The number of patches from the compliance standard that failed to install.</p>
    pub failed_count: i32,
    /// <p>The number of installed patches that are not part of the compliance standard.</p>
    pub installed_other_count: i32,
    /// <p>The number of patches that are installed but are also on a list of patches that the customer rejected.</p>
    pub installed_rejected_count: i32,
    /// <p>The number of patches that were applied, but that require the instance to be rebooted in order to be marked as installed.</p>
    pub installed_pending_reboot: i32,
    /// <p>Indicates when the operation started.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub operation_start_time: std::option::Option<std::string::String>,
    /// <p>Indicates when the operation completed.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub operation_end_time: std::option::Option<std::string::String>,
    /// <p>The reboot option specified for the instance.</p>
    pub reboot_option: std::option::Option<std::string::String>,
    /// <p>The type of patch operation performed. For Patch Manager, the values are <code>SCAN</code> and <code>INSTALL</code>. </p>
    pub operation: std::option::Option<std::string::String>,
}
impl PatchSummary {
    /// <p>The identifier of the compliance standard that was used to determine the patch compliance status.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The number of patches from the compliance standard that were installed successfully.</p>
    pub fn installed_count(&self) -> i32 {
        self.installed_count
    }
    /// <p>The number of patches that are part of the compliance standard but are not installed. The count includes patches that failed to install.</p>
    pub fn missing_count(&self) -> i32 {
        self.missing_count
    }
    /// <p>The number of patches from the compliance standard that failed to install.</p>
    pub fn failed_count(&self) -> i32 {
        self.failed_count
    }
    /// <p>The number of installed patches that are not part of the compliance standard.</p>
    pub fn installed_other_count(&self) -> i32 {
        self.installed_other_count
    }
    /// <p>The number of patches that are installed but are also on a list of patches that the customer rejected.</p>
    pub fn installed_rejected_count(&self) -> i32 {
        self.installed_rejected_count
    }
    /// <p>The number of patches that were applied, but that require the instance to be rebooted in order to be marked as installed.</p>
    pub fn installed_pending_reboot(&self) -> i32 {
        self.installed_pending_reboot
    }
    /// <p>Indicates when the operation started.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn operation_start_time(&self) -> std::option::Option<&str> {
        self.operation_start_time.as_deref()
    }
    /// <p>Indicates when the operation completed.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn operation_end_time(&self) -> std::option::Option<&str> {
        self.operation_end_time.as_deref()
    }
    /// <p>The reboot option specified for the instance.</p>
    pub fn reboot_option(&self) -> std::option::Option<&str> {
        self.reboot_option.as_deref()
    }
    /// <p>The type of patch operation performed. For Patch Manager, the values are <code>SCAN</code> and <code>INSTALL</code>. </p>
    pub fn operation(&self) -> std::option::Option<&str> {
        self.operation.as_deref()
    }
}
impl std::fmt::Debug for PatchSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PatchSummary");
        formatter.field("id", &self.id);
        formatter.field("installed_count", &self.installed_count);
        formatter.field("missing_count", &self.missing_count);
        formatter.field("failed_count", &self.failed_count);
        formatter.field("installed_other_count", &self.installed_other_count);
        formatter.field("installed_rejected_count", &self.installed_rejected_count);
        formatter.field("installed_pending_reboot", &self.installed_pending_reboot);
        formatter.field("operation_start_time", &self.operation_start_time);
        formatter.field("operation_end_time", &self.operation_end_time);
        formatter.field("reboot_option", &self.reboot_option);
        formatter.field("operation", &self.operation);
        formatter.finish()
    }
}
/// See [`PatchSummary`](crate::model::PatchSummary)
pub mod patch_summary {

    /// A builder for [`PatchSummary`](crate::model::PatchSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) installed_count: std::option::Option<i32>,
        pub(crate) missing_count: std::option::Option<i32>,
        pub(crate) failed_count: std::option::Option<i32>,
        pub(crate) installed_other_count: std::option::Option<i32>,
        pub(crate) installed_rejected_count: std::option::Option<i32>,
        pub(crate) installed_pending_reboot: std::option::Option<i32>,
        pub(crate) operation_start_time: std::option::Option<std::string::String>,
        pub(crate) operation_end_time: std::option::Option<std::string::String>,
        pub(crate) reboot_option: std::option::Option<std::string::String>,
        pub(crate) operation: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the compliance standard that was used to determine the patch compliance status.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the compliance standard that was used to determine the patch compliance status.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The number of patches from the compliance standard that were installed successfully.</p>
        pub fn installed_count(mut self, input: i32) -> Self {
            self.installed_count = Some(input);
            self
        }
        /// <p>The number of patches from the compliance standard that were installed successfully.</p>
        pub fn set_installed_count(mut self, input: std::option::Option<i32>) -> Self {
            self.installed_count = input;
            self
        }
        /// <p>The number of patches that are part of the compliance standard but are not installed. The count includes patches that failed to install.</p>
        pub fn missing_count(mut self, input: i32) -> Self {
            self.missing_count = Some(input);
            self
        }
        /// <p>The number of patches that are part of the compliance standard but are not installed. The count includes patches that failed to install.</p>
        pub fn set_missing_count(mut self, input: std::option::Option<i32>) -> Self {
            self.missing_count = input;
            self
        }
        /// <p>The number of patches from the compliance standard that failed to install.</p>
        pub fn failed_count(mut self, input: i32) -> Self {
            self.failed_count = Some(input);
            self
        }
        /// <p>The number of patches from the compliance standard that failed to install.</p>
        pub fn set_failed_count(mut self, input: std::option::Option<i32>) -> Self {
            self.failed_count = input;
            self
        }
        /// <p>The number of installed patches that are not part of the compliance standard.</p>
        pub fn installed_other_count(mut self, input: i32) -> Self {
            self.installed_other_count = Some(input);
            self
        }
        /// <p>The number of installed patches that are not part of the compliance standard.</p>
        pub fn set_installed_other_count(mut self, input: std::option::Option<i32>) -> Self {
            self.installed_other_count = input;
            self
        }
        /// <p>The number of patches that are installed but are also on a list of patches that the customer rejected.</p>
        pub fn installed_rejected_count(mut self, input: i32) -> Self {
            self.installed_rejected_count = Some(input);
            self
        }
        /// <p>The number of patches that are installed but are also on a list of patches that the customer rejected.</p>
        pub fn set_installed_rejected_count(mut self, input: std::option::Option<i32>) -> Self {
            self.installed_rejected_count = input;
            self
        }
        /// <p>The number of patches that were applied, but that require the instance to be rebooted in order to be marked as installed.</p>
        pub fn installed_pending_reboot(mut self, input: i32) -> Self {
            self.installed_pending_reboot = Some(input);
            self
        }
        /// <p>The number of patches that were applied, but that require the instance to be rebooted in order to be marked as installed.</p>
        pub fn set_installed_pending_reboot(mut self, input: std::option::Option<i32>) -> Self {
            self.installed_pending_reboot = input;
            self
        }
        /// <p>Indicates when the operation started.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn operation_start_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.operation_start_time = Some(input.into());
            self
        }
        /// <p>Indicates when the operation started.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_operation_start_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.operation_start_time = input;
            self
        }
        /// <p>Indicates when the operation completed.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn operation_end_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.operation_end_time = Some(input.into());
            self
        }
        /// <p>Indicates when the operation completed.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_operation_end_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.operation_end_time = input;
            self
        }
        /// <p>The reboot option specified for the instance.</p>
        pub fn reboot_option(mut self, input: impl Into<std::string::String>) -> Self {
            self.reboot_option = Some(input.into());
            self
        }
        /// <p>The reboot option specified for the instance.</p>
        pub fn set_reboot_option(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reboot_option = input;
            self
        }
        /// <p>The type of patch operation performed. For Patch Manager, the values are <code>SCAN</code> and <code>INSTALL</code>. </p>
        pub fn operation(mut self, input: impl Into<std::string::String>) -> Self {
            self.operation = Some(input.into());
            self
        }
        /// <p>The type of patch operation performed. For Patch Manager, the values are <code>SCAN</code> and <code>INSTALL</code>. </p>
        pub fn set_operation(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.operation = input;
            self
        }
        /// Consumes the builder and constructs a [`PatchSummary`](crate::model::PatchSummary)
        pub fn build(self) -> crate::model::PatchSummary {
            crate::model::PatchSummary {
                id: self.id,
                installed_count: self.installed_count.unwrap_or_default(),
                missing_count: self.missing_count.unwrap_or_default(),
                failed_count: self.failed_count.unwrap_or_default(),
                installed_other_count: self.installed_other_count.unwrap_or_default(),
                installed_rejected_count: self.installed_rejected_count.unwrap_or_default(),
                installed_pending_reboot: self.installed_pending_reboot.unwrap_or_default(),
                operation_start_time: self.operation_start_time,
                operation_end_time: self.operation_end_time,
                reboot_option: self.reboot_option,
                operation: self.operation,
            }
        }
    }
}
impl PatchSummary {
    /// Creates a new builder-style object to manufacture [`PatchSummary`](crate::model::PatchSummary)
    pub fn builder() -> crate::model::patch_summary::Builder {
        crate::model::patch_summary::Builder::default()
    }
}

/// <p>A vulnerability associated with a finding.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Vulnerability {
    /// <p>The identifier of the vulnerability.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>List of software packages that have the vulnerability.</p>
    pub vulnerable_packages: std::option::Option<std::vec::Vec<crate::model::SoftwarePackage>>,
    /// <p>CVSS scores from the advisory related to the vulnerability.</p>
    pub cvss: std::option::Option<std::vec::Vec<crate::model::Cvss>>,
    /// <p>List of vulnerabilities that are related to this vulnerability.</p>
    pub related_vulnerabilities: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Information about the vendor that generates the vulnerability report.</p>
    pub vendor: std::option::Option<crate::model::VulnerabilityVendor>,
    /// <p>A list of URLs that provide additional information about the vulnerability.</p>
    pub reference_urls: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl Vulnerability {
    /// <p>The identifier of the vulnerability.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>List of software packages that have the vulnerability.</p>
    pub fn vulnerable_packages(&self) -> std::option::Option<&[crate::model::SoftwarePackage]> {
        self.vulnerable_packages.as_deref()
    }
    /// <p>CVSS scores from the advisory related to the vulnerability.</p>
    pub fn cvss(&self) -> std::option::Option<&[crate::model::Cvss]> {
        self.cvss.as_deref()
    }
    /// <p>List of vulnerabilities that are related to this vulnerability.</p>
    pub fn related_vulnerabilities(&self) -> std::option::Option<&[std::string::String]> {
        self.related_vulnerabilities.as_deref()
    }
    /// <p>Information about the vendor that generates the vulnerability report.</p>
    pub fn vendor(&self) -> std::option::Option<&crate::model::VulnerabilityVendor> {
        self.vendor.as_ref()
    }
    /// <p>A list of URLs that provide additional information about the vulnerability.</p>
    pub fn reference_urls(&self) -> std::option::Option<&[std::string::String]> {
        self.reference_urls.as_deref()
    }
}
impl std::fmt::Debug for Vulnerability {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Vulnerability");
        formatter.field("id", &self.id);
        formatter.field("vulnerable_packages", &self.vulnerable_packages);
        formatter.field("cvss", &self.cvss);
        formatter.field("related_vulnerabilities", &self.related_vulnerabilities);
        formatter.field("vendor", &self.vendor);
        formatter.field("reference_urls", &self.reference_urls);
        formatter.finish()
    }
}
/// See [`Vulnerability`](crate::model::Vulnerability)
pub mod vulnerability {

    /// A builder for [`Vulnerability`](crate::model::Vulnerability)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) vulnerable_packages:
            std::option::Option<std::vec::Vec<crate::model::SoftwarePackage>>,
        pub(crate) cvss: std::option::Option<std::vec::Vec<crate::model::Cvss>>,
        pub(crate) related_vulnerabilities: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) vendor: std::option::Option<crate::model::VulnerabilityVendor>,
        pub(crate) reference_urls: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The identifier of the vulnerability.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the vulnerability.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Appends an item to `vulnerable_packages`.
        ///
        /// To override the contents of this collection use [`set_vulnerable_packages`](Self::set_vulnerable_packages).
        ///
        /// <p>List of software packages that have the vulnerability.</p>
        pub fn vulnerable_packages(mut self, input: crate::model::SoftwarePackage) -> Self {
            let mut v = self.vulnerable_packages.unwrap_or_default();
            v.push(input);
            self.vulnerable_packages = Some(v);
            self
        }
        /// <p>List of software packages that have the vulnerability.</p>
        pub fn set_vulnerable_packages(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SoftwarePackage>>,
        ) -> Self {
            self.vulnerable_packages = input;
            self
        }
        /// Appends an item to `cvss`.
        ///
        /// To override the contents of this collection use [`set_cvss`](Self::set_cvss).
        ///
        /// <p>CVSS scores from the advisory related to the vulnerability.</p>
        pub fn cvss(mut self, input: crate::model::Cvss) -> Self {
            let mut v = self.cvss.unwrap_or_default();
            v.push(input);
            self.cvss = Some(v);
            self
        }
        /// <p>CVSS scores from the advisory related to the vulnerability.</p>
        pub fn set_cvss(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Cvss>>,
        ) -> Self {
            self.cvss = input;
            self
        }
        /// Appends an item to `related_vulnerabilities`.
        ///
        /// To override the contents of this collection use [`set_related_vulnerabilities`](Self::set_related_vulnerabilities).
        ///
        /// <p>List of vulnerabilities that are related to this vulnerability.</p>
        pub fn related_vulnerabilities(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.related_vulnerabilities.unwrap_or_default();
            v.push(input.into());
            self.related_vulnerabilities = Some(v);
            self
        }
        /// <p>List of vulnerabilities that are related to this vulnerability.</p>
        pub fn set_related_vulnerabilities(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.related_vulnerabilities = input;
            self
        }
        /// <p>Information about the vendor that generates the vulnerability report.</p>
        pub fn vendor(mut self, input: crate::model::VulnerabilityVendor) -> Self {
            self.vendor = Some(input);
            self
        }
        /// <p>Information about the vendor that generates the vulnerability report.</p>
        pub fn set_vendor(
            mut self,
            input: std::option::Option<crate::model::VulnerabilityVendor>,
        ) -> Self {
            self.vendor = input;
            self
        }
        /// Appends an item to `reference_urls`.
        ///
        /// To override the contents of this collection use [`set_reference_urls`](Self::set_reference_urls).
        ///
        /// <p>A list of URLs that provide additional information about the vulnerability.</p>
        pub fn reference_urls(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.reference_urls.unwrap_or_default();
            v.push(input.into());
            self.reference_urls = Some(v);
            self
        }
        /// <p>A list of URLs that provide additional information about the vulnerability.</p>
        pub fn set_reference_urls(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.reference_urls = input;
            self
        }
        /// Consumes the builder and constructs a [`Vulnerability`](crate::model::Vulnerability)
        pub fn build(self) -> crate::model::Vulnerability {
            crate::model::Vulnerability {
                id: self.id,
                vulnerable_packages: self.vulnerable_packages,
                cvss: self.cvss,
                related_vulnerabilities: self.related_vulnerabilities,
                vendor: self.vendor,
                reference_urls: self.reference_urls,
            }
        }
    }
}
impl Vulnerability {
    /// Creates a new builder-style object to manufacture [`Vulnerability`](crate::model::Vulnerability)
    pub fn builder() -> crate::model::vulnerability::Builder {
        crate::model::vulnerability::Builder::default()
    }
}

/// <p>A vendor that generates a vulnerability report.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VulnerabilityVendor {
    /// <p>The name of the vendor.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The URL of the vulnerability advisory.</p>
    pub url: std::option::Option<std::string::String>,
    /// <p>The severity that the vendor assigned to the vulnerability.</p>
    pub vendor_severity: std::option::Option<std::string::String>,
    /// <p>Indicates when the vulnerability advisory was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub vendor_created_at: std::option::Option<std::string::String>,
    /// <p>Indicates when the vulnerability advisory was last updated.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub vendor_updated_at: std::option::Option<std::string::String>,
}
impl VulnerabilityVendor {
    /// <p>The name of the vendor.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The URL of the vulnerability advisory.</p>
    pub fn url(&self) -> std::option::Option<&str> {
        self.url.as_deref()
    }
    /// <p>The severity that the vendor assigned to the vulnerability.</p>
    pub fn vendor_severity(&self) -> std::option::Option<&str> {
        self.vendor_severity.as_deref()
    }
    /// <p>Indicates when the vulnerability advisory was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn vendor_created_at(&self) -> std::option::Option<&str> {
        self.vendor_created_at.as_deref()
    }
    /// <p>Indicates when the vulnerability advisory was last updated.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn vendor_updated_at(&self) -> std::option::Option<&str> {
        self.vendor_updated_at.as_deref()
    }
}
impl std::fmt::Debug for VulnerabilityVendor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VulnerabilityVendor");
        formatter.field("name", &self.name);
        formatter.field("url", &self.url);
        formatter.field("vendor_severity", &self.vendor_severity);
        formatter.field("vendor_created_at", &self.vendor_created_at);
        formatter.field("vendor_updated_at", &self.vendor_updated_at);
        formatter.finish()
    }
}
/// See [`VulnerabilityVendor`](crate::model::VulnerabilityVendor)
pub mod vulnerability_vendor {

    /// A builder for [`VulnerabilityVendor`](crate::model::VulnerabilityVendor)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) url: std::option::Option<std::string::String>,
        pub(crate) vendor_severity: std::option::Option<std::string::String>,
        pub(crate) vendor_created_at: std::option::Option<std::string::String>,
        pub(crate) vendor_updated_at: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the vendor.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the vendor.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The URL of the vulnerability advisory.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        /// <p>The URL of the vulnerability advisory.</p>
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// <p>The severity that the vendor assigned to the vulnerability.</p>
        pub fn vendor_severity(mut self, input: impl Into<std::string::String>) -> Self {
            self.vendor_severity = Some(input.into());
            self
        }
        /// <p>The severity that the vendor assigned to the vulnerability.</p>
        pub fn set_vendor_severity(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vendor_severity = input;
            self
        }
        /// <p>Indicates when the vulnerability advisory was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn vendor_created_at(mut self, input: impl Into<std::string::String>) -> Self {
            self.vendor_created_at = Some(input.into());
            self
        }
        /// <p>Indicates when the vulnerability advisory was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_vendor_created_at(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vendor_created_at = input;
            self
        }
        /// <p>Indicates when the vulnerability advisory was last updated.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn vendor_updated_at(mut self, input: impl Into<std::string::String>) -> Self {
            self.vendor_updated_at = Some(input.into());
            self
        }
        /// <p>Indicates when the vulnerability advisory was last updated.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_vendor_updated_at(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vendor_updated_at = input;
            self
        }
        /// Consumes the builder and constructs a [`VulnerabilityVendor`](crate::model::VulnerabilityVendor)
        pub fn build(self) -> crate::model::VulnerabilityVendor {
            crate::model::VulnerabilityVendor {
                name: self.name,
                url: self.url,
                vendor_severity: self.vendor_severity,
                vendor_created_at: self.vendor_created_at,
                vendor_updated_at: self.vendor_updated_at,
            }
        }
    }
}
impl VulnerabilityVendor {
    /// Creates a new builder-style object to manufacture [`VulnerabilityVendor`](crate::model::VulnerabilityVendor)
    pub fn builder() -> crate::model::vulnerability_vendor::Builder {
        crate::model::vulnerability_vendor::Builder::default()
    }
}

/// <p>CVSS scores from the advisory related to the vulnerability.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Cvss {
    /// <p>The version of CVSS for the CVSS score.</p>
    pub version: std::option::Option<std::string::String>,
    /// <p>The base CVSS score.</p>
    pub base_score: f64,
    /// <p>The base scoring vector for the CVSS score.</p>
    pub base_vector: std::option::Option<std::string::String>,
    /// <p>The origin of the original CVSS score and vector.</p>
    pub source: std::option::Option<std::string::String>,
    /// <p>Adjustments to the CVSS metrics.</p>
    pub adjustments: std::option::Option<std::vec::Vec<crate::model::Adjustment>>,
}
impl Cvss {
    /// <p>The version of CVSS for the CVSS score.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
    /// <p>The base CVSS score.</p>
    pub fn base_score(&self) -> f64 {
        self.base_score
    }
    /// <p>The base scoring vector for the CVSS score.</p>
    pub fn base_vector(&self) -> std::option::Option<&str> {
        self.base_vector.as_deref()
    }
    /// <p>The origin of the original CVSS score and vector.</p>
    pub fn source(&self) -> std::option::Option<&str> {
        self.source.as_deref()
    }
    /// <p>Adjustments to the CVSS metrics.</p>
    pub fn adjustments(&self) -> std::option::Option<&[crate::model::Adjustment]> {
        self.adjustments.as_deref()
    }
}
impl std::fmt::Debug for Cvss {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Cvss");
        formatter.field("version", &self.version);
        formatter.field("base_score", &self.base_score);
        formatter.field("base_vector", &self.base_vector);
        formatter.field("source", &self.source);
        formatter.field("adjustments", &self.adjustments);
        formatter.finish()
    }
}
/// See [`Cvss`](crate::model::Cvss)
pub mod cvss {

    /// A builder for [`Cvss`](crate::model::Cvss)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) version: std::option::Option<std::string::String>,
        pub(crate) base_score: std::option::Option<f64>,
        pub(crate) base_vector: std::option::Option<std::string::String>,
        pub(crate) source: std::option::Option<std::string::String>,
        pub(crate) adjustments: std::option::Option<std::vec::Vec<crate::model::Adjustment>>,
    }
    impl Builder {
        /// <p>The version of CVSS for the CVSS score.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The version of CVSS for the CVSS score.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// <p>The base CVSS score.</p>
        pub fn base_score(mut self, input: f64) -> Self {
            self.base_score = Some(input);
            self
        }
        /// <p>The base CVSS score.</p>
        pub fn set_base_score(mut self, input: std::option::Option<f64>) -> Self {
            self.base_score = input;
            self
        }
        /// <p>The base scoring vector for the CVSS score.</p>
        pub fn base_vector(mut self, input: impl Into<std::string::String>) -> Self {
            self.base_vector = Some(input.into());
            self
        }
        /// <p>The base scoring vector for the CVSS score.</p>
        pub fn set_base_vector(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.base_vector = input;
            self
        }
        /// <p>The origin of the original CVSS score and vector.</p>
        pub fn source(mut self, input: impl Into<std::string::String>) -> Self {
            self.source = Some(input.into());
            self
        }
        /// <p>The origin of the original CVSS score and vector.</p>
        pub fn set_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source = input;
            self
        }
        /// Appends an item to `adjustments`.
        ///
        /// To override the contents of this collection use [`set_adjustments`](Self::set_adjustments).
        ///
        /// <p>Adjustments to the CVSS metrics.</p>
        pub fn adjustments(mut self, input: crate::model::Adjustment) -> Self {
            let mut v = self.adjustments.unwrap_or_default();
            v.push(input);
            self.adjustments = Some(v);
            self
        }
        /// <p>Adjustments to the CVSS metrics.</p>
        pub fn set_adjustments(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Adjustment>>,
        ) -> Self {
            self.adjustments = input;
            self
        }
        /// Consumes the builder and constructs a [`Cvss`](crate::model::Cvss)
        pub fn build(self) -> crate::model::Cvss {
            crate::model::Cvss {
                version: self.version,
                base_score: self.base_score.unwrap_or_default(),
                base_vector: self.base_vector,
                source: self.source,
                adjustments: self.adjustments,
            }
        }
    }
}
impl Cvss {
    /// Creates a new builder-style object to manufacture [`Cvss`](crate::model::Cvss)
    pub fn builder() -> crate::model::cvss::Builder {
        crate::model::cvss::Builder::default()
    }
}

/// <p>An adjustment to the CVSS metric.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Adjustment {
    /// <p>The metric to adjust.</p>
    pub metric: std::option::Option<std::string::String>,
    /// <p>The reason for the adjustment.</p>
    pub reason: std::option::Option<std::string::String>,
}
impl Adjustment {
    /// <p>The metric to adjust.</p>
    pub fn metric(&self) -> std::option::Option<&str> {
        self.metric.as_deref()
    }
    /// <p>The reason for the adjustment.</p>
    pub fn reason(&self) -> std::option::Option<&str> {
        self.reason.as_deref()
    }
}
impl std::fmt::Debug for Adjustment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Adjustment");
        formatter.field("metric", &self.metric);
        formatter.field("reason", &self.reason);
        formatter.finish()
    }
}
/// See [`Adjustment`](crate::model::Adjustment)
pub mod adjustment {

    /// A builder for [`Adjustment`](crate::model::Adjustment)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric: std::option::Option<std::string::String>,
        pub(crate) reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The metric to adjust.</p>
        pub fn metric(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric = Some(input.into());
            self
        }
        /// <p>The metric to adjust.</p>
        pub fn set_metric(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric = input;
            self
        }
        /// <p>The reason for the adjustment.</p>
        pub fn reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.reason = Some(input.into());
            self
        }
        /// <p>The reason for the adjustment.</p>
        pub fn set_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reason = input;
            self
        }
        /// Consumes the builder and constructs a [`Adjustment`](crate::model::Adjustment)
        pub fn build(self) -> crate::model::Adjustment {
            crate::model::Adjustment {
                metric: self.metric,
                reason: self.reason,
            }
        }
    }
}
impl Adjustment {
    /// Creates a new builder-style object to manufacture [`Adjustment`](crate::model::Adjustment)
    pub fn builder() -> crate::model::adjustment::Builder {
        crate::model::adjustment::Builder::default()
    }
}

/// <p>Information about a software package.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SoftwarePackage {
    /// <p>The name of the software package.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The version of the software package.</p>
    pub version: std::option::Option<std::string::String>,
    /// <p>The epoch of the software package.</p>
    pub epoch: std::option::Option<std::string::String>,
    /// <p>The release of the software package.</p>
    pub release: std::option::Option<std::string::String>,
    /// <p>The architecture used for the software package.</p>
    pub architecture: std::option::Option<std::string::String>,
    /// <p>The source of the package.</p>
    pub package_manager: std::option::Option<std::string::String>,
    /// <p>The file system path to the package manager inventory file.</p>
    pub file_path: std::option::Option<std::string::String>,
}
impl SoftwarePackage {
    /// <p>The name of the software package.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The version of the software package.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
    /// <p>The epoch of the software package.</p>
    pub fn epoch(&self) -> std::option::Option<&str> {
        self.epoch.as_deref()
    }
    /// <p>The release of the software package.</p>
    pub fn release(&self) -> std::option::Option<&str> {
        self.release.as_deref()
    }
    /// <p>The architecture used for the software package.</p>
    pub fn architecture(&self) -> std::option::Option<&str> {
        self.architecture.as_deref()
    }
    /// <p>The source of the package.</p>
    pub fn package_manager(&self) -> std::option::Option<&str> {
        self.package_manager.as_deref()
    }
    /// <p>The file system path to the package manager inventory file.</p>
    pub fn file_path(&self) -> std::option::Option<&str> {
        self.file_path.as_deref()
    }
}
impl std::fmt::Debug for SoftwarePackage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SoftwarePackage");
        formatter.field("name", &self.name);
        formatter.field("version", &self.version);
        formatter.field("epoch", &self.epoch);
        formatter.field("release", &self.release);
        formatter.field("architecture", &self.architecture);
        formatter.field("package_manager", &self.package_manager);
        formatter.field("file_path", &self.file_path);
        formatter.finish()
    }
}
/// See [`SoftwarePackage`](crate::model::SoftwarePackage)
pub mod software_package {

    /// A builder for [`SoftwarePackage`](crate::model::SoftwarePackage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
        pub(crate) epoch: std::option::Option<std::string::String>,
        pub(crate) release: std::option::Option<std::string::String>,
        pub(crate) architecture: std::option::Option<std::string::String>,
        pub(crate) package_manager: std::option::Option<std::string::String>,
        pub(crate) file_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the software package.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the software package.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The version of the software package.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The version of the software package.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// <p>The epoch of the software package.</p>
        pub fn epoch(mut self, input: impl Into<std::string::String>) -> Self {
            self.epoch = Some(input.into());
            self
        }
        /// <p>The epoch of the software package.</p>
        pub fn set_epoch(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.epoch = input;
            self
        }
        /// <p>The release of the software package.</p>
        pub fn release(mut self, input: impl Into<std::string::String>) -> Self {
            self.release = Some(input.into());
            self
        }
        /// <p>The release of the software package.</p>
        pub fn set_release(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.release = input;
            self
        }
        /// <p>The architecture used for the software package.</p>
        pub fn architecture(mut self, input: impl Into<std::string::String>) -> Self {
            self.architecture = Some(input.into());
            self
        }
        /// <p>The architecture used for the software package.</p>
        pub fn set_architecture(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.architecture = input;
            self
        }
        /// <p>The source of the package.</p>
        pub fn package_manager(mut self, input: impl Into<std::string::String>) -> Self {
            self.package_manager = Some(input.into());
            self
        }
        /// <p>The source of the package.</p>
        pub fn set_package_manager(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.package_manager = input;
            self
        }
        /// <p>The file system path to the package manager inventory file.</p>
        pub fn file_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_path = Some(input.into());
            self
        }
        /// <p>The file system path to the package manager inventory file.</p>
        pub fn set_file_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.file_path = input;
            self
        }
        /// Consumes the builder and constructs a [`SoftwarePackage`](crate::model::SoftwarePackage)
        pub fn build(self) -> crate::model::SoftwarePackage {
            crate::model::SoftwarePackage {
                name: self.name,
                version: self.version,
                epoch: self.epoch,
                release: self.release,
                architecture: self.architecture,
                package_manager: self.package_manager,
                file_path: self.file_path,
            }
        }
    }
}
impl SoftwarePackage {
    /// Creates a new builder-style object to manufacture [`SoftwarePackage`](crate::model::SoftwarePackage)
    pub fn builder() -> crate::model::software_package::Builder {
        crate::model::software_package::Builder::default()
    }
}

/// <p>A user-defined note added to a finding.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Note {
    /// <p>The text of a note.</p>
    pub text: std::option::Option<std::string::String>,
    /// <p>The principal that created a note.</p>
    pub updated_by: std::option::Option<std::string::String>,
    /// <p>The timestamp of when the note was updated.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub updated_at: std::option::Option<std::string::String>,
}
impl Note {
    /// <p>The text of a note.</p>
    pub fn text(&self) -> std::option::Option<&str> {
        self.text.as_deref()
    }
    /// <p>The principal that created a note.</p>
    pub fn updated_by(&self) -> std::option::Option<&str> {
        self.updated_by.as_deref()
    }
    /// <p>The timestamp of when the note was updated.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn updated_at(&self) -> std::option::Option<&str> {
        self.updated_at.as_deref()
    }
}
impl std::fmt::Debug for Note {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Note");
        formatter.field("text", &self.text);
        formatter.field("updated_by", &self.updated_by);
        formatter.field("updated_at", &self.updated_at);
        formatter.finish()
    }
}
/// See [`Note`](crate::model::Note)
pub mod note {

    /// A builder for [`Note`](crate::model::Note)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) text: std::option::Option<std::string::String>,
        pub(crate) updated_by: std::option::Option<std::string::String>,
        pub(crate) updated_at: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The text of a note.</p>
        pub fn text(mut self, input: impl Into<std::string::String>) -> Self {
            self.text = Some(input.into());
            self
        }
        /// <p>The text of a note.</p>
        pub fn set_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.text = input;
            self
        }
        /// <p>The principal that created a note.</p>
        pub fn updated_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.updated_by = Some(input.into());
            self
        }
        /// <p>The principal that created a note.</p>
        pub fn set_updated_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.updated_by = input;
            self
        }
        /// <p>The timestamp of when the note was updated.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn updated_at(mut self, input: impl Into<std::string::String>) -> Self {
            self.updated_at = Some(input.into());
            self
        }
        /// <p>The timestamp of when the note was updated.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_updated_at(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.updated_at = input;
            self
        }
        /// Consumes the builder and constructs a [`Note`](crate::model::Note)
        pub fn build(self) -> crate::model::Note {
            crate::model::Note {
                text: self.text,
                updated_by: self.updated_by,
                updated_at: self.updated_at,
            }
        }
    }
}
impl Note {
    /// Creates a new builder-style object to manufacture [`Note`](crate::model::Note)
    pub fn builder() -> crate::model::note::Builder {
        crate::model::note::Builder::default()
    }
}

/// <p>Provides information about the status of the investigation into a finding.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Workflow {
    /// <p>The status of the investigation into the finding. The workflow status is specific to an individual finding. It does not affect the generation of new findings. For example, setting the workflow status to <code>SUPPRESSED</code> or <code>RESOLVED</code> does not prevent a new finding for the same issue.</p>
    /// <p>The allowed values are the following.</p>
    /// <ul>
    /// <li> <p> <code>NEW</code> - The initial state of a finding, before it is reviewed.</p> <p>Security Hub also resets the workflow status from <code>NOTIFIED</code> or <code>RESOLVED</code> to <code>NEW</code> in the following cases:</p>
    /// <ul>
    /// <li> <p> <code>RecordState</code> changes from <code>ARCHIVED</code> to <code>ACTIVE</code>.</p> </li>
    /// <li> <p> <code>ComplianceStatus</code> changes from <code>PASSED</code> to either <code>WARNING</code>, <code>FAILED</code>, or <code>NOT_AVAILABLE</code>.</p> </li>
    /// </ul> </li>
    /// <li> <p> <code>NOTIFIED</code> - Indicates that you notified the resource owner about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner.</p> </li>
    /// <li> <p> <code>SUPPRESSED</code> - Indicates that you reviewed the finding and do not believe that any action is needed. The finding is no longer updated.</p> </li>
    /// <li> <p> <code>RESOLVED</code> - The finding was reviewed and remediated and is now considered resolved. </p> </li>
    /// </ul>
    pub status: std::option::Option<crate::model::WorkflowStatus>,
}
impl Workflow {
    /// <p>The status of the investigation into the finding. The workflow status is specific to an individual finding. It does not affect the generation of new findings. For example, setting the workflow status to <code>SUPPRESSED</code> or <code>RESOLVED</code> does not prevent a new finding for the same issue.</p>
    /// <p>The allowed values are the following.</p>
    /// <ul>
    /// <li> <p> <code>NEW</code> - The initial state of a finding, before it is reviewed.</p> <p>Security Hub also resets the workflow status from <code>NOTIFIED</code> or <code>RESOLVED</code> to <code>NEW</code> in the following cases:</p>
    /// <ul>
    /// <li> <p> <code>RecordState</code> changes from <code>ARCHIVED</code> to <code>ACTIVE</code>.</p> </li>
    /// <li> <p> <code>ComplianceStatus</code> changes from <code>PASSED</code> to either <code>WARNING</code>, <code>FAILED</code>, or <code>NOT_AVAILABLE</code>.</p> </li>
    /// </ul> </li>
    /// <li> <p> <code>NOTIFIED</code> - Indicates that you notified the resource owner about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner.</p> </li>
    /// <li> <p> <code>SUPPRESSED</code> - Indicates that you reviewed the finding and do not believe that any action is needed. The finding is no longer updated.</p> </li>
    /// <li> <p> <code>RESOLVED</code> - The finding was reviewed and remediated and is now considered resolved. </p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::WorkflowStatus> {
        self.status.as_ref()
    }
}
impl std::fmt::Debug for Workflow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Workflow");
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`Workflow`](crate::model::Workflow)
pub mod workflow {

    /// A builder for [`Workflow`](crate::model::Workflow)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::WorkflowStatus>,
    }
    impl Builder {
        /// <p>The status of the investigation into the finding. The workflow status is specific to an individual finding. It does not affect the generation of new findings. For example, setting the workflow status to <code>SUPPRESSED</code> or <code>RESOLVED</code> does not prevent a new finding for the same issue.</p>
        /// <p>The allowed values are the following.</p>
        /// <ul>
        /// <li> <p> <code>NEW</code> - The initial state of a finding, before it is reviewed.</p> <p>Security Hub also resets the workflow status from <code>NOTIFIED</code> or <code>RESOLVED</code> to <code>NEW</code> in the following cases:</p>
        /// <ul>
        /// <li> <p> <code>RecordState</code> changes from <code>ARCHIVED</code> to <code>ACTIVE</code>.</p> </li>
        /// <li> <p> <code>ComplianceStatus</code> changes from <code>PASSED</code> to either <code>WARNING</code>, <code>FAILED</code>, or <code>NOT_AVAILABLE</code>.</p> </li>
        /// </ul> </li>
        /// <li> <p> <code>NOTIFIED</code> - Indicates that you notified the resource owner about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner.</p> </li>
        /// <li> <p> <code>SUPPRESSED</code> - Indicates that you reviewed the finding and do not believe that any action is needed. The finding is no longer updated.</p> </li>
        /// <li> <p> <code>RESOLVED</code> - The finding was reviewed and remediated and is now considered resolved. </p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::WorkflowStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the investigation into the finding. The workflow status is specific to an individual finding. It does not affect the generation of new findings. For example, setting the workflow status to <code>SUPPRESSED</code> or <code>RESOLVED</code> does not prevent a new finding for the same issue.</p>
        /// <p>The allowed values are the following.</p>
        /// <ul>
        /// <li> <p> <code>NEW</code> - The initial state of a finding, before it is reviewed.</p> <p>Security Hub also resets the workflow status from <code>NOTIFIED</code> or <code>RESOLVED</code> to <code>NEW</code> in the following cases:</p>
        /// <ul>
        /// <li> <p> <code>RecordState</code> changes from <code>ARCHIVED</code> to <code>ACTIVE</code>.</p> </li>
        /// <li> <p> <code>ComplianceStatus</code> changes from <code>PASSED</code> to either <code>WARNING</code>, <code>FAILED</code>, or <code>NOT_AVAILABLE</code>.</p> </li>
        /// </ul> </li>
        /// <li> <p> <code>NOTIFIED</code> - Indicates that you notified the resource owner about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner.</p> </li>
        /// <li> <p> <code>SUPPRESSED</code> - Indicates that you reviewed the finding and do not believe that any action is needed. The finding is no longer updated.</p> </li>
        /// <li> <p> <code>RESOLVED</code> - The finding was reviewed and remediated and is now considered resolved. </p> </li>
        /// </ul>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::WorkflowStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`Workflow`](crate::model::Workflow)
        pub fn build(self) -> crate::model::Workflow {
            crate::model::Workflow {
                status: self.status,
            }
        }
    }
}
impl Workflow {
    /// Creates a new builder-style object to manufacture [`Workflow`](crate::model::Workflow)
    pub fn builder() -> crate::model::workflow::Builder {
        crate::model::workflow::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WorkflowStatus {
    #[allow(missing_docs)] // documentation missing in model
    New,
    #[allow(missing_docs)] // documentation missing in model
    Notified,
    #[allow(missing_docs)] // documentation missing in model
    Resolved,
    #[allow(missing_docs)] // documentation missing in model
    Suppressed,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for WorkflowStatus {
    fn from(s: &str) -> Self {
        match s {
            "NEW" => WorkflowStatus::New,
            "NOTIFIED" => WorkflowStatus::Notified,
            "RESOLVED" => WorkflowStatus::Resolved,
            "SUPPRESSED" => WorkflowStatus::Suppressed,
            other => WorkflowStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for WorkflowStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WorkflowStatus::from(s))
    }
}
impl WorkflowStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WorkflowStatus::New => "NEW",
            WorkflowStatus::Notified => "NOTIFIED",
            WorkflowStatus::Resolved => "RESOLVED",
            WorkflowStatus::Suppressed => "SUPPRESSED",
            WorkflowStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["NEW", "NOTIFIED", "RESOLVED", "SUPPRESSED"]
    }
}
impl AsRef<str> for WorkflowStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WorkflowState {
    #[allow(missing_docs)] // documentation missing in model
    Assigned,
    #[allow(missing_docs)] // documentation missing in model
    Deferred,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    New,
    #[allow(missing_docs)] // documentation missing in model
    Resolved,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for WorkflowState {
    fn from(s: &str) -> Self {
        match s {
            "ASSIGNED" => WorkflowState::Assigned,
            "DEFERRED" => WorkflowState::Deferred,
            "IN_PROGRESS" => WorkflowState::InProgress,
            "NEW" => WorkflowState::New,
            "RESOLVED" => WorkflowState::Resolved,
            other => WorkflowState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for WorkflowState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WorkflowState::from(s))
    }
}
impl WorkflowState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WorkflowState::Assigned => "ASSIGNED",
            WorkflowState::Deferred => "DEFERRED",
            WorkflowState::InProgress => "IN_PROGRESS",
            WorkflowState::New => "NEW",
            WorkflowState::Resolved => "RESOLVED",
            WorkflowState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ASSIGNED", "DEFERRED", "IN_PROGRESS", "NEW", "RESOLVED"]
    }
}
impl AsRef<str> for WorkflowState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// _Note: `VerificationState::Unknown` has been renamed to `::UnknownValue`._
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VerificationState {
    #[allow(missing_docs)] // documentation missing in model
    BenignPositive,
    #[allow(missing_docs)] // documentation missing in model
    FalsePositive,
    #[allow(missing_docs)] // documentation missing in model
    TruePositive,
    /// _Note: `::Unknown` has been renamed to `::UnknownValue`._
    UnknownValue,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VerificationState {
    fn from(s: &str) -> Self {
        match s {
            "BENIGN_POSITIVE" => VerificationState::BenignPositive,
            "FALSE_POSITIVE" => VerificationState::FalsePositive,
            "TRUE_POSITIVE" => VerificationState::TruePositive,
            "UNKNOWN" => VerificationState::UnknownValue,
            other => VerificationState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VerificationState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VerificationState::from(s))
    }
}
impl VerificationState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VerificationState::BenignPositive => "BENIGN_POSITIVE",
            VerificationState::FalsePositive => "FALSE_POSITIVE",
            VerificationState::TruePositive => "TRUE_POSITIVE",
            VerificationState::UnknownValue => "UNKNOWN",
            VerificationState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "BENIGN_POSITIVE",
            "FALSE_POSITIVE",
            "TRUE_POSITIVE",
            "UNKNOWN",
        ]
    }
}
impl AsRef<str> for VerificationState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains finding details that are specific to control-based findings. Only returned for findings generated from controls.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Compliance {
    /// <p>The result of a standards check.</p>
    /// <p>The valid values for <code>Status</code> are as follows.</p>
    /// <ul>
    /// <li>
    /// <ul>
    /// <li> <p> <code>PASSED</code> - Standards check passed for all evaluated resources.</p> </li>
    /// <li> <p> <code>WARNING</code> - Some information is missing or this check is not supported for your configuration.</p> </li>
    /// <li> <p> <code>FAILED</code> - Standards check failed for at least one evaluated resource.</p> </li>
    /// <li> <p> <code>NOT_AVAILABLE</code> - Check could not be performed due to a service outage, API error, or because the result of the Config evaluation was <code>NOT_APPLICABLE</code>. If the Config evaluation result was <code>NOT_APPLICABLE</code>, then after 3 days, Security Hub automatically archives the finding.</p> </li>
    /// </ul> </li>
    /// </ul>
    pub status: std::option::Option<crate::model::ComplianceStatus>,
    /// <p>For a control, the industry or regulatory framework requirements that are related to the control. The check for that control is aligned with these requirements.</p>
    pub related_requirements: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>For findings generated from controls, a list of reasons behind the value of <code>Status</code>. For the list of status reason codes and their meanings, see <a href="https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-results.html#securityhub-standards-results-asff">Standards-related information in the ASFF</a> in the <i>Security Hub User Guide</i>. </p>
    pub status_reasons: std::option::Option<std::vec::Vec<crate::model::StatusReason>>,
}
impl Compliance {
    /// <p>The result of a standards check.</p>
    /// <p>The valid values for <code>Status</code> are as follows.</p>
    /// <ul>
    /// <li>
    /// <ul>
    /// <li> <p> <code>PASSED</code> - Standards check passed for all evaluated resources.</p> </li>
    /// <li> <p> <code>WARNING</code> - Some information is missing or this check is not supported for your configuration.</p> </li>
    /// <li> <p> <code>FAILED</code> - Standards check failed for at least one evaluated resource.</p> </li>
    /// <li> <p> <code>NOT_AVAILABLE</code> - Check could not be performed due to a service outage, API error, or because the result of the Config evaluation was <code>NOT_APPLICABLE</code>. If the Config evaluation result was <code>NOT_APPLICABLE</code>, then after 3 days, Security Hub automatically archives the finding.</p> </li>
    /// </ul> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::ComplianceStatus> {
        self.status.as_ref()
    }
    /// <p>For a control, the industry or regulatory framework requirements that are related to the control. The check for that control is aligned with these requirements.</p>
    pub fn related_requirements(&self) -> std::option::Option<&[std::string::String]> {
        self.related_requirements.as_deref()
    }
    /// <p>For findings generated from controls, a list of reasons behind the value of <code>Status</code>. For the list of status reason codes and their meanings, see <a href="https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-results.html#securityhub-standards-results-asff">Standards-related information in the ASFF</a> in the <i>Security Hub User Guide</i>. </p>
    pub fn status_reasons(&self) -> std::option::Option<&[crate::model::StatusReason]> {
        self.status_reasons.as_deref()
    }
}
impl std::fmt::Debug for Compliance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Compliance");
        formatter.field("status", &self.status);
        formatter.field("related_requirements", &self.related_requirements);
        formatter.field("status_reasons", &self.status_reasons);
        formatter.finish()
    }
}
/// See [`Compliance`](crate::model::Compliance)
pub mod compliance {

    /// A builder for [`Compliance`](crate::model::Compliance)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::ComplianceStatus>,
        pub(crate) related_requirements: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) status_reasons: std::option::Option<std::vec::Vec<crate::model::StatusReason>>,
    }
    impl Builder {
        /// <p>The result of a standards check.</p>
        /// <p>The valid values for <code>Status</code> are as follows.</p>
        /// <ul>
        /// <li>
        /// <ul>
        /// <li> <p> <code>PASSED</code> - Standards check passed for all evaluated resources.</p> </li>
        /// <li> <p> <code>WARNING</code> - Some information is missing or this check is not supported for your configuration.</p> </li>
        /// <li> <p> <code>FAILED</code> - Standards check failed for at least one evaluated resource.</p> </li>
        /// <li> <p> <code>NOT_AVAILABLE</code> - Check could not be performed due to a service outage, API error, or because the result of the Config evaluation was <code>NOT_APPLICABLE</code>. If the Config evaluation result was <code>NOT_APPLICABLE</code>, then after 3 days, Security Hub automatically archives the finding.</p> </li>
        /// </ul> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::ComplianceStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The result of a standards check.</p>
        /// <p>The valid values for <code>Status</code> are as follows.</p>
        /// <ul>
        /// <li>
        /// <ul>
        /// <li> <p> <code>PASSED</code> - Standards check passed for all evaluated resources.</p> </li>
        /// <li> <p> <code>WARNING</code> - Some information is missing or this check is not supported for your configuration.</p> </li>
        /// <li> <p> <code>FAILED</code> - Standards check failed for at least one evaluated resource.</p> </li>
        /// <li> <p> <code>NOT_AVAILABLE</code> - Check could not be performed due to a service outage, API error, or because the result of the Config evaluation was <code>NOT_APPLICABLE</code>. If the Config evaluation result was <code>NOT_APPLICABLE</code>, then after 3 days, Security Hub automatically archives the finding.</p> </li>
        /// </ul> </li>
        /// </ul>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ComplianceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Appends an item to `related_requirements`.
        ///
        /// To override the contents of this collection use [`set_related_requirements`](Self::set_related_requirements).
        ///
        /// <p>For a control, the industry or regulatory framework requirements that are related to the control. The check for that control is aligned with these requirements.</p>
        pub fn related_requirements(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.related_requirements.unwrap_or_default();
            v.push(input.into());
            self.related_requirements = Some(v);
            self
        }
        /// <p>For a control, the industry or regulatory framework requirements that are related to the control. The check for that control is aligned with these requirements.</p>
        pub fn set_related_requirements(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.related_requirements = input;
            self
        }
        /// Appends an item to `status_reasons`.
        ///
        /// To override the contents of this collection use [`set_status_reasons`](Self::set_status_reasons).
        ///
        /// <p>For findings generated from controls, a list of reasons behind the value of <code>Status</code>. For the list of status reason codes and their meanings, see <a href="https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-results.html#securityhub-standards-results-asff">Standards-related information in the ASFF</a> in the <i>Security Hub User Guide</i>. </p>
        pub fn status_reasons(mut self, input: crate::model::StatusReason) -> Self {
            let mut v = self.status_reasons.unwrap_or_default();
            v.push(input);
            self.status_reasons = Some(v);
            self
        }
        /// <p>For findings generated from controls, a list of reasons behind the value of <code>Status</code>. For the list of status reason codes and their meanings, see <a href="https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-results.html#securityhub-standards-results-asff">Standards-related information in the ASFF</a> in the <i>Security Hub User Guide</i>. </p>
        pub fn set_status_reasons(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StatusReason>>,
        ) -> Self {
            self.status_reasons = input;
            self
        }
        /// Consumes the builder and constructs a [`Compliance`](crate::model::Compliance)
        pub fn build(self) -> crate::model::Compliance {
            crate::model::Compliance {
                status: self.status,
                related_requirements: self.related_requirements,
                status_reasons: self.status_reasons,
            }
        }
    }
}
impl Compliance {
    /// Creates a new builder-style object to manufacture [`Compliance`](crate::model::Compliance)
    pub fn builder() -> crate::model::compliance::Builder {
        crate::model::compliance::Builder::default()
    }
}

/// <p>Provides additional context for the value of <code>Compliance.Status</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StatusReason {
    /// <p>A code that represents a reason for the control status. For the list of status reason codes and their meanings, see <a href="https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-results.html#securityhub-standards-results-asff">Standards-related information in the ASFF</a> in the <i>Security Hub User Guide</i>. </p>
    pub reason_code: std::option::Option<std::string::String>,
    /// <p>The corresponding description for the status reason code.</p>
    pub description: std::option::Option<std::string::String>,
}
impl StatusReason {
    /// <p>A code that represents a reason for the control status. For the list of status reason codes and their meanings, see <a href="https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-results.html#securityhub-standards-results-asff">Standards-related information in the ASFF</a> in the <i>Security Hub User Guide</i>. </p>
    pub fn reason_code(&self) -> std::option::Option<&str> {
        self.reason_code.as_deref()
    }
    /// <p>The corresponding description for the status reason code.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
impl std::fmt::Debug for StatusReason {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StatusReason");
        formatter.field("reason_code", &self.reason_code);
        formatter.field("description", &self.description);
        formatter.finish()
    }
}
/// See [`StatusReason`](crate::model::StatusReason)
pub mod status_reason {

    /// A builder for [`StatusReason`](crate::model::StatusReason)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reason_code: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A code that represents a reason for the control status. For the list of status reason codes and their meanings, see <a href="https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-results.html#securityhub-standards-results-asff">Standards-related information in the ASFF</a> in the <i>Security Hub User Guide</i>. </p>
        pub fn reason_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.reason_code = Some(input.into());
            self
        }
        /// <p>A code that represents a reason for the control status. For the list of status reason codes and their meanings, see <a href="https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-results.html#securityhub-standards-results-asff">Standards-related information in the ASFF</a> in the <i>Security Hub User Guide</i>. </p>
        pub fn set_reason_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reason_code = input;
            self
        }
        /// <p>The corresponding description for the status reason code.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The corresponding description for the status reason code.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`StatusReason`](crate::model::StatusReason)
        pub fn build(self) -> crate::model::StatusReason {
            crate::model::StatusReason {
                reason_code: self.reason_code,
                description: self.description,
            }
        }
    }
}
impl StatusReason {
    /// Creates a new builder-style object to manufacture [`StatusReason`](crate::model::StatusReason)
    pub fn builder() -> crate::model::status_reason::Builder {
        crate::model::status_reason::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ComplianceStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    NotAvailable,
    #[allow(missing_docs)] // documentation missing in model
    Passed,
    #[allow(missing_docs)] // documentation missing in model
    Warning,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ComplianceStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => ComplianceStatus::Failed,
            "NOT_AVAILABLE" => ComplianceStatus::NotAvailable,
            "PASSED" => ComplianceStatus::Passed,
            "WARNING" => ComplianceStatus::Warning,
            other => ComplianceStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ComplianceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ComplianceStatus::from(s))
    }
}
impl ComplianceStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ComplianceStatus::Failed => "FAILED",
            ComplianceStatus::NotAvailable => "NOT_AVAILABLE",
            ComplianceStatus::Passed => "PASSED",
            ComplianceStatus::Warning => "WARNING",
            ComplianceStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["FAILED", "NOT_AVAILABLE", "PASSED", "WARNING"]
    }
}
impl AsRef<str> for ComplianceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A resource related to a finding.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Resource {
    /// <p>The type of the resource that details are provided for. If possible, set <code>Type</code> to one of the supported resource types. For example, if the resource is an EC2 instance, then set <code>Type</code> to <code>AwsEc2Instance</code>.</p>
    /// <p>If the resource does not match any of the provided types, then set <code>Type</code> to <code>Other</code>. </p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The canonical identifier for the given resource type.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The canonical Amazon Web Services partition name that the Region is assigned to.</p>
    pub partition: std::option::Option<crate::model::Partition>,
    /// <p>The canonical Amazon Web Services external Region name where this resource is located.</p>
    pub region: std::option::Option<std::string::String>,
    /// <p>Identifies the role of the resource in the finding. A resource is either the actor or target of the finding activity,</p>
    pub resource_role: std::option::Option<std::string::String>,
    /// <p>A list of Amazon Web Services tags associated with a resource at the time the finding was processed.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Contains information about sensitive data that was detected on the resource.</p>
    pub data_classification: std::option::Option<crate::model::DataClassificationDetails>,
    /// <p>Additional details about the resource related to a finding.</p>
    pub details: std::option::Option<crate::model::ResourceDetails>,
}
impl Resource {
    /// <p>The type of the resource that details are provided for. If possible, set <code>Type</code> to one of the supported resource types. For example, if the resource is an EC2 instance, then set <code>Type</code> to <code>AwsEc2Instance</code>.</p>
    /// <p>If the resource does not match any of the provided types, then set <code>Type</code> to <code>Other</code>. </p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The canonical identifier for the given resource type.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The canonical Amazon Web Services partition name that the Region is assigned to.</p>
    pub fn partition(&self) -> std::option::Option<&crate::model::Partition> {
        self.partition.as_ref()
    }
    /// <p>The canonical Amazon Web Services external Region name where this resource is located.</p>
    pub fn region(&self) -> std::option::Option<&str> {
        self.region.as_deref()
    }
    /// <p>Identifies the role of the resource in the finding. A resource is either the actor or target of the finding activity,</p>
    pub fn resource_role(&self) -> std::option::Option<&str> {
        self.resource_role.as_deref()
    }
    /// <p>A list of Amazon Web Services tags associated with a resource at the time the finding was processed.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>Contains information about sensitive data that was detected on the resource.</p>
    pub fn data_classification(
        &self,
    ) -> std::option::Option<&crate::model::DataClassificationDetails> {
        self.data_classification.as_ref()
    }
    /// <p>Additional details about the resource related to a finding.</p>
    pub fn details(&self) -> std::option::Option<&crate::model::ResourceDetails> {
        self.details.as_ref()
    }
}
impl std::fmt::Debug for Resource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Resource");
        formatter.field("r#type", &self.r#type);
        formatter.field("id", &self.id);
        formatter.field("partition", &self.partition);
        formatter.field("region", &self.region);
        formatter.field("resource_role", &self.resource_role);
        formatter.field("tags", &self.tags);
        formatter.field("data_classification", &self.data_classification);
        formatter.field("details", &self.details);
        formatter.finish()
    }
}
/// See [`Resource`](crate::model::Resource)
pub mod resource {

    /// A builder for [`Resource`](crate::model::Resource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) partition: std::option::Option<crate::model::Partition>,
        pub(crate) region: std::option::Option<std::string::String>,
        pub(crate) resource_role: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) data_classification:
            std::option::Option<crate::model::DataClassificationDetails>,
        pub(crate) details: std::option::Option<crate::model::ResourceDetails>,
    }
    impl Builder {
        /// <p>The type of the resource that details are provided for. If possible, set <code>Type</code> to one of the supported resource types. For example, if the resource is an EC2 instance, then set <code>Type</code> to <code>AwsEc2Instance</code>.</p>
        /// <p>If the resource does not match any of the provided types, then set <code>Type</code> to <code>Other</code>. </p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of the resource that details are provided for. If possible, set <code>Type</code> to one of the supported resource types. For example, if the resource is an EC2 instance, then set <code>Type</code> to <code>AwsEc2Instance</code>.</p>
        /// <p>If the resource does not match any of the provided types, then set <code>Type</code> to <code>Other</code>. </p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The canonical identifier for the given resource type.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The canonical identifier for the given resource type.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The canonical Amazon Web Services partition name that the Region is assigned to.</p>
        pub fn partition(mut self, input: crate::model::Partition) -> Self {
            self.partition = Some(input);
            self
        }
        /// <p>The canonical Amazon Web Services partition name that the Region is assigned to.</p>
        pub fn set_partition(
            mut self,
            input: std::option::Option<crate::model::Partition>,
        ) -> Self {
            self.partition = input;
            self
        }
        /// <p>The canonical Amazon Web Services external Region name where this resource is located.</p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        /// <p>The canonical Amazon Web Services external Region name where this resource is located.</p>
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// <p>Identifies the role of the resource in the finding. A resource is either the actor or target of the finding activity,</p>
        pub fn resource_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_role = Some(input.into());
            self
        }
        /// <p>Identifies the role of the resource in the finding. A resource is either the actor or target of the finding activity,</p>
        pub fn set_resource_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_role = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A list of Amazon Web Services tags associated with a resource at the time the finding was processed.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A list of Amazon Web Services tags associated with a resource at the time the finding was processed.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>Contains information about sensitive data that was detected on the resource.</p>
        pub fn data_classification(
            mut self,
            input: crate::model::DataClassificationDetails,
        ) -> Self {
            self.data_classification = Some(input);
            self
        }
        /// <p>Contains information about sensitive data that was detected on the resource.</p>
        pub fn set_data_classification(
            mut self,
            input: std::option::Option<crate::model::DataClassificationDetails>,
        ) -> Self {
            self.data_classification = input;
            self
        }
        /// <p>Additional details about the resource related to a finding.</p>
        pub fn details(mut self, input: crate::model::ResourceDetails) -> Self {
            self.details = Some(input);
            self
        }
        /// <p>Additional details about the resource related to a finding.</p>
        pub fn set_details(
            mut self,
            input: std::option::Option<crate::model::ResourceDetails>,
        ) -> Self {
            self.details = input;
            self
        }
        /// Consumes the builder and constructs a [`Resource`](crate::model::Resource)
        pub fn build(self) -> crate::model::Resource {
            crate::model::Resource {
                r#type: self.r#type,
                id: self.id,
                partition: self.partition,
                region: self.region,
                resource_role: self.resource_role,
                tags: self.tags,
                data_classification: self.data_classification,
                details: self.details,
            }
        }
    }
}
impl Resource {
    /// Creates a new builder-style object to manufacture [`Resource`](crate::model::Resource)
    pub fn builder() -> crate::model::resource::Builder {
        crate::model::resource::Builder::default()
    }
}

/// <p>Additional details about a resource related to a finding.</p>
/// <p>To provide the details, use the object that corresponds to the resource type. For example, if the resource type is <code>AwsEc2Instance</code>, then you use the <code>AwsEc2Instance</code> object to provide the details.</p>
/// <p>If the type-specific object does not contain all of the fields you want to populate, then you use the <code>Other</code> object to populate those additional fields.</p>
/// <p>You also use the <code>Other</code> object to populate the details when the selected type does not have a corresponding object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceDetails {
    /// <p>Details for an autoscaling group.</p>
    pub aws_auto_scaling_auto_scaling_group:
        std::option::Option<crate::model::AwsAutoScalingAutoScalingGroupDetails>,
    /// <p>Details for an CodeBuild project.</p>
    pub aws_code_build_project: std::option::Option<crate::model::AwsCodeBuildProjectDetails>,
    /// <p>Details about a CloudFront distribution.</p>
    pub aws_cloud_front_distribution:
        std::option::Option<crate::model::AwsCloudFrontDistributionDetails>,
    /// <p>Details about an EC2 instance related to a finding.</p>
    pub aws_ec2_instance: std::option::Option<crate::model::AwsEc2InstanceDetails>,
    /// <p>Details for an EC2 network interface.</p>
    pub aws_ec2_network_interface: std::option::Option<crate::model::AwsEc2NetworkInterfaceDetails>,
    /// <p>Details for an EC2 security group.</p>
    pub aws_ec2_security_group: std::option::Option<crate::model::AwsEc2SecurityGroupDetails>,
    /// <p>Details for an Amazon EC2 volume.</p>
    pub aws_ec2_volume: std::option::Option<crate::model::AwsEc2VolumeDetails>,
    /// <p>Details for an Amazon EC2 VPC.</p>
    pub aws_ec2_vpc: std::option::Option<crate::model::AwsEc2VpcDetails>,
    /// <p>Details about an Elastic IP address.</p>
    pub aws_ec2_eip: std::option::Option<crate::model::AwsEc2EipDetails>,
    /// <p>Details about a subnet in Amazon EC2.</p>
    pub aws_ec2_subnet: std::option::Option<crate::model::AwsEc2SubnetDetails>,
    /// <p>Details about an EC2 network access control list (ACL).</p>
    pub aws_ec2_network_acl: std::option::Option<crate::model::AwsEc2NetworkAclDetails>,
    /// <p>Details about a load balancer.</p>
    pub aws_elbv2_load_balancer: std::option::Option<crate::model::AwsElbv2LoadBalancerDetails>,
    /// <p>Details about an Elastic Beanstalk environment.</p>
    pub aws_elastic_beanstalk_environment:
        std::option::Option<crate::model::AwsElasticBeanstalkEnvironmentDetails>,
    /// <p>Details for an Elasticsearch domain.</p>
    pub aws_elasticsearch_domain: std::option::Option<crate::model::AwsElasticsearchDomainDetails>,
    /// <p>Details about an S3 bucket related to a finding.</p>
    pub aws_s3_bucket: std::option::Option<crate::model::AwsS3BucketDetails>,
    /// <p>Details about the Amazon S3 Public Access Block configuration for an account.</p>
    pub aws_s3_account_public_access_block:
        std::option::Option<crate::model::AwsS3AccountPublicAccessBlockDetails>,
    /// <p>Details about an S3 object related to a finding.</p>
    pub aws_s3_object: std::option::Option<crate::model::AwsS3ObjectDetails>,
    /// <p>Details about a Secrets Manager secret.</p>
    pub aws_secrets_manager_secret:
        std::option::Option<crate::model::AwsSecretsManagerSecretDetails>,
    /// <p>Details about an IAM access key related to a finding.</p>
    pub aws_iam_access_key: std::option::Option<crate::model::AwsIamAccessKeyDetails>,
    /// <p>Details about an IAM user.</p>
    pub aws_iam_user: std::option::Option<crate::model::AwsIamUserDetails>,
    /// <p>Details about an IAM permissions policy.</p>
    pub aws_iam_policy: std::option::Option<crate::model::AwsIamPolicyDetails>,
    /// <p>Provides information about a version 2 stage for Amazon API Gateway.</p>
    pub aws_api_gateway_v2_stage: std::option::Option<crate::model::AwsApiGatewayV2StageDetails>,
    /// <p>Provides information about a version 2 API in Amazon API Gateway.</p>
    pub aws_api_gateway_v2_api: std::option::Option<crate::model::AwsApiGatewayV2ApiDetails>,
    /// <p>Details about a DynamoDB table.</p>
    pub aws_dynamo_db_table: std::option::Option<crate::model::AwsDynamoDbTableDetails>,
    /// <p>Provides information about a version 1 Amazon API Gateway stage.</p>
    pub aws_api_gateway_stage: std::option::Option<crate::model::AwsApiGatewayStageDetails>,
    /// <p>Provides information about a REST API in version 1 of Amazon API Gateway.</p>
    pub aws_api_gateway_rest_api: std::option::Option<crate::model::AwsApiGatewayRestApiDetails>,
    /// <p>Provides details about a CloudTrail trail.</p>
    pub aws_cloud_trail_trail: std::option::Option<crate::model::AwsCloudTrailTrailDetails>,
    /// <p>Provides information about the state of a patch on an instance based on the patch baseline that was used to patch the instance.</p>
    pub aws_ssm_patch_compliance: std::option::Option<crate::model::AwsSsmPatchComplianceDetails>,
    /// <p>Provides details about an Certificate Manager certificate.</p>
    pub aws_certificate_manager_certificate:
        std::option::Option<crate::model::AwsCertificateManagerCertificateDetails>,
    /// <p>Contains details about an Amazon Redshift cluster.</p>
    pub aws_redshift_cluster: std::option::Option<crate::model::AwsRedshiftClusterDetails>,
    /// <p>Contains details about a Classic Load Balancer.</p>
    pub aws_elb_load_balancer: std::option::Option<crate::model::AwsElbLoadBalancerDetails>,
    /// <p>Contains details about an IAM group.</p>
    pub aws_iam_group: std::option::Option<crate::model::AwsIamGroupDetails>,
    /// <p>Details about an IAM role.</p>
    pub aws_iam_role: std::option::Option<crate::model::AwsIamRoleDetails>,
    /// <p>Details about an KMS key.</p>
    pub aws_kms_key: std::option::Option<crate::model::AwsKmsKeyDetails>,
    /// <p>Details about a Lambda function.</p>
    pub aws_lambda_function: std::option::Option<crate::model::AwsLambdaFunctionDetails>,
    /// <p>Details for a Lambda layer version.</p>
    pub aws_lambda_layer_version: std::option::Option<crate::model::AwsLambdaLayerVersionDetails>,
    /// <p>Details about an Amazon RDS database instance.</p>
    pub aws_rds_db_instance: std::option::Option<crate::model::AwsRdsDbInstanceDetails>,
    /// <p>Details about an SNS topic.</p>
    pub aws_sns_topic: std::option::Option<crate::model::AwsSnsTopicDetails>,
    /// <p>Details about an SQS queue.</p>
    pub aws_sqs_queue: std::option::Option<crate::model::AwsSqsQueueDetails>,
    /// <p>Details for an WAF web ACL.</p>
    pub aws_waf_web_acl: std::option::Option<crate::model::AwsWafWebAclDetails>,
    /// <p>Details about an Amazon RDS database snapshot.</p>
    pub aws_rds_db_snapshot: std::option::Option<crate::model::AwsRdsDbSnapshotDetails>,
    /// <p>Details about an Amazon RDS database cluster snapshot.</p>
    pub aws_rds_db_cluster_snapshot:
        std::option::Option<crate::model::AwsRdsDbClusterSnapshotDetails>,
    /// <p>Details about an Amazon RDS database cluster.</p>
    pub aws_rds_db_cluster: std::option::Option<crate::model::AwsRdsDbClusterDetails>,
    /// <p>Details about an Amazon ECS cluster.</p>
    pub aws_ecs_cluster: std::option::Option<crate::model::AwsEcsClusterDetails>,
    /// <p>Provides information about a Docker container that's part of a task. </p>
    pub aws_ecs_container: std::option::Option<crate::model::AwsEcsContainerDetails>,
    /// <p>Details about a task definition. A task definition describes the container and volume definitions of an Amazon Elastic Container Service task.</p>
    pub aws_ecs_task_definition: std::option::Option<crate::model::AwsEcsTaskDefinitionDetails>,
    /// <p>Details about a container resource related to a finding.</p>
    pub container: std::option::Option<crate::model::ContainerDetails>,
    /// <p>Details about a resource that are not available in a type-specific details object. Use the <code>Other</code> object in the following cases.</p>
    /// <ul>
    /// <li> <p>The type-specific object does not contain all of the fields that you want to populate. In this case, first use the type-specific object to populate those fields. Use the <code>Other</code> object to populate the fields that are missing from the type-specific object.</p> </li>
    /// <li> <p>The resource type does not have a corresponding object. This includes resources for which the type is <code>Other</code>. </p> </li>
    /// </ul>
    pub other:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Details about an RDS event notification subscription.</p>
    pub aws_rds_event_subscription:
        std::option::Option<crate::model::AwsRdsEventSubscriptionDetails>,
    /// <p>Details about a service within an ECS cluster.</p>
    pub aws_ecs_service: std::option::Option<crate::model::AwsEcsServiceDetails>,
    /// <p>Provides details about a launch configuration.</p>
    pub aws_auto_scaling_launch_configuration:
        std::option::Option<crate::model::AwsAutoScalingLaunchConfigurationDetails>,
    /// <p>Details about an Amazon EC2 VPN connection.</p>
    pub aws_ec2_vpn_connection: std::option::Option<crate::model::AwsEc2VpnConnectionDetails>,
    /// <p>Information about an Amazon ECR image.</p>
    pub aws_ecr_container_image: std::option::Option<crate::model::AwsEcrContainerImageDetails>,
    /// <p>Details about an Amazon OpenSearch Service domain.</p>
    pub aws_open_search_service_domain:
        std::option::Option<crate::model::AwsOpenSearchServiceDomainDetails>,
    /// <p>Details about the service configuration for a VPC endpoint service.</p>
    pub aws_ec2_vpc_endpoint_service:
        std::option::Option<crate::model::AwsEc2VpcEndpointServiceDetails>,
    /// <p>Information about the encryption configuration for X-Ray.</p>
    pub aws_xray_encryption_config:
        std::option::Option<crate::model::AwsXrayEncryptionConfigDetails>,
    /// <p>Details about a rate-based rule for global resources.</p>
    pub aws_waf_rate_based_rule: std::option::Option<crate::model::AwsWafRateBasedRuleDetails>,
    /// <p>Details about a rate-based rule for Regional resources.</p>
    pub aws_waf_regional_rate_based_rule:
        std::option::Option<crate::model::AwsWafRegionalRateBasedRuleDetails>,
    /// <p>Information about an Amazon Elastic Container Registry repository.</p>
    pub aws_ecr_repository: std::option::Option<crate::model::AwsEcrRepositoryDetails>,
    /// <p>Details about an Amazon EKS cluster.</p>
    pub aws_eks_cluster: std::option::Option<crate::model::AwsEksClusterDetails>,
    /// <p>Details about an Network Firewall firewall policy.</p>
    pub aws_network_firewall_firewall_policy:
        std::option::Option<crate::model::AwsNetworkFirewallFirewallPolicyDetails>,
    /// <p>Details about an Network Firewall firewall.</p>
    pub aws_network_firewall_firewall:
        std::option::Option<crate::model::AwsNetworkFirewallFirewallDetails>,
    /// <p>Details about an Network Firewall rule group.</p>
    pub aws_network_firewall_rule_group:
        std::option::Option<crate::model::AwsNetworkFirewallRuleGroupDetails>,
    /// <p>Details about an Amazon RDS DB security group.</p>
    pub aws_rds_db_security_group: std::option::Option<crate::model::AwsRdsDbSecurityGroupDetails>,
    /// <p>Details about an Amazon Kinesis data stream.</p>
    pub aws_kinesis_stream: std::option::Option<crate::model::AwsKinesisStreamDetails>,
    /// <p>Details about an Amazon EC2 transit gateway that interconnects your virtual private clouds (VPC) and on-premises networks.</p>
    pub aws_ec2_transit_gateway: std::option::Option<crate::model::AwsEc2TransitGatewayDetails>,
    /// <p>Details about an Amazon EFS access point. An access point is an application-specific view into an EFS file system that applies an operating system user and group, and a file system path, to any file system request made through the access point. </p>
    pub aws_efs_access_point: std::option::Option<crate::model::AwsEfsAccessPointDetails>,
    /// <p>Details about an CloudFormation stack. A stack is a collection of Amazon Web Services resources that you can manage as a single unit.</p>
    pub aws_cloud_formation_stack: std::option::Option<crate::model::AwsCloudFormationStackDetails>,
    /// <p>Details about an Amazon CloudWatch alarm. An alarm allows you to monitor and receive alerts about your Amazon Web Services resources and applications across multiple Regions.</p>
    pub aws_cloud_watch_alarm: std::option::Option<crate::model::AwsCloudWatchAlarmDetails>,
    /// <p>Details about an Amazon EC2 VPC peering connection. A VPC peering connection is a networking connection between two VPCs that enables you to route traffic between them privately. </p>
    pub aws_ec2_vpc_peering_connection:
        std::option::Option<crate::model::AwsEc2VpcPeeringConnectionDetails>,
    /// <p>Details about an WAF rule group for Regional resources. </p>
    pub aws_waf_regional_rule_group:
        std::option::Option<crate::model::AwsWafRegionalRuleGroupDetails>,
    /// <p>Details about an WAF rule for Regional resources. </p>
    pub aws_waf_regional_rule: std::option::Option<crate::model::AwsWafRegionalRuleDetails>,
    /// <p>Details about an WAF web access control list (web ACL) for Regional resources. </p>
    pub aws_waf_regional_web_acl: std::option::Option<crate::model::AwsWafRegionalWebAclDetails>,
    /// <p>Details about an WAF rule for global resources. </p>
    pub aws_waf_rule: std::option::Option<crate::model::AwsWafRuleDetails>,
    /// <p>Details about an WAF rule group for global resources. </p>
    pub aws_waf_rule_group: std::option::Option<crate::model::AwsWafRuleGroupDetails>,
    /// <p>Details about a task in a cluster. </p>
    pub aws_ecs_task: std::option::Option<crate::model::AwsEcsTaskDetails>,
}
impl ResourceDetails {
    /// <p>Details for an autoscaling group.</p>
    pub fn aws_auto_scaling_auto_scaling_group(
        &self,
    ) -> std::option::Option<&crate::model::AwsAutoScalingAutoScalingGroupDetails> {
        self.aws_auto_scaling_auto_scaling_group.as_ref()
    }
    /// <p>Details for an CodeBuild project.</p>
    pub fn aws_code_build_project(
        &self,
    ) -> std::option::Option<&crate::model::AwsCodeBuildProjectDetails> {
        self.aws_code_build_project.as_ref()
    }
    /// <p>Details about a CloudFront distribution.</p>
    pub fn aws_cloud_front_distribution(
        &self,
    ) -> std::option::Option<&crate::model::AwsCloudFrontDistributionDetails> {
        self.aws_cloud_front_distribution.as_ref()
    }
    /// <p>Details about an EC2 instance related to a finding.</p>
    pub fn aws_ec2_instance(&self) -> std::option::Option<&crate::model::AwsEc2InstanceDetails> {
        self.aws_ec2_instance.as_ref()
    }
    /// <p>Details for an EC2 network interface.</p>
    pub fn aws_ec2_network_interface(
        &self,
    ) -> std::option::Option<&crate::model::AwsEc2NetworkInterfaceDetails> {
        self.aws_ec2_network_interface.as_ref()
    }
    /// <p>Details for an EC2 security group.</p>
    pub fn aws_ec2_security_group(
        &self,
    ) -> std::option::Option<&crate::model::AwsEc2SecurityGroupDetails> {
        self.aws_ec2_security_group.as_ref()
    }
    /// <p>Details for an Amazon EC2 volume.</p>
    pub fn aws_ec2_volume(&self) -> std::option::Option<&crate::model::AwsEc2VolumeDetails> {
        self.aws_ec2_volume.as_ref()
    }
    /// <p>Details for an Amazon EC2 VPC.</p>
    pub fn aws_ec2_vpc(&self) -> std::option::Option<&crate::model::AwsEc2VpcDetails> {
        self.aws_ec2_vpc.as_ref()
    }
    /// <p>Details about an Elastic IP address.</p>
    pub fn aws_ec2_eip(&self) -> std::option::Option<&crate::model::AwsEc2EipDetails> {
        self.aws_ec2_eip.as_ref()
    }
    /// <p>Details about a subnet in Amazon EC2.</p>
    pub fn aws_ec2_subnet(&self) -> std::option::Option<&crate::model::AwsEc2SubnetDetails> {
        self.aws_ec2_subnet.as_ref()
    }
    /// <p>Details about an EC2 network access control list (ACL).</p>
    pub fn aws_ec2_network_acl(
        &self,
    ) -> std::option::Option<&crate::model::AwsEc2NetworkAclDetails> {
        self.aws_ec2_network_acl.as_ref()
    }
    /// <p>Details about a load balancer.</p>
    pub fn aws_elbv2_load_balancer(
        &self,
    ) -> std::option::Option<&crate::model::AwsElbv2LoadBalancerDetails> {
        self.aws_elbv2_load_balancer.as_ref()
    }
    /// <p>Details about an Elastic Beanstalk environment.</p>
    pub fn aws_elastic_beanstalk_environment(
        &self,
    ) -> std::option::Option<&crate::model::AwsElasticBeanstalkEnvironmentDetails> {
        self.aws_elastic_beanstalk_environment.as_ref()
    }
    /// <p>Details for an Elasticsearch domain.</p>
    pub fn aws_elasticsearch_domain(
        &self,
    ) -> std::option::Option<&crate::model::AwsElasticsearchDomainDetails> {
        self.aws_elasticsearch_domain.as_ref()
    }
    /// <p>Details about an S3 bucket related to a finding.</p>
    pub fn aws_s3_bucket(&self) -> std::option::Option<&crate::model::AwsS3BucketDetails> {
        self.aws_s3_bucket.as_ref()
    }
    /// <p>Details about the Amazon S3 Public Access Block configuration for an account.</p>
    pub fn aws_s3_account_public_access_block(
        &self,
    ) -> std::option::Option<&crate::model::AwsS3AccountPublicAccessBlockDetails> {
        self.aws_s3_account_public_access_block.as_ref()
    }
    /// <p>Details about an S3 object related to a finding.</p>
    pub fn aws_s3_object(&self) -> std::option::Option<&crate::model::AwsS3ObjectDetails> {
        self.aws_s3_object.as_ref()
    }
    /// <p>Details about a Secrets Manager secret.</p>
    pub fn aws_secrets_manager_secret(
        &self,
    ) -> std::option::Option<&crate::model::AwsSecretsManagerSecretDetails> {
        self.aws_secrets_manager_secret.as_ref()
    }
    /// <p>Details about an IAM access key related to a finding.</p>
    pub fn aws_iam_access_key(&self) -> std::option::Option<&crate::model::AwsIamAccessKeyDetails> {
        self.aws_iam_access_key.as_ref()
    }
    /// <p>Details about an IAM user.</p>
    pub fn aws_iam_user(&self) -> std::option::Option<&crate::model::AwsIamUserDetails> {
        self.aws_iam_user.as_ref()
    }
    /// <p>Details about an IAM permissions policy.</p>
    pub fn aws_iam_policy(&self) -> std::option::Option<&crate::model::AwsIamPolicyDetails> {
        self.aws_iam_policy.as_ref()
    }
    /// <p>Provides information about a version 2 stage for Amazon API Gateway.</p>
    pub fn aws_api_gateway_v2_stage(
        &self,
    ) -> std::option::Option<&crate::model::AwsApiGatewayV2StageDetails> {
        self.aws_api_gateway_v2_stage.as_ref()
    }
    /// <p>Provides information about a version 2 API in Amazon API Gateway.</p>
    pub fn aws_api_gateway_v2_api(
        &self,
    ) -> std::option::Option<&crate::model::AwsApiGatewayV2ApiDetails> {
        self.aws_api_gateway_v2_api.as_ref()
    }
    /// <p>Details about a DynamoDB table.</p>
    pub fn aws_dynamo_db_table(
        &self,
    ) -> std::option::Option<&crate::model::AwsDynamoDbTableDetails> {
        self.aws_dynamo_db_table.as_ref()
    }
    /// <p>Provides information about a version 1 Amazon API Gateway stage.</p>
    pub fn aws_api_gateway_stage(
        &self,
    ) -> std::option::Option<&crate::model::AwsApiGatewayStageDetails> {
        self.aws_api_gateway_stage.as_ref()
    }
    /// <p>Provides information about a REST API in version 1 of Amazon API Gateway.</p>
    pub fn aws_api_gateway_rest_api(
        &self,
    ) -> std::option::Option<&crate::model::AwsApiGatewayRestApiDetails> {
        self.aws_api_gateway_rest_api.as_ref()
    }
    /// <p>Provides details about a CloudTrail trail.</p>
    pub fn aws_cloud_trail_trail(
        &self,
    ) -> std::option::Option<&crate::model::AwsCloudTrailTrailDetails> {
        self.aws_cloud_trail_trail.as_ref()
    }
    /// <p>Provides information about the state of a patch on an instance based on the patch baseline that was used to patch the instance.</p>
    pub fn aws_ssm_patch_compliance(
        &self,
    ) -> std::option::Option<&crate::model::AwsSsmPatchComplianceDetails> {
        self.aws_ssm_patch_compliance.as_ref()
    }
    /// <p>Provides details about an Certificate Manager certificate.</p>
    pub fn aws_certificate_manager_certificate(
        &self,
    ) -> std::option::Option<&crate::model::AwsCertificateManagerCertificateDetails> {
        self.aws_certificate_manager_certificate.as_ref()
    }
    /// <p>Contains details about an Amazon Redshift cluster.</p>
    pub fn aws_redshift_cluster(
        &self,
    ) -> std::option::Option<&crate::model::AwsRedshiftClusterDetails> {
        self.aws_redshift_cluster.as_ref()
    }
    /// <p>Contains details about a Classic Load Balancer.</p>
    pub fn aws_elb_load_balancer(
        &self,
    ) -> std::option::Option<&crate::model::AwsElbLoadBalancerDetails> {
        self.aws_elb_load_balancer.as_ref()
    }
    /// <p>Contains details about an IAM group.</p>
    pub fn aws_iam_group(&self) -> std::option::Option<&crate::model::AwsIamGroupDetails> {
        self.aws_iam_group.as_ref()
    }
    /// <p>Details about an IAM role.</p>
    pub fn aws_iam_role(&self) -> std::option::Option<&crate::model::AwsIamRoleDetails> {
        self.aws_iam_role.as_ref()
    }
    /// <p>Details about an KMS key.</p>
    pub fn aws_kms_key(&self) -> std::option::Option<&crate::model::AwsKmsKeyDetails> {
        self.aws_kms_key.as_ref()
    }
    /// <p>Details about a Lambda function.</p>
    pub fn aws_lambda_function(
        &self,
    ) -> std::option::Option<&crate::model::AwsLambdaFunctionDetails> {
        self.aws_lambda_function.as_ref()
    }
    /// <p>Details for a Lambda layer version.</p>
    pub fn aws_lambda_layer_version(
        &self,
    ) -> std::option::Option<&crate::model::AwsLambdaLayerVersionDetails> {
        self.aws_lambda_layer_version.as_ref()
    }
    /// <p>Details about an Amazon RDS database instance.</p>
    pub fn aws_rds_db_instance(
        &self,
    ) -> std::option::Option<&crate::model::AwsRdsDbInstanceDetails> {
        self.aws_rds_db_instance.as_ref()
    }
    /// <p>Details about an SNS topic.</p>
    pub fn aws_sns_topic(&self) -> std::option::Option<&crate::model::AwsSnsTopicDetails> {
        self.aws_sns_topic.as_ref()
    }
    /// <p>Details about an SQS queue.</p>
    pub fn aws_sqs_queue(&self) -> std::option::Option<&crate::model::AwsSqsQueueDetails> {
        self.aws_sqs_queue.as_ref()
    }
    /// <p>Details for an WAF web ACL.</p>
    pub fn aws_waf_web_acl(&self) -> std::option::Option<&crate::model::AwsWafWebAclDetails> {
        self.aws_waf_web_acl.as_ref()
    }
    /// <p>Details about an Amazon RDS database snapshot.</p>
    pub fn aws_rds_db_snapshot(
        &self,
    ) -> std::option::Option<&crate::model::AwsRdsDbSnapshotDetails> {
        self.aws_rds_db_snapshot.as_ref()
    }
    /// <p>Details about an Amazon RDS database cluster snapshot.</p>
    pub fn aws_rds_db_cluster_snapshot(
        &self,
    ) -> std::option::Option<&crate::model::AwsRdsDbClusterSnapshotDetails> {
        self.aws_rds_db_cluster_snapshot.as_ref()
    }
    /// <p>Details about an Amazon RDS database cluster.</p>
    pub fn aws_rds_db_cluster(&self) -> std::option::Option<&crate::model::AwsRdsDbClusterDetails> {
        self.aws_rds_db_cluster.as_ref()
    }
    /// <p>Details about an Amazon ECS cluster.</p>
    pub fn aws_ecs_cluster(&self) -> std::option::Option<&crate::model::AwsEcsClusterDetails> {
        self.aws_ecs_cluster.as_ref()
    }
    /// <p>Provides information about a Docker container that's part of a task. </p>
    pub fn aws_ecs_container(&self) -> std::option::Option<&crate::model::AwsEcsContainerDetails> {
        self.aws_ecs_container.as_ref()
    }
    /// <p>Details about a task definition. A task definition describes the container and volume definitions of an Amazon Elastic Container Service task.</p>
    pub fn aws_ecs_task_definition(
        &self,
    ) -> std::option::Option<&crate::model::AwsEcsTaskDefinitionDetails> {
        self.aws_ecs_task_definition.as_ref()
    }
    /// <p>Details about a container resource related to a finding.</p>
    pub fn container(&self) -> std::option::Option<&crate::model::ContainerDetails> {
        self.container.as_ref()
    }
    /// <p>Details about a resource that are not available in a type-specific details object. Use the <code>Other</code> object in the following cases.</p>
    /// <ul>
    /// <li> <p>The type-specific object does not contain all of the fields that you want to populate. In this case, first use the type-specific object to populate those fields. Use the <code>Other</code> object to populate the fields that are missing from the type-specific object.</p> </li>
    /// <li> <p>The resource type does not have a corresponding object. This includes resources for which the type is <code>Other</code>. </p> </li>
    /// </ul>
    pub fn other(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.other.as_ref()
    }
    /// <p>Details about an RDS event notification subscription.</p>
    pub fn aws_rds_event_subscription(
        &self,
    ) -> std::option::Option<&crate::model::AwsRdsEventSubscriptionDetails> {
        self.aws_rds_event_subscription.as_ref()
    }
    /// <p>Details about a service within an ECS cluster.</p>
    pub fn aws_ecs_service(&self) -> std::option::Option<&crate::model::AwsEcsServiceDetails> {
        self.aws_ecs_service.as_ref()
    }
    /// <p>Provides details about a launch configuration.</p>
    pub fn aws_auto_scaling_launch_configuration(
        &self,
    ) -> std::option::Option<&crate::model::AwsAutoScalingLaunchConfigurationDetails> {
        self.aws_auto_scaling_launch_configuration.as_ref()
    }
    /// <p>Details about an Amazon EC2 VPN connection.</p>
    pub fn aws_ec2_vpn_connection(
        &self,
    ) -> std::option::Option<&crate::model::AwsEc2VpnConnectionDetails> {
        self.aws_ec2_vpn_connection.as_ref()
    }
    /// <p>Information about an Amazon ECR image.</p>
    pub fn aws_ecr_container_image(
        &self,
    ) -> std::option::Option<&crate::model::AwsEcrContainerImageDetails> {
        self.aws_ecr_container_image.as_ref()
    }
    /// <p>Details about an Amazon OpenSearch Service domain.</p>
    pub fn aws_open_search_service_domain(
        &self,
    ) -> std::option::Option<&crate::model::AwsOpenSearchServiceDomainDetails> {
        self.aws_open_search_service_domain.as_ref()
    }
    /// <p>Details about the service configuration for a VPC endpoint service.</p>
    pub fn aws_ec2_vpc_endpoint_service(
        &self,
    ) -> std::option::Option<&crate::model::AwsEc2VpcEndpointServiceDetails> {
        self.aws_ec2_vpc_endpoint_service.as_ref()
    }
    /// <p>Information about the encryption configuration for X-Ray.</p>
    pub fn aws_xray_encryption_config(
        &self,
    ) -> std::option::Option<&crate::model::AwsXrayEncryptionConfigDetails> {
        self.aws_xray_encryption_config.as_ref()
    }
    /// <p>Details about a rate-based rule for global resources.</p>
    pub fn aws_waf_rate_based_rule(
        &self,
    ) -> std::option::Option<&crate::model::AwsWafRateBasedRuleDetails> {
        self.aws_waf_rate_based_rule.as_ref()
    }
    /// <p>Details about a rate-based rule for Regional resources.</p>
    pub fn aws_waf_regional_rate_based_rule(
        &self,
    ) -> std::option::Option<&crate::model::AwsWafRegionalRateBasedRuleDetails> {
        self.aws_waf_regional_rate_based_rule.as_ref()
    }
    /// <p>Information about an Amazon Elastic Container Registry repository.</p>
    pub fn aws_ecr_repository(
        &self,
    ) -> std::option::Option<&crate::model::AwsEcrRepositoryDetails> {
        self.aws_ecr_repository.as_ref()
    }
    /// <p>Details about an Amazon EKS cluster.</p>
    pub fn aws_eks_cluster(&self) -> std::option::Option<&crate::model::AwsEksClusterDetails> {
        self.aws_eks_cluster.as_ref()
    }
    /// <p>Details about an Network Firewall firewall policy.</p>
    pub fn aws_network_firewall_firewall_policy(
        &self,
    ) -> std::option::Option<&crate::model::AwsNetworkFirewallFirewallPolicyDetails> {
        self.aws_network_firewall_firewall_policy.as_ref()
    }
    /// <p>Details about an Network Firewall firewall.</p>
    pub fn aws_network_firewall_firewall(
        &self,
    ) -> std::option::Option<&crate::model::AwsNetworkFirewallFirewallDetails> {
        self.aws_network_firewall_firewall.as_ref()
    }
    /// <p>Details about an Network Firewall rule group.</p>
    pub fn aws_network_firewall_rule_group(
        &self,
    ) -> std::option::Option<&crate::model::AwsNetworkFirewallRuleGroupDetails> {
        self.aws_network_firewall_rule_group.as_ref()
    }
    /// <p>Details about an Amazon RDS DB security group.</p>
    pub fn aws_rds_db_security_group(
        &self,
    ) -> std::option::Option<&crate::model::AwsRdsDbSecurityGroupDetails> {
        self.aws_rds_db_security_group.as_ref()
    }
    /// <p>Details about an Amazon Kinesis data stream.</p>
    pub fn aws_kinesis_stream(
        &self,
    ) -> std::option::Option<&crate::model::AwsKinesisStreamDetails> {
        self.aws_kinesis_stream.as_ref()
    }
    /// <p>Details about an Amazon EC2 transit gateway that interconnects your virtual private clouds (VPC) and on-premises networks.</p>
    pub fn aws_ec2_transit_gateway(
        &self,
    ) -> std::option::Option<&crate::model::AwsEc2TransitGatewayDetails> {
        self.aws_ec2_transit_gateway.as_ref()
    }
    /// <p>Details about an Amazon EFS access point. An access point is an application-specific view into an EFS file system that applies an operating system user and group, and a file system path, to any file system request made through the access point. </p>
    pub fn aws_efs_access_point(
        &self,
    ) -> std::option::Option<&crate::model::AwsEfsAccessPointDetails> {
        self.aws_efs_access_point.as_ref()
    }
    /// <p>Details about an CloudFormation stack. A stack is a collection of Amazon Web Services resources that you can manage as a single unit.</p>
    pub fn aws_cloud_formation_stack(
        &self,
    ) -> std::option::Option<&crate::model::AwsCloudFormationStackDetails> {
        self.aws_cloud_formation_stack.as_ref()
    }
    /// <p>Details about an Amazon CloudWatch alarm. An alarm allows you to monitor and receive alerts about your Amazon Web Services resources and applications across multiple Regions.</p>
    pub fn aws_cloud_watch_alarm(
        &self,
    ) -> std::option::Option<&crate::model::AwsCloudWatchAlarmDetails> {
        self.aws_cloud_watch_alarm.as_ref()
    }
    /// <p>Details about an Amazon EC2 VPC peering connection. A VPC peering connection is a networking connection between two VPCs that enables you to route traffic between them privately. </p>
    pub fn aws_ec2_vpc_peering_connection(
        &self,
    ) -> std::option::Option<&crate::model::AwsEc2VpcPeeringConnectionDetails> {
        self.aws_ec2_vpc_peering_connection.as_ref()
    }
    /// <p>Details about an WAF rule group for Regional resources. </p>
    pub fn aws_waf_regional_rule_group(
        &self,
    ) -> std::option::Option<&crate::model::AwsWafRegionalRuleGroupDetails> {
        self.aws_waf_regional_rule_group.as_ref()
    }
    /// <p>Details about an WAF rule for Regional resources. </p>
    pub fn aws_waf_regional_rule(
        &self,
    ) -> std::option::Option<&crate::model::AwsWafRegionalRuleDetails> {
        self.aws_waf_regional_rule.as_ref()
    }
    /// <p>Details about an WAF web access control list (web ACL) for Regional resources. </p>
    pub fn aws_waf_regional_web_acl(
        &self,
    ) -> std::option::Option<&crate::model::AwsWafRegionalWebAclDetails> {
        self.aws_waf_regional_web_acl.as_ref()
    }
    /// <p>Details about an WAF rule for global resources. </p>
    pub fn aws_waf_rule(&self) -> std::option::Option<&crate::model::AwsWafRuleDetails> {
        self.aws_waf_rule.as_ref()
    }
    /// <p>Details about an WAF rule group for global resources. </p>
    pub fn aws_waf_rule_group(&self) -> std::option::Option<&crate::model::AwsWafRuleGroupDetails> {
        self.aws_waf_rule_group.as_ref()
    }
    /// <p>Details about a task in a cluster. </p>
    pub fn aws_ecs_task(&self) -> std::option::Option<&crate::model::AwsEcsTaskDetails> {
        self.aws_ecs_task.as_ref()
    }
}
impl std::fmt::Debug for ResourceDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceDetails");
        formatter.field(
            "aws_auto_scaling_auto_scaling_group",
            &self.aws_auto_scaling_auto_scaling_group,
        );
        formatter.field("aws_code_build_project", &self.aws_code_build_project);
        formatter.field(
            "aws_cloud_front_distribution",
            &self.aws_cloud_front_distribution,
        );
        formatter.field("aws_ec2_instance", &self.aws_ec2_instance);
        formatter.field("aws_ec2_network_interface", &self.aws_ec2_network_interface);
        formatter.field("aws_ec2_security_group", &self.aws_ec2_security_group);
        formatter.field("aws_ec2_volume", &self.aws_ec2_volume);
        formatter.field("aws_ec2_vpc", &self.aws_ec2_vpc);
        formatter.field("aws_ec2_eip", &self.aws_ec2_eip);
        formatter.field("aws_ec2_subnet", &self.aws_ec2_subnet);
        formatter.field("aws_ec2_network_acl", &self.aws_ec2_network_acl);
        formatter.field("aws_elbv2_load_balancer", &self.aws_elbv2_load_balancer);
        formatter.field(
            "aws_elastic_beanstalk_environment",
            &self.aws_elastic_beanstalk_environment,
        );
        formatter.field("aws_elasticsearch_domain", &self.aws_elasticsearch_domain);
        formatter.field("aws_s3_bucket", &self.aws_s3_bucket);
        formatter.field(
            "aws_s3_account_public_access_block",
            &self.aws_s3_account_public_access_block,
        );
        formatter.field("aws_s3_object", &self.aws_s3_object);
        formatter.field(
            "aws_secrets_manager_secret",
            &self.aws_secrets_manager_secret,
        );
        formatter.field("aws_iam_access_key", &self.aws_iam_access_key);
        formatter.field("aws_iam_user", &self.aws_iam_user);
        formatter.field("aws_iam_policy", &self.aws_iam_policy);
        formatter.field("aws_api_gateway_v2_stage", &self.aws_api_gateway_v2_stage);
        formatter.field("aws_api_gateway_v2_api", &self.aws_api_gateway_v2_api);
        formatter.field("aws_dynamo_db_table", &self.aws_dynamo_db_table);
        formatter.field("aws_api_gateway_stage", &self.aws_api_gateway_stage);
        formatter.field("aws_api_gateway_rest_api", &self.aws_api_gateway_rest_api);
        formatter.field("aws_cloud_trail_trail", &self.aws_cloud_trail_trail);
        formatter.field("aws_ssm_patch_compliance", &self.aws_ssm_patch_compliance);
        formatter.field(
            "aws_certificate_manager_certificate",
            &self.aws_certificate_manager_certificate,
        );
        formatter.field("aws_redshift_cluster", &self.aws_redshift_cluster);
        formatter.field("aws_elb_load_balancer", &self.aws_elb_load_balancer);
        formatter.field("aws_iam_group", &self.aws_iam_group);
        formatter.field("aws_iam_role", &self.aws_iam_role);
        formatter.field("aws_kms_key", &self.aws_kms_key);
        formatter.field("aws_lambda_function", &self.aws_lambda_function);
        formatter.field("aws_lambda_layer_version", &self.aws_lambda_layer_version);
        formatter.field("aws_rds_db_instance", &self.aws_rds_db_instance);
        formatter.field("aws_sns_topic", &self.aws_sns_topic);
        formatter.field("aws_sqs_queue", &self.aws_sqs_queue);
        formatter.field("aws_waf_web_acl", &self.aws_waf_web_acl);
        formatter.field("aws_rds_db_snapshot", &self.aws_rds_db_snapshot);
        formatter.field(
            "aws_rds_db_cluster_snapshot",
            &self.aws_rds_db_cluster_snapshot,
        );
        formatter.field("aws_rds_db_cluster", &self.aws_rds_db_cluster);
        formatter.field("aws_ecs_cluster", &self.aws_ecs_cluster);
        formatter.field("aws_ecs_container", &self.aws_ecs_container);
        formatter.field("aws_ecs_task_definition", &self.aws_ecs_task_definition);
        formatter.field("container", &self.container);
        formatter.field("other", &self.other);
        formatter.field(
            "aws_rds_event_subscription",
            &self.aws_rds_event_subscription,
        );
        formatter.field("aws_ecs_service", &self.aws_ecs_service);
        formatter.field(
            "aws_auto_scaling_launch_configuration",
            &self.aws_auto_scaling_launch_configuration,
        );
        formatter.field("aws_ec2_vpn_connection", &self.aws_ec2_vpn_connection);
        formatter.field("aws_ecr_container_image", &self.aws_ecr_container_image);
        formatter.field(
            "aws_open_search_service_domain",
            &self.aws_open_search_service_domain,
        );
        formatter.field(
            "aws_ec2_vpc_endpoint_service",
            &self.aws_ec2_vpc_endpoint_service,
        );
        formatter.field(
            "aws_xray_encryption_config",
            &self.aws_xray_encryption_config,
        );
        formatter.field("aws_waf_rate_based_rule", &self.aws_waf_rate_based_rule);
        formatter.field(
            "aws_waf_regional_rate_based_rule",
            &self.aws_waf_regional_rate_based_rule,
        );
        formatter.field("aws_ecr_repository", &self.aws_ecr_repository);
        formatter.field("aws_eks_cluster", &self.aws_eks_cluster);
        formatter.field(
            "aws_network_firewall_firewall_policy",
            &self.aws_network_firewall_firewall_policy,
        );
        formatter.field(
            "aws_network_firewall_firewall",
            &self.aws_network_firewall_firewall,
        );
        formatter.field(
            "aws_network_firewall_rule_group",
            &self.aws_network_firewall_rule_group,
        );
        formatter.field("aws_rds_db_security_group", &self.aws_rds_db_security_group);
        formatter.field("aws_kinesis_stream", &self.aws_kinesis_stream);
        formatter.field("aws_ec2_transit_gateway", &self.aws_ec2_transit_gateway);
        formatter.field("aws_efs_access_point", &self.aws_efs_access_point);
        formatter.field("aws_cloud_formation_stack", &self.aws_cloud_formation_stack);
        formatter.field("aws_cloud_watch_alarm", &self.aws_cloud_watch_alarm);
        formatter.field(
            "aws_ec2_vpc_peering_connection",
            &self.aws_ec2_vpc_peering_connection,
        );
        formatter.field(
            "aws_waf_regional_rule_group",
            &self.aws_waf_regional_rule_group,
        );
        formatter.field("aws_waf_regional_rule", &self.aws_waf_regional_rule);
        formatter.field("aws_waf_regional_web_acl", &self.aws_waf_regional_web_acl);
        formatter.field("aws_waf_rule", &self.aws_waf_rule);
        formatter.field("aws_waf_rule_group", &self.aws_waf_rule_group);
        formatter.field("aws_ecs_task", &self.aws_ecs_task);
        formatter.finish()
    }
}
/// See [`ResourceDetails`](crate::model::ResourceDetails)
pub mod resource_details {

    /// A builder for [`ResourceDetails`](crate::model::ResourceDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) aws_auto_scaling_auto_scaling_group:
            std::option::Option<crate::model::AwsAutoScalingAutoScalingGroupDetails>,
        pub(crate) aws_code_build_project:
            std::option::Option<crate::model::AwsCodeBuildProjectDetails>,
        pub(crate) aws_cloud_front_distribution:
            std::option::Option<crate::model::AwsCloudFrontDistributionDetails>,
        pub(crate) aws_ec2_instance: std::option::Option<crate::model::AwsEc2InstanceDetails>,
        pub(crate) aws_ec2_network_interface:
            std::option::Option<crate::model::AwsEc2NetworkInterfaceDetails>,
        pub(crate) aws_ec2_security_group:
            std::option::Option<crate::model::AwsEc2SecurityGroupDetails>,
        pub(crate) aws_ec2_volume: std::option::Option<crate::model::AwsEc2VolumeDetails>,
        pub(crate) aws_ec2_vpc: std::option::Option<crate::model::AwsEc2VpcDetails>,
        pub(crate) aws_ec2_eip: std::option::Option<crate::model::AwsEc2EipDetails>,
        pub(crate) aws_ec2_subnet: std::option::Option<crate::model::AwsEc2SubnetDetails>,
        pub(crate) aws_ec2_network_acl: std::option::Option<crate::model::AwsEc2NetworkAclDetails>,
        pub(crate) aws_elbv2_load_balancer:
            std::option::Option<crate::model::AwsElbv2LoadBalancerDetails>,
        pub(crate) aws_elastic_beanstalk_environment:
            std::option::Option<crate::model::AwsElasticBeanstalkEnvironmentDetails>,
        pub(crate) aws_elasticsearch_domain:
            std::option::Option<crate::model::AwsElasticsearchDomainDetails>,
        pub(crate) aws_s3_bucket: std::option::Option<crate::model::AwsS3BucketDetails>,
        pub(crate) aws_s3_account_public_access_block:
            std::option::Option<crate::model::AwsS3AccountPublicAccessBlockDetails>,
        pub(crate) aws_s3_object: std::option::Option<crate::model::AwsS3ObjectDetails>,
        pub(crate) aws_secrets_manager_secret:
            std::option::Option<crate::model::AwsSecretsManagerSecretDetails>,
        pub(crate) aws_iam_access_key: std::option::Option<crate::model::AwsIamAccessKeyDetails>,
        pub(crate) aws_iam_user: std::option::Option<crate::model::AwsIamUserDetails>,
        pub(crate) aws_iam_policy: std::option::Option<crate::model::AwsIamPolicyDetails>,
        pub(crate) aws_api_gateway_v2_stage:
            std::option::Option<crate::model::AwsApiGatewayV2StageDetails>,
        pub(crate) aws_api_gateway_v2_api:
            std::option::Option<crate::model::AwsApiGatewayV2ApiDetails>,
        pub(crate) aws_dynamo_db_table: std::option::Option<crate::model::AwsDynamoDbTableDetails>,
        pub(crate) aws_api_gateway_stage:
            std::option::Option<crate::model::AwsApiGatewayStageDetails>,
        pub(crate) aws_api_gateway_rest_api:
            std::option::Option<crate::model::AwsApiGatewayRestApiDetails>,
        pub(crate) aws_cloud_trail_trail:
            std::option::Option<crate::model::AwsCloudTrailTrailDetails>,
        pub(crate) aws_ssm_patch_compliance:
            std::option::Option<crate::model::AwsSsmPatchComplianceDetails>,
        pub(crate) aws_certificate_manager_certificate:
            std::option::Option<crate::model::AwsCertificateManagerCertificateDetails>,
        pub(crate) aws_redshift_cluster:
            std::option::Option<crate::model::AwsRedshiftClusterDetails>,
        pub(crate) aws_elb_load_balancer:
            std::option::Option<crate::model::AwsElbLoadBalancerDetails>,
        pub(crate) aws_iam_group: std::option::Option<crate::model::AwsIamGroupDetails>,
        pub(crate) aws_iam_role: std::option::Option<crate::model::AwsIamRoleDetails>,
        pub(crate) aws_kms_key: std::option::Option<crate::model::AwsKmsKeyDetails>,
        pub(crate) aws_lambda_function: std::option::Option<crate::model::AwsLambdaFunctionDetails>,
        pub(crate) aws_lambda_layer_version:
            std::option::Option<crate::model::AwsLambdaLayerVersionDetails>,
        pub(crate) aws_rds_db_instance: std::option::Option<crate::model::AwsRdsDbInstanceDetails>,
        pub(crate) aws_sns_topic: std::option::Option<crate::model::AwsSnsTopicDetails>,
        pub(crate) aws_sqs_queue: std::option::Option<crate::model::AwsSqsQueueDetails>,
        pub(crate) aws_waf_web_acl: std::option::Option<crate::model::AwsWafWebAclDetails>,
        pub(crate) aws_rds_db_snapshot: std::option::Option<crate::model::AwsRdsDbSnapshotDetails>,
        pub(crate) aws_rds_db_cluster_snapshot:
            std::option::Option<crate::model::AwsRdsDbClusterSnapshotDetails>,
        pub(crate) aws_rds_db_cluster: std::option::Option<crate::model::AwsRdsDbClusterDetails>,
        pub(crate) aws_ecs_cluster: std::option::Option<crate::model::AwsEcsClusterDetails>,
        pub(crate) aws_ecs_container: std::option::Option<crate::model::AwsEcsContainerDetails>,
        pub(crate) aws_ecs_task_definition:
            std::option::Option<crate::model::AwsEcsTaskDefinitionDetails>,
        pub(crate) container: std::option::Option<crate::model::ContainerDetails>,
        pub(crate) other: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) aws_rds_event_subscription:
            std::option::Option<crate::model::AwsRdsEventSubscriptionDetails>,
        pub(crate) aws_ecs_service: std::option::Option<crate::model::AwsEcsServiceDetails>,
        pub(crate) aws_auto_scaling_launch_configuration:
            std::option::Option<crate::model::AwsAutoScalingLaunchConfigurationDetails>,
        pub(crate) aws_ec2_vpn_connection:
            std::option::Option<crate::model::AwsEc2VpnConnectionDetails>,
        pub(crate) aws_ecr_container_image:
            std::option::Option<crate::model::AwsEcrContainerImageDetails>,
        pub(crate) aws_open_search_service_domain:
            std::option::Option<crate::model::AwsOpenSearchServiceDomainDetails>,
        pub(crate) aws_ec2_vpc_endpoint_service:
            std::option::Option<crate::model::AwsEc2VpcEndpointServiceDetails>,
        pub(crate) aws_xray_encryption_config:
            std::option::Option<crate::model::AwsXrayEncryptionConfigDetails>,
        pub(crate) aws_waf_rate_based_rule:
            std::option::Option<crate::model::AwsWafRateBasedRuleDetails>,
        pub(crate) aws_waf_regional_rate_based_rule:
            std::option::Option<crate::model::AwsWafRegionalRateBasedRuleDetails>,
        pub(crate) aws_ecr_repository: std::option::Option<crate::model::AwsEcrRepositoryDetails>,
        pub(crate) aws_eks_cluster: std::option::Option<crate::model::AwsEksClusterDetails>,
        pub(crate) aws_network_firewall_firewall_policy:
            std::option::Option<crate::model::AwsNetworkFirewallFirewallPolicyDetails>,
        pub(crate) aws_network_firewall_firewall:
            std::option::Option<crate::model::AwsNetworkFirewallFirewallDetails>,
        pub(crate) aws_network_firewall_rule_group:
            std::option::Option<crate::model::AwsNetworkFirewallRuleGroupDetails>,
        pub(crate) aws_rds_db_security_group:
            std::option::Option<crate::model::AwsRdsDbSecurityGroupDetails>,
        pub(crate) aws_kinesis_stream: std::option::Option<crate::model::AwsKinesisStreamDetails>,
        pub(crate) aws_ec2_transit_gateway:
            std::option::Option<crate::model::AwsEc2TransitGatewayDetails>,
        pub(crate) aws_efs_access_point:
            std::option::Option<crate::model::AwsEfsAccessPointDetails>,
        pub(crate) aws_cloud_formation_stack:
            std::option::Option<crate::model::AwsCloudFormationStackDetails>,
        pub(crate) aws_cloud_watch_alarm:
            std::option::Option<crate::model::AwsCloudWatchAlarmDetails>,
        pub(crate) aws_ec2_vpc_peering_connection:
            std::option::Option<crate::model::AwsEc2VpcPeeringConnectionDetails>,
        pub(crate) aws_waf_regional_rule_group:
            std::option::Option<crate::model::AwsWafRegionalRuleGroupDetails>,
        pub(crate) aws_waf_regional_rule:
            std::option::Option<crate::model::AwsWafRegionalRuleDetails>,
        pub(crate) aws_waf_regional_web_acl:
            std::option::Option<crate::model::AwsWafRegionalWebAclDetails>,
        pub(crate) aws_waf_rule: std::option::Option<crate::model::AwsWafRuleDetails>,
        pub(crate) aws_waf_rule_group: std::option::Option<crate::model::AwsWafRuleGroupDetails>,
        pub(crate) aws_ecs_task: std::option::Option<crate::model::AwsEcsTaskDetails>,
    }
    impl Builder {
        /// <p>Details for an autoscaling group.</p>
        pub fn aws_auto_scaling_auto_scaling_group(
            mut self,
            input: crate::model::AwsAutoScalingAutoScalingGroupDetails,
        ) -> Self {
            self.aws_auto_scaling_auto_scaling_group = Some(input);
            self
        }
        /// <p>Details for an autoscaling group.</p>
        pub fn set_aws_auto_scaling_auto_scaling_group(
            mut self,
            input: std::option::Option<crate::model::AwsAutoScalingAutoScalingGroupDetails>,
        ) -> Self {
            self.aws_auto_scaling_auto_scaling_group = input;
            self
        }
        /// <p>Details for an CodeBuild project.</p>
        pub fn aws_code_build_project(
            mut self,
            input: crate::model::AwsCodeBuildProjectDetails,
        ) -> Self {
            self.aws_code_build_project = Some(input);
            self
        }
        /// <p>Details for an CodeBuild project.</p>
        pub fn set_aws_code_build_project(
            mut self,
            input: std::option::Option<crate::model::AwsCodeBuildProjectDetails>,
        ) -> Self {
            self.aws_code_build_project = input;
            self
        }
        /// <p>Details about a CloudFront distribution.</p>
        pub fn aws_cloud_front_distribution(
            mut self,
            input: crate::model::AwsCloudFrontDistributionDetails,
        ) -> Self {
            self.aws_cloud_front_distribution = Some(input);
            self
        }
        /// <p>Details about a CloudFront distribution.</p>
        pub fn set_aws_cloud_front_distribution(
            mut self,
            input: std::option::Option<crate::model::AwsCloudFrontDistributionDetails>,
        ) -> Self {
            self.aws_cloud_front_distribution = input;
            self
        }
        /// <p>Details about an EC2 instance related to a finding.</p>
        pub fn aws_ec2_instance(mut self, input: crate::model::AwsEc2InstanceDetails) -> Self {
            self.aws_ec2_instance = Some(input);
            self
        }
        /// <p>Details about an EC2 instance related to a finding.</p>
        pub fn set_aws_ec2_instance(
            mut self,
            input: std::option::Option<crate::model::AwsEc2InstanceDetails>,
        ) -> Self {
            self.aws_ec2_instance = input;
            self
        }
        /// <p>Details for an EC2 network interface.</p>
        pub fn aws_ec2_network_interface(
            mut self,
            input: crate::model::AwsEc2NetworkInterfaceDetails,
        ) -> Self {
            self.aws_ec2_network_interface = Some(input);
            self
        }
        /// <p>Details for an EC2 network interface.</p>
        pub fn set_aws_ec2_network_interface(
            mut self,
            input: std::option::Option<crate::model::AwsEc2NetworkInterfaceDetails>,
        ) -> Self {
            self.aws_ec2_network_interface = input;
            self
        }
        /// <p>Details for an EC2 security group.</p>
        pub fn aws_ec2_security_group(
            mut self,
            input: crate::model::AwsEc2SecurityGroupDetails,
        ) -> Self {
            self.aws_ec2_security_group = Some(input);
            self
        }
        /// <p>Details for an EC2 security group.</p>
        pub fn set_aws_ec2_security_group(
            mut self,
            input: std::option::Option<crate::model::AwsEc2SecurityGroupDetails>,
        ) -> Self {
            self.aws_ec2_security_group = input;
            self
        }
        /// <p>Details for an Amazon EC2 volume.</p>
        pub fn aws_ec2_volume(mut self, input: crate::model::AwsEc2VolumeDetails) -> Self {
            self.aws_ec2_volume = Some(input);
            self
        }
        /// <p>Details for an Amazon EC2 volume.</p>
        pub fn set_aws_ec2_volume(
            mut self,
            input: std::option::Option<crate::model::AwsEc2VolumeDetails>,
        ) -> Self {
            self.aws_ec2_volume = input;
            self
        }
        /// <p>Details for an Amazon EC2 VPC.</p>
        pub fn aws_ec2_vpc(mut self, input: crate::model::AwsEc2VpcDetails) -> Self {
            self.aws_ec2_vpc = Some(input);
            self
        }
        /// <p>Details for an Amazon EC2 VPC.</p>
        pub fn set_aws_ec2_vpc(
            mut self,
            input: std::option::Option<crate::model::AwsEc2VpcDetails>,
        ) -> Self {
            self.aws_ec2_vpc = input;
            self
        }
        /// <p>Details about an Elastic IP address.</p>
        pub fn aws_ec2_eip(mut self, input: crate::model::AwsEc2EipDetails) -> Self {
            self.aws_ec2_eip = Some(input);
            self
        }
        /// <p>Details about an Elastic IP address.</p>
        pub fn set_aws_ec2_eip(
            mut self,
            input: std::option::Option<crate::model::AwsEc2EipDetails>,
        ) -> Self {
            self.aws_ec2_eip = input;
            self
        }
        /// <p>Details about a subnet in Amazon EC2.</p>
        pub fn aws_ec2_subnet(mut self, input: crate::model::AwsEc2SubnetDetails) -> Self {
            self.aws_ec2_subnet = Some(input);
            self
        }
        /// <p>Details about a subnet in Amazon EC2.</p>
        pub fn set_aws_ec2_subnet(
            mut self,
            input: std::option::Option<crate::model::AwsEc2SubnetDetails>,
        ) -> Self {
            self.aws_ec2_subnet = input;
            self
        }
        /// <p>Details about an EC2 network access control list (ACL).</p>
        pub fn aws_ec2_network_acl(mut self, input: crate::model::AwsEc2NetworkAclDetails) -> Self {
            self.aws_ec2_network_acl = Some(input);
            self
        }
        /// <p>Details about an EC2 network access control list (ACL).</p>
        pub fn set_aws_ec2_network_acl(
            mut self,
            input: std::option::Option<crate::model::AwsEc2NetworkAclDetails>,
        ) -> Self {
            self.aws_ec2_network_acl = input;
            self
        }
        /// <p>Details about a load balancer.</p>
        pub fn aws_elbv2_load_balancer(
            mut self,
            input: crate::model::AwsElbv2LoadBalancerDetails,
        ) -> Self {
            self.aws_elbv2_load_balancer = Some(input);
            self
        }
        /// <p>Details about a load balancer.</p>
        pub fn set_aws_elbv2_load_balancer(
            mut self,
            input: std::option::Option<crate::model::AwsElbv2LoadBalancerDetails>,
        ) -> Self {
            self.aws_elbv2_load_balancer = input;
            self
        }
        /// <p>Details about an Elastic Beanstalk environment.</p>
        pub fn aws_elastic_beanstalk_environment(
            mut self,
            input: crate::model::AwsElasticBeanstalkEnvironmentDetails,
        ) -> Self {
            self.aws_elastic_beanstalk_environment = Some(input);
            self
        }
        /// <p>Details about an Elastic Beanstalk environment.</p>
        pub fn set_aws_elastic_beanstalk_environment(
            mut self,
            input: std::option::Option<crate::model::AwsElasticBeanstalkEnvironmentDetails>,
        ) -> Self {
            self.aws_elastic_beanstalk_environment = input;
            self
        }
        /// <p>Details for an Elasticsearch domain.</p>
        pub fn aws_elasticsearch_domain(
            mut self,
            input: crate::model::AwsElasticsearchDomainDetails,
        ) -> Self {
            self.aws_elasticsearch_domain = Some(input);
            self
        }
        /// <p>Details for an Elasticsearch domain.</p>
        pub fn set_aws_elasticsearch_domain(
            mut self,
            input: std::option::Option<crate::model::AwsElasticsearchDomainDetails>,
        ) -> Self {
            self.aws_elasticsearch_domain = input;
            self
        }
        /// <p>Details about an S3 bucket related to a finding.</p>
        pub fn aws_s3_bucket(mut self, input: crate::model::AwsS3BucketDetails) -> Self {
            self.aws_s3_bucket = Some(input);
            self
        }
        /// <p>Details about an S3 bucket related to a finding.</p>
        pub fn set_aws_s3_bucket(
            mut self,
            input: std::option::Option<crate::model::AwsS3BucketDetails>,
        ) -> Self {
            self.aws_s3_bucket = input;
            self
        }
        /// <p>Details about the Amazon S3 Public Access Block configuration for an account.</p>
        pub fn aws_s3_account_public_access_block(
            mut self,
            input: crate::model::AwsS3AccountPublicAccessBlockDetails,
        ) -> Self {
            self.aws_s3_account_public_access_block = Some(input);
            self
        }
        /// <p>Details about the Amazon S3 Public Access Block configuration for an account.</p>
        pub fn set_aws_s3_account_public_access_block(
            mut self,
            input: std::option::Option<crate::model::AwsS3AccountPublicAccessBlockDetails>,
        ) -> Self {
            self.aws_s3_account_public_access_block = input;
            self
        }
        /// <p>Details about an S3 object related to a finding.</p>
        pub fn aws_s3_object(mut self, input: crate::model::AwsS3ObjectDetails) -> Self {
            self.aws_s3_object = Some(input);
            self
        }
        /// <p>Details about an S3 object related to a finding.</p>
        pub fn set_aws_s3_object(
            mut self,
            input: std::option::Option<crate::model::AwsS3ObjectDetails>,
        ) -> Self {
            self.aws_s3_object = input;
            self
        }
        /// <p>Details about a Secrets Manager secret.</p>
        pub fn aws_secrets_manager_secret(
            mut self,
            input: crate::model::AwsSecretsManagerSecretDetails,
        ) -> Self {
            self.aws_secrets_manager_secret = Some(input);
            self
        }
        /// <p>Details about a Secrets Manager secret.</p>
        pub fn set_aws_secrets_manager_secret(
            mut self,
            input: std::option::Option<crate::model::AwsSecretsManagerSecretDetails>,
        ) -> Self {
            self.aws_secrets_manager_secret = input;
            self
        }
        /// <p>Details about an IAM access key related to a finding.</p>
        pub fn aws_iam_access_key(mut self, input: crate::model::AwsIamAccessKeyDetails) -> Self {
            self.aws_iam_access_key = Some(input);
            self
        }
        /// <p>Details about an IAM access key related to a finding.</p>
        pub fn set_aws_iam_access_key(
            mut self,
            input: std::option::Option<crate::model::AwsIamAccessKeyDetails>,
        ) -> Self {
            self.aws_iam_access_key = input;
            self
        }
        /// <p>Details about an IAM user.</p>
        pub fn aws_iam_user(mut self, input: crate::model::AwsIamUserDetails) -> Self {
            self.aws_iam_user = Some(input);
            self
        }
        /// <p>Details about an IAM user.</p>
        pub fn set_aws_iam_user(
            mut self,
            input: std::option::Option<crate::model::AwsIamUserDetails>,
        ) -> Self {
            self.aws_iam_user = input;
            self
        }
        /// <p>Details about an IAM permissions policy.</p>
        pub fn aws_iam_policy(mut self, input: crate::model::AwsIamPolicyDetails) -> Self {
            self.aws_iam_policy = Some(input);
            self
        }
        /// <p>Details about an IAM permissions policy.</p>
        pub fn set_aws_iam_policy(
            mut self,
            input: std::option::Option<crate::model::AwsIamPolicyDetails>,
        ) -> Self {
            self.aws_iam_policy = input;
            self
        }
        /// <p>Provides information about a version 2 stage for Amazon API Gateway.</p>
        pub fn aws_api_gateway_v2_stage(
            mut self,
            input: crate::model::AwsApiGatewayV2StageDetails,
        ) -> Self {
            self.aws_api_gateway_v2_stage = Some(input);
            self
        }
        /// <p>Provides information about a version 2 stage for Amazon API Gateway.</p>
        pub fn set_aws_api_gateway_v2_stage(
            mut self,
            input: std::option::Option<crate::model::AwsApiGatewayV2StageDetails>,
        ) -> Self {
            self.aws_api_gateway_v2_stage = input;
            self
        }
        /// <p>Provides information about a version 2 API in Amazon API Gateway.</p>
        pub fn aws_api_gateway_v2_api(
            mut self,
            input: crate::model::AwsApiGatewayV2ApiDetails,
        ) -> Self {
            self.aws_api_gateway_v2_api = Some(input);
            self
        }
        /// <p>Provides information about a version 2 API in Amazon API Gateway.</p>
        pub fn set_aws_api_gateway_v2_api(
            mut self,
            input: std::option::Option<crate::model::AwsApiGatewayV2ApiDetails>,
        ) -> Self {
            self.aws_api_gateway_v2_api = input;
            self
        }
        /// <p>Details about a DynamoDB table.</p>
        pub fn aws_dynamo_db_table(mut self, input: crate::model::AwsDynamoDbTableDetails) -> Self {
            self.aws_dynamo_db_table = Some(input);
            self
        }
        /// <p>Details about a DynamoDB table.</p>
        pub fn set_aws_dynamo_db_table(
            mut self,
            input: std::option::Option<crate::model::AwsDynamoDbTableDetails>,
        ) -> Self {
            self.aws_dynamo_db_table = input;
            self
        }
        /// <p>Provides information about a version 1 Amazon API Gateway stage.</p>
        pub fn aws_api_gateway_stage(
            mut self,
            input: crate::model::AwsApiGatewayStageDetails,
        ) -> Self {
            self.aws_api_gateway_stage = Some(input);
            self
        }
        /// <p>Provides information about a version 1 Amazon API Gateway stage.</p>
        pub fn set_aws_api_gateway_stage(
            mut self,
            input: std::option::Option<crate::model::AwsApiGatewayStageDetails>,
        ) -> Self {
            self.aws_api_gateway_stage = input;
            self
        }
        /// <p>Provides information about a REST API in version 1 of Amazon API Gateway.</p>
        pub fn aws_api_gateway_rest_api(
            mut self,
            input: crate::model::AwsApiGatewayRestApiDetails,
        ) -> Self {
            self.aws_api_gateway_rest_api = Some(input);
            self
        }
        /// <p>Provides information about a REST API in version 1 of Amazon API Gateway.</p>
        pub fn set_aws_api_gateway_rest_api(
            mut self,
            input: std::option::Option<crate::model::AwsApiGatewayRestApiDetails>,
        ) -> Self {
            self.aws_api_gateway_rest_api = input;
            self
        }
        /// <p>Provides details about a CloudTrail trail.</p>
        pub fn aws_cloud_trail_trail(
            mut self,
            input: crate::model::AwsCloudTrailTrailDetails,
        ) -> Self {
            self.aws_cloud_trail_trail = Some(input);
            self
        }
        /// <p>Provides details about a CloudTrail trail.</p>
        pub fn set_aws_cloud_trail_trail(
            mut self,
            input: std::option::Option<crate::model::AwsCloudTrailTrailDetails>,
        ) -> Self {
            self.aws_cloud_trail_trail = input;
            self
        }
        /// <p>Provides information about the state of a patch on an instance based on the patch baseline that was used to patch the instance.</p>
        pub fn aws_ssm_patch_compliance(
            mut self,
            input: crate::model::AwsSsmPatchComplianceDetails,
        ) -> Self {
            self.aws_ssm_patch_compliance = Some(input);
            self
        }
        /// <p>Provides information about the state of a patch on an instance based on the patch baseline that was used to patch the instance.</p>
        pub fn set_aws_ssm_patch_compliance(
            mut self,
            input: std::option::Option<crate::model::AwsSsmPatchComplianceDetails>,
        ) -> Self {
            self.aws_ssm_patch_compliance = input;
            self
        }
        /// <p>Provides details about an Certificate Manager certificate.</p>
        pub fn aws_certificate_manager_certificate(
            mut self,
            input: crate::model::AwsCertificateManagerCertificateDetails,
        ) -> Self {
            self.aws_certificate_manager_certificate = Some(input);
            self
        }
        /// <p>Provides details about an Certificate Manager certificate.</p>
        pub fn set_aws_certificate_manager_certificate(
            mut self,
            input: std::option::Option<crate::model::AwsCertificateManagerCertificateDetails>,
        ) -> Self {
            self.aws_certificate_manager_certificate = input;
            self
        }
        /// <p>Contains details about an Amazon Redshift cluster.</p>
        pub fn aws_redshift_cluster(
            mut self,
            input: crate::model::AwsRedshiftClusterDetails,
        ) -> Self {
            self.aws_redshift_cluster = Some(input);
            self
        }
        /// <p>Contains details about an Amazon Redshift cluster.</p>
        pub fn set_aws_redshift_cluster(
            mut self,
            input: std::option::Option<crate::model::AwsRedshiftClusterDetails>,
        ) -> Self {
            self.aws_redshift_cluster = input;
            self
        }
        /// <p>Contains details about a Classic Load Balancer.</p>
        pub fn aws_elb_load_balancer(
            mut self,
            input: crate::model::AwsElbLoadBalancerDetails,
        ) -> Self {
            self.aws_elb_load_balancer = Some(input);
            self
        }
        /// <p>Contains details about a Classic Load Balancer.</p>
        pub fn set_aws_elb_load_balancer(
            mut self,
            input: std::option::Option<crate::model::AwsElbLoadBalancerDetails>,
        ) -> Self {
            self.aws_elb_load_balancer = input;
            self
        }
        /// <p>Contains details about an IAM group.</p>
        pub fn aws_iam_group(mut self, input: crate::model::AwsIamGroupDetails) -> Self {
            self.aws_iam_group = Some(input);
            self
        }
        /// <p>Contains details about an IAM group.</p>
        pub fn set_aws_iam_group(
            mut self,
            input: std::option::Option<crate::model::AwsIamGroupDetails>,
        ) -> Self {
            self.aws_iam_group = input;
            self
        }
        /// <p>Details about an IAM role.</p>
        pub fn aws_iam_role(mut self, input: crate::model::AwsIamRoleDetails) -> Self {
            self.aws_iam_role = Some(input);
            self
        }
        /// <p>Details about an IAM role.</p>
        pub fn set_aws_iam_role(
            mut self,
            input: std::option::Option<crate::model::AwsIamRoleDetails>,
        ) -> Self {
            self.aws_iam_role = input;
            self
        }
        /// <p>Details about an KMS key.</p>
        pub fn aws_kms_key(mut self, input: crate::model::AwsKmsKeyDetails) -> Self {
            self.aws_kms_key = Some(input);
            self
        }
        /// <p>Details about an KMS key.</p>
        pub fn set_aws_kms_key(
            mut self,
            input: std::option::Option<crate::model::AwsKmsKeyDetails>,
        ) -> Self {
            self.aws_kms_key = input;
            self
        }
        /// <p>Details about a Lambda function.</p>
        pub fn aws_lambda_function(
            mut self,
            input: crate::model::AwsLambdaFunctionDetails,
        ) -> Self {
            self.aws_lambda_function = Some(input);
            self
        }
        /// <p>Details about a Lambda function.</p>
        pub fn set_aws_lambda_function(
            mut self,
            input: std::option::Option<crate::model::AwsLambdaFunctionDetails>,
        ) -> Self {
            self.aws_lambda_function = input;
            self
        }
        /// <p>Details for a Lambda layer version.</p>
        pub fn aws_lambda_layer_version(
            mut self,
            input: crate::model::AwsLambdaLayerVersionDetails,
        ) -> Self {
            self.aws_lambda_layer_version = Some(input);
            self
        }
        /// <p>Details for a Lambda layer version.</p>
        pub fn set_aws_lambda_layer_version(
            mut self,
            input: std::option::Option<crate::model::AwsLambdaLayerVersionDetails>,
        ) -> Self {
            self.aws_lambda_layer_version = input;
            self
        }
        /// <p>Details about an Amazon RDS database instance.</p>
        pub fn aws_rds_db_instance(mut self, input: crate::model::AwsRdsDbInstanceDetails) -> Self {
            self.aws_rds_db_instance = Some(input);
            self
        }
        /// <p>Details about an Amazon RDS database instance.</p>
        pub fn set_aws_rds_db_instance(
            mut self,
            input: std::option::Option<crate::model::AwsRdsDbInstanceDetails>,
        ) -> Self {
            self.aws_rds_db_instance = input;
            self
        }
        /// <p>Details about an SNS topic.</p>
        pub fn aws_sns_topic(mut self, input: crate::model::AwsSnsTopicDetails) -> Self {
            self.aws_sns_topic = Some(input);
            self
        }
        /// <p>Details about an SNS topic.</p>
        pub fn set_aws_sns_topic(
            mut self,
            input: std::option::Option<crate::model::AwsSnsTopicDetails>,
        ) -> Self {
            self.aws_sns_topic = input;
            self
        }
        /// <p>Details about an SQS queue.</p>
        pub fn aws_sqs_queue(mut self, input: crate::model::AwsSqsQueueDetails) -> Self {
            self.aws_sqs_queue = Some(input);
            self
        }
        /// <p>Details about an SQS queue.</p>
        pub fn set_aws_sqs_queue(
            mut self,
            input: std::option::Option<crate::model::AwsSqsQueueDetails>,
        ) -> Self {
            self.aws_sqs_queue = input;
            self
        }
        /// <p>Details for an WAF web ACL.</p>
        pub fn aws_waf_web_acl(mut self, input: crate::model::AwsWafWebAclDetails) -> Self {
            self.aws_waf_web_acl = Some(input);
            self
        }
        /// <p>Details for an WAF web ACL.</p>
        pub fn set_aws_waf_web_acl(
            mut self,
            input: std::option::Option<crate::model::AwsWafWebAclDetails>,
        ) -> Self {
            self.aws_waf_web_acl = input;
            self
        }
        /// <p>Details about an Amazon RDS database snapshot.</p>
        pub fn aws_rds_db_snapshot(mut self, input: crate::model::AwsRdsDbSnapshotDetails) -> Self {
            self.aws_rds_db_snapshot = Some(input);
            self
        }
        /// <p>Details about an Amazon RDS database snapshot.</p>
        pub fn set_aws_rds_db_snapshot(
            mut self,
            input: std::option::Option<crate::model::AwsRdsDbSnapshotDetails>,
        ) -> Self {
            self.aws_rds_db_snapshot = input;
            self
        }
        /// <p>Details about an Amazon RDS database cluster snapshot.</p>
        pub fn aws_rds_db_cluster_snapshot(
            mut self,
            input: crate::model::AwsRdsDbClusterSnapshotDetails,
        ) -> Self {
            self.aws_rds_db_cluster_snapshot = Some(input);
            self
        }
        /// <p>Details about an Amazon RDS database cluster snapshot.</p>
        pub fn set_aws_rds_db_cluster_snapshot(
            mut self,
            input: std::option::Option<crate::model::AwsRdsDbClusterSnapshotDetails>,
        ) -> Self {
            self.aws_rds_db_cluster_snapshot = input;
            self
        }
        /// <p>Details about an Amazon RDS database cluster.</p>
        pub fn aws_rds_db_cluster(mut self, input: crate::model::AwsRdsDbClusterDetails) -> Self {
            self.aws_rds_db_cluster = Some(input);
            self
        }
        /// <p>Details about an Amazon RDS database cluster.</p>
        pub fn set_aws_rds_db_cluster(
            mut self,
            input: std::option::Option<crate::model::AwsRdsDbClusterDetails>,
        ) -> Self {
            self.aws_rds_db_cluster = input;
            self
        }
        /// <p>Details about an Amazon ECS cluster.</p>
        pub fn aws_ecs_cluster(mut self, input: crate::model::AwsEcsClusterDetails) -> Self {
            self.aws_ecs_cluster = Some(input);
            self
        }
        /// <p>Details about an Amazon ECS cluster.</p>
        pub fn set_aws_ecs_cluster(
            mut self,
            input: std::option::Option<crate::model::AwsEcsClusterDetails>,
        ) -> Self {
            self.aws_ecs_cluster = input;
            self
        }
        /// <p>Provides information about a Docker container that's part of a task. </p>
        pub fn aws_ecs_container(mut self, input: crate::model::AwsEcsContainerDetails) -> Self {
            self.aws_ecs_container = Some(input);
            self
        }
        /// <p>Provides information about a Docker container that's part of a task. </p>
        pub fn set_aws_ecs_container(
            mut self,
            input: std::option::Option<crate::model::AwsEcsContainerDetails>,
        ) -> Self {
            self.aws_ecs_container = input;
            self
        }
        /// <p>Details about a task definition. A task definition describes the container and volume definitions of an Amazon Elastic Container Service task.</p>
        pub fn aws_ecs_task_definition(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionDetails,
        ) -> Self {
            self.aws_ecs_task_definition = Some(input);
            self
        }
        /// <p>Details about a task definition. A task definition describes the container and volume definitions of an Amazon Elastic Container Service task.</p>
        pub fn set_aws_ecs_task_definition(
            mut self,
            input: std::option::Option<crate::model::AwsEcsTaskDefinitionDetails>,
        ) -> Self {
            self.aws_ecs_task_definition = input;
            self
        }
        /// <p>Details about a container resource related to a finding.</p>
        pub fn container(mut self, input: crate::model::ContainerDetails) -> Self {
            self.container = Some(input);
            self
        }
        /// <p>Details about a container resource related to a finding.</p>
        pub fn set_container(
            mut self,
            input: std::option::Option<crate::model::ContainerDetails>,
        ) -> Self {
            self.container = input;
            self
        }
        /// Adds a key-value pair to `other`.
        ///
        /// To override the contents of this collection use [`set_other`](Self::set_other).
        ///
        /// <p>Details about a resource that are not available in a type-specific details object. Use the <code>Other</code> object in the following cases.</p>
        /// <ul>
        /// <li> <p>The type-specific object does not contain all of the fields that you want to populate. In this case, first use the type-specific object to populate those fields. Use the <code>Other</code> object to populate the fields that are missing from the type-specific object.</p> </li>
        /// <li> <p>The resource type does not have a corresponding object. This includes resources for which the type is <code>Other</code>. </p> </li>
        /// </ul>
        pub fn other(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.other.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.other = Some(hash_map);
            self
        }
        /// <p>Details about a resource that are not available in a type-specific details object. Use the <code>Other</code> object in the following cases.</p>
        /// <ul>
        /// <li> <p>The type-specific object does not contain all of the fields that you want to populate. In this case, first use the type-specific object to populate those fields. Use the <code>Other</code> object to populate the fields that are missing from the type-specific object.</p> </li>
        /// <li> <p>The resource type does not have a corresponding object. This includes resources for which the type is <code>Other</code>. </p> </li>
        /// </ul>
        pub fn set_other(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.other = input;
            self
        }
        /// <p>Details about an RDS event notification subscription.</p>
        pub fn aws_rds_event_subscription(
            mut self,
            input: crate::model::AwsRdsEventSubscriptionDetails,
        ) -> Self {
            self.aws_rds_event_subscription = Some(input);
            self
        }
        /// <p>Details about an RDS event notification subscription.</p>
        pub fn set_aws_rds_event_subscription(
            mut self,
            input: std::option::Option<crate::model::AwsRdsEventSubscriptionDetails>,
        ) -> Self {
            self.aws_rds_event_subscription = input;
            self
        }
        /// <p>Details about a service within an ECS cluster.</p>
        pub fn aws_ecs_service(mut self, input: crate::model::AwsEcsServiceDetails) -> Self {
            self.aws_ecs_service = Some(input);
            self
        }
        /// <p>Details about a service within an ECS cluster.</p>
        pub fn set_aws_ecs_service(
            mut self,
            input: std::option::Option<crate::model::AwsEcsServiceDetails>,
        ) -> Self {
            self.aws_ecs_service = input;
            self
        }
        /// <p>Provides details about a launch configuration.</p>
        pub fn aws_auto_scaling_launch_configuration(
            mut self,
            input: crate::model::AwsAutoScalingLaunchConfigurationDetails,
        ) -> Self {
            self.aws_auto_scaling_launch_configuration = Some(input);
            self
        }
        /// <p>Provides details about a launch configuration.</p>
        pub fn set_aws_auto_scaling_launch_configuration(
            mut self,
            input: std::option::Option<crate::model::AwsAutoScalingLaunchConfigurationDetails>,
        ) -> Self {
            self.aws_auto_scaling_launch_configuration = input;
            self
        }
        /// <p>Details about an Amazon EC2 VPN connection.</p>
        pub fn aws_ec2_vpn_connection(
            mut self,
            input: crate::model::AwsEc2VpnConnectionDetails,
        ) -> Self {
            self.aws_ec2_vpn_connection = Some(input);
            self
        }
        /// <p>Details about an Amazon EC2 VPN connection.</p>
        pub fn set_aws_ec2_vpn_connection(
            mut self,
            input: std::option::Option<crate::model::AwsEc2VpnConnectionDetails>,
        ) -> Self {
            self.aws_ec2_vpn_connection = input;
            self
        }
        /// <p>Information about an Amazon ECR image.</p>
        pub fn aws_ecr_container_image(
            mut self,
            input: crate::model::AwsEcrContainerImageDetails,
        ) -> Self {
            self.aws_ecr_container_image = Some(input);
            self
        }
        /// <p>Information about an Amazon ECR image.</p>
        pub fn set_aws_ecr_container_image(
            mut self,
            input: std::option::Option<crate::model::AwsEcrContainerImageDetails>,
        ) -> Self {
            self.aws_ecr_container_image = input;
            self
        }
        /// <p>Details about an Amazon OpenSearch Service domain.</p>
        pub fn aws_open_search_service_domain(
            mut self,
            input: crate::model::AwsOpenSearchServiceDomainDetails,
        ) -> Self {
            self.aws_open_search_service_domain = Some(input);
            self
        }
        /// <p>Details about an Amazon OpenSearch Service domain.</p>
        pub fn set_aws_open_search_service_domain(
            mut self,
            input: std::option::Option<crate::model::AwsOpenSearchServiceDomainDetails>,
        ) -> Self {
            self.aws_open_search_service_domain = input;
            self
        }
        /// <p>Details about the service configuration for a VPC endpoint service.</p>
        pub fn aws_ec2_vpc_endpoint_service(
            mut self,
            input: crate::model::AwsEc2VpcEndpointServiceDetails,
        ) -> Self {
            self.aws_ec2_vpc_endpoint_service = Some(input);
            self
        }
        /// <p>Details about the service configuration for a VPC endpoint service.</p>
        pub fn set_aws_ec2_vpc_endpoint_service(
            mut self,
            input: std::option::Option<crate::model::AwsEc2VpcEndpointServiceDetails>,
        ) -> Self {
            self.aws_ec2_vpc_endpoint_service = input;
            self
        }
        /// <p>Information about the encryption configuration for X-Ray.</p>
        pub fn aws_xray_encryption_config(
            mut self,
            input: crate::model::AwsXrayEncryptionConfigDetails,
        ) -> Self {
            self.aws_xray_encryption_config = Some(input);
            self
        }
        /// <p>Information about the encryption configuration for X-Ray.</p>
        pub fn set_aws_xray_encryption_config(
            mut self,
            input: std::option::Option<crate::model::AwsXrayEncryptionConfigDetails>,
        ) -> Self {
            self.aws_xray_encryption_config = input;
            self
        }
        /// <p>Details about a rate-based rule for global resources.</p>
        pub fn aws_waf_rate_based_rule(
            mut self,
            input: crate::model::AwsWafRateBasedRuleDetails,
        ) -> Self {
            self.aws_waf_rate_based_rule = Some(input);
            self
        }
        /// <p>Details about a rate-based rule for global resources.</p>
        pub fn set_aws_waf_rate_based_rule(
            mut self,
            input: std::option::Option<crate::model::AwsWafRateBasedRuleDetails>,
        ) -> Self {
            self.aws_waf_rate_based_rule = input;
            self
        }
        /// <p>Details about a rate-based rule for Regional resources.</p>
        pub fn aws_waf_regional_rate_based_rule(
            mut self,
            input: crate::model::AwsWafRegionalRateBasedRuleDetails,
        ) -> Self {
            self.aws_waf_regional_rate_based_rule = Some(input);
            self
        }
        /// <p>Details about a rate-based rule for Regional resources.</p>
        pub fn set_aws_waf_regional_rate_based_rule(
            mut self,
            input: std::option::Option<crate::model::AwsWafRegionalRateBasedRuleDetails>,
        ) -> Self {
            self.aws_waf_regional_rate_based_rule = input;
            self
        }
        /// <p>Information about an Amazon Elastic Container Registry repository.</p>
        pub fn aws_ecr_repository(mut self, input: crate::model::AwsEcrRepositoryDetails) -> Self {
            self.aws_ecr_repository = Some(input);
            self
        }
        /// <p>Information about an Amazon Elastic Container Registry repository.</p>
        pub fn set_aws_ecr_repository(
            mut self,
            input: std::option::Option<crate::model::AwsEcrRepositoryDetails>,
        ) -> Self {
            self.aws_ecr_repository = input;
            self
        }
        /// <p>Details about an Amazon EKS cluster.</p>
        pub fn aws_eks_cluster(mut self, input: crate::model::AwsEksClusterDetails) -> Self {
            self.aws_eks_cluster = Some(input);
            self
        }
        /// <p>Details about an Amazon EKS cluster.</p>
        pub fn set_aws_eks_cluster(
            mut self,
            input: std::option::Option<crate::model::AwsEksClusterDetails>,
        ) -> Self {
            self.aws_eks_cluster = input;
            self
        }
        /// <p>Details about an Network Firewall firewall policy.</p>
        pub fn aws_network_firewall_firewall_policy(
            mut self,
            input: crate::model::AwsNetworkFirewallFirewallPolicyDetails,
        ) -> Self {
            self.aws_network_firewall_firewall_policy = Some(input);
            self
        }
        /// <p>Details about an Network Firewall firewall policy.</p>
        pub fn set_aws_network_firewall_firewall_policy(
            mut self,
            input: std::option::Option<crate::model::AwsNetworkFirewallFirewallPolicyDetails>,
        ) -> Self {
            self.aws_network_firewall_firewall_policy = input;
            self
        }
        /// <p>Details about an Network Firewall firewall.</p>
        pub fn aws_network_firewall_firewall(
            mut self,
            input: crate::model::AwsNetworkFirewallFirewallDetails,
        ) -> Self {
            self.aws_network_firewall_firewall = Some(input);
            self
        }
        /// <p>Details about an Network Firewall firewall.</p>
        pub fn set_aws_network_firewall_firewall(
            mut self,
            input: std::option::Option<crate::model::AwsNetworkFirewallFirewallDetails>,
        ) -> Self {
            self.aws_network_firewall_firewall = input;
            self
        }
        /// <p>Details about an Network Firewall rule group.</p>
        pub fn aws_network_firewall_rule_group(
            mut self,
            input: crate::model::AwsNetworkFirewallRuleGroupDetails,
        ) -> Self {
            self.aws_network_firewall_rule_group = Some(input);
            self
        }
        /// <p>Details about an Network Firewall rule group.</p>
        pub fn set_aws_network_firewall_rule_group(
            mut self,
            input: std::option::Option<crate::model::AwsNetworkFirewallRuleGroupDetails>,
        ) -> Self {
            self.aws_network_firewall_rule_group = input;
            self
        }
        /// <p>Details about an Amazon RDS DB security group.</p>
        pub fn aws_rds_db_security_group(
            mut self,
            input: crate::model::AwsRdsDbSecurityGroupDetails,
        ) -> Self {
            self.aws_rds_db_security_group = Some(input);
            self
        }
        /// <p>Details about an Amazon RDS DB security group.</p>
        pub fn set_aws_rds_db_security_group(
            mut self,
            input: std::option::Option<crate::model::AwsRdsDbSecurityGroupDetails>,
        ) -> Self {
            self.aws_rds_db_security_group = input;
            self
        }
        /// <p>Details about an Amazon Kinesis data stream.</p>
        pub fn aws_kinesis_stream(mut self, input: crate::model::AwsKinesisStreamDetails) -> Self {
            self.aws_kinesis_stream = Some(input);
            self
        }
        /// <p>Details about an Amazon Kinesis data stream.</p>
        pub fn set_aws_kinesis_stream(
            mut self,
            input: std::option::Option<crate::model::AwsKinesisStreamDetails>,
        ) -> Self {
            self.aws_kinesis_stream = input;
            self
        }
        /// <p>Details about an Amazon EC2 transit gateway that interconnects your virtual private clouds (VPC) and on-premises networks.</p>
        pub fn aws_ec2_transit_gateway(
            mut self,
            input: crate::model::AwsEc2TransitGatewayDetails,
        ) -> Self {
            self.aws_ec2_transit_gateway = Some(input);
            self
        }
        /// <p>Details about an Amazon EC2 transit gateway that interconnects your virtual private clouds (VPC) and on-premises networks.</p>
        pub fn set_aws_ec2_transit_gateway(
            mut self,
            input: std::option::Option<crate::model::AwsEc2TransitGatewayDetails>,
        ) -> Self {
            self.aws_ec2_transit_gateway = input;
            self
        }
        /// <p>Details about an Amazon EFS access point. An access point is an application-specific view into an EFS file system that applies an operating system user and group, and a file system path, to any file system request made through the access point. </p>
        pub fn aws_efs_access_point(
            mut self,
            input: crate::model::AwsEfsAccessPointDetails,
        ) -> Self {
            self.aws_efs_access_point = Some(input);
            self
        }
        /// <p>Details about an Amazon EFS access point. An access point is an application-specific view into an EFS file system that applies an operating system user and group, and a file system path, to any file system request made through the access point. </p>
        pub fn set_aws_efs_access_point(
            mut self,
            input: std::option::Option<crate::model::AwsEfsAccessPointDetails>,
        ) -> Self {
            self.aws_efs_access_point = input;
            self
        }
        /// <p>Details about an CloudFormation stack. A stack is a collection of Amazon Web Services resources that you can manage as a single unit.</p>
        pub fn aws_cloud_formation_stack(
            mut self,
            input: crate::model::AwsCloudFormationStackDetails,
        ) -> Self {
            self.aws_cloud_formation_stack = Some(input);
            self
        }
        /// <p>Details about an CloudFormation stack. A stack is a collection of Amazon Web Services resources that you can manage as a single unit.</p>
        pub fn set_aws_cloud_formation_stack(
            mut self,
            input: std::option::Option<crate::model::AwsCloudFormationStackDetails>,
        ) -> Self {
            self.aws_cloud_formation_stack = input;
            self
        }
        /// <p>Details about an Amazon CloudWatch alarm. An alarm allows you to monitor and receive alerts about your Amazon Web Services resources and applications across multiple Regions.</p>
        pub fn aws_cloud_watch_alarm(
            mut self,
            input: crate::model::AwsCloudWatchAlarmDetails,
        ) -> Self {
            self.aws_cloud_watch_alarm = Some(input);
            self
        }
        /// <p>Details about an Amazon CloudWatch alarm. An alarm allows you to monitor and receive alerts about your Amazon Web Services resources and applications across multiple Regions.</p>
        pub fn set_aws_cloud_watch_alarm(
            mut self,
            input: std::option::Option<crate::model::AwsCloudWatchAlarmDetails>,
        ) -> Self {
            self.aws_cloud_watch_alarm = input;
            self
        }
        /// <p>Details about an Amazon EC2 VPC peering connection. A VPC peering connection is a networking connection between two VPCs that enables you to route traffic between them privately. </p>
        pub fn aws_ec2_vpc_peering_connection(
            mut self,
            input: crate::model::AwsEc2VpcPeeringConnectionDetails,
        ) -> Self {
            self.aws_ec2_vpc_peering_connection = Some(input);
            self
        }
        /// <p>Details about an Amazon EC2 VPC peering connection. A VPC peering connection is a networking connection between two VPCs that enables you to route traffic between them privately. </p>
        pub fn set_aws_ec2_vpc_peering_connection(
            mut self,
            input: std::option::Option<crate::model::AwsEc2VpcPeeringConnectionDetails>,
        ) -> Self {
            self.aws_ec2_vpc_peering_connection = input;
            self
        }
        /// <p>Details about an WAF rule group for Regional resources. </p>
        pub fn aws_waf_regional_rule_group(
            mut self,
            input: crate::model::AwsWafRegionalRuleGroupDetails,
        ) -> Self {
            self.aws_waf_regional_rule_group = Some(input);
            self
        }
        /// <p>Details about an WAF rule group for Regional resources. </p>
        pub fn set_aws_waf_regional_rule_group(
            mut self,
            input: std::option::Option<crate::model::AwsWafRegionalRuleGroupDetails>,
        ) -> Self {
            self.aws_waf_regional_rule_group = input;
            self
        }
        /// <p>Details about an WAF rule for Regional resources. </p>
        pub fn aws_waf_regional_rule(
            mut self,
            input: crate::model::AwsWafRegionalRuleDetails,
        ) -> Self {
            self.aws_waf_regional_rule = Some(input);
            self
        }
        /// <p>Details about an WAF rule for Regional resources. </p>
        pub fn set_aws_waf_regional_rule(
            mut self,
            input: std::option::Option<crate::model::AwsWafRegionalRuleDetails>,
        ) -> Self {
            self.aws_waf_regional_rule = input;
            self
        }
        /// <p>Details about an WAF web access control list (web ACL) for Regional resources. </p>
        pub fn aws_waf_regional_web_acl(
            mut self,
            input: crate::model::AwsWafRegionalWebAclDetails,
        ) -> Self {
            self.aws_waf_regional_web_acl = Some(input);
            self
        }
        /// <p>Details about an WAF web access control list (web ACL) for Regional resources. </p>
        pub fn set_aws_waf_regional_web_acl(
            mut self,
            input: std::option::Option<crate::model::AwsWafRegionalWebAclDetails>,
        ) -> Self {
            self.aws_waf_regional_web_acl = input;
            self
        }
        /// <p>Details about an WAF rule for global resources. </p>
        pub fn aws_waf_rule(mut self, input: crate::model::AwsWafRuleDetails) -> Self {
            self.aws_waf_rule = Some(input);
            self
        }
        /// <p>Details about an WAF rule for global resources. </p>
        pub fn set_aws_waf_rule(
            mut self,
            input: std::option::Option<crate::model::AwsWafRuleDetails>,
        ) -> Self {
            self.aws_waf_rule = input;
            self
        }
        /// <p>Details about an WAF rule group for global resources. </p>
        pub fn aws_waf_rule_group(mut self, input: crate::model::AwsWafRuleGroupDetails) -> Self {
            self.aws_waf_rule_group = Some(input);
            self
        }
        /// <p>Details about an WAF rule group for global resources. </p>
        pub fn set_aws_waf_rule_group(
            mut self,
            input: std::option::Option<crate::model::AwsWafRuleGroupDetails>,
        ) -> Self {
            self.aws_waf_rule_group = input;
            self
        }
        /// <p>Details about a task in a cluster. </p>
        pub fn aws_ecs_task(mut self, input: crate::model::AwsEcsTaskDetails) -> Self {
            self.aws_ecs_task = Some(input);
            self
        }
        /// <p>Details about a task in a cluster. </p>
        pub fn set_aws_ecs_task(
            mut self,
            input: std::option::Option<crate::model::AwsEcsTaskDetails>,
        ) -> Self {
            self.aws_ecs_task = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceDetails`](crate::model::ResourceDetails)
        pub fn build(self) -> crate::model::ResourceDetails {
            crate::model::ResourceDetails {
                aws_auto_scaling_auto_scaling_group: self.aws_auto_scaling_auto_scaling_group,
                aws_code_build_project: self.aws_code_build_project,
                aws_cloud_front_distribution: self.aws_cloud_front_distribution,
                aws_ec2_instance: self.aws_ec2_instance,
                aws_ec2_network_interface: self.aws_ec2_network_interface,
                aws_ec2_security_group: self.aws_ec2_security_group,
                aws_ec2_volume: self.aws_ec2_volume,
                aws_ec2_vpc: self.aws_ec2_vpc,
                aws_ec2_eip: self.aws_ec2_eip,
                aws_ec2_subnet: self.aws_ec2_subnet,
                aws_ec2_network_acl: self.aws_ec2_network_acl,
                aws_elbv2_load_balancer: self.aws_elbv2_load_balancer,
                aws_elastic_beanstalk_environment: self.aws_elastic_beanstalk_environment,
                aws_elasticsearch_domain: self.aws_elasticsearch_domain,
                aws_s3_bucket: self.aws_s3_bucket,
                aws_s3_account_public_access_block: self.aws_s3_account_public_access_block,
                aws_s3_object: self.aws_s3_object,
                aws_secrets_manager_secret: self.aws_secrets_manager_secret,
                aws_iam_access_key: self.aws_iam_access_key,
                aws_iam_user: self.aws_iam_user,
                aws_iam_policy: self.aws_iam_policy,
                aws_api_gateway_v2_stage: self.aws_api_gateway_v2_stage,
                aws_api_gateway_v2_api: self.aws_api_gateway_v2_api,
                aws_dynamo_db_table: self.aws_dynamo_db_table,
                aws_api_gateway_stage: self.aws_api_gateway_stage,
                aws_api_gateway_rest_api: self.aws_api_gateway_rest_api,
                aws_cloud_trail_trail: self.aws_cloud_trail_trail,
                aws_ssm_patch_compliance: self.aws_ssm_patch_compliance,
                aws_certificate_manager_certificate: self.aws_certificate_manager_certificate,
                aws_redshift_cluster: self.aws_redshift_cluster,
                aws_elb_load_balancer: self.aws_elb_load_balancer,
                aws_iam_group: self.aws_iam_group,
                aws_iam_role: self.aws_iam_role,
                aws_kms_key: self.aws_kms_key,
                aws_lambda_function: self.aws_lambda_function,
                aws_lambda_layer_version: self.aws_lambda_layer_version,
                aws_rds_db_instance: self.aws_rds_db_instance,
                aws_sns_topic: self.aws_sns_topic,
                aws_sqs_queue: self.aws_sqs_queue,
                aws_waf_web_acl: self.aws_waf_web_acl,
                aws_rds_db_snapshot: self.aws_rds_db_snapshot,
                aws_rds_db_cluster_snapshot: self.aws_rds_db_cluster_snapshot,
                aws_rds_db_cluster: self.aws_rds_db_cluster,
                aws_ecs_cluster: self.aws_ecs_cluster,
                aws_ecs_container: self.aws_ecs_container,
                aws_ecs_task_definition: self.aws_ecs_task_definition,
                container: self.container,
                other: self.other,
                aws_rds_event_subscription: self.aws_rds_event_subscription,
                aws_ecs_service: self.aws_ecs_service,
                aws_auto_scaling_launch_configuration: self.aws_auto_scaling_launch_configuration,
                aws_ec2_vpn_connection: self.aws_ec2_vpn_connection,
                aws_ecr_container_image: self.aws_ecr_container_image,
                aws_open_search_service_domain: self.aws_open_search_service_domain,
                aws_ec2_vpc_endpoint_service: self.aws_ec2_vpc_endpoint_service,
                aws_xray_encryption_config: self.aws_xray_encryption_config,
                aws_waf_rate_based_rule: self.aws_waf_rate_based_rule,
                aws_waf_regional_rate_based_rule: self.aws_waf_regional_rate_based_rule,
                aws_ecr_repository: self.aws_ecr_repository,
                aws_eks_cluster: self.aws_eks_cluster,
                aws_network_firewall_firewall_policy: self.aws_network_firewall_firewall_policy,
                aws_network_firewall_firewall: self.aws_network_firewall_firewall,
                aws_network_firewall_rule_group: self.aws_network_firewall_rule_group,
                aws_rds_db_security_group: self.aws_rds_db_security_group,
                aws_kinesis_stream: self.aws_kinesis_stream,
                aws_ec2_transit_gateway: self.aws_ec2_transit_gateway,
                aws_efs_access_point: self.aws_efs_access_point,
                aws_cloud_formation_stack: self.aws_cloud_formation_stack,
                aws_cloud_watch_alarm: self.aws_cloud_watch_alarm,
                aws_ec2_vpc_peering_connection: self.aws_ec2_vpc_peering_connection,
                aws_waf_regional_rule_group: self.aws_waf_regional_rule_group,
                aws_waf_regional_rule: self.aws_waf_regional_rule,
                aws_waf_regional_web_acl: self.aws_waf_regional_web_acl,
                aws_waf_rule: self.aws_waf_rule,
                aws_waf_rule_group: self.aws_waf_rule_group,
                aws_ecs_task: self.aws_ecs_task,
            }
        }
    }
}
impl ResourceDetails {
    /// Creates a new builder-style object to manufacture [`ResourceDetails`](crate::model::ResourceDetails)
    pub fn builder() -> crate::model::resource_details::Builder {
        crate::model::resource_details::Builder::default()
    }
}

/// <p>Provides details about a task in a cluster. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDetails {
    /// <p>The Amazon Resource Name (ARN) of the cluster that hosts the task. </p>
    pub cluster_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the task definition that creates the task. </p>
    pub task_definition_arn: std::option::Option<std::string::String>,
    /// <p>The version counter for the task. </p>
    pub version: std::option::Option<std::string::String>,
    /// <p>The Unix timestamp for the time when the task was created. More specifically, it's for the time when the task entered the <code>PENDING</code> state. </p>
    pub created_at: std::option::Option<std::string::String>,
    /// <p>The Unix timestamp for the time when the task started. More specifically, it's for the time when the task transitioned from the <code>PENDING</code> state to the <code>RUNNING</code> state. </p>
    pub started_at: std::option::Option<std::string::String>,
    /// <p>The tag specified when a task is started. If an Amazon ECS service started the task, the <code>startedBy</code> parameter contains the deployment ID of that service. </p>
    pub started_by: std::option::Option<std::string::String>,
    /// <p>The name of the task group that's associated with the task. </p>
    pub group: std::option::Option<std::string::String>,
    /// <p>Details about the data volume that is used in a task definition. </p>
    pub volumes: std::option::Option<std::vec::Vec<crate::model::AwsEcsTaskVolumeDetails>>,
    /// <p>The containers that are associated with the task. </p>
    pub containers: std::option::Option<std::vec::Vec<crate::model::AwsEcsContainerDetails>>,
}
impl AwsEcsTaskDetails {
    /// <p>The Amazon Resource Name (ARN) of the cluster that hosts the task. </p>
    pub fn cluster_arn(&self) -> std::option::Option<&str> {
        self.cluster_arn.as_deref()
    }
    /// <p>The ARN of the task definition that creates the task. </p>
    pub fn task_definition_arn(&self) -> std::option::Option<&str> {
        self.task_definition_arn.as_deref()
    }
    /// <p>The version counter for the task. </p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
    /// <p>The Unix timestamp for the time when the task was created. More specifically, it's for the time when the task entered the <code>PENDING</code> state. </p>
    pub fn created_at(&self) -> std::option::Option<&str> {
        self.created_at.as_deref()
    }
    /// <p>The Unix timestamp for the time when the task started. More specifically, it's for the time when the task transitioned from the <code>PENDING</code> state to the <code>RUNNING</code> state. </p>
    pub fn started_at(&self) -> std::option::Option<&str> {
        self.started_at.as_deref()
    }
    /// <p>The tag specified when a task is started. If an Amazon ECS service started the task, the <code>startedBy</code> parameter contains the deployment ID of that service. </p>
    pub fn started_by(&self) -> std::option::Option<&str> {
        self.started_by.as_deref()
    }
    /// <p>The name of the task group that's associated with the task. </p>
    pub fn group(&self) -> std::option::Option<&str> {
        self.group.as_deref()
    }
    /// <p>Details about the data volume that is used in a task definition. </p>
    pub fn volumes(&self) -> std::option::Option<&[crate::model::AwsEcsTaskVolumeDetails]> {
        self.volumes.as_deref()
    }
    /// <p>The containers that are associated with the task. </p>
    pub fn containers(&self) -> std::option::Option<&[crate::model::AwsEcsContainerDetails]> {
        self.containers.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsTaskDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcsTaskDetails");
        formatter.field("cluster_arn", &self.cluster_arn);
        formatter.field("task_definition_arn", &self.task_definition_arn);
        formatter.field("version", &self.version);
        formatter.field("created_at", &self.created_at);
        formatter.field("started_at", &self.started_at);
        formatter.field("started_by", &self.started_by);
        formatter.field("group", &self.group);
        formatter.field("volumes", &self.volumes);
        formatter.field("containers", &self.containers);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDetails`](crate::model::AwsEcsTaskDetails)
pub mod aws_ecs_task_details {

    /// A builder for [`AwsEcsTaskDetails`](crate::model::AwsEcsTaskDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cluster_arn: std::option::Option<std::string::String>,
        pub(crate) task_definition_arn: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<std::string::String>,
        pub(crate) started_at: std::option::Option<std::string::String>,
        pub(crate) started_by: std::option::Option<std::string::String>,
        pub(crate) group: std::option::Option<std::string::String>,
        pub(crate) volumes:
            std::option::Option<std::vec::Vec<crate::model::AwsEcsTaskVolumeDetails>>,
        pub(crate) containers:
            std::option::Option<std::vec::Vec<crate::model::AwsEcsContainerDetails>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the cluster that hosts the task. </p>
        pub fn cluster_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the cluster that hosts the task. </p>
        pub fn set_cluster_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cluster_arn = input;
            self
        }
        /// <p>The ARN of the task definition that creates the task. </p>
        pub fn task_definition_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_definition_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the task definition that creates the task. </p>
        pub fn set_task_definition_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.task_definition_arn = input;
            self
        }
        /// <p>The version counter for the task. </p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The version counter for the task. </p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// <p>The Unix timestamp for the time when the task was created. More specifically, it's for the time when the task entered the <code>PENDING</code> state. </p>
        pub fn created_at(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_at = Some(input.into());
            self
        }
        /// <p>The Unix timestamp for the time when the task was created. More specifically, it's for the time when the task entered the <code>PENDING</code> state. </p>
        pub fn set_created_at(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The Unix timestamp for the time when the task started. More specifically, it's for the time when the task transitioned from the <code>PENDING</code> state to the <code>RUNNING</code> state. </p>
        pub fn started_at(mut self, input: impl Into<std::string::String>) -> Self {
            self.started_at = Some(input.into());
            self
        }
        /// <p>The Unix timestamp for the time when the task started. More specifically, it's for the time when the task transitioned from the <code>PENDING</code> state to the <code>RUNNING</code> state. </p>
        pub fn set_started_at(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.started_at = input;
            self
        }
        /// <p>The tag specified when a task is started. If an Amazon ECS service started the task, the <code>startedBy</code> parameter contains the deployment ID of that service. </p>
        pub fn started_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.started_by = Some(input.into());
            self
        }
        /// <p>The tag specified when a task is started. If an Amazon ECS service started the task, the <code>startedBy</code> parameter contains the deployment ID of that service. </p>
        pub fn set_started_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.started_by = input;
            self
        }
        /// <p>The name of the task group that's associated with the task. </p>
        pub fn group(mut self, input: impl Into<std::string::String>) -> Self {
            self.group = Some(input.into());
            self
        }
        /// <p>The name of the task group that's associated with the task. </p>
        pub fn set_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group = input;
            self
        }
        /// Appends an item to `volumes`.
        ///
        /// To override the contents of this collection use [`set_volumes`](Self::set_volumes).
        ///
        /// <p>Details about the data volume that is used in a task definition. </p>
        pub fn volumes(mut self, input: crate::model::AwsEcsTaskVolumeDetails) -> Self {
            let mut v = self.volumes.unwrap_or_default();
            v.push(input);
            self.volumes = Some(v);
            self
        }
        /// <p>Details about the data volume that is used in a task definition. </p>
        pub fn set_volumes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsEcsTaskVolumeDetails>>,
        ) -> Self {
            self.volumes = input;
            self
        }
        /// Appends an item to `containers`.
        ///
        /// To override the contents of this collection use [`set_containers`](Self::set_containers).
        ///
        /// <p>The containers that are associated with the task. </p>
        pub fn containers(mut self, input: crate::model::AwsEcsContainerDetails) -> Self {
            let mut v = self.containers.unwrap_or_default();
            v.push(input);
            self.containers = Some(v);
            self
        }
        /// <p>The containers that are associated with the task. </p>
        pub fn set_containers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsEcsContainerDetails>>,
        ) -> Self {
            self.containers = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDetails`](crate::model::AwsEcsTaskDetails)
        pub fn build(self) -> crate::model::AwsEcsTaskDetails {
            crate::model::AwsEcsTaskDetails {
                cluster_arn: self.cluster_arn,
                task_definition_arn: self.task_definition_arn,
                version: self.version,
                created_at: self.created_at,
                started_at: self.started_at,
                started_by: self.started_by,
                group: self.group,
                volumes: self.volumes,
                containers: self.containers,
            }
        }
    }
}
impl AwsEcsTaskDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDetails`](crate::model::AwsEcsTaskDetails)
    pub fn builder() -> crate::model::aws_ecs_task_details::Builder {
        crate::model::aws_ecs_task_details::Builder::default()
    }
}

/// <p>Provides information about an Amazon ECS container. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsContainerDetails {
    /// <p>The name of the container. </p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The image used for the container. </p>
    pub image: std::option::Option<std::string::String>,
    /// <p>The mount points for data volumes in your container. </p>
    pub mount_points: std::option::Option<std::vec::Vec<crate::model::AwsMountPoint>>,
    /// <p>When this parameter is true, the container is given elevated privileges on the host container instance (similar to the root user). </p>
    pub privileged: bool,
}
impl AwsEcsContainerDetails {
    /// <p>The name of the container. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The image used for the container. </p>
    pub fn image(&self) -> std::option::Option<&str> {
        self.image.as_deref()
    }
    /// <p>The mount points for data volumes in your container. </p>
    pub fn mount_points(&self) -> std::option::Option<&[crate::model::AwsMountPoint]> {
        self.mount_points.as_deref()
    }
    /// <p>When this parameter is true, the container is given elevated privileges on the host container instance (similar to the root user). </p>
    pub fn privileged(&self) -> bool {
        self.privileged
    }
}
impl std::fmt::Debug for AwsEcsContainerDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcsContainerDetails");
        formatter.field("name", &self.name);
        formatter.field("image", &self.image);
        formatter.field("mount_points", &self.mount_points);
        formatter.field("privileged", &self.privileged);
        formatter.finish()
    }
}
/// See [`AwsEcsContainerDetails`](crate::model::AwsEcsContainerDetails)
pub mod aws_ecs_container_details {

    /// A builder for [`AwsEcsContainerDetails`](crate::model::AwsEcsContainerDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) image: std::option::Option<std::string::String>,
        pub(crate) mount_points: std::option::Option<std::vec::Vec<crate::model::AwsMountPoint>>,
        pub(crate) privileged: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the container. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the container. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The image used for the container. </p>
        pub fn image(mut self, input: impl Into<std::string::String>) -> Self {
            self.image = Some(input.into());
            self
        }
        /// <p>The image used for the container. </p>
        pub fn set_image(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image = input;
            self
        }
        /// Appends an item to `mount_points`.
        ///
        /// To override the contents of this collection use [`set_mount_points`](Self::set_mount_points).
        ///
        /// <p>The mount points for data volumes in your container. </p>
        pub fn mount_points(mut self, input: crate::model::AwsMountPoint) -> Self {
            let mut v = self.mount_points.unwrap_or_default();
            v.push(input);
            self.mount_points = Some(v);
            self
        }
        /// <p>The mount points for data volumes in your container. </p>
        pub fn set_mount_points(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsMountPoint>>,
        ) -> Self {
            self.mount_points = input;
            self
        }
        /// <p>When this parameter is true, the container is given elevated privileges on the host container instance (similar to the root user). </p>
        pub fn privileged(mut self, input: bool) -> Self {
            self.privileged = Some(input);
            self
        }
        /// <p>When this parameter is true, the container is given elevated privileges on the host container instance (similar to the root user). </p>
        pub fn set_privileged(mut self, input: std::option::Option<bool>) -> Self {
            self.privileged = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsContainerDetails`](crate::model::AwsEcsContainerDetails)
        pub fn build(self) -> crate::model::AwsEcsContainerDetails {
            crate::model::AwsEcsContainerDetails {
                name: self.name,
                image: self.image,
                mount_points: self.mount_points,
                privileged: self.privileged.unwrap_or_default(),
            }
        }
    }
}
impl AwsEcsContainerDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsContainerDetails`](crate::model::AwsEcsContainerDetails)
    pub fn builder() -> crate::model::aws_ecs_container_details::Builder {
        crate::model::aws_ecs_container_details::Builder::default()
    }
}

/// <p>Details for a volume mount point that's used in a container definition. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsMountPoint {
    /// <p>The name of the volume to mount. Must be a volume name referenced in the <code>name</code> parameter of task definition <code>volume</code>. </p>
    pub source_volume: std::option::Option<std::string::String>,
    /// <p>The path on the container to mount the host volume at. </p>
    pub container_path: std::option::Option<std::string::String>,
}
impl AwsMountPoint {
    /// <p>The name of the volume to mount. Must be a volume name referenced in the <code>name</code> parameter of task definition <code>volume</code>. </p>
    pub fn source_volume(&self) -> std::option::Option<&str> {
        self.source_volume.as_deref()
    }
    /// <p>The path on the container to mount the host volume at. </p>
    pub fn container_path(&self) -> std::option::Option<&str> {
        self.container_path.as_deref()
    }
}
impl std::fmt::Debug for AwsMountPoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsMountPoint");
        formatter.field("source_volume", &self.source_volume);
        formatter.field("container_path", &self.container_path);
        formatter.finish()
    }
}
/// See [`AwsMountPoint`](crate::model::AwsMountPoint)
pub mod aws_mount_point {

    /// A builder for [`AwsMountPoint`](crate::model::AwsMountPoint)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_volume: std::option::Option<std::string::String>,
        pub(crate) container_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the volume to mount. Must be a volume name referenced in the <code>name</code> parameter of task definition <code>volume</code>. </p>
        pub fn source_volume(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_volume = Some(input.into());
            self
        }
        /// <p>The name of the volume to mount. Must be a volume name referenced in the <code>name</code> parameter of task definition <code>volume</code>. </p>
        pub fn set_source_volume(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_volume = input;
            self
        }
        /// <p>The path on the container to mount the host volume at. </p>
        pub fn container_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.container_path = Some(input.into());
            self
        }
        /// <p>The path on the container to mount the host volume at. </p>
        pub fn set_container_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.container_path = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsMountPoint`](crate::model::AwsMountPoint)
        pub fn build(self) -> crate::model::AwsMountPoint {
            crate::model::AwsMountPoint {
                source_volume: self.source_volume,
                container_path: self.container_path,
            }
        }
    }
}
impl AwsMountPoint {
    /// Creates a new builder-style object to manufacture [`AwsMountPoint`](crate::model::AwsMountPoint)
    pub fn builder() -> crate::model::aws_mount_point::Builder {
        crate::model::aws_mount_point::Builder::default()
    }
}

/// <p>Provides information about a data volume that's used in a task definition. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskVolumeDetails {
    /// <p>The name of the volume. Up to 255 letters (uppercase and lowercase), numbers, underscores, and hyphens are allowed. This name is referenced in the <code>sourceVolume</code> parameter of container definition <code>mountPoints</code>. </p>
    pub name: std::option::Option<std::string::String>,
    /// <p>This parameter is specified when you use bind mount host volumes. The contents of the <code>host</code> parameter determine whether your bind mount host volume persists on the host container instance and where it's stored. </p>
    pub host: std::option::Option<crate::model::AwsEcsTaskVolumeHostDetails>,
}
impl AwsEcsTaskVolumeDetails {
    /// <p>The name of the volume. Up to 255 letters (uppercase and lowercase), numbers, underscores, and hyphens are allowed. This name is referenced in the <code>sourceVolume</code> parameter of container definition <code>mountPoints</code>. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>This parameter is specified when you use bind mount host volumes. The contents of the <code>host</code> parameter determine whether your bind mount host volume persists on the host container instance and where it's stored. </p>
    pub fn host(&self) -> std::option::Option<&crate::model::AwsEcsTaskVolumeHostDetails> {
        self.host.as_ref()
    }
}
impl std::fmt::Debug for AwsEcsTaskVolumeDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcsTaskVolumeDetails");
        formatter.field("name", &self.name);
        formatter.field("host", &self.host);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskVolumeDetails`](crate::model::AwsEcsTaskVolumeDetails)
pub mod aws_ecs_task_volume_details {

    /// A builder for [`AwsEcsTaskVolumeDetails`](crate::model::AwsEcsTaskVolumeDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) host: std::option::Option<crate::model::AwsEcsTaskVolumeHostDetails>,
    }
    impl Builder {
        /// <p>The name of the volume. Up to 255 letters (uppercase and lowercase), numbers, underscores, and hyphens are allowed. This name is referenced in the <code>sourceVolume</code> parameter of container definition <code>mountPoints</code>. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the volume. Up to 255 letters (uppercase and lowercase), numbers, underscores, and hyphens are allowed. This name is referenced in the <code>sourceVolume</code> parameter of container definition <code>mountPoints</code>. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>This parameter is specified when you use bind mount host volumes. The contents of the <code>host</code> parameter determine whether your bind mount host volume persists on the host container instance and where it's stored. </p>
        pub fn host(mut self, input: crate::model::AwsEcsTaskVolumeHostDetails) -> Self {
            self.host = Some(input);
            self
        }
        /// <p>This parameter is specified when you use bind mount host volumes. The contents of the <code>host</code> parameter determine whether your bind mount host volume persists on the host container instance and where it's stored. </p>
        pub fn set_host(
            mut self,
            input: std::option::Option<crate::model::AwsEcsTaskVolumeHostDetails>,
        ) -> Self {
            self.host = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskVolumeDetails`](crate::model::AwsEcsTaskVolumeDetails)
        pub fn build(self) -> crate::model::AwsEcsTaskVolumeDetails {
            crate::model::AwsEcsTaskVolumeDetails {
                name: self.name,
                host: self.host,
            }
        }
    }
}
impl AwsEcsTaskVolumeDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskVolumeDetails`](crate::model::AwsEcsTaskVolumeDetails)
    pub fn builder() -> crate::model::aws_ecs_task_volume_details::Builder {
        crate::model::aws_ecs_task_volume_details::Builder::default()
    }
}

/// <p>Provides details on a container instance bind mount host volume. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskVolumeHostDetails {
    /// <p>When the <code>host</code> parameter is used, specify a <code>sourcePath</code> to declare the path on the host container instance that's presented to the container. </p>
    pub source_path: std::option::Option<std::string::String>,
}
impl AwsEcsTaskVolumeHostDetails {
    /// <p>When the <code>host</code> parameter is used, specify a <code>sourcePath</code> to declare the path on the host container instance that's presented to the container. </p>
    pub fn source_path(&self) -> std::option::Option<&str> {
        self.source_path.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsTaskVolumeHostDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcsTaskVolumeHostDetails");
        formatter.field("source_path", &self.source_path);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskVolumeHostDetails`](crate::model::AwsEcsTaskVolumeHostDetails)
pub mod aws_ecs_task_volume_host_details {

    /// A builder for [`AwsEcsTaskVolumeHostDetails`](crate::model::AwsEcsTaskVolumeHostDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>When the <code>host</code> parameter is used, specify a <code>sourcePath</code> to declare the path on the host container instance that's presented to the container. </p>
        pub fn source_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_path = Some(input.into());
            self
        }
        /// <p>When the <code>host</code> parameter is used, specify a <code>sourcePath</code> to declare the path on the host container instance that's presented to the container. </p>
        pub fn set_source_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_path = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskVolumeHostDetails`](crate::model::AwsEcsTaskVolumeHostDetails)
        pub fn build(self) -> crate::model::AwsEcsTaskVolumeHostDetails {
            crate::model::AwsEcsTaskVolumeHostDetails {
                source_path: self.source_path,
            }
        }
    }
}
impl AwsEcsTaskVolumeHostDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskVolumeHostDetails`](crate::model::AwsEcsTaskVolumeHostDetails)
    pub fn builder() -> crate::model::aws_ecs_task_volume_host_details::Builder {
        crate::model::aws_ecs_task_volume_host_details::Builder::default()
    }
}

/// <p>Provides information about an WAF rule group. A rule group is a collection of rules for inspecting and controlling web requests. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsWafRuleGroupDetails {
    /// <p>The name of the metrics for this rule group. </p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>The name of the rule group. </p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The ID of the rule group. </p>
    pub rule_group_id: std::option::Option<std::string::String>,
    /// <p>Provides information about the rules attached to the rule group. These rules identify the web requests that you want to allow, block, or count. </p>
    pub rules: std::option::Option<std::vec::Vec<crate::model::AwsWafRuleGroupRulesDetails>>,
}
impl AwsWafRuleGroupDetails {
    /// <p>The name of the metrics for this rule group. </p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
    /// <p>The name of the rule group. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ID of the rule group. </p>
    pub fn rule_group_id(&self) -> std::option::Option<&str> {
        self.rule_group_id.as_deref()
    }
    /// <p>Provides information about the rules attached to the rule group. These rules identify the web requests that you want to allow, block, or count. </p>
    pub fn rules(&self) -> std::option::Option<&[crate::model::AwsWafRuleGroupRulesDetails]> {
        self.rules.as_deref()
    }
}
impl std::fmt::Debug for AwsWafRuleGroupDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsWafRuleGroupDetails");
        formatter.field("metric_name", &self.metric_name);
        formatter.field("name", &self.name);
        formatter.field("rule_group_id", &self.rule_group_id);
        formatter.field("rules", &self.rules);
        formatter.finish()
    }
}
/// See [`AwsWafRuleGroupDetails`](crate::model::AwsWafRuleGroupDetails)
pub mod aws_waf_rule_group_details {

    /// A builder for [`AwsWafRuleGroupDetails`](crate::model::AwsWafRuleGroupDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) rule_group_id: std::option::Option<std::string::String>,
        pub(crate) rules:
            std::option::Option<std::vec::Vec<crate::model::AwsWafRuleGroupRulesDetails>>,
    }
    impl Builder {
        /// <p>The name of the metrics for this rule group. </p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>The name of the metrics for this rule group. </p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The name of the rule group. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the rule group. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ID of the rule group. </p>
        pub fn rule_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_group_id = Some(input.into());
            self
        }
        /// <p>The ID of the rule group. </p>
        pub fn set_rule_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_group_id = input;
            self
        }
        /// Appends an item to `rules`.
        ///
        /// To override the contents of this collection use [`set_rules`](Self::set_rules).
        ///
        /// <p>Provides information about the rules attached to the rule group. These rules identify the web requests that you want to allow, block, or count. </p>
        pub fn rules(mut self, input: crate::model::AwsWafRuleGroupRulesDetails) -> Self {
            let mut v = self.rules.unwrap_or_default();
            v.push(input);
            self.rules = Some(v);
            self
        }
        /// <p>Provides information about the rules attached to the rule group. These rules identify the web requests that you want to allow, block, or count. </p>
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsWafRuleGroupRulesDetails>>,
        ) -> Self {
            self.rules = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsWafRuleGroupDetails`](crate::model::AwsWafRuleGroupDetails)
        pub fn build(self) -> crate::model::AwsWafRuleGroupDetails {
            crate::model::AwsWafRuleGroupDetails {
                metric_name: self.metric_name,
                name: self.name,
                rule_group_id: self.rule_group_id,
                rules: self.rules,
            }
        }
    }
}
impl AwsWafRuleGroupDetails {
    /// Creates a new builder-style object to manufacture [`AwsWafRuleGroupDetails`](crate::model::AwsWafRuleGroupDetails)
    pub fn builder() -> crate::model::aws_waf_rule_group_details::Builder {
        crate::model::aws_waf_rule_group_details::Builder::default()
    }
}

/// <p>Provides information about the rules attached to the rule group. These rules identify the web requests that you want to allow, block, or count. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsWafRuleGroupRulesDetails {
    /// <p>Provides information about what action WAF should take on a web request when it matches the criteria defined in the rule. </p>
    pub action: std::option::Option<crate::model::AwsWafRuleGroupRulesActionDetails>,
    /// <p>If you define more than one rule in a web ACL, WAF evaluates each request against the rules in order based on the value of <code>Priority</code>.</p>
    pub priority: i32,
    /// <p>The rule ID for a rule. </p>
    pub rule_id: std::option::Option<std::string::String>,
    /// <p>The type of rule. </p>
    pub r#type: std::option::Option<std::string::String>,
}
impl AwsWafRuleGroupRulesDetails {
    /// <p>Provides information about what action WAF should take on a web request when it matches the criteria defined in the rule. </p>
    pub fn action(&self) -> std::option::Option<&crate::model::AwsWafRuleGroupRulesActionDetails> {
        self.action.as_ref()
    }
    /// <p>If you define more than one rule in a web ACL, WAF evaluates each request against the rules in order based on the value of <code>Priority</code>.</p>
    pub fn priority(&self) -> i32 {
        self.priority
    }
    /// <p>The rule ID for a rule. </p>
    pub fn rule_id(&self) -> std::option::Option<&str> {
        self.rule_id.as_deref()
    }
    /// <p>The type of rule. </p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for AwsWafRuleGroupRulesDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsWafRuleGroupRulesDetails");
        formatter.field("action", &self.action);
        formatter.field("priority", &self.priority);
        formatter.field("rule_id", &self.rule_id);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AwsWafRuleGroupRulesDetails`](crate::model::AwsWafRuleGroupRulesDetails)
pub mod aws_waf_rule_group_rules_details {

    /// A builder for [`AwsWafRuleGroupRulesDetails`](crate::model::AwsWafRuleGroupRulesDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action: std::option::Option<crate::model::AwsWafRuleGroupRulesActionDetails>,
        pub(crate) priority: std::option::Option<i32>,
        pub(crate) rule_id: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Provides information about what action WAF should take on a web request when it matches the criteria defined in the rule. </p>
        pub fn action(mut self, input: crate::model::AwsWafRuleGroupRulesActionDetails) -> Self {
            self.action = Some(input);
            self
        }
        /// <p>Provides information about what action WAF should take on a web request when it matches the criteria defined in the rule. </p>
        pub fn set_action(
            mut self,
            input: std::option::Option<crate::model::AwsWafRuleGroupRulesActionDetails>,
        ) -> Self {
            self.action = input;
            self
        }
        /// <p>If you define more than one rule in a web ACL, WAF evaluates each request against the rules in order based on the value of <code>Priority</code>.</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        /// <p>If you define more than one rule in a web ACL, WAF evaluates each request against the rules in order based on the value of <code>Priority</code>.</p>
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input;
            self
        }
        /// <p>The rule ID for a rule. </p>
        pub fn rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_id = Some(input.into());
            self
        }
        /// <p>The rule ID for a rule. </p>
        pub fn set_rule_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_id = input;
            self
        }
        /// <p>The type of rule. </p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of rule. </p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsWafRuleGroupRulesDetails`](crate::model::AwsWafRuleGroupRulesDetails)
        pub fn build(self) -> crate::model::AwsWafRuleGroupRulesDetails {
            crate::model::AwsWafRuleGroupRulesDetails {
                action: self.action,
                priority: self.priority.unwrap_or_default(),
                rule_id: self.rule_id,
                r#type: self.r#type,
            }
        }
    }
}
impl AwsWafRuleGroupRulesDetails {
    /// Creates a new builder-style object to manufacture [`AwsWafRuleGroupRulesDetails`](crate::model::AwsWafRuleGroupRulesDetails)
    pub fn builder() -> crate::model::aws_waf_rule_group_rules_details::Builder {
        crate::model::aws_waf_rule_group_rules_details::Builder::default()
    }
}

/// <p>Provides information about what action WAF should take on a web request when it matches the criteria defined in the rule. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsWafRuleGroupRulesActionDetails {
    /// <p>The action that WAF should take on a web request when it matches the rule's statement.</p>
    pub r#type: std::option::Option<std::string::String>,
}
impl AwsWafRuleGroupRulesActionDetails {
    /// <p>The action that WAF should take on a web request when it matches the rule's statement.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for AwsWafRuleGroupRulesActionDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsWafRuleGroupRulesActionDetails");
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AwsWafRuleGroupRulesActionDetails`](crate::model::AwsWafRuleGroupRulesActionDetails)
pub mod aws_waf_rule_group_rules_action_details {

    /// A builder for [`AwsWafRuleGroupRulesActionDetails`](crate::model::AwsWafRuleGroupRulesActionDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The action that WAF should take on a web request when it matches the rule's statement.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The action that WAF should take on a web request when it matches the rule's statement.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsWafRuleGroupRulesActionDetails`](crate::model::AwsWafRuleGroupRulesActionDetails)
        pub fn build(self) -> crate::model::AwsWafRuleGroupRulesActionDetails {
            crate::model::AwsWafRuleGroupRulesActionDetails {
                r#type: self.r#type,
            }
        }
    }
}
impl AwsWafRuleGroupRulesActionDetails {
    /// Creates a new builder-style object to manufacture [`AwsWafRuleGroupRulesActionDetails`](crate::model::AwsWafRuleGroupRulesActionDetails)
    pub fn builder() -> crate::model::aws_waf_rule_group_rules_action_details::Builder {
        crate::model::aws_waf_rule_group_rules_action_details::Builder::default()
    }
}

/// <p>Provides information about a WAF rule. This rule specifies the web requests that you want to allow, block, or count. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsWafRuleDetails {
    /// <p>The name of the metrics for this rule. </p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>A descriptive name for the rule. </p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies the <code>ByteMatchSet</code>, <code>IPSet</code>, <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>, <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, and <code>SizeConstraintSet</code> objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings. </p>
    pub predicate_list:
        std::option::Option<std::vec::Vec<crate::model::AwsWafRulePredicateListDetails>>,
    /// <p>The ID of the WAF rule. </p>
    pub rule_id: std::option::Option<std::string::String>,
}
impl AwsWafRuleDetails {
    /// <p>The name of the metrics for this rule. </p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
    /// <p>A descriptive name for the rule. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Specifies the <code>ByteMatchSet</code>, <code>IPSet</code>, <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>, <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, and <code>SizeConstraintSet</code> objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings. </p>
    pub fn predicate_list(
        &self,
    ) -> std::option::Option<&[crate::model::AwsWafRulePredicateListDetails]> {
        self.predicate_list.as_deref()
    }
    /// <p>The ID of the WAF rule. </p>
    pub fn rule_id(&self) -> std::option::Option<&str> {
        self.rule_id.as_deref()
    }
}
impl std::fmt::Debug for AwsWafRuleDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsWafRuleDetails");
        formatter.field("metric_name", &self.metric_name);
        formatter.field("name", &self.name);
        formatter.field("predicate_list", &self.predicate_list);
        formatter.field("rule_id", &self.rule_id);
        formatter.finish()
    }
}
/// See [`AwsWafRuleDetails`](crate::model::AwsWafRuleDetails)
pub mod aws_waf_rule_details {

    /// A builder for [`AwsWafRuleDetails`](crate::model::AwsWafRuleDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) predicate_list:
            std::option::Option<std::vec::Vec<crate::model::AwsWafRulePredicateListDetails>>,
        pub(crate) rule_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the metrics for this rule. </p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>The name of the metrics for this rule. </p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>A descriptive name for the rule. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A descriptive name for the rule. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `predicate_list`.
        ///
        /// To override the contents of this collection use [`set_predicate_list`](Self::set_predicate_list).
        ///
        /// <p>Specifies the <code>ByteMatchSet</code>, <code>IPSet</code>, <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>, <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, and <code>SizeConstraintSet</code> objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings. </p>
        pub fn predicate_list(
            mut self,
            input: crate::model::AwsWafRulePredicateListDetails,
        ) -> Self {
            let mut v = self.predicate_list.unwrap_or_default();
            v.push(input);
            self.predicate_list = Some(v);
            self
        }
        /// <p>Specifies the <code>ByteMatchSet</code>, <code>IPSet</code>, <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>, <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, and <code>SizeConstraintSet</code> objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings. </p>
        pub fn set_predicate_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsWafRulePredicateListDetails>>,
        ) -> Self {
            self.predicate_list = input;
            self
        }
        /// <p>The ID of the WAF rule. </p>
        pub fn rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_id = Some(input.into());
            self
        }
        /// <p>The ID of the WAF rule. </p>
        pub fn set_rule_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsWafRuleDetails`](crate::model::AwsWafRuleDetails)
        pub fn build(self) -> crate::model::AwsWafRuleDetails {
            crate::model::AwsWafRuleDetails {
                metric_name: self.metric_name,
                name: self.name,
                predicate_list: self.predicate_list,
                rule_id: self.rule_id,
            }
        }
    }
}
impl AwsWafRuleDetails {
    /// Creates a new builder-style object to manufacture [`AwsWafRuleDetails`](crate::model::AwsWafRuleDetails)
    pub fn builder() -> crate::model::aws_waf_rule_details::Builder {
        crate::model::aws_waf_rule_details::Builder::default()
    }
}

/// <p>Provides details about the <code>ByteMatchSet</code>, <code>IPSet</code>, <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>, <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, and <code>SizeConstraintSet</code> objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsWafRulePredicateListDetails {
    /// <p>A unique identifier for a predicate in a rule, such as <code>ByteMatchSetId</code> or <code>IPSetId</code>. </p>
    pub data_id: std::option::Option<std::string::String>,
    /// <p>Specifies if you want WAF to allow, block, or count requests based on the settings in the <code>ByteMatchSet</code>, <code>IPSet</code>, <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>, <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, or <code>SizeConstraintSet</code>. </p>
    pub negated: bool,
    /// <p>The type of predicate in a rule, such as <code>ByteMatch</code> or <code>IPSet</code>. </p>
    pub r#type: std::option::Option<std::string::String>,
}
impl AwsWafRulePredicateListDetails {
    /// <p>A unique identifier for a predicate in a rule, such as <code>ByteMatchSetId</code> or <code>IPSetId</code>. </p>
    pub fn data_id(&self) -> std::option::Option<&str> {
        self.data_id.as_deref()
    }
    /// <p>Specifies if you want WAF to allow, block, or count requests based on the settings in the <code>ByteMatchSet</code>, <code>IPSet</code>, <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>, <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, or <code>SizeConstraintSet</code>. </p>
    pub fn negated(&self) -> bool {
        self.negated
    }
    /// <p>The type of predicate in a rule, such as <code>ByteMatch</code> or <code>IPSet</code>. </p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for AwsWafRulePredicateListDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsWafRulePredicateListDetails");
        formatter.field("data_id", &self.data_id);
        formatter.field("negated", &self.negated);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AwsWafRulePredicateListDetails`](crate::model::AwsWafRulePredicateListDetails)
pub mod aws_waf_rule_predicate_list_details {

    /// A builder for [`AwsWafRulePredicateListDetails`](crate::model::AwsWafRulePredicateListDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_id: std::option::Option<std::string::String>,
        pub(crate) negated: std::option::Option<bool>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A unique identifier for a predicate in a rule, such as <code>ByteMatchSetId</code> or <code>IPSetId</code>. </p>
        pub fn data_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for a predicate in a rule, such as <code>ByteMatchSetId</code> or <code>IPSetId</code>. </p>
        pub fn set_data_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_id = input;
            self
        }
        /// <p>Specifies if you want WAF to allow, block, or count requests based on the settings in the <code>ByteMatchSet</code>, <code>IPSet</code>, <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>, <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, or <code>SizeConstraintSet</code>. </p>
        pub fn negated(mut self, input: bool) -> Self {
            self.negated = Some(input);
            self
        }
        /// <p>Specifies if you want WAF to allow, block, or count requests based on the settings in the <code>ByteMatchSet</code>, <code>IPSet</code>, <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>, <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, or <code>SizeConstraintSet</code>. </p>
        pub fn set_negated(mut self, input: std::option::Option<bool>) -> Self {
            self.negated = input;
            self
        }
        /// <p>The type of predicate in a rule, such as <code>ByteMatch</code> or <code>IPSet</code>. </p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of predicate in a rule, such as <code>ByteMatch</code> or <code>IPSet</code>. </p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsWafRulePredicateListDetails`](crate::model::AwsWafRulePredicateListDetails)
        pub fn build(self) -> crate::model::AwsWafRulePredicateListDetails {
            crate::model::AwsWafRulePredicateListDetails {
                data_id: self.data_id,
                negated: self.negated.unwrap_or_default(),
                r#type: self.r#type,
            }
        }
    }
}
impl AwsWafRulePredicateListDetails {
    /// Creates a new builder-style object to manufacture [`AwsWafRulePredicateListDetails`](crate::model::AwsWafRulePredicateListDetails)
    pub fn builder() -> crate::model::aws_waf_rule_predicate_list_details::Builder {
        crate::model::aws_waf_rule_predicate_list_details::Builder::default()
    }
}

/// <p>Provides information about the web access control list (web ACL). The web ACL contains the rules that identify the requests that you want to allow, block, or count. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsWafRegionalWebAclDetails {
    /// <p>The action to perform if none of the rules contained in the web ACL match. </p>
    pub default_action: std::option::Option<std::string::String>,
    /// <p>A name for the metrics for this web ACL. </p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>A descriptive name for the web ACL. </p>
    pub name: std::option::Option<std::string::String>,
    /// <p>An array that contains the action for each rule in a web ACL, the priority of the rule, and the ID of the rule. </p>
    pub rules_list:
        std::option::Option<std::vec::Vec<crate::model::AwsWafRegionalWebAclRulesListDetails>>,
    /// <p>The ID of the web ACL. </p>
    pub web_acl_id: std::option::Option<std::string::String>,
}
impl AwsWafRegionalWebAclDetails {
    /// <p>The action to perform if none of the rules contained in the web ACL match. </p>
    pub fn default_action(&self) -> std::option::Option<&str> {
        self.default_action.as_deref()
    }
    /// <p>A name for the metrics for this web ACL. </p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
    /// <p>A descriptive name for the web ACL. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>An array that contains the action for each rule in a web ACL, the priority of the rule, and the ID of the rule. </p>
    pub fn rules_list(
        &self,
    ) -> std::option::Option<&[crate::model::AwsWafRegionalWebAclRulesListDetails]> {
        self.rules_list.as_deref()
    }
    /// <p>The ID of the web ACL. </p>
    pub fn web_acl_id(&self) -> std::option::Option<&str> {
        self.web_acl_id.as_deref()
    }
}
impl std::fmt::Debug for AwsWafRegionalWebAclDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsWafRegionalWebAclDetails");
        formatter.field("default_action", &self.default_action);
        formatter.field("metric_name", &self.metric_name);
        formatter.field("name", &self.name);
        formatter.field("rules_list", &self.rules_list);
        formatter.field("web_acl_id", &self.web_acl_id);
        formatter.finish()
    }
}
/// See [`AwsWafRegionalWebAclDetails`](crate::model::AwsWafRegionalWebAclDetails)
pub mod aws_waf_regional_web_acl_details {

    /// A builder for [`AwsWafRegionalWebAclDetails`](crate::model::AwsWafRegionalWebAclDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) default_action: std::option::Option<std::string::String>,
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) rules_list:
            std::option::Option<std::vec::Vec<crate::model::AwsWafRegionalWebAclRulesListDetails>>,
        pub(crate) web_acl_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The action to perform if none of the rules contained in the web ACL match. </p>
        pub fn default_action(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_action = Some(input.into());
            self
        }
        /// <p>The action to perform if none of the rules contained in the web ACL match. </p>
        pub fn set_default_action(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_action = input;
            self
        }
        /// <p>A name for the metrics for this web ACL. </p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>A name for the metrics for this web ACL. </p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>A descriptive name for the web ACL. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A descriptive name for the web ACL. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `rules_list`.
        ///
        /// To override the contents of this collection use [`set_rules_list`](Self::set_rules_list).
        ///
        /// <p>An array that contains the action for each rule in a web ACL, the priority of the rule, and the ID of the rule. </p>
        pub fn rules_list(
            mut self,
            input: crate::model::AwsWafRegionalWebAclRulesListDetails,
        ) -> Self {
            let mut v = self.rules_list.unwrap_or_default();
            v.push(input);
            self.rules_list = Some(v);
            self
        }
        /// <p>An array that contains the action for each rule in a web ACL, the priority of the rule, and the ID of the rule. </p>
        pub fn set_rules_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsWafRegionalWebAclRulesListDetails>,
            >,
        ) -> Self {
            self.rules_list = input;
            self
        }
        /// <p>The ID of the web ACL. </p>
        pub fn web_acl_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.web_acl_id = Some(input.into());
            self
        }
        /// <p>The ID of the web ACL. </p>
        pub fn set_web_acl_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.web_acl_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsWafRegionalWebAclDetails`](crate::model::AwsWafRegionalWebAclDetails)
        pub fn build(self) -> crate::model::AwsWafRegionalWebAclDetails {
            crate::model::AwsWafRegionalWebAclDetails {
                default_action: self.default_action,
                metric_name: self.metric_name,
                name: self.name,
                rules_list: self.rules_list,
                web_acl_id: self.web_acl_id,
            }
        }
    }
}
impl AwsWafRegionalWebAclDetails {
    /// Creates a new builder-style object to manufacture [`AwsWafRegionalWebAclDetails`](crate::model::AwsWafRegionalWebAclDetails)
    pub fn builder() -> crate::model::aws_waf_regional_web_acl_details::Builder {
        crate::model::aws_waf_regional_web_acl_details::Builder::default()
    }
}

/// <p>A combination of <code>ByteMatchSet</code>, <code>IPSet</code>, and/or <code>SqlInjectionMatchSet</code> objects that identify the web requests that you want to allow, block, or count. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsWafRegionalWebAclRulesListDetails {
    /// <p>The action that AWS WAF takes when a web request matches all conditions in the rule, such as allow, block, or count the request. </p>
    pub action: std::option::Option<crate::model::AwsWafRegionalWebAclRulesListActionDetails>,
    /// <p>Overrides the rule evaluation result in the rule group. </p>
    pub override_action:
        std::option::Option<crate::model::AwsWafRegionalWebAclRulesListOverrideActionDetails>,
    /// <p>The order in which WAF evaluates the rules in a web ACL. </p>
    pub priority: i32,
    /// <p>The ID of an WAF Regional rule to associate with a web ACL. </p>
    pub rule_id: std::option::Option<std::string::String>,
    /// <p>For actions that are associated with a rule, the action that WAF takes when a web request matches all conditions in a rule. </p>
    pub r#type: std::option::Option<std::string::String>,
}
impl AwsWafRegionalWebAclRulesListDetails {
    /// <p>The action that AWS WAF takes when a web request matches all conditions in the rule, such as allow, block, or count the request. </p>
    pub fn action(
        &self,
    ) -> std::option::Option<&crate::model::AwsWafRegionalWebAclRulesListActionDetails> {
        self.action.as_ref()
    }
    /// <p>Overrides the rule evaluation result in the rule group. </p>
    pub fn override_action(
        &self,
    ) -> std::option::Option<&crate::model::AwsWafRegionalWebAclRulesListOverrideActionDetails>
    {
        self.override_action.as_ref()
    }
    /// <p>The order in which WAF evaluates the rules in a web ACL. </p>
    pub fn priority(&self) -> i32 {
        self.priority
    }
    /// <p>The ID of an WAF Regional rule to associate with a web ACL. </p>
    pub fn rule_id(&self) -> std::option::Option<&str> {
        self.rule_id.as_deref()
    }
    /// <p>For actions that are associated with a rule, the action that WAF takes when a web request matches all conditions in a rule. </p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for AwsWafRegionalWebAclRulesListDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsWafRegionalWebAclRulesListDetails");
        formatter.field("action", &self.action);
        formatter.field("override_action", &self.override_action);
        formatter.field("priority", &self.priority);
        formatter.field("rule_id", &self.rule_id);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AwsWafRegionalWebAclRulesListDetails`](crate::model::AwsWafRegionalWebAclRulesListDetails)
pub mod aws_waf_regional_web_acl_rules_list_details {

    /// A builder for [`AwsWafRegionalWebAclRulesListDetails`](crate::model::AwsWafRegionalWebAclRulesListDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action:
            std::option::Option<crate::model::AwsWafRegionalWebAclRulesListActionDetails>,
        pub(crate) override_action:
            std::option::Option<crate::model::AwsWafRegionalWebAclRulesListOverrideActionDetails>,
        pub(crate) priority: std::option::Option<i32>,
        pub(crate) rule_id: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The action that AWS WAF takes when a web request matches all conditions in the rule, such as allow, block, or count the request. </p>
        pub fn action(
            mut self,
            input: crate::model::AwsWafRegionalWebAclRulesListActionDetails,
        ) -> Self {
            self.action = Some(input);
            self
        }
        /// <p>The action that AWS WAF takes when a web request matches all conditions in the rule, such as allow, block, or count the request. </p>
        pub fn set_action(
            mut self,
            input: std::option::Option<crate::model::AwsWafRegionalWebAclRulesListActionDetails>,
        ) -> Self {
            self.action = input;
            self
        }
        /// <p>Overrides the rule evaluation result in the rule group. </p>
        pub fn override_action(
            mut self,
            input: crate::model::AwsWafRegionalWebAclRulesListOverrideActionDetails,
        ) -> Self {
            self.override_action = Some(input);
            self
        }
        /// <p>Overrides the rule evaluation result in the rule group. </p>
        pub fn set_override_action(
            mut self,
            input: std::option::Option<
                crate::model::AwsWafRegionalWebAclRulesListOverrideActionDetails,
            >,
        ) -> Self {
            self.override_action = input;
            self
        }
        /// <p>The order in which WAF evaluates the rules in a web ACL. </p>
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        /// <p>The order in which WAF evaluates the rules in a web ACL. </p>
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input;
            self
        }
        /// <p>The ID of an WAF Regional rule to associate with a web ACL. </p>
        pub fn rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_id = Some(input.into());
            self
        }
        /// <p>The ID of an WAF Regional rule to associate with a web ACL. </p>
        pub fn set_rule_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_id = input;
            self
        }
        /// <p>For actions that are associated with a rule, the action that WAF takes when a web request matches all conditions in a rule. </p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>For actions that are associated with a rule, the action that WAF takes when a web request matches all conditions in a rule. </p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsWafRegionalWebAclRulesListDetails`](crate::model::AwsWafRegionalWebAclRulesListDetails)
        pub fn build(self) -> crate::model::AwsWafRegionalWebAclRulesListDetails {
            crate::model::AwsWafRegionalWebAclRulesListDetails {
                action: self.action,
                override_action: self.override_action,
                priority: self.priority.unwrap_or_default(),
                rule_id: self.rule_id,
                r#type: self.r#type,
            }
        }
    }
}
impl AwsWafRegionalWebAclRulesListDetails {
    /// Creates a new builder-style object to manufacture [`AwsWafRegionalWebAclRulesListDetails`](crate::model::AwsWafRegionalWebAclRulesListDetails)
    pub fn builder() -> crate::model::aws_waf_regional_web_acl_rules_list_details::Builder {
        crate::model::aws_waf_regional_web_acl_rules_list_details::Builder::default()
    }
}

/// <p>Provides details about the action to use in the place of the action that results from the rule group evaluation. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsWafRegionalWebAclRulesListOverrideActionDetails {
    /// <p>Overrides the rule evaluation result in the rule group. </p>
    pub r#type: std::option::Option<std::string::String>,
}
impl AwsWafRegionalWebAclRulesListOverrideActionDetails {
    /// <p>Overrides the rule evaluation result in the rule group. </p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for AwsWafRegionalWebAclRulesListOverrideActionDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsWafRegionalWebAclRulesListOverrideActionDetails");
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AwsWafRegionalWebAclRulesListOverrideActionDetails`](crate::model::AwsWafRegionalWebAclRulesListOverrideActionDetails)
pub mod aws_waf_regional_web_acl_rules_list_override_action_details {

    /// A builder for [`AwsWafRegionalWebAclRulesListOverrideActionDetails`](crate::model::AwsWafRegionalWebAclRulesListOverrideActionDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Overrides the rule evaluation result in the rule group. </p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>Overrides the rule evaluation result in the rule group. </p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsWafRegionalWebAclRulesListOverrideActionDetails`](crate::model::AwsWafRegionalWebAclRulesListOverrideActionDetails)
        pub fn build(self) -> crate::model::AwsWafRegionalWebAclRulesListOverrideActionDetails {
            crate::model::AwsWafRegionalWebAclRulesListOverrideActionDetails {
                r#type: self.r#type,
            }
        }
    }
}
impl AwsWafRegionalWebAclRulesListOverrideActionDetails {
    /// Creates a new builder-style object to manufacture [`AwsWafRegionalWebAclRulesListOverrideActionDetails`](crate::model::AwsWafRegionalWebAclRulesListOverrideActionDetails)
    pub fn builder(
    ) -> crate::model::aws_waf_regional_web_acl_rules_list_override_action_details::Builder {
        crate::model::aws_waf_regional_web_acl_rules_list_override_action_details::Builder::default(
        )
    }
}

/// <p>The action that WAF takes when a web request matches all conditions in the rule, such as allow, block, or count the request. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsWafRegionalWebAclRulesListActionDetails {
    /// <p>For actions that are associated with a rule, the action that WAF takes when a web request matches all conditions in a rule. </p>
    pub r#type: std::option::Option<std::string::String>,
}
impl AwsWafRegionalWebAclRulesListActionDetails {
    /// <p>For actions that are associated with a rule, the action that WAF takes when a web request matches all conditions in a rule. </p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for AwsWafRegionalWebAclRulesListActionDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsWafRegionalWebAclRulesListActionDetails");
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AwsWafRegionalWebAclRulesListActionDetails`](crate::model::AwsWafRegionalWebAclRulesListActionDetails)
pub mod aws_waf_regional_web_acl_rules_list_action_details {

    /// A builder for [`AwsWafRegionalWebAclRulesListActionDetails`](crate::model::AwsWafRegionalWebAclRulesListActionDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>For actions that are associated with a rule, the action that WAF takes when a web request matches all conditions in a rule. </p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>For actions that are associated with a rule, the action that WAF takes when a web request matches all conditions in a rule. </p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsWafRegionalWebAclRulesListActionDetails`](crate::model::AwsWafRegionalWebAclRulesListActionDetails)
        pub fn build(self) -> crate::model::AwsWafRegionalWebAclRulesListActionDetails {
            crate::model::AwsWafRegionalWebAclRulesListActionDetails {
                r#type: self.r#type,
            }
        }
    }
}
impl AwsWafRegionalWebAclRulesListActionDetails {
    /// Creates a new builder-style object to manufacture [`AwsWafRegionalWebAclRulesListActionDetails`](crate::model::AwsWafRegionalWebAclRulesListActionDetails)
    pub fn builder() -> crate::model::aws_waf_regional_web_acl_rules_list_action_details::Builder {
        crate::model::aws_waf_regional_web_acl_rules_list_action_details::Builder::default()
    }
}

/// <p>Provides information about an WAF Regional rule. This rule identifies the web requests that you want to allow, block, or count. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsWafRegionalRuleDetails {
    /// <p>A name for the metrics for the rule. </p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>A descriptive name for the rule. </p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies the <code>ByteMatchSet</code>, <code>IPSet</code>, <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>, <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, and <code>SizeConstraintSet</code> objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings. </p>
    pub predicate_list:
        std::option::Option<std::vec::Vec<crate::model::AwsWafRegionalRulePredicateListDetails>>,
    /// <p>The ID of the rule. </p>
    pub rule_id: std::option::Option<std::string::String>,
}
impl AwsWafRegionalRuleDetails {
    /// <p>A name for the metrics for the rule. </p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
    /// <p>A descriptive name for the rule. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Specifies the <code>ByteMatchSet</code>, <code>IPSet</code>, <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>, <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, and <code>SizeConstraintSet</code> objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings. </p>
    pub fn predicate_list(
        &self,
    ) -> std::option::Option<&[crate::model::AwsWafRegionalRulePredicateListDetails]> {
        self.predicate_list.as_deref()
    }
    /// <p>The ID of the rule. </p>
    pub fn rule_id(&self) -> std::option::Option<&str> {
        self.rule_id.as_deref()
    }
}
impl std::fmt::Debug for AwsWafRegionalRuleDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsWafRegionalRuleDetails");
        formatter.field("metric_name", &self.metric_name);
        formatter.field("name", &self.name);
        formatter.field("predicate_list", &self.predicate_list);
        formatter.field("rule_id", &self.rule_id);
        formatter.finish()
    }
}
/// See [`AwsWafRegionalRuleDetails`](crate::model::AwsWafRegionalRuleDetails)
pub mod aws_waf_regional_rule_details {

    /// A builder for [`AwsWafRegionalRuleDetails`](crate::model::AwsWafRegionalRuleDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) predicate_list: std::option::Option<
            std::vec::Vec<crate::model::AwsWafRegionalRulePredicateListDetails>,
        >,
        pub(crate) rule_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A name for the metrics for the rule. </p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>A name for the metrics for the rule. </p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>A descriptive name for the rule. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A descriptive name for the rule. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `predicate_list`.
        ///
        /// To override the contents of this collection use [`set_predicate_list`](Self::set_predicate_list).
        ///
        /// <p>Specifies the <code>ByteMatchSet</code>, <code>IPSet</code>, <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>, <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, and <code>SizeConstraintSet</code> objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings. </p>
        pub fn predicate_list(
            mut self,
            input: crate::model::AwsWafRegionalRulePredicateListDetails,
        ) -> Self {
            let mut v = self.predicate_list.unwrap_or_default();
            v.push(input);
            self.predicate_list = Some(v);
            self
        }
        /// <p>Specifies the <code>ByteMatchSet</code>, <code>IPSet</code>, <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>, <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, and <code>SizeConstraintSet</code> objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings. </p>
        pub fn set_predicate_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsWafRegionalRulePredicateListDetails>,
            >,
        ) -> Self {
            self.predicate_list = input;
            self
        }
        /// <p>The ID of the rule. </p>
        pub fn rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_id = Some(input.into());
            self
        }
        /// <p>The ID of the rule. </p>
        pub fn set_rule_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsWafRegionalRuleDetails`](crate::model::AwsWafRegionalRuleDetails)
        pub fn build(self) -> crate::model::AwsWafRegionalRuleDetails {
            crate::model::AwsWafRegionalRuleDetails {
                metric_name: self.metric_name,
                name: self.name,
                predicate_list: self.predicate_list,
                rule_id: self.rule_id,
            }
        }
    }
}
impl AwsWafRegionalRuleDetails {
    /// Creates a new builder-style object to manufacture [`AwsWafRegionalRuleDetails`](crate::model::AwsWafRegionalRuleDetails)
    pub fn builder() -> crate::model::aws_waf_regional_rule_details::Builder {
        crate::model::aws_waf_regional_rule_details::Builder::default()
    }
}

/// <p>Provides details about the <code>ByteMatchSet</code>, <code>IPSet</code>, <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>, <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, and <code>SizeConstraintSet</code> objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsWafRegionalRulePredicateListDetails {
    /// <p>A unique identifier for a predicate in a rule, such as <code>ByteMatchSetId</code> or <code>IPSetId</code>. </p>
    pub data_id: std::option::Option<std::string::String>,
    /// <p>Specifies if you want WAF to allow, block, or count requests based on the settings in the <code>ByteMatchSet</code>, <code>IPSet</code>, <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>, <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, or <code>SizeConstraintSet</code>. </p>
    pub negated: bool,
    /// <p>The type of predicate in a rule, such as <code>ByteMatch</code> or <code>IPSet</code>. </p>
    pub r#type: std::option::Option<std::string::String>,
}
impl AwsWafRegionalRulePredicateListDetails {
    /// <p>A unique identifier for a predicate in a rule, such as <code>ByteMatchSetId</code> or <code>IPSetId</code>. </p>
    pub fn data_id(&self) -> std::option::Option<&str> {
        self.data_id.as_deref()
    }
    /// <p>Specifies if you want WAF to allow, block, or count requests based on the settings in the <code>ByteMatchSet</code>, <code>IPSet</code>, <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>, <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, or <code>SizeConstraintSet</code>. </p>
    pub fn negated(&self) -> bool {
        self.negated
    }
    /// <p>The type of predicate in a rule, such as <code>ByteMatch</code> or <code>IPSet</code>. </p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for AwsWafRegionalRulePredicateListDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsWafRegionalRulePredicateListDetails");
        formatter.field("data_id", &self.data_id);
        formatter.field("negated", &self.negated);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AwsWafRegionalRulePredicateListDetails`](crate::model::AwsWafRegionalRulePredicateListDetails)
pub mod aws_waf_regional_rule_predicate_list_details {

    /// A builder for [`AwsWafRegionalRulePredicateListDetails`](crate::model::AwsWafRegionalRulePredicateListDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_id: std::option::Option<std::string::String>,
        pub(crate) negated: std::option::Option<bool>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A unique identifier for a predicate in a rule, such as <code>ByteMatchSetId</code> or <code>IPSetId</code>. </p>
        pub fn data_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for a predicate in a rule, such as <code>ByteMatchSetId</code> or <code>IPSetId</code>. </p>
        pub fn set_data_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_id = input;
            self
        }
        /// <p>Specifies if you want WAF to allow, block, or count requests based on the settings in the <code>ByteMatchSet</code>, <code>IPSet</code>, <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>, <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, or <code>SizeConstraintSet</code>. </p>
        pub fn negated(mut self, input: bool) -> Self {
            self.negated = Some(input);
            self
        }
        /// <p>Specifies if you want WAF to allow, block, or count requests based on the settings in the <code>ByteMatchSet</code>, <code>IPSet</code>, <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>, <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, or <code>SizeConstraintSet</code>. </p>
        pub fn set_negated(mut self, input: std::option::Option<bool>) -> Self {
            self.negated = input;
            self
        }
        /// <p>The type of predicate in a rule, such as <code>ByteMatch</code> or <code>IPSet</code>. </p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of predicate in a rule, such as <code>ByteMatch</code> or <code>IPSet</code>. </p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsWafRegionalRulePredicateListDetails`](crate::model::AwsWafRegionalRulePredicateListDetails)
        pub fn build(self) -> crate::model::AwsWafRegionalRulePredicateListDetails {
            crate::model::AwsWafRegionalRulePredicateListDetails {
                data_id: self.data_id,
                negated: self.negated.unwrap_or_default(),
                r#type: self.r#type,
            }
        }
    }
}
impl AwsWafRegionalRulePredicateListDetails {
    /// Creates a new builder-style object to manufacture [`AwsWafRegionalRulePredicateListDetails`](crate::model::AwsWafRegionalRulePredicateListDetails)
    pub fn builder() -> crate::model::aws_waf_regional_rule_predicate_list_details::Builder {
        crate::model::aws_waf_regional_rule_predicate_list_details::Builder::default()
    }
}

/// <p>Provides information about an WAF Regional rule group. The rule group is a collection of rules for inspecting and controlling web requests. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsWafRegionalRuleGroupDetails {
    /// <p>A name for the metrics for this rule group. </p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>The descriptive name of the rule group. </p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The ID of the rule group. </p>
    pub rule_group_id: std::option::Option<std::string::String>,
    /// <p>Provides information about the rule statements used to identify the web requests that you want to allow, block, or count. </p>
    pub rules:
        std::option::Option<std::vec::Vec<crate::model::AwsWafRegionalRuleGroupRulesDetails>>,
}
impl AwsWafRegionalRuleGroupDetails {
    /// <p>A name for the metrics for this rule group. </p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
    /// <p>The descriptive name of the rule group. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ID of the rule group. </p>
    pub fn rule_group_id(&self) -> std::option::Option<&str> {
        self.rule_group_id.as_deref()
    }
    /// <p>Provides information about the rule statements used to identify the web requests that you want to allow, block, or count. </p>
    pub fn rules(
        &self,
    ) -> std::option::Option<&[crate::model::AwsWafRegionalRuleGroupRulesDetails]> {
        self.rules.as_deref()
    }
}
impl std::fmt::Debug for AwsWafRegionalRuleGroupDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsWafRegionalRuleGroupDetails");
        formatter.field("metric_name", &self.metric_name);
        formatter.field("name", &self.name);
        formatter.field("rule_group_id", &self.rule_group_id);
        formatter.field("rules", &self.rules);
        formatter.finish()
    }
}
/// See [`AwsWafRegionalRuleGroupDetails`](crate::model::AwsWafRegionalRuleGroupDetails)
pub mod aws_waf_regional_rule_group_details {

    /// A builder for [`AwsWafRegionalRuleGroupDetails`](crate::model::AwsWafRegionalRuleGroupDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) rule_group_id: std::option::Option<std::string::String>,
        pub(crate) rules:
            std::option::Option<std::vec::Vec<crate::model::AwsWafRegionalRuleGroupRulesDetails>>,
    }
    impl Builder {
        /// <p>A name for the metrics for this rule group. </p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>A name for the metrics for this rule group. </p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The descriptive name of the rule group. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The descriptive name of the rule group. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ID of the rule group. </p>
        pub fn rule_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_group_id = Some(input.into());
            self
        }
        /// <p>The ID of the rule group. </p>
        pub fn set_rule_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_group_id = input;
            self
        }
        /// Appends an item to `rules`.
        ///
        /// To override the contents of this collection use [`set_rules`](Self::set_rules).
        ///
        /// <p>Provides information about the rule statements used to identify the web requests that you want to allow, block, or count. </p>
        pub fn rules(mut self, input: crate::model::AwsWafRegionalRuleGroupRulesDetails) -> Self {
            let mut v = self.rules.unwrap_or_default();
            v.push(input);
            self.rules = Some(v);
            self
        }
        /// <p>Provides information about the rule statements used to identify the web requests that you want to allow, block, or count. </p>
        pub fn set_rules(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsWafRegionalRuleGroupRulesDetails>,
            >,
        ) -> Self {
            self.rules = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsWafRegionalRuleGroupDetails`](crate::model::AwsWafRegionalRuleGroupDetails)
        pub fn build(self) -> crate::model::AwsWafRegionalRuleGroupDetails {
            crate::model::AwsWafRegionalRuleGroupDetails {
                metric_name: self.metric_name,
                name: self.name,
                rule_group_id: self.rule_group_id,
                rules: self.rules,
            }
        }
    }
}
impl AwsWafRegionalRuleGroupDetails {
    /// Creates a new builder-style object to manufacture [`AwsWafRegionalRuleGroupDetails`](crate::model::AwsWafRegionalRuleGroupDetails)
    pub fn builder() -> crate::model::aws_waf_regional_rule_group_details::Builder {
        crate::model::aws_waf_regional_rule_group_details::Builder::default()
    }
}

/// <p>Provides information about the rules attached to a rule group </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsWafRegionalRuleGroupRulesDetails {
    /// <p>The action that WAF should take on a web request when it matches the criteria defined in the rule. </p>
    pub action: std::option::Option<crate::model::AwsWafRegionalRuleGroupRulesActionDetails>,
    /// <p>If you define more than one rule in a web ACL, WAF evaluates each request against the rules in order based on the value of <code>Priority</code>. </p>
    pub priority: i32,
    /// <p>The ID for a rule. </p>
    pub rule_id: std::option::Option<std::string::String>,
    /// <p>The type of rule in the rule group. </p>
    pub r#type: std::option::Option<std::string::String>,
}
impl AwsWafRegionalRuleGroupRulesDetails {
    /// <p>The action that WAF should take on a web request when it matches the criteria defined in the rule. </p>
    pub fn action(
        &self,
    ) -> std::option::Option<&crate::model::AwsWafRegionalRuleGroupRulesActionDetails> {
        self.action.as_ref()
    }
    /// <p>If you define more than one rule in a web ACL, WAF evaluates each request against the rules in order based on the value of <code>Priority</code>. </p>
    pub fn priority(&self) -> i32 {
        self.priority
    }
    /// <p>The ID for a rule. </p>
    pub fn rule_id(&self) -> std::option::Option<&str> {
        self.rule_id.as_deref()
    }
    /// <p>The type of rule in the rule group. </p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for AwsWafRegionalRuleGroupRulesDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsWafRegionalRuleGroupRulesDetails");
        formatter.field("action", &self.action);
        formatter.field("priority", &self.priority);
        formatter.field("rule_id", &self.rule_id);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AwsWafRegionalRuleGroupRulesDetails`](crate::model::AwsWafRegionalRuleGroupRulesDetails)
pub mod aws_waf_regional_rule_group_rules_details {

    /// A builder for [`AwsWafRegionalRuleGroupRulesDetails`](crate::model::AwsWafRegionalRuleGroupRulesDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action:
            std::option::Option<crate::model::AwsWafRegionalRuleGroupRulesActionDetails>,
        pub(crate) priority: std::option::Option<i32>,
        pub(crate) rule_id: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The action that WAF should take on a web request when it matches the criteria defined in the rule. </p>
        pub fn action(
            mut self,
            input: crate::model::AwsWafRegionalRuleGroupRulesActionDetails,
        ) -> Self {
            self.action = Some(input);
            self
        }
        /// <p>The action that WAF should take on a web request when it matches the criteria defined in the rule. </p>
        pub fn set_action(
            mut self,
            input: std::option::Option<crate::model::AwsWafRegionalRuleGroupRulesActionDetails>,
        ) -> Self {
            self.action = input;
            self
        }
        /// <p>If you define more than one rule in a web ACL, WAF evaluates each request against the rules in order based on the value of <code>Priority</code>. </p>
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        /// <p>If you define more than one rule in a web ACL, WAF evaluates each request against the rules in order based on the value of <code>Priority</code>. </p>
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input;
            self
        }
        /// <p>The ID for a rule. </p>
        pub fn rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_id = Some(input.into());
            self
        }
        /// <p>The ID for a rule. </p>
        pub fn set_rule_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_id = input;
            self
        }
        /// <p>The type of rule in the rule group. </p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of rule in the rule group. </p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsWafRegionalRuleGroupRulesDetails`](crate::model::AwsWafRegionalRuleGroupRulesDetails)
        pub fn build(self) -> crate::model::AwsWafRegionalRuleGroupRulesDetails {
            crate::model::AwsWafRegionalRuleGroupRulesDetails {
                action: self.action,
                priority: self.priority.unwrap_or_default(),
                rule_id: self.rule_id,
                r#type: self.r#type,
            }
        }
    }
}
impl AwsWafRegionalRuleGroupRulesDetails {
    /// Creates a new builder-style object to manufacture [`AwsWafRegionalRuleGroupRulesDetails`](crate::model::AwsWafRegionalRuleGroupRulesDetails)
    pub fn builder() -> crate::model::aws_waf_regional_rule_group_rules_details::Builder {
        crate::model::aws_waf_regional_rule_group_rules_details::Builder::default()
    }
}

/// <p>Describes the action that AWS WAF should take on a web request when it matches the criteria defined in the rule. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsWafRegionalRuleGroupRulesActionDetails {
    /// <p>Specifies the <code>ByteMatchSet</code>, <code>IPSet</code>, <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>, <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, and <code>SizeConstraintSet</code> objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings.</p>
    pub r#type: std::option::Option<std::string::String>,
}
impl AwsWafRegionalRuleGroupRulesActionDetails {
    /// <p>Specifies the <code>ByteMatchSet</code>, <code>IPSet</code>, <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>, <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, and <code>SizeConstraintSet</code> objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for AwsWafRegionalRuleGroupRulesActionDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsWafRegionalRuleGroupRulesActionDetails");
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AwsWafRegionalRuleGroupRulesActionDetails`](crate::model::AwsWafRegionalRuleGroupRulesActionDetails)
pub mod aws_waf_regional_rule_group_rules_action_details {

    /// A builder for [`AwsWafRegionalRuleGroupRulesActionDetails`](crate::model::AwsWafRegionalRuleGroupRulesActionDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the <code>ByteMatchSet</code>, <code>IPSet</code>, <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>, <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, and <code>SizeConstraintSet</code> objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>Specifies the <code>ByteMatchSet</code>, <code>IPSet</code>, <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>, <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, and <code>SizeConstraintSet</code> objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsWafRegionalRuleGroupRulesActionDetails`](crate::model::AwsWafRegionalRuleGroupRulesActionDetails)
        pub fn build(self) -> crate::model::AwsWafRegionalRuleGroupRulesActionDetails {
            crate::model::AwsWafRegionalRuleGroupRulesActionDetails {
                r#type: self.r#type,
            }
        }
    }
}
impl AwsWafRegionalRuleGroupRulesActionDetails {
    /// Creates a new builder-style object to manufacture [`AwsWafRegionalRuleGroupRulesActionDetails`](crate::model::AwsWafRegionalRuleGroupRulesActionDetails)
    pub fn builder() -> crate::model::aws_waf_regional_rule_group_rules_action_details::Builder {
        crate::model::aws_waf_regional_rule_group_rules_action_details::Builder::default()
    }
}

/// <p>Provides information about a VPC peering connection between two VPCs: a requester VPC that you own and an accepter VPC with which to create the connection. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2VpcPeeringConnectionDetails {
    /// <p>Information about the accepter VPC. </p>
    pub accepter_vpc_info:
        std::option::Option<crate::model::AwsEc2VpcPeeringConnectionVpcInfoDetails>,
    /// <p>The time at which an unaccepted VPC peering connection will expire. </p>
    pub expiration_time: std::option::Option<std::string::String>,
    /// <p>Information about the requester VPC. </p>
    pub requester_vpc_info:
        std::option::Option<crate::model::AwsEc2VpcPeeringConnectionVpcInfoDetails>,
    /// <p>The status of the VPC peering connection. </p>
    pub status: std::option::Option<crate::model::AwsEc2VpcPeeringConnectionStatusDetails>,
    /// <p>The ID of the VPC peering connection. </p>
    pub vpc_peering_connection_id: std::option::Option<std::string::String>,
}
impl AwsEc2VpcPeeringConnectionDetails {
    /// <p>Information about the accepter VPC. </p>
    pub fn accepter_vpc_info(
        &self,
    ) -> std::option::Option<&crate::model::AwsEc2VpcPeeringConnectionVpcInfoDetails> {
        self.accepter_vpc_info.as_ref()
    }
    /// <p>The time at which an unaccepted VPC peering connection will expire. </p>
    pub fn expiration_time(&self) -> std::option::Option<&str> {
        self.expiration_time.as_deref()
    }
    /// <p>Information about the requester VPC. </p>
    pub fn requester_vpc_info(
        &self,
    ) -> std::option::Option<&crate::model::AwsEc2VpcPeeringConnectionVpcInfoDetails> {
        self.requester_vpc_info.as_ref()
    }
    /// <p>The status of the VPC peering connection. </p>
    pub fn status(
        &self,
    ) -> std::option::Option<&crate::model::AwsEc2VpcPeeringConnectionStatusDetails> {
        self.status.as_ref()
    }
    /// <p>The ID of the VPC peering connection. </p>
    pub fn vpc_peering_connection_id(&self) -> std::option::Option<&str> {
        self.vpc_peering_connection_id.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2VpcPeeringConnectionDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2VpcPeeringConnectionDetails");
        formatter.field("accepter_vpc_info", &self.accepter_vpc_info);
        formatter.field("expiration_time", &self.expiration_time);
        formatter.field("requester_vpc_info", &self.requester_vpc_info);
        formatter.field("status", &self.status);
        formatter.field("vpc_peering_connection_id", &self.vpc_peering_connection_id);
        formatter.finish()
    }
}
/// See [`AwsEc2VpcPeeringConnectionDetails`](crate::model::AwsEc2VpcPeeringConnectionDetails)
pub mod aws_ec2_vpc_peering_connection_details {

    /// A builder for [`AwsEc2VpcPeeringConnectionDetails`](crate::model::AwsEc2VpcPeeringConnectionDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) accepter_vpc_info:
            std::option::Option<crate::model::AwsEc2VpcPeeringConnectionVpcInfoDetails>,
        pub(crate) expiration_time: std::option::Option<std::string::String>,
        pub(crate) requester_vpc_info:
            std::option::Option<crate::model::AwsEc2VpcPeeringConnectionVpcInfoDetails>,
        pub(crate) status:
            std::option::Option<crate::model::AwsEc2VpcPeeringConnectionStatusDetails>,
        pub(crate) vpc_peering_connection_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Information about the accepter VPC. </p>
        pub fn accepter_vpc_info(
            mut self,
            input: crate::model::AwsEc2VpcPeeringConnectionVpcInfoDetails,
        ) -> Self {
            self.accepter_vpc_info = Some(input);
            self
        }
        /// <p>Information about the accepter VPC. </p>
        pub fn set_accepter_vpc_info(
            mut self,
            input: std::option::Option<crate::model::AwsEc2VpcPeeringConnectionVpcInfoDetails>,
        ) -> Self {
            self.accepter_vpc_info = input;
            self
        }
        /// <p>The time at which an unaccepted VPC peering connection will expire. </p>
        pub fn expiration_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.expiration_time = Some(input.into());
            self
        }
        /// <p>The time at which an unaccepted VPC peering connection will expire. </p>
        pub fn set_expiration_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expiration_time = input;
            self
        }
        /// <p>Information about the requester VPC. </p>
        pub fn requester_vpc_info(
            mut self,
            input: crate::model::AwsEc2VpcPeeringConnectionVpcInfoDetails,
        ) -> Self {
            self.requester_vpc_info = Some(input);
            self
        }
        /// <p>Information about the requester VPC. </p>
        pub fn set_requester_vpc_info(
            mut self,
            input: std::option::Option<crate::model::AwsEc2VpcPeeringConnectionVpcInfoDetails>,
        ) -> Self {
            self.requester_vpc_info = input;
            self
        }
        /// <p>The status of the VPC peering connection. </p>
        pub fn status(
            mut self,
            input: crate::model::AwsEc2VpcPeeringConnectionStatusDetails,
        ) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the VPC peering connection. </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AwsEc2VpcPeeringConnectionStatusDetails>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The ID of the VPC peering connection. </p>
        pub fn vpc_peering_connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_peering_connection_id = Some(input.into());
            self
        }
        /// <p>The ID of the VPC peering connection. </p>
        pub fn set_vpc_peering_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_peering_connection_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2VpcPeeringConnectionDetails`](crate::model::AwsEc2VpcPeeringConnectionDetails)
        pub fn build(self) -> crate::model::AwsEc2VpcPeeringConnectionDetails {
            crate::model::AwsEc2VpcPeeringConnectionDetails {
                accepter_vpc_info: self.accepter_vpc_info,
                expiration_time: self.expiration_time,
                requester_vpc_info: self.requester_vpc_info,
                status: self.status,
                vpc_peering_connection_id: self.vpc_peering_connection_id,
            }
        }
    }
}
impl AwsEc2VpcPeeringConnectionDetails {
    /// Creates a new builder-style object to manufacture [`AwsEc2VpcPeeringConnectionDetails`](crate::model::AwsEc2VpcPeeringConnectionDetails)
    pub fn builder() -> crate::model::aws_ec2_vpc_peering_connection_details::Builder {
        crate::model::aws_ec2_vpc_peering_connection_details::Builder::default()
    }
}

/// <p>Details about the status of the VPC peering connection. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2VpcPeeringConnectionStatusDetails {
    /// <p>The status of the VPC peering connection. </p>
    pub code: std::option::Option<std::string::String>,
    /// <p>A message that provides more information about the status, if applicable. </p>
    pub message: std::option::Option<std::string::String>,
}
impl AwsEc2VpcPeeringConnectionStatusDetails {
    /// <p>The status of the VPC peering connection. </p>
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
    /// <p>A message that provides more information about the status, if applicable. </p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2VpcPeeringConnectionStatusDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2VpcPeeringConnectionStatusDetails");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`AwsEc2VpcPeeringConnectionStatusDetails`](crate::model::AwsEc2VpcPeeringConnectionStatusDetails)
pub mod aws_ec2_vpc_peering_connection_status_details {

    /// A builder for [`AwsEc2VpcPeeringConnectionStatusDetails`](crate::model::AwsEc2VpcPeeringConnectionStatusDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The status of the VPC peering connection. </p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// <p>The status of the VPC peering connection. </p>
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A message that provides more information about the status, if applicable. </p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message that provides more information about the status, if applicable. </p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2VpcPeeringConnectionStatusDetails`](crate::model::AwsEc2VpcPeeringConnectionStatusDetails)
        pub fn build(self) -> crate::model::AwsEc2VpcPeeringConnectionStatusDetails {
            crate::model::AwsEc2VpcPeeringConnectionStatusDetails {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl AwsEc2VpcPeeringConnectionStatusDetails {
    /// Creates a new builder-style object to manufacture [`AwsEc2VpcPeeringConnectionStatusDetails`](crate::model::AwsEc2VpcPeeringConnectionStatusDetails)
    pub fn builder() -> crate::model::aws_ec2_vpc_peering_connection_status_details::Builder {
        crate::model::aws_ec2_vpc_peering_connection_status_details::Builder::default()
    }
}

/// <p>Describes a VPC in a VPC peering connection. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2VpcPeeringConnectionVpcInfoDetails {
    /// <p>The IPv4 CIDR block for the VPC. </p>
    pub cidr_block: std::option::Option<std::string::String>,
    /// <p>Information about the IPv4 CIDR blocks for the VPC. </p>
    pub cidr_block_set:
        std::option::Option<std::vec::Vec<crate::model::VpcInfoCidrBlockSetDetails>>,
    /// <p>The IPv6 CIDR block for the VPC. </p>
    pub ipv6_cidr_block_set:
        std::option::Option<std::vec::Vec<crate::model::VpcInfoIpv6CidrBlockSetDetails>>,
    /// <p>The ID of the Amazon Web Services account that owns the VPC. </p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>Information about the VPC peering connection options for the accepter or requester VPC. </p>
    pub peering_options: std::option::Option<crate::model::VpcInfoPeeringOptionsDetails>,
    /// <p>The Amazon Web Services Region in which the VPC is located. </p>
    pub region: std::option::Option<std::string::String>,
    /// <p>The ID of the VPC. </p>
    pub vpc_id: std::option::Option<std::string::String>,
}
impl AwsEc2VpcPeeringConnectionVpcInfoDetails {
    /// <p>The IPv4 CIDR block for the VPC. </p>
    pub fn cidr_block(&self) -> std::option::Option<&str> {
        self.cidr_block.as_deref()
    }
    /// <p>Information about the IPv4 CIDR blocks for the VPC. </p>
    pub fn cidr_block_set(
        &self,
    ) -> std::option::Option<&[crate::model::VpcInfoCidrBlockSetDetails]> {
        self.cidr_block_set.as_deref()
    }
    /// <p>The IPv6 CIDR block for the VPC. </p>
    pub fn ipv6_cidr_block_set(
        &self,
    ) -> std::option::Option<&[crate::model::VpcInfoIpv6CidrBlockSetDetails]> {
        self.ipv6_cidr_block_set.as_deref()
    }
    /// <p>The ID of the Amazon Web Services account that owns the VPC. </p>
    pub fn owner_id(&self) -> std::option::Option<&str> {
        self.owner_id.as_deref()
    }
    /// <p>Information about the VPC peering connection options for the accepter or requester VPC. </p>
    pub fn peering_options(
        &self,
    ) -> std::option::Option<&crate::model::VpcInfoPeeringOptionsDetails> {
        self.peering_options.as_ref()
    }
    /// <p>The Amazon Web Services Region in which the VPC is located. </p>
    pub fn region(&self) -> std::option::Option<&str> {
        self.region.as_deref()
    }
    /// <p>The ID of the VPC. </p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2VpcPeeringConnectionVpcInfoDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2VpcPeeringConnectionVpcInfoDetails");
        formatter.field("cidr_block", &self.cidr_block);
        formatter.field("cidr_block_set", &self.cidr_block_set);
        formatter.field("ipv6_cidr_block_set", &self.ipv6_cidr_block_set);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("peering_options", &self.peering_options);
        formatter.field("region", &self.region);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.finish()
    }
}
/// See [`AwsEc2VpcPeeringConnectionVpcInfoDetails`](crate::model::AwsEc2VpcPeeringConnectionVpcInfoDetails)
pub mod aws_ec2_vpc_peering_connection_vpc_info_details {

    /// A builder for [`AwsEc2VpcPeeringConnectionVpcInfoDetails`](crate::model::AwsEc2VpcPeeringConnectionVpcInfoDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cidr_block: std::option::Option<std::string::String>,
        pub(crate) cidr_block_set:
            std::option::Option<std::vec::Vec<crate::model::VpcInfoCidrBlockSetDetails>>,
        pub(crate) ipv6_cidr_block_set:
            std::option::Option<std::vec::Vec<crate::model::VpcInfoIpv6CidrBlockSetDetails>>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) peering_options: std::option::Option<crate::model::VpcInfoPeeringOptionsDetails>,
        pub(crate) region: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IPv4 CIDR block for the VPC. </p>
        pub fn cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr_block = Some(input.into());
            self
        }
        /// <p>The IPv4 CIDR block for the VPC. </p>
        pub fn set_cidr_block(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr_block = input;
            self
        }
        /// Appends an item to `cidr_block_set`.
        ///
        /// To override the contents of this collection use [`set_cidr_block_set`](Self::set_cidr_block_set).
        ///
        /// <p>Information about the IPv4 CIDR blocks for the VPC. </p>
        pub fn cidr_block_set(mut self, input: crate::model::VpcInfoCidrBlockSetDetails) -> Self {
            let mut v = self.cidr_block_set.unwrap_or_default();
            v.push(input);
            self.cidr_block_set = Some(v);
            self
        }
        /// <p>Information about the IPv4 CIDR blocks for the VPC. </p>
        pub fn set_cidr_block_set(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VpcInfoCidrBlockSetDetails>>,
        ) -> Self {
            self.cidr_block_set = input;
            self
        }
        /// Appends an item to `ipv6_cidr_block_set`.
        ///
        /// To override the contents of this collection use [`set_ipv6_cidr_block_set`](Self::set_ipv6_cidr_block_set).
        ///
        /// <p>The IPv6 CIDR block for the VPC. </p>
        pub fn ipv6_cidr_block_set(
            mut self,
            input: crate::model::VpcInfoIpv6CidrBlockSetDetails,
        ) -> Self {
            let mut v = self.ipv6_cidr_block_set.unwrap_or_default();
            v.push(input);
            self.ipv6_cidr_block_set = Some(v);
            self
        }
        /// <p>The IPv6 CIDR block for the VPC. </p>
        pub fn set_ipv6_cidr_block_set(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VpcInfoIpv6CidrBlockSetDetails>>,
        ) -> Self {
            self.ipv6_cidr_block_set = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account that owns the VPC. </p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        /// <p>The ID of the Amazon Web Services account that owns the VPC. </p>
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>Information about the VPC peering connection options for the accepter or requester VPC. </p>
        pub fn peering_options(
            mut self,
            input: crate::model::VpcInfoPeeringOptionsDetails,
        ) -> Self {
            self.peering_options = Some(input);
            self
        }
        /// <p>Information about the VPC peering connection options for the accepter or requester VPC. </p>
        pub fn set_peering_options(
            mut self,
            input: std::option::Option<crate::model::VpcInfoPeeringOptionsDetails>,
        ) -> Self {
            self.peering_options = input;
            self
        }
        /// <p>The Amazon Web Services Region in which the VPC is located. </p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Region in which the VPC is located. </p>
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// <p>The ID of the VPC. </p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The ID of the VPC. </p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2VpcPeeringConnectionVpcInfoDetails`](crate::model::AwsEc2VpcPeeringConnectionVpcInfoDetails)
        pub fn build(self) -> crate::model::AwsEc2VpcPeeringConnectionVpcInfoDetails {
            crate::model::AwsEc2VpcPeeringConnectionVpcInfoDetails {
                cidr_block: self.cidr_block,
                cidr_block_set: self.cidr_block_set,
                ipv6_cidr_block_set: self.ipv6_cidr_block_set,
                owner_id: self.owner_id,
                peering_options: self.peering_options,
                region: self.region,
                vpc_id: self.vpc_id,
            }
        }
    }
}
impl AwsEc2VpcPeeringConnectionVpcInfoDetails {
    /// Creates a new builder-style object to manufacture [`AwsEc2VpcPeeringConnectionVpcInfoDetails`](crate::model::AwsEc2VpcPeeringConnectionVpcInfoDetails)
    pub fn builder() -> crate::model::aws_ec2_vpc_peering_connection_vpc_info_details::Builder {
        crate::model::aws_ec2_vpc_peering_connection_vpc_info_details::Builder::default()
    }
}

/// <p>Provides information about the VPC peering connection options for the accepter or requester VPC. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcInfoPeeringOptionsDetails {
    /// <p>Indicates whether a local VPC can resolve public DNS hostnames to private IP addresses when queried from instances in a peer VPC. </p>
    pub allow_dns_resolution_from_remote_vpc: bool,
    /// <p>Indicates whether a local ClassicLink connection can communicate with the peer VPC over the VPC peering connection. </p>
    pub allow_egress_from_local_classic_link_to_remote_vpc: bool,
    /// <p>Indicates whether a local VPC can communicate with a ClassicLink connection in the peer VPC over the VPC peering connection. </p>
    pub allow_egress_from_local_vpc_to_remote_classic_link: bool,
}
impl VpcInfoPeeringOptionsDetails {
    /// <p>Indicates whether a local VPC can resolve public DNS hostnames to private IP addresses when queried from instances in a peer VPC. </p>
    pub fn allow_dns_resolution_from_remote_vpc(&self) -> bool {
        self.allow_dns_resolution_from_remote_vpc
    }
    /// <p>Indicates whether a local ClassicLink connection can communicate with the peer VPC over the VPC peering connection. </p>
    pub fn allow_egress_from_local_classic_link_to_remote_vpc(&self) -> bool {
        self.allow_egress_from_local_classic_link_to_remote_vpc
    }
    /// <p>Indicates whether a local VPC can communicate with a ClassicLink connection in the peer VPC over the VPC peering connection. </p>
    pub fn allow_egress_from_local_vpc_to_remote_classic_link(&self) -> bool {
        self.allow_egress_from_local_vpc_to_remote_classic_link
    }
}
impl std::fmt::Debug for VpcInfoPeeringOptionsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcInfoPeeringOptionsDetails");
        formatter.field(
            "allow_dns_resolution_from_remote_vpc",
            &self.allow_dns_resolution_from_remote_vpc,
        );
        formatter.field(
            "allow_egress_from_local_classic_link_to_remote_vpc",
            &self.allow_egress_from_local_classic_link_to_remote_vpc,
        );
        formatter.field(
            "allow_egress_from_local_vpc_to_remote_classic_link",
            &self.allow_egress_from_local_vpc_to_remote_classic_link,
        );
        formatter.finish()
    }
}
/// See [`VpcInfoPeeringOptionsDetails`](crate::model::VpcInfoPeeringOptionsDetails)
pub mod vpc_info_peering_options_details {

    /// A builder for [`VpcInfoPeeringOptionsDetails`](crate::model::VpcInfoPeeringOptionsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) allow_dns_resolution_from_remote_vpc: std::option::Option<bool>,
        pub(crate) allow_egress_from_local_classic_link_to_remote_vpc: std::option::Option<bool>,
        pub(crate) allow_egress_from_local_vpc_to_remote_classic_link: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Indicates whether a local VPC can resolve public DNS hostnames to private IP addresses when queried from instances in a peer VPC. </p>
        pub fn allow_dns_resolution_from_remote_vpc(mut self, input: bool) -> Self {
            self.allow_dns_resolution_from_remote_vpc = Some(input);
            self
        }
        /// <p>Indicates whether a local VPC can resolve public DNS hostnames to private IP addresses when queried from instances in a peer VPC. </p>
        pub fn set_allow_dns_resolution_from_remote_vpc(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.allow_dns_resolution_from_remote_vpc = input;
            self
        }
        /// <p>Indicates whether a local ClassicLink connection can communicate with the peer VPC over the VPC peering connection. </p>
        pub fn allow_egress_from_local_classic_link_to_remote_vpc(mut self, input: bool) -> Self {
            self.allow_egress_from_local_classic_link_to_remote_vpc = Some(input);
            self
        }
        /// <p>Indicates whether a local ClassicLink connection can communicate with the peer VPC over the VPC peering connection. </p>
        pub fn set_allow_egress_from_local_classic_link_to_remote_vpc(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.allow_egress_from_local_classic_link_to_remote_vpc = input;
            self
        }
        /// <p>Indicates whether a local VPC can communicate with a ClassicLink connection in the peer VPC over the VPC peering connection. </p>
        pub fn allow_egress_from_local_vpc_to_remote_classic_link(mut self, input: bool) -> Self {
            self.allow_egress_from_local_vpc_to_remote_classic_link = Some(input);
            self
        }
        /// <p>Indicates whether a local VPC can communicate with a ClassicLink connection in the peer VPC over the VPC peering connection. </p>
        pub fn set_allow_egress_from_local_vpc_to_remote_classic_link(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.allow_egress_from_local_vpc_to_remote_classic_link = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcInfoPeeringOptionsDetails`](crate::model::VpcInfoPeeringOptionsDetails)
        pub fn build(self) -> crate::model::VpcInfoPeeringOptionsDetails {
            crate::model::VpcInfoPeeringOptionsDetails {
                allow_dns_resolution_from_remote_vpc: self
                    .allow_dns_resolution_from_remote_vpc
                    .unwrap_or_default(),
                allow_egress_from_local_classic_link_to_remote_vpc: self
                    .allow_egress_from_local_classic_link_to_remote_vpc
                    .unwrap_or_default(),
                allow_egress_from_local_vpc_to_remote_classic_link: self
                    .allow_egress_from_local_vpc_to_remote_classic_link
                    .unwrap_or_default(),
            }
        }
    }
}
impl VpcInfoPeeringOptionsDetails {
    /// Creates a new builder-style object to manufacture [`VpcInfoPeeringOptionsDetails`](crate::model::VpcInfoPeeringOptionsDetails)
    pub fn builder() -> crate::model::vpc_info_peering_options_details::Builder {
        crate::model::vpc_info_peering_options_details::Builder::default()
    }
}

/// <p>Provides details about the IPv6 CIDR blocks for the VPC. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcInfoIpv6CidrBlockSetDetails {
    /// <p>The IPv6 CIDR block for the VPC. </p>
    pub ipv6_cidr_block: std::option::Option<std::string::String>,
}
impl VpcInfoIpv6CidrBlockSetDetails {
    /// <p>The IPv6 CIDR block for the VPC. </p>
    pub fn ipv6_cidr_block(&self) -> std::option::Option<&str> {
        self.ipv6_cidr_block.as_deref()
    }
}
impl std::fmt::Debug for VpcInfoIpv6CidrBlockSetDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcInfoIpv6CidrBlockSetDetails");
        formatter.field("ipv6_cidr_block", &self.ipv6_cidr_block);
        formatter.finish()
    }
}
/// See [`VpcInfoIpv6CidrBlockSetDetails`](crate::model::VpcInfoIpv6CidrBlockSetDetails)
pub mod vpc_info_ipv6_cidr_block_set_details {

    /// A builder for [`VpcInfoIpv6CidrBlockSetDetails`](crate::model::VpcInfoIpv6CidrBlockSetDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ipv6_cidr_block: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IPv6 CIDR block for the VPC. </p>
        pub fn ipv6_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.ipv6_cidr_block = Some(input.into());
            self
        }
        /// <p>The IPv6 CIDR block for the VPC. </p>
        pub fn set_ipv6_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ipv6_cidr_block = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcInfoIpv6CidrBlockSetDetails`](crate::model::VpcInfoIpv6CidrBlockSetDetails)
        pub fn build(self) -> crate::model::VpcInfoIpv6CidrBlockSetDetails {
            crate::model::VpcInfoIpv6CidrBlockSetDetails {
                ipv6_cidr_block: self.ipv6_cidr_block,
            }
        }
    }
}
impl VpcInfoIpv6CidrBlockSetDetails {
    /// Creates a new builder-style object to manufacture [`VpcInfoIpv6CidrBlockSetDetails`](crate::model::VpcInfoIpv6CidrBlockSetDetails)
    pub fn builder() -> crate::model::vpc_info_ipv6_cidr_block_set_details::Builder {
        crate::model::vpc_info_ipv6_cidr_block_set_details::Builder::default()
    }
}

/// <p>Provides details about the IPv4 CIDR blocks for the VPC. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcInfoCidrBlockSetDetails {
    /// <p>The IPv4 CIDR block for the VPC. </p>
    pub cidr_block: std::option::Option<std::string::String>,
}
impl VpcInfoCidrBlockSetDetails {
    /// <p>The IPv4 CIDR block for the VPC. </p>
    pub fn cidr_block(&self) -> std::option::Option<&str> {
        self.cidr_block.as_deref()
    }
}
impl std::fmt::Debug for VpcInfoCidrBlockSetDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcInfoCidrBlockSetDetails");
        formatter.field("cidr_block", &self.cidr_block);
        formatter.finish()
    }
}
/// See [`VpcInfoCidrBlockSetDetails`](crate::model::VpcInfoCidrBlockSetDetails)
pub mod vpc_info_cidr_block_set_details {

    /// A builder for [`VpcInfoCidrBlockSetDetails`](crate::model::VpcInfoCidrBlockSetDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cidr_block: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IPv4 CIDR block for the VPC. </p>
        pub fn cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr_block = Some(input.into());
            self
        }
        /// <p>The IPv4 CIDR block for the VPC. </p>
        pub fn set_cidr_block(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr_block = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcInfoCidrBlockSetDetails`](crate::model::VpcInfoCidrBlockSetDetails)
        pub fn build(self) -> crate::model::VpcInfoCidrBlockSetDetails {
            crate::model::VpcInfoCidrBlockSetDetails {
                cidr_block: self.cidr_block,
            }
        }
    }
}
impl VpcInfoCidrBlockSetDetails {
    /// Creates a new builder-style object to manufacture [`VpcInfoCidrBlockSetDetails`](crate::model::VpcInfoCidrBlockSetDetails)
    pub fn builder() -> crate::model::vpc_info_cidr_block_set_details::Builder {
        crate::model::vpc_info_cidr_block_set_details::Builder::default()
    }
}

/// <p>Specifies an alarm and associates it with the specified metric or metric math expression. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCloudWatchAlarmDetails {
    /// <p>Indicates whether actions should be executed during any changes to the alarm state. </p>
    pub actions_enabled: bool,
    /// <p>The list of actions, specified as Amazon Resource Names (ARNs) to execute when this alarm transitions into an <code>ALARM</code> state from any other state. </p>
    pub alarm_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ARN of the alarm. </p>
    pub alarm_arn: std::option::Option<std::string::String>,
    /// <p>The time stamp of the last update to the alarm configuration. </p>
    pub alarm_configuration_updated_timestamp: std::option::Option<std::string::String>,
    /// <p>The description of the alarm. </p>
    pub alarm_description: std::option::Option<std::string::String>,
    /// <p>The name of the alarm. If you don't specify a name, CloudFront generates a unique physical ID and uses that ID for the alarm name. </p>
    pub alarm_name: std::option::Option<std::string::String>,
    /// <p>The arithmetic operation to use when comparing the specified statistic and threshold. The specified statistic value is used as the first operand. </p>
    pub comparison_operator: std::option::Option<std::string::String>,
    /// <p>The number of datapoints that must be breaching to trigger the alarm. </p>
    pub datapoints_to_alarm: i32,
    /// <p>The dimensions for the metric associated with the alarm. </p>
    pub dimensions:
        std::option::Option<std::vec::Vec<crate::model::AwsCloudWatchAlarmDimensionsDetails>>,
    /// <p>Used only for alarms based on percentiles. If <code>ignore</code>, the alarm state does not change during periods with too few data points to be statistically significant. If <code>evaluate</code> or this parameter is not used, the alarm is always evaluated and possibly changes state no matter how many data points are available. </p>
    pub evaluate_low_sample_count_percentile: std::option::Option<std::string::String>,
    /// <p>The number of periods over which data is compared to the specified threshold. </p>
    pub evaluation_periods: i32,
    /// <p>The percentile statistic for the metric associated with the alarm. </p>
    pub extended_statistic: std::option::Option<std::string::String>,
    /// <p>The actions to execute when this alarm transitions to the <code>INSUFFICIENT_DATA</code> state from any other state. Each action is specified as an ARN. </p>
    pub insufficient_data_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you use <code>Metrics</code> instead and you can't specify <code>MetricName</code>. </p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>The namespace of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you can't specify <code>Namespace</code> and you use <code>Metrics</code> instead. </p>
    pub namespace: std::option::Option<std::string::String>,
    /// <p>The actions to execute when this alarm transitions to the <code>OK</code> state from any other state. Each action is specified as an ARN. </p>
    pub ok_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The period, in seconds, over which the statistic is applied. This is required for an alarm based on a metric. </p>
    pub period: i32,
    /// <p>The statistic for the metric associated with the alarm, other than percentile. For percentile statistics, use <code>ExtendedStatistic</code>.</p>
    /// <p>For an alarm based on a metric, you must specify either <code>Statistic</code> or <code>ExtendedStatistic</code> but not both.</p>
    /// <p>For an alarm based on a math expression, you can't specify <code>Statistic</code>. Instead, you use <code>Metrics</code>.</p>
    pub statistic: std::option::Option<std::string::String>,
    /// <p>The value to compare with the specified statistic. </p>
    pub threshold: f64,
    /// <p>n an alarm based on an anomaly detection model, this is the ID of the <code>ANOMALY_DETECTION_BAND</code> function used as the threshold for the alarm. </p>
    pub threshold_metric_id: std::option::Option<std::string::String>,
    /// <p>Sets how this alarm is to handle missing data points. </p>
    pub treat_missing_data: std::option::Option<std::string::String>,
    /// <p>The unit of the metric associated with the alarm. </p>
    pub unit: std::option::Option<std::string::String>,
}
impl AwsCloudWatchAlarmDetails {
    /// <p>Indicates whether actions should be executed during any changes to the alarm state. </p>
    pub fn actions_enabled(&self) -> bool {
        self.actions_enabled
    }
    /// <p>The list of actions, specified as Amazon Resource Names (ARNs) to execute when this alarm transitions into an <code>ALARM</code> state from any other state. </p>
    pub fn alarm_actions(&self) -> std::option::Option<&[std::string::String]> {
        self.alarm_actions.as_deref()
    }
    /// <p>The ARN of the alarm. </p>
    pub fn alarm_arn(&self) -> std::option::Option<&str> {
        self.alarm_arn.as_deref()
    }
    /// <p>The time stamp of the last update to the alarm configuration. </p>
    pub fn alarm_configuration_updated_timestamp(&self) -> std::option::Option<&str> {
        self.alarm_configuration_updated_timestamp.as_deref()
    }
    /// <p>The description of the alarm. </p>
    pub fn alarm_description(&self) -> std::option::Option<&str> {
        self.alarm_description.as_deref()
    }
    /// <p>The name of the alarm. If you don't specify a name, CloudFront generates a unique physical ID and uses that ID for the alarm name. </p>
    pub fn alarm_name(&self) -> std::option::Option<&str> {
        self.alarm_name.as_deref()
    }
    /// <p>The arithmetic operation to use when comparing the specified statistic and threshold. The specified statistic value is used as the first operand. </p>
    pub fn comparison_operator(&self) -> std::option::Option<&str> {
        self.comparison_operator.as_deref()
    }
    /// <p>The number of datapoints that must be breaching to trigger the alarm. </p>
    pub fn datapoints_to_alarm(&self) -> i32 {
        self.datapoints_to_alarm
    }
    /// <p>The dimensions for the metric associated with the alarm. </p>
    pub fn dimensions(
        &self,
    ) -> std::option::Option<&[crate::model::AwsCloudWatchAlarmDimensionsDetails]> {
        self.dimensions.as_deref()
    }
    /// <p>Used only for alarms based on percentiles. If <code>ignore</code>, the alarm state does not change during periods with too few data points to be statistically significant. If <code>evaluate</code> or this parameter is not used, the alarm is always evaluated and possibly changes state no matter how many data points are available. </p>
    pub fn evaluate_low_sample_count_percentile(&self) -> std::option::Option<&str> {
        self.evaluate_low_sample_count_percentile.as_deref()
    }
    /// <p>The number of periods over which data is compared to the specified threshold. </p>
    pub fn evaluation_periods(&self) -> i32 {
        self.evaluation_periods
    }
    /// <p>The percentile statistic for the metric associated with the alarm. </p>
    pub fn extended_statistic(&self) -> std::option::Option<&str> {
        self.extended_statistic.as_deref()
    }
    /// <p>The actions to execute when this alarm transitions to the <code>INSUFFICIENT_DATA</code> state from any other state. Each action is specified as an ARN. </p>
    pub fn insufficient_data_actions(&self) -> std::option::Option<&[std::string::String]> {
        self.insufficient_data_actions.as_deref()
    }
    /// <p>The name of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you use <code>Metrics</code> instead and you can't specify <code>MetricName</code>. </p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
    /// <p>The namespace of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you can't specify <code>Namespace</code> and you use <code>Metrics</code> instead. </p>
    pub fn namespace(&self) -> std::option::Option<&str> {
        self.namespace.as_deref()
    }
    /// <p>The actions to execute when this alarm transitions to the <code>OK</code> state from any other state. Each action is specified as an ARN. </p>
    pub fn ok_actions(&self) -> std::option::Option<&[std::string::String]> {
        self.ok_actions.as_deref()
    }
    /// <p>The period, in seconds, over which the statistic is applied. This is required for an alarm based on a metric. </p>
    pub fn period(&self) -> i32 {
        self.period
    }
    /// <p>The statistic for the metric associated with the alarm, other than percentile. For percentile statistics, use <code>ExtendedStatistic</code>.</p>
    /// <p>For an alarm based on a metric, you must specify either <code>Statistic</code> or <code>ExtendedStatistic</code> but not both.</p>
    /// <p>For an alarm based on a math expression, you can't specify <code>Statistic</code>. Instead, you use <code>Metrics</code>.</p>
    pub fn statistic(&self) -> std::option::Option<&str> {
        self.statistic.as_deref()
    }
    /// <p>The value to compare with the specified statistic. </p>
    pub fn threshold(&self) -> f64 {
        self.threshold
    }
    /// <p>n an alarm based on an anomaly detection model, this is the ID of the <code>ANOMALY_DETECTION_BAND</code> function used as the threshold for the alarm. </p>
    pub fn threshold_metric_id(&self) -> std::option::Option<&str> {
        self.threshold_metric_id.as_deref()
    }
    /// <p>Sets how this alarm is to handle missing data points. </p>
    pub fn treat_missing_data(&self) -> std::option::Option<&str> {
        self.treat_missing_data.as_deref()
    }
    /// <p>The unit of the metric associated with the alarm. </p>
    pub fn unit(&self) -> std::option::Option<&str> {
        self.unit.as_deref()
    }
}
impl std::fmt::Debug for AwsCloudWatchAlarmDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCloudWatchAlarmDetails");
        formatter.field("actions_enabled", &self.actions_enabled);
        formatter.field("alarm_actions", &self.alarm_actions);
        formatter.field("alarm_arn", &self.alarm_arn);
        formatter.field(
            "alarm_configuration_updated_timestamp",
            &self.alarm_configuration_updated_timestamp,
        );
        formatter.field("alarm_description", &self.alarm_description);
        formatter.field("alarm_name", &self.alarm_name);
        formatter.field("comparison_operator", &self.comparison_operator);
        formatter.field("datapoints_to_alarm", &self.datapoints_to_alarm);
        formatter.field("dimensions", &self.dimensions);
        formatter.field(
            "evaluate_low_sample_count_percentile",
            &self.evaluate_low_sample_count_percentile,
        );
        formatter.field("evaluation_periods", &self.evaluation_periods);
        formatter.field("extended_statistic", &self.extended_statistic);
        formatter.field("insufficient_data_actions", &self.insufficient_data_actions);
        formatter.field("metric_name", &self.metric_name);
        formatter.field("namespace", &self.namespace);
        formatter.field("ok_actions", &self.ok_actions);
        formatter.field("period", &self.period);
        formatter.field("statistic", &self.statistic);
        formatter.field("threshold", &self.threshold);
        formatter.field("threshold_metric_id", &self.threshold_metric_id);
        formatter.field("treat_missing_data", &self.treat_missing_data);
        formatter.field("unit", &self.unit);
        formatter.finish()
    }
}
/// See [`AwsCloudWatchAlarmDetails`](crate::model::AwsCloudWatchAlarmDetails)
pub mod aws_cloud_watch_alarm_details {

    /// A builder for [`AwsCloudWatchAlarmDetails`](crate::model::AwsCloudWatchAlarmDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) actions_enabled: std::option::Option<bool>,
        pub(crate) alarm_actions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) alarm_arn: std::option::Option<std::string::String>,
        pub(crate) alarm_configuration_updated_timestamp: std::option::Option<std::string::String>,
        pub(crate) alarm_description: std::option::Option<std::string::String>,
        pub(crate) alarm_name: std::option::Option<std::string::String>,
        pub(crate) comparison_operator: std::option::Option<std::string::String>,
        pub(crate) datapoints_to_alarm: std::option::Option<i32>,
        pub(crate) dimensions:
            std::option::Option<std::vec::Vec<crate::model::AwsCloudWatchAlarmDimensionsDetails>>,
        pub(crate) evaluate_low_sample_count_percentile: std::option::Option<std::string::String>,
        pub(crate) evaluation_periods: std::option::Option<i32>,
        pub(crate) extended_statistic: std::option::Option<std::string::String>,
        pub(crate) insufficient_data_actions:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) ok_actions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) period: std::option::Option<i32>,
        pub(crate) statistic: std::option::Option<std::string::String>,
        pub(crate) threshold: std::option::Option<f64>,
        pub(crate) threshold_metric_id: std::option::Option<std::string::String>,
        pub(crate) treat_missing_data: std::option::Option<std::string::String>,
        pub(crate) unit: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates whether actions should be executed during any changes to the alarm state. </p>
        pub fn actions_enabled(mut self, input: bool) -> Self {
            self.actions_enabled = Some(input);
            self
        }
        /// <p>Indicates whether actions should be executed during any changes to the alarm state. </p>
        pub fn set_actions_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.actions_enabled = input;
            self
        }
        /// Appends an item to `alarm_actions`.
        ///
        /// To override the contents of this collection use [`set_alarm_actions`](Self::set_alarm_actions).
        ///
        /// <p>The list of actions, specified as Amazon Resource Names (ARNs) to execute when this alarm transitions into an <code>ALARM</code> state from any other state. </p>
        pub fn alarm_actions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.alarm_actions.unwrap_or_default();
            v.push(input.into());
            self.alarm_actions = Some(v);
            self
        }
        /// <p>The list of actions, specified as Amazon Resource Names (ARNs) to execute when this alarm transitions into an <code>ALARM</code> state from any other state. </p>
        pub fn set_alarm_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.alarm_actions = input;
            self
        }
        /// <p>The ARN of the alarm. </p>
        pub fn alarm_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.alarm_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the alarm. </p>
        pub fn set_alarm_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alarm_arn = input;
            self
        }
        /// <p>The time stamp of the last update to the alarm configuration. </p>
        pub fn alarm_configuration_updated_timestamp(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.alarm_configuration_updated_timestamp = Some(input.into());
            self
        }
        /// <p>The time stamp of the last update to the alarm configuration. </p>
        pub fn set_alarm_configuration_updated_timestamp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.alarm_configuration_updated_timestamp = input;
            self
        }
        /// <p>The description of the alarm. </p>
        pub fn alarm_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.alarm_description = Some(input.into());
            self
        }
        /// <p>The description of the alarm. </p>
        pub fn set_alarm_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.alarm_description = input;
            self
        }
        /// <p>The name of the alarm. If you don't specify a name, CloudFront generates a unique physical ID and uses that ID for the alarm name. </p>
        pub fn alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.alarm_name = Some(input.into());
            self
        }
        /// <p>The name of the alarm. If you don't specify a name, CloudFront generates a unique physical ID and uses that ID for the alarm name. </p>
        pub fn set_alarm_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alarm_name = input;
            self
        }
        /// <p>The arithmetic operation to use when comparing the specified statistic and threshold. The specified statistic value is used as the first operand. </p>
        pub fn comparison_operator(mut self, input: impl Into<std::string::String>) -> Self {
            self.comparison_operator = Some(input.into());
            self
        }
        /// <p>The arithmetic operation to use when comparing the specified statistic and threshold. The specified statistic value is used as the first operand. </p>
        pub fn set_comparison_operator(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.comparison_operator = input;
            self
        }
        /// <p>The number of datapoints that must be breaching to trigger the alarm. </p>
        pub fn datapoints_to_alarm(mut self, input: i32) -> Self {
            self.datapoints_to_alarm = Some(input);
            self
        }
        /// <p>The number of datapoints that must be breaching to trigger the alarm. </p>
        pub fn set_datapoints_to_alarm(mut self, input: std::option::Option<i32>) -> Self {
            self.datapoints_to_alarm = input;
            self
        }
        /// Appends an item to `dimensions`.
        ///
        /// To override the contents of this collection use [`set_dimensions`](Self::set_dimensions).
        ///
        /// <p>The dimensions for the metric associated with the alarm. </p>
        pub fn dimensions(
            mut self,
            input: crate::model::AwsCloudWatchAlarmDimensionsDetails,
        ) -> Self {
            let mut v = self.dimensions.unwrap_or_default();
            v.push(input);
            self.dimensions = Some(v);
            self
        }
        /// <p>The dimensions for the metric associated with the alarm. </p>
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsCloudWatchAlarmDimensionsDetails>,
            >,
        ) -> Self {
            self.dimensions = input;
            self
        }
        /// <p>Used only for alarms based on percentiles. If <code>ignore</code>, the alarm state does not change during periods with too few data points to be statistically significant. If <code>evaluate</code> or this parameter is not used, the alarm is always evaluated and possibly changes state no matter how many data points are available. </p>
        pub fn evaluate_low_sample_count_percentile(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.evaluate_low_sample_count_percentile = Some(input.into());
            self
        }
        /// <p>Used only for alarms based on percentiles. If <code>ignore</code>, the alarm state does not change during periods with too few data points to be statistically significant. If <code>evaluate</code> or this parameter is not used, the alarm is always evaluated and possibly changes state no matter how many data points are available. </p>
        pub fn set_evaluate_low_sample_count_percentile(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.evaluate_low_sample_count_percentile = input;
            self
        }
        /// <p>The number of periods over which data is compared to the specified threshold. </p>
        pub fn evaluation_periods(mut self, input: i32) -> Self {
            self.evaluation_periods = Some(input);
            self
        }
        /// <p>The number of periods over which data is compared to the specified threshold. </p>
        pub fn set_evaluation_periods(mut self, input: std::option::Option<i32>) -> Self {
            self.evaluation_periods = input;
            self
        }
        /// <p>The percentile statistic for the metric associated with the alarm. </p>
        pub fn extended_statistic(mut self, input: impl Into<std::string::String>) -> Self {
            self.extended_statistic = Some(input.into());
            self
        }
        /// <p>The percentile statistic for the metric associated with the alarm. </p>
        pub fn set_extended_statistic(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.extended_statistic = input;
            self
        }
        /// Appends an item to `insufficient_data_actions`.
        ///
        /// To override the contents of this collection use [`set_insufficient_data_actions`](Self::set_insufficient_data_actions).
        ///
        /// <p>The actions to execute when this alarm transitions to the <code>INSUFFICIENT_DATA</code> state from any other state. Each action is specified as an ARN. </p>
        pub fn insufficient_data_actions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.insufficient_data_actions.unwrap_or_default();
            v.push(input.into());
            self.insufficient_data_actions = Some(v);
            self
        }
        /// <p>The actions to execute when this alarm transitions to the <code>INSUFFICIENT_DATA</code> state from any other state. Each action is specified as an ARN. </p>
        pub fn set_insufficient_data_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.insufficient_data_actions = input;
            self
        }
        /// <p>The name of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you use <code>Metrics</code> instead and you can't specify <code>MetricName</code>. </p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>The name of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you use <code>Metrics</code> instead and you can't specify <code>MetricName</code>. </p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The namespace of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you can't specify <code>Namespace</code> and you use <code>Metrics</code> instead. </p>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>The namespace of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you can't specify <code>Namespace</code> and you use <code>Metrics</code> instead. </p>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// Appends an item to `ok_actions`.
        ///
        /// To override the contents of this collection use [`set_ok_actions`](Self::set_ok_actions).
        ///
        /// <p>The actions to execute when this alarm transitions to the <code>OK</code> state from any other state. Each action is specified as an ARN. </p>
        pub fn ok_actions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ok_actions.unwrap_or_default();
            v.push(input.into());
            self.ok_actions = Some(v);
            self
        }
        /// <p>The actions to execute when this alarm transitions to the <code>OK</code> state from any other state. Each action is specified as an ARN. </p>
        pub fn set_ok_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ok_actions = input;
            self
        }
        /// <p>The period, in seconds, over which the statistic is applied. This is required for an alarm based on a metric. </p>
        pub fn period(mut self, input: i32) -> Self {
            self.period = Some(input);
            self
        }
        /// <p>The period, in seconds, over which the statistic is applied. This is required for an alarm based on a metric. </p>
        pub fn set_period(mut self, input: std::option::Option<i32>) -> Self {
            self.period = input;
            self
        }
        /// <p>The statistic for the metric associated with the alarm, other than percentile. For percentile statistics, use <code>ExtendedStatistic</code>.</p>
        /// <p>For an alarm based on a metric, you must specify either <code>Statistic</code> or <code>ExtendedStatistic</code> but not both.</p>
        /// <p>For an alarm based on a math expression, you can't specify <code>Statistic</code>. Instead, you use <code>Metrics</code>.</p>
        pub fn statistic(mut self, input: impl Into<std::string::String>) -> Self {
            self.statistic = Some(input.into());
            self
        }
        /// <p>The statistic for the metric associated with the alarm, other than percentile. For percentile statistics, use <code>ExtendedStatistic</code>.</p>
        /// <p>For an alarm based on a metric, you must specify either <code>Statistic</code> or <code>ExtendedStatistic</code> but not both.</p>
        /// <p>For an alarm based on a math expression, you can't specify <code>Statistic</code>. Instead, you use <code>Metrics</code>.</p>
        pub fn set_statistic(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.statistic = input;
            self
        }
        /// <p>The value to compare with the specified statistic. </p>
        pub fn threshold(mut self, input: f64) -> Self {
            self.threshold = Some(input);
            self
        }
        /// <p>The value to compare with the specified statistic. </p>
        pub fn set_threshold(mut self, input: std::option::Option<f64>) -> Self {
            self.threshold = input;
            self
        }
        /// <p>n an alarm based on an anomaly detection model, this is the ID of the <code>ANOMALY_DETECTION_BAND</code> function used as the threshold for the alarm. </p>
        pub fn threshold_metric_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.threshold_metric_id = Some(input.into());
            self
        }
        /// <p>n an alarm based on an anomaly detection model, this is the ID of the <code>ANOMALY_DETECTION_BAND</code> function used as the threshold for the alarm. </p>
        pub fn set_threshold_metric_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.threshold_metric_id = input;
            self
        }
        /// <p>Sets how this alarm is to handle missing data points. </p>
        pub fn treat_missing_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.treat_missing_data = Some(input.into());
            self
        }
        /// <p>Sets how this alarm is to handle missing data points. </p>
        pub fn set_treat_missing_data(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.treat_missing_data = input;
            self
        }
        /// <p>The unit of the metric associated with the alarm. </p>
        pub fn unit(mut self, input: impl Into<std::string::String>) -> Self {
            self.unit = Some(input.into());
            self
        }
        /// <p>The unit of the metric associated with the alarm. </p>
        pub fn set_unit(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.unit = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCloudWatchAlarmDetails`](crate::model::AwsCloudWatchAlarmDetails)
        pub fn build(self) -> crate::model::AwsCloudWatchAlarmDetails {
            crate::model::AwsCloudWatchAlarmDetails {
                actions_enabled: self.actions_enabled.unwrap_or_default(),
                alarm_actions: self.alarm_actions,
                alarm_arn: self.alarm_arn,
                alarm_configuration_updated_timestamp: self.alarm_configuration_updated_timestamp,
                alarm_description: self.alarm_description,
                alarm_name: self.alarm_name,
                comparison_operator: self.comparison_operator,
                datapoints_to_alarm: self.datapoints_to_alarm.unwrap_or_default(),
                dimensions: self.dimensions,
                evaluate_low_sample_count_percentile: self.evaluate_low_sample_count_percentile,
                evaluation_periods: self.evaluation_periods.unwrap_or_default(),
                extended_statistic: self.extended_statistic,
                insufficient_data_actions: self.insufficient_data_actions,
                metric_name: self.metric_name,
                namespace: self.namespace,
                ok_actions: self.ok_actions,
                period: self.period.unwrap_or_default(),
                statistic: self.statistic,
                threshold: self.threshold.unwrap_or_default(),
                threshold_metric_id: self.threshold_metric_id,
                treat_missing_data: self.treat_missing_data,
                unit: self.unit,
            }
        }
    }
}
impl AwsCloudWatchAlarmDetails {
    /// Creates a new builder-style object to manufacture [`AwsCloudWatchAlarmDetails`](crate::model::AwsCloudWatchAlarmDetails)
    pub fn builder() -> crate::model::aws_cloud_watch_alarm_details::Builder {
        crate::model::aws_cloud_watch_alarm_details::Builder::default()
    }
}

/// <p>Details about the dimensions for the metric associated with the alarm. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCloudWatchAlarmDimensionsDetails {
    /// <p>The name of a dimension. </p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The value of a dimension. </p>
    pub value: std::option::Option<std::string::String>,
}
impl AwsCloudWatchAlarmDimensionsDetails {
    /// <p>The name of a dimension. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The value of a dimension. </p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for AwsCloudWatchAlarmDimensionsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCloudWatchAlarmDimensionsDetails");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`AwsCloudWatchAlarmDimensionsDetails`](crate::model::AwsCloudWatchAlarmDimensionsDetails)
pub mod aws_cloud_watch_alarm_dimensions_details {

    /// A builder for [`AwsCloudWatchAlarmDimensionsDetails`](crate::model::AwsCloudWatchAlarmDimensionsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of a dimension. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of a dimension. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The value of a dimension. </p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of a dimension. </p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCloudWatchAlarmDimensionsDetails`](crate::model::AwsCloudWatchAlarmDimensionsDetails)
        pub fn build(self) -> crate::model::AwsCloudWatchAlarmDimensionsDetails {
            crate::model::AwsCloudWatchAlarmDimensionsDetails {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl AwsCloudWatchAlarmDimensionsDetails {
    /// Creates a new builder-style object to manufacture [`AwsCloudWatchAlarmDimensionsDetails`](crate::model::AwsCloudWatchAlarmDimensionsDetails)
    pub fn builder() -> crate::model::aws_cloud_watch_alarm_dimensions_details::Builder {
        crate::model::aws_cloud_watch_alarm_dimensions_details::Builder::default()
    }
}

/// <p>Nests a stack as a resource in a top-level template. Nested stacks are stacks created as resources for another stack.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCloudFormationStackDetails {
    /// <p>The capabilities allowed in the stack. </p>
    pub capabilities: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The time at which the stack was created. </p>
    pub creation_time: std::option::Option<std::string::String>,
    /// <p>A user-defined description associated with the stack. </p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Boolean to enable or disable rollback on stack creation failures. </p>
    pub disable_rollback: bool,
    /// <p>Information about whether a stack's actual configuration differs, or has drifted, from its expected configuration, as defined in the stack template and any values specified as template parameters. </p>
    pub drift_information:
        std::option::Option<crate::model::AwsCloudFormationStackDriftInformationDetails>,
    /// <p>Whether termination protection is enabled for the stack. </p>
    pub enable_termination_protection: bool,
    /// <p>The time the nested stack was last updated. This field will only be returned if the stack has been updated at least once.</p>
    pub last_updated_time: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Names (ARNs) of the Amazon SNS topic to which stack-related events are published. </p>
    pub notification_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of output structures. </p>
    pub outputs:
        std::option::Option<std::vec::Vec<crate::model::AwsCloudFormationStackOutputsDetails>>,
    /// <p>The ARN of an IAM role that's associated with the stack. </p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>Unique identifier of the stack. </p>
    pub stack_id: std::option::Option<std::string::String>,
    /// <p>The name associated with the stack. </p>
    pub stack_name: std::option::Option<std::string::String>,
    /// <p>Current status of the stack. </p>
    pub stack_status: std::option::Option<std::string::String>,
    /// <p>Success or failure message associated with the stack status. </p>
    pub stack_status_reason: std::option::Option<std::string::String>,
    /// <p>The length of time, in minutes, that CloudFormation waits for the nested stack to reach the <code>CREATE_COMPLETE</code> state. </p>
    pub timeout_in_minutes: i32,
}
impl AwsCloudFormationStackDetails {
    /// <p>The capabilities allowed in the stack. </p>
    pub fn capabilities(&self) -> std::option::Option<&[std::string::String]> {
        self.capabilities.as_deref()
    }
    /// <p>The time at which the stack was created. </p>
    pub fn creation_time(&self) -> std::option::Option<&str> {
        self.creation_time.as_deref()
    }
    /// <p>A user-defined description associated with the stack. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Boolean to enable or disable rollback on stack creation failures. </p>
    pub fn disable_rollback(&self) -> bool {
        self.disable_rollback
    }
    /// <p>Information about whether a stack's actual configuration differs, or has drifted, from its expected configuration, as defined in the stack template and any values specified as template parameters. </p>
    pub fn drift_information(
        &self,
    ) -> std::option::Option<&crate::model::AwsCloudFormationStackDriftInformationDetails> {
        self.drift_information.as_ref()
    }
    /// <p>Whether termination protection is enabled for the stack. </p>
    pub fn enable_termination_protection(&self) -> bool {
        self.enable_termination_protection
    }
    /// <p>The time the nested stack was last updated. This field will only be returned if the stack has been updated at least once.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&str> {
        self.last_updated_time.as_deref()
    }
    /// <p>The Amazon Resource Names (ARNs) of the Amazon SNS topic to which stack-related events are published. </p>
    pub fn notification_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.notification_arns.as_deref()
    }
    /// <p>A list of output structures. </p>
    pub fn outputs(
        &self,
    ) -> std::option::Option<&[crate::model::AwsCloudFormationStackOutputsDetails]> {
        self.outputs.as_deref()
    }
    /// <p>The ARN of an IAM role that's associated with the stack. </p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>Unique identifier of the stack. </p>
    pub fn stack_id(&self) -> std::option::Option<&str> {
        self.stack_id.as_deref()
    }
    /// <p>The name associated with the stack. </p>
    pub fn stack_name(&self) -> std::option::Option<&str> {
        self.stack_name.as_deref()
    }
    /// <p>Current status of the stack. </p>
    pub fn stack_status(&self) -> std::option::Option<&str> {
        self.stack_status.as_deref()
    }
    /// <p>Success or failure message associated with the stack status. </p>
    pub fn stack_status_reason(&self) -> std::option::Option<&str> {
        self.stack_status_reason.as_deref()
    }
    /// <p>The length of time, in minutes, that CloudFormation waits for the nested stack to reach the <code>CREATE_COMPLETE</code> state. </p>
    pub fn timeout_in_minutes(&self) -> i32 {
        self.timeout_in_minutes
    }
}
impl std::fmt::Debug for AwsCloudFormationStackDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCloudFormationStackDetails");
        formatter.field("capabilities", &self.capabilities);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("description", &self.description);
        formatter.field("disable_rollback", &self.disable_rollback);
        formatter.field("drift_information", &self.drift_information);
        formatter.field(
            "enable_termination_protection",
            &self.enable_termination_protection,
        );
        formatter.field("last_updated_time", &self.last_updated_time);
        formatter.field("notification_arns", &self.notification_arns);
        formatter.field("outputs", &self.outputs);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("stack_id", &self.stack_id);
        formatter.field("stack_name", &self.stack_name);
        formatter.field("stack_status", &self.stack_status);
        formatter.field("stack_status_reason", &self.stack_status_reason);
        formatter.field("timeout_in_minutes", &self.timeout_in_minutes);
        formatter.finish()
    }
}
/// See [`AwsCloudFormationStackDetails`](crate::model::AwsCloudFormationStackDetails)
pub mod aws_cloud_formation_stack_details {

    /// A builder for [`AwsCloudFormationStackDetails`](crate::model::AwsCloudFormationStackDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) capabilities: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) creation_time: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) disable_rollback: std::option::Option<bool>,
        pub(crate) drift_information:
            std::option::Option<crate::model::AwsCloudFormationStackDriftInformationDetails>,
        pub(crate) enable_termination_protection: std::option::Option<bool>,
        pub(crate) last_updated_time: std::option::Option<std::string::String>,
        pub(crate) notification_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) outputs:
            std::option::Option<std::vec::Vec<crate::model::AwsCloudFormationStackOutputsDetails>>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) stack_id: std::option::Option<std::string::String>,
        pub(crate) stack_name: std::option::Option<std::string::String>,
        pub(crate) stack_status: std::option::Option<std::string::String>,
        pub(crate) stack_status_reason: std::option::Option<std::string::String>,
        pub(crate) timeout_in_minutes: std::option::Option<i32>,
    }
    impl Builder {
        /// Appends an item to `capabilities`.
        ///
        /// To override the contents of this collection use [`set_capabilities`](Self::set_capabilities).
        ///
        /// <p>The capabilities allowed in the stack. </p>
        pub fn capabilities(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.capabilities.unwrap_or_default();
            v.push(input.into());
            self.capabilities = Some(v);
            self
        }
        /// <p>The capabilities allowed in the stack. </p>
        pub fn set_capabilities(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.capabilities = input;
            self
        }
        /// <p>The time at which the stack was created. </p>
        pub fn creation_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_time = Some(input.into());
            self
        }
        /// <p>The time at which the stack was created. </p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>A user-defined description associated with the stack. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A user-defined description associated with the stack. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Boolean to enable or disable rollback on stack creation failures. </p>
        pub fn disable_rollback(mut self, input: bool) -> Self {
            self.disable_rollback = Some(input);
            self
        }
        /// <p>Boolean to enable or disable rollback on stack creation failures. </p>
        pub fn set_disable_rollback(mut self, input: std::option::Option<bool>) -> Self {
            self.disable_rollback = input;
            self
        }
        /// <p>Information about whether a stack's actual configuration differs, or has drifted, from its expected configuration, as defined in the stack template and any values specified as template parameters. </p>
        pub fn drift_information(
            mut self,
            input: crate::model::AwsCloudFormationStackDriftInformationDetails,
        ) -> Self {
            self.drift_information = Some(input);
            self
        }
        /// <p>Information about whether a stack's actual configuration differs, or has drifted, from its expected configuration, as defined in the stack template and any values specified as template parameters. </p>
        pub fn set_drift_information(
            mut self,
            input: std::option::Option<crate::model::AwsCloudFormationStackDriftInformationDetails>,
        ) -> Self {
            self.drift_information = input;
            self
        }
        /// <p>Whether termination protection is enabled for the stack. </p>
        pub fn enable_termination_protection(mut self, input: bool) -> Self {
            self.enable_termination_protection = Some(input);
            self
        }
        /// <p>Whether termination protection is enabled for the stack. </p>
        pub fn set_enable_termination_protection(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.enable_termination_protection = input;
            self
        }
        /// <p>The time the nested stack was last updated. This field will only be returned if the stack has been updated at least once.</p>
        pub fn last_updated_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_updated_time = Some(input.into());
            self
        }
        /// <p>The time the nested stack was last updated. This field will only be returned if the stack has been updated at least once.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// Appends an item to `notification_arns`.
        ///
        /// To override the contents of this collection use [`set_notification_arns`](Self::set_notification_arns).
        ///
        /// <p>The Amazon Resource Names (ARNs) of the Amazon SNS topic to which stack-related events are published. </p>
        pub fn notification_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.notification_arns.unwrap_or_default();
            v.push(input.into());
            self.notification_arns = Some(v);
            self
        }
        /// <p>The Amazon Resource Names (ARNs) of the Amazon SNS topic to which stack-related events are published. </p>
        pub fn set_notification_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.notification_arns = input;
            self
        }
        /// Appends an item to `outputs`.
        ///
        /// To override the contents of this collection use [`set_outputs`](Self::set_outputs).
        ///
        /// <p>A list of output structures. </p>
        pub fn outputs(
            mut self,
            input: crate::model::AwsCloudFormationStackOutputsDetails,
        ) -> Self {
            let mut v = self.outputs.unwrap_or_default();
            v.push(input);
            self.outputs = Some(v);
            self
        }
        /// <p>A list of output structures. </p>
        pub fn set_outputs(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsCloudFormationStackOutputsDetails>,
            >,
        ) -> Self {
            self.outputs = input;
            self
        }
        /// <p>The ARN of an IAM role that's associated with the stack. </p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of an IAM role that's associated with the stack. </p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>Unique identifier of the stack. </p>
        pub fn stack_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.stack_id = Some(input.into());
            self
        }
        /// <p>Unique identifier of the stack. </p>
        pub fn set_stack_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stack_id = input;
            self
        }
        /// <p>The name associated with the stack. </p>
        pub fn stack_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.stack_name = Some(input.into());
            self
        }
        /// <p>The name associated with the stack. </p>
        pub fn set_stack_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stack_name = input;
            self
        }
        /// <p>Current status of the stack. </p>
        pub fn stack_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.stack_status = Some(input.into());
            self
        }
        /// <p>Current status of the stack. </p>
        pub fn set_stack_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stack_status = input;
            self
        }
        /// <p>Success or failure message associated with the stack status. </p>
        pub fn stack_status_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.stack_status_reason = Some(input.into());
            self
        }
        /// <p>Success or failure message associated with the stack status. </p>
        pub fn set_stack_status_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.stack_status_reason = input;
            self
        }
        /// <p>The length of time, in minutes, that CloudFormation waits for the nested stack to reach the <code>CREATE_COMPLETE</code> state. </p>
        pub fn timeout_in_minutes(mut self, input: i32) -> Self {
            self.timeout_in_minutes = Some(input);
            self
        }
        /// <p>The length of time, in minutes, that CloudFormation waits for the nested stack to reach the <code>CREATE_COMPLETE</code> state. </p>
        pub fn set_timeout_in_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.timeout_in_minutes = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCloudFormationStackDetails`](crate::model::AwsCloudFormationStackDetails)
        pub fn build(self) -> crate::model::AwsCloudFormationStackDetails {
            crate::model::AwsCloudFormationStackDetails {
                capabilities: self.capabilities,
                creation_time: self.creation_time,
                description: self.description,
                disable_rollback: self.disable_rollback.unwrap_or_default(),
                drift_information: self.drift_information,
                enable_termination_protection: self
                    .enable_termination_protection
                    .unwrap_or_default(),
                last_updated_time: self.last_updated_time,
                notification_arns: self.notification_arns,
                outputs: self.outputs,
                role_arn: self.role_arn,
                stack_id: self.stack_id,
                stack_name: self.stack_name,
                stack_status: self.stack_status,
                stack_status_reason: self.stack_status_reason,
                timeout_in_minutes: self.timeout_in_minutes.unwrap_or_default(),
            }
        }
    }
}
impl AwsCloudFormationStackDetails {
    /// Creates a new builder-style object to manufacture [`AwsCloudFormationStackDetails`](crate::model::AwsCloudFormationStackDetails)
    pub fn builder() -> crate::model::aws_cloud_formation_stack_details::Builder {
        crate::model::aws_cloud_formation_stack_details::Builder::default()
    }
}

/// <p>Provides information about the CloudFormation stack output. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCloudFormationStackOutputsDetails {
    /// <p>A user-defined description associated with the output. </p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The key associated with the output. </p>
    pub output_key: std::option::Option<std::string::String>,
    /// <p>The value associated with the output. </p>
    pub output_value: std::option::Option<std::string::String>,
}
impl AwsCloudFormationStackOutputsDetails {
    /// <p>A user-defined description associated with the output. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The key associated with the output. </p>
    pub fn output_key(&self) -> std::option::Option<&str> {
        self.output_key.as_deref()
    }
    /// <p>The value associated with the output. </p>
    pub fn output_value(&self) -> std::option::Option<&str> {
        self.output_value.as_deref()
    }
}
impl std::fmt::Debug for AwsCloudFormationStackOutputsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCloudFormationStackOutputsDetails");
        formatter.field("description", &self.description);
        formatter.field("output_key", &self.output_key);
        formatter.field("output_value", &self.output_value);
        formatter.finish()
    }
}
/// See [`AwsCloudFormationStackOutputsDetails`](crate::model::AwsCloudFormationStackOutputsDetails)
pub mod aws_cloud_formation_stack_outputs_details {

    /// A builder for [`AwsCloudFormationStackOutputsDetails`](crate::model::AwsCloudFormationStackOutputsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) output_key: std::option::Option<std::string::String>,
        pub(crate) output_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A user-defined description associated with the output. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A user-defined description associated with the output. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The key associated with the output. </p>
        pub fn output_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_key = Some(input.into());
            self
        }
        /// <p>The key associated with the output. </p>
        pub fn set_output_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.output_key = input;
            self
        }
        /// <p>The value associated with the output. </p>
        pub fn output_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_value = Some(input.into());
            self
        }
        /// <p>The value associated with the output. </p>
        pub fn set_output_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.output_value = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCloudFormationStackOutputsDetails`](crate::model::AwsCloudFormationStackOutputsDetails)
        pub fn build(self) -> crate::model::AwsCloudFormationStackOutputsDetails {
            crate::model::AwsCloudFormationStackOutputsDetails {
                description: self.description,
                output_key: self.output_key,
                output_value: self.output_value,
            }
        }
    }
}
impl AwsCloudFormationStackOutputsDetails {
    /// Creates a new builder-style object to manufacture [`AwsCloudFormationStackOutputsDetails`](crate::model::AwsCloudFormationStackOutputsDetails)
    pub fn builder() -> crate::model::aws_cloud_formation_stack_outputs_details::Builder {
        crate::model::aws_cloud_formation_stack_outputs_details::Builder::default()
    }
}

/// <p>Provides information about the stack's conformity to its expected template configuration. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCloudFormationStackDriftInformationDetails {
    /// <p>Status of the stack's actual configuration compared to its expected template configuration. </p>
    pub stack_drift_status: std::option::Option<std::string::String>,
}
impl AwsCloudFormationStackDriftInformationDetails {
    /// <p>Status of the stack's actual configuration compared to its expected template configuration. </p>
    pub fn stack_drift_status(&self) -> std::option::Option<&str> {
        self.stack_drift_status.as_deref()
    }
}
impl std::fmt::Debug for AwsCloudFormationStackDriftInformationDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCloudFormationStackDriftInformationDetails");
        formatter.field("stack_drift_status", &self.stack_drift_status);
        formatter.finish()
    }
}
/// See [`AwsCloudFormationStackDriftInformationDetails`](crate::model::AwsCloudFormationStackDriftInformationDetails)
pub mod aws_cloud_formation_stack_drift_information_details {

    /// A builder for [`AwsCloudFormationStackDriftInformationDetails`](crate::model::AwsCloudFormationStackDriftInformationDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stack_drift_status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Status of the stack's actual configuration compared to its expected template configuration. </p>
        pub fn stack_drift_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.stack_drift_status = Some(input.into());
            self
        }
        /// <p>Status of the stack's actual configuration compared to its expected template configuration. </p>
        pub fn set_stack_drift_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.stack_drift_status = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCloudFormationStackDriftInformationDetails`](crate::model::AwsCloudFormationStackDriftInformationDetails)
        pub fn build(self) -> crate::model::AwsCloudFormationStackDriftInformationDetails {
            crate::model::AwsCloudFormationStackDriftInformationDetails {
                stack_drift_status: self.stack_drift_status,
            }
        }
    }
}
impl AwsCloudFormationStackDriftInformationDetails {
    /// Creates a new builder-style object to manufacture [`AwsCloudFormationStackDriftInformationDetails`](crate::model::AwsCloudFormationStackDriftInformationDetails)
    pub fn builder() -> crate::model::aws_cloud_formation_stack_drift_information_details::Builder {
        crate::model::aws_cloud_formation_stack_drift_information_details::Builder::default()
    }
}

/// <p>Provides information about an Amazon EFS access point. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEfsAccessPointDetails {
    /// <p>The ID of the Amazon EFS access point. </p>
    pub access_point_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Amazon EFS access point. </p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The opaque string specified in the request to ensure idempotent creation. </p>
    pub client_token: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon EFS file system that the access point applies to. </p>
    pub file_system_id: std::option::Option<std::string::String>,
    /// <p>The full POSIX identity, including the user ID, group ID, and secondary group IDs on the access point, that is used for all file operations by NFS clients using the access point. </p>
    pub posix_user: std::option::Option<crate::model::AwsEfsAccessPointPosixUserDetails>,
    /// <p>The directory on the Amazon EFS file system that the access point exposes as the root directory to NFS clients using the access point. </p>
    pub root_directory: std::option::Option<crate::model::AwsEfsAccessPointRootDirectoryDetails>,
}
impl AwsEfsAccessPointDetails {
    /// <p>The ID of the Amazon EFS access point. </p>
    pub fn access_point_id(&self) -> std::option::Option<&str> {
        self.access_point_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Amazon EFS access point. </p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The opaque string specified in the request to ensure idempotent creation. </p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
    /// <p>The ID of the Amazon EFS file system that the access point applies to. </p>
    pub fn file_system_id(&self) -> std::option::Option<&str> {
        self.file_system_id.as_deref()
    }
    /// <p>The full POSIX identity, including the user ID, group ID, and secondary group IDs on the access point, that is used for all file operations by NFS clients using the access point. </p>
    pub fn posix_user(
        &self,
    ) -> std::option::Option<&crate::model::AwsEfsAccessPointPosixUserDetails> {
        self.posix_user.as_ref()
    }
    /// <p>The directory on the Amazon EFS file system that the access point exposes as the root directory to NFS clients using the access point. </p>
    pub fn root_directory(
        &self,
    ) -> std::option::Option<&crate::model::AwsEfsAccessPointRootDirectoryDetails> {
        self.root_directory.as_ref()
    }
}
impl std::fmt::Debug for AwsEfsAccessPointDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEfsAccessPointDetails");
        formatter.field("access_point_id", &self.access_point_id);
        formatter.field("arn", &self.arn);
        formatter.field("client_token", &self.client_token);
        formatter.field("file_system_id", &self.file_system_id);
        formatter.field("posix_user", &self.posix_user);
        formatter.field("root_directory", &self.root_directory);
        formatter.finish()
    }
}
/// See [`AwsEfsAccessPointDetails`](crate::model::AwsEfsAccessPointDetails)
pub mod aws_efs_access_point_details {

    /// A builder for [`AwsEfsAccessPointDetails`](crate::model::AwsEfsAccessPointDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) access_point_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) file_system_id: std::option::Option<std::string::String>,
        pub(crate) posix_user: std::option::Option<crate::model::AwsEfsAccessPointPosixUserDetails>,
        pub(crate) root_directory:
            std::option::Option<crate::model::AwsEfsAccessPointRootDirectoryDetails>,
    }
    impl Builder {
        /// <p>The ID of the Amazon EFS access point. </p>
        pub fn access_point_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.access_point_id = Some(input.into());
            self
        }
        /// <p>The ID of the Amazon EFS access point. </p>
        pub fn set_access_point_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.access_point_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon EFS access point. </p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon EFS access point. </p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The opaque string specified in the request to ensure idempotent creation. </p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>The opaque string specified in the request to ensure idempotent creation. </p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// <p>The ID of the Amazon EFS file system that the access point applies to. </p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_system_id = Some(input.into());
            self
        }
        /// <p>The ID of the Amazon EFS file system that the access point applies to. </p>
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.file_system_id = input;
            self
        }
        /// <p>The full POSIX identity, including the user ID, group ID, and secondary group IDs on the access point, that is used for all file operations by NFS clients using the access point. </p>
        pub fn posix_user(
            mut self,
            input: crate::model::AwsEfsAccessPointPosixUserDetails,
        ) -> Self {
            self.posix_user = Some(input);
            self
        }
        /// <p>The full POSIX identity, including the user ID, group ID, and secondary group IDs on the access point, that is used for all file operations by NFS clients using the access point. </p>
        pub fn set_posix_user(
            mut self,
            input: std::option::Option<crate::model::AwsEfsAccessPointPosixUserDetails>,
        ) -> Self {
            self.posix_user = input;
            self
        }
        /// <p>The directory on the Amazon EFS file system that the access point exposes as the root directory to NFS clients using the access point. </p>
        pub fn root_directory(
            mut self,
            input: crate::model::AwsEfsAccessPointRootDirectoryDetails,
        ) -> Self {
            self.root_directory = Some(input);
            self
        }
        /// <p>The directory on the Amazon EFS file system that the access point exposes as the root directory to NFS clients using the access point. </p>
        pub fn set_root_directory(
            mut self,
            input: std::option::Option<crate::model::AwsEfsAccessPointRootDirectoryDetails>,
        ) -> Self {
            self.root_directory = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEfsAccessPointDetails`](crate::model::AwsEfsAccessPointDetails)
        pub fn build(self) -> crate::model::AwsEfsAccessPointDetails {
            crate::model::AwsEfsAccessPointDetails {
                access_point_id: self.access_point_id,
                arn: self.arn,
                client_token: self.client_token,
                file_system_id: self.file_system_id,
                posix_user: self.posix_user,
                root_directory: self.root_directory,
            }
        }
    }
}
impl AwsEfsAccessPointDetails {
    /// Creates a new builder-style object to manufacture [`AwsEfsAccessPointDetails`](crate::model::AwsEfsAccessPointDetails)
    pub fn builder() -> crate::model::aws_efs_access_point_details::Builder {
        crate::model::aws_efs_access_point_details::Builder::default()
    }
}

/// <p>Provides information about the directory on the Amazon EFS file system that the access point exposes as the root directory to NFS clients using the access point. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEfsAccessPointRootDirectoryDetails {
    /// <p>Specifies the POSIX IDs and permissions to apply to the access point's root directory. </p>
    pub creation_info:
        std::option::Option<crate::model::AwsEfsAccessPointRootDirectoryCreationInfoDetails>,
    /// <p>Specifies the path on the Amazon EFS file system to expose as the root directory to NFS clients using the access point to access the EFS file system. A path can have up to four subdirectories. If the specified path does not exist, you are required to provide <code>CreationInfo</code>. </p>
    pub path: std::option::Option<std::string::String>,
}
impl AwsEfsAccessPointRootDirectoryDetails {
    /// <p>Specifies the POSIX IDs and permissions to apply to the access point's root directory. </p>
    pub fn creation_info(
        &self,
    ) -> std::option::Option<&crate::model::AwsEfsAccessPointRootDirectoryCreationInfoDetails> {
        self.creation_info.as_ref()
    }
    /// <p>Specifies the path on the Amazon EFS file system to expose as the root directory to NFS clients using the access point to access the EFS file system. A path can have up to four subdirectories. If the specified path does not exist, you are required to provide <code>CreationInfo</code>. </p>
    pub fn path(&self) -> std::option::Option<&str> {
        self.path.as_deref()
    }
}
impl std::fmt::Debug for AwsEfsAccessPointRootDirectoryDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEfsAccessPointRootDirectoryDetails");
        formatter.field("creation_info", &self.creation_info);
        formatter.field("path", &self.path);
        formatter.finish()
    }
}
/// See [`AwsEfsAccessPointRootDirectoryDetails`](crate::model::AwsEfsAccessPointRootDirectoryDetails)
pub mod aws_efs_access_point_root_directory_details {

    /// A builder for [`AwsEfsAccessPointRootDirectoryDetails`](crate::model::AwsEfsAccessPointRootDirectoryDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) creation_info:
            std::option::Option<crate::model::AwsEfsAccessPointRootDirectoryCreationInfoDetails>,
        pub(crate) path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the POSIX IDs and permissions to apply to the access point's root directory. </p>
        pub fn creation_info(
            mut self,
            input: crate::model::AwsEfsAccessPointRootDirectoryCreationInfoDetails,
        ) -> Self {
            self.creation_info = Some(input);
            self
        }
        /// <p>Specifies the POSIX IDs and permissions to apply to the access point's root directory. </p>
        pub fn set_creation_info(
            mut self,
            input: std::option::Option<
                crate::model::AwsEfsAccessPointRootDirectoryCreationInfoDetails,
            >,
        ) -> Self {
            self.creation_info = input;
            self
        }
        /// <p>Specifies the path on the Amazon EFS file system to expose as the root directory to NFS clients using the access point to access the EFS file system. A path can have up to four subdirectories. If the specified path does not exist, you are required to provide <code>CreationInfo</code>. </p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.path = Some(input.into());
            self
        }
        /// <p>Specifies the path on the Amazon EFS file system to expose as the root directory to NFS clients using the access point to access the EFS file system. A path can have up to four subdirectories. If the specified path does not exist, you are required to provide <code>CreationInfo</code>. </p>
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEfsAccessPointRootDirectoryDetails`](crate::model::AwsEfsAccessPointRootDirectoryDetails)
        pub fn build(self) -> crate::model::AwsEfsAccessPointRootDirectoryDetails {
            crate::model::AwsEfsAccessPointRootDirectoryDetails {
                creation_info: self.creation_info,
                path: self.path,
            }
        }
    }
}
impl AwsEfsAccessPointRootDirectoryDetails {
    /// Creates a new builder-style object to manufacture [`AwsEfsAccessPointRootDirectoryDetails`](crate::model::AwsEfsAccessPointRootDirectoryDetails)
    pub fn builder() -> crate::model::aws_efs_access_point_root_directory_details::Builder {
        crate::model::aws_efs_access_point_root_directory_details::Builder::default()
    }
}

/// <p>Provides information about the settings that Amazon EFS uses to create the root directory when a client connects to an access point. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEfsAccessPointRootDirectoryCreationInfoDetails {
    /// <p>Specifies the POSIX group ID to apply to the root directory. </p>
    pub owner_gid: std::option::Option<std::string::String>,
    /// <p>Specifies the POSIX user ID to apply to the root directory. </p>
    pub owner_uid: std::option::Option<std::string::String>,
    /// <p>Specifies the POSIX permissions to apply to the root directory, in the format of an octal number representing the file's mode bits. </p>
    pub permissions: std::option::Option<std::string::String>,
}
impl AwsEfsAccessPointRootDirectoryCreationInfoDetails {
    /// <p>Specifies the POSIX group ID to apply to the root directory. </p>
    pub fn owner_gid(&self) -> std::option::Option<&str> {
        self.owner_gid.as_deref()
    }
    /// <p>Specifies the POSIX user ID to apply to the root directory. </p>
    pub fn owner_uid(&self) -> std::option::Option<&str> {
        self.owner_uid.as_deref()
    }
    /// <p>Specifies the POSIX permissions to apply to the root directory, in the format of an octal number representing the file's mode bits. </p>
    pub fn permissions(&self) -> std::option::Option<&str> {
        self.permissions.as_deref()
    }
}
impl std::fmt::Debug for AwsEfsAccessPointRootDirectoryCreationInfoDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEfsAccessPointRootDirectoryCreationInfoDetails");
        formatter.field("owner_gid", &self.owner_gid);
        formatter.field("owner_uid", &self.owner_uid);
        formatter.field("permissions", &self.permissions);
        formatter.finish()
    }
}
/// See [`AwsEfsAccessPointRootDirectoryCreationInfoDetails`](crate::model::AwsEfsAccessPointRootDirectoryCreationInfoDetails)
pub mod aws_efs_access_point_root_directory_creation_info_details {

    /// A builder for [`AwsEfsAccessPointRootDirectoryCreationInfoDetails`](crate::model::AwsEfsAccessPointRootDirectoryCreationInfoDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) owner_gid: std::option::Option<std::string::String>,
        pub(crate) owner_uid: std::option::Option<std::string::String>,
        pub(crate) permissions: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the POSIX group ID to apply to the root directory. </p>
        pub fn owner_gid(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_gid = Some(input.into());
            self
        }
        /// <p>Specifies the POSIX group ID to apply to the root directory. </p>
        pub fn set_owner_gid(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_gid = input;
            self
        }
        /// <p>Specifies the POSIX user ID to apply to the root directory. </p>
        pub fn owner_uid(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_uid = Some(input.into());
            self
        }
        /// <p>Specifies the POSIX user ID to apply to the root directory. </p>
        pub fn set_owner_uid(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_uid = input;
            self
        }
        /// <p>Specifies the POSIX permissions to apply to the root directory, in the format of an octal number representing the file's mode bits. </p>
        pub fn permissions(mut self, input: impl Into<std::string::String>) -> Self {
            self.permissions = Some(input.into());
            self
        }
        /// <p>Specifies the POSIX permissions to apply to the root directory, in the format of an octal number representing the file's mode bits. </p>
        pub fn set_permissions(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.permissions = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEfsAccessPointRootDirectoryCreationInfoDetails`](crate::model::AwsEfsAccessPointRootDirectoryCreationInfoDetails)
        pub fn build(self) -> crate::model::AwsEfsAccessPointRootDirectoryCreationInfoDetails {
            crate::model::AwsEfsAccessPointRootDirectoryCreationInfoDetails {
                owner_gid: self.owner_gid,
                owner_uid: self.owner_uid,
                permissions: self.permissions,
            }
        }
    }
}
impl AwsEfsAccessPointRootDirectoryCreationInfoDetails {
    /// Creates a new builder-style object to manufacture [`AwsEfsAccessPointRootDirectoryCreationInfoDetails`](crate::model::AwsEfsAccessPointRootDirectoryCreationInfoDetails)
    pub fn builder(
    ) -> crate::model::aws_efs_access_point_root_directory_creation_info_details::Builder {
        crate::model::aws_efs_access_point_root_directory_creation_info_details::Builder::default()
    }
}

/// <p>Provides details for all file system operations using this Amazon EFS access point. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEfsAccessPointPosixUserDetails {
    /// <p>The POSIX group ID used for all file system operations using this access point. </p>
    pub gid: std::option::Option<std::string::String>,
    /// <p>Secondary POSIX group IDs used for all file system operations using this access point. </p>
    pub secondary_gids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The POSIX user ID used for all file system operations using this access point. </p>
    pub uid: std::option::Option<std::string::String>,
}
impl AwsEfsAccessPointPosixUserDetails {
    /// <p>The POSIX group ID used for all file system operations using this access point. </p>
    pub fn gid(&self) -> std::option::Option<&str> {
        self.gid.as_deref()
    }
    /// <p>Secondary POSIX group IDs used for all file system operations using this access point. </p>
    pub fn secondary_gids(&self) -> std::option::Option<&[std::string::String]> {
        self.secondary_gids.as_deref()
    }
    /// <p>The POSIX user ID used for all file system operations using this access point. </p>
    pub fn uid(&self) -> std::option::Option<&str> {
        self.uid.as_deref()
    }
}
impl std::fmt::Debug for AwsEfsAccessPointPosixUserDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEfsAccessPointPosixUserDetails");
        formatter.field("gid", &self.gid);
        formatter.field("secondary_gids", &self.secondary_gids);
        formatter.field("uid", &self.uid);
        formatter.finish()
    }
}
/// See [`AwsEfsAccessPointPosixUserDetails`](crate::model::AwsEfsAccessPointPosixUserDetails)
pub mod aws_efs_access_point_posix_user_details {

    /// A builder for [`AwsEfsAccessPointPosixUserDetails`](crate::model::AwsEfsAccessPointPosixUserDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) gid: std::option::Option<std::string::String>,
        pub(crate) secondary_gids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) uid: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The POSIX group ID used for all file system operations using this access point. </p>
        pub fn gid(mut self, input: impl Into<std::string::String>) -> Self {
            self.gid = Some(input.into());
            self
        }
        /// <p>The POSIX group ID used for all file system operations using this access point. </p>
        pub fn set_gid(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.gid = input;
            self
        }
        /// Appends an item to `secondary_gids`.
        ///
        /// To override the contents of this collection use [`set_secondary_gids`](Self::set_secondary_gids).
        ///
        /// <p>Secondary POSIX group IDs used for all file system operations using this access point. </p>
        pub fn secondary_gids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.secondary_gids.unwrap_or_default();
            v.push(input.into());
            self.secondary_gids = Some(v);
            self
        }
        /// <p>Secondary POSIX group IDs used for all file system operations using this access point. </p>
        pub fn set_secondary_gids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.secondary_gids = input;
            self
        }
        /// <p>The POSIX user ID used for all file system operations using this access point. </p>
        pub fn uid(mut self, input: impl Into<std::string::String>) -> Self {
            self.uid = Some(input.into());
            self
        }
        /// <p>The POSIX user ID used for all file system operations using this access point. </p>
        pub fn set_uid(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.uid = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEfsAccessPointPosixUserDetails`](crate::model::AwsEfsAccessPointPosixUserDetails)
        pub fn build(self) -> crate::model::AwsEfsAccessPointPosixUserDetails {
            crate::model::AwsEfsAccessPointPosixUserDetails {
                gid: self.gid,
                secondary_gids: self.secondary_gids,
                uid: self.uid,
            }
        }
    }
}
impl AwsEfsAccessPointPosixUserDetails {
    /// Creates a new builder-style object to manufacture [`AwsEfsAccessPointPosixUserDetails`](crate::model::AwsEfsAccessPointPosixUserDetails)
    pub fn builder() -> crate::model::aws_efs_access_point_posix_user_details::Builder {
        crate::model::aws_efs_access_point_posix_user_details::Builder::default()
    }
}

/// <p>Information about an Amazon Web Services Amazon EC2 Transit Gateway that interconnects virtual private clouds (VPCs) and on-premises networks. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2TransitGatewayDetails {
    /// <p>The ID of the transit gateway. </p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The description of the transit gateway. </p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Turn on or turn off automatic propagation of routes to the default propagation route table. </p>
    pub default_route_table_propagation: std::option::Option<std::string::String>,
    /// <p>Turn on or turn off automatic acceptance of attachment requests. </p>
    pub auto_accept_shared_attachments: std::option::Option<std::string::String>,
    /// <p>Turn on or turn off automatic association with the default association route table. </p>
    pub default_route_table_association: std::option::Option<std::string::String>,
    /// <p>The transit gateway Classless Inter-Domain Routing (CIDR) blocks. </p>
    pub transit_gateway_cidr_blocks: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the default association route table. </p>
    pub association_default_route_table_id: std::option::Option<std::string::String>,
    /// <p>The ID of the default propagation route table. </p>
    pub propagation_default_route_table_id: std::option::Option<std::string::String>,
    /// <p>Turn on or turn off Equal Cost Multipath Protocol (ECMP) support. </p>
    pub vpn_ecmp_support: std::option::Option<std::string::String>,
    /// <p>Turn on or turn off DNS support. </p>
    pub dns_support: std::option::Option<std::string::String>,
    /// <p>Indicates whether multicast is supported on the transit gateway. </p>
    pub multicast_support: std::option::Option<std::string::String>,
    /// <p>A private Autonomous System Number (ASN) for the Amazon side of a BGP session. </p>
    pub amazon_side_asn: i32,
}
impl AwsEc2TransitGatewayDetails {
    /// <p>The ID of the transit gateway. </p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The description of the transit gateway. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Turn on or turn off automatic propagation of routes to the default propagation route table. </p>
    pub fn default_route_table_propagation(&self) -> std::option::Option<&str> {
        self.default_route_table_propagation.as_deref()
    }
    /// <p>Turn on or turn off automatic acceptance of attachment requests. </p>
    pub fn auto_accept_shared_attachments(&self) -> std::option::Option<&str> {
        self.auto_accept_shared_attachments.as_deref()
    }
    /// <p>Turn on or turn off automatic association with the default association route table. </p>
    pub fn default_route_table_association(&self) -> std::option::Option<&str> {
        self.default_route_table_association.as_deref()
    }
    /// <p>The transit gateway Classless Inter-Domain Routing (CIDR) blocks. </p>
    pub fn transit_gateway_cidr_blocks(&self) -> std::option::Option<&[std::string::String]> {
        self.transit_gateway_cidr_blocks.as_deref()
    }
    /// <p>The ID of the default association route table. </p>
    pub fn association_default_route_table_id(&self) -> std::option::Option<&str> {
        self.association_default_route_table_id.as_deref()
    }
    /// <p>The ID of the default propagation route table. </p>
    pub fn propagation_default_route_table_id(&self) -> std::option::Option<&str> {
        self.propagation_default_route_table_id.as_deref()
    }
    /// <p>Turn on or turn off Equal Cost Multipath Protocol (ECMP) support. </p>
    pub fn vpn_ecmp_support(&self) -> std::option::Option<&str> {
        self.vpn_ecmp_support.as_deref()
    }
    /// <p>Turn on or turn off DNS support. </p>
    pub fn dns_support(&self) -> std::option::Option<&str> {
        self.dns_support.as_deref()
    }
    /// <p>Indicates whether multicast is supported on the transit gateway. </p>
    pub fn multicast_support(&self) -> std::option::Option<&str> {
        self.multicast_support.as_deref()
    }
    /// <p>A private Autonomous System Number (ASN) for the Amazon side of a BGP session. </p>
    pub fn amazon_side_asn(&self) -> i32 {
        self.amazon_side_asn
    }
}
impl std::fmt::Debug for AwsEc2TransitGatewayDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2TransitGatewayDetails");
        formatter.field("id", &self.id);
        formatter.field("description", &self.description);
        formatter.field(
            "default_route_table_propagation",
            &self.default_route_table_propagation,
        );
        formatter.field(
            "auto_accept_shared_attachments",
            &self.auto_accept_shared_attachments,
        );
        formatter.field(
            "default_route_table_association",
            &self.default_route_table_association,
        );
        formatter.field(
            "transit_gateway_cidr_blocks",
            &self.transit_gateway_cidr_blocks,
        );
        formatter.field(
            "association_default_route_table_id",
            &self.association_default_route_table_id,
        );
        formatter.field(
            "propagation_default_route_table_id",
            &self.propagation_default_route_table_id,
        );
        formatter.field("vpn_ecmp_support", &self.vpn_ecmp_support);
        formatter.field("dns_support", &self.dns_support);
        formatter.field("multicast_support", &self.multicast_support);
        formatter.field("amazon_side_asn", &self.amazon_side_asn);
        formatter.finish()
    }
}
/// See [`AwsEc2TransitGatewayDetails`](crate::model::AwsEc2TransitGatewayDetails)
pub mod aws_ec2_transit_gateway_details {

    /// A builder for [`AwsEc2TransitGatewayDetails`](crate::model::AwsEc2TransitGatewayDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) default_route_table_propagation: std::option::Option<std::string::String>,
        pub(crate) auto_accept_shared_attachments: std::option::Option<std::string::String>,
        pub(crate) default_route_table_association: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_cidr_blocks:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) association_default_route_table_id: std::option::Option<std::string::String>,
        pub(crate) propagation_default_route_table_id: std::option::Option<std::string::String>,
        pub(crate) vpn_ecmp_support: std::option::Option<std::string::String>,
        pub(crate) dns_support: std::option::Option<std::string::String>,
        pub(crate) multicast_support: std::option::Option<std::string::String>,
        pub(crate) amazon_side_asn: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of the transit gateway. </p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the transit gateway. </p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The description of the transit gateway. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the transit gateway. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Turn on or turn off automatic propagation of routes to the default propagation route table. </p>
        pub fn default_route_table_propagation(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.default_route_table_propagation = Some(input.into());
            self
        }
        /// <p>Turn on or turn off automatic propagation of routes to the default propagation route table. </p>
        pub fn set_default_route_table_propagation(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_route_table_propagation = input;
            self
        }
        /// <p>Turn on or turn off automatic acceptance of attachment requests. </p>
        pub fn auto_accept_shared_attachments(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.auto_accept_shared_attachments = Some(input.into());
            self
        }
        /// <p>Turn on or turn off automatic acceptance of attachment requests. </p>
        pub fn set_auto_accept_shared_attachments(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_accept_shared_attachments = input;
            self
        }
        /// <p>Turn on or turn off automatic association with the default association route table. </p>
        pub fn default_route_table_association(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.default_route_table_association = Some(input.into());
            self
        }
        /// <p>Turn on or turn off automatic association with the default association route table. </p>
        pub fn set_default_route_table_association(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_route_table_association = input;
            self
        }
        /// Appends an item to `transit_gateway_cidr_blocks`.
        ///
        /// To override the contents of this collection use [`set_transit_gateway_cidr_blocks`](Self::set_transit_gateway_cidr_blocks).
        ///
        /// <p>The transit gateway Classless Inter-Domain Routing (CIDR) blocks. </p>
        pub fn transit_gateway_cidr_blocks(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.transit_gateway_cidr_blocks.unwrap_or_default();
            v.push(input.into());
            self.transit_gateway_cidr_blocks = Some(v);
            self
        }
        /// <p>The transit gateway Classless Inter-Domain Routing (CIDR) blocks. </p>
        pub fn set_transit_gateway_cidr_blocks(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.transit_gateway_cidr_blocks = input;
            self
        }
        /// <p>The ID of the default association route table. </p>
        pub fn association_default_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.association_default_route_table_id = Some(input.into());
            self
        }
        /// <p>The ID of the default association route table. </p>
        pub fn set_association_default_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_default_route_table_id = input;
            self
        }
        /// <p>The ID of the default propagation route table. </p>
        pub fn propagation_default_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.propagation_default_route_table_id = Some(input.into());
            self
        }
        /// <p>The ID of the default propagation route table. </p>
        pub fn set_propagation_default_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.propagation_default_route_table_id = input;
            self
        }
        /// <p>Turn on or turn off Equal Cost Multipath Protocol (ECMP) support. </p>
        pub fn vpn_ecmp_support(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpn_ecmp_support = Some(input.into());
            self
        }
        /// <p>Turn on or turn off Equal Cost Multipath Protocol (ECMP) support. </p>
        pub fn set_vpn_ecmp_support(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpn_ecmp_support = input;
            self
        }
        /// <p>Turn on or turn off DNS support. </p>
        pub fn dns_support(mut self, input: impl Into<std::string::String>) -> Self {
            self.dns_support = Some(input.into());
            self
        }
        /// <p>Turn on or turn off DNS support. </p>
        pub fn set_dns_support(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dns_support = input;
            self
        }
        /// <p>Indicates whether multicast is supported on the transit gateway. </p>
        pub fn multicast_support(mut self, input: impl Into<std::string::String>) -> Self {
            self.multicast_support = Some(input.into());
            self
        }
        /// <p>Indicates whether multicast is supported on the transit gateway. </p>
        pub fn set_multicast_support(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.multicast_support = input;
            self
        }
        /// <p>A private Autonomous System Number (ASN) for the Amazon side of a BGP session. </p>
        pub fn amazon_side_asn(mut self, input: i32) -> Self {
            self.amazon_side_asn = Some(input);
            self
        }
        /// <p>A private Autonomous System Number (ASN) for the Amazon side of a BGP session. </p>
        pub fn set_amazon_side_asn(mut self, input: std::option::Option<i32>) -> Self {
            self.amazon_side_asn = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2TransitGatewayDetails`](crate::model::AwsEc2TransitGatewayDetails)
        pub fn build(self) -> crate::model::AwsEc2TransitGatewayDetails {
            crate::model::AwsEc2TransitGatewayDetails {
                id: self.id,
                description: self.description,
                default_route_table_propagation: self.default_route_table_propagation,
                auto_accept_shared_attachments: self.auto_accept_shared_attachments,
                default_route_table_association: self.default_route_table_association,
                transit_gateway_cidr_blocks: self.transit_gateway_cidr_blocks,
                association_default_route_table_id: self.association_default_route_table_id,
                propagation_default_route_table_id: self.propagation_default_route_table_id,
                vpn_ecmp_support: self.vpn_ecmp_support,
                dns_support: self.dns_support,
                multicast_support: self.multicast_support,
                amazon_side_asn: self.amazon_side_asn.unwrap_or_default(),
            }
        }
    }
}
impl AwsEc2TransitGatewayDetails {
    /// Creates a new builder-style object to manufacture [`AwsEc2TransitGatewayDetails`](crate::model::AwsEc2TransitGatewayDetails)
    pub fn builder() -> crate::model::aws_ec2_transit_gateway_details::Builder {
        crate::model::aws_ec2_transit_gateway_details::Builder::default()
    }
}

/// <p>Provides information about an Amazon Kinesis data stream. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsKinesisStreamDetails {
    /// <p>The name of the Kinesis stream. If you don't specify a name, CloudFront generates a unique physical ID and uses that ID for the stream name. </p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream. </p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>When specified, enables or updates server-side encryption using an KMS key for a specified stream. Removing this property from your stack template and updating your stack disables encryption. </p>
    pub stream_encryption:
        std::option::Option<crate::model::AwsKinesisStreamStreamEncryptionDetails>,
    /// <p>The number of shards that the stream uses. </p>
    pub shard_count: i32,
    /// <p>The number of hours for the data records that are stored in shards to remain accessible. </p>
    pub retention_period_hours: i32,
}
impl AwsKinesisStreamDetails {
    /// <p>The name of the Kinesis stream. If you don't specify a name, CloudFront generates a unique physical ID and uses that ID for the stream name. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream. </p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>When specified, enables or updates server-side encryption using an KMS key for a specified stream. Removing this property from your stack template and updating your stack disables encryption. </p>
    pub fn stream_encryption(
        &self,
    ) -> std::option::Option<&crate::model::AwsKinesisStreamStreamEncryptionDetails> {
        self.stream_encryption.as_ref()
    }
    /// <p>The number of shards that the stream uses. </p>
    pub fn shard_count(&self) -> i32 {
        self.shard_count
    }
    /// <p>The number of hours for the data records that are stored in shards to remain accessible. </p>
    pub fn retention_period_hours(&self) -> i32 {
        self.retention_period_hours
    }
}
impl std::fmt::Debug for AwsKinesisStreamDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsKinesisStreamDetails");
        formatter.field("name", &self.name);
        formatter.field("arn", &self.arn);
        formatter.field("stream_encryption", &self.stream_encryption);
        formatter.field("shard_count", &self.shard_count);
        formatter.field("retention_period_hours", &self.retention_period_hours);
        formatter.finish()
    }
}
/// See [`AwsKinesisStreamDetails`](crate::model::AwsKinesisStreamDetails)
pub mod aws_kinesis_stream_details {

    /// A builder for [`AwsKinesisStreamDetails`](crate::model::AwsKinesisStreamDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) stream_encryption:
            std::option::Option<crate::model::AwsKinesisStreamStreamEncryptionDetails>,
        pub(crate) shard_count: std::option::Option<i32>,
        pub(crate) retention_period_hours: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the Kinesis stream. If you don't specify a name, CloudFront generates a unique physical ID and uses that ID for the stream name. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the Kinesis stream. If you don't specify a name, CloudFront generates a unique physical ID and uses that ID for the stream name. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream. </p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream. </p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>When specified, enables or updates server-side encryption using an KMS key for a specified stream. Removing this property from your stack template and updating your stack disables encryption. </p>
        pub fn stream_encryption(
            mut self,
            input: crate::model::AwsKinesisStreamStreamEncryptionDetails,
        ) -> Self {
            self.stream_encryption = Some(input);
            self
        }
        /// <p>When specified, enables or updates server-side encryption using an KMS key for a specified stream. Removing this property from your stack template and updating your stack disables encryption. </p>
        pub fn set_stream_encryption(
            mut self,
            input: std::option::Option<crate::model::AwsKinesisStreamStreamEncryptionDetails>,
        ) -> Self {
            self.stream_encryption = input;
            self
        }
        /// <p>The number of shards that the stream uses. </p>
        pub fn shard_count(mut self, input: i32) -> Self {
            self.shard_count = Some(input);
            self
        }
        /// <p>The number of shards that the stream uses. </p>
        pub fn set_shard_count(mut self, input: std::option::Option<i32>) -> Self {
            self.shard_count = input;
            self
        }
        /// <p>The number of hours for the data records that are stored in shards to remain accessible. </p>
        pub fn retention_period_hours(mut self, input: i32) -> Self {
            self.retention_period_hours = Some(input);
            self
        }
        /// <p>The number of hours for the data records that are stored in shards to remain accessible. </p>
        pub fn set_retention_period_hours(mut self, input: std::option::Option<i32>) -> Self {
            self.retention_period_hours = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsKinesisStreamDetails`](crate::model::AwsKinesisStreamDetails)
        pub fn build(self) -> crate::model::AwsKinesisStreamDetails {
            crate::model::AwsKinesisStreamDetails {
                name: self.name,
                arn: self.arn,
                stream_encryption: self.stream_encryption,
                shard_count: self.shard_count.unwrap_or_default(),
                retention_period_hours: self.retention_period_hours.unwrap_or_default(),
            }
        }
    }
}
impl AwsKinesisStreamDetails {
    /// Creates a new builder-style object to manufacture [`AwsKinesisStreamDetails`](crate::model::AwsKinesisStreamDetails)
    pub fn builder() -> crate::model::aws_kinesis_stream_details::Builder {
        crate::model::aws_kinesis_stream_details::Builder::default()
    }
}

/// <p>Provides information about stream encryption. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsKinesisStreamStreamEncryptionDetails {
    /// <p>The encryption type to use. </p>
    pub encryption_type: std::option::Option<std::string::String>,
    /// <p>The globally unique identifier for the customer-managed KMS key to use for encryption. </p>
    pub key_id: std::option::Option<std::string::String>,
}
impl AwsKinesisStreamStreamEncryptionDetails {
    /// <p>The encryption type to use. </p>
    pub fn encryption_type(&self) -> std::option::Option<&str> {
        self.encryption_type.as_deref()
    }
    /// <p>The globally unique identifier for the customer-managed KMS key to use for encryption. </p>
    pub fn key_id(&self) -> std::option::Option<&str> {
        self.key_id.as_deref()
    }
}
impl std::fmt::Debug for AwsKinesisStreamStreamEncryptionDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsKinesisStreamStreamEncryptionDetails");
        formatter.field("encryption_type", &self.encryption_type);
        formatter.field("key_id", &self.key_id);
        formatter.finish()
    }
}
/// See [`AwsKinesisStreamStreamEncryptionDetails`](crate::model::AwsKinesisStreamStreamEncryptionDetails)
pub mod aws_kinesis_stream_stream_encryption_details {

    /// A builder for [`AwsKinesisStreamStreamEncryptionDetails`](crate::model::AwsKinesisStreamStreamEncryptionDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) encryption_type: std::option::Option<std::string::String>,
        pub(crate) key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The encryption type to use. </p>
        pub fn encryption_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.encryption_type = Some(input.into());
            self
        }
        /// <p>The encryption type to use. </p>
        pub fn set_encryption_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.encryption_type = input;
            self
        }
        /// <p>The globally unique identifier for the customer-managed KMS key to use for encryption. </p>
        pub fn key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_id = Some(input.into());
            self
        }
        /// <p>The globally unique identifier for the customer-managed KMS key to use for encryption. </p>
        pub fn set_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsKinesisStreamStreamEncryptionDetails`](crate::model::AwsKinesisStreamStreamEncryptionDetails)
        pub fn build(self) -> crate::model::AwsKinesisStreamStreamEncryptionDetails {
            crate::model::AwsKinesisStreamStreamEncryptionDetails {
                encryption_type: self.encryption_type,
                key_id: self.key_id,
            }
        }
    }
}
impl AwsKinesisStreamStreamEncryptionDetails {
    /// Creates a new builder-style object to manufacture [`AwsKinesisStreamStreamEncryptionDetails`](crate::model::AwsKinesisStreamStreamEncryptionDetails)
    pub fn builder() -> crate::model::aws_kinesis_stream_stream_encryption_details::Builder {
        crate::model::aws_kinesis_stream_stream_encryption_details::Builder::default()
    }
}

/// <p>Provides information about an Amazon RDS DB security group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRdsDbSecurityGroupDetails {
    /// <p>The ARN for the DB security group.</p>
    pub db_security_group_arn: std::option::Option<std::string::String>,
    /// <p>Provides the description of the DB security group.</p>
    pub db_security_group_description: std::option::Option<std::string::String>,
    /// <p>Specifies the name of the DB security group.</p>
    pub db_security_group_name: std::option::Option<std::string::String>,
    /// <p>Contains a list of EC2 security groups.</p>
    pub ec2_security_groups:
        std::option::Option<std::vec::Vec<crate::model::AwsRdsDbSecurityGroupEc2SecurityGroup>>,
    /// <p>Contains a list of IP ranges.</p>
    pub ip_ranges: std::option::Option<std::vec::Vec<crate::model::AwsRdsDbSecurityGroupIpRange>>,
    /// <p>Provides the Amazon Web Services ID of the owner of a specific DB security group.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>Provides VPC ID associated with the DB security group. </p>
    pub vpc_id: std::option::Option<std::string::String>,
}
impl AwsRdsDbSecurityGroupDetails {
    /// <p>The ARN for the DB security group.</p>
    pub fn db_security_group_arn(&self) -> std::option::Option<&str> {
        self.db_security_group_arn.as_deref()
    }
    /// <p>Provides the description of the DB security group.</p>
    pub fn db_security_group_description(&self) -> std::option::Option<&str> {
        self.db_security_group_description.as_deref()
    }
    /// <p>Specifies the name of the DB security group.</p>
    pub fn db_security_group_name(&self) -> std::option::Option<&str> {
        self.db_security_group_name.as_deref()
    }
    /// <p>Contains a list of EC2 security groups.</p>
    pub fn ec2_security_groups(
        &self,
    ) -> std::option::Option<&[crate::model::AwsRdsDbSecurityGroupEc2SecurityGroup]> {
        self.ec2_security_groups.as_deref()
    }
    /// <p>Contains a list of IP ranges.</p>
    pub fn ip_ranges(&self) -> std::option::Option<&[crate::model::AwsRdsDbSecurityGroupIpRange]> {
        self.ip_ranges.as_deref()
    }
    /// <p>Provides the Amazon Web Services ID of the owner of a specific DB security group.</p>
    pub fn owner_id(&self) -> std::option::Option<&str> {
        self.owner_id.as_deref()
    }
    /// <p>Provides VPC ID associated with the DB security group. </p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
}
impl std::fmt::Debug for AwsRdsDbSecurityGroupDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRdsDbSecurityGroupDetails");
        formatter.field("db_security_group_arn", &self.db_security_group_arn);
        formatter.field(
            "db_security_group_description",
            &self.db_security_group_description,
        );
        formatter.field("db_security_group_name", &self.db_security_group_name);
        formatter.field("ec2_security_groups", &self.ec2_security_groups);
        formatter.field("ip_ranges", &self.ip_ranges);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.finish()
    }
}
/// See [`AwsRdsDbSecurityGroupDetails`](crate::model::AwsRdsDbSecurityGroupDetails)
pub mod aws_rds_db_security_group_details {

    /// A builder for [`AwsRdsDbSecurityGroupDetails`](crate::model::AwsRdsDbSecurityGroupDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) db_security_group_arn: std::option::Option<std::string::String>,
        pub(crate) db_security_group_description: std::option::Option<std::string::String>,
        pub(crate) db_security_group_name: std::option::Option<std::string::String>,
        pub(crate) ec2_security_groups:
            std::option::Option<std::vec::Vec<crate::model::AwsRdsDbSecurityGroupEc2SecurityGroup>>,
        pub(crate) ip_ranges:
            std::option::Option<std::vec::Vec<crate::model::AwsRdsDbSecurityGroupIpRange>>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN for the DB security group.</p>
        pub fn db_security_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_security_group_arn = Some(input.into());
            self
        }
        /// <p>The ARN for the DB security group.</p>
        pub fn set_db_security_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.db_security_group_arn = input;
            self
        }
        /// <p>Provides the description of the DB security group.</p>
        pub fn db_security_group_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.db_security_group_description = Some(input.into());
            self
        }
        /// <p>Provides the description of the DB security group.</p>
        pub fn set_db_security_group_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.db_security_group_description = input;
            self
        }
        /// <p>Specifies the name of the DB security group.</p>
        pub fn db_security_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_security_group_name = Some(input.into());
            self
        }
        /// <p>Specifies the name of the DB security group.</p>
        pub fn set_db_security_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.db_security_group_name = input;
            self
        }
        /// Appends an item to `ec2_security_groups`.
        ///
        /// To override the contents of this collection use [`set_ec2_security_groups`](Self::set_ec2_security_groups).
        ///
        /// <p>Contains a list of EC2 security groups.</p>
        pub fn ec2_security_groups(
            mut self,
            input: crate::model::AwsRdsDbSecurityGroupEc2SecurityGroup,
        ) -> Self {
            let mut v = self.ec2_security_groups.unwrap_or_default();
            v.push(input);
            self.ec2_security_groups = Some(v);
            self
        }
        /// <p>Contains a list of EC2 security groups.</p>
        pub fn set_ec2_security_groups(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsRdsDbSecurityGroupEc2SecurityGroup>,
            >,
        ) -> Self {
            self.ec2_security_groups = input;
            self
        }
        /// Appends an item to `ip_ranges`.
        ///
        /// To override the contents of this collection use [`set_ip_ranges`](Self::set_ip_ranges).
        ///
        /// <p>Contains a list of IP ranges.</p>
        pub fn ip_ranges(mut self, input: crate::model::AwsRdsDbSecurityGroupIpRange) -> Self {
            let mut v = self.ip_ranges.unwrap_or_default();
            v.push(input);
            self.ip_ranges = Some(v);
            self
        }
        /// <p>Contains a list of IP ranges.</p>
        pub fn set_ip_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsRdsDbSecurityGroupIpRange>>,
        ) -> Self {
            self.ip_ranges = input;
            self
        }
        /// <p>Provides the Amazon Web Services ID of the owner of a specific DB security group.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        /// <p>Provides the Amazon Web Services ID of the owner of a specific DB security group.</p>
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>Provides VPC ID associated with the DB security group. </p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>Provides VPC ID associated with the DB security group. </p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRdsDbSecurityGroupDetails`](crate::model::AwsRdsDbSecurityGroupDetails)
        pub fn build(self) -> crate::model::AwsRdsDbSecurityGroupDetails {
            crate::model::AwsRdsDbSecurityGroupDetails {
                db_security_group_arn: self.db_security_group_arn,
                db_security_group_description: self.db_security_group_description,
                db_security_group_name: self.db_security_group_name,
                ec2_security_groups: self.ec2_security_groups,
                ip_ranges: self.ip_ranges,
                owner_id: self.owner_id,
                vpc_id: self.vpc_id,
            }
        }
    }
}
impl AwsRdsDbSecurityGroupDetails {
    /// Creates a new builder-style object to manufacture [`AwsRdsDbSecurityGroupDetails`](crate::model::AwsRdsDbSecurityGroupDetails)
    pub fn builder() -> crate::model::aws_rds_db_security_group_details::Builder {
        crate::model::aws_rds_db_security_group_details::Builder::default()
    }
}

/// <p>IP range information for an RDS DB security group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRdsDbSecurityGroupIpRange {
    /// <p>Specifies the IP range.</p>
    pub cidr_ip: std::option::Option<std::string::String>,
    /// <p>Specifies the status of the IP range.</p>
    pub status: std::option::Option<std::string::String>,
}
impl AwsRdsDbSecurityGroupIpRange {
    /// <p>Specifies the IP range.</p>
    pub fn cidr_ip(&self) -> std::option::Option<&str> {
        self.cidr_ip.as_deref()
    }
    /// <p>Specifies the status of the IP range.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
}
impl std::fmt::Debug for AwsRdsDbSecurityGroupIpRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRdsDbSecurityGroupIpRange");
        formatter.field("cidr_ip", &self.cidr_ip);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`AwsRdsDbSecurityGroupIpRange`](crate::model::AwsRdsDbSecurityGroupIpRange)
pub mod aws_rds_db_security_group_ip_range {

    /// A builder for [`AwsRdsDbSecurityGroupIpRange`](crate::model::AwsRdsDbSecurityGroupIpRange)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cidr_ip: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the IP range.</p>
        pub fn cidr_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr_ip = Some(input.into());
            self
        }
        /// <p>Specifies the IP range.</p>
        pub fn set_cidr_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr_ip = input;
            self
        }
        /// <p>Specifies the status of the IP range.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>Specifies the status of the IP range.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRdsDbSecurityGroupIpRange`](crate::model::AwsRdsDbSecurityGroupIpRange)
        pub fn build(self) -> crate::model::AwsRdsDbSecurityGroupIpRange {
            crate::model::AwsRdsDbSecurityGroupIpRange {
                cidr_ip: self.cidr_ip,
                status: self.status,
            }
        }
    }
}
impl AwsRdsDbSecurityGroupIpRange {
    /// Creates a new builder-style object to manufacture [`AwsRdsDbSecurityGroupIpRange`](crate::model::AwsRdsDbSecurityGroupIpRange)
    pub fn builder() -> crate::model::aws_rds_db_security_group_ip_range::Builder {
        crate::model::aws_rds_db_security_group_ip_range::Builder::default()
    }
}

/// <p>EC2 security group information for an RDS DB security group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRdsDbSecurityGroupEc2SecurityGroup {
    /// <p>Specifies the ID for the EC2 security group.</p>
    pub ec2_security_group_id: std::option::Option<std::string::String>,
    /// <p>Specifies the name of the EC2 security group.</p>
    pub ec2_security_group_name: std::option::Option<std::string::String>,
    /// <p>Provides the Amazon Web Services ID of the owner of the EC2 security group.</p>
    pub ec2_security_group_owner_id: std::option::Option<std::string::String>,
    /// <p>Provides the status of the EC2 security group.</p>
    pub status: std::option::Option<std::string::String>,
}
impl AwsRdsDbSecurityGroupEc2SecurityGroup {
    /// <p>Specifies the ID for the EC2 security group.</p>
    pub fn ec2_security_group_id(&self) -> std::option::Option<&str> {
        self.ec2_security_group_id.as_deref()
    }
    /// <p>Specifies the name of the EC2 security group.</p>
    pub fn ec2_security_group_name(&self) -> std::option::Option<&str> {
        self.ec2_security_group_name.as_deref()
    }
    /// <p>Provides the Amazon Web Services ID of the owner of the EC2 security group.</p>
    pub fn ec2_security_group_owner_id(&self) -> std::option::Option<&str> {
        self.ec2_security_group_owner_id.as_deref()
    }
    /// <p>Provides the status of the EC2 security group.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
}
impl std::fmt::Debug for AwsRdsDbSecurityGroupEc2SecurityGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRdsDbSecurityGroupEc2SecurityGroup");
        formatter.field("ec2_security_group_id", &self.ec2_security_group_id);
        formatter.field("ec2_security_group_name", &self.ec2_security_group_name);
        formatter.field(
            "ec2_security_group_owner_id",
            &self.ec2_security_group_owner_id,
        );
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`AwsRdsDbSecurityGroupEc2SecurityGroup`](crate::model::AwsRdsDbSecurityGroupEc2SecurityGroup)
pub mod aws_rds_db_security_group_ec2_security_group {

    /// A builder for [`AwsRdsDbSecurityGroupEc2SecurityGroup`](crate::model::AwsRdsDbSecurityGroupEc2SecurityGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ec2_security_group_id: std::option::Option<std::string::String>,
        pub(crate) ec2_security_group_name: std::option::Option<std::string::String>,
        pub(crate) ec2_security_group_owner_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the ID for the EC2 security group.</p>
        pub fn ec2_security_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ec2_security_group_id = Some(input.into());
            self
        }
        /// <p>Specifies the ID for the EC2 security group.</p>
        pub fn set_ec2_security_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ec2_security_group_id = input;
            self
        }
        /// <p>Specifies the name of the EC2 security group.</p>
        pub fn ec2_security_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.ec2_security_group_name = Some(input.into());
            self
        }
        /// <p>Specifies the name of the EC2 security group.</p>
        pub fn set_ec2_security_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ec2_security_group_name = input;
            self
        }
        /// <p>Provides the Amazon Web Services ID of the owner of the EC2 security group.</p>
        pub fn ec2_security_group_owner_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.ec2_security_group_owner_id = Some(input.into());
            self
        }
        /// <p>Provides the Amazon Web Services ID of the owner of the EC2 security group.</p>
        pub fn set_ec2_security_group_owner_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ec2_security_group_owner_id = input;
            self
        }
        /// <p>Provides the status of the EC2 security group.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>Provides the status of the EC2 security group.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRdsDbSecurityGroupEc2SecurityGroup`](crate::model::AwsRdsDbSecurityGroupEc2SecurityGroup)
        pub fn build(self) -> crate::model::AwsRdsDbSecurityGroupEc2SecurityGroup {
            crate::model::AwsRdsDbSecurityGroupEc2SecurityGroup {
                ec2_security_group_id: self.ec2_security_group_id,
                ec2_security_group_name: self.ec2_security_group_name,
                ec2_security_group_owner_id: self.ec2_security_group_owner_id,
                status: self.status,
            }
        }
    }
}
impl AwsRdsDbSecurityGroupEc2SecurityGroup {
    /// Creates a new builder-style object to manufacture [`AwsRdsDbSecurityGroupEc2SecurityGroup`](crate::model::AwsRdsDbSecurityGroupEc2SecurityGroup)
    pub fn builder() -> crate::model::aws_rds_db_security_group_ec2_security_group::Builder {
        crate::model::aws_rds_db_security_group_ec2_security_group::Builder::default()
    }
}

/// <p>Details about an Network Firewall rule group. Rule groups are used to inspect and control network traffic. Stateless rule groups apply to individual packets. Stateful rule groups apply to packets in the context of their traffic flow.</p>
/// <p>Rule groups are referenced in firewall policies. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsNetworkFirewallRuleGroupDetails {
    /// <p>The maximum number of operating resources that this rule group can use.</p>
    pub capacity: i32,
    /// <p>A description of the rule group.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Details about the rule group.</p>
    pub rule_group: std::option::Option<crate::model::RuleGroupDetails>,
    /// <p>The ARN of the rule group.</p>
    pub rule_group_arn: std::option::Option<std::string::String>,
    /// <p>The identifier of the rule group.</p>
    pub rule_group_id: std::option::Option<std::string::String>,
    /// <p>The descriptive name of the rule group.</p>
    pub rule_group_name: std::option::Option<std::string::String>,
    /// <p>The type of rule group. A rule group can be stateful or stateless.</p>
    pub r#type: std::option::Option<std::string::String>,
}
impl AwsNetworkFirewallRuleGroupDetails {
    /// <p>The maximum number of operating resources that this rule group can use.</p>
    pub fn capacity(&self) -> i32 {
        self.capacity
    }
    /// <p>A description of the rule group.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Details about the rule group.</p>
    pub fn rule_group(&self) -> std::option::Option<&crate::model::RuleGroupDetails> {
        self.rule_group.as_ref()
    }
    /// <p>The ARN of the rule group.</p>
    pub fn rule_group_arn(&self) -> std::option::Option<&str> {
        self.rule_group_arn.as_deref()
    }
    /// <p>The identifier of the rule group.</p>
    pub fn rule_group_id(&self) -> std::option::Option<&str> {
        self.rule_group_id.as_deref()
    }
    /// <p>The descriptive name of the rule group.</p>
    pub fn rule_group_name(&self) -> std::option::Option<&str> {
        self.rule_group_name.as_deref()
    }
    /// <p>The type of rule group. A rule group can be stateful or stateless.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for AwsNetworkFirewallRuleGroupDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsNetworkFirewallRuleGroupDetails");
        formatter.field("capacity", &self.capacity);
        formatter.field("description", &self.description);
        formatter.field("rule_group", &self.rule_group);
        formatter.field("rule_group_arn", &self.rule_group_arn);
        formatter.field("rule_group_id", &self.rule_group_id);
        formatter.field("rule_group_name", &self.rule_group_name);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AwsNetworkFirewallRuleGroupDetails`](crate::model::AwsNetworkFirewallRuleGroupDetails)
pub mod aws_network_firewall_rule_group_details {

    /// A builder for [`AwsNetworkFirewallRuleGroupDetails`](crate::model::AwsNetworkFirewallRuleGroupDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) capacity: std::option::Option<i32>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) rule_group: std::option::Option<crate::model::RuleGroupDetails>,
        pub(crate) rule_group_arn: std::option::Option<std::string::String>,
        pub(crate) rule_group_id: std::option::Option<std::string::String>,
        pub(crate) rule_group_name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The maximum number of operating resources that this rule group can use.</p>
        pub fn capacity(mut self, input: i32) -> Self {
            self.capacity = Some(input);
            self
        }
        /// <p>The maximum number of operating resources that this rule group can use.</p>
        pub fn set_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.capacity = input;
            self
        }
        /// <p>A description of the rule group.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the rule group.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Details about the rule group.</p>
        pub fn rule_group(mut self, input: crate::model::RuleGroupDetails) -> Self {
            self.rule_group = Some(input);
            self
        }
        /// <p>Details about the rule group.</p>
        pub fn set_rule_group(
            mut self,
            input: std::option::Option<crate::model::RuleGroupDetails>,
        ) -> Self {
            self.rule_group = input;
            self
        }
        /// <p>The ARN of the rule group.</p>
        pub fn rule_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_group_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the rule group.</p>
        pub fn set_rule_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_group_arn = input;
            self
        }
        /// <p>The identifier of the rule group.</p>
        pub fn rule_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_group_id = Some(input.into());
            self
        }
        /// <p>The identifier of the rule group.</p>
        pub fn set_rule_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_group_id = input;
            self
        }
        /// <p>The descriptive name of the rule group.</p>
        pub fn rule_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_group_name = Some(input.into());
            self
        }
        /// <p>The descriptive name of the rule group.</p>
        pub fn set_rule_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_group_name = input;
            self
        }
        /// <p>The type of rule group. A rule group can be stateful or stateless.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of rule group. A rule group can be stateful or stateless.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsNetworkFirewallRuleGroupDetails`](crate::model::AwsNetworkFirewallRuleGroupDetails)
        pub fn build(self) -> crate::model::AwsNetworkFirewallRuleGroupDetails {
            crate::model::AwsNetworkFirewallRuleGroupDetails {
                capacity: self.capacity.unwrap_or_default(),
                description: self.description,
                rule_group: self.rule_group,
                rule_group_arn: self.rule_group_arn,
                rule_group_id: self.rule_group_id,
                rule_group_name: self.rule_group_name,
                r#type: self.r#type,
            }
        }
    }
}
impl AwsNetworkFirewallRuleGroupDetails {
    /// Creates a new builder-style object to manufacture [`AwsNetworkFirewallRuleGroupDetails`](crate::model::AwsNetworkFirewallRuleGroupDetails)
    pub fn builder() -> crate::model::aws_network_firewall_rule_group_details::Builder {
        crate::model::aws_network_firewall_rule_group_details::Builder::default()
    }
}

/// <p>Details about the rule group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RuleGroupDetails {
    /// <p>Additional settings to use in the specified rules.</p>
    pub rule_variables: std::option::Option<crate::model::RuleGroupVariables>,
    /// <p>The rules and actions for the rule group.</p>
    /// <p>For stateful rule groups, can contain <code>RulesString</code>, <code>RulesSourceList</code>, or <code>StatefulRules</code>.</p>
    /// <p>For stateless rule groups, contains <code>StatelessRulesAndCustomActions</code>.</p>
    pub rules_source: std::option::Option<crate::model::RuleGroupSource>,
}
impl RuleGroupDetails {
    /// <p>Additional settings to use in the specified rules.</p>
    pub fn rule_variables(&self) -> std::option::Option<&crate::model::RuleGroupVariables> {
        self.rule_variables.as_ref()
    }
    /// <p>The rules and actions for the rule group.</p>
    /// <p>For stateful rule groups, can contain <code>RulesString</code>, <code>RulesSourceList</code>, or <code>StatefulRules</code>.</p>
    /// <p>For stateless rule groups, contains <code>StatelessRulesAndCustomActions</code>.</p>
    pub fn rules_source(&self) -> std::option::Option<&crate::model::RuleGroupSource> {
        self.rules_source.as_ref()
    }
}
impl std::fmt::Debug for RuleGroupDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RuleGroupDetails");
        formatter.field("rule_variables", &self.rule_variables);
        formatter.field("rules_source", &self.rules_source);
        formatter.finish()
    }
}
/// See [`RuleGroupDetails`](crate::model::RuleGroupDetails)
pub mod rule_group_details {

    /// A builder for [`RuleGroupDetails`](crate::model::RuleGroupDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_variables: std::option::Option<crate::model::RuleGroupVariables>,
        pub(crate) rules_source: std::option::Option<crate::model::RuleGroupSource>,
    }
    impl Builder {
        /// <p>Additional settings to use in the specified rules.</p>
        pub fn rule_variables(mut self, input: crate::model::RuleGroupVariables) -> Self {
            self.rule_variables = Some(input);
            self
        }
        /// <p>Additional settings to use in the specified rules.</p>
        pub fn set_rule_variables(
            mut self,
            input: std::option::Option<crate::model::RuleGroupVariables>,
        ) -> Self {
            self.rule_variables = input;
            self
        }
        /// <p>The rules and actions for the rule group.</p>
        /// <p>For stateful rule groups, can contain <code>RulesString</code>, <code>RulesSourceList</code>, or <code>StatefulRules</code>.</p>
        /// <p>For stateless rule groups, contains <code>StatelessRulesAndCustomActions</code>.</p>
        pub fn rules_source(mut self, input: crate::model::RuleGroupSource) -> Self {
            self.rules_source = Some(input);
            self
        }
        /// <p>The rules and actions for the rule group.</p>
        /// <p>For stateful rule groups, can contain <code>RulesString</code>, <code>RulesSourceList</code>, or <code>StatefulRules</code>.</p>
        /// <p>For stateless rule groups, contains <code>StatelessRulesAndCustomActions</code>.</p>
        pub fn set_rules_source(
            mut self,
            input: std::option::Option<crate::model::RuleGroupSource>,
        ) -> Self {
            self.rules_source = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleGroupDetails`](crate::model::RuleGroupDetails)
        pub fn build(self) -> crate::model::RuleGroupDetails {
            crate::model::RuleGroupDetails {
                rule_variables: self.rule_variables,
                rules_source: self.rules_source,
            }
        }
    }
}
impl RuleGroupDetails {
    /// Creates a new builder-style object to manufacture [`RuleGroupDetails`](crate::model::RuleGroupDetails)
    pub fn builder() -> crate::model::rule_group_details::Builder {
        crate::model::rule_group_details::Builder::default()
    }
}

/// <p>The rules and actions for the rule group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RuleGroupSource {
    /// <p>Stateful inspection criteria for a domain list rule group. A domain list rule group determines access by specific protocols to specific domains.</p>
    pub rules_source_list: std::option::Option<crate::model::RuleGroupSourceListDetails>,
    /// <p>Stateful inspection criteria, provided in Suricata compatible intrusion prevention system (IPS) rules.</p>
    pub rules_string: std::option::Option<std::string::String>,
    /// <p>Suricata rule specifications.</p>
    pub stateful_rules:
        std::option::Option<std::vec::Vec<crate::model::RuleGroupSourceStatefulRulesDetails>>,
    /// <p>The stateless rules and custom actions used by a stateless rule group.</p>
    pub stateless_rules_and_custom_actions:
        std::option::Option<crate::model::RuleGroupSourceStatelessRulesAndCustomActionsDetails>,
}
impl RuleGroupSource {
    /// <p>Stateful inspection criteria for a domain list rule group. A domain list rule group determines access by specific protocols to specific domains.</p>
    pub fn rules_source_list(
        &self,
    ) -> std::option::Option<&crate::model::RuleGroupSourceListDetails> {
        self.rules_source_list.as_ref()
    }
    /// <p>Stateful inspection criteria, provided in Suricata compatible intrusion prevention system (IPS) rules.</p>
    pub fn rules_string(&self) -> std::option::Option<&str> {
        self.rules_string.as_deref()
    }
    /// <p>Suricata rule specifications.</p>
    pub fn stateful_rules(
        &self,
    ) -> std::option::Option<&[crate::model::RuleGroupSourceStatefulRulesDetails]> {
        self.stateful_rules.as_deref()
    }
    /// <p>The stateless rules and custom actions used by a stateless rule group.</p>
    pub fn stateless_rules_and_custom_actions(
        &self,
    ) -> std::option::Option<&crate::model::RuleGroupSourceStatelessRulesAndCustomActionsDetails>
    {
        self.stateless_rules_and_custom_actions.as_ref()
    }
}
impl std::fmt::Debug for RuleGroupSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RuleGroupSource");
        formatter.field("rules_source_list", &self.rules_source_list);
        formatter.field("rules_string", &self.rules_string);
        formatter.field("stateful_rules", &self.stateful_rules);
        formatter.field(
            "stateless_rules_and_custom_actions",
            &self.stateless_rules_and_custom_actions,
        );
        formatter.finish()
    }
}
/// See [`RuleGroupSource`](crate::model::RuleGroupSource)
pub mod rule_group_source {

    /// A builder for [`RuleGroupSource`](crate::model::RuleGroupSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rules_source_list: std::option::Option<crate::model::RuleGroupSourceListDetails>,
        pub(crate) rules_string: std::option::Option<std::string::String>,
        pub(crate) stateful_rules:
            std::option::Option<std::vec::Vec<crate::model::RuleGroupSourceStatefulRulesDetails>>,
        pub(crate) stateless_rules_and_custom_actions:
            std::option::Option<crate::model::RuleGroupSourceStatelessRulesAndCustomActionsDetails>,
    }
    impl Builder {
        /// <p>Stateful inspection criteria for a domain list rule group. A domain list rule group determines access by specific protocols to specific domains.</p>
        pub fn rules_source_list(
            mut self,
            input: crate::model::RuleGroupSourceListDetails,
        ) -> Self {
            self.rules_source_list = Some(input);
            self
        }
        /// <p>Stateful inspection criteria for a domain list rule group. A domain list rule group determines access by specific protocols to specific domains.</p>
        pub fn set_rules_source_list(
            mut self,
            input: std::option::Option<crate::model::RuleGroupSourceListDetails>,
        ) -> Self {
            self.rules_source_list = input;
            self
        }
        /// <p>Stateful inspection criteria, provided in Suricata compatible intrusion prevention system (IPS) rules.</p>
        pub fn rules_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.rules_string = Some(input.into());
            self
        }
        /// <p>Stateful inspection criteria, provided in Suricata compatible intrusion prevention system (IPS) rules.</p>
        pub fn set_rules_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rules_string = input;
            self
        }
        /// Appends an item to `stateful_rules`.
        ///
        /// To override the contents of this collection use [`set_stateful_rules`](Self::set_stateful_rules).
        ///
        /// <p>Suricata rule specifications.</p>
        pub fn stateful_rules(
            mut self,
            input: crate::model::RuleGroupSourceStatefulRulesDetails,
        ) -> Self {
            let mut v = self.stateful_rules.unwrap_or_default();
            v.push(input);
            self.stateful_rules = Some(v);
            self
        }
        /// <p>Suricata rule specifications.</p>
        pub fn set_stateful_rules(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::RuleGroupSourceStatefulRulesDetails>,
            >,
        ) -> Self {
            self.stateful_rules = input;
            self
        }
        /// <p>The stateless rules and custom actions used by a stateless rule group.</p>
        pub fn stateless_rules_and_custom_actions(
            mut self,
            input: crate::model::RuleGroupSourceStatelessRulesAndCustomActionsDetails,
        ) -> Self {
            self.stateless_rules_and_custom_actions = Some(input);
            self
        }
        /// <p>The stateless rules and custom actions used by a stateless rule group.</p>
        pub fn set_stateless_rules_and_custom_actions(
            mut self,
            input: std::option::Option<
                crate::model::RuleGroupSourceStatelessRulesAndCustomActionsDetails,
            >,
        ) -> Self {
            self.stateless_rules_and_custom_actions = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleGroupSource`](crate::model::RuleGroupSource)
        pub fn build(self) -> crate::model::RuleGroupSource {
            crate::model::RuleGroupSource {
                rules_source_list: self.rules_source_list,
                rules_string: self.rules_string,
                stateful_rules: self.stateful_rules,
                stateless_rules_and_custom_actions: self.stateless_rules_and_custom_actions,
            }
        }
    }
}
impl RuleGroupSource {
    /// Creates a new builder-style object to manufacture [`RuleGroupSource`](crate::model::RuleGroupSource)
    pub fn builder() -> crate::model::rule_group_source::Builder {
        crate::model::rule_group_source::Builder::default()
    }
}

/// <p>Stateless rules and custom actions for a stateless rule group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RuleGroupSourceStatelessRulesAndCustomActionsDetails {
    /// <p>Custom actions for the rule group.</p>
    pub custom_actions:
        std::option::Option<std::vec::Vec<crate::model::RuleGroupSourceCustomActionsDetails>>,
    /// <p>Stateless rules for the rule group.</p>
    pub stateless_rules:
        std::option::Option<std::vec::Vec<crate::model::RuleGroupSourceStatelessRulesDetails>>,
}
impl RuleGroupSourceStatelessRulesAndCustomActionsDetails {
    /// <p>Custom actions for the rule group.</p>
    pub fn custom_actions(
        &self,
    ) -> std::option::Option<&[crate::model::RuleGroupSourceCustomActionsDetails]> {
        self.custom_actions.as_deref()
    }
    /// <p>Stateless rules for the rule group.</p>
    pub fn stateless_rules(
        &self,
    ) -> std::option::Option<&[crate::model::RuleGroupSourceStatelessRulesDetails]> {
        self.stateless_rules.as_deref()
    }
}
impl std::fmt::Debug for RuleGroupSourceStatelessRulesAndCustomActionsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RuleGroupSourceStatelessRulesAndCustomActionsDetails");
        formatter.field("custom_actions", &self.custom_actions);
        formatter.field("stateless_rules", &self.stateless_rules);
        formatter.finish()
    }
}
/// See [`RuleGroupSourceStatelessRulesAndCustomActionsDetails`](crate::model::RuleGroupSourceStatelessRulesAndCustomActionsDetails)
pub mod rule_group_source_stateless_rules_and_custom_actions_details {

    /// A builder for [`RuleGroupSourceStatelessRulesAndCustomActionsDetails`](crate::model::RuleGroupSourceStatelessRulesAndCustomActionsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) custom_actions:
            std::option::Option<std::vec::Vec<crate::model::RuleGroupSourceCustomActionsDetails>>,
        pub(crate) stateless_rules:
            std::option::Option<std::vec::Vec<crate::model::RuleGroupSourceStatelessRulesDetails>>,
    }
    impl Builder {
        /// Appends an item to `custom_actions`.
        ///
        /// To override the contents of this collection use [`set_custom_actions`](Self::set_custom_actions).
        ///
        /// <p>Custom actions for the rule group.</p>
        pub fn custom_actions(
            mut self,
            input: crate::model::RuleGroupSourceCustomActionsDetails,
        ) -> Self {
            let mut v = self.custom_actions.unwrap_or_default();
            v.push(input);
            self.custom_actions = Some(v);
            self
        }
        /// <p>Custom actions for the rule group.</p>
        pub fn set_custom_actions(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::RuleGroupSourceCustomActionsDetails>,
            >,
        ) -> Self {
            self.custom_actions = input;
            self
        }
        /// Appends an item to `stateless_rules`.
        ///
        /// To override the contents of this collection use [`set_stateless_rules`](Self::set_stateless_rules).
        ///
        /// <p>Stateless rules for the rule group.</p>
        pub fn stateless_rules(
            mut self,
            input: crate::model::RuleGroupSourceStatelessRulesDetails,
        ) -> Self {
            let mut v = self.stateless_rules.unwrap_or_default();
            v.push(input);
            self.stateless_rules = Some(v);
            self
        }
        /// <p>Stateless rules for the rule group.</p>
        pub fn set_stateless_rules(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::RuleGroupSourceStatelessRulesDetails>,
            >,
        ) -> Self {
            self.stateless_rules = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleGroupSourceStatelessRulesAndCustomActionsDetails`](crate::model::RuleGroupSourceStatelessRulesAndCustomActionsDetails)
        pub fn build(self) -> crate::model::RuleGroupSourceStatelessRulesAndCustomActionsDetails {
            crate::model::RuleGroupSourceStatelessRulesAndCustomActionsDetails {
                custom_actions: self.custom_actions,
                stateless_rules: self.stateless_rules,
            }
        }
    }
}
impl RuleGroupSourceStatelessRulesAndCustomActionsDetails {
    /// Creates a new builder-style object to manufacture [`RuleGroupSourceStatelessRulesAndCustomActionsDetails`](crate::model::RuleGroupSourceStatelessRulesAndCustomActionsDetails)
    pub fn builder(
    ) -> crate::model::rule_group_source_stateless_rules_and_custom_actions_details::Builder {
        crate::model::rule_group_source_stateless_rules_and_custom_actions_details::Builder::default(
        )
    }
}

/// <p>A stateless rule in the rule group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RuleGroupSourceStatelessRulesDetails {
    /// <p>Indicates the order in which to run this rule relative to all of the rules in the stateless rule group.</p>
    pub priority: i32,
    /// <p>Provides the definition of the stateless rule.</p>
    pub rule_definition: std::option::Option<crate::model::RuleGroupSourceStatelessRuleDefinition>,
}
impl RuleGroupSourceStatelessRulesDetails {
    /// <p>Indicates the order in which to run this rule relative to all of the rules in the stateless rule group.</p>
    pub fn priority(&self) -> i32 {
        self.priority
    }
    /// <p>Provides the definition of the stateless rule.</p>
    pub fn rule_definition(
        &self,
    ) -> std::option::Option<&crate::model::RuleGroupSourceStatelessRuleDefinition> {
        self.rule_definition.as_ref()
    }
}
impl std::fmt::Debug for RuleGroupSourceStatelessRulesDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RuleGroupSourceStatelessRulesDetails");
        formatter.field("priority", &self.priority);
        formatter.field("rule_definition", &self.rule_definition);
        formatter.finish()
    }
}
/// See [`RuleGroupSourceStatelessRulesDetails`](crate::model::RuleGroupSourceStatelessRulesDetails)
pub mod rule_group_source_stateless_rules_details {

    /// A builder for [`RuleGroupSourceStatelessRulesDetails`](crate::model::RuleGroupSourceStatelessRulesDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) priority: std::option::Option<i32>,
        pub(crate) rule_definition:
            std::option::Option<crate::model::RuleGroupSourceStatelessRuleDefinition>,
    }
    impl Builder {
        /// <p>Indicates the order in which to run this rule relative to all of the rules in the stateless rule group.</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        /// <p>Indicates the order in which to run this rule relative to all of the rules in the stateless rule group.</p>
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input;
            self
        }
        /// <p>Provides the definition of the stateless rule.</p>
        pub fn rule_definition(
            mut self,
            input: crate::model::RuleGroupSourceStatelessRuleDefinition,
        ) -> Self {
            self.rule_definition = Some(input);
            self
        }
        /// <p>Provides the definition of the stateless rule.</p>
        pub fn set_rule_definition(
            mut self,
            input: std::option::Option<crate::model::RuleGroupSourceStatelessRuleDefinition>,
        ) -> Self {
            self.rule_definition = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleGroupSourceStatelessRulesDetails`](crate::model::RuleGroupSourceStatelessRulesDetails)
        pub fn build(self) -> crate::model::RuleGroupSourceStatelessRulesDetails {
            crate::model::RuleGroupSourceStatelessRulesDetails {
                priority: self.priority.unwrap_or_default(),
                rule_definition: self.rule_definition,
            }
        }
    }
}
impl RuleGroupSourceStatelessRulesDetails {
    /// Creates a new builder-style object to manufacture [`RuleGroupSourceStatelessRulesDetails`](crate::model::RuleGroupSourceStatelessRulesDetails)
    pub fn builder() -> crate::model::rule_group_source_stateless_rules_details::Builder {
        crate::model::rule_group_source_stateless_rules_details::Builder::default()
    }
}

/// <p>The definition of the stateless rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RuleGroupSourceStatelessRuleDefinition {
    /// <p>The actions to take on a packet that matches one of the stateless rule definition's match attributes. You must specify a standard action (<code>aws:pass</code>, <code>aws:drop</code>, or <code>aws:forward_to_sfe</code>). You can then add custom actions.</p>
    pub actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The criteria for Network Firewall to use to inspect an individual packet in a stateless rule inspection.</p>
    pub match_attributes:
        std::option::Option<crate::model::RuleGroupSourceStatelessRuleMatchAttributes>,
}
impl RuleGroupSourceStatelessRuleDefinition {
    /// <p>The actions to take on a packet that matches one of the stateless rule definition's match attributes. You must specify a standard action (<code>aws:pass</code>, <code>aws:drop</code>, or <code>aws:forward_to_sfe</code>). You can then add custom actions.</p>
    pub fn actions(&self) -> std::option::Option<&[std::string::String]> {
        self.actions.as_deref()
    }
    /// <p>The criteria for Network Firewall to use to inspect an individual packet in a stateless rule inspection.</p>
    pub fn match_attributes(
        &self,
    ) -> std::option::Option<&crate::model::RuleGroupSourceStatelessRuleMatchAttributes> {
        self.match_attributes.as_ref()
    }
}
impl std::fmt::Debug for RuleGroupSourceStatelessRuleDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RuleGroupSourceStatelessRuleDefinition");
        formatter.field("actions", &self.actions);
        formatter.field("match_attributes", &self.match_attributes);
        formatter.finish()
    }
}
/// See [`RuleGroupSourceStatelessRuleDefinition`](crate::model::RuleGroupSourceStatelessRuleDefinition)
pub mod rule_group_source_stateless_rule_definition {

    /// A builder for [`RuleGroupSourceStatelessRuleDefinition`](crate::model::RuleGroupSourceStatelessRuleDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) actions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) match_attributes:
            std::option::Option<crate::model::RuleGroupSourceStatelessRuleMatchAttributes>,
    }
    impl Builder {
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>The actions to take on a packet that matches one of the stateless rule definition's match attributes. You must specify a standard action (<code>aws:pass</code>, <code>aws:drop</code>, or <code>aws:forward_to_sfe</code>). You can then add custom actions.</p>
        pub fn actions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input.into());
            self.actions = Some(v);
            self
        }
        /// <p>The actions to take on a packet that matches one of the stateless rule definition's match attributes. You must specify a standard action (<code>aws:pass</code>, <code>aws:drop</code>, or <code>aws:forward_to_sfe</code>). You can then add custom actions.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// <p>The criteria for Network Firewall to use to inspect an individual packet in a stateless rule inspection.</p>
        pub fn match_attributes(
            mut self,
            input: crate::model::RuleGroupSourceStatelessRuleMatchAttributes,
        ) -> Self {
            self.match_attributes = Some(input);
            self
        }
        /// <p>The criteria for Network Firewall to use to inspect an individual packet in a stateless rule inspection.</p>
        pub fn set_match_attributes(
            mut self,
            input: std::option::Option<crate::model::RuleGroupSourceStatelessRuleMatchAttributes>,
        ) -> Self {
            self.match_attributes = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleGroupSourceStatelessRuleDefinition`](crate::model::RuleGroupSourceStatelessRuleDefinition)
        pub fn build(self) -> crate::model::RuleGroupSourceStatelessRuleDefinition {
            crate::model::RuleGroupSourceStatelessRuleDefinition {
                actions: self.actions,
                match_attributes: self.match_attributes,
            }
        }
    }
}
impl RuleGroupSourceStatelessRuleDefinition {
    /// Creates a new builder-style object to manufacture [`RuleGroupSourceStatelessRuleDefinition`](crate::model::RuleGroupSourceStatelessRuleDefinition)
    pub fn builder() -> crate::model::rule_group_source_stateless_rule_definition::Builder {
        crate::model::rule_group_source_stateless_rule_definition::Builder::default()
    }
}

/// <p>Criteria for the stateless rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RuleGroupSourceStatelessRuleMatchAttributes {
    /// <p>A list of port ranges to specify the destination ports to inspect for.</p>
    pub destination_ports: std::option::Option<
        std::vec::Vec<crate::model::RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts>,
    >,
    /// <p>The destination IP addresses and address ranges to inspect for, in CIDR notation.</p>
    pub destinations: std::option::Option<
        std::vec::Vec<crate::model::RuleGroupSourceStatelessRuleMatchAttributesDestinations>,
    >,
    /// <p>The protocols to inspect for.</p>
    pub protocols: std::option::Option<std::vec::Vec<i32>>,
    /// <p>A list of port ranges to specify the source ports to inspect for.</p>
    pub source_ports: std::option::Option<
        std::vec::Vec<crate::model::RuleGroupSourceStatelessRuleMatchAttributesSourcePorts>,
    >,
    /// <p>The source IP addresses and address ranges to inspect for, in CIDR notation.</p>
    pub sources: std::option::Option<
        std::vec::Vec<crate::model::RuleGroupSourceStatelessRuleMatchAttributesSources>,
    >,
    /// <p>The TCP flags and masks to inspect for.</p>
    pub tcp_flags: std::option::Option<
        std::vec::Vec<crate::model::RuleGroupSourceStatelessRuleMatchAttributesTcpFlags>,
    >,
}
impl RuleGroupSourceStatelessRuleMatchAttributes {
    /// <p>A list of port ranges to specify the destination ports to inspect for.</p>
    pub fn destination_ports(
        &self,
    ) -> std::option::Option<
        &[crate::model::RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts],
    > {
        self.destination_ports.as_deref()
    }
    /// <p>The destination IP addresses and address ranges to inspect for, in CIDR notation.</p>
    pub fn destinations(
        &self,
    ) -> std::option::Option<&[crate::model::RuleGroupSourceStatelessRuleMatchAttributesDestinations]>
    {
        self.destinations.as_deref()
    }
    /// <p>The protocols to inspect for.</p>
    pub fn protocols(&self) -> std::option::Option<&[i32]> {
        self.protocols.as_deref()
    }
    /// <p>A list of port ranges to specify the source ports to inspect for.</p>
    pub fn source_ports(
        &self,
    ) -> std::option::Option<&[crate::model::RuleGroupSourceStatelessRuleMatchAttributesSourcePorts]>
    {
        self.source_ports.as_deref()
    }
    /// <p>The source IP addresses and address ranges to inspect for, in CIDR notation.</p>
    pub fn sources(
        &self,
    ) -> std::option::Option<&[crate::model::RuleGroupSourceStatelessRuleMatchAttributesSources]>
    {
        self.sources.as_deref()
    }
    /// <p>The TCP flags and masks to inspect for.</p>
    pub fn tcp_flags(
        &self,
    ) -> std::option::Option<&[crate::model::RuleGroupSourceStatelessRuleMatchAttributesTcpFlags]>
    {
        self.tcp_flags.as_deref()
    }
}
impl std::fmt::Debug for RuleGroupSourceStatelessRuleMatchAttributes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RuleGroupSourceStatelessRuleMatchAttributes");
        formatter.field("destination_ports", &self.destination_ports);
        formatter.field("destinations", &self.destinations);
        formatter.field("protocols", &self.protocols);
        formatter.field("source_ports", &self.source_ports);
        formatter.field("sources", &self.sources);
        formatter.field("tcp_flags", &self.tcp_flags);
        formatter.finish()
    }
}
/// See [`RuleGroupSourceStatelessRuleMatchAttributes`](crate::model::RuleGroupSourceStatelessRuleMatchAttributes)
pub mod rule_group_source_stateless_rule_match_attributes {

    /// A builder for [`RuleGroupSourceStatelessRuleMatchAttributes`](crate::model::RuleGroupSourceStatelessRuleMatchAttributes)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_ports: std::option::Option<
            std::vec::Vec<
                crate::model::RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts,
            >,
        >,
        pub(crate) destinations: std::option::Option<
            std::vec::Vec<crate::model::RuleGroupSourceStatelessRuleMatchAttributesDestinations>,
        >,
        pub(crate) protocols: std::option::Option<std::vec::Vec<i32>>,
        pub(crate) source_ports: std::option::Option<
            std::vec::Vec<crate::model::RuleGroupSourceStatelessRuleMatchAttributesSourcePorts>,
        >,
        pub(crate) sources: std::option::Option<
            std::vec::Vec<crate::model::RuleGroupSourceStatelessRuleMatchAttributesSources>,
        >,
        pub(crate) tcp_flags: std::option::Option<
            std::vec::Vec<crate::model::RuleGroupSourceStatelessRuleMatchAttributesTcpFlags>,
        >,
    }
    impl Builder {
        /// Appends an item to `destination_ports`.
        ///
        /// To override the contents of this collection use [`set_destination_ports`](Self::set_destination_ports).
        ///
        /// <p>A list of port ranges to specify the destination ports to inspect for.</p>
        pub fn destination_ports(
            mut self,
            input: crate::model::RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts,
        ) -> Self {
            let mut v = self.destination_ports.unwrap_or_default();
            v.push(input);
            self.destination_ports = Some(v);
            self
        }
        /// <p>A list of port ranges to specify the destination ports to inspect for.</p>
        pub fn set_destination_ports(
            mut self,
            input: std::option::Option<
                std::vec::Vec<
                    crate::model::RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts,
                >,
            >,
        ) -> Self {
            self.destination_ports = input;
            self
        }
        /// Appends an item to `destinations`.
        ///
        /// To override the contents of this collection use [`set_destinations`](Self::set_destinations).
        ///
        /// <p>The destination IP addresses and address ranges to inspect for, in CIDR notation.</p>
        pub fn destinations(
            mut self,
            input: crate::model::RuleGroupSourceStatelessRuleMatchAttributesDestinations,
        ) -> Self {
            let mut v = self.destinations.unwrap_or_default();
            v.push(input);
            self.destinations = Some(v);
            self
        }
        /// <p>The destination IP addresses and address ranges to inspect for, in CIDR notation.</p>
        pub fn set_destinations(
            mut self,
            input: std::option::Option<
                std::vec::Vec<
                    crate::model::RuleGroupSourceStatelessRuleMatchAttributesDestinations,
                >,
            >,
        ) -> Self {
            self.destinations = input;
            self
        }
        /// Appends an item to `protocols`.
        ///
        /// To override the contents of this collection use [`set_protocols`](Self::set_protocols).
        ///
        /// <p>The protocols to inspect for.</p>
        pub fn protocols(mut self, input: i32) -> Self {
            let mut v = self.protocols.unwrap_or_default();
            v.push(input);
            self.protocols = Some(v);
            self
        }
        /// <p>The protocols to inspect for.</p>
        pub fn set_protocols(mut self, input: std::option::Option<std::vec::Vec<i32>>) -> Self {
            self.protocols = input;
            self
        }
        /// Appends an item to `source_ports`.
        ///
        /// To override the contents of this collection use [`set_source_ports`](Self::set_source_ports).
        ///
        /// <p>A list of port ranges to specify the source ports to inspect for.</p>
        pub fn source_ports(
            mut self,
            input: crate::model::RuleGroupSourceStatelessRuleMatchAttributesSourcePorts,
        ) -> Self {
            let mut v = self.source_ports.unwrap_or_default();
            v.push(input);
            self.source_ports = Some(v);
            self
        }
        /// <p>A list of port ranges to specify the source ports to inspect for.</p>
        pub fn set_source_ports(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::RuleGroupSourceStatelessRuleMatchAttributesSourcePorts>,
            >,
        ) -> Self {
            self.source_ports = input;
            self
        }
        /// Appends an item to `sources`.
        ///
        /// To override the contents of this collection use [`set_sources`](Self::set_sources).
        ///
        /// <p>The source IP addresses and address ranges to inspect for, in CIDR notation.</p>
        pub fn sources(
            mut self,
            input: crate::model::RuleGroupSourceStatelessRuleMatchAttributesSources,
        ) -> Self {
            let mut v = self.sources.unwrap_or_default();
            v.push(input);
            self.sources = Some(v);
            self
        }
        /// <p>The source IP addresses and address ranges to inspect for, in CIDR notation.</p>
        pub fn set_sources(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::RuleGroupSourceStatelessRuleMatchAttributesSources>,
            >,
        ) -> Self {
            self.sources = input;
            self
        }
        /// Appends an item to `tcp_flags`.
        ///
        /// To override the contents of this collection use [`set_tcp_flags`](Self::set_tcp_flags).
        ///
        /// <p>The TCP flags and masks to inspect for.</p>
        pub fn tcp_flags(
            mut self,
            input: crate::model::RuleGroupSourceStatelessRuleMatchAttributesTcpFlags,
        ) -> Self {
            let mut v = self.tcp_flags.unwrap_or_default();
            v.push(input);
            self.tcp_flags = Some(v);
            self
        }
        /// <p>The TCP flags and masks to inspect for.</p>
        pub fn set_tcp_flags(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::RuleGroupSourceStatelessRuleMatchAttributesTcpFlags>,
            >,
        ) -> Self {
            self.tcp_flags = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleGroupSourceStatelessRuleMatchAttributes`](crate::model::RuleGroupSourceStatelessRuleMatchAttributes)
        pub fn build(self) -> crate::model::RuleGroupSourceStatelessRuleMatchAttributes {
            crate::model::RuleGroupSourceStatelessRuleMatchAttributes {
                destination_ports: self.destination_ports,
                destinations: self.destinations,
                protocols: self.protocols,
                source_ports: self.source_ports,
                sources: self.sources,
                tcp_flags: self.tcp_flags,
            }
        }
    }
}
impl RuleGroupSourceStatelessRuleMatchAttributes {
    /// Creates a new builder-style object to manufacture [`RuleGroupSourceStatelessRuleMatchAttributes`](crate::model::RuleGroupSourceStatelessRuleMatchAttributes)
    pub fn builder() -> crate::model::rule_group_source_stateless_rule_match_attributes::Builder {
        crate::model::rule_group_source_stateless_rule_match_attributes::Builder::default()
    }
}

/// <p>A set of TCP flags and masks to inspect for.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RuleGroupSourceStatelessRuleMatchAttributesTcpFlags {
    /// <p>Defines the flags from the <code>Masks</code> setting that must be set in order for the packet to match. Flags that are listed must be set. Flags that are not listed must not be set.</p>
    pub flags: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The set of flags to consider in the inspection. If not specified, then all flags are inspected.</p>
    pub masks: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl RuleGroupSourceStatelessRuleMatchAttributesTcpFlags {
    /// <p>Defines the flags from the <code>Masks</code> setting that must be set in order for the packet to match. Flags that are listed must be set. Flags that are not listed must not be set.</p>
    pub fn flags(&self) -> std::option::Option<&[std::string::String]> {
        self.flags.as_deref()
    }
    /// <p>The set of flags to consider in the inspection. If not specified, then all flags are inspected.</p>
    pub fn masks(&self) -> std::option::Option<&[std::string::String]> {
        self.masks.as_deref()
    }
}
impl std::fmt::Debug for RuleGroupSourceStatelessRuleMatchAttributesTcpFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RuleGroupSourceStatelessRuleMatchAttributesTcpFlags");
        formatter.field("flags", &self.flags);
        formatter.field("masks", &self.masks);
        formatter.finish()
    }
}
/// See [`RuleGroupSourceStatelessRuleMatchAttributesTcpFlags`](crate::model::RuleGroupSourceStatelessRuleMatchAttributesTcpFlags)
pub mod rule_group_source_stateless_rule_match_attributes_tcp_flags {

    /// A builder for [`RuleGroupSourceStatelessRuleMatchAttributesTcpFlags`](crate::model::RuleGroupSourceStatelessRuleMatchAttributesTcpFlags)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) flags: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) masks: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `flags`.
        ///
        /// To override the contents of this collection use [`set_flags`](Self::set_flags).
        ///
        /// <p>Defines the flags from the <code>Masks</code> setting that must be set in order for the packet to match. Flags that are listed must be set. Flags that are not listed must not be set.</p>
        pub fn flags(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.flags.unwrap_or_default();
            v.push(input.into());
            self.flags = Some(v);
            self
        }
        /// <p>Defines the flags from the <code>Masks</code> setting that must be set in order for the packet to match. Flags that are listed must be set. Flags that are not listed must not be set.</p>
        pub fn set_flags(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.flags = input;
            self
        }
        /// Appends an item to `masks`.
        ///
        /// To override the contents of this collection use [`set_masks`](Self::set_masks).
        ///
        /// <p>The set of flags to consider in the inspection. If not specified, then all flags are inspected.</p>
        pub fn masks(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.masks.unwrap_or_default();
            v.push(input.into());
            self.masks = Some(v);
            self
        }
        /// <p>The set of flags to consider in the inspection. If not specified, then all flags are inspected.</p>
        pub fn set_masks(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.masks = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleGroupSourceStatelessRuleMatchAttributesTcpFlags`](crate::model::RuleGroupSourceStatelessRuleMatchAttributesTcpFlags)
        pub fn build(self) -> crate::model::RuleGroupSourceStatelessRuleMatchAttributesTcpFlags {
            crate::model::RuleGroupSourceStatelessRuleMatchAttributesTcpFlags {
                flags: self.flags,
                masks: self.masks,
            }
        }
    }
}
impl RuleGroupSourceStatelessRuleMatchAttributesTcpFlags {
    /// Creates a new builder-style object to manufacture [`RuleGroupSourceStatelessRuleMatchAttributesTcpFlags`](crate::model::RuleGroupSourceStatelessRuleMatchAttributesTcpFlags)
    pub fn builder(
    ) -> crate::model::rule_group_source_stateless_rule_match_attributes_tcp_flags::Builder {
        crate::model::rule_group_source_stateless_rule_match_attributes_tcp_flags::Builder::default(
        )
    }
}

/// <p>A source IP addresses and address range to inspect for.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RuleGroupSourceStatelessRuleMatchAttributesSources {
    /// <p>An IP address or a block of IP addresses.</p>
    pub address_definition: std::option::Option<std::string::String>,
}
impl RuleGroupSourceStatelessRuleMatchAttributesSources {
    /// <p>An IP address or a block of IP addresses.</p>
    pub fn address_definition(&self) -> std::option::Option<&str> {
        self.address_definition.as_deref()
    }
}
impl std::fmt::Debug for RuleGroupSourceStatelessRuleMatchAttributesSources {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RuleGroupSourceStatelessRuleMatchAttributesSources");
        formatter.field("address_definition", &self.address_definition);
        formatter.finish()
    }
}
/// See [`RuleGroupSourceStatelessRuleMatchAttributesSources`](crate::model::RuleGroupSourceStatelessRuleMatchAttributesSources)
pub mod rule_group_source_stateless_rule_match_attributes_sources {

    /// A builder for [`RuleGroupSourceStatelessRuleMatchAttributesSources`](crate::model::RuleGroupSourceStatelessRuleMatchAttributesSources)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) address_definition: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An IP address or a block of IP addresses.</p>
        pub fn address_definition(mut self, input: impl Into<std::string::String>) -> Self {
            self.address_definition = Some(input.into());
            self
        }
        /// <p>An IP address or a block of IP addresses.</p>
        pub fn set_address_definition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.address_definition = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleGroupSourceStatelessRuleMatchAttributesSources`](crate::model::RuleGroupSourceStatelessRuleMatchAttributesSources)
        pub fn build(self) -> crate::model::RuleGroupSourceStatelessRuleMatchAttributesSources {
            crate::model::RuleGroupSourceStatelessRuleMatchAttributesSources {
                address_definition: self.address_definition,
            }
        }
    }
}
impl RuleGroupSourceStatelessRuleMatchAttributesSources {
    /// Creates a new builder-style object to manufacture [`RuleGroupSourceStatelessRuleMatchAttributesSources`](crate::model::RuleGroupSourceStatelessRuleMatchAttributesSources)
    pub fn builder(
    ) -> crate::model::rule_group_source_stateless_rule_match_attributes_sources::Builder {
        crate::model::rule_group_source_stateless_rule_match_attributes_sources::Builder::default()
    }
}

/// <p>A port range to specify the source ports to inspect for.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RuleGroupSourceStatelessRuleMatchAttributesSourcePorts {
    /// <p>The starting port value for the port range.</p>
    pub from_port: i32,
    /// <p>The ending port value for the port range.</p>
    pub to_port: i32,
}
impl RuleGroupSourceStatelessRuleMatchAttributesSourcePorts {
    /// <p>The starting port value for the port range.</p>
    pub fn from_port(&self) -> i32 {
        self.from_port
    }
    /// <p>The ending port value for the port range.</p>
    pub fn to_port(&self) -> i32 {
        self.to_port
    }
}
impl std::fmt::Debug for RuleGroupSourceStatelessRuleMatchAttributesSourcePorts {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("RuleGroupSourceStatelessRuleMatchAttributesSourcePorts");
        formatter.field("from_port", &self.from_port);
        formatter.field("to_port", &self.to_port);
        formatter.finish()
    }
}
/// See [`RuleGroupSourceStatelessRuleMatchAttributesSourcePorts`](crate::model::RuleGroupSourceStatelessRuleMatchAttributesSourcePorts)
pub mod rule_group_source_stateless_rule_match_attributes_source_ports {

    /// A builder for [`RuleGroupSourceStatelessRuleMatchAttributesSourcePorts`](crate::model::RuleGroupSourceStatelessRuleMatchAttributesSourcePorts)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) from_port: std::option::Option<i32>,
        pub(crate) to_port: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The starting port value for the port range.</p>
        pub fn from_port(mut self, input: i32) -> Self {
            self.from_port = Some(input);
            self
        }
        /// <p>The starting port value for the port range.</p>
        pub fn set_from_port(mut self, input: std::option::Option<i32>) -> Self {
            self.from_port = input;
            self
        }
        /// <p>The ending port value for the port range.</p>
        pub fn to_port(mut self, input: i32) -> Self {
            self.to_port = Some(input);
            self
        }
        /// <p>The ending port value for the port range.</p>
        pub fn set_to_port(mut self, input: std::option::Option<i32>) -> Self {
            self.to_port = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleGroupSourceStatelessRuleMatchAttributesSourcePorts`](crate::model::RuleGroupSourceStatelessRuleMatchAttributesSourcePorts)
        pub fn build(self) -> crate::model::RuleGroupSourceStatelessRuleMatchAttributesSourcePorts {
            crate::model::RuleGroupSourceStatelessRuleMatchAttributesSourcePorts {
                from_port: self.from_port.unwrap_or_default(),
                to_port: self.to_port.unwrap_or_default(),
            }
        }
    }
}
impl RuleGroupSourceStatelessRuleMatchAttributesSourcePorts {
    /// Creates a new builder-style object to manufacture [`RuleGroupSourceStatelessRuleMatchAttributesSourcePorts`](crate::model::RuleGroupSourceStatelessRuleMatchAttributesSourcePorts)
    pub fn builder(
    ) -> crate::model::rule_group_source_stateless_rule_match_attributes_source_ports::Builder {
        crate::model::rule_group_source_stateless_rule_match_attributes_source_ports::Builder::default()
    }
}

/// <p>A destination IP address or range.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RuleGroupSourceStatelessRuleMatchAttributesDestinations {
    /// <p>An IP address or a block of IP addresses.</p>
    pub address_definition: std::option::Option<std::string::String>,
}
impl RuleGroupSourceStatelessRuleMatchAttributesDestinations {
    /// <p>An IP address or a block of IP addresses.</p>
    pub fn address_definition(&self) -> std::option::Option<&str> {
        self.address_definition.as_deref()
    }
}
impl std::fmt::Debug for RuleGroupSourceStatelessRuleMatchAttributesDestinations {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("RuleGroupSourceStatelessRuleMatchAttributesDestinations");
        formatter.field("address_definition", &self.address_definition);
        formatter.finish()
    }
}
/// See [`RuleGroupSourceStatelessRuleMatchAttributesDestinations`](crate::model::RuleGroupSourceStatelessRuleMatchAttributesDestinations)
pub mod rule_group_source_stateless_rule_match_attributes_destinations {

    /// A builder for [`RuleGroupSourceStatelessRuleMatchAttributesDestinations`](crate::model::RuleGroupSourceStatelessRuleMatchAttributesDestinations)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) address_definition: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An IP address or a block of IP addresses.</p>
        pub fn address_definition(mut self, input: impl Into<std::string::String>) -> Self {
            self.address_definition = Some(input.into());
            self
        }
        /// <p>An IP address or a block of IP addresses.</p>
        pub fn set_address_definition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.address_definition = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleGroupSourceStatelessRuleMatchAttributesDestinations`](crate::model::RuleGroupSourceStatelessRuleMatchAttributesDestinations)
        pub fn build(
            self,
        ) -> crate::model::RuleGroupSourceStatelessRuleMatchAttributesDestinations {
            crate::model::RuleGroupSourceStatelessRuleMatchAttributesDestinations {
                address_definition: self.address_definition,
            }
        }
    }
}
impl RuleGroupSourceStatelessRuleMatchAttributesDestinations {
    /// Creates a new builder-style object to manufacture [`RuleGroupSourceStatelessRuleMatchAttributesDestinations`](crate::model::RuleGroupSourceStatelessRuleMatchAttributesDestinations)
    pub fn builder(
    ) -> crate::model::rule_group_source_stateless_rule_match_attributes_destinations::Builder {
        crate::model::rule_group_source_stateless_rule_match_attributes_destinations::Builder::default()
    }
}

/// <p>A port range to specify the destination ports to inspect for.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts {
    /// <p>The starting port value for the port range.</p>
    pub from_port: i32,
    /// <p>The ending port value for the port range.</p>
    pub to_port: i32,
}
impl RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts {
    /// <p>The starting port value for the port range.</p>
    pub fn from_port(&self) -> i32 {
        self.from_port
    }
    /// <p>The ending port value for the port range.</p>
    pub fn to_port(&self) -> i32 {
        self.to_port
    }
}
impl std::fmt::Debug for RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts");
        formatter.field("from_port", &self.from_port);
        formatter.field("to_port", &self.to_port);
        formatter.finish()
    }
}
/// See [`RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts`](crate::model::RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts)
pub mod rule_group_source_stateless_rule_match_attributes_destination_ports {

    /// A builder for [`RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts`](crate::model::RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) from_port: std::option::Option<i32>,
        pub(crate) to_port: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The starting port value for the port range.</p>
        pub fn from_port(mut self, input: i32) -> Self {
            self.from_port = Some(input);
            self
        }
        /// <p>The starting port value for the port range.</p>
        pub fn set_from_port(mut self, input: std::option::Option<i32>) -> Self {
            self.from_port = input;
            self
        }
        /// <p>The ending port value for the port range.</p>
        pub fn to_port(mut self, input: i32) -> Self {
            self.to_port = Some(input);
            self
        }
        /// <p>The ending port value for the port range.</p>
        pub fn set_to_port(mut self, input: std::option::Option<i32>) -> Self {
            self.to_port = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts`](crate::model::RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts)
        pub fn build(
            self,
        ) -> crate::model::RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts {
            crate::model::RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts {
                from_port: self.from_port.unwrap_or_default(),
                to_port: self.to_port.unwrap_or_default(),
            }
        }
    }
}
impl RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts {
    /// Creates a new builder-style object to manufacture [`RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts`](crate::model::RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts)
    pub fn builder(
    ) -> crate::model::rule_group_source_stateless_rule_match_attributes_destination_ports::Builder
    {
        crate::model::rule_group_source_stateless_rule_match_attributes_destination_ports::Builder::default()
    }
}

/// <p>A custom action definition. A custom action is an optional, non-standard action to use for stateless packet handling.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RuleGroupSourceCustomActionsDetails {
    /// <p>The definition of a custom action.</p>
    pub action_definition: std::option::Option<crate::model::StatelessCustomActionDefinition>,
    /// <p>A descriptive name of the custom action.</p>
    pub action_name: std::option::Option<std::string::String>,
}
impl RuleGroupSourceCustomActionsDetails {
    /// <p>The definition of a custom action.</p>
    pub fn action_definition(
        &self,
    ) -> std::option::Option<&crate::model::StatelessCustomActionDefinition> {
        self.action_definition.as_ref()
    }
    /// <p>A descriptive name of the custom action.</p>
    pub fn action_name(&self) -> std::option::Option<&str> {
        self.action_name.as_deref()
    }
}
impl std::fmt::Debug for RuleGroupSourceCustomActionsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RuleGroupSourceCustomActionsDetails");
        formatter.field("action_definition", &self.action_definition);
        formatter.field("action_name", &self.action_name);
        formatter.finish()
    }
}
/// See [`RuleGroupSourceCustomActionsDetails`](crate::model::RuleGroupSourceCustomActionsDetails)
pub mod rule_group_source_custom_actions_details {

    /// A builder for [`RuleGroupSourceCustomActionsDetails`](crate::model::RuleGroupSourceCustomActionsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action_definition:
            std::option::Option<crate::model::StatelessCustomActionDefinition>,
        pub(crate) action_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The definition of a custom action.</p>
        pub fn action_definition(
            mut self,
            input: crate::model::StatelessCustomActionDefinition,
        ) -> Self {
            self.action_definition = Some(input);
            self
        }
        /// <p>The definition of a custom action.</p>
        pub fn set_action_definition(
            mut self,
            input: std::option::Option<crate::model::StatelessCustomActionDefinition>,
        ) -> Self {
            self.action_definition = input;
            self
        }
        /// <p>A descriptive name of the custom action.</p>
        pub fn action_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_name = Some(input.into());
            self
        }
        /// <p>A descriptive name of the custom action.</p>
        pub fn set_action_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_name = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleGroupSourceCustomActionsDetails`](crate::model::RuleGroupSourceCustomActionsDetails)
        pub fn build(self) -> crate::model::RuleGroupSourceCustomActionsDetails {
            crate::model::RuleGroupSourceCustomActionsDetails {
                action_definition: self.action_definition,
                action_name: self.action_name,
            }
        }
    }
}
impl RuleGroupSourceCustomActionsDetails {
    /// Creates a new builder-style object to manufacture [`RuleGroupSourceCustomActionsDetails`](crate::model::RuleGroupSourceCustomActionsDetails)
    pub fn builder() -> crate::model::rule_group_source_custom_actions_details::Builder {
        crate::model::rule_group_source_custom_actions_details::Builder::default()
    }
}

/// <p>The definition of a custom action that can be used for stateless packet handling.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StatelessCustomActionDefinition {
    /// <p>Information about metrics to publish to CloudWatch.</p>
    pub publish_metric_action:
        std::option::Option<crate::model::StatelessCustomPublishMetricAction>,
}
impl StatelessCustomActionDefinition {
    /// <p>Information about metrics to publish to CloudWatch.</p>
    pub fn publish_metric_action(
        &self,
    ) -> std::option::Option<&crate::model::StatelessCustomPublishMetricAction> {
        self.publish_metric_action.as_ref()
    }
}
impl std::fmt::Debug for StatelessCustomActionDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StatelessCustomActionDefinition");
        formatter.field("publish_metric_action", &self.publish_metric_action);
        formatter.finish()
    }
}
/// See [`StatelessCustomActionDefinition`](crate::model::StatelessCustomActionDefinition)
pub mod stateless_custom_action_definition {

    /// A builder for [`StatelessCustomActionDefinition`](crate::model::StatelessCustomActionDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) publish_metric_action:
            std::option::Option<crate::model::StatelessCustomPublishMetricAction>,
    }
    impl Builder {
        /// <p>Information about metrics to publish to CloudWatch.</p>
        pub fn publish_metric_action(
            mut self,
            input: crate::model::StatelessCustomPublishMetricAction,
        ) -> Self {
            self.publish_metric_action = Some(input);
            self
        }
        /// <p>Information about metrics to publish to CloudWatch.</p>
        pub fn set_publish_metric_action(
            mut self,
            input: std::option::Option<crate::model::StatelessCustomPublishMetricAction>,
        ) -> Self {
            self.publish_metric_action = input;
            self
        }
        /// Consumes the builder and constructs a [`StatelessCustomActionDefinition`](crate::model::StatelessCustomActionDefinition)
        pub fn build(self) -> crate::model::StatelessCustomActionDefinition {
            crate::model::StatelessCustomActionDefinition {
                publish_metric_action: self.publish_metric_action,
            }
        }
    }
}
impl StatelessCustomActionDefinition {
    /// Creates a new builder-style object to manufacture [`StatelessCustomActionDefinition`](crate::model::StatelessCustomActionDefinition)
    pub fn builder() -> crate::model::stateless_custom_action_definition::Builder {
        crate::model::stateless_custom_action_definition::Builder::default()
    }
}

/// <p>Information about metrics to publish to CloudWatch.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StatelessCustomPublishMetricAction {
    /// <p>Defines CloudWatch dimension values to publish.</p>
    pub dimensions: std::option::Option<
        std::vec::Vec<crate::model::StatelessCustomPublishMetricActionDimension>,
    >,
}
impl StatelessCustomPublishMetricAction {
    /// <p>Defines CloudWatch dimension values to publish.</p>
    pub fn dimensions(
        &self,
    ) -> std::option::Option<&[crate::model::StatelessCustomPublishMetricActionDimension]> {
        self.dimensions.as_deref()
    }
}
impl std::fmt::Debug for StatelessCustomPublishMetricAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StatelessCustomPublishMetricAction");
        formatter.field("dimensions", &self.dimensions);
        formatter.finish()
    }
}
/// See [`StatelessCustomPublishMetricAction`](crate::model::StatelessCustomPublishMetricAction)
pub mod stateless_custom_publish_metric_action {

    /// A builder for [`StatelessCustomPublishMetricAction`](crate::model::StatelessCustomPublishMetricAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dimensions: std::option::Option<
            std::vec::Vec<crate::model::StatelessCustomPublishMetricActionDimension>,
        >,
    }
    impl Builder {
        /// Appends an item to `dimensions`.
        ///
        /// To override the contents of this collection use [`set_dimensions`](Self::set_dimensions).
        ///
        /// <p>Defines CloudWatch dimension values to publish.</p>
        pub fn dimensions(
            mut self,
            input: crate::model::StatelessCustomPublishMetricActionDimension,
        ) -> Self {
            let mut v = self.dimensions.unwrap_or_default();
            v.push(input);
            self.dimensions = Some(v);
            self
        }
        /// <p>Defines CloudWatch dimension values to publish.</p>
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::StatelessCustomPublishMetricActionDimension>,
            >,
        ) -> Self {
            self.dimensions = input;
            self
        }
        /// Consumes the builder and constructs a [`StatelessCustomPublishMetricAction`](crate::model::StatelessCustomPublishMetricAction)
        pub fn build(self) -> crate::model::StatelessCustomPublishMetricAction {
            crate::model::StatelessCustomPublishMetricAction {
                dimensions: self.dimensions,
            }
        }
    }
}
impl StatelessCustomPublishMetricAction {
    /// Creates a new builder-style object to manufacture [`StatelessCustomPublishMetricAction`](crate::model::StatelessCustomPublishMetricAction)
    pub fn builder() -> crate::model::stateless_custom_publish_metric_action::Builder {
        crate::model::stateless_custom_publish_metric_action::Builder::default()
    }
}

/// <p>Defines a CloudWatch dimension value to publish.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StatelessCustomPublishMetricActionDimension {
    /// <p>The value to use for the custom metric dimension.</p>
    pub value: std::option::Option<std::string::String>,
}
impl StatelessCustomPublishMetricActionDimension {
    /// <p>The value to use for the custom metric dimension.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for StatelessCustomPublishMetricActionDimension {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StatelessCustomPublishMetricActionDimension");
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`StatelessCustomPublishMetricActionDimension`](crate::model::StatelessCustomPublishMetricActionDimension)
pub mod stateless_custom_publish_metric_action_dimension {

    /// A builder for [`StatelessCustomPublishMetricActionDimension`](crate::model::StatelessCustomPublishMetricActionDimension)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The value to use for the custom metric dimension.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value to use for the custom metric dimension.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`StatelessCustomPublishMetricActionDimension`](crate::model::StatelessCustomPublishMetricActionDimension)
        pub fn build(self) -> crate::model::StatelessCustomPublishMetricActionDimension {
            crate::model::StatelessCustomPublishMetricActionDimension { value: self.value }
        }
    }
}
impl StatelessCustomPublishMetricActionDimension {
    /// Creates a new builder-style object to manufacture [`StatelessCustomPublishMetricActionDimension`](crate::model::StatelessCustomPublishMetricActionDimension)
    pub fn builder() -> crate::model::stateless_custom_publish_metric_action_dimension::Builder {
        crate::model::stateless_custom_publish_metric_action_dimension::Builder::default()
    }
}

/// <p>A Suricata rule specification.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RuleGroupSourceStatefulRulesDetails {
    /// <p>Defines what Network Firewall should do with the packets in a traffic flow when the flow matches the stateful rule criteria.</p>
    pub action: std::option::Option<std::string::String>,
    /// <p>The stateful inspection criteria for the rule.</p>
    pub header: std::option::Option<crate::model::RuleGroupSourceStatefulRulesHeaderDetails>,
    /// <p>Additional options for the rule.</p>
    pub rule_options: std::option::Option<
        std::vec::Vec<crate::model::RuleGroupSourceStatefulRulesOptionsDetails>,
    >,
}
impl RuleGroupSourceStatefulRulesDetails {
    /// <p>Defines what Network Firewall should do with the packets in a traffic flow when the flow matches the stateful rule criteria.</p>
    pub fn action(&self) -> std::option::Option<&str> {
        self.action.as_deref()
    }
    /// <p>The stateful inspection criteria for the rule.</p>
    pub fn header(
        &self,
    ) -> std::option::Option<&crate::model::RuleGroupSourceStatefulRulesHeaderDetails> {
        self.header.as_ref()
    }
    /// <p>Additional options for the rule.</p>
    pub fn rule_options(
        &self,
    ) -> std::option::Option<&[crate::model::RuleGroupSourceStatefulRulesOptionsDetails]> {
        self.rule_options.as_deref()
    }
}
impl std::fmt::Debug for RuleGroupSourceStatefulRulesDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RuleGroupSourceStatefulRulesDetails");
        formatter.field("action", &self.action);
        formatter.field("header", &self.header);
        formatter.field("rule_options", &self.rule_options);
        formatter.finish()
    }
}
/// See [`RuleGroupSourceStatefulRulesDetails`](crate::model::RuleGroupSourceStatefulRulesDetails)
pub mod rule_group_source_stateful_rules_details {

    /// A builder for [`RuleGroupSourceStatefulRulesDetails`](crate::model::RuleGroupSourceStatefulRulesDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action: std::option::Option<std::string::String>,
        pub(crate) header:
            std::option::Option<crate::model::RuleGroupSourceStatefulRulesHeaderDetails>,
        pub(crate) rule_options: std::option::Option<
            std::vec::Vec<crate::model::RuleGroupSourceStatefulRulesOptionsDetails>,
        >,
    }
    impl Builder {
        /// <p>Defines what Network Firewall should do with the packets in a traffic flow when the flow matches the stateful rule criteria.</p>
        pub fn action(mut self, input: impl Into<std::string::String>) -> Self {
            self.action = Some(input.into());
            self
        }
        /// <p>Defines what Network Firewall should do with the packets in a traffic flow when the flow matches the stateful rule criteria.</p>
        pub fn set_action(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action = input;
            self
        }
        /// <p>The stateful inspection criteria for the rule.</p>
        pub fn header(
            mut self,
            input: crate::model::RuleGroupSourceStatefulRulesHeaderDetails,
        ) -> Self {
            self.header = Some(input);
            self
        }
        /// <p>The stateful inspection criteria for the rule.</p>
        pub fn set_header(
            mut self,
            input: std::option::Option<crate::model::RuleGroupSourceStatefulRulesHeaderDetails>,
        ) -> Self {
            self.header = input;
            self
        }
        /// Appends an item to `rule_options`.
        ///
        /// To override the contents of this collection use [`set_rule_options`](Self::set_rule_options).
        ///
        /// <p>Additional options for the rule.</p>
        pub fn rule_options(
            mut self,
            input: crate::model::RuleGroupSourceStatefulRulesOptionsDetails,
        ) -> Self {
            let mut v = self.rule_options.unwrap_or_default();
            v.push(input);
            self.rule_options = Some(v);
            self
        }
        /// <p>Additional options for the rule.</p>
        pub fn set_rule_options(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::RuleGroupSourceStatefulRulesOptionsDetails>,
            >,
        ) -> Self {
            self.rule_options = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleGroupSourceStatefulRulesDetails`](crate::model::RuleGroupSourceStatefulRulesDetails)
        pub fn build(self) -> crate::model::RuleGroupSourceStatefulRulesDetails {
            crate::model::RuleGroupSourceStatefulRulesDetails {
                action: self.action,
                header: self.header,
                rule_options: self.rule_options,
            }
        }
    }
}
impl RuleGroupSourceStatefulRulesDetails {
    /// Creates a new builder-style object to manufacture [`RuleGroupSourceStatefulRulesDetails`](crate::model::RuleGroupSourceStatefulRulesDetails)
    pub fn builder() -> crate::model::rule_group_source_stateful_rules_details::Builder {
        crate::model::rule_group_source_stateful_rules_details::Builder::default()
    }
}

/// <p>A rule option for a stateful rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RuleGroupSourceStatefulRulesOptionsDetails {
    /// <p>A keyword to look for.</p>
    pub keyword: std::option::Option<std::string::String>,
    /// <p>A list of settings.</p>
    pub settings: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl RuleGroupSourceStatefulRulesOptionsDetails {
    /// <p>A keyword to look for.</p>
    pub fn keyword(&self) -> std::option::Option<&str> {
        self.keyword.as_deref()
    }
    /// <p>A list of settings.</p>
    pub fn settings(&self) -> std::option::Option<&[std::string::String]> {
        self.settings.as_deref()
    }
}
impl std::fmt::Debug for RuleGroupSourceStatefulRulesOptionsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RuleGroupSourceStatefulRulesOptionsDetails");
        formatter.field("keyword", &self.keyword);
        formatter.field("settings", &self.settings);
        formatter.finish()
    }
}
/// See [`RuleGroupSourceStatefulRulesOptionsDetails`](crate::model::RuleGroupSourceStatefulRulesOptionsDetails)
pub mod rule_group_source_stateful_rules_options_details {

    /// A builder for [`RuleGroupSourceStatefulRulesOptionsDetails`](crate::model::RuleGroupSourceStatefulRulesOptionsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) keyword: std::option::Option<std::string::String>,
        pub(crate) settings: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>A keyword to look for.</p>
        pub fn keyword(mut self, input: impl Into<std::string::String>) -> Self {
            self.keyword = Some(input.into());
            self
        }
        /// <p>A keyword to look for.</p>
        pub fn set_keyword(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.keyword = input;
            self
        }
        /// Appends an item to `settings`.
        ///
        /// To override the contents of this collection use [`set_settings`](Self::set_settings).
        ///
        /// <p>A list of settings.</p>
        pub fn settings(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.settings.unwrap_or_default();
            v.push(input.into());
            self.settings = Some(v);
            self
        }
        /// <p>A list of settings.</p>
        pub fn set_settings(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.settings = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleGroupSourceStatefulRulesOptionsDetails`](crate::model::RuleGroupSourceStatefulRulesOptionsDetails)
        pub fn build(self) -> crate::model::RuleGroupSourceStatefulRulesOptionsDetails {
            crate::model::RuleGroupSourceStatefulRulesOptionsDetails {
                keyword: self.keyword,
                settings: self.settings,
            }
        }
    }
}
impl RuleGroupSourceStatefulRulesOptionsDetails {
    /// Creates a new builder-style object to manufacture [`RuleGroupSourceStatefulRulesOptionsDetails`](crate::model::RuleGroupSourceStatefulRulesOptionsDetails)
    pub fn builder() -> crate::model::rule_group_source_stateful_rules_options_details::Builder {
        crate::model::rule_group_source_stateful_rules_options_details::Builder::default()
    }
}

/// <p>The inspection criteria for a stateful rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RuleGroupSourceStatefulRulesHeaderDetails {
    /// <p>The destination IP address or address range to inspect for, in CIDR notation. To match with any address, specify <code>ANY</code>.</p>
    pub destination: std::option::Option<std::string::String>,
    /// <p>The destination port to inspect for. You can specify an individual port, such as <code>1994</code>. You also can specify a port range, such as <code>1990:1994</code>. To match with any port, specify <code>ANY</code>.</p>
    pub destination_port: std::option::Option<std::string::String>,
    /// <p>The direction of traffic flow to inspect. If set to <code>ANY</code>, the inspection matches bidirectional traffic, both from the source to the destination and from the destination to the source. If set to <code>FORWARD</code>, the inspection only matches traffic going from the source to the destination.</p>
    pub direction: std::option::Option<std::string::String>,
    /// <p>The protocol to inspect for. To inspector for all protocols, use <code>IP</code>.</p>
    pub protocol: std::option::Option<std::string::String>,
    /// <p>The source IP address or address range to inspect for, in CIDR notation. To match with any address, specify <code>ANY</code>.</p>
    pub source: std::option::Option<std::string::String>,
    /// <p>The source port to inspect for. You can specify an individual port, such as <code>1994</code>. You also can specify a port range, such as <code>1990:1994</code>. To match with any port, specify <code>ANY</code>.</p>
    pub source_port: std::option::Option<std::string::String>,
}
impl RuleGroupSourceStatefulRulesHeaderDetails {
    /// <p>The destination IP address or address range to inspect for, in CIDR notation. To match with any address, specify <code>ANY</code>.</p>
    pub fn destination(&self) -> std::option::Option<&str> {
        self.destination.as_deref()
    }
    /// <p>The destination port to inspect for. You can specify an individual port, such as <code>1994</code>. You also can specify a port range, such as <code>1990:1994</code>. To match with any port, specify <code>ANY</code>.</p>
    pub fn destination_port(&self) -> std::option::Option<&str> {
        self.destination_port.as_deref()
    }
    /// <p>The direction of traffic flow to inspect. If set to <code>ANY</code>, the inspection matches bidirectional traffic, both from the source to the destination and from the destination to the source. If set to <code>FORWARD</code>, the inspection only matches traffic going from the source to the destination.</p>
    pub fn direction(&self) -> std::option::Option<&str> {
        self.direction.as_deref()
    }
    /// <p>The protocol to inspect for. To inspector for all protocols, use <code>IP</code>.</p>
    pub fn protocol(&self) -> std::option::Option<&str> {
        self.protocol.as_deref()
    }
    /// <p>The source IP address or address range to inspect for, in CIDR notation. To match with any address, specify <code>ANY</code>.</p>
    pub fn source(&self) -> std::option::Option<&str> {
        self.source.as_deref()
    }
    /// <p>The source port to inspect for. You can specify an individual port, such as <code>1994</code>. You also can specify a port range, such as <code>1990:1994</code>. To match with any port, specify <code>ANY</code>.</p>
    pub fn source_port(&self) -> std::option::Option<&str> {
        self.source_port.as_deref()
    }
}
impl std::fmt::Debug for RuleGroupSourceStatefulRulesHeaderDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RuleGroupSourceStatefulRulesHeaderDetails");
        formatter.field("destination", &self.destination);
        formatter.field("destination_port", &self.destination_port);
        formatter.field("direction", &self.direction);
        formatter.field("protocol", &self.protocol);
        formatter.field("source", &self.source);
        formatter.field("source_port", &self.source_port);
        formatter.finish()
    }
}
/// See [`RuleGroupSourceStatefulRulesHeaderDetails`](crate::model::RuleGroupSourceStatefulRulesHeaderDetails)
pub mod rule_group_source_stateful_rules_header_details {

    /// A builder for [`RuleGroupSourceStatefulRulesHeaderDetails`](crate::model::RuleGroupSourceStatefulRulesHeaderDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination: std::option::Option<std::string::String>,
        pub(crate) destination_port: std::option::Option<std::string::String>,
        pub(crate) direction: std::option::Option<std::string::String>,
        pub(crate) protocol: std::option::Option<std::string::String>,
        pub(crate) source: std::option::Option<std::string::String>,
        pub(crate) source_port: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The destination IP address or address range to inspect for, in CIDR notation. To match with any address, specify <code>ANY</code>.</p>
        pub fn destination(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination = Some(input.into());
            self
        }
        /// <p>The destination IP address or address range to inspect for, in CIDR notation. To match with any address, specify <code>ANY</code>.</p>
        pub fn set_destination(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.destination = input;
            self
        }
        /// <p>The destination port to inspect for. You can specify an individual port, such as <code>1994</code>. You also can specify a port range, such as <code>1990:1994</code>. To match with any port, specify <code>ANY</code>.</p>
        pub fn destination_port(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_port = Some(input.into());
            self
        }
        /// <p>The destination port to inspect for. You can specify an individual port, such as <code>1994</code>. You also can specify a port range, such as <code>1990:1994</code>. To match with any port, specify <code>ANY</code>.</p>
        pub fn set_destination_port(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_port = input;
            self
        }
        /// <p>The direction of traffic flow to inspect. If set to <code>ANY</code>, the inspection matches bidirectional traffic, both from the source to the destination and from the destination to the source. If set to <code>FORWARD</code>, the inspection only matches traffic going from the source to the destination.</p>
        pub fn direction(mut self, input: impl Into<std::string::String>) -> Self {
            self.direction = Some(input.into());
            self
        }
        /// <p>The direction of traffic flow to inspect. If set to <code>ANY</code>, the inspection matches bidirectional traffic, both from the source to the destination and from the destination to the source. If set to <code>FORWARD</code>, the inspection only matches traffic going from the source to the destination.</p>
        pub fn set_direction(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.direction = input;
            self
        }
        /// <p>The protocol to inspect for. To inspector for all protocols, use <code>IP</code>.</p>
        pub fn protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.protocol = Some(input.into());
            self
        }
        /// <p>The protocol to inspect for. To inspector for all protocols, use <code>IP</code>.</p>
        pub fn set_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.protocol = input;
            self
        }
        /// <p>The source IP address or address range to inspect for, in CIDR notation. To match with any address, specify <code>ANY</code>.</p>
        pub fn source(mut self, input: impl Into<std::string::String>) -> Self {
            self.source = Some(input.into());
            self
        }
        /// <p>The source IP address or address range to inspect for, in CIDR notation. To match with any address, specify <code>ANY</code>.</p>
        pub fn set_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source = input;
            self
        }
        /// <p>The source port to inspect for. You can specify an individual port, such as <code>1994</code>. You also can specify a port range, such as <code>1990:1994</code>. To match with any port, specify <code>ANY</code>.</p>
        pub fn source_port(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_port = Some(input.into());
            self
        }
        /// <p>The source port to inspect for. You can specify an individual port, such as <code>1994</code>. You also can specify a port range, such as <code>1990:1994</code>. To match with any port, specify <code>ANY</code>.</p>
        pub fn set_source_port(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_port = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleGroupSourceStatefulRulesHeaderDetails`](crate::model::RuleGroupSourceStatefulRulesHeaderDetails)
        pub fn build(self) -> crate::model::RuleGroupSourceStatefulRulesHeaderDetails {
            crate::model::RuleGroupSourceStatefulRulesHeaderDetails {
                destination: self.destination,
                destination_port: self.destination_port,
                direction: self.direction,
                protocol: self.protocol,
                source: self.source,
                source_port: self.source_port,
            }
        }
    }
}
impl RuleGroupSourceStatefulRulesHeaderDetails {
    /// Creates a new builder-style object to manufacture [`RuleGroupSourceStatefulRulesHeaderDetails`](crate::model::RuleGroupSourceStatefulRulesHeaderDetails)
    pub fn builder() -> crate::model::rule_group_source_stateful_rules_header_details::Builder {
        crate::model::rule_group_source_stateful_rules_header_details::Builder::default()
    }
}

/// <p>Stateful inspection criteria for a domain list rule group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RuleGroupSourceListDetails {
    /// <p>Indicates whether to allow or deny access to the domains listed in <code>Targets</code>.</p>
    pub generated_rules_type: std::option::Option<std::string::String>,
    /// <p>The protocols that you want to inspect. Specify <code>LS_SNI</code> for HTTPS. Specify <code>HTTP_HOST</code> for HTTP. You can specify either or both.</p>
    pub target_types: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The domains that you want to inspect for in your traffic flows. You can provide full domain names, or use the '.' prefix as a wildcard. For example, <code>.example.com</code> matches all domains that end with <code>example.com</code>.</p>
    pub targets: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl RuleGroupSourceListDetails {
    /// <p>Indicates whether to allow or deny access to the domains listed in <code>Targets</code>.</p>
    pub fn generated_rules_type(&self) -> std::option::Option<&str> {
        self.generated_rules_type.as_deref()
    }
    /// <p>The protocols that you want to inspect. Specify <code>LS_SNI</code> for HTTPS. Specify <code>HTTP_HOST</code> for HTTP. You can specify either or both.</p>
    pub fn target_types(&self) -> std::option::Option<&[std::string::String]> {
        self.target_types.as_deref()
    }
    /// <p>The domains that you want to inspect for in your traffic flows. You can provide full domain names, or use the '.' prefix as a wildcard. For example, <code>.example.com</code> matches all domains that end with <code>example.com</code>.</p>
    pub fn targets(&self) -> std::option::Option<&[std::string::String]> {
        self.targets.as_deref()
    }
}
impl std::fmt::Debug for RuleGroupSourceListDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RuleGroupSourceListDetails");
        formatter.field("generated_rules_type", &self.generated_rules_type);
        formatter.field("target_types", &self.target_types);
        formatter.field("targets", &self.targets);
        formatter.finish()
    }
}
/// See [`RuleGroupSourceListDetails`](crate::model::RuleGroupSourceListDetails)
pub mod rule_group_source_list_details {

    /// A builder for [`RuleGroupSourceListDetails`](crate::model::RuleGroupSourceListDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) generated_rules_type: std::option::Option<std::string::String>,
        pub(crate) target_types: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) targets: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>Indicates whether to allow or deny access to the domains listed in <code>Targets</code>.</p>
        pub fn generated_rules_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.generated_rules_type = Some(input.into());
            self
        }
        /// <p>Indicates whether to allow or deny access to the domains listed in <code>Targets</code>.</p>
        pub fn set_generated_rules_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.generated_rules_type = input;
            self
        }
        /// Appends an item to `target_types`.
        ///
        /// To override the contents of this collection use [`set_target_types`](Self::set_target_types).
        ///
        /// <p>The protocols that you want to inspect. Specify <code>LS_SNI</code> for HTTPS. Specify <code>HTTP_HOST</code> for HTTP. You can specify either or both.</p>
        pub fn target_types(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.target_types.unwrap_or_default();
            v.push(input.into());
            self.target_types = Some(v);
            self
        }
        /// <p>The protocols that you want to inspect. Specify <code>LS_SNI</code> for HTTPS. Specify <code>HTTP_HOST</code> for HTTP. You can specify either or both.</p>
        pub fn set_target_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.target_types = input;
            self
        }
        /// Appends an item to `targets`.
        ///
        /// To override the contents of this collection use [`set_targets`](Self::set_targets).
        ///
        /// <p>The domains that you want to inspect for in your traffic flows. You can provide full domain names, or use the '.' prefix as a wildcard. For example, <code>.example.com</code> matches all domains that end with <code>example.com</code>.</p>
        pub fn targets(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.targets.unwrap_or_default();
            v.push(input.into());
            self.targets = Some(v);
            self
        }
        /// <p>The domains that you want to inspect for in your traffic flows. You can provide full domain names, or use the '.' prefix as a wildcard. For example, <code>.example.com</code> matches all domains that end with <code>example.com</code>.</p>
        pub fn set_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.targets = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleGroupSourceListDetails`](crate::model::RuleGroupSourceListDetails)
        pub fn build(self) -> crate::model::RuleGroupSourceListDetails {
            crate::model::RuleGroupSourceListDetails {
                generated_rules_type: self.generated_rules_type,
                target_types: self.target_types,
                targets: self.targets,
            }
        }
    }
}
impl RuleGroupSourceListDetails {
    /// Creates a new builder-style object to manufacture [`RuleGroupSourceListDetails`](crate::model::RuleGroupSourceListDetails)
    pub fn builder() -> crate::model::rule_group_source_list_details::Builder {
        crate::model::rule_group_source_list_details::Builder::default()
    }
}

/// <p>Additional settings to use in the specified rules.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RuleGroupVariables {
    /// <p>A list of IP addresses and address ranges, in CIDR notation.</p>
    pub ip_sets: std::option::Option<crate::model::RuleGroupVariablesIpSetsDetails>,
    /// <p>A list of port ranges.</p>
    pub port_sets: std::option::Option<crate::model::RuleGroupVariablesPortSetsDetails>,
}
impl RuleGroupVariables {
    /// <p>A list of IP addresses and address ranges, in CIDR notation.</p>
    pub fn ip_sets(&self) -> std::option::Option<&crate::model::RuleGroupVariablesIpSetsDetails> {
        self.ip_sets.as_ref()
    }
    /// <p>A list of port ranges.</p>
    pub fn port_sets(
        &self,
    ) -> std::option::Option<&crate::model::RuleGroupVariablesPortSetsDetails> {
        self.port_sets.as_ref()
    }
}
impl std::fmt::Debug for RuleGroupVariables {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RuleGroupVariables");
        formatter.field("ip_sets", &self.ip_sets);
        formatter.field("port_sets", &self.port_sets);
        formatter.finish()
    }
}
/// See [`RuleGroupVariables`](crate::model::RuleGroupVariables)
pub mod rule_group_variables {

    /// A builder for [`RuleGroupVariables`](crate::model::RuleGroupVariables)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ip_sets: std::option::Option<crate::model::RuleGroupVariablesIpSetsDetails>,
        pub(crate) port_sets: std::option::Option<crate::model::RuleGroupVariablesPortSetsDetails>,
    }
    impl Builder {
        /// <p>A list of IP addresses and address ranges, in CIDR notation.</p>
        pub fn ip_sets(mut self, input: crate::model::RuleGroupVariablesIpSetsDetails) -> Self {
            self.ip_sets = Some(input);
            self
        }
        /// <p>A list of IP addresses and address ranges, in CIDR notation.</p>
        pub fn set_ip_sets(
            mut self,
            input: std::option::Option<crate::model::RuleGroupVariablesIpSetsDetails>,
        ) -> Self {
            self.ip_sets = input;
            self
        }
        /// <p>A list of port ranges.</p>
        pub fn port_sets(mut self, input: crate::model::RuleGroupVariablesPortSetsDetails) -> Self {
            self.port_sets = Some(input);
            self
        }
        /// <p>A list of port ranges.</p>
        pub fn set_port_sets(
            mut self,
            input: std::option::Option<crate::model::RuleGroupVariablesPortSetsDetails>,
        ) -> Self {
            self.port_sets = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleGroupVariables`](crate::model::RuleGroupVariables)
        pub fn build(self) -> crate::model::RuleGroupVariables {
            crate::model::RuleGroupVariables {
                ip_sets: self.ip_sets,
                port_sets: self.port_sets,
            }
        }
    }
}
impl RuleGroupVariables {
    /// Creates a new builder-style object to manufacture [`RuleGroupVariables`](crate::model::RuleGroupVariables)
    pub fn builder() -> crate::model::rule_group_variables::Builder {
        crate::model::rule_group_variables::Builder::default()
    }
}

/// <p>A list of port ranges.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RuleGroupVariablesPortSetsDetails {
    /// <p>The list of port ranges.</p>
    pub definition: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl RuleGroupVariablesPortSetsDetails {
    /// <p>The list of port ranges.</p>
    pub fn definition(&self) -> std::option::Option<&[std::string::String]> {
        self.definition.as_deref()
    }
}
impl std::fmt::Debug for RuleGroupVariablesPortSetsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RuleGroupVariablesPortSetsDetails");
        formatter.field("definition", &self.definition);
        formatter.finish()
    }
}
/// See [`RuleGroupVariablesPortSetsDetails`](crate::model::RuleGroupVariablesPortSetsDetails)
pub mod rule_group_variables_port_sets_details {

    /// A builder for [`RuleGroupVariablesPortSetsDetails`](crate::model::RuleGroupVariablesPortSetsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) definition: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `definition`.
        ///
        /// To override the contents of this collection use [`set_definition`](Self::set_definition).
        ///
        /// <p>The list of port ranges.</p>
        pub fn definition(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.definition.unwrap_or_default();
            v.push(input.into());
            self.definition = Some(v);
            self
        }
        /// <p>The list of port ranges.</p>
        pub fn set_definition(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.definition = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleGroupVariablesPortSetsDetails`](crate::model::RuleGroupVariablesPortSetsDetails)
        pub fn build(self) -> crate::model::RuleGroupVariablesPortSetsDetails {
            crate::model::RuleGroupVariablesPortSetsDetails {
                definition: self.definition,
            }
        }
    }
}
impl RuleGroupVariablesPortSetsDetails {
    /// Creates a new builder-style object to manufacture [`RuleGroupVariablesPortSetsDetails`](crate::model::RuleGroupVariablesPortSetsDetails)
    pub fn builder() -> crate::model::rule_group_variables_port_sets_details::Builder {
        crate::model::rule_group_variables_port_sets_details::Builder::default()
    }
}

/// <p>A list of IP addresses and address ranges, in CIDR notation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RuleGroupVariablesIpSetsDetails {
    /// <p>The list of IP addresses and ranges.</p>
    pub definition: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl RuleGroupVariablesIpSetsDetails {
    /// <p>The list of IP addresses and ranges.</p>
    pub fn definition(&self) -> std::option::Option<&[std::string::String]> {
        self.definition.as_deref()
    }
}
impl std::fmt::Debug for RuleGroupVariablesIpSetsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RuleGroupVariablesIpSetsDetails");
        formatter.field("definition", &self.definition);
        formatter.finish()
    }
}
/// See [`RuleGroupVariablesIpSetsDetails`](crate::model::RuleGroupVariablesIpSetsDetails)
pub mod rule_group_variables_ip_sets_details {

    /// A builder for [`RuleGroupVariablesIpSetsDetails`](crate::model::RuleGroupVariablesIpSetsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) definition: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `definition`.
        ///
        /// To override the contents of this collection use [`set_definition`](Self::set_definition).
        ///
        /// <p>The list of IP addresses and ranges.</p>
        pub fn definition(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.definition.unwrap_or_default();
            v.push(input.into());
            self.definition = Some(v);
            self
        }
        /// <p>The list of IP addresses and ranges.</p>
        pub fn set_definition(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.definition = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleGroupVariablesIpSetsDetails`](crate::model::RuleGroupVariablesIpSetsDetails)
        pub fn build(self) -> crate::model::RuleGroupVariablesIpSetsDetails {
            crate::model::RuleGroupVariablesIpSetsDetails {
                definition: self.definition,
            }
        }
    }
}
impl RuleGroupVariablesIpSetsDetails {
    /// Creates a new builder-style object to manufacture [`RuleGroupVariablesIpSetsDetails`](crate::model::RuleGroupVariablesIpSetsDetails)
    pub fn builder() -> crate::model::rule_group_variables_ip_sets_details::Builder {
        crate::model::rule_group_variables_ip_sets_details::Builder::default()
    }
}

/// <p>Details about an Network Firewall firewall.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsNetworkFirewallFirewallDetails {
    /// <p>Whether the firewall is protected from deletion. If set to <code>true</code>, then the firewall cannot be deleted.</p>
    pub delete_protection: bool,
    /// <p>A description of the firewall.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The ARN of the firewall.</p>
    pub firewall_arn: std::option::Option<std::string::String>,
    /// <p>The identifier of the firewall.</p>
    pub firewall_id: std::option::Option<std::string::String>,
    /// <p>A descriptive name of the firewall.</p>
    pub firewall_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the firewall policy.</p>
    pub firewall_policy_arn: std::option::Option<std::string::String>,
    /// <p>Whether the firewall is protected from a change to the firewall policy. If set to <code>true</code>, you cannot associate a different policy with the firewall.</p>
    pub firewall_policy_change_protection: bool,
    /// <p>Whether the firewall is protected from a change to the subnet associations. If set to <code>true</code>, you cannot map different subnets to the firewall.</p>
    pub subnet_change_protection: bool,
    /// <p>The public subnets that Network Firewall uses for the firewall. Each subnet must belong to a different Availability Zone.</p>
    pub subnet_mappings: std::option::Option<
        std::vec::Vec<crate::model::AwsNetworkFirewallFirewallSubnetMappingsDetails>,
    >,
    /// <p>The identifier of the VPC where the firewall is used.</p>
    pub vpc_id: std::option::Option<std::string::String>,
}
impl AwsNetworkFirewallFirewallDetails {
    /// <p>Whether the firewall is protected from deletion. If set to <code>true</code>, then the firewall cannot be deleted.</p>
    pub fn delete_protection(&self) -> bool {
        self.delete_protection
    }
    /// <p>A description of the firewall.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The ARN of the firewall.</p>
    pub fn firewall_arn(&self) -> std::option::Option<&str> {
        self.firewall_arn.as_deref()
    }
    /// <p>The identifier of the firewall.</p>
    pub fn firewall_id(&self) -> std::option::Option<&str> {
        self.firewall_id.as_deref()
    }
    /// <p>A descriptive name of the firewall.</p>
    pub fn firewall_name(&self) -> std::option::Option<&str> {
        self.firewall_name.as_deref()
    }
    /// <p>The ARN of the firewall policy.</p>
    pub fn firewall_policy_arn(&self) -> std::option::Option<&str> {
        self.firewall_policy_arn.as_deref()
    }
    /// <p>Whether the firewall is protected from a change to the firewall policy. If set to <code>true</code>, you cannot associate a different policy with the firewall.</p>
    pub fn firewall_policy_change_protection(&self) -> bool {
        self.firewall_policy_change_protection
    }
    /// <p>Whether the firewall is protected from a change to the subnet associations. If set to <code>true</code>, you cannot map different subnets to the firewall.</p>
    pub fn subnet_change_protection(&self) -> bool {
        self.subnet_change_protection
    }
    /// <p>The public subnets that Network Firewall uses for the firewall. Each subnet must belong to a different Availability Zone.</p>
    pub fn subnet_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::AwsNetworkFirewallFirewallSubnetMappingsDetails]> {
        self.subnet_mappings.as_deref()
    }
    /// <p>The identifier of the VPC where the firewall is used.</p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
}
impl std::fmt::Debug for AwsNetworkFirewallFirewallDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsNetworkFirewallFirewallDetails");
        formatter.field("delete_protection", &self.delete_protection);
        formatter.field("description", &self.description);
        formatter.field("firewall_arn", &self.firewall_arn);
        formatter.field("firewall_id", &self.firewall_id);
        formatter.field("firewall_name", &self.firewall_name);
        formatter.field("firewall_policy_arn", &self.firewall_policy_arn);
        formatter.field(
            "firewall_policy_change_protection",
            &self.firewall_policy_change_protection,
        );
        formatter.field("subnet_change_protection", &self.subnet_change_protection);
        formatter.field("subnet_mappings", &self.subnet_mappings);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.finish()
    }
}
/// See [`AwsNetworkFirewallFirewallDetails`](crate::model::AwsNetworkFirewallFirewallDetails)
pub mod aws_network_firewall_firewall_details {

    /// A builder for [`AwsNetworkFirewallFirewallDetails`](crate::model::AwsNetworkFirewallFirewallDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) delete_protection: std::option::Option<bool>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) firewall_arn: std::option::Option<std::string::String>,
        pub(crate) firewall_id: std::option::Option<std::string::String>,
        pub(crate) firewall_name: std::option::Option<std::string::String>,
        pub(crate) firewall_policy_arn: std::option::Option<std::string::String>,
        pub(crate) firewall_policy_change_protection: std::option::Option<bool>,
        pub(crate) subnet_change_protection: std::option::Option<bool>,
        pub(crate) subnet_mappings: std::option::Option<
            std::vec::Vec<crate::model::AwsNetworkFirewallFirewallSubnetMappingsDetails>,
        >,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Whether the firewall is protected from deletion. If set to <code>true</code>, then the firewall cannot be deleted.</p>
        pub fn delete_protection(mut self, input: bool) -> Self {
            self.delete_protection = Some(input);
            self
        }
        /// <p>Whether the firewall is protected from deletion. If set to <code>true</code>, then the firewall cannot be deleted.</p>
        pub fn set_delete_protection(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_protection = input;
            self
        }
        /// <p>A description of the firewall.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the firewall.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The ARN of the firewall.</p>
        pub fn firewall_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the firewall.</p>
        pub fn set_firewall_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.firewall_arn = input;
            self
        }
        /// <p>The identifier of the firewall.</p>
        pub fn firewall_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_id = Some(input.into());
            self
        }
        /// <p>The identifier of the firewall.</p>
        pub fn set_firewall_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.firewall_id = input;
            self
        }
        /// <p>A descriptive name of the firewall.</p>
        pub fn firewall_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_name = Some(input.into());
            self
        }
        /// <p>A descriptive name of the firewall.</p>
        pub fn set_firewall_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.firewall_name = input;
            self
        }
        /// <p>The ARN of the firewall policy.</p>
        pub fn firewall_policy_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_policy_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the firewall policy.</p>
        pub fn set_firewall_policy_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.firewall_policy_arn = input;
            self
        }
        /// <p>Whether the firewall is protected from a change to the firewall policy. If set to <code>true</code>, you cannot associate a different policy with the firewall.</p>
        pub fn firewall_policy_change_protection(mut self, input: bool) -> Self {
            self.firewall_policy_change_protection = Some(input);
            self
        }
        /// <p>Whether the firewall is protected from a change to the firewall policy. If set to <code>true</code>, you cannot associate a different policy with the firewall.</p>
        pub fn set_firewall_policy_change_protection(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.firewall_policy_change_protection = input;
            self
        }
        /// <p>Whether the firewall is protected from a change to the subnet associations. If set to <code>true</code>, you cannot map different subnets to the firewall.</p>
        pub fn subnet_change_protection(mut self, input: bool) -> Self {
            self.subnet_change_protection = Some(input);
            self
        }
        /// <p>Whether the firewall is protected from a change to the subnet associations. If set to <code>true</code>, you cannot map different subnets to the firewall.</p>
        pub fn set_subnet_change_protection(mut self, input: std::option::Option<bool>) -> Self {
            self.subnet_change_protection = input;
            self
        }
        /// Appends an item to `subnet_mappings`.
        ///
        /// To override the contents of this collection use [`set_subnet_mappings`](Self::set_subnet_mappings).
        ///
        /// <p>The public subnets that Network Firewall uses for the firewall. Each subnet must belong to a different Availability Zone.</p>
        pub fn subnet_mappings(
            mut self,
            input: crate::model::AwsNetworkFirewallFirewallSubnetMappingsDetails,
        ) -> Self {
            let mut v = self.subnet_mappings.unwrap_or_default();
            v.push(input);
            self.subnet_mappings = Some(v);
            self
        }
        /// <p>The public subnets that Network Firewall uses for the firewall. Each subnet must belong to a different Availability Zone.</p>
        pub fn set_subnet_mappings(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsNetworkFirewallFirewallSubnetMappingsDetails>,
            >,
        ) -> Self {
            self.subnet_mappings = input;
            self
        }
        /// <p>The identifier of the VPC where the firewall is used.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The identifier of the VPC where the firewall is used.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsNetworkFirewallFirewallDetails`](crate::model::AwsNetworkFirewallFirewallDetails)
        pub fn build(self) -> crate::model::AwsNetworkFirewallFirewallDetails {
            crate::model::AwsNetworkFirewallFirewallDetails {
                delete_protection: self.delete_protection.unwrap_or_default(),
                description: self.description,
                firewall_arn: self.firewall_arn,
                firewall_id: self.firewall_id,
                firewall_name: self.firewall_name,
                firewall_policy_arn: self.firewall_policy_arn,
                firewall_policy_change_protection: self
                    .firewall_policy_change_protection
                    .unwrap_or_default(),
                subnet_change_protection: self.subnet_change_protection.unwrap_or_default(),
                subnet_mappings: self.subnet_mappings,
                vpc_id: self.vpc_id,
            }
        }
    }
}
impl AwsNetworkFirewallFirewallDetails {
    /// Creates a new builder-style object to manufacture [`AwsNetworkFirewallFirewallDetails`](crate::model::AwsNetworkFirewallFirewallDetails)
    pub fn builder() -> crate::model::aws_network_firewall_firewall_details::Builder {
        crate::model::aws_network_firewall_firewall_details::Builder::default()
    }
}

/// <p>A public subnet that Network Firewall uses for the firewall.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsNetworkFirewallFirewallSubnetMappingsDetails {
    /// <p>The identifier of the subnet</p>
    pub subnet_id: std::option::Option<std::string::String>,
}
impl AwsNetworkFirewallFirewallSubnetMappingsDetails {
    /// <p>The identifier of the subnet</p>
    pub fn subnet_id(&self) -> std::option::Option<&str> {
        self.subnet_id.as_deref()
    }
}
impl std::fmt::Debug for AwsNetworkFirewallFirewallSubnetMappingsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsNetworkFirewallFirewallSubnetMappingsDetails");
        formatter.field("subnet_id", &self.subnet_id);
        formatter.finish()
    }
}
/// See [`AwsNetworkFirewallFirewallSubnetMappingsDetails`](crate::model::AwsNetworkFirewallFirewallSubnetMappingsDetails)
pub mod aws_network_firewall_firewall_subnet_mappings_details {

    /// A builder for [`AwsNetworkFirewallFirewallSubnetMappingsDetails`](crate::model::AwsNetworkFirewallFirewallSubnetMappingsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subnet_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the subnet</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        /// <p>The identifier of the subnet</p>
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsNetworkFirewallFirewallSubnetMappingsDetails`](crate::model::AwsNetworkFirewallFirewallSubnetMappingsDetails)
        pub fn build(self) -> crate::model::AwsNetworkFirewallFirewallSubnetMappingsDetails {
            crate::model::AwsNetworkFirewallFirewallSubnetMappingsDetails {
                subnet_id: self.subnet_id,
            }
        }
    }
}
impl AwsNetworkFirewallFirewallSubnetMappingsDetails {
    /// Creates a new builder-style object to manufacture [`AwsNetworkFirewallFirewallSubnetMappingsDetails`](crate::model::AwsNetworkFirewallFirewallSubnetMappingsDetails)
    pub fn builder() -> crate::model::aws_network_firewall_firewall_subnet_mappings_details::Builder
    {
        crate::model::aws_network_firewall_firewall_subnet_mappings_details::Builder::default()
    }
}

/// <p>Details about a firewall policy. A firewall policy defines the behavior of a network firewall.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsNetworkFirewallFirewallPolicyDetails {
    /// <p>The firewall policy configuration.</p>
    pub firewall_policy: std::option::Option<crate::model::FirewallPolicyDetails>,
    /// <p>The ARN of the firewall policy.</p>
    pub firewall_policy_arn: std::option::Option<std::string::String>,
    /// <p>The identifier of the firewall policy.</p>
    pub firewall_policy_id: std::option::Option<std::string::String>,
    /// <p>The name of the firewall policy.</p>
    pub firewall_policy_name: std::option::Option<std::string::String>,
    /// <p>A description of the firewall policy.</p>
    pub description: std::option::Option<std::string::String>,
}
impl AwsNetworkFirewallFirewallPolicyDetails {
    /// <p>The firewall policy configuration.</p>
    pub fn firewall_policy(&self) -> std::option::Option<&crate::model::FirewallPolicyDetails> {
        self.firewall_policy.as_ref()
    }
    /// <p>The ARN of the firewall policy.</p>
    pub fn firewall_policy_arn(&self) -> std::option::Option<&str> {
        self.firewall_policy_arn.as_deref()
    }
    /// <p>The identifier of the firewall policy.</p>
    pub fn firewall_policy_id(&self) -> std::option::Option<&str> {
        self.firewall_policy_id.as_deref()
    }
    /// <p>The name of the firewall policy.</p>
    pub fn firewall_policy_name(&self) -> std::option::Option<&str> {
        self.firewall_policy_name.as_deref()
    }
    /// <p>A description of the firewall policy.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
impl std::fmt::Debug for AwsNetworkFirewallFirewallPolicyDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsNetworkFirewallFirewallPolicyDetails");
        formatter.field("firewall_policy", &self.firewall_policy);
        formatter.field("firewall_policy_arn", &self.firewall_policy_arn);
        formatter.field("firewall_policy_id", &self.firewall_policy_id);
        formatter.field("firewall_policy_name", &self.firewall_policy_name);
        formatter.field("description", &self.description);
        formatter.finish()
    }
}
/// See [`AwsNetworkFirewallFirewallPolicyDetails`](crate::model::AwsNetworkFirewallFirewallPolicyDetails)
pub mod aws_network_firewall_firewall_policy_details {

    /// A builder for [`AwsNetworkFirewallFirewallPolicyDetails`](crate::model::AwsNetworkFirewallFirewallPolicyDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) firewall_policy: std::option::Option<crate::model::FirewallPolicyDetails>,
        pub(crate) firewall_policy_arn: std::option::Option<std::string::String>,
        pub(crate) firewall_policy_id: std::option::Option<std::string::String>,
        pub(crate) firewall_policy_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The firewall policy configuration.</p>
        pub fn firewall_policy(mut self, input: crate::model::FirewallPolicyDetails) -> Self {
            self.firewall_policy = Some(input);
            self
        }
        /// <p>The firewall policy configuration.</p>
        pub fn set_firewall_policy(
            mut self,
            input: std::option::Option<crate::model::FirewallPolicyDetails>,
        ) -> Self {
            self.firewall_policy = input;
            self
        }
        /// <p>The ARN of the firewall policy.</p>
        pub fn firewall_policy_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_policy_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the firewall policy.</p>
        pub fn set_firewall_policy_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.firewall_policy_arn = input;
            self
        }
        /// <p>The identifier of the firewall policy.</p>
        pub fn firewall_policy_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_policy_id = Some(input.into());
            self
        }
        /// <p>The identifier of the firewall policy.</p>
        pub fn set_firewall_policy_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.firewall_policy_id = input;
            self
        }
        /// <p>The name of the firewall policy.</p>
        pub fn firewall_policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_policy_name = Some(input.into());
            self
        }
        /// <p>The name of the firewall policy.</p>
        pub fn set_firewall_policy_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.firewall_policy_name = input;
            self
        }
        /// <p>A description of the firewall policy.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the firewall policy.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsNetworkFirewallFirewallPolicyDetails`](crate::model::AwsNetworkFirewallFirewallPolicyDetails)
        pub fn build(self) -> crate::model::AwsNetworkFirewallFirewallPolicyDetails {
            crate::model::AwsNetworkFirewallFirewallPolicyDetails {
                firewall_policy: self.firewall_policy,
                firewall_policy_arn: self.firewall_policy_arn,
                firewall_policy_id: self.firewall_policy_id,
                firewall_policy_name: self.firewall_policy_name,
                description: self.description,
            }
        }
    }
}
impl AwsNetworkFirewallFirewallPolicyDetails {
    /// Creates a new builder-style object to manufacture [`AwsNetworkFirewallFirewallPolicyDetails`](crate::model::AwsNetworkFirewallFirewallPolicyDetails)
    pub fn builder() -> crate::model::aws_network_firewall_firewall_policy_details::Builder {
        crate::model::aws_network_firewall_firewall_policy_details::Builder::default()
    }
}

/// <p>Defines the behavior of the firewall.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FirewallPolicyDetails {
    /// <p>The stateful rule groups that are used in the firewall policy.</p>
    pub stateful_rule_group_references: std::option::Option<
        std::vec::Vec<crate::model::FirewallPolicyStatefulRuleGroupReferencesDetails>,
    >,
    /// <p>The custom action definitions that are available to use in the firewall policy's <code>StatelessDefaultActions</code> setting.</p>
    pub stateless_custom_actions: std::option::Option<
        std::vec::Vec<crate::model::FirewallPolicyStatelessCustomActionsDetails>,
    >,
    /// <p>The actions to take on a packet if it doesn't match any of the stateless rules in the policy.</p>
    /// <p>You must specify a standard action (<code>aws:pass</code>, <code>aws:drop</code>, <code>aws:forward_to_sfe</code>), and can optionally include a custom action from <code>StatelessCustomActions</code>. </p>
    pub stateless_default_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The actions to take on a fragmented UDP packet if it doesn't match any of the stateless rules in the policy.</p>
    /// <p>You must specify a standard action (<code>aws:pass</code>, <code>aws:drop</code>, <code>aws:forward_to_sfe</code>), and can optionally include a custom action from <code>StatelessCustomActions</code>. </p>
    pub stateless_fragment_default_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The stateless rule groups that are used in the firewall policy.</p>
    pub stateless_rule_group_references: std::option::Option<
        std::vec::Vec<crate::model::FirewallPolicyStatelessRuleGroupReferencesDetails>,
    >,
}
impl FirewallPolicyDetails {
    /// <p>The stateful rule groups that are used in the firewall policy.</p>
    pub fn stateful_rule_group_references(
        &self,
    ) -> std::option::Option<&[crate::model::FirewallPolicyStatefulRuleGroupReferencesDetails]>
    {
        self.stateful_rule_group_references.as_deref()
    }
    /// <p>The custom action definitions that are available to use in the firewall policy's <code>StatelessDefaultActions</code> setting.</p>
    pub fn stateless_custom_actions(
        &self,
    ) -> std::option::Option<&[crate::model::FirewallPolicyStatelessCustomActionsDetails]> {
        self.stateless_custom_actions.as_deref()
    }
    /// <p>The actions to take on a packet if it doesn't match any of the stateless rules in the policy.</p>
    /// <p>You must specify a standard action (<code>aws:pass</code>, <code>aws:drop</code>, <code>aws:forward_to_sfe</code>), and can optionally include a custom action from <code>StatelessCustomActions</code>. </p>
    pub fn stateless_default_actions(&self) -> std::option::Option<&[std::string::String]> {
        self.stateless_default_actions.as_deref()
    }
    /// <p>The actions to take on a fragmented UDP packet if it doesn't match any of the stateless rules in the policy.</p>
    /// <p>You must specify a standard action (<code>aws:pass</code>, <code>aws:drop</code>, <code>aws:forward_to_sfe</code>), and can optionally include a custom action from <code>StatelessCustomActions</code>. </p>
    pub fn stateless_fragment_default_actions(
        &self,
    ) -> std::option::Option<&[std::string::String]> {
        self.stateless_fragment_default_actions.as_deref()
    }
    /// <p>The stateless rule groups that are used in the firewall policy.</p>
    pub fn stateless_rule_group_references(
        &self,
    ) -> std::option::Option<&[crate::model::FirewallPolicyStatelessRuleGroupReferencesDetails]>
    {
        self.stateless_rule_group_references.as_deref()
    }
}
impl std::fmt::Debug for FirewallPolicyDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FirewallPolicyDetails");
        formatter.field(
            "stateful_rule_group_references",
            &self.stateful_rule_group_references,
        );
        formatter.field("stateless_custom_actions", &self.stateless_custom_actions);
        formatter.field("stateless_default_actions", &self.stateless_default_actions);
        formatter.field(
            "stateless_fragment_default_actions",
            &self.stateless_fragment_default_actions,
        );
        formatter.field(
            "stateless_rule_group_references",
            &self.stateless_rule_group_references,
        );
        formatter.finish()
    }
}
/// See [`FirewallPolicyDetails`](crate::model::FirewallPolicyDetails)
pub mod firewall_policy_details {

    /// A builder for [`FirewallPolicyDetails`](crate::model::FirewallPolicyDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stateful_rule_group_references: std::option::Option<
            std::vec::Vec<crate::model::FirewallPolicyStatefulRuleGroupReferencesDetails>,
        >,
        pub(crate) stateless_custom_actions: std::option::Option<
            std::vec::Vec<crate::model::FirewallPolicyStatelessCustomActionsDetails>,
        >,
        pub(crate) stateless_default_actions:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) stateless_fragment_default_actions:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) stateless_rule_group_references: std::option::Option<
            std::vec::Vec<crate::model::FirewallPolicyStatelessRuleGroupReferencesDetails>,
        >,
    }
    impl Builder {
        /// Appends an item to `stateful_rule_group_references`.
        ///
        /// To override the contents of this collection use [`set_stateful_rule_group_references`](Self::set_stateful_rule_group_references).
        ///
        /// <p>The stateful rule groups that are used in the firewall policy.</p>
        pub fn stateful_rule_group_references(
            mut self,
            input: crate::model::FirewallPolicyStatefulRuleGroupReferencesDetails,
        ) -> Self {
            let mut v = self.stateful_rule_group_references.unwrap_or_default();
            v.push(input);
            self.stateful_rule_group_references = Some(v);
            self
        }
        /// <p>The stateful rule groups that are used in the firewall policy.</p>
        pub fn set_stateful_rule_group_references(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::FirewallPolicyStatefulRuleGroupReferencesDetails>,
            >,
        ) -> Self {
            self.stateful_rule_group_references = input;
            self
        }
        /// Appends an item to `stateless_custom_actions`.
        ///
        /// To override the contents of this collection use [`set_stateless_custom_actions`](Self::set_stateless_custom_actions).
        ///
        /// <p>The custom action definitions that are available to use in the firewall policy's <code>StatelessDefaultActions</code> setting.</p>
        pub fn stateless_custom_actions(
            mut self,
            input: crate::model::FirewallPolicyStatelessCustomActionsDetails,
        ) -> Self {
            let mut v = self.stateless_custom_actions.unwrap_or_default();
            v.push(input);
            self.stateless_custom_actions = Some(v);
            self
        }
        /// <p>The custom action definitions that are available to use in the firewall policy's <code>StatelessDefaultActions</code> setting.</p>
        pub fn set_stateless_custom_actions(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::FirewallPolicyStatelessCustomActionsDetails>,
            >,
        ) -> Self {
            self.stateless_custom_actions = input;
            self
        }
        /// Appends an item to `stateless_default_actions`.
        ///
        /// To override the contents of this collection use [`set_stateless_default_actions`](Self::set_stateless_default_actions).
        ///
        /// <p>The actions to take on a packet if it doesn't match any of the stateless rules in the policy.</p>
        /// <p>You must specify a standard action (<code>aws:pass</code>, <code>aws:drop</code>, <code>aws:forward_to_sfe</code>), and can optionally include a custom action from <code>StatelessCustomActions</code>. </p>
        pub fn stateless_default_actions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.stateless_default_actions.unwrap_or_default();
            v.push(input.into());
            self.stateless_default_actions = Some(v);
            self
        }
        /// <p>The actions to take on a packet if it doesn't match any of the stateless rules in the policy.</p>
        /// <p>You must specify a standard action (<code>aws:pass</code>, <code>aws:drop</code>, <code>aws:forward_to_sfe</code>), and can optionally include a custom action from <code>StatelessCustomActions</code>. </p>
        pub fn set_stateless_default_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.stateless_default_actions = input;
            self
        }
        /// Appends an item to `stateless_fragment_default_actions`.
        ///
        /// To override the contents of this collection use [`set_stateless_fragment_default_actions`](Self::set_stateless_fragment_default_actions).
        ///
        /// <p>The actions to take on a fragmented UDP packet if it doesn't match any of the stateless rules in the policy.</p>
        /// <p>You must specify a standard action (<code>aws:pass</code>, <code>aws:drop</code>, <code>aws:forward_to_sfe</code>), and can optionally include a custom action from <code>StatelessCustomActions</code>. </p>
        pub fn stateless_fragment_default_actions(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.stateless_fragment_default_actions.unwrap_or_default();
            v.push(input.into());
            self.stateless_fragment_default_actions = Some(v);
            self
        }
        /// <p>The actions to take on a fragmented UDP packet if it doesn't match any of the stateless rules in the policy.</p>
        /// <p>You must specify a standard action (<code>aws:pass</code>, <code>aws:drop</code>, <code>aws:forward_to_sfe</code>), and can optionally include a custom action from <code>StatelessCustomActions</code>. </p>
        pub fn set_stateless_fragment_default_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.stateless_fragment_default_actions = input;
            self
        }
        /// Appends an item to `stateless_rule_group_references`.
        ///
        /// To override the contents of this collection use [`set_stateless_rule_group_references`](Self::set_stateless_rule_group_references).
        ///
        /// <p>The stateless rule groups that are used in the firewall policy.</p>
        pub fn stateless_rule_group_references(
            mut self,
            input: crate::model::FirewallPolicyStatelessRuleGroupReferencesDetails,
        ) -> Self {
            let mut v = self.stateless_rule_group_references.unwrap_or_default();
            v.push(input);
            self.stateless_rule_group_references = Some(v);
            self
        }
        /// <p>The stateless rule groups that are used in the firewall policy.</p>
        pub fn set_stateless_rule_group_references(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::FirewallPolicyStatelessRuleGroupReferencesDetails>,
            >,
        ) -> Self {
            self.stateless_rule_group_references = input;
            self
        }
        /// Consumes the builder and constructs a [`FirewallPolicyDetails`](crate::model::FirewallPolicyDetails)
        pub fn build(self) -> crate::model::FirewallPolicyDetails {
            crate::model::FirewallPolicyDetails {
                stateful_rule_group_references: self.stateful_rule_group_references,
                stateless_custom_actions: self.stateless_custom_actions,
                stateless_default_actions: self.stateless_default_actions,
                stateless_fragment_default_actions: self.stateless_fragment_default_actions,
                stateless_rule_group_references: self.stateless_rule_group_references,
            }
        }
    }
}
impl FirewallPolicyDetails {
    /// Creates a new builder-style object to manufacture [`FirewallPolicyDetails`](crate::model::FirewallPolicyDetails)
    pub fn builder() -> crate::model::firewall_policy_details::Builder {
        crate::model::firewall_policy_details::Builder::default()
    }
}

/// <p>A stateless rule group that is used by the firewall policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FirewallPolicyStatelessRuleGroupReferencesDetails {
    /// <p>The order in which to run the stateless rule group.</p>
    pub priority: i32,
    /// <p>The ARN of the stateless rule group.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl FirewallPolicyStatelessRuleGroupReferencesDetails {
    /// <p>The order in which to run the stateless rule group.</p>
    pub fn priority(&self) -> i32 {
        self.priority
    }
    /// <p>The ARN of the stateless rule group.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl std::fmt::Debug for FirewallPolicyStatelessRuleGroupReferencesDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FirewallPolicyStatelessRuleGroupReferencesDetails");
        formatter.field("priority", &self.priority);
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}
/// See [`FirewallPolicyStatelessRuleGroupReferencesDetails`](crate::model::FirewallPolicyStatelessRuleGroupReferencesDetails)
pub mod firewall_policy_stateless_rule_group_references_details {

    /// A builder for [`FirewallPolicyStatelessRuleGroupReferencesDetails`](crate::model::FirewallPolicyStatelessRuleGroupReferencesDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) priority: std::option::Option<i32>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The order in which to run the stateless rule group.</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        /// <p>The order in which to run the stateless rule group.</p>
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input;
            self
        }
        /// <p>The ARN of the stateless rule group.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the stateless rule group.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`FirewallPolicyStatelessRuleGroupReferencesDetails`](crate::model::FirewallPolicyStatelessRuleGroupReferencesDetails)
        pub fn build(self) -> crate::model::FirewallPolicyStatelessRuleGroupReferencesDetails {
            crate::model::FirewallPolicyStatelessRuleGroupReferencesDetails {
                priority: self.priority.unwrap_or_default(),
                resource_arn: self.resource_arn,
            }
        }
    }
}
impl FirewallPolicyStatelessRuleGroupReferencesDetails {
    /// Creates a new builder-style object to manufacture [`FirewallPolicyStatelessRuleGroupReferencesDetails`](crate::model::FirewallPolicyStatelessRuleGroupReferencesDetails)
    pub fn builder(
    ) -> crate::model::firewall_policy_stateless_rule_group_references_details::Builder {
        crate::model::firewall_policy_stateless_rule_group_references_details::Builder::default()
    }
}

/// <p>A custom action that can be used for stateless packet handling.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FirewallPolicyStatelessCustomActionsDetails {
    /// <p>The definition of the custom action.</p>
    pub action_definition: std::option::Option<crate::model::StatelessCustomActionDefinition>,
    /// <p>The name of the custom action.</p>
    pub action_name: std::option::Option<std::string::String>,
}
impl FirewallPolicyStatelessCustomActionsDetails {
    /// <p>The definition of the custom action.</p>
    pub fn action_definition(
        &self,
    ) -> std::option::Option<&crate::model::StatelessCustomActionDefinition> {
        self.action_definition.as_ref()
    }
    /// <p>The name of the custom action.</p>
    pub fn action_name(&self) -> std::option::Option<&str> {
        self.action_name.as_deref()
    }
}
impl std::fmt::Debug for FirewallPolicyStatelessCustomActionsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FirewallPolicyStatelessCustomActionsDetails");
        formatter.field("action_definition", &self.action_definition);
        formatter.field("action_name", &self.action_name);
        formatter.finish()
    }
}
/// See [`FirewallPolicyStatelessCustomActionsDetails`](crate::model::FirewallPolicyStatelessCustomActionsDetails)
pub mod firewall_policy_stateless_custom_actions_details {

    /// A builder for [`FirewallPolicyStatelessCustomActionsDetails`](crate::model::FirewallPolicyStatelessCustomActionsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action_definition:
            std::option::Option<crate::model::StatelessCustomActionDefinition>,
        pub(crate) action_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The definition of the custom action.</p>
        pub fn action_definition(
            mut self,
            input: crate::model::StatelessCustomActionDefinition,
        ) -> Self {
            self.action_definition = Some(input);
            self
        }
        /// <p>The definition of the custom action.</p>
        pub fn set_action_definition(
            mut self,
            input: std::option::Option<crate::model::StatelessCustomActionDefinition>,
        ) -> Self {
            self.action_definition = input;
            self
        }
        /// <p>The name of the custom action.</p>
        pub fn action_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_name = Some(input.into());
            self
        }
        /// <p>The name of the custom action.</p>
        pub fn set_action_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_name = input;
            self
        }
        /// Consumes the builder and constructs a [`FirewallPolicyStatelessCustomActionsDetails`](crate::model::FirewallPolicyStatelessCustomActionsDetails)
        pub fn build(self) -> crate::model::FirewallPolicyStatelessCustomActionsDetails {
            crate::model::FirewallPolicyStatelessCustomActionsDetails {
                action_definition: self.action_definition,
                action_name: self.action_name,
            }
        }
    }
}
impl FirewallPolicyStatelessCustomActionsDetails {
    /// Creates a new builder-style object to manufacture [`FirewallPolicyStatelessCustomActionsDetails`](crate::model::FirewallPolicyStatelessCustomActionsDetails)
    pub fn builder() -> crate::model::firewall_policy_stateless_custom_actions_details::Builder {
        crate::model::firewall_policy_stateless_custom_actions_details::Builder::default()
    }
}

/// <p>A stateful rule group that is used by the firewall policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FirewallPolicyStatefulRuleGroupReferencesDetails {
    /// <p>The ARN of the stateful rule group.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl FirewallPolicyStatefulRuleGroupReferencesDetails {
    /// <p>The ARN of the stateful rule group.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl std::fmt::Debug for FirewallPolicyStatefulRuleGroupReferencesDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FirewallPolicyStatefulRuleGroupReferencesDetails");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}
/// See [`FirewallPolicyStatefulRuleGroupReferencesDetails`](crate::model::FirewallPolicyStatefulRuleGroupReferencesDetails)
pub mod firewall_policy_stateful_rule_group_references_details {

    /// A builder for [`FirewallPolicyStatefulRuleGroupReferencesDetails`](crate::model::FirewallPolicyStatefulRuleGroupReferencesDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the stateful rule group.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the stateful rule group.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`FirewallPolicyStatefulRuleGroupReferencesDetails`](crate::model::FirewallPolicyStatefulRuleGroupReferencesDetails)
        pub fn build(self) -> crate::model::FirewallPolicyStatefulRuleGroupReferencesDetails {
            crate::model::FirewallPolicyStatefulRuleGroupReferencesDetails {
                resource_arn: self.resource_arn,
            }
        }
    }
}
impl FirewallPolicyStatefulRuleGroupReferencesDetails {
    /// Creates a new builder-style object to manufacture [`FirewallPolicyStatefulRuleGroupReferencesDetails`](crate::model::FirewallPolicyStatefulRuleGroupReferencesDetails)
    pub fn builder() -> crate::model::firewall_policy_stateful_rule_group_references_details::Builder
    {
        crate::model::firewall_policy_stateful_rule_group_references_details::Builder::default()
    }
}

/// <p>Provides details about an Amazon EKS cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEksClusterDetails {
    /// <p>The ARN of the cluster.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The certificate authority data for the cluster.</p>
    pub certificate_authority_data: std::option::Option<std::string::String>,
    /// <p>The status of the cluster.</p>
    pub cluster_status: std::option::Option<std::string::String>,
    /// <p>The endpoint for the Amazon EKS API server.</p>
    pub endpoint: std::option::Option<std::string::String>,
    /// <p>The name of the cluster.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The VPC configuration used by the cluster control plane.</p>
    pub resources_vpc_config:
        std::option::Option<crate::model::AwsEksClusterResourcesVpcConfigDetails>,
    /// <p>The ARN of the IAM role that provides permissions for the Amazon EKS control plane to make calls to Amazon Web Services API operations on your behalf.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon EKS server version for the cluster.</p>
    pub version: std::option::Option<std::string::String>,
    /// <p>The logging configuration for the cluster.</p>
    pub logging: std::option::Option<crate::model::AwsEksClusterLoggingDetails>,
}
impl AwsEksClusterDetails {
    /// <p>The ARN of the cluster.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The certificate authority data for the cluster.</p>
    pub fn certificate_authority_data(&self) -> std::option::Option<&str> {
        self.certificate_authority_data.as_deref()
    }
    /// <p>The status of the cluster.</p>
    pub fn cluster_status(&self) -> std::option::Option<&str> {
        self.cluster_status.as_deref()
    }
    /// <p>The endpoint for the Amazon EKS API server.</p>
    pub fn endpoint(&self) -> std::option::Option<&str> {
        self.endpoint.as_deref()
    }
    /// <p>The name of the cluster.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The VPC configuration used by the cluster control plane.</p>
    pub fn resources_vpc_config(
        &self,
    ) -> std::option::Option<&crate::model::AwsEksClusterResourcesVpcConfigDetails> {
        self.resources_vpc_config.as_ref()
    }
    /// <p>The ARN of the IAM role that provides permissions for the Amazon EKS control plane to make calls to Amazon Web Services API operations on your behalf.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>The Amazon EKS server version for the cluster.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
    /// <p>The logging configuration for the cluster.</p>
    pub fn logging(&self) -> std::option::Option<&crate::model::AwsEksClusterLoggingDetails> {
        self.logging.as_ref()
    }
}
impl std::fmt::Debug for AwsEksClusterDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEksClusterDetails");
        formatter.field("arn", &self.arn);
        formatter.field(
            "certificate_authority_data",
            &self.certificate_authority_data,
        );
        formatter.field("cluster_status", &self.cluster_status);
        formatter.field("endpoint", &self.endpoint);
        formatter.field("name", &self.name);
        formatter.field("resources_vpc_config", &self.resources_vpc_config);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("version", &self.version);
        formatter.field("logging", &self.logging);
        formatter.finish()
    }
}
/// See [`AwsEksClusterDetails`](crate::model::AwsEksClusterDetails)
pub mod aws_eks_cluster_details {

    /// A builder for [`AwsEksClusterDetails`](crate::model::AwsEksClusterDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) certificate_authority_data: std::option::Option<std::string::String>,
        pub(crate) cluster_status: std::option::Option<std::string::String>,
        pub(crate) endpoint: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) resources_vpc_config:
            std::option::Option<crate::model::AwsEksClusterResourcesVpcConfigDetails>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
        pub(crate) logging: std::option::Option<crate::model::AwsEksClusterLoggingDetails>,
    }
    impl Builder {
        /// <p>The ARN of the cluster.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the cluster.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The certificate authority data for the cluster.</p>
        pub fn certificate_authority_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_authority_data = Some(input.into());
            self
        }
        /// <p>The certificate authority data for the cluster.</p>
        pub fn set_certificate_authority_data(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_authority_data = input;
            self
        }
        /// <p>The status of the cluster.</p>
        pub fn cluster_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_status = Some(input.into());
            self
        }
        /// <p>The status of the cluster.</p>
        pub fn set_cluster_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_status = input;
            self
        }
        /// <p>The endpoint for the Amazon EKS API server.</p>
        pub fn endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint = Some(input.into());
            self
        }
        /// <p>The endpoint for the Amazon EKS API server.</p>
        pub fn set_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint = input;
            self
        }
        /// <p>The name of the cluster.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the cluster.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The VPC configuration used by the cluster control plane.</p>
        pub fn resources_vpc_config(
            mut self,
            input: crate::model::AwsEksClusterResourcesVpcConfigDetails,
        ) -> Self {
            self.resources_vpc_config = Some(input);
            self
        }
        /// <p>The VPC configuration used by the cluster control plane.</p>
        pub fn set_resources_vpc_config(
            mut self,
            input: std::option::Option<crate::model::AwsEksClusterResourcesVpcConfigDetails>,
        ) -> Self {
            self.resources_vpc_config = input;
            self
        }
        /// <p>The ARN of the IAM role that provides permissions for the Amazon EKS control plane to make calls to Amazon Web Services API operations on your behalf.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the IAM role that provides permissions for the Amazon EKS control plane to make calls to Amazon Web Services API operations on your behalf.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The Amazon EKS server version for the cluster.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The Amazon EKS server version for the cluster.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// <p>The logging configuration for the cluster.</p>
        pub fn logging(mut self, input: crate::model::AwsEksClusterLoggingDetails) -> Self {
            self.logging = Some(input);
            self
        }
        /// <p>The logging configuration for the cluster.</p>
        pub fn set_logging(
            mut self,
            input: std::option::Option<crate::model::AwsEksClusterLoggingDetails>,
        ) -> Self {
            self.logging = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEksClusterDetails`](crate::model::AwsEksClusterDetails)
        pub fn build(self) -> crate::model::AwsEksClusterDetails {
            crate::model::AwsEksClusterDetails {
                arn: self.arn,
                certificate_authority_data: self.certificate_authority_data,
                cluster_status: self.cluster_status,
                endpoint: self.endpoint,
                name: self.name,
                resources_vpc_config: self.resources_vpc_config,
                role_arn: self.role_arn,
                version: self.version,
                logging: self.logging,
            }
        }
    }
}
impl AwsEksClusterDetails {
    /// Creates a new builder-style object to manufacture [`AwsEksClusterDetails`](crate::model::AwsEksClusterDetails)
    pub fn builder() -> crate::model::aws_eks_cluster_details::Builder {
        crate::model::aws_eks_cluster_details::Builder::default()
    }
}

/// <p>The logging configuration for an Amazon EKS cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEksClusterLoggingDetails {
    /// <p>Cluster logging configurations.</p>
    pub cluster_logging:
        std::option::Option<std::vec::Vec<crate::model::AwsEksClusterLoggingClusterLoggingDetails>>,
}
impl AwsEksClusterLoggingDetails {
    /// <p>Cluster logging configurations.</p>
    pub fn cluster_logging(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEksClusterLoggingClusterLoggingDetails]> {
        self.cluster_logging.as_deref()
    }
}
impl std::fmt::Debug for AwsEksClusterLoggingDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEksClusterLoggingDetails");
        formatter.field("cluster_logging", &self.cluster_logging);
        formatter.finish()
    }
}
/// See [`AwsEksClusterLoggingDetails`](crate::model::AwsEksClusterLoggingDetails)
pub mod aws_eks_cluster_logging_details {

    /// A builder for [`AwsEksClusterLoggingDetails`](crate::model::AwsEksClusterLoggingDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cluster_logging: std::option::Option<
            std::vec::Vec<crate::model::AwsEksClusterLoggingClusterLoggingDetails>,
        >,
    }
    impl Builder {
        /// Appends an item to `cluster_logging`.
        ///
        /// To override the contents of this collection use [`set_cluster_logging`](Self::set_cluster_logging).
        ///
        /// <p>Cluster logging configurations.</p>
        pub fn cluster_logging(
            mut self,
            input: crate::model::AwsEksClusterLoggingClusterLoggingDetails,
        ) -> Self {
            let mut v = self.cluster_logging.unwrap_or_default();
            v.push(input);
            self.cluster_logging = Some(v);
            self
        }
        /// <p>Cluster logging configurations.</p>
        pub fn set_cluster_logging(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEksClusterLoggingClusterLoggingDetails>,
            >,
        ) -> Self {
            self.cluster_logging = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEksClusterLoggingDetails`](crate::model::AwsEksClusterLoggingDetails)
        pub fn build(self) -> crate::model::AwsEksClusterLoggingDetails {
            crate::model::AwsEksClusterLoggingDetails {
                cluster_logging: self.cluster_logging,
            }
        }
    }
}
impl AwsEksClusterLoggingDetails {
    /// Creates a new builder-style object to manufacture [`AwsEksClusterLoggingDetails`](crate::model::AwsEksClusterLoggingDetails)
    pub fn builder() -> crate::model::aws_eks_cluster_logging_details::Builder {
        crate::model::aws_eks_cluster_logging_details::Builder::default()
    }
}

/// <p>Details for a cluster logging configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEksClusterLoggingClusterLoggingDetails {
    /// <p>Whether the logging types that are listed in <code>Types</code> are enabled.</p>
    pub enabled: bool,
    /// <p>A list of logging types.</p>
    pub types: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AwsEksClusterLoggingClusterLoggingDetails {
    /// <p>Whether the logging types that are listed in <code>Types</code> are enabled.</p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
    /// <p>A list of logging types.</p>
    pub fn types(&self) -> std::option::Option<&[std::string::String]> {
        self.types.as_deref()
    }
}
impl std::fmt::Debug for AwsEksClusterLoggingClusterLoggingDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEksClusterLoggingClusterLoggingDetails");
        formatter.field("enabled", &self.enabled);
        formatter.field("types", &self.types);
        formatter.finish()
    }
}
/// See [`AwsEksClusterLoggingClusterLoggingDetails`](crate::model::AwsEksClusterLoggingClusterLoggingDetails)
pub mod aws_eks_cluster_logging_cluster_logging_details {

    /// A builder for [`AwsEksClusterLoggingClusterLoggingDetails`](crate::model::AwsEksClusterLoggingClusterLoggingDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) types: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>Whether the logging types that are listed in <code>Types</code> are enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Whether the logging types that are listed in <code>Types</code> are enabled.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Appends an item to `types`.
        ///
        /// To override the contents of this collection use [`set_types`](Self::set_types).
        ///
        /// <p>A list of logging types.</p>
        pub fn types(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.types.unwrap_or_default();
            v.push(input.into());
            self.types = Some(v);
            self
        }
        /// <p>A list of logging types.</p>
        pub fn set_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.types = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEksClusterLoggingClusterLoggingDetails`](crate::model::AwsEksClusterLoggingClusterLoggingDetails)
        pub fn build(self) -> crate::model::AwsEksClusterLoggingClusterLoggingDetails {
            crate::model::AwsEksClusterLoggingClusterLoggingDetails {
                enabled: self.enabled.unwrap_or_default(),
                types: self.types,
            }
        }
    }
}
impl AwsEksClusterLoggingClusterLoggingDetails {
    /// Creates a new builder-style object to manufacture [`AwsEksClusterLoggingClusterLoggingDetails`](crate::model::AwsEksClusterLoggingClusterLoggingDetails)
    pub fn builder() -> crate::model::aws_eks_cluster_logging_cluster_logging_details::Builder {
        crate::model::aws_eks_cluster_logging_cluster_logging_details::Builder::default()
    }
}

/// <p>Information about the VPC configuration used by the cluster control plane.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEksClusterResourcesVpcConfigDetails {
    /// <p>The security groups that are associated with the cross-account elastic network interfaces that are used to allow communication between your nodes and the Amazon EKS control plane.</p>
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The subnets that are associated with the cluster.</p>
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AwsEksClusterResourcesVpcConfigDetails {
    /// <p>The security groups that are associated with the cross-account elastic network interfaces that are used to allow communication between your nodes and the Amazon EKS control plane.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
    /// <p>The subnets that are associated with the cluster.</p>
    pub fn subnet_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_ids.as_deref()
    }
}
impl std::fmt::Debug for AwsEksClusterResourcesVpcConfigDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEksClusterResourcesVpcConfigDetails");
        formatter.field("security_group_ids", &self.security_group_ids);
        formatter.field("subnet_ids", &self.subnet_ids);
        formatter.finish()
    }
}
/// See [`AwsEksClusterResourcesVpcConfigDetails`](crate::model::AwsEksClusterResourcesVpcConfigDetails)
pub mod aws_eks_cluster_resources_vpc_config_details {

    /// A builder for [`AwsEksClusterResourcesVpcConfigDetails`](crate::model::AwsEksClusterResourcesVpcConfigDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
        ///
        /// <p>The security groups that are associated with the cross-account elastic network interfaces that are used to allow communication between your nodes and the Amazon EKS control plane.</p>
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        /// <p>The security groups that are associated with the cross-account elastic network interfaces that are used to allow communication between your nodes and the Amazon EKS control plane.</p>
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// Appends an item to `subnet_ids`.
        ///
        /// To override the contents of this collection use [`set_subnet_ids`](Self::set_subnet_ids).
        ///
        /// <p>The subnets that are associated with the cluster.</p>
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        /// <p>The subnets that are associated with the cluster.</p>
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEksClusterResourcesVpcConfigDetails`](crate::model::AwsEksClusterResourcesVpcConfigDetails)
        pub fn build(self) -> crate::model::AwsEksClusterResourcesVpcConfigDetails {
            crate::model::AwsEksClusterResourcesVpcConfigDetails {
                security_group_ids: self.security_group_ids,
                subnet_ids: self.subnet_ids,
            }
        }
    }
}
impl AwsEksClusterResourcesVpcConfigDetails {
    /// Creates a new builder-style object to manufacture [`AwsEksClusterResourcesVpcConfigDetails`](crate::model::AwsEksClusterResourcesVpcConfigDetails)
    pub fn builder() -> crate::model::aws_eks_cluster_resources_vpc_config_details::Builder {
        crate::model::aws_eks_cluster_resources_vpc_config_details::Builder::default()
    }
}

/// <p>Provides information about an Amazon Elastic Container Registry repository.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcrRepositoryDetails {
    /// <p>The ARN of the repository.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The image scanning configuration for a repository.</p>
    pub image_scanning_configuration:
        std::option::Option<crate::model::AwsEcrRepositoryImageScanningConfigurationDetails>,
    /// <p>The tag mutability setting for the repository.</p>
    pub image_tag_mutability: std::option::Option<std::string::String>,
    /// <p>Information about the lifecycle policy for the repository.</p>
    pub lifecycle_policy: std::option::Option<crate::model::AwsEcrRepositoryLifecyclePolicyDetails>,
    /// <p>The name of the repository.</p>
    pub repository_name: std::option::Option<std::string::String>,
    /// <p>The text of the repository policy.</p>
    pub repository_policy_text: std::option::Option<std::string::String>,
}
impl AwsEcrRepositoryDetails {
    /// <p>The ARN of the repository.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The image scanning configuration for a repository.</p>
    pub fn image_scanning_configuration(
        &self,
    ) -> std::option::Option<&crate::model::AwsEcrRepositoryImageScanningConfigurationDetails> {
        self.image_scanning_configuration.as_ref()
    }
    /// <p>The tag mutability setting for the repository.</p>
    pub fn image_tag_mutability(&self) -> std::option::Option<&str> {
        self.image_tag_mutability.as_deref()
    }
    /// <p>Information about the lifecycle policy for the repository.</p>
    pub fn lifecycle_policy(
        &self,
    ) -> std::option::Option<&crate::model::AwsEcrRepositoryLifecyclePolicyDetails> {
        self.lifecycle_policy.as_ref()
    }
    /// <p>The name of the repository.</p>
    pub fn repository_name(&self) -> std::option::Option<&str> {
        self.repository_name.as_deref()
    }
    /// <p>The text of the repository policy.</p>
    pub fn repository_policy_text(&self) -> std::option::Option<&str> {
        self.repository_policy_text.as_deref()
    }
}
impl std::fmt::Debug for AwsEcrRepositoryDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcrRepositoryDetails");
        formatter.field("arn", &self.arn);
        formatter.field(
            "image_scanning_configuration",
            &self.image_scanning_configuration,
        );
        formatter.field("image_tag_mutability", &self.image_tag_mutability);
        formatter.field("lifecycle_policy", &self.lifecycle_policy);
        formatter.field("repository_name", &self.repository_name);
        formatter.field("repository_policy_text", &self.repository_policy_text);
        formatter.finish()
    }
}
/// See [`AwsEcrRepositoryDetails`](crate::model::AwsEcrRepositoryDetails)
pub mod aws_ecr_repository_details {

    /// A builder for [`AwsEcrRepositoryDetails`](crate::model::AwsEcrRepositoryDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) image_scanning_configuration:
            std::option::Option<crate::model::AwsEcrRepositoryImageScanningConfigurationDetails>,
        pub(crate) image_tag_mutability: std::option::Option<std::string::String>,
        pub(crate) lifecycle_policy:
            std::option::Option<crate::model::AwsEcrRepositoryLifecyclePolicyDetails>,
        pub(crate) repository_name: std::option::Option<std::string::String>,
        pub(crate) repository_policy_text: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the repository.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the repository.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The image scanning configuration for a repository.</p>
        pub fn image_scanning_configuration(
            mut self,
            input: crate::model::AwsEcrRepositoryImageScanningConfigurationDetails,
        ) -> Self {
            self.image_scanning_configuration = Some(input);
            self
        }
        /// <p>The image scanning configuration for a repository.</p>
        pub fn set_image_scanning_configuration(
            mut self,
            input: std::option::Option<
                crate::model::AwsEcrRepositoryImageScanningConfigurationDetails,
            >,
        ) -> Self {
            self.image_scanning_configuration = input;
            self
        }
        /// <p>The tag mutability setting for the repository.</p>
        pub fn image_tag_mutability(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_tag_mutability = Some(input.into());
            self
        }
        /// <p>The tag mutability setting for the repository.</p>
        pub fn set_image_tag_mutability(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.image_tag_mutability = input;
            self
        }
        /// <p>Information about the lifecycle policy for the repository.</p>
        pub fn lifecycle_policy(
            mut self,
            input: crate::model::AwsEcrRepositoryLifecyclePolicyDetails,
        ) -> Self {
            self.lifecycle_policy = Some(input);
            self
        }
        /// <p>Information about the lifecycle policy for the repository.</p>
        pub fn set_lifecycle_policy(
            mut self,
            input: std::option::Option<crate::model::AwsEcrRepositoryLifecyclePolicyDetails>,
        ) -> Self {
            self.lifecycle_policy = input;
            self
        }
        /// <p>The name of the repository.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository_name = Some(input.into());
            self
        }
        /// <p>The name of the repository.</p>
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.repository_name = input;
            self
        }
        /// <p>The text of the repository policy.</p>
        pub fn repository_policy_text(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository_policy_text = Some(input.into());
            self
        }
        /// <p>The text of the repository policy.</p>
        pub fn set_repository_policy_text(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.repository_policy_text = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcrRepositoryDetails`](crate::model::AwsEcrRepositoryDetails)
        pub fn build(self) -> crate::model::AwsEcrRepositoryDetails {
            crate::model::AwsEcrRepositoryDetails {
                arn: self.arn,
                image_scanning_configuration: self.image_scanning_configuration,
                image_tag_mutability: self.image_tag_mutability,
                lifecycle_policy: self.lifecycle_policy,
                repository_name: self.repository_name,
                repository_policy_text: self.repository_policy_text,
            }
        }
    }
}
impl AwsEcrRepositoryDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcrRepositoryDetails`](crate::model::AwsEcrRepositoryDetails)
    pub fn builder() -> crate::model::aws_ecr_repository_details::Builder {
        crate::model::aws_ecr_repository_details::Builder::default()
    }
}

/// <p>Information about the lifecycle policy for the repository.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcrRepositoryLifecyclePolicyDetails {
    /// <p>The text of the lifecycle policy.</p>
    pub lifecycle_policy_text: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account identifier that is associated with the registry that contains the repository.</p>
    pub registry_id: std::option::Option<std::string::String>,
}
impl AwsEcrRepositoryLifecyclePolicyDetails {
    /// <p>The text of the lifecycle policy.</p>
    pub fn lifecycle_policy_text(&self) -> std::option::Option<&str> {
        self.lifecycle_policy_text.as_deref()
    }
    /// <p>The Amazon Web Services account identifier that is associated with the registry that contains the repository.</p>
    pub fn registry_id(&self) -> std::option::Option<&str> {
        self.registry_id.as_deref()
    }
}
impl std::fmt::Debug for AwsEcrRepositoryLifecyclePolicyDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcrRepositoryLifecyclePolicyDetails");
        formatter.field("lifecycle_policy_text", &self.lifecycle_policy_text);
        formatter.field("registry_id", &self.registry_id);
        formatter.finish()
    }
}
/// See [`AwsEcrRepositoryLifecyclePolicyDetails`](crate::model::AwsEcrRepositoryLifecyclePolicyDetails)
pub mod aws_ecr_repository_lifecycle_policy_details {

    /// A builder for [`AwsEcrRepositoryLifecyclePolicyDetails`](crate::model::AwsEcrRepositoryLifecyclePolicyDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lifecycle_policy_text: std::option::Option<std::string::String>,
        pub(crate) registry_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The text of the lifecycle policy.</p>
        pub fn lifecycle_policy_text(mut self, input: impl Into<std::string::String>) -> Self {
            self.lifecycle_policy_text = Some(input.into());
            self
        }
        /// <p>The text of the lifecycle policy.</p>
        pub fn set_lifecycle_policy_text(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.lifecycle_policy_text = input;
            self
        }
        /// <p>The Amazon Web Services account identifier that is associated with the registry that contains the repository.</p>
        pub fn registry_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.registry_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account identifier that is associated with the registry that contains the repository.</p>
        pub fn set_registry_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.registry_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcrRepositoryLifecyclePolicyDetails`](crate::model::AwsEcrRepositoryLifecyclePolicyDetails)
        pub fn build(self) -> crate::model::AwsEcrRepositoryLifecyclePolicyDetails {
            crate::model::AwsEcrRepositoryLifecyclePolicyDetails {
                lifecycle_policy_text: self.lifecycle_policy_text,
                registry_id: self.registry_id,
            }
        }
    }
}
impl AwsEcrRepositoryLifecyclePolicyDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcrRepositoryLifecyclePolicyDetails`](crate::model::AwsEcrRepositoryLifecyclePolicyDetails)
    pub fn builder() -> crate::model::aws_ecr_repository_lifecycle_policy_details::Builder {
        crate::model::aws_ecr_repository_lifecycle_policy_details::Builder::default()
    }
}

/// <p>The image scanning configuration for a repository.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcrRepositoryImageScanningConfigurationDetails {
    /// <p>Whether to scan images after they are pushed to a repository.</p>
    pub scan_on_push: bool,
}
impl AwsEcrRepositoryImageScanningConfigurationDetails {
    /// <p>Whether to scan images after they are pushed to a repository.</p>
    pub fn scan_on_push(&self) -> bool {
        self.scan_on_push
    }
}
impl std::fmt::Debug for AwsEcrRepositoryImageScanningConfigurationDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcrRepositoryImageScanningConfigurationDetails");
        formatter.field("scan_on_push", &self.scan_on_push);
        formatter.finish()
    }
}
/// See [`AwsEcrRepositoryImageScanningConfigurationDetails`](crate::model::AwsEcrRepositoryImageScanningConfigurationDetails)
pub mod aws_ecr_repository_image_scanning_configuration_details {

    /// A builder for [`AwsEcrRepositoryImageScanningConfigurationDetails`](crate::model::AwsEcrRepositoryImageScanningConfigurationDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scan_on_push: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Whether to scan images after they are pushed to a repository.</p>
        pub fn scan_on_push(mut self, input: bool) -> Self {
            self.scan_on_push = Some(input);
            self
        }
        /// <p>Whether to scan images after they are pushed to a repository.</p>
        pub fn set_scan_on_push(mut self, input: std::option::Option<bool>) -> Self {
            self.scan_on_push = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcrRepositoryImageScanningConfigurationDetails`](crate::model::AwsEcrRepositoryImageScanningConfigurationDetails)
        pub fn build(self) -> crate::model::AwsEcrRepositoryImageScanningConfigurationDetails {
            crate::model::AwsEcrRepositoryImageScanningConfigurationDetails {
                scan_on_push: self.scan_on_push.unwrap_or_default(),
            }
        }
    }
}
impl AwsEcrRepositoryImageScanningConfigurationDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcrRepositoryImageScanningConfigurationDetails`](crate::model::AwsEcrRepositoryImageScanningConfigurationDetails)
    pub fn builder(
    ) -> crate::model::aws_ecr_repository_image_scanning_configuration_details::Builder {
        crate::model::aws_ecr_repository_image_scanning_configuration_details::Builder::default()
    }
}

/// <p>contains details about a rate-based rule for Regional resources. A rate-based rule provides settings to indicate when to allow, block, or count a request. Rate-based rules include the number of requests that arrive over a specified period of time.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsWafRegionalRateBasedRuleDetails {
    /// <p>The name of the metrics for the rate-based rule.</p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>The name of the rate-based rule.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The field that WAF uses to determine whether requests are likely arriving from single source and are subject to rate monitoring.</p>
    pub rate_key: std::option::Option<std::string::String>,
    /// <p>The maximum number of requests that have an identical value for the field specified in <code>RateKey</code> that are allowed within a five-minute period. If the number of requests exceeds <code>RateLimit</code> and the other predicates specified in the rule are met, WAF triggers the action for the rule.</p>
    pub rate_limit: i64,
    /// <p>The unique identifier for the rate-based rule.</p>
    pub rule_id: std::option::Option<std::string::String>,
    /// <p>The predicates to include in the rate-based rule.</p>
    pub match_predicates:
        std::option::Option<std::vec::Vec<crate::model::AwsWafRegionalRateBasedRuleMatchPredicate>>,
}
impl AwsWafRegionalRateBasedRuleDetails {
    /// <p>The name of the metrics for the rate-based rule.</p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
    /// <p>The name of the rate-based rule.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The field that WAF uses to determine whether requests are likely arriving from single source and are subject to rate monitoring.</p>
    pub fn rate_key(&self) -> std::option::Option<&str> {
        self.rate_key.as_deref()
    }
    /// <p>The maximum number of requests that have an identical value for the field specified in <code>RateKey</code> that are allowed within a five-minute period. If the number of requests exceeds <code>RateLimit</code> and the other predicates specified in the rule are met, WAF triggers the action for the rule.</p>
    pub fn rate_limit(&self) -> i64 {
        self.rate_limit
    }
    /// <p>The unique identifier for the rate-based rule.</p>
    pub fn rule_id(&self) -> std::option::Option<&str> {
        self.rule_id.as_deref()
    }
    /// <p>The predicates to include in the rate-based rule.</p>
    pub fn match_predicates(
        &self,
    ) -> std::option::Option<&[crate::model::AwsWafRegionalRateBasedRuleMatchPredicate]> {
        self.match_predicates.as_deref()
    }
}
impl std::fmt::Debug for AwsWafRegionalRateBasedRuleDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsWafRegionalRateBasedRuleDetails");
        formatter.field("metric_name", &self.metric_name);
        formatter.field("name", &self.name);
        formatter.field("rate_key", &self.rate_key);
        formatter.field("rate_limit", &self.rate_limit);
        formatter.field("rule_id", &self.rule_id);
        formatter.field("match_predicates", &self.match_predicates);
        formatter.finish()
    }
}
/// See [`AwsWafRegionalRateBasedRuleDetails`](crate::model::AwsWafRegionalRateBasedRuleDetails)
pub mod aws_waf_regional_rate_based_rule_details {

    /// A builder for [`AwsWafRegionalRateBasedRuleDetails`](crate::model::AwsWafRegionalRateBasedRuleDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) rate_key: std::option::Option<std::string::String>,
        pub(crate) rate_limit: std::option::Option<i64>,
        pub(crate) rule_id: std::option::Option<std::string::String>,
        pub(crate) match_predicates: std::option::Option<
            std::vec::Vec<crate::model::AwsWafRegionalRateBasedRuleMatchPredicate>,
        >,
    }
    impl Builder {
        /// <p>The name of the metrics for the rate-based rule.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>The name of the metrics for the rate-based rule.</p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The name of the rate-based rule.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the rate-based rule.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The field that WAF uses to determine whether requests are likely arriving from single source and are subject to rate monitoring.</p>
        pub fn rate_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.rate_key = Some(input.into());
            self
        }
        /// <p>The field that WAF uses to determine whether requests are likely arriving from single source and are subject to rate monitoring.</p>
        pub fn set_rate_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rate_key = input;
            self
        }
        /// <p>The maximum number of requests that have an identical value for the field specified in <code>RateKey</code> that are allowed within a five-minute period. If the number of requests exceeds <code>RateLimit</code> and the other predicates specified in the rule are met, WAF triggers the action for the rule.</p>
        pub fn rate_limit(mut self, input: i64) -> Self {
            self.rate_limit = Some(input);
            self
        }
        /// <p>The maximum number of requests that have an identical value for the field specified in <code>RateKey</code> that are allowed within a five-minute period. If the number of requests exceeds <code>RateLimit</code> and the other predicates specified in the rule are met, WAF triggers the action for the rule.</p>
        pub fn set_rate_limit(mut self, input: std::option::Option<i64>) -> Self {
            self.rate_limit = input;
            self
        }
        /// <p>The unique identifier for the rate-based rule.</p>
        pub fn rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the rate-based rule.</p>
        pub fn set_rule_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_id = input;
            self
        }
        /// Appends an item to `match_predicates`.
        ///
        /// To override the contents of this collection use [`set_match_predicates`](Self::set_match_predicates).
        ///
        /// <p>The predicates to include in the rate-based rule.</p>
        pub fn match_predicates(
            mut self,
            input: crate::model::AwsWafRegionalRateBasedRuleMatchPredicate,
        ) -> Self {
            let mut v = self.match_predicates.unwrap_or_default();
            v.push(input);
            self.match_predicates = Some(v);
            self
        }
        /// <p>The predicates to include in the rate-based rule.</p>
        pub fn set_match_predicates(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsWafRegionalRateBasedRuleMatchPredicate>,
            >,
        ) -> Self {
            self.match_predicates = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsWafRegionalRateBasedRuleDetails`](crate::model::AwsWafRegionalRateBasedRuleDetails)
        pub fn build(self) -> crate::model::AwsWafRegionalRateBasedRuleDetails {
            crate::model::AwsWafRegionalRateBasedRuleDetails {
                metric_name: self.metric_name,
                name: self.name,
                rate_key: self.rate_key,
                rate_limit: self.rate_limit.unwrap_or_default(),
                rule_id: self.rule_id,
                match_predicates: self.match_predicates,
            }
        }
    }
}
impl AwsWafRegionalRateBasedRuleDetails {
    /// Creates a new builder-style object to manufacture [`AwsWafRegionalRateBasedRuleDetails`](crate::model::AwsWafRegionalRateBasedRuleDetails)
    pub fn builder() -> crate::model::aws_waf_regional_rate_based_rule_details::Builder {
        crate::model::aws_waf_regional_rate_based_rule_details::Builder::default()
    }
}

/// <p>Details for a match predicate. A predicate might look for characteristics such as specific IP addresses, geographic locations, or sizes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsWafRegionalRateBasedRuleMatchPredicate {
    /// <p>The unique identifier for the predicate.</p>
    pub data_id: std::option::Option<std::string::String>,
    /// <p>If set to <code>true</code>, then the rule actions are performed on requests that match the predicate settings.</p>
    /// <p>If set to <code>false</code>, then the rule actions are performed on all requests except those that match the predicate settings.</p>
    pub negated: bool,
    /// <p>The type of predicate.</p>
    pub r#type: std::option::Option<std::string::String>,
}
impl AwsWafRegionalRateBasedRuleMatchPredicate {
    /// <p>The unique identifier for the predicate.</p>
    pub fn data_id(&self) -> std::option::Option<&str> {
        self.data_id.as_deref()
    }
    /// <p>If set to <code>true</code>, then the rule actions are performed on requests that match the predicate settings.</p>
    /// <p>If set to <code>false</code>, then the rule actions are performed on all requests except those that match the predicate settings.</p>
    pub fn negated(&self) -> bool {
        self.negated
    }
    /// <p>The type of predicate.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for AwsWafRegionalRateBasedRuleMatchPredicate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsWafRegionalRateBasedRuleMatchPredicate");
        formatter.field("data_id", &self.data_id);
        formatter.field("negated", &self.negated);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AwsWafRegionalRateBasedRuleMatchPredicate`](crate::model::AwsWafRegionalRateBasedRuleMatchPredicate)
pub mod aws_waf_regional_rate_based_rule_match_predicate {

    /// A builder for [`AwsWafRegionalRateBasedRuleMatchPredicate`](crate::model::AwsWafRegionalRateBasedRuleMatchPredicate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_id: std::option::Option<std::string::String>,
        pub(crate) negated: std::option::Option<bool>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for the predicate.</p>
        pub fn data_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the predicate.</p>
        pub fn set_data_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_id = input;
            self
        }
        /// <p>If set to <code>true</code>, then the rule actions are performed on requests that match the predicate settings.</p>
        /// <p>If set to <code>false</code>, then the rule actions are performed on all requests except those that match the predicate settings.</p>
        pub fn negated(mut self, input: bool) -> Self {
            self.negated = Some(input);
            self
        }
        /// <p>If set to <code>true</code>, then the rule actions are performed on requests that match the predicate settings.</p>
        /// <p>If set to <code>false</code>, then the rule actions are performed on all requests except those that match the predicate settings.</p>
        pub fn set_negated(mut self, input: std::option::Option<bool>) -> Self {
            self.negated = input;
            self
        }
        /// <p>The type of predicate.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of predicate.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsWafRegionalRateBasedRuleMatchPredicate`](crate::model::AwsWafRegionalRateBasedRuleMatchPredicate)
        pub fn build(self) -> crate::model::AwsWafRegionalRateBasedRuleMatchPredicate {
            crate::model::AwsWafRegionalRateBasedRuleMatchPredicate {
                data_id: self.data_id,
                negated: self.negated.unwrap_or_default(),
                r#type: self.r#type,
            }
        }
    }
}
impl AwsWafRegionalRateBasedRuleMatchPredicate {
    /// Creates a new builder-style object to manufacture [`AwsWafRegionalRateBasedRuleMatchPredicate`](crate::model::AwsWafRegionalRateBasedRuleMatchPredicate)
    pub fn builder() -> crate::model::aws_waf_regional_rate_based_rule_match_predicate::Builder {
        crate::model::aws_waf_regional_rate_based_rule_match_predicate::Builder::default()
    }
}

/// <p>Details about a rate-based rule for global resources. A rate-based rule provides settings to indicate when to allow, block, or count a request. Rate-based rules include the number of requests that arrive over a specified period of time.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsWafRateBasedRuleDetails {
    /// <p>The name of the metrics for the rate-based rule.</p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>The name of the rate-based rule.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The field that WAF uses to determine whether requests are likely arriving from single source and are subject to rate monitoring.</p>
    pub rate_key: std::option::Option<std::string::String>,
    /// <p>The maximum number of requests that have an identical value for the field specified in <code>RateKey</code> that are allowed within a five-minute period. If the number of requests exceeds <code>RateLimit</code> and the other predicates specified in the rule are met, WAF triggers the action for the rule.</p>
    pub rate_limit: i64,
    /// <p>The unique identifier for the rate-based rule.</p>
    pub rule_id: std::option::Option<std::string::String>,
    /// <p>The predicates to include in the rate-based rule.</p>
    pub match_predicates:
        std::option::Option<std::vec::Vec<crate::model::AwsWafRateBasedRuleMatchPredicate>>,
}
impl AwsWafRateBasedRuleDetails {
    /// <p>The name of the metrics for the rate-based rule.</p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
    /// <p>The name of the rate-based rule.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The field that WAF uses to determine whether requests are likely arriving from single source and are subject to rate monitoring.</p>
    pub fn rate_key(&self) -> std::option::Option<&str> {
        self.rate_key.as_deref()
    }
    /// <p>The maximum number of requests that have an identical value for the field specified in <code>RateKey</code> that are allowed within a five-minute period. If the number of requests exceeds <code>RateLimit</code> and the other predicates specified in the rule are met, WAF triggers the action for the rule.</p>
    pub fn rate_limit(&self) -> i64 {
        self.rate_limit
    }
    /// <p>The unique identifier for the rate-based rule.</p>
    pub fn rule_id(&self) -> std::option::Option<&str> {
        self.rule_id.as_deref()
    }
    /// <p>The predicates to include in the rate-based rule.</p>
    pub fn match_predicates(
        &self,
    ) -> std::option::Option<&[crate::model::AwsWafRateBasedRuleMatchPredicate]> {
        self.match_predicates.as_deref()
    }
}
impl std::fmt::Debug for AwsWafRateBasedRuleDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsWafRateBasedRuleDetails");
        formatter.field("metric_name", &self.metric_name);
        formatter.field("name", &self.name);
        formatter.field("rate_key", &self.rate_key);
        formatter.field("rate_limit", &self.rate_limit);
        formatter.field("rule_id", &self.rule_id);
        formatter.field("match_predicates", &self.match_predicates);
        formatter.finish()
    }
}
/// See [`AwsWafRateBasedRuleDetails`](crate::model::AwsWafRateBasedRuleDetails)
pub mod aws_waf_rate_based_rule_details {

    /// A builder for [`AwsWafRateBasedRuleDetails`](crate::model::AwsWafRateBasedRuleDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) rate_key: std::option::Option<std::string::String>,
        pub(crate) rate_limit: std::option::Option<i64>,
        pub(crate) rule_id: std::option::Option<std::string::String>,
        pub(crate) match_predicates:
            std::option::Option<std::vec::Vec<crate::model::AwsWafRateBasedRuleMatchPredicate>>,
    }
    impl Builder {
        /// <p>The name of the metrics for the rate-based rule.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>The name of the metrics for the rate-based rule.</p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The name of the rate-based rule.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the rate-based rule.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The field that WAF uses to determine whether requests are likely arriving from single source and are subject to rate monitoring.</p>
        pub fn rate_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.rate_key = Some(input.into());
            self
        }
        /// <p>The field that WAF uses to determine whether requests are likely arriving from single source and are subject to rate monitoring.</p>
        pub fn set_rate_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rate_key = input;
            self
        }
        /// <p>The maximum number of requests that have an identical value for the field specified in <code>RateKey</code> that are allowed within a five-minute period. If the number of requests exceeds <code>RateLimit</code> and the other predicates specified in the rule are met, WAF triggers the action for the rule.</p>
        pub fn rate_limit(mut self, input: i64) -> Self {
            self.rate_limit = Some(input);
            self
        }
        /// <p>The maximum number of requests that have an identical value for the field specified in <code>RateKey</code> that are allowed within a five-minute period. If the number of requests exceeds <code>RateLimit</code> and the other predicates specified in the rule are met, WAF triggers the action for the rule.</p>
        pub fn set_rate_limit(mut self, input: std::option::Option<i64>) -> Self {
            self.rate_limit = input;
            self
        }
        /// <p>The unique identifier for the rate-based rule.</p>
        pub fn rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the rate-based rule.</p>
        pub fn set_rule_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_id = input;
            self
        }
        /// Appends an item to `match_predicates`.
        ///
        /// To override the contents of this collection use [`set_match_predicates`](Self::set_match_predicates).
        ///
        /// <p>The predicates to include in the rate-based rule.</p>
        pub fn match_predicates(
            mut self,
            input: crate::model::AwsWafRateBasedRuleMatchPredicate,
        ) -> Self {
            let mut v = self.match_predicates.unwrap_or_default();
            v.push(input);
            self.match_predicates = Some(v);
            self
        }
        /// <p>The predicates to include in the rate-based rule.</p>
        pub fn set_match_predicates(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsWafRateBasedRuleMatchPredicate>,
            >,
        ) -> Self {
            self.match_predicates = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsWafRateBasedRuleDetails`](crate::model::AwsWafRateBasedRuleDetails)
        pub fn build(self) -> crate::model::AwsWafRateBasedRuleDetails {
            crate::model::AwsWafRateBasedRuleDetails {
                metric_name: self.metric_name,
                name: self.name,
                rate_key: self.rate_key,
                rate_limit: self.rate_limit.unwrap_or_default(),
                rule_id: self.rule_id,
                match_predicates: self.match_predicates,
            }
        }
    }
}
impl AwsWafRateBasedRuleDetails {
    /// Creates a new builder-style object to manufacture [`AwsWafRateBasedRuleDetails`](crate::model::AwsWafRateBasedRuleDetails)
    pub fn builder() -> crate::model::aws_waf_rate_based_rule_details::Builder {
        crate::model::aws_waf_rate_based_rule_details::Builder::default()
    }
}

/// <p>A match predicate. A predicate might look for characteristics such as specific IP addresses, geographic locations, or sizes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsWafRateBasedRuleMatchPredicate {
    /// <p>The unique identifier for the predicate.</p>
    pub data_id: std::option::Option<std::string::String>,
    /// <p>If set to <code>true</code>, then the rule actions are performed on requests that match the predicate settings.</p>
    /// <p>If set to <code>false</code>, then the rule actions are performed on all requests except those that match the predicate settings. </p>
    pub negated: bool,
    /// <p>The type of predicate.</p>
    pub r#type: std::option::Option<std::string::String>,
}
impl AwsWafRateBasedRuleMatchPredicate {
    /// <p>The unique identifier for the predicate.</p>
    pub fn data_id(&self) -> std::option::Option<&str> {
        self.data_id.as_deref()
    }
    /// <p>If set to <code>true</code>, then the rule actions are performed on requests that match the predicate settings.</p>
    /// <p>If set to <code>false</code>, then the rule actions are performed on all requests except those that match the predicate settings. </p>
    pub fn negated(&self) -> bool {
        self.negated
    }
    /// <p>The type of predicate.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for AwsWafRateBasedRuleMatchPredicate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsWafRateBasedRuleMatchPredicate");
        formatter.field("data_id", &self.data_id);
        formatter.field("negated", &self.negated);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AwsWafRateBasedRuleMatchPredicate`](crate::model::AwsWafRateBasedRuleMatchPredicate)
pub mod aws_waf_rate_based_rule_match_predicate {

    /// A builder for [`AwsWafRateBasedRuleMatchPredicate`](crate::model::AwsWafRateBasedRuleMatchPredicate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_id: std::option::Option<std::string::String>,
        pub(crate) negated: std::option::Option<bool>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for the predicate.</p>
        pub fn data_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the predicate.</p>
        pub fn set_data_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_id = input;
            self
        }
        /// <p>If set to <code>true</code>, then the rule actions are performed on requests that match the predicate settings.</p>
        /// <p>If set to <code>false</code>, then the rule actions are performed on all requests except those that match the predicate settings. </p>
        pub fn negated(mut self, input: bool) -> Self {
            self.negated = Some(input);
            self
        }
        /// <p>If set to <code>true</code>, then the rule actions are performed on requests that match the predicate settings.</p>
        /// <p>If set to <code>false</code>, then the rule actions are performed on all requests except those that match the predicate settings. </p>
        pub fn set_negated(mut self, input: std::option::Option<bool>) -> Self {
            self.negated = input;
            self
        }
        /// <p>The type of predicate.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of predicate.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsWafRateBasedRuleMatchPredicate`](crate::model::AwsWafRateBasedRuleMatchPredicate)
        pub fn build(self) -> crate::model::AwsWafRateBasedRuleMatchPredicate {
            crate::model::AwsWafRateBasedRuleMatchPredicate {
                data_id: self.data_id,
                negated: self.negated.unwrap_or_default(),
                r#type: self.r#type,
            }
        }
    }
}
impl AwsWafRateBasedRuleMatchPredicate {
    /// Creates a new builder-style object to manufacture [`AwsWafRateBasedRuleMatchPredicate`](crate::model::AwsWafRateBasedRuleMatchPredicate)
    pub fn builder() -> crate::model::aws_waf_rate_based_rule_match_predicate::Builder {
        crate::model::aws_waf_rate_based_rule_match_predicate::Builder::default()
    }
}

/// <p>Information about the encryption configuration for X-Ray.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsXrayEncryptionConfigDetails {
    /// <p>The identifier of the KMS key that is used for encryption. Provided if <code>Type</code> is <code>KMS</code>.</p>
    pub key_id: std::option::Option<std::string::String>,
    /// <p>The current status of the encryption configuration. When <code>Status</code> is <code>UPDATING</code>, X-Ray might use both the old and new encryption.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>The type of encryption. <code>KMS</code> indicates that the encryption uses KMS keys. <code>NONE</code> indicates to use the default encryption.</p>
    pub r#type: std::option::Option<std::string::String>,
}
impl AwsXrayEncryptionConfigDetails {
    /// <p>The identifier of the KMS key that is used for encryption. Provided if <code>Type</code> is <code>KMS</code>.</p>
    pub fn key_id(&self) -> std::option::Option<&str> {
        self.key_id.as_deref()
    }
    /// <p>The current status of the encryption configuration. When <code>Status</code> is <code>UPDATING</code>, X-Ray might use both the old and new encryption.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>The type of encryption. <code>KMS</code> indicates that the encryption uses KMS keys. <code>NONE</code> indicates to use the default encryption.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for AwsXrayEncryptionConfigDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsXrayEncryptionConfigDetails");
        formatter.field("key_id", &self.key_id);
        formatter.field("status", &self.status);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AwsXrayEncryptionConfigDetails`](crate::model::AwsXrayEncryptionConfigDetails)
pub mod aws_xray_encryption_config_details {

    /// A builder for [`AwsXrayEncryptionConfigDetails`](crate::model::AwsXrayEncryptionConfigDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the KMS key that is used for encryption. Provided if <code>Type</code> is <code>KMS</code>.</p>
        pub fn key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_id = Some(input.into());
            self
        }
        /// <p>The identifier of the KMS key that is used for encryption. Provided if <code>Type</code> is <code>KMS</code>.</p>
        pub fn set_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_id = input;
            self
        }
        /// <p>The current status of the encryption configuration. When <code>Status</code> is <code>UPDATING</code>, X-Ray might use both the old and new encryption.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The current status of the encryption configuration. When <code>Status</code> is <code>UPDATING</code>, X-Ray might use both the old and new encryption.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>The type of encryption. <code>KMS</code> indicates that the encryption uses KMS keys. <code>NONE</code> indicates to use the default encryption.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of encryption. <code>KMS</code> indicates that the encryption uses KMS keys. <code>NONE</code> indicates to use the default encryption.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsXrayEncryptionConfigDetails`](crate::model::AwsXrayEncryptionConfigDetails)
        pub fn build(self) -> crate::model::AwsXrayEncryptionConfigDetails {
            crate::model::AwsXrayEncryptionConfigDetails {
                key_id: self.key_id,
                status: self.status,
                r#type: self.r#type,
            }
        }
    }
}
impl AwsXrayEncryptionConfigDetails {
    /// Creates a new builder-style object to manufacture [`AwsXrayEncryptionConfigDetails`](crate::model::AwsXrayEncryptionConfigDetails)
    pub fn builder() -> crate::model::aws_xray_encryption_config_details::Builder {
        crate::model::aws_xray_encryption_config_details::Builder::default()
    }
}

/// <p>Contains details about the service configuration for a VPC endpoint service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2VpcEndpointServiceDetails {
    /// <p>Whether requests from other Amazon Web Services accounts to create an endpoint to the service must first be accepted.</p>
    pub acceptance_required: bool,
    /// <p>The Availability Zones where the service is available.</p>
    pub availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The DNS names for the service.</p>
    pub base_endpoint_dns_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Whether the service manages its VPC endpoints.</p>
    pub manages_vpc_endpoints: bool,
    /// <p>The ARNs of the Gateway Load Balancers for the service.</p>
    pub gateway_load_balancer_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ARNs of the Network Load Balancers for the service.</p>
    pub network_load_balancer_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The private DNS name for the service.</p>
    pub private_dns_name: std::option::Option<std::string::String>,
    /// <p>The identifier of the service.</p>
    pub service_id: std::option::Option<std::string::String>,
    /// <p>The name of the service.</p>
    pub service_name: std::option::Option<std::string::String>,
    /// <p>The current state of the service.</p>
    pub service_state: std::option::Option<std::string::String>,
    /// <p>The types for the service.</p>
    pub service_type: std::option::Option<
        std::vec::Vec<crate::model::AwsEc2VpcEndpointServiceServiceTypeDetails>,
    >,
}
impl AwsEc2VpcEndpointServiceDetails {
    /// <p>Whether requests from other Amazon Web Services accounts to create an endpoint to the service must first be accepted.</p>
    pub fn acceptance_required(&self) -> bool {
        self.acceptance_required
    }
    /// <p>The Availability Zones where the service is available.</p>
    pub fn availability_zones(&self) -> std::option::Option<&[std::string::String]> {
        self.availability_zones.as_deref()
    }
    /// <p>The DNS names for the service.</p>
    pub fn base_endpoint_dns_names(&self) -> std::option::Option<&[std::string::String]> {
        self.base_endpoint_dns_names.as_deref()
    }
    /// <p>Whether the service manages its VPC endpoints.</p>
    pub fn manages_vpc_endpoints(&self) -> bool {
        self.manages_vpc_endpoints
    }
    /// <p>The ARNs of the Gateway Load Balancers for the service.</p>
    pub fn gateway_load_balancer_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.gateway_load_balancer_arns.as_deref()
    }
    /// <p>The ARNs of the Network Load Balancers for the service.</p>
    pub fn network_load_balancer_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.network_load_balancer_arns.as_deref()
    }
    /// <p>The private DNS name for the service.</p>
    pub fn private_dns_name(&self) -> std::option::Option<&str> {
        self.private_dns_name.as_deref()
    }
    /// <p>The identifier of the service.</p>
    pub fn service_id(&self) -> std::option::Option<&str> {
        self.service_id.as_deref()
    }
    /// <p>The name of the service.</p>
    pub fn service_name(&self) -> std::option::Option<&str> {
        self.service_name.as_deref()
    }
    /// <p>The current state of the service.</p>
    pub fn service_state(&self) -> std::option::Option<&str> {
        self.service_state.as_deref()
    }
    /// <p>The types for the service.</p>
    pub fn service_type(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEc2VpcEndpointServiceServiceTypeDetails]> {
        self.service_type.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2VpcEndpointServiceDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2VpcEndpointServiceDetails");
        formatter.field("acceptance_required", &self.acceptance_required);
        formatter.field("availability_zones", &self.availability_zones);
        formatter.field("base_endpoint_dns_names", &self.base_endpoint_dns_names);
        formatter.field("manages_vpc_endpoints", &self.manages_vpc_endpoints);
        formatter.field(
            "gateway_load_balancer_arns",
            &self.gateway_load_balancer_arns,
        );
        formatter.field(
            "network_load_balancer_arns",
            &self.network_load_balancer_arns,
        );
        formatter.field("private_dns_name", &self.private_dns_name);
        formatter.field("service_id", &self.service_id);
        formatter.field("service_name", &self.service_name);
        formatter.field("service_state", &self.service_state);
        formatter.field("service_type", &self.service_type);
        formatter.finish()
    }
}
/// See [`AwsEc2VpcEndpointServiceDetails`](crate::model::AwsEc2VpcEndpointServiceDetails)
pub mod aws_ec2_vpc_endpoint_service_details {

    /// A builder for [`AwsEc2VpcEndpointServiceDetails`](crate::model::AwsEc2VpcEndpointServiceDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) acceptance_required: std::option::Option<bool>,
        pub(crate) availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) base_endpoint_dns_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) manages_vpc_endpoints: std::option::Option<bool>,
        pub(crate) gateway_load_balancer_arns:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) network_load_balancer_arns:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) private_dns_name: std::option::Option<std::string::String>,
        pub(crate) service_id: std::option::Option<std::string::String>,
        pub(crate) service_name: std::option::Option<std::string::String>,
        pub(crate) service_state: std::option::Option<std::string::String>,
        pub(crate) service_type: std::option::Option<
            std::vec::Vec<crate::model::AwsEc2VpcEndpointServiceServiceTypeDetails>,
        >,
    }
    impl Builder {
        /// <p>Whether requests from other Amazon Web Services accounts to create an endpoint to the service must first be accepted.</p>
        pub fn acceptance_required(mut self, input: bool) -> Self {
            self.acceptance_required = Some(input);
            self
        }
        /// <p>Whether requests from other Amazon Web Services accounts to create an endpoint to the service must first be accepted.</p>
        pub fn set_acceptance_required(mut self, input: std::option::Option<bool>) -> Self {
            self.acceptance_required = input;
            self
        }
        /// Appends an item to `availability_zones`.
        ///
        /// To override the contents of this collection use [`set_availability_zones`](Self::set_availability_zones).
        ///
        /// <p>The Availability Zones where the service is available.</p>
        pub fn availability_zones(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.availability_zones.unwrap_or_default();
            v.push(input.into());
            self.availability_zones = Some(v);
            self
        }
        /// <p>The Availability Zones where the service is available.</p>
        pub fn set_availability_zones(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.availability_zones = input;
            self
        }
        /// Appends an item to `base_endpoint_dns_names`.
        ///
        /// To override the contents of this collection use [`set_base_endpoint_dns_names`](Self::set_base_endpoint_dns_names).
        ///
        /// <p>The DNS names for the service.</p>
        pub fn base_endpoint_dns_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.base_endpoint_dns_names.unwrap_or_default();
            v.push(input.into());
            self.base_endpoint_dns_names = Some(v);
            self
        }
        /// <p>The DNS names for the service.</p>
        pub fn set_base_endpoint_dns_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.base_endpoint_dns_names = input;
            self
        }
        /// <p>Whether the service manages its VPC endpoints.</p>
        pub fn manages_vpc_endpoints(mut self, input: bool) -> Self {
            self.manages_vpc_endpoints = Some(input);
            self
        }
        /// <p>Whether the service manages its VPC endpoints.</p>
        pub fn set_manages_vpc_endpoints(mut self, input: std::option::Option<bool>) -> Self {
            self.manages_vpc_endpoints = input;
            self
        }
        /// Appends an item to `gateway_load_balancer_arns`.
        ///
        /// To override the contents of this collection use [`set_gateway_load_balancer_arns`](Self::set_gateway_load_balancer_arns).
        ///
        /// <p>The ARNs of the Gateway Load Balancers for the service.</p>
        pub fn gateway_load_balancer_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.gateway_load_balancer_arns.unwrap_or_default();
            v.push(input.into());
            self.gateway_load_balancer_arns = Some(v);
            self
        }
        /// <p>The ARNs of the Gateway Load Balancers for the service.</p>
        pub fn set_gateway_load_balancer_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.gateway_load_balancer_arns = input;
            self
        }
        /// Appends an item to `network_load_balancer_arns`.
        ///
        /// To override the contents of this collection use [`set_network_load_balancer_arns`](Self::set_network_load_balancer_arns).
        ///
        /// <p>The ARNs of the Network Load Balancers for the service.</p>
        pub fn network_load_balancer_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.network_load_balancer_arns.unwrap_or_default();
            v.push(input.into());
            self.network_load_balancer_arns = Some(v);
            self
        }
        /// <p>The ARNs of the Network Load Balancers for the service.</p>
        pub fn set_network_load_balancer_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.network_load_balancer_arns = input;
            self
        }
        /// <p>The private DNS name for the service.</p>
        pub fn private_dns_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_dns_name = Some(input.into());
            self
        }
        /// <p>The private DNS name for the service.</p>
        pub fn set_private_dns_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_dns_name = input;
            self
        }
        /// <p>The identifier of the service.</p>
        pub fn service_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_id = Some(input.into());
            self
        }
        /// <p>The identifier of the service.</p>
        pub fn set_service_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_id = input;
            self
        }
        /// <p>The name of the service.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_name = Some(input.into());
            self
        }
        /// <p>The name of the service.</p>
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_name = input;
            self
        }
        /// <p>The current state of the service.</p>
        pub fn service_state(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_state = Some(input.into());
            self
        }
        /// <p>The current state of the service.</p>
        pub fn set_service_state(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.service_state = input;
            self
        }
        /// Appends an item to `service_type`.
        ///
        /// To override the contents of this collection use [`set_service_type`](Self::set_service_type).
        ///
        /// <p>The types for the service.</p>
        pub fn service_type(
            mut self,
            input: crate::model::AwsEc2VpcEndpointServiceServiceTypeDetails,
        ) -> Self {
            let mut v = self.service_type.unwrap_or_default();
            v.push(input);
            self.service_type = Some(v);
            self
        }
        /// <p>The types for the service.</p>
        pub fn set_service_type(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEc2VpcEndpointServiceServiceTypeDetails>,
            >,
        ) -> Self {
            self.service_type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2VpcEndpointServiceDetails`](crate::model::AwsEc2VpcEndpointServiceDetails)
        pub fn build(self) -> crate::model::AwsEc2VpcEndpointServiceDetails {
            crate::model::AwsEc2VpcEndpointServiceDetails {
                acceptance_required: self.acceptance_required.unwrap_or_default(),
                availability_zones: self.availability_zones,
                base_endpoint_dns_names: self.base_endpoint_dns_names,
                manages_vpc_endpoints: self.manages_vpc_endpoints.unwrap_or_default(),
                gateway_load_balancer_arns: self.gateway_load_balancer_arns,
                network_load_balancer_arns: self.network_load_balancer_arns,
                private_dns_name: self.private_dns_name,
                service_id: self.service_id,
                service_name: self.service_name,
                service_state: self.service_state,
                service_type: self.service_type,
            }
        }
    }
}
impl AwsEc2VpcEndpointServiceDetails {
    /// Creates a new builder-style object to manufacture [`AwsEc2VpcEndpointServiceDetails`](crate::model::AwsEc2VpcEndpointServiceDetails)
    pub fn builder() -> crate::model::aws_ec2_vpc_endpoint_service_details::Builder {
        crate::model::aws_ec2_vpc_endpoint_service_details::Builder::default()
    }
}

/// <p>The service type information for a VPC endpoint service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2VpcEndpointServiceServiceTypeDetails {
    /// <p>The type of service.</p>
    pub service_type: std::option::Option<std::string::String>,
}
impl AwsEc2VpcEndpointServiceServiceTypeDetails {
    /// <p>The type of service.</p>
    pub fn service_type(&self) -> std::option::Option<&str> {
        self.service_type.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2VpcEndpointServiceServiceTypeDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2VpcEndpointServiceServiceTypeDetails");
        formatter.field("service_type", &self.service_type);
        formatter.finish()
    }
}
/// See [`AwsEc2VpcEndpointServiceServiceTypeDetails`](crate::model::AwsEc2VpcEndpointServiceServiceTypeDetails)
pub mod aws_ec2_vpc_endpoint_service_service_type_details {

    /// A builder for [`AwsEc2VpcEndpointServiceServiceTypeDetails`](crate::model::AwsEc2VpcEndpointServiceServiceTypeDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of service.</p>
        pub fn service_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_type = Some(input.into());
            self
        }
        /// <p>The type of service.</p>
        pub fn set_service_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2VpcEndpointServiceServiceTypeDetails`](crate::model::AwsEc2VpcEndpointServiceServiceTypeDetails)
        pub fn build(self) -> crate::model::AwsEc2VpcEndpointServiceServiceTypeDetails {
            crate::model::AwsEc2VpcEndpointServiceServiceTypeDetails {
                service_type: self.service_type,
            }
        }
    }
}
impl AwsEc2VpcEndpointServiceServiceTypeDetails {
    /// Creates a new builder-style object to manufacture [`AwsEc2VpcEndpointServiceServiceTypeDetails`](crate::model::AwsEc2VpcEndpointServiceServiceTypeDetails)
    pub fn builder() -> crate::model::aws_ec2_vpc_endpoint_service_service_type_details::Builder {
        crate::model::aws_ec2_vpc_endpoint_service_service_type_details::Builder::default()
    }
}

/// <p>Information about an Amazon OpenSearch Service domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsOpenSearchServiceDomainDetails {
    /// <p>The ARN of the OpenSearch Service domain.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>IAM policy document that specifies the access policies for the OpenSearch Service domain.</p>
    pub access_policies: std::option::Option<std::string::String>,
    /// <p>The name of the endpoint.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The identifier of the domain.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The domain endpoint.</p>
    pub domain_endpoint: std::option::Option<std::string::String>,
    /// <p>The version of the domain engine.</p>
    pub engine_version: std::option::Option<std::string::String>,
    /// <p>Details about the configuration for encryption at rest.</p>
    pub encryption_at_rest_options:
        std::option::Option<crate::model::AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails>,
    /// <p>Details about the configuration for node-to-node encryption.</p>
    pub node_to_node_encryption_options: std::option::Option<
        crate::model::AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails,
    >,
    /// <p>Information about the status of a domain relative to the latest service software.</p>
    pub service_software_options:
        std::option::Option<crate::model::AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails>,
    /// <p>Details about the configuration of an OpenSearch cluster.</p>
    pub cluster_config:
        std::option::Option<crate::model::AwsOpenSearchServiceDomainClusterConfigDetails>,
    /// <p>Additional options for the domain endpoint.</p>
    pub domain_endpoint_options:
        std::option::Option<crate::model::AwsOpenSearchServiceDomainDomainEndpointOptionsDetails>,
    /// <p>Information that OpenSearch Service derives based on <code>VPCOptions</code> for the domain.</p>
    pub vpc_options: std::option::Option<crate::model::AwsOpenSearchServiceDomainVpcOptionsDetails>,
    /// <p>Configures the CloudWatch Logs to publish for the OpenSearch domain.</p>
    pub log_publishing_options:
        std::option::Option<crate::model::AwsOpenSearchServiceDomainLogPublishingOptionsDetails>,
    /// <p>The domain endpoints. Used if the OpenSearch domain resides in a VPC.</p>
    /// <p>This is a map of key-value pairs. The key is always <code>vpc</code>. The value is the endpoint.</p>
    pub domain_endpoints:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Specifies options for fine-grained access control. </p>
    pub advanced_security_options:
        std::option::Option<crate::model::AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails>,
}
impl AwsOpenSearchServiceDomainDetails {
    /// <p>The ARN of the OpenSearch Service domain.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>IAM policy document that specifies the access policies for the OpenSearch Service domain.</p>
    pub fn access_policies(&self) -> std::option::Option<&str> {
        self.access_policies.as_deref()
    }
    /// <p>The name of the endpoint.</p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p>The identifier of the domain.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The domain endpoint.</p>
    pub fn domain_endpoint(&self) -> std::option::Option<&str> {
        self.domain_endpoint.as_deref()
    }
    /// <p>The version of the domain engine.</p>
    pub fn engine_version(&self) -> std::option::Option<&str> {
        self.engine_version.as_deref()
    }
    /// <p>Details about the configuration for encryption at rest.</p>
    pub fn encryption_at_rest_options(
        &self,
    ) -> std::option::Option<&crate::model::AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails>
    {
        self.encryption_at_rest_options.as_ref()
    }
    /// <p>Details about the configuration for node-to-node encryption.</p>
    pub fn node_to_node_encryption_options(
        &self,
    ) -> std::option::Option<
        &crate::model::AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails,
    > {
        self.node_to_node_encryption_options.as_ref()
    }
    /// <p>Information about the status of a domain relative to the latest service software.</p>
    pub fn service_software_options(
        &self,
    ) -> std::option::Option<&crate::model::AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails>
    {
        self.service_software_options.as_ref()
    }
    /// <p>Details about the configuration of an OpenSearch cluster.</p>
    pub fn cluster_config(
        &self,
    ) -> std::option::Option<&crate::model::AwsOpenSearchServiceDomainClusterConfigDetails> {
        self.cluster_config.as_ref()
    }
    /// <p>Additional options for the domain endpoint.</p>
    pub fn domain_endpoint_options(
        &self,
    ) -> std::option::Option<&crate::model::AwsOpenSearchServiceDomainDomainEndpointOptionsDetails>
    {
        self.domain_endpoint_options.as_ref()
    }
    /// <p>Information that OpenSearch Service derives based on <code>VPCOptions</code> for the domain.</p>
    pub fn vpc_options(
        &self,
    ) -> std::option::Option<&crate::model::AwsOpenSearchServiceDomainVpcOptionsDetails> {
        self.vpc_options.as_ref()
    }
    /// <p>Configures the CloudWatch Logs to publish for the OpenSearch domain.</p>
    pub fn log_publishing_options(
        &self,
    ) -> std::option::Option<&crate::model::AwsOpenSearchServiceDomainLogPublishingOptionsDetails>
    {
        self.log_publishing_options.as_ref()
    }
    /// <p>The domain endpoints. Used if the OpenSearch domain resides in a VPC.</p>
    /// <p>This is a map of key-value pairs. The key is always <code>vpc</code>. The value is the endpoint.</p>
    pub fn domain_endpoints(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.domain_endpoints.as_ref()
    }
    /// <p>Specifies options for fine-grained access control. </p>
    pub fn advanced_security_options(
        &self,
    ) -> std::option::Option<&crate::model::AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails>
    {
        self.advanced_security_options.as_ref()
    }
}
impl std::fmt::Debug for AwsOpenSearchServiceDomainDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsOpenSearchServiceDomainDetails");
        formatter.field("arn", &self.arn);
        formatter.field("access_policies", &self.access_policies);
        formatter.field("domain_name", &self.domain_name);
        formatter.field("id", &self.id);
        formatter.field("domain_endpoint", &self.domain_endpoint);
        formatter.field("engine_version", &self.engine_version);
        formatter.field(
            "encryption_at_rest_options",
            &self.encryption_at_rest_options,
        );
        formatter.field(
            "node_to_node_encryption_options",
            &self.node_to_node_encryption_options,
        );
        formatter.field("service_software_options", &self.service_software_options);
        formatter.field("cluster_config", &self.cluster_config);
        formatter.field("domain_endpoint_options", &self.domain_endpoint_options);
        formatter.field("vpc_options", &self.vpc_options);
        formatter.field("log_publishing_options", &self.log_publishing_options);
        formatter.field("domain_endpoints", &self.domain_endpoints);
        formatter.field("advanced_security_options", &self.advanced_security_options);
        formatter.finish()
    }
}
/// See [`AwsOpenSearchServiceDomainDetails`](crate::model::AwsOpenSearchServiceDomainDetails)
pub mod aws_open_search_service_domain_details {

    /// A builder for [`AwsOpenSearchServiceDomainDetails`](crate::model::AwsOpenSearchServiceDomainDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) access_policies: std::option::Option<std::string::String>,
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) domain_endpoint: std::option::Option<std::string::String>,
        pub(crate) engine_version: std::option::Option<std::string::String>,
        pub(crate) encryption_at_rest_options: std::option::Option<
            crate::model::AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails,
        >,
        pub(crate) node_to_node_encryption_options: std::option::Option<
            crate::model::AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails,
        >,
        pub(crate) service_software_options: std::option::Option<
            crate::model::AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails,
        >,
        pub(crate) cluster_config:
            std::option::Option<crate::model::AwsOpenSearchServiceDomainClusterConfigDetails>,
        pub(crate) domain_endpoint_options: std::option::Option<
            crate::model::AwsOpenSearchServiceDomainDomainEndpointOptionsDetails,
        >,
        pub(crate) vpc_options:
            std::option::Option<crate::model::AwsOpenSearchServiceDomainVpcOptionsDetails>,
        pub(crate) log_publishing_options: std::option::Option<
            crate::model::AwsOpenSearchServiceDomainLogPublishingOptionsDetails,
        >,
        pub(crate) domain_endpoints: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) advanced_security_options: std::option::Option<
            crate::model::AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails,
        >,
    }
    impl Builder {
        /// <p>The ARN of the OpenSearch Service domain.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the OpenSearch Service domain.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>IAM policy document that specifies the access policies for the OpenSearch Service domain.</p>
        pub fn access_policies(mut self, input: impl Into<std::string::String>) -> Self {
            self.access_policies = Some(input.into());
            self
        }
        /// <p>IAM policy document that specifies the access policies for the OpenSearch Service domain.</p>
        pub fn set_access_policies(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.access_policies = input;
            self
        }
        /// <p>The name of the endpoint.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>The name of the endpoint.</p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>The identifier of the domain.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the domain.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The domain endpoint.</p>
        pub fn domain_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_endpoint = Some(input.into());
            self
        }
        /// <p>The domain endpoint.</p>
        pub fn set_domain_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.domain_endpoint = input;
            self
        }
        /// <p>The version of the domain engine.</p>
        pub fn engine_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.engine_version = Some(input.into());
            self
        }
        /// <p>The version of the domain engine.</p>
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.engine_version = input;
            self
        }
        /// <p>Details about the configuration for encryption at rest.</p>
        pub fn encryption_at_rest_options(
            mut self,
            input: crate::model::AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails,
        ) -> Self {
            self.encryption_at_rest_options = Some(input);
            self
        }
        /// <p>Details about the configuration for encryption at rest.</p>
        pub fn set_encryption_at_rest_options(
            mut self,
            input: std::option::Option<
                crate::model::AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails,
            >,
        ) -> Self {
            self.encryption_at_rest_options = input;
            self
        }
        /// <p>Details about the configuration for node-to-node encryption.</p>
        pub fn node_to_node_encryption_options(
            mut self,
            input: crate::model::AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails,
        ) -> Self {
            self.node_to_node_encryption_options = Some(input);
            self
        }
        /// <p>Details about the configuration for node-to-node encryption.</p>
        pub fn set_node_to_node_encryption_options(
            mut self,
            input: std::option::Option<
                crate::model::AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails,
            >,
        ) -> Self {
            self.node_to_node_encryption_options = input;
            self
        }
        /// <p>Information about the status of a domain relative to the latest service software.</p>
        pub fn service_software_options(
            mut self,
            input: crate::model::AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails,
        ) -> Self {
            self.service_software_options = Some(input);
            self
        }
        /// <p>Information about the status of a domain relative to the latest service software.</p>
        pub fn set_service_software_options(
            mut self,
            input: std::option::Option<
                crate::model::AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails,
            >,
        ) -> Self {
            self.service_software_options = input;
            self
        }
        /// <p>Details about the configuration of an OpenSearch cluster.</p>
        pub fn cluster_config(
            mut self,
            input: crate::model::AwsOpenSearchServiceDomainClusterConfigDetails,
        ) -> Self {
            self.cluster_config = Some(input);
            self
        }
        /// <p>Details about the configuration of an OpenSearch cluster.</p>
        pub fn set_cluster_config(
            mut self,
            input: std::option::Option<
                crate::model::AwsOpenSearchServiceDomainClusterConfigDetails,
            >,
        ) -> Self {
            self.cluster_config = input;
            self
        }
        /// <p>Additional options for the domain endpoint.</p>
        pub fn domain_endpoint_options(
            mut self,
            input: crate::model::AwsOpenSearchServiceDomainDomainEndpointOptionsDetails,
        ) -> Self {
            self.domain_endpoint_options = Some(input);
            self
        }
        /// <p>Additional options for the domain endpoint.</p>
        pub fn set_domain_endpoint_options(
            mut self,
            input: std::option::Option<
                crate::model::AwsOpenSearchServiceDomainDomainEndpointOptionsDetails,
            >,
        ) -> Self {
            self.domain_endpoint_options = input;
            self
        }
        /// <p>Information that OpenSearch Service derives based on <code>VPCOptions</code> for the domain.</p>
        pub fn vpc_options(
            mut self,
            input: crate::model::AwsOpenSearchServiceDomainVpcOptionsDetails,
        ) -> Self {
            self.vpc_options = Some(input);
            self
        }
        /// <p>Information that OpenSearch Service derives based on <code>VPCOptions</code> for the domain.</p>
        pub fn set_vpc_options(
            mut self,
            input: std::option::Option<crate::model::AwsOpenSearchServiceDomainVpcOptionsDetails>,
        ) -> Self {
            self.vpc_options = input;
            self
        }
        /// <p>Configures the CloudWatch Logs to publish for the OpenSearch domain.</p>
        pub fn log_publishing_options(
            mut self,
            input: crate::model::AwsOpenSearchServiceDomainLogPublishingOptionsDetails,
        ) -> Self {
            self.log_publishing_options = Some(input);
            self
        }
        /// <p>Configures the CloudWatch Logs to publish for the OpenSearch domain.</p>
        pub fn set_log_publishing_options(
            mut self,
            input: std::option::Option<
                crate::model::AwsOpenSearchServiceDomainLogPublishingOptionsDetails,
            >,
        ) -> Self {
            self.log_publishing_options = input;
            self
        }
        /// Adds a key-value pair to `domain_endpoints`.
        ///
        /// To override the contents of this collection use [`set_domain_endpoints`](Self::set_domain_endpoints).
        ///
        /// <p>The domain endpoints. Used if the OpenSearch domain resides in a VPC.</p>
        /// <p>This is a map of key-value pairs. The key is always <code>vpc</code>. The value is the endpoint.</p>
        pub fn domain_endpoints(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.domain_endpoints.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.domain_endpoints = Some(hash_map);
            self
        }
        /// <p>The domain endpoints. Used if the OpenSearch domain resides in a VPC.</p>
        /// <p>This is a map of key-value pairs. The key is always <code>vpc</code>. The value is the endpoint.</p>
        pub fn set_domain_endpoints(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.domain_endpoints = input;
            self
        }
        /// <p>Specifies options for fine-grained access control. </p>
        pub fn advanced_security_options(
            mut self,
            input: crate::model::AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails,
        ) -> Self {
            self.advanced_security_options = Some(input);
            self
        }
        /// <p>Specifies options for fine-grained access control. </p>
        pub fn set_advanced_security_options(
            mut self,
            input: std::option::Option<
                crate::model::AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails,
            >,
        ) -> Self {
            self.advanced_security_options = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsOpenSearchServiceDomainDetails`](crate::model::AwsOpenSearchServiceDomainDetails)
        pub fn build(self) -> crate::model::AwsOpenSearchServiceDomainDetails {
            crate::model::AwsOpenSearchServiceDomainDetails {
                arn: self.arn,
                access_policies: self.access_policies,
                domain_name: self.domain_name,
                id: self.id,
                domain_endpoint: self.domain_endpoint,
                engine_version: self.engine_version,
                encryption_at_rest_options: self.encryption_at_rest_options,
                node_to_node_encryption_options: self.node_to_node_encryption_options,
                service_software_options: self.service_software_options,
                cluster_config: self.cluster_config,
                domain_endpoint_options: self.domain_endpoint_options,
                vpc_options: self.vpc_options,
                log_publishing_options: self.log_publishing_options,
                domain_endpoints: self.domain_endpoints,
                advanced_security_options: self.advanced_security_options,
            }
        }
    }
}
impl AwsOpenSearchServiceDomainDetails {
    /// Creates a new builder-style object to manufacture [`AwsOpenSearchServiceDomainDetails`](crate::model::AwsOpenSearchServiceDomainDetails)
    pub fn builder() -> crate::model::aws_open_search_service_domain_details::Builder {
        crate::model::aws_open_search_service_domain_details::Builder::default()
    }
}

/// <p>Provides information about domain access control options. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails {
    /// <p>Enables fine-grained access control. </p>
    pub enabled: bool,
    /// <p>Enables the internal user database. </p>
    pub internal_user_database_enabled: bool,
    /// <p>Specifies information about the master user of the domain. </p>
    pub master_user_options:
        std::option::Option<crate::model::AwsOpenSearchServiceDomainMasterUserOptionsDetails>,
}
impl AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails {
    /// <p>Enables fine-grained access control. </p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
    /// <p>Enables the internal user database. </p>
    pub fn internal_user_database_enabled(&self) -> bool {
        self.internal_user_database_enabled
    }
    /// <p>Specifies information about the master user of the domain. </p>
    pub fn master_user_options(
        &self,
    ) -> std::option::Option<&crate::model::AwsOpenSearchServiceDomainMasterUserOptionsDetails>
    {
        self.master_user_options.as_ref()
    }
}
impl std::fmt::Debug for AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails");
        formatter.field("enabled", &self.enabled);
        formatter.field(
            "internal_user_database_enabled",
            &self.internal_user_database_enabled,
        );
        formatter.field("master_user_options", &self.master_user_options);
        formatter.finish()
    }
}
/// See [`AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails`](crate::model::AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails)
pub mod aws_open_search_service_domain_advanced_security_options_details {

    /// A builder for [`AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails`](crate::model::AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) internal_user_database_enabled: std::option::Option<bool>,
        pub(crate) master_user_options:
            std::option::Option<crate::model::AwsOpenSearchServiceDomainMasterUserOptionsDetails>,
    }
    impl Builder {
        /// <p>Enables fine-grained access control. </p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Enables fine-grained access control. </p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>Enables the internal user database. </p>
        pub fn internal_user_database_enabled(mut self, input: bool) -> Self {
            self.internal_user_database_enabled = Some(input);
            self
        }
        /// <p>Enables the internal user database. </p>
        pub fn set_internal_user_database_enabled(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.internal_user_database_enabled = input;
            self
        }
        /// <p>Specifies information about the master user of the domain. </p>
        pub fn master_user_options(
            mut self,
            input: crate::model::AwsOpenSearchServiceDomainMasterUserOptionsDetails,
        ) -> Self {
            self.master_user_options = Some(input);
            self
        }
        /// <p>Specifies information about the master user of the domain. </p>
        pub fn set_master_user_options(
            mut self,
            input: std::option::Option<
                crate::model::AwsOpenSearchServiceDomainMasterUserOptionsDetails,
            >,
        ) -> Self {
            self.master_user_options = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails`](crate::model::AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails {
            crate::model::AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails {
                enabled: self.enabled.unwrap_or_default(),
                internal_user_database_enabled: self
                    .internal_user_database_enabled
                    .unwrap_or_default(),
                master_user_options: self.master_user_options,
            }
        }
    }
}
impl AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails {
    /// Creates a new builder-style object to manufacture [`AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails`](crate::model::AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails)
    pub fn builder(
    ) -> crate::model::aws_open_search_service_domain_advanced_security_options_details::Builder
    {
        crate::model::aws_open_search_service_domain_advanced_security_options_details::Builder::default()
    }
}

/// <p>Specifies information about the master user of the domain. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsOpenSearchServiceDomainMasterUserOptionsDetails {
    /// <p>The Amazon Resource Name (ARN) for the master user. </p>
    pub master_user_arn: std::option::Option<std::string::String>,
    /// <p>The username for the master user. </p>
    pub master_user_name: std::option::Option<std::string::String>,
    /// <p>The password for the master user. </p>
    pub master_user_password: std::option::Option<std::string::String>,
}
impl AwsOpenSearchServiceDomainMasterUserOptionsDetails {
    /// <p>The Amazon Resource Name (ARN) for the master user. </p>
    pub fn master_user_arn(&self) -> std::option::Option<&str> {
        self.master_user_arn.as_deref()
    }
    /// <p>The username for the master user. </p>
    pub fn master_user_name(&self) -> std::option::Option<&str> {
        self.master_user_name.as_deref()
    }
    /// <p>The password for the master user. </p>
    pub fn master_user_password(&self) -> std::option::Option<&str> {
        self.master_user_password.as_deref()
    }
}
impl std::fmt::Debug for AwsOpenSearchServiceDomainMasterUserOptionsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsOpenSearchServiceDomainMasterUserOptionsDetails");
        formatter.field("master_user_arn", &self.master_user_arn);
        formatter.field("master_user_name", &self.master_user_name);
        formatter.field("master_user_password", &self.master_user_password);
        formatter.finish()
    }
}
/// See [`AwsOpenSearchServiceDomainMasterUserOptionsDetails`](crate::model::AwsOpenSearchServiceDomainMasterUserOptionsDetails)
pub mod aws_open_search_service_domain_master_user_options_details {

    /// A builder for [`AwsOpenSearchServiceDomainMasterUserOptionsDetails`](crate::model::AwsOpenSearchServiceDomainMasterUserOptionsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) master_user_arn: std::option::Option<std::string::String>,
        pub(crate) master_user_name: std::option::Option<std::string::String>,
        pub(crate) master_user_password: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) for the master user. </p>
        pub fn master_user_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_user_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the master user. </p>
        pub fn set_master_user_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_user_arn = input;
            self
        }
        /// <p>The username for the master user. </p>
        pub fn master_user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_user_name = Some(input.into());
            self
        }
        /// <p>The username for the master user. </p>
        pub fn set_master_user_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_user_name = input;
            self
        }
        /// <p>The password for the master user. </p>
        pub fn master_user_password(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_user_password = Some(input.into());
            self
        }
        /// <p>The password for the master user. </p>
        pub fn set_master_user_password(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_user_password = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsOpenSearchServiceDomainMasterUserOptionsDetails`](crate::model::AwsOpenSearchServiceDomainMasterUserOptionsDetails)
        pub fn build(self) -> crate::model::AwsOpenSearchServiceDomainMasterUserOptionsDetails {
            crate::model::AwsOpenSearchServiceDomainMasterUserOptionsDetails {
                master_user_arn: self.master_user_arn,
                master_user_name: self.master_user_name,
                master_user_password: self.master_user_password,
            }
        }
    }
}
impl AwsOpenSearchServiceDomainMasterUserOptionsDetails {
    /// Creates a new builder-style object to manufacture [`AwsOpenSearchServiceDomainMasterUserOptionsDetails`](crate::model::AwsOpenSearchServiceDomainMasterUserOptionsDetails)
    pub fn builder(
    ) -> crate::model::aws_open_search_service_domain_master_user_options_details::Builder {
        crate::model::aws_open_search_service_domain_master_user_options_details::Builder::default()
    }
}

/// <p>Configures the CloudWatch Logs to publish for the OpenSearch domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsOpenSearchServiceDomainLogPublishingOptionsDetails {
    /// <p>Configures the OpenSearch index logs publishing.</p>
    pub index_slow_logs:
        std::option::Option<crate::model::AwsOpenSearchServiceDomainLogPublishingOption>,
    /// <p>Configures the OpenSearch search slow log publishing.</p>
    pub search_slow_logs:
        std::option::Option<crate::model::AwsOpenSearchServiceDomainLogPublishingOption>,
    /// <p>Configures the OpenSearch audit logs publishing.</p>
    pub audit_logs:
        std::option::Option<crate::model::AwsOpenSearchServiceDomainLogPublishingOption>,
}
impl AwsOpenSearchServiceDomainLogPublishingOptionsDetails {
    /// <p>Configures the OpenSearch index logs publishing.</p>
    pub fn index_slow_logs(
        &self,
    ) -> std::option::Option<&crate::model::AwsOpenSearchServiceDomainLogPublishingOption> {
        self.index_slow_logs.as_ref()
    }
    /// <p>Configures the OpenSearch search slow log publishing.</p>
    pub fn search_slow_logs(
        &self,
    ) -> std::option::Option<&crate::model::AwsOpenSearchServiceDomainLogPublishingOption> {
        self.search_slow_logs.as_ref()
    }
    /// <p>Configures the OpenSearch audit logs publishing.</p>
    pub fn audit_logs(
        &self,
    ) -> std::option::Option<&crate::model::AwsOpenSearchServiceDomainLogPublishingOption> {
        self.audit_logs.as_ref()
    }
}
impl std::fmt::Debug for AwsOpenSearchServiceDomainLogPublishingOptionsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsOpenSearchServiceDomainLogPublishingOptionsDetails");
        formatter.field("index_slow_logs", &self.index_slow_logs);
        formatter.field("search_slow_logs", &self.search_slow_logs);
        formatter.field("audit_logs", &self.audit_logs);
        formatter.finish()
    }
}
/// See [`AwsOpenSearchServiceDomainLogPublishingOptionsDetails`](crate::model::AwsOpenSearchServiceDomainLogPublishingOptionsDetails)
pub mod aws_open_search_service_domain_log_publishing_options_details {

    /// A builder for [`AwsOpenSearchServiceDomainLogPublishingOptionsDetails`](crate::model::AwsOpenSearchServiceDomainLogPublishingOptionsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_slow_logs:
            std::option::Option<crate::model::AwsOpenSearchServiceDomainLogPublishingOption>,
        pub(crate) search_slow_logs:
            std::option::Option<crate::model::AwsOpenSearchServiceDomainLogPublishingOption>,
        pub(crate) audit_logs:
            std::option::Option<crate::model::AwsOpenSearchServiceDomainLogPublishingOption>,
    }
    impl Builder {
        /// <p>Configures the OpenSearch index logs publishing.</p>
        pub fn index_slow_logs(
            mut self,
            input: crate::model::AwsOpenSearchServiceDomainLogPublishingOption,
        ) -> Self {
            self.index_slow_logs = Some(input);
            self
        }
        /// <p>Configures the OpenSearch index logs publishing.</p>
        pub fn set_index_slow_logs(
            mut self,
            input: std::option::Option<crate::model::AwsOpenSearchServiceDomainLogPublishingOption>,
        ) -> Self {
            self.index_slow_logs = input;
            self
        }
        /// <p>Configures the OpenSearch search slow log publishing.</p>
        pub fn search_slow_logs(
            mut self,
            input: crate::model::AwsOpenSearchServiceDomainLogPublishingOption,
        ) -> Self {
            self.search_slow_logs = Some(input);
            self
        }
        /// <p>Configures the OpenSearch search slow log publishing.</p>
        pub fn set_search_slow_logs(
            mut self,
            input: std::option::Option<crate::model::AwsOpenSearchServiceDomainLogPublishingOption>,
        ) -> Self {
            self.search_slow_logs = input;
            self
        }
        /// <p>Configures the OpenSearch audit logs publishing.</p>
        pub fn audit_logs(
            mut self,
            input: crate::model::AwsOpenSearchServiceDomainLogPublishingOption,
        ) -> Self {
            self.audit_logs = Some(input);
            self
        }
        /// <p>Configures the OpenSearch audit logs publishing.</p>
        pub fn set_audit_logs(
            mut self,
            input: std::option::Option<crate::model::AwsOpenSearchServiceDomainLogPublishingOption>,
        ) -> Self {
            self.audit_logs = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsOpenSearchServiceDomainLogPublishingOptionsDetails`](crate::model::AwsOpenSearchServiceDomainLogPublishingOptionsDetails)
        pub fn build(self) -> crate::model::AwsOpenSearchServiceDomainLogPublishingOptionsDetails {
            crate::model::AwsOpenSearchServiceDomainLogPublishingOptionsDetails {
                index_slow_logs: self.index_slow_logs,
                search_slow_logs: self.search_slow_logs,
                audit_logs: self.audit_logs,
            }
        }
    }
}
impl AwsOpenSearchServiceDomainLogPublishingOptionsDetails {
    /// Creates a new builder-style object to manufacture [`AwsOpenSearchServiceDomainLogPublishingOptionsDetails`](crate::model::AwsOpenSearchServiceDomainLogPublishingOptionsDetails)
    pub fn builder(
    ) -> crate::model::aws_open_search_service_domain_log_publishing_options_details::Builder {
        crate::model::aws_open_search_service_domain_log_publishing_options_details::Builder::default()
    }
}

/// <p>Configuration details for a log publishing option.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsOpenSearchServiceDomainLogPublishingOption {
    /// <p>The ARN of the CloudWatch Logs group to publish the logs to.</p>
    pub cloud_watch_logs_log_group_arn: std::option::Option<std::string::String>,
    /// <p>Whether the log publishing is enabled.</p>
    pub enabled: bool,
}
impl AwsOpenSearchServiceDomainLogPublishingOption {
    /// <p>The ARN of the CloudWatch Logs group to publish the logs to.</p>
    pub fn cloud_watch_logs_log_group_arn(&self) -> std::option::Option<&str> {
        self.cloud_watch_logs_log_group_arn.as_deref()
    }
    /// <p>Whether the log publishing is enabled.</p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
}
impl std::fmt::Debug for AwsOpenSearchServiceDomainLogPublishingOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsOpenSearchServiceDomainLogPublishingOption");
        formatter.field(
            "cloud_watch_logs_log_group_arn",
            &self.cloud_watch_logs_log_group_arn,
        );
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`AwsOpenSearchServiceDomainLogPublishingOption`](crate::model::AwsOpenSearchServiceDomainLogPublishingOption)
pub mod aws_open_search_service_domain_log_publishing_option {

    /// A builder for [`AwsOpenSearchServiceDomainLogPublishingOption`](crate::model::AwsOpenSearchServiceDomainLogPublishingOption)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cloud_watch_logs_log_group_arn: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The ARN of the CloudWatch Logs group to publish the logs to.</p>
        pub fn cloud_watch_logs_log_group_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.cloud_watch_logs_log_group_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the CloudWatch Logs group to publish the logs to.</p>
        pub fn set_cloud_watch_logs_log_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cloud_watch_logs_log_group_arn = input;
            self
        }
        /// <p>Whether the log publishing is enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Whether the log publishing is enabled.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsOpenSearchServiceDomainLogPublishingOption`](crate::model::AwsOpenSearchServiceDomainLogPublishingOption)
        pub fn build(self) -> crate::model::AwsOpenSearchServiceDomainLogPublishingOption {
            crate::model::AwsOpenSearchServiceDomainLogPublishingOption {
                cloud_watch_logs_log_group_arn: self.cloud_watch_logs_log_group_arn,
                enabled: self.enabled.unwrap_or_default(),
            }
        }
    }
}
impl AwsOpenSearchServiceDomainLogPublishingOption {
    /// Creates a new builder-style object to manufacture [`AwsOpenSearchServiceDomainLogPublishingOption`](crate::model::AwsOpenSearchServiceDomainLogPublishingOption)
    pub fn builder() -> crate::model::aws_open_search_service_domain_log_publishing_option::Builder
    {
        crate::model::aws_open_search_service_domain_log_publishing_option::Builder::default()
    }
}

/// <p>Contains information that OpenSearch Service derives based on the <code>VPCOptions</code> for the domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsOpenSearchServiceDomainVpcOptionsDetails {
    /// <p>The list of security group IDs that are associated with the VPC endpoints for the domain.</p>
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of subnet IDs that are associated with the VPC endpoints for the domain.</p>
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AwsOpenSearchServiceDomainVpcOptionsDetails {
    /// <p>The list of security group IDs that are associated with the VPC endpoints for the domain.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
    /// <p>A list of subnet IDs that are associated with the VPC endpoints for the domain.</p>
    pub fn subnet_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_ids.as_deref()
    }
}
impl std::fmt::Debug for AwsOpenSearchServiceDomainVpcOptionsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsOpenSearchServiceDomainVpcOptionsDetails");
        formatter.field("security_group_ids", &self.security_group_ids);
        formatter.field("subnet_ids", &self.subnet_ids);
        formatter.finish()
    }
}
/// See [`AwsOpenSearchServiceDomainVpcOptionsDetails`](crate::model::AwsOpenSearchServiceDomainVpcOptionsDetails)
pub mod aws_open_search_service_domain_vpc_options_details {

    /// A builder for [`AwsOpenSearchServiceDomainVpcOptionsDetails`](crate::model::AwsOpenSearchServiceDomainVpcOptionsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
        ///
        /// <p>The list of security group IDs that are associated with the VPC endpoints for the domain.</p>
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        /// <p>The list of security group IDs that are associated with the VPC endpoints for the domain.</p>
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// Appends an item to `subnet_ids`.
        ///
        /// To override the contents of this collection use [`set_subnet_ids`](Self::set_subnet_ids).
        ///
        /// <p>A list of subnet IDs that are associated with the VPC endpoints for the domain.</p>
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        /// <p>A list of subnet IDs that are associated with the VPC endpoints for the domain.</p>
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsOpenSearchServiceDomainVpcOptionsDetails`](crate::model::AwsOpenSearchServiceDomainVpcOptionsDetails)
        pub fn build(self) -> crate::model::AwsOpenSearchServiceDomainVpcOptionsDetails {
            crate::model::AwsOpenSearchServiceDomainVpcOptionsDetails {
                security_group_ids: self.security_group_ids,
                subnet_ids: self.subnet_ids,
            }
        }
    }
}
impl AwsOpenSearchServiceDomainVpcOptionsDetails {
    /// Creates a new builder-style object to manufacture [`AwsOpenSearchServiceDomainVpcOptionsDetails`](crate::model::AwsOpenSearchServiceDomainVpcOptionsDetails)
    pub fn builder() -> crate::model::aws_open_search_service_domain_vpc_options_details::Builder {
        crate::model::aws_open_search_service_domain_vpc_options_details::Builder::default()
    }
}

/// <p>Information about additional options for the domain endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsOpenSearchServiceDomainDomainEndpointOptionsDetails {
    /// <p>The ARN for the security certificate. The certificate is managed in ACM.</p>
    pub custom_endpoint_certificate_arn: std::option::Option<std::string::String>,
    /// <p>Whether to enable a custom endpoint for the domain.</p>
    pub custom_endpoint_enabled: bool,
    /// <p>Whether to require that all traffic to the domain arrive over HTTPS.</p>
    pub enforce_https: bool,
    /// <p>The fully qualified URL for the custom endpoint.</p>
    pub custom_endpoint: std::option::Option<std::string::String>,
    /// <p>The TLS security policy to apply to the HTTPS endpoint of the OpenSearch domain.</p>
    pub tls_security_policy: std::option::Option<std::string::String>,
}
impl AwsOpenSearchServiceDomainDomainEndpointOptionsDetails {
    /// <p>The ARN for the security certificate. The certificate is managed in ACM.</p>
    pub fn custom_endpoint_certificate_arn(&self) -> std::option::Option<&str> {
        self.custom_endpoint_certificate_arn.as_deref()
    }
    /// <p>Whether to enable a custom endpoint for the domain.</p>
    pub fn custom_endpoint_enabled(&self) -> bool {
        self.custom_endpoint_enabled
    }
    /// <p>Whether to require that all traffic to the domain arrive over HTTPS.</p>
    pub fn enforce_https(&self) -> bool {
        self.enforce_https
    }
    /// <p>The fully qualified URL for the custom endpoint.</p>
    pub fn custom_endpoint(&self) -> std::option::Option<&str> {
        self.custom_endpoint.as_deref()
    }
    /// <p>The TLS security policy to apply to the HTTPS endpoint of the OpenSearch domain.</p>
    pub fn tls_security_policy(&self) -> std::option::Option<&str> {
        self.tls_security_policy.as_deref()
    }
}
impl std::fmt::Debug for AwsOpenSearchServiceDomainDomainEndpointOptionsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsOpenSearchServiceDomainDomainEndpointOptionsDetails");
        formatter.field(
            "custom_endpoint_certificate_arn",
            &self.custom_endpoint_certificate_arn,
        );
        formatter.field("custom_endpoint_enabled", &self.custom_endpoint_enabled);
        formatter.field("enforce_https", &self.enforce_https);
        formatter.field("custom_endpoint", &self.custom_endpoint);
        formatter.field("tls_security_policy", &self.tls_security_policy);
        formatter.finish()
    }
}
/// See [`AwsOpenSearchServiceDomainDomainEndpointOptionsDetails`](crate::model::AwsOpenSearchServiceDomainDomainEndpointOptionsDetails)
pub mod aws_open_search_service_domain_domain_endpoint_options_details {

    /// A builder for [`AwsOpenSearchServiceDomainDomainEndpointOptionsDetails`](crate::model::AwsOpenSearchServiceDomainDomainEndpointOptionsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) custom_endpoint_certificate_arn: std::option::Option<std::string::String>,
        pub(crate) custom_endpoint_enabled: std::option::Option<bool>,
        pub(crate) enforce_https: std::option::Option<bool>,
        pub(crate) custom_endpoint: std::option::Option<std::string::String>,
        pub(crate) tls_security_policy: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN for the security certificate. The certificate is managed in ACM.</p>
        pub fn custom_endpoint_certificate_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.custom_endpoint_certificate_arn = Some(input.into());
            self
        }
        /// <p>The ARN for the security certificate. The certificate is managed in ACM.</p>
        pub fn set_custom_endpoint_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.custom_endpoint_certificate_arn = input;
            self
        }
        /// <p>Whether to enable a custom endpoint for the domain.</p>
        pub fn custom_endpoint_enabled(mut self, input: bool) -> Self {
            self.custom_endpoint_enabled = Some(input);
            self
        }
        /// <p>Whether to enable a custom endpoint for the domain.</p>
        pub fn set_custom_endpoint_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.custom_endpoint_enabled = input;
            self
        }
        /// <p>Whether to require that all traffic to the domain arrive over HTTPS.</p>
        pub fn enforce_https(mut self, input: bool) -> Self {
            self.enforce_https = Some(input);
            self
        }
        /// <p>Whether to require that all traffic to the domain arrive over HTTPS.</p>
        pub fn set_enforce_https(mut self, input: std::option::Option<bool>) -> Self {
            self.enforce_https = input;
            self
        }
        /// <p>The fully qualified URL for the custom endpoint.</p>
        pub fn custom_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_endpoint = Some(input.into());
            self
        }
        /// <p>The fully qualified URL for the custom endpoint.</p>
        pub fn set_custom_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.custom_endpoint = input;
            self
        }
        /// <p>The TLS security policy to apply to the HTTPS endpoint of the OpenSearch domain.</p>
        pub fn tls_security_policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.tls_security_policy = Some(input.into());
            self
        }
        /// <p>The TLS security policy to apply to the HTTPS endpoint of the OpenSearch domain.</p>
        pub fn set_tls_security_policy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tls_security_policy = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsOpenSearchServiceDomainDomainEndpointOptionsDetails`](crate::model::AwsOpenSearchServiceDomainDomainEndpointOptionsDetails)
        pub fn build(self) -> crate::model::AwsOpenSearchServiceDomainDomainEndpointOptionsDetails {
            crate::model::AwsOpenSearchServiceDomainDomainEndpointOptionsDetails {
                custom_endpoint_certificate_arn: self.custom_endpoint_certificate_arn,
                custom_endpoint_enabled: self.custom_endpoint_enabled.unwrap_or_default(),
                enforce_https: self.enforce_https.unwrap_or_default(),
                custom_endpoint: self.custom_endpoint,
                tls_security_policy: self.tls_security_policy,
            }
        }
    }
}
impl AwsOpenSearchServiceDomainDomainEndpointOptionsDetails {
    /// Creates a new builder-style object to manufacture [`AwsOpenSearchServiceDomainDomainEndpointOptionsDetails`](crate::model::AwsOpenSearchServiceDomainDomainEndpointOptionsDetails)
    pub fn builder(
    ) -> crate::model::aws_open_search_service_domain_domain_endpoint_options_details::Builder {
        crate::model::aws_open_search_service_domain_domain_endpoint_options_details::Builder::default()
    }
}

/// <p>Details about the configuration of an OpenSearch cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsOpenSearchServiceDomainClusterConfigDetails {
    /// <p>The number of data nodes to use in the OpenSearch domain.</p>
    pub instance_count: i32,
    /// <p>Whether UltraWarm is enabled.</p>
    pub warm_enabled: bool,
    /// <p>The number of UltraWarm instances.</p>
    pub warm_count: i32,
    /// <p>Whether to use a dedicated master node for the OpenSearch domain. A dedicated master node performs cluster management tasks, but does not hold data or respond to data upload requests.</p>
    pub dedicated_master_enabled: bool,
    /// <p>Configuration options for zone awareness. Provided if <code>ZoneAwarenessEnabled</code> is <code>true</code>.</p>
    pub zone_awareness_config: std::option::Option<
        crate::model::AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails,
    >,
    /// <p>The number of instances to use for the master node. If this attribute is specified, then <code>DedicatedMasterEnabled</code> must be <code>true</code>.</p>
    pub dedicated_master_count: i32,
    /// <p>The instance type for your data nodes. </p>
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>The type of UltraWarm instance.</p>
    pub warm_type: std::option::Option<std::string::String>,
    /// <p>Whether to enable zone awareness for the OpenSearch domain. When zone awareness is enabled, OpenSearch Service allocates the cluster's nodes and replica index shards across Availability Zones (AZs) in the same Region. This prevents data loss and minimizes downtime if a node or data center fails.</p>
    pub zone_awareness_enabled: bool,
    /// <p>The hardware configuration of the computer that hosts the dedicated master node.</p>
    /// <p>If this attribute is specified, then <code>DedicatedMasterEnabled</code> must be <code>true</code>. </p>
    pub dedicated_master_type: std::option::Option<std::string::String>,
}
impl AwsOpenSearchServiceDomainClusterConfigDetails {
    /// <p>The number of data nodes to use in the OpenSearch domain.</p>
    pub fn instance_count(&self) -> i32 {
        self.instance_count
    }
    /// <p>Whether UltraWarm is enabled.</p>
    pub fn warm_enabled(&self) -> bool {
        self.warm_enabled
    }
    /// <p>The number of UltraWarm instances.</p>
    pub fn warm_count(&self) -> i32 {
        self.warm_count
    }
    /// <p>Whether to use a dedicated master node for the OpenSearch domain. A dedicated master node performs cluster management tasks, but does not hold data or respond to data upload requests.</p>
    pub fn dedicated_master_enabled(&self) -> bool {
        self.dedicated_master_enabled
    }
    /// <p>Configuration options for zone awareness. Provided if <code>ZoneAwarenessEnabled</code> is <code>true</code>.</p>
    pub fn zone_awareness_config(
        &self,
    ) -> std::option::Option<
        &crate::model::AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails,
    > {
        self.zone_awareness_config.as_ref()
    }
    /// <p>The number of instances to use for the master node. If this attribute is specified, then <code>DedicatedMasterEnabled</code> must be <code>true</code>.</p>
    pub fn dedicated_master_count(&self) -> i32 {
        self.dedicated_master_count
    }
    /// <p>The instance type for your data nodes. </p>
    pub fn instance_type(&self) -> std::option::Option<&str> {
        self.instance_type.as_deref()
    }
    /// <p>The type of UltraWarm instance.</p>
    pub fn warm_type(&self) -> std::option::Option<&str> {
        self.warm_type.as_deref()
    }
    /// <p>Whether to enable zone awareness for the OpenSearch domain. When zone awareness is enabled, OpenSearch Service allocates the cluster's nodes and replica index shards across Availability Zones (AZs) in the same Region. This prevents data loss and minimizes downtime if a node or data center fails.</p>
    pub fn zone_awareness_enabled(&self) -> bool {
        self.zone_awareness_enabled
    }
    /// <p>The hardware configuration of the computer that hosts the dedicated master node.</p>
    /// <p>If this attribute is specified, then <code>DedicatedMasterEnabled</code> must be <code>true</code>. </p>
    pub fn dedicated_master_type(&self) -> std::option::Option<&str> {
        self.dedicated_master_type.as_deref()
    }
}
impl std::fmt::Debug for AwsOpenSearchServiceDomainClusterConfigDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsOpenSearchServiceDomainClusterConfigDetails");
        formatter.field("instance_count", &self.instance_count);
        formatter.field("warm_enabled", &self.warm_enabled);
        formatter.field("warm_count", &self.warm_count);
        formatter.field("dedicated_master_enabled", &self.dedicated_master_enabled);
        formatter.field("zone_awareness_config", &self.zone_awareness_config);
        formatter.field("dedicated_master_count", &self.dedicated_master_count);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("warm_type", &self.warm_type);
        formatter.field("zone_awareness_enabled", &self.zone_awareness_enabled);
        formatter.field("dedicated_master_type", &self.dedicated_master_type);
        formatter.finish()
    }
}
/// See [`AwsOpenSearchServiceDomainClusterConfigDetails`](crate::model::AwsOpenSearchServiceDomainClusterConfigDetails)
pub mod aws_open_search_service_domain_cluster_config_details {

    /// A builder for [`AwsOpenSearchServiceDomainClusterConfigDetails`](crate::model::AwsOpenSearchServiceDomainClusterConfigDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_count: std::option::Option<i32>,
        pub(crate) warm_enabled: std::option::Option<bool>,
        pub(crate) warm_count: std::option::Option<i32>,
        pub(crate) dedicated_master_enabled: std::option::Option<bool>,
        pub(crate) zone_awareness_config: std::option::Option<
            crate::model::AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails,
        >,
        pub(crate) dedicated_master_count: std::option::Option<i32>,
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) warm_type: std::option::Option<std::string::String>,
        pub(crate) zone_awareness_enabled: std::option::Option<bool>,
        pub(crate) dedicated_master_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The number of data nodes to use in the OpenSearch domain.</p>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.instance_count = Some(input);
            self
        }
        /// <p>The number of data nodes to use in the OpenSearch domain.</p>
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_count = input;
            self
        }
        /// <p>Whether UltraWarm is enabled.</p>
        pub fn warm_enabled(mut self, input: bool) -> Self {
            self.warm_enabled = Some(input);
            self
        }
        /// <p>Whether UltraWarm is enabled.</p>
        pub fn set_warm_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.warm_enabled = input;
            self
        }
        /// <p>The number of UltraWarm instances.</p>
        pub fn warm_count(mut self, input: i32) -> Self {
            self.warm_count = Some(input);
            self
        }
        /// <p>The number of UltraWarm instances.</p>
        pub fn set_warm_count(mut self, input: std::option::Option<i32>) -> Self {
            self.warm_count = input;
            self
        }
        /// <p>Whether to use a dedicated master node for the OpenSearch domain. A dedicated master node performs cluster management tasks, but does not hold data or respond to data upload requests.</p>
        pub fn dedicated_master_enabled(mut self, input: bool) -> Self {
            self.dedicated_master_enabled = Some(input);
            self
        }
        /// <p>Whether to use a dedicated master node for the OpenSearch domain. A dedicated master node performs cluster management tasks, but does not hold data or respond to data upload requests.</p>
        pub fn set_dedicated_master_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.dedicated_master_enabled = input;
            self
        }
        /// <p>Configuration options for zone awareness. Provided if <code>ZoneAwarenessEnabled</code> is <code>true</code>.</p>
        pub fn zone_awareness_config(
            mut self,
            input: crate::model::AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails,
        ) -> Self {
            self.zone_awareness_config = Some(input);
            self
        }
        /// <p>Configuration options for zone awareness. Provided if <code>ZoneAwarenessEnabled</code> is <code>true</code>.</p>
        pub fn set_zone_awareness_config(
            mut self,
            input: std::option::Option<
                crate::model::AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails,
            >,
        ) -> Self {
            self.zone_awareness_config = input;
            self
        }
        /// <p>The number of instances to use for the master node. If this attribute is specified, then <code>DedicatedMasterEnabled</code> must be <code>true</code>.</p>
        pub fn dedicated_master_count(mut self, input: i32) -> Self {
            self.dedicated_master_count = Some(input);
            self
        }
        /// <p>The number of instances to use for the master node. If this attribute is specified, then <code>DedicatedMasterEnabled</code> must be <code>true</code>.</p>
        pub fn set_dedicated_master_count(mut self, input: std::option::Option<i32>) -> Self {
            self.dedicated_master_count = input;
            self
        }
        /// <p>The instance type for your data nodes. </p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        /// <p>The instance type for your data nodes. </p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The type of UltraWarm instance.</p>
        pub fn warm_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.warm_type = Some(input.into());
            self
        }
        /// <p>The type of UltraWarm instance.</p>
        pub fn set_warm_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.warm_type = input;
            self
        }
        /// <p>Whether to enable zone awareness for the OpenSearch domain. When zone awareness is enabled, OpenSearch Service allocates the cluster's nodes and replica index shards across Availability Zones (AZs) in the same Region. This prevents data loss and minimizes downtime if a node or data center fails.</p>
        pub fn zone_awareness_enabled(mut self, input: bool) -> Self {
            self.zone_awareness_enabled = Some(input);
            self
        }
        /// <p>Whether to enable zone awareness for the OpenSearch domain. When zone awareness is enabled, OpenSearch Service allocates the cluster's nodes and replica index shards across Availability Zones (AZs) in the same Region. This prevents data loss and minimizes downtime if a node or data center fails.</p>
        pub fn set_zone_awareness_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.zone_awareness_enabled = input;
            self
        }
        /// <p>The hardware configuration of the computer that hosts the dedicated master node.</p>
        /// <p>If this attribute is specified, then <code>DedicatedMasterEnabled</code> must be <code>true</code>. </p>
        pub fn dedicated_master_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.dedicated_master_type = Some(input.into());
            self
        }
        /// <p>The hardware configuration of the computer that hosts the dedicated master node.</p>
        /// <p>If this attribute is specified, then <code>DedicatedMasterEnabled</code> must be <code>true</code>. </p>
        pub fn set_dedicated_master_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dedicated_master_type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsOpenSearchServiceDomainClusterConfigDetails`](crate::model::AwsOpenSearchServiceDomainClusterConfigDetails)
        pub fn build(self) -> crate::model::AwsOpenSearchServiceDomainClusterConfigDetails {
            crate::model::AwsOpenSearchServiceDomainClusterConfigDetails {
                instance_count: self.instance_count.unwrap_or_default(),
                warm_enabled: self.warm_enabled.unwrap_or_default(),
                warm_count: self.warm_count.unwrap_or_default(),
                dedicated_master_enabled: self.dedicated_master_enabled.unwrap_or_default(),
                zone_awareness_config: self.zone_awareness_config,
                dedicated_master_count: self.dedicated_master_count.unwrap_or_default(),
                instance_type: self.instance_type,
                warm_type: self.warm_type,
                zone_awareness_enabled: self.zone_awareness_enabled.unwrap_or_default(),
                dedicated_master_type: self.dedicated_master_type,
            }
        }
    }
}
impl AwsOpenSearchServiceDomainClusterConfigDetails {
    /// Creates a new builder-style object to manufacture [`AwsOpenSearchServiceDomainClusterConfigDetails`](crate::model::AwsOpenSearchServiceDomainClusterConfigDetails)
    pub fn builder() -> crate::model::aws_open_search_service_domain_cluster_config_details::Builder
    {
        crate::model::aws_open_search_service_domain_cluster_config_details::Builder::default()
    }
}

/// <p>Configuration options for zone awareness.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails {
    /// <p>The number of Availability Zones that the domain uses. Valid values are 2 and 3. The default is 2.</p>
    pub availability_zone_count: i32,
}
impl AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails {
    /// <p>The number of Availability Zones that the domain uses. Valid values are 2 and 3. The default is 2.</p>
    pub fn availability_zone_count(&self) -> i32 {
        self.availability_zone_count
    }
}
impl std::fmt::Debug for AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails");
        formatter.field("availability_zone_count", &self.availability_zone_count);
        formatter.finish()
    }
}
/// See [`AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails`](crate::model::AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails)
pub mod aws_open_search_service_domain_cluster_config_zone_awareness_config_details {

    /// A builder for [`AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails`](crate::model::AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_zone_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The number of Availability Zones that the domain uses. Valid values are 2 and 3. The default is 2.</p>
        pub fn availability_zone_count(mut self, input: i32) -> Self {
            self.availability_zone_count = Some(input);
            self
        }
        /// <p>The number of Availability Zones that the domain uses. Valid values are 2 and 3. The default is 2.</p>
        pub fn set_availability_zone_count(mut self, input: std::option::Option<i32>) -> Self {
            self.availability_zone_count = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails`](crate::model::AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails
        {
            crate::model::AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails {
                availability_zone_count: self.availability_zone_count.unwrap_or_default(),
            }
        }
    }
}
impl AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails {
    /// Creates a new builder-style object to manufacture [`AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails`](crate::model::AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails)
    pub fn builder() -> crate::model::aws_open_search_service_domain_cluster_config_zone_awareness_config_details::Builder{
        crate::model::aws_open_search_service_domain_cluster_config_zone_awareness_config_details::Builder::default()
    }
}

/// <p>Provides information about the state of the domain relative to the latest service software.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails {
    /// <p>The epoch time when the deployment window closes for required updates. After this time, OpenSearch Service schedules the software upgrade automatically.</p>
    pub automated_update_date: std::option::Option<std::string::String>,
    /// <p>Whether a request to update the domain can be canceled.</p>
    pub cancellable: bool,
    /// <p>The version of the service software that is currently installed on the domain.</p>
    pub current_version: std::option::Option<std::string::String>,
    /// <p>A more detailed description of the service software status.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The most recent version of the service software.</p>
    pub new_version: std::option::Option<std::string::String>,
    /// <p>Whether a service software update is available for the domain.</p>
    pub update_available: bool,
    /// <p>The status of the service software update.</p>
    pub update_status: std::option::Option<std::string::String>,
    /// <p>Whether the service software update is optional.</p>
    pub optional_deployment: bool,
}
impl AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails {
    /// <p>The epoch time when the deployment window closes for required updates. After this time, OpenSearch Service schedules the software upgrade automatically.</p>
    pub fn automated_update_date(&self) -> std::option::Option<&str> {
        self.automated_update_date.as_deref()
    }
    /// <p>Whether a request to update the domain can be canceled.</p>
    pub fn cancellable(&self) -> bool {
        self.cancellable
    }
    /// <p>The version of the service software that is currently installed on the domain.</p>
    pub fn current_version(&self) -> std::option::Option<&str> {
        self.current_version.as_deref()
    }
    /// <p>A more detailed description of the service software status.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The most recent version of the service software.</p>
    pub fn new_version(&self) -> std::option::Option<&str> {
        self.new_version.as_deref()
    }
    /// <p>Whether a service software update is available for the domain.</p>
    pub fn update_available(&self) -> bool {
        self.update_available
    }
    /// <p>The status of the service software update.</p>
    pub fn update_status(&self) -> std::option::Option<&str> {
        self.update_status.as_deref()
    }
    /// <p>Whether the service software update is optional.</p>
    pub fn optional_deployment(&self) -> bool {
        self.optional_deployment
    }
}
impl std::fmt::Debug for AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails");
        formatter.field("automated_update_date", &self.automated_update_date);
        formatter.field("cancellable", &self.cancellable);
        formatter.field("current_version", &self.current_version);
        formatter.field("description", &self.description);
        formatter.field("new_version", &self.new_version);
        formatter.field("update_available", &self.update_available);
        formatter.field("update_status", &self.update_status);
        formatter.field("optional_deployment", &self.optional_deployment);
        formatter.finish()
    }
}
/// See [`AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails`](crate::model::AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails)
pub mod aws_open_search_service_domain_service_software_options_details {

    /// A builder for [`AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails`](crate::model::AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) automated_update_date: std::option::Option<std::string::String>,
        pub(crate) cancellable: std::option::Option<bool>,
        pub(crate) current_version: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) new_version: std::option::Option<std::string::String>,
        pub(crate) update_available: std::option::Option<bool>,
        pub(crate) update_status: std::option::Option<std::string::String>,
        pub(crate) optional_deployment: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The epoch time when the deployment window closes for required updates. After this time, OpenSearch Service schedules the software upgrade automatically.</p>
        pub fn automated_update_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.automated_update_date = Some(input.into());
            self
        }
        /// <p>The epoch time when the deployment window closes for required updates. After this time, OpenSearch Service schedules the software upgrade automatically.</p>
        pub fn set_automated_update_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.automated_update_date = input;
            self
        }
        /// <p>Whether a request to update the domain can be canceled.</p>
        pub fn cancellable(mut self, input: bool) -> Self {
            self.cancellable = Some(input);
            self
        }
        /// <p>Whether a request to update the domain can be canceled.</p>
        pub fn set_cancellable(mut self, input: std::option::Option<bool>) -> Self {
            self.cancellable = input;
            self
        }
        /// <p>The version of the service software that is currently installed on the domain.</p>
        pub fn current_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.current_version = Some(input.into());
            self
        }
        /// <p>The version of the service software that is currently installed on the domain.</p>
        pub fn set_current_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.current_version = input;
            self
        }
        /// <p>A more detailed description of the service software status.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A more detailed description of the service software status.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The most recent version of the service software.</p>
        pub fn new_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.new_version = Some(input.into());
            self
        }
        /// <p>The most recent version of the service software.</p>
        pub fn set_new_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.new_version = input;
            self
        }
        /// <p>Whether a service software update is available for the domain.</p>
        pub fn update_available(mut self, input: bool) -> Self {
            self.update_available = Some(input);
            self
        }
        /// <p>Whether a service software update is available for the domain.</p>
        pub fn set_update_available(mut self, input: std::option::Option<bool>) -> Self {
            self.update_available = input;
            self
        }
        /// <p>The status of the service software update.</p>
        pub fn update_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.update_status = Some(input.into());
            self
        }
        /// <p>The status of the service software update.</p>
        pub fn set_update_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.update_status = input;
            self
        }
        /// <p>Whether the service software update is optional.</p>
        pub fn optional_deployment(mut self, input: bool) -> Self {
            self.optional_deployment = Some(input);
            self
        }
        /// <p>Whether the service software update is optional.</p>
        pub fn set_optional_deployment(mut self, input: std::option::Option<bool>) -> Self {
            self.optional_deployment = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails`](crate::model::AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails {
            crate::model::AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails {
                automated_update_date: self.automated_update_date,
                cancellable: self.cancellable.unwrap_or_default(),
                current_version: self.current_version,
                description: self.description,
                new_version: self.new_version,
                update_available: self.update_available.unwrap_or_default(),
                update_status: self.update_status,
                optional_deployment: self.optional_deployment.unwrap_or_default(),
            }
        }
    }
}
impl AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails {
    /// Creates a new builder-style object to manufacture [`AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails`](crate::model::AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails)
    pub fn builder(
    ) -> crate::model::aws_open_search_service_domain_service_software_options_details::Builder
    {
        crate::model::aws_open_search_service_domain_service_software_options_details::Builder::default()
    }
}

/// <p>Provides details about the configuration for node-to-node encryption.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails {
    /// <p>Whether node-to-node encryption is enabled.</p>
    pub enabled: bool,
}
impl AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails {
    /// <p>Whether node-to-node encryption is enabled.</p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
}
impl std::fmt::Debug for AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails");
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails`](crate::model::AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails)
pub mod aws_open_search_service_domain_node_to_node_encryption_options_details {

    /// A builder for [`AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails`](crate::model::AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Whether node-to-node encryption is enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Whether node-to-node encryption is enabled.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails`](crate::model::AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails {
            crate::model::AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails {
                enabled: self.enabled.unwrap_or_default(),
            }
        }
    }
}
impl AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails {
    /// Creates a new builder-style object to manufacture [`AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails`](crate::model::AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails)
    pub fn builder(
    ) -> crate::model::aws_open_search_service_domain_node_to_node_encryption_options_details::Builder
    {
        crate::model::aws_open_search_service_domain_node_to_node_encryption_options_details::Builder::default()
    }
}

/// <p>Details about the configuration for encryption at rest for the OpenSearch domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails {
    /// <p>Whether encryption at rest is enabled.</p>
    pub enabled: bool,
    /// <p>The KMS key ID.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails {
    /// <p>Whether encryption at rest is enabled.</p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
    /// <p>The KMS key ID.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
}
impl std::fmt::Debug for AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails");
        formatter.field("enabled", &self.enabled);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.finish()
    }
}
/// See [`AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails`](crate::model::AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails)
pub mod aws_open_search_service_domain_encryption_at_rest_options_details {

    /// A builder for [`AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails`](crate::model::AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Whether encryption at rest is enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Whether encryption at rest is enabled.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The KMS key ID.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The KMS key ID.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails`](crate::model::AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails {
            crate::model::AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails {
                enabled: self.enabled.unwrap_or_default(),
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails {
    /// Creates a new builder-style object to manufacture [`AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails`](crate::model::AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails)
    pub fn builder(
    ) -> crate::model::aws_open_search_service_domain_encryption_at_rest_options_details::Builder
    {
        crate::model::aws_open_search_service_domain_encryption_at_rest_options_details::Builder::default()
    }
}

/// <p>Information about an Amazon ECR image.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcrContainerImageDetails {
    /// <p>The Amazon Web Services account identifier that is associated with the registry that the image belongs to.</p>
    pub registry_id: std::option::Option<std::string::String>,
    /// <p>The name of the repository that the image belongs to.</p>
    pub repository_name: std::option::Option<std::string::String>,
    /// <p>The architecture of the image.</p>
    pub architecture: std::option::Option<std::string::String>,
    /// <p>The sha256 digest of the image manifest.</p>
    pub image_digest: std::option::Option<std::string::String>,
    /// <p>The list of tags that are associated with the image.</p>
    pub image_tags: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The date and time when the image was pushed to the repository.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub image_published_at: std::option::Option<std::string::String>,
}
impl AwsEcrContainerImageDetails {
    /// <p>The Amazon Web Services account identifier that is associated with the registry that the image belongs to.</p>
    pub fn registry_id(&self) -> std::option::Option<&str> {
        self.registry_id.as_deref()
    }
    /// <p>The name of the repository that the image belongs to.</p>
    pub fn repository_name(&self) -> std::option::Option<&str> {
        self.repository_name.as_deref()
    }
    /// <p>The architecture of the image.</p>
    pub fn architecture(&self) -> std::option::Option<&str> {
        self.architecture.as_deref()
    }
    /// <p>The sha256 digest of the image manifest.</p>
    pub fn image_digest(&self) -> std::option::Option<&str> {
        self.image_digest.as_deref()
    }
    /// <p>The list of tags that are associated with the image.</p>
    pub fn image_tags(&self) -> std::option::Option<&[std::string::String]> {
        self.image_tags.as_deref()
    }
    /// <p>The date and time when the image was pushed to the repository.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn image_published_at(&self) -> std::option::Option<&str> {
        self.image_published_at.as_deref()
    }
}
impl std::fmt::Debug for AwsEcrContainerImageDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcrContainerImageDetails");
        formatter.field("registry_id", &self.registry_id);
        formatter.field("repository_name", &self.repository_name);
        formatter.field("architecture", &self.architecture);
        formatter.field("image_digest", &self.image_digest);
        formatter.field("image_tags", &self.image_tags);
        formatter.field("image_published_at", &self.image_published_at);
        formatter.finish()
    }
}
/// See [`AwsEcrContainerImageDetails`](crate::model::AwsEcrContainerImageDetails)
pub mod aws_ecr_container_image_details {

    /// A builder for [`AwsEcrContainerImageDetails`](crate::model::AwsEcrContainerImageDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) registry_id: std::option::Option<std::string::String>,
        pub(crate) repository_name: std::option::Option<std::string::String>,
        pub(crate) architecture: std::option::Option<std::string::String>,
        pub(crate) image_digest: std::option::Option<std::string::String>,
        pub(crate) image_tags: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) image_published_at: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Web Services account identifier that is associated with the registry that the image belongs to.</p>
        pub fn registry_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.registry_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account identifier that is associated with the registry that the image belongs to.</p>
        pub fn set_registry_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.registry_id = input;
            self
        }
        /// <p>The name of the repository that the image belongs to.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository_name = Some(input.into());
            self
        }
        /// <p>The name of the repository that the image belongs to.</p>
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.repository_name = input;
            self
        }
        /// <p>The architecture of the image.</p>
        pub fn architecture(mut self, input: impl Into<std::string::String>) -> Self {
            self.architecture = Some(input.into());
            self
        }
        /// <p>The architecture of the image.</p>
        pub fn set_architecture(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.architecture = input;
            self
        }
        /// <p>The sha256 digest of the image manifest.</p>
        pub fn image_digest(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_digest = Some(input.into());
            self
        }
        /// <p>The sha256 digest of the image manifest.</p>
        pub fn set_image_digest(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_digest = input;
            self
        }
        /// Appends an item to `image_tags`.
        ///
        /// To override the contents of this collection use [`set_image_tags`](Self::set_image_tags).
        ///
        /// <p>The list of tags that are associated with the image.</p>
        pub fn image_tags(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.image_tags.unwrap_or_default();
            v.push(input.into());
            self.image_tags = Some(v);
            self
        }
        /// <p>The list of tags that are associated with the image.</p>
        pub fn set_image_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.image_tags = input;
            self
        }
        /// <p>The date and time when the image was pushed to the repository.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn image_published_at(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_published_at = Some(input.into());
            self
        }
        /// <p>The date and time when the image was pushed to the repository.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_image_published_at(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.image_published_at = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcrContainerImageDetails`](crate::model::AwsEcrContainerImageDetails)
        pub fn build(self) -> crate::model::AwsEcrContainerImageDetails {
            crate::model::AwsEcrContainerImageDetails {
                registry_id: self.registry_id,
                repository_name: self.repository_name,
                architecture: self.architecture,
                image_digest: self.image_digest,
                image_tags: self.image_tags,
                image_published_at: self.image_published_at,
            }
        }
    }
}
impl AwsEcrContainerImageDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcrContainerImageDetails`](crate::model::AwsEcrContainerImageDetails)
    pub fn builder() -> crate::model::aws_ecr_container_image_details::Builder {
        crate::model::aws_ecr_container_image_details::Builder::default()
    }
}

/// <p>Details about an Amazon EC2 VPN connection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2VpnConnectionDetails {
    /// <p>The identifier of the VPN connection.</p>
    pub vpn_connection_id: std::option::Option<std::string::String>,
    /// <p>The current state of the VPN connection.</p>
    pub state: std::option::Option<std::string::String>,
    /// <p>The identifier of the customer gateway that is at your end of the VPN connection.</p>
    pub customer_gateway_id: std::option::Option<std::string::String>,
    /// <p>The configuration information for the VPN connection's customer gateway, in the native XML format.</p>
    pub customer_gateway_configuration: std::option::Option<std::string::String>,
    /// <p>The type of VPN connection.</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The identifier of the virtual private gateway that is at the Amazon Web Services side of the VPN connection.</p>
    pub vpn_gateway_id: std::option::Option<std::string::String>,
    /// <p>The category of the VPN connection. <code>VPN</code> indicates an Amazon Web Services VPN connection. <code>VPN-Classic</code> indicates an Amazon Web Services Classic VPN connection.</p>
    pub category: std::option::Option<std::string::String>,
    /// <p>Information about the VPN tunnel.</p>
    pub vgw_telemetry:
        std::option::Option<std::vec::Vec<crate::model::AwsEc2VpnConnectionVgwTelemetryDetails>>,
    /// <p>The VPN connection options.</p>
    pub options: std::option::Option<crate::model::AwsEc2VpnConnectionOptionsDetails>,
    /// <p>The static routes that are associated with the VPN connection.</p>
    pub routes: std::option::Option<std::vec::Vec<crate::model::AwsEc2VpnConnectionRoutesDetails>>,
    /// <p>The identifier of the transit gateway that is associated with the VPN connection.</p>
    pub transit_gateway_id: std::option::Option<std::string::String>,
}
impl AwsEc2VpnConnectionDetails {
    /// <p>The identifier of the VPN connection.</p>
    pub fn vpn_connection_id(&self) -> std::option::Option<&str> {
        self.vpn_connection_id.as_deref()
    }
    /// <p>The current state of the VPN connection.</p>
    pub fn state(&self) -> std::option::Option<&str> {
        self.state.as_deref()
    }
    /// <p>The identifier of the customer gateway that is at your end of the VPN connection.</p>
    pub fn customer_gateway_id(&self) -> std::option::Option<&str> {
        self.customer_gateway_id.as_deref()
    }
    /// <p>The configuration information for the VPN connection's customer gateway, in the native XML format.</p>
    pub fn customer_gateway_configuration(&self) -> std::option::Option<&str> {
        self.customer_gateway_configuration.as_deref()
    }
    /// <p>The type of VPN connection.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The identifier of the virtual private gateway that is at the Amazon Web Services side of the VPN connection.</p>
    pub fn vpn_gateway_id(&self) -> std::option::Option<&str> {
        self.vpn_gateway_id.as_deref()
    }
    /// <p>The category of the VPN connection. <code>VPN</code> indicates an Amazon Web Services VPN connection. <code>VPN-Classic</code> indicates an Amazon Web Services Classic VPN connection.</p>
    pub fn category(&self) -> std::option::Option<&str> {
        self.category.as_deref()
    }
    /// <p>Information about the VPN tunnel.</p>
    pub fn vgw_telemetry(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEc2VpnConnectionVgwTelemetryDetails]> {
        self.vgw_telemetry.as_deref()
    }
    /// <p>The VPN connection options.</p>
    pub fn options(&self) -> std::option::Option<&crate::model::AwsEc2VpnConnectionOptionsDetails> {
        self.options.as_ref()
    }
    /// <p>The static routes that are associated with the VPN connection.</p>
    pub fn routes(&self) -> std::option::Option<&[crate::model::AwsEc2VpnConnectionRoutesDetails]> {
        self.routes.as_deref()
    }
    /// <p>The identifier of the transit gateway that is associated with the VPN connection.</p>
    pub fn transit_gateway_id(&self) -> std::option::Option<&str> {
        self.transit_gateway_id.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2VpnConnectionDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2VpnConnectionDetails");
        formatter.field("vpn_connection_id", &self.vpn_connection_id);
        formatter.field("state", &self.state);
        formatter.field("customer_gateway_id", &self.customer_gateway_id);
        formatter.field(
            "customer_gateway_configuration",
            &self.customer_gateway_configuration,
        );
        formatter.field("r#type", &self.r#type);
        formatter.field("vpn_gateway_id", &self.vpn_gateway_id);
        formatter.field("category", &self.category);
        formatter.field("vgw_telemetry", &self.vgw_telemetry);
        formatter.field("options", &self.options);
        formatter.field("routes", &self.routes);
        formatter.field("transit_gateway_id", &self.transit_gateway_id);
        formatter.finish()
    }
}
/// See [`AwsEc2VpnConnectionDetails`](crate::model::AwsEc2VpnConnectionDetails)
pub mod aws_ec2_vpn_connection_details {

    /// A builder for [`AwsEc2VpnConnectionDetails`](crate::model::AwsEc2VpnConnectionDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vpn_connection_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<std::string::String>,
        pub(crate) customer_gateway_id: std::option::Option<std::string::String>,
        pub(crate) customer_gateway_configuration: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) vpn_gateway_id: std::option::Option<std::string::String>,
        pub(crate) category: std::option::Option<std::string::String>,
        pub(crate) vgw_telemetry: std::option::Option<
            std::vec::Vec<crate::model::AwsEc2VpnConnectionVgwTelemetryDetails>,
        >,
        pub(crate) options: std::option::Option<crate::model::AwsEc2VpnConnectionOptionsDetails>,
        pub(crate) routes:
            std::option::Option<std::vec::Vec<crate::model::AwsEc2VpnConnectionRoutesDetails>>,
        pub(crate) transit_gateway_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the VPN connection.</p>
        pub fn vpn_connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpn_connection_id = Some(input.into());
            self
        }
        /// <p>The identifier of the VPN connection.</p>
        pub fn set_vpn_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpn_connection_id = input;
            self
        }
        /// <p>The current state of the VPN connection.</p>
        pub fn state(mut self, input: impl Into<std::string::String>) -> Self {
            self.state = Some(input.into());
            self
        }
        /// <p>The current state of the VPN connection.</p>
        pub fn set_state(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.state = input;
            self
        }
        /// <p>The identifier of the customer gateway that is at your end of the VPN connection.</p>
        pub fn customer_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.customer_gateway_id = Some(input.into());
            self
        }
        /// <p>The identifier of the customer gateway that is at your end of the VPN connection.</p>
        pub fn set_customer_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.customer_gateway_id = input;
            self
        }
        /// <p>The configuration information for the VPN connection's customer gateway, in the native XML format.</p>
        pub fn customer_gateway_configuration(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.customer_gateway_configuration = Some(input.into());
            self
        }
        /// <p>The configuration information for the VPN connection's customer gateway, in the native XML format.</p>
        pub fn set_customer_gateway_configuration(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.customer_gateway_configuration = input;
            self
        }
        /// <p>The type of VPN connection.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of VPN connection.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The identifier of the virtual private gateway that is at the Amazon Web Services side of the VPN connection.</p>
        pub fn vpn_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpn_gateway_id = Some(input.into());
            self
        }
        /// <p>The identifier of the virtual private gateway that is at the Amazon Web Services side of the VPN connection.</p>
        pub fn set_vpn_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpn_gateway_id = input;
            self
        }
        /// <p>The category of the VPN connection. <code>VPN</code> indicates an Amazon Web Services VPN connection. <code>VPN-Classic</code> indicates an Amazon Web Services Classic VPN connection.</p>
        pub fn category(mut self, input: impl Into<std::string::String>) -> Self {
            self.category = Some(input.into());
            self
        }
        /// <p>The category of the VPN connection. <code>VPN</code> indicates an Amazon Web Services VPN connection. <code>VPN-Classic</code> indicates an Amazon Web Services Classic VPN connection.</p>
        pub fn set_category(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.category = input;
            self
        }
        /// Appends an item to `vgw_telemetry`.
        ///
        /// To override the contents of this collection use [`set_vgw_telemetry`](Self::set_vgw_telemetry).
        ///
        /// <p>Information about the VPN tunnel.</p>
        pub fn vgw_telemetry(
            mut self,
            input: crate::model::AwsEc2VpnConnectionVgwTelemetryDetails,
        ) -> Self {
            let mut v = self.vgw_telemetry.unwrap_or_default();
            v.push(input);
            self.vgw_telemetry = Some(v);
            self
        }
        /// <p>Information about the VPN tunnel.</p>
        pub fn set_vgw_telemetry(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEc2VpnConnectionVgwTelemetryDetails>,
            >,
        ) -> Self {
            self.vgw_telemetry = input;
            self
        }
        /// <p>The VPN connection options.</p>
        pub fn options(mut self, input: crate::model::AwsEc2VpnConnectionOptionsDetails) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>The VPN connection options.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::AwsEc2VpnConnectionOptionsDetails>,
        ) -> Self {
            self.options = input;
            self
        }
        /// Appends an item to `routes`.
        ///
        /// To override the contents of this collection use [`set_routes`](Self::set_routes).
        ///
        /// <p>The static routes that are associated with the VPN connection.</p>
        pub fn routes(mut self, input: crate::model::AwsEc2VpnConnectionRoutesDetails) -> Self {
            let mut v = self.routes.unwrap_or_default();
            v.push(input);
            self.routes = Some(v);
            self
        }
        /// <p>The static routes that are associated with the VPN connection.</p>
        pub fn set_routes(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEc2VpnConnectionRoutesDetails>,
            >,
        ) -> Self {
            self.routes = input;
            self
        }
        /// <p>The identifier of the transit gateway that is associated with the VPN connection.</p>
        pub fn transit_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_id = Some(input.into());
            self
        }
        /// <p>The identifier of the transit gateway that is associated with the VPN connection.</p>
        pub fn set_transit_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2VpnConnectionDetails`](crate::model::AwsEc2VpnConnectionDetails)
        pub fn build(self) -> crate::model::AwsEc2VpnConnectionDetails {
            crate::model::AwsEc2VpnConnectionDetails {
                vpn_connection_id: self.vpn_connection_id,
                state: self.state,
                customer_gateway_id: self.customer_gateway_id,
                customer_gateway_configuration: self.customer_gateway_configuration,
                r#type: self.r#type,
                vpn_gateway_id: self.vpn_gateway_id,
                category: self.category,
                vgw_telemetry: self.vgw_telemetry,
                options: self.options,
                routes: self.routes,
                transit_gateway_id: self.transit_gateway_id,
            }
        }
    }
}
impl AwsEc2VpnConnectionDetails {
    /// Creates a new builder-style object to manufacture [`AwsEc2VpnConnectionDetails`](crate::model::AwsEc2VpnConnectionDetails)
    pub fn builder() -> crate::model::aws_ec2_vpn_connection_details::Builder {
        crate::model::aws_ec2_vpn_connection_details::Builder::default()
    }
}

/// <p>A static routes associated with the VPN connection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2VpnConnectionRoutesDetails {
    /// <p>The CIDR block associated with the local subnet of the customer data center.</p>
    pub destination_cidr_block: std::option::Option<std::string::String>,
    /// <p>The current state of the static route.</p>
    pub state: std::option::Option<std::string::String>,
}
impl AwsEc2VpnConnectionRoutesDetails {
    /// <p>The CIDR block associated with the local subnet of the customer data center.</p>
    pub fn destination_cidr_block(&self) -> std::option::Option<&str> {
        self.destination_cidr_block.as_deref()
    }
    /// <p>The current state of the static route.</p>
    pub fn state(&self) -> std::option::Option<&str> {
        self.state.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2VpnConnectionRoutesDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2VpnConnectionRoutesDetails");
        formatter.field("destination_cidr_block", &self.destination_cidr_block);
        formatter.field("state", &self.state);
        formatter.finish()
    }
}
/// See [`AwsEc2VpnConnectionRoutesDetails`](crate::model::AwsEc2VpnConnectionRoutesDetails)
pub mod aws_ec2_vpn_connection_routes_details {

    /// A builder for [`AwsEc2VpnConnectionRoutesDetails`](crate::model::AwsEc2VpnConnectionRoutesDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_cidr_block: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The CIDR block associated with the local subnet of the customer data center.</p>
        pub fn destination_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_cidr_block = Some(input.into());
            self
        }
        /// <p>The CIDR block associated with the local subnet of the customer data center.</p>
        pub fn set_destination_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_cidr_block = input;
            self
        }
        /// <p>The current state of the static route.</p>
        pub fn state(mut self, input: impl Into<std::string::String>) -> Self {
            self.state = Some(input.into());
            self
        }
        /// <p>The current state of the static route.</p>
        pub fn set_state(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2VpnConnectionRoutesDetails`](crate::model::AwsEc2VpnConnectionRoutesDetails)
        pub fn build(self) -> crate::model::AwsEc2VpnConnectionRoutesDetails {
            crate::model::AwsEc2VpnConnectionRoutesDetails {
                destination_cidr_block: self.destination_cidr_block,
                state: self.state,
            }
        }
    }
}
impl AwsEc2VpnConnectionRoutesDetails {
    /// Creates a new builder-style object to manufacture [`AwsEc2VpnConnectionRoutesDetails`](crate::model::AwsEc2VpnConnectionRoutesDetails)
    pub fn builder() -> crate::model::aws_ec2_vpn_connection_routes_details::Builder {
        crate::model::aws_ec2_vpn_connection_routes_details::Builder::default()
    }
}

/// <p>VPN connection options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2VpnConnectionOptionsDetails {
    /// <p>Whether the VPN connection uses static routes only.</p>
    pub static_routes_only: bool,
    /// <p>The VPN tunnel options.</p>
    pub tunnel_options: std::option::Option<
        std::vec::Vec<crate::model::AwsEc2VpnConnectionOptionsTunnelOptionsDetails>,
    >,
}
impl AwsEc2VpnConnectionOptionsDetails {
    /// <p>Whether the VPN connection uses static routes only.</p>
    pub fn static_routes_only(&self) -> bool {
        self.static_routes_only
    }
    /// <p>The VPN tunnel options.</p>
    pub fn tunnel_options(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEc2VpnConnectionOptionsTunnelOptionsDetails]> {
        self.tunnel_options.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2VpnConnectionOptionsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2VpnConnectionOptionsDetails");
        formatter.field("static_routes_only", &self.static_routes_only);
        formatter.field("tunnel_options", &self.tunnel_options);
        formatter.finish()
    }
}
/// See [`AwsEc2VpnConnectionOptionsDetails`](crate::model::AwsEc2VpnConnectionOptionsDetails)
pub mod aws_ec2_vpn_connection_options_details {

    /// A builder for [`AwsEc2VpnConnectionOptionsDetails`](crate::model::AwsEc2VpnConnectionOptionsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) static_routes_only: std::option::Option<bool>,
        pub(crate) tunnel_options: std::option::Option<
            std::vec::Vec<crate::model::AwsEc2VpnConnectionOptionsTunnelOptionsDetails>,
        >,
    }
    impl Builder {
        /// <p>Whether the VPN connection uses static routes only.</p>
        pub fn static_routes_only(mut self, input: bool) -> Self {
            self.static_routes_only = Some(input);
            self
        }
        /// <p>Whether the VPN connection uses static routes only.</p>
        pub fn set_static_routes_only(mut self, input: std::option::Option<bool>) -> Self {
            self.static_routes_only = input;
            self
        }
        /// Appends an item to `tunnel_options`.
        ///
        /// To override the contents of this collection use [`set_tunnel_options`](Self::set_tunnel_options).
        ///
        /// <p>The VPN tunnel options.</p>
        pub fn tunnel_options(
            mut self,
            input: crate::model::AwsEc2VpnConnectionOptionsTunnelOptionsDetails,
        ) -> Self {
            let mut v = self.tunnel_options.unwrap_or_default();
            v.push(input);
            self.tunnel_options = Some(v);
            self
        }
        /// <p>The VPN tunnel options.</p>
        pub fn set_tunnel_options(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEc2VpnConnectionOptionsTunnelOptionsDetails>,
            >,
        ) -> Self {
            self.tunnel_options = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2VpnConnectionOptionsDetails`](crate::model::AwsEc2VpnConnectionOptionsDetails)
        pub fn build(self) -> crate::model::AwsEc2VpnConnectionOptionsDetails {
            crate::model::AwsEc2VpnConnectionOptionsDetails {
                static_routes_only: self.static_routes_only.unwrap_or_default(),
                tunnel_options: self.tunnel_options,
            }
        }
    }
}
impl AwsEc2VpnConnectionOptionsDetails {
    /// Creates a new builder-style object to manufacture [`AwsEc2VpnConnectionOptionsDetails`](crate::model::AwsEc2VpnConnectionOptionsDetails)
    pub fn builder() -> crate::model::aws_ec2_vpn_connection_options_details::Builder {
        crate::model::aws_ec2_vpn_connection_options_details::Builder::default()
    }
}

/// <p>The VPN tunnel options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2VpnConnectionOptionsTunnelOptionsDetails {
    /// <p>The number of seconds after which a Dead Peer Detection (DPD) timeout occurs.</p>
    pub dpd_timeout_seconds: i32,
    /// <p>The Internet Key Exchange (IKE) versions that are permitted for the VPN tunnel.</p>
    pub ike_versions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The external IP address of the VPN tunnel.</p>
    pub outside_ip_address: std::option::Option<std::string::String>,
    /// <p>The permitted Diffie-Hellman group numbers for the VPN tunnel for phase 1 IKE negotiations.</p>
    pub phase1_dh_group_numbers: std::option::Option<std::vec::Vec<i32>>,
    /// <p>The permitted encryption algorithms for the VPN tunnel for phase 1 IKE negotiations.</p>
    pub phase1_encryption_algorithms: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The permitted integrity algorithms for the VPN tunnel for phase 1 IKE negotiations.</p>
    pub phase1_integrity_algorithms: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The lifetime for phase 1 of the IKE negotiation, in seconds.</p>
    pub phase1_lifetime_seconds: i32,
    /// <p>The permitted Diffie-Hellman group numbers for the VPN tunnel for phase 2 IKE negotiations.</p>
    pub phase2_dh_group_numbers: std::option::Option<std::vec::Vec<i32>>,
    /// <p>The permitted encryption algorithms for the VPN tunnel for phase 2 IKE negotiations.</p>
    pub phase2_encryption_algorithms: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The permitted integrity algorithms for the VPN tunnel for phase 2 IKE negotiations.</p>
    pub phase2_integrity_algorithms: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The lifetime for phase 2 of the IKE negotiation, in seconds.</p>
    pub phase2_lifetime_seconds: i32,
    /// <p>The preshared key to establish initial authentication between the virtual private gateway and the customer gateway.</p>
    pub pre_shared_key: std::option::Option<std::string::String>,
    /// <p>The percentage of the rekey window, which is determined by <code>RekeyMarginTimeSeconds</code> during which the rekey time is randomly selected.</p>
    pub rekey_fuzz_percentage: i32,
    /// <p>The margin time, in seconds, before the phase 2 lifetime expires, during which the Amazon Web Services side of the VPN connection performs an IKE rekey.</p>
    pub rekey_margin_time_seconds: i32,
    /// <p>The number of packets in an IKE replay window.</p>
    pub replay_window_size: i32,
    /// <p>The range of inside IPv4 addresses for the tunnel.</p>
    pub tunnel_inside_cidr: std::option::Option<std::string::String>,
}
impl AwsEc2VpnConnectionOptionsTunnelOptionsDetails {
    /// <p>The number of seconds after which a Dead Peer Detection (DPD) timeout occurs.</p>
    pub fn dpd_timeout_seconds(&self) -> i32 {
        self.dpd_timeout_seconds
    }
    /// <p>The Internet Key Exchange (IKE) versions that are permitted for the VPN tunnel.</p>
    pub fn ike_versions(&self) -> std::option::Option<&[std::string::String]> {
        self.ike_versions.as_deref()
    }
    /// <p>The external IP address of the VPN tunnel.</p>
    pub fn outside_ip_address(&self) -> std::option::Option<&str> {
        self.outside_ip_address.as_deref()
    }
    /// <p>The permitted Diffie-Hellman group numbers for the VPN tunnel for phase 1 IKE negotiations.</p>
    pub fn phase1_dh_group_numbers(&self) -> std::option::Option<&[i32]> {
        self.phase1_dh_group_numbers.as_deref()
    }
    /// <p>The permitted encryption algorithms for the VPN tunnel for phase 1 IKE negotiations.</p>
    pub fn phase1_encryption_algorithms(&self) -> std::option::Option<&[std::string::String]> {
        self.phase1_encryption_algorithms.as_deref()
    }
    /// <p>The permitted integrity algorithms for the VPN tunnel for phase 1 IKE negotiations.</p>
    pub fn phase1_integrity_algorithms(&self) -> std::option::Option<&[std::string::String]> {
        self.phase1_integrity_algorithms.as_deref()
    }
    /// <p>The lifetime for phase 1 of the IKE negotiation, in seconds.</p>
    pub fn phase1_lifetime_seconds(&self) -> i32 {
        self.phase1_lifetime_seconds
    }
    /// <p>The permitted Diffie-Hellman group numbers for the VPN tunnel for phase 2 IKE negotiations.</p>
    pub fn phase2_dh_group_numbers(&self) -> std::option::Option<&[i32]> {
        self.phase2_dh_group_numbers.as_deref()
    }
    /// <p>The permitted encryption algorithms for the VPN tunnel for phase 2 IKE negotiations.</p>
    pub fn phase2_encryption_algorithms(&self) -> std::option::Option<&[std::string::String]> {
        self.phase2_encryption_algorithms.as_deref()
    }
    /// <p>The permitted integrity algorithms for the VPN tunnel for phase 2 IKE negotiations.</p>
    pub fn phase2_integrity_algorithms(&self) -> std::option::Option<&[std::string::String]> {
        self.phase2_integrity_algorithms.as_deref()
    }
    /// <p>The lifetime for phase 2 of the IKE negotiation, in seconds.</p>
    pub fn phase2_lifetime_seconds(&self) -> i32 {
        self.phase2_lifetime_seconds
    }
    /// <p>The preshared key to establish initial authentication between the virtual private gateway and the customer gateway.</p>
    pub fn pre_shared_key(&self) -> std::option::Option<&str> {
        self.pre_shared_key.as_deref()
    }
    /// <p>The percentage of the rekey window, which is determined by <code>RekeyMarginTimeSeconds</code> during which the rekey time is randomly selected.</p>
    pub fn rekey_fuzz_percentage(&self) -> i32 {
        self.rekey_fuzz_percentage
    }
    /// <p>The margin time, in seconds, before the phase 2 lifetime expires, during which the Amazon Web Services side of the VPN connection performs an IKE rekey.</p>
    pub fn rekey_margin_time_seconds(&self) -> i32 {
        self.rekey_margin_time_seconds
    }
    /// <p>The number of packets in an IKE replay window.</p>
    pub fn replay_window_size(&self) -> i32 {
        self.replay_window_size
    }
    /// <p>The range of inside IPv4 addresses for the tunnel.</p>
    pub fn tunnel_inside_cidr(&self) -> std::option::Option<&str> {
        self.tunnel_inside_cidr.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2VpnConnectionOptionsTunnelOptionsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2VpnConnectionOptionsTunnelOptionsDetails");
        formatter.field("dpd_timeout_seconds", &self.dpd_timeout_seconds);
        formatter.field("ike_versions", &self.ike_versions);
        formatter.field("outside_ip_address", &self.outside_ip_address);
        formatter.field("phase1_dh_group_numbers", &self.phase1_dh_group_numbers);
        formatter.field(
            "phase1_encryption_algorithms",
            &self.phase1_encryption_algorithms,
        );
        formatter.field(
            "phase1_integrity_algorithms",
            &self.phase1_integrity_algorithms,
        );
        formatter.field("phase1_lifetime_seconds", &self.phase1_lifetime_seconds);
        formatter.field("phase2_dh_group_numbers", &self.phase2_dh_group_numbers);
        formatter.field(
            "phase2_encryption_algorithms",
            &self.phase2_encryption_algorithms,
        );
        formatter.field(
            "phase2_integrity_algorithms",
            &self.phase2_integrity_algorithms,
        );
        formatter.field("phase2_lifetime_seconds", &self.phase2_lifetime_seconds);
        formatter.field("pre_shared_key", &self.pre_shared_key);
        formatter.field("rekey_fuzz_percentage", &self.rekey_fuzz_percentage);
        formatter.field("rekey_margin_time_seconds", &self.rekey_margin_time_seconds);
        formatter.field("replay_window_size", &self.replay_window_size);
        formatter.field("tunnel_inside_cidr", &self.tunnel_inside_cidr);
        formatter.finish()
    }
}
/// See [`AwsEc2VpnConnectionOptionsTunnelOptionsDetails`](crate::model::AwsEc2VpnConnectionOptionsTunnelOptionsDetails)
pub mod aws_ec2_vpn_connection_options_tunnel_options_details {

    /// A builder for [`AwsEc2VpnConnectionOptionsTunnelOptionsDetails`](crate::model::AwsEc2VpnConnectionOptionsTunnelOptionsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dpd_timeout_seconds: std::option::Option<i32>,
        pub(crate) ike_versions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) outside_ip_address: std::option::Option<std::string::String>,
        pub(crate) phase1_dh_group_numbers: std::option::Option<std::vec::Vec<i32>>,
        pub(crate) phase1_encryption_algorithms:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) phase1_integrity_algorithms:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) phase1_lifetime_seconds: std::option::Option<i32>,
        pub(crate) phase2_dh_group_numbers: std::option::Option<std::vec::Vec<i32>>,
        pub(crate) phase2_encryption_algorithms:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) phase2_integrity_algorithms:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) phase2_lifetime_seconds: std::option::Option<i32>,
        pub(crate) pre_shared_key: std::option::Option<std::string::String>,
        pub(crate) rekey_fuzz_percentage: std::option::Option<i32>,
        pub(crate) rekey_margin_time_seconds: std::option::Option<i32>,
        pub(crate) replay_window_size: std::option::Option<i32>,
        pub(crate) tunnel_inside_cidr: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The number of seconds after which a Dead Peer Detection (DPD) timeout occurs.</p>
        pub fn dpd_timeout_seconds(mut self, input: i32) -> Self {
            self.dpd_timeout_seconds = Some(input);
            self
        }
        /// <p>The number of seconds after which a Dead Peer Detection (DPD) timeout occurs.</p>
        pub fn set_dpd_timeout_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.dpd_timeout_seconds = input;
            self
        }
        /// Appends an item to `ike_versions`.
        ///
        /// To override the contents of this collection use [`set_ike_versions`](Self::set_ike_versions).
        ///
        /// <p>The Internet Key Exchange (IKE) versions that are permitted for the VPN tunnel.</p>
        pub fn ike_versions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ike_versions.unwrap_or_default();
            v.push(input.into());
            self.ike_versions = Some(v);
            self
        }
        /// <p>The Internet Key Exchange (IKE) versions that are permitted for the VPN tunnel.</p>
        pub fn set_ike_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ike_versions = input;
            self
        }
        /// <p>The external IP address of the VPN tunnel.</p>
        pub fn outside_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.outside_ip_address = Some(input.into());
            self
        }
        /// <p>The external IP address of the VPN tunnel.</p>
        pub fn set_outside_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.outside_ip_address = input;
            self
        }
        /// Appends an item to `phase1_dh_group_numbers`.
        ///
        /// To override the contents of this collection use [`set_phase1_dh_group_numbers`](Self::set_phase1_dh_group_numbers).
        ///
        /// <p>The permitted Diffie-Hellman group numbers for the VPN tunnel for phase 1 IKE negotiations.</p>
        pub fn phase1_dh_group_numbers(mut self, input: i32) -> Self {
            let mut v = self.phase1_dh_group_numbers.unwrap_or_default();
            v.push(input);
            self.phase1_dh_group_numbers = Some(v);
            self
        }
        /// <p>The permitted Diffie-Hellman group numbers for the VPN tunnel for phase 1 IKE negotiations.</p>
        pub fn set_phase1_dh_group_numbers(
            mut self,
            input: std::option::Option<std::vec::Vec<i32>>,
        ) -> Self {
            self.phase1_dh_group_numbers = input;
            self
        }
        /// Appends an item to `phase1_encryption_algorithms`.
        ///
        /// To override the contents of this collection use [`set_phase1_encryption_algorithms`](Self::set_phase1_encryption_algorithms).
        ///
        /// <p>The permitted encryption algorithms for the VPN tunnel for phase 1 IKE negotiations.</p>
        pub fn phase1_encryption_algorithms(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.phase1_encryption_algorithms.unwrap_or_default();
            v.push(input.into());
            self.phase1_encryption_algorithms = Some(v);
            self
        }
        /// <p>The permitted encryption algorithms for the VPN tunnel for phase 1 IKE negotiations.</p>
        pub fn set_phase1_encryption_algorithms(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.phase1_encryption_algorithms = input;
            self
        }
        /// Appends an item to `phase1_integrity_algorithms`.
        ///
        /// To override the contents of this collection use [`set_phase1_integrity_algorithms`](Self::set_phase1_integrity_algorithms).
        ///
        /// <p>The permitted integrity algorithms for the VPN tunnel for phase 1 IKE negotiations.</p>
        pub fn phase1_integrity_algorithms(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.phase1_integrity_algorithms.unwrap_or_default();
            v.push(input.into());
            self.phase1_integrity_algorithms = Some(v);
            self
        }
        /// <p>The permitted integrity algorithms for the VPN tunnel for phase 1 IKE negotiations.</p>
        pub fn set_phase1_integrity_algorithms(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.phase1_integrity_algorithms = input;
            self
        }
        /// <p>The lifetime for phase 1 of the IKE negotiation, in seconds.</p>
        pub fn phase1_lifetime_seconds(mut self, input: i32) -> Self {
            self.phase1_lifetime_seconds = Some(input);
            self
        }
        /// <p>The lifetime for phase 1 of the IKE negotiation, in seconds.</p>
        pub fn set_phase1_lifetime_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.phase1_lifetime_seconds = input;
            self
        }
        /// Appends an item to `phase2_dh_group_numbers`.
        ///
        /// To override the contents of this collection use [`set_phase2_dh_group_numbers`](Self::set_phase2_dh_group_numbers).
        ///
        /// <p>The permitted Diffie-Hellman group numbers for the VPN tunnel for phase 2 IKE negotiations.</p>
        pub fn phase2_dh_group_numbers(mut self, input: i32) -> Self {
            let mut v = self.phase2_dh_group_numbers.unwrap_or_default();
            v.push(input);
            self.phase2_dh_group_numbers = Some(v);
            self
        }
        /// <p>The permitted Diffie-Hellman group numbers for the VPN tunnel for phase 2 IKE negotiations.</p>
        pub fn set_phase2_dh_group_numbers(
            mut self,
            input: std::option::Option<std::vec::Vec<i32>>,
        ) -> Self {
            self.phase2_dh_group_numbers = input;
            self
        }
        /// Appends an item to `phase2_encryption_algorithms`.
        ///
        /// To override the contents of this collection use [`set_phase2_encryption_algorithms`](Self::set_phase2_encryption_algorithms).
        ///
        /// <p>The permitted encryption algorithms for the VPN tunnel for phase 2 IKE negotiations.</p>
        pub fn phase2_encryption_algorithms(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.phase2_encryption_algorithms.unwrap_or_default();
            v.push(input.into());
            self.phase2_encryption_algorithms = Some(v);
            self
        }
        /// <p>The permitted encryption algorithms for the VPN tunnel for phase 2 IKE negotiations.</p>
        pub fn set_phase2_encryption_algorithms(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.phase2_encryption_algorithms = input;
            self
        }
        /// Appends an item to `phase2_integrity_algorithms`.
        ///
        /// To override the contents of this collection use [`set_phase2_integrity_algorithms`](Self::set_phase2_integrity_algorithms).
        ///
        /// <p>The permitted integrity algorithms for the VPN tunnel for phase 2 IKE negotiations.</p>
        pub fn phase2_integrity_algorithms(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.phase2_integrity_algorithms.unwrap_or_default();
            v.push(input.into());
            self.phase2_integrity_algorithms = Some(v);
            self
        }
        /// <p>The permitted integrity algorithms for the VPN tunnel for phase 2 IKE negotiations.</p>
        pub fn set_phase2_integrity_algorithms(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.phase2_integrity_algorithms = input;
            self
        }
        /// <p>The lifetime for phase 2 of the IKE negotiation, in seconds.</p>
        pub fn phase2_lifetime_seconds(mut self, input: i32) -> Self {
            self.phase2_lifetime_seconds = Some(input);
            self
        }
        /// <p>The lifetime for phase 2 of the IKE negotiation, in seconds.</p>
        pub fn set_phase2_lifetime_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.phase2_lifetime_seconds = input;
            self
        }
        /// <p>The preshared key to establish initial authentication between the virtual private gateway and the customer gateway.</p>
        pub fn pre_shared_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.pre_shared_key = Some(input.into());
            self
        }
        /// <p>The preshared key to establish initial authentication between the virtual private gateway and the customer gateway.</p>
        pub fn set_pre_shared_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pre_shared_key = input;
            self
        }
        /// <p>The percentage of the rekey window, which is determined by <code>RekeyMarginTimeSeconds</code> during which the rekey time is randomly selected.</p>
        pub fn rekey_fuzz_percentage(mut self, input: i32) -> Self {
            self.rekey_fuzz_percentage = Some(input);
            self
        }
        /// <p>The percentage of the rekey window, which is determined by <code>RekeyMarginTimeSeconds</code> during which the rekey time is randomly selected.</p>
        pub fn set_rekey_fuzz_percentage(mut self, input: std::option::Option<i32>) -> Self {
            self.rekey_fuzz_percentage = input;
            self
        }
        /// <p>The margin time, in seconds, before the phase 2 lifetime expires, during which the Amazon Web Services side of the VPN connection performs an IKE rekey.</p>
        pub fn rekey_margin_time_seconds(mut self, input: i32) -> Self {
            self.rekey_margin_time_seconds = Some(input);
            self
        }
        /// <p>The margin time, in seconds, before the phase 2 lifetime expires, during which the Amazon Web Services side of the VPN connection performs an IKE rekey.</p>
        pub fn set_rekey_margin_time_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.rekey_margin_time_seconds = input;
            self
        }
        /// <p>The number of packets in an IKE replay window.</p>
        pub fn replay_window_size(mut self, input: i32) -> Self {
            self.replay_window_size = Some(input);
            self
        }
        /// <p>The number of packets in an IKE replay window.</p>
        pub fn set_replay_window_size(mut self, input: std::option::Option<i32>) -> Self {
            self.replay_window_size = input;
            self
        }
        /// <p>The range of inside IPv4 addresses for the tunnel.</p>
        pub fn tunnel_inside_cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.tunnel_inside_cidr = Some(input.into());
            self
        }
        /// <p>The range of inside IPv4 addresses for the tunnel.</p>
        pub fn set_tunnel_inside_cidr(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tunnel_inside_cidr = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2VpnConnectionOptionsTunnelOptionsDetails`](crate::model::AwsEc2VpnConnectionOptionsTunnelOptionsDetails)
        pub fn build(self) -> crate::model::AwsEc2VpnConnectionOptionsTunnelOptionsDetails {
            crate::model::AwsEc2VpnConnectionOptionsTunnelOptionsDetails {
                dpd_timeout_seconds: self.dpd_timeout_seconds.unwrap_or_default(),
                ike_versions: self.ike_versions,
                outside_ip_address: self.outside_ip_address,
                phase1_dh_group_numbers: self.phase1_dh_group_numbers,
                phase1_encryption_algorithms: self.phase1_encryption_algorithms,
                phase1_integrity_algorithms: self.phase1_integrity_algorithms,
                phase1_lifetime_seconds: self.phase1_lifetime_seconds.unwrap_or_default(),
                phase2_dh_group_numbers: self.phase2_dh_group_numbers,
                phase2_encryption_algorithms: self.phase2_encryption_algorithms,
                phase2_integrity_algorithms: self.phase2_integrity_algorithms,
                phase2_lifetime_seconds: self.phase2_lifetime_seconds.unwrap_or_default(),
                pre_shared_key: self.pre_shared_key,
                rekey_fuzz_percentage: self.rekey_fuzz_percentage.unwrap_or_default(),
                rekey_margin_time_seconds: self.rekey_margin_time_seconds.unwrap_or_default(),
                replay_window_size: self.replay_window_size.unwrap_or_default(),
                tunnel_inside_cidr: self.tunnel_inside_cidr,
            }
        }
    }
}
impl AwsEc2VpnConnectionOptionsTunnelOptionsDetails {
    /// Creates a new builder-style object to manufacture [`AwsEc2VpnConnectionOptionsTunnelOptionsDetails`](crate::model::AwsEc2VpnConnectionOptionsTunnelOptionsDetails)
    pub fn builder() -> crate::model::aws_ec2_vpn_connection_options_tunnel_options_details::Builder
    {
        crate::model::aws_ec2_vpn_connection_options_tunnel_options_details::Builder::default()
    }
}

/// <p>Information about the VPN tunnel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2VpnConnectionVgwTelemetryDetails {
    /// <p>The number of accepted routes.</p>
    pub accepted_route_count: i32,
    /// <p>The ARN of the VPN tunnel endpoint certificate.</p>
    pub certificate_arn: std::option::Option<std::string::String>,
    /// <p>The date and time of the last change in status.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub last_status_change: std::option::Option<std::string::String>,
    /// <p>The Internet-routable IP address of the virtual private gateway's outside interface.</p>
    pub outside_ip_address: std::option::Option<std::string::String>,
    /// <p>The status of the VPN tunnel.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>If an error occurs, a description of the error.</p>
    pub status_message: std::option::Option<std::string::String>,
}
impl AwsEc2VpnConnectionVgwTelemetryDetails {
    /// <p>The number of accepted routes.</p>
    pub fn accepted_route_count(&self) -> i32 {
        self.accepted_route_count
    }
    /// <p>The ARN of the VPN tunnel endpoint certificate.</p>
    pub fn certificate_arn(&self) -> std::option::Option<&str> {
        self.certificate_arn.as_deref()
    }
    /// <p>The date and time of the last change in status.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn last_status_change(&self) -> std::option::Option<&str> {
        self.last_status_change.as_deref()
    }
    /// <p>The Internet-routable IP address of the virtual private gateway's outside interface.</p>
    pub fn outside_ip_address(&self) -> std::option::Option<&str> {
        self.outside_ip_address.as_deref()
    }
    /// <p>The status of the VPN tunnel.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>If an error occurs, a description of the error.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2VpnConnectionVgwTelemetryDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2VpnConnectionVgwTelemetryDetails");
        formatter.field("accepted_route_count", &self.accepted_route_count);
        formatter.field("certificate_arn", &self.certificate_arn);
        formatter.field("last_status_change", &self.last_status_change);
        formatter.field("outside_ip_address", &self.outside_ip_address);
        formatter.field("status", &self.status);
        formatter.field("status_message", &self.status_message);
        formatter.finish()
    }
}
/// See [`AwsEc2VpnConnectionVgwTelemetryDetails`](crate::model::AwsEc2VpnConnectionVgwTelemetryDetails)
pub mod aws_ec2_vpn_connection_vgw_telemetry_details {

    /// A builder for [`AwsEc2VpnConnectionVgwTelemetryDetails`](crate::model::AwsEc2VpnConnectionVgwTelemetryDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) accepted_route_count: std::option::Option<i32>,
        pub(crate) certificate_arn: std::option::Option<std::string::String>,
        pub(crate) last_status_change: std::option::Option<std::string::String>,
        pub(crate) outside_ip_address: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) status_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The number of accepted routes.</p>
        pub fn accepted_route_count(mut self, input: i32) -> Self {
            self.accepted_route_count = Some(input);
            self
        }
        /// <p>The number of accepted routes.</p>
        pub fn set_accepted_route_count(mut self, input: std::option::Option<i32>) -> Self {
            self.accepted_route_count = input;
            self
        }
        /// <p>The ARN of the VPN tunnel endpoint certificate.</p>
        pub fn certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the VPN tunnel endpoint certificate.</p>
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_arn = input;
            self
        }
        /// <p>The date and time of the last change in status.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn last_status_change(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_status_change = Some(input.into());
            self
        }
        /// <p>The date and time of the last change in status.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_last_status_change(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_status_change = input;
            self
        }
        /// <p>The Internet-routable IP address of the virtual private gateway's outside interface.</p>
        pub fn outside_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.outside_ip_address = Some(input.into());
            self
        }
        /// <p>The Internet-routable IP address of the virtual private gateway's outside interface.</p>
        pub fn set_outside_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.outside_ip_address = input;
            self
        }
        /// <p>The status of the VPN tunnel.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the VPN tunnel.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>If an error occurs, a description of the error.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>If an error occurs, a description of the error.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2VpnConnectionVgwTelemetryDetails`](crate::model::AwsEc2VpnConnectionVgwTelemetryDetails)
        pub fn build(self) -> crate::model::AwsEc2VpnConnectionVgwTelemetryDetails {
            crate::model::AwsEc2VpnConnectionVgwTelemetryDetails {
                accepted_route_count: self.accepted_route_count.unwrap_or_default(),
                certificate_arn: self.certificate_arn,
                last_status_change: self.last_status_change,
                outside_ip_address: self.outside_ip_address,
                status: self.status,
                status_message: self.status_message,
            }
        }
    }
}
impl AwsEc2VpnConnectionVgwTelemetryDetails {
    /// Creates a new builder-style object to manufacture [`AwsEc2VpnConnectionVgwTelemetryDetails`](crate::model::AwsEc2VpnConnectionVgwTelemetryDetails)
    pub fn builder() -> crate::model::aws_ec2_vpn_connection_vgw_telemetry_details::Builder {
        crate::model::aws_ec2_vpn_connection_vgw_telemetry_details::Builder::default()
    }
}

/// <p>Details about a launch configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsAutoScalingLaunchConfigurationDetails {
    /// <p>For Auto Scaling groups that run in a VPC, specifies whether to assign a public IP address to the group's instances.</p>
    pub associate_public_ip_address: bool,
    /// <p>Specifies the block devices for the instance.</p>
    pub block_device_mappings: std::option::Option<
        std::vec::Vec<crate::model::AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails>,
    >,
    /// <p>The identifier of a ClassicLink-enabled VPC that EC2-Classic instances are linked to.</p>
    pub classic_link_vpc_id: std::option::Option<std::string::String>,
    /// <p>The identifiers of one or more security groups for the VPC that is specified in <code>ClassicLinkVPCId</code>.</p>
    pub classic_link_vpc_security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The creation date and time for the launch configuration.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub created_time: std::option::Option<std::string::String>,
    /// <p>Whether the launch configuration is optimized for Amazon EBS I/O.</p>
    pub ebs_optimized: bool,
    /// <p>The name or the ARN of the instance profile associated with the IAM role for the instance. The instance profile contains the IAM role.</p>
    pub iam_instance_profile: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Machine Image (AMI) that is used to launch EC2 instances.</p>
    pub image_id: std::option::Option<std::string::String>,
    /// <p>Indicates the type of monitoring for instances in the group.</p>
    pub instance_monitoring: std::option::Option<
        crate::model::AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails,
    >,
    /// <p>The instance type for the instances.</p>
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>The identifier of the kernel associated with the AMI.</p>
    pub kernel_id: std::option::Option<std::string::String>,
    /// <p>The name of the key pair.</p>
    pub key_name: std::option::Option<std::string::String>,
    /// <p>The name of the launch configuration.</p>
    pub launch_configuration_name: std::option::Option<std::string::String>,
    /// <p>The tenancy of the instance. An instance with <code>dedicated</code> tenancy runs on isolated, single-tenant hardware and can only be launched into a VPC.</p>
    pub placement_tenancy: std::option::Option<std::string::String>,
    /// <p>The identifier of the RAM disk associated with the AMI.</p>
    pub ramdisk_id: std::option::Option<std::string::String>,
    /// <p>The security groups to assign to the instances in the Auto Scaling group.</p>
    pub security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The maximum hourly price to be paid for any Spot Instance that is launched to fulfill the request.</p>
    pub spot_price: std::option::Option<std::string::String>,
    /// <p>The user data to make available to the launched EC2 instances. Must be base64-encoded text.</p>
    pub user_data: std::option::Option<std::string::String>,
    /// <p>The metadata options for the instances.</p>
    pub metadata_options:
        std::option::Option<crate::model::AwsAutoScalingLaunchConfigurationMetadataOptions>,
}
impl AwsAutoScalingLaunchConfigurationDetails {
    /// <p>For Auto Scaling groups that run in a VPC, specifies whether to assign a public IP address to the group's instances.</p>
    pub fn associate_public_ip_address(&self) -> bool {
        self.associate_public_ip_address
    }
    /// <p>Specifies the block devices for the instance.</p>
    pub fn block_device_mappings(
        &self,
    ) -> std::option::Option<
        &[crate::model::AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails],
    > {
        self.block_device_mappings.as_deref()
    }
    /// <p>The identifier of a ClassicLink-enabled VPC that EC2-Classic instances are linked to.</p>
    pub fn classic_link_vpc_id(&self) -> std::option::Option<&str> {
        self.classic_link_vpc_id.as_deref()
    }
    /// <p>The identifiers of one or more security groups for the VPC that is specified in <code>ClassicLinkVPCId</code>.</p>
    pub fn classic_link_vpc_security_groups(&self) -> std::option::Option<&[std::string::String]> {
        self.classic_link_vpc_security_groups.as_deref()
    }
    /// <p>The creation date and time for the launch configuration.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn created_time(&self) -> std::option::Option<&str> {
        self.created_time.as_deref()
    }
    /// <p>Whether the launch configuration is optimized for Amazon EBS I/O.</p>
    pub fn ebs_optimized(&self) -> bool {
        self.ebs_optimized
    }
    /// <p>The name or the ARN of the instance profile associated with the IAM role for the instance. The instance profile contains the IAM role.</p>
    pub fn iam_instance_profile(&self) -> std::option::Option<&str> {
        self.iam_instance_profile.as_deref()
    }
    /// <p>The identifier of the Amazon Machine Image (AMI) that is used to launch EC2 instances.</p>
    pub fn image_id(&self) -> std::option::Option<&str> {
        self.image_id.as_deref()
    }
    /// <p>Indicates the type of monitoring for instances in the group.</p>
    pub fn instance_monitoring(
        &self,
    ) -> std::option::Option<
        &crate::model::AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails,
    > {
        self.instance_monitoring.as_ref()
    }
    /// <p>The instance type for the instances.</p>
    pub fn instance_type(&self) -> std::option::Option<&str> {
        self.instance_type.as_deref()
    }
    /// <p>The identifier of the kernel associated with the AMI.</p>
    pub fn kernel_id(&self) -> std::option::Option<&str> {
        self.kernel_id.as_deref()
    }
    /// <p>The name of the key pair.</p>
    pub fn key_name(&self) -> std::option::Option<&str> {
        self.key_name.as_deref()
    }
    /// <p>The name of the launch configuration.</p>
    pub fn launch_configuration_name(&self) -> std::option::Option<&str> {
        self.launch_configuration_name.as_deref()
    }
    /// <p>The tenancy of the instance. An instance with <code>dedicated</code> tenancy runs on isolated, single-tenant hardware and can only be launched into a VPC.</p>
    pub fn placement_tenancy(&self) -> std::option::Option<&str> {
        self.placement_tenancy.as_deref()
    }
    /// <p>The identifier of the RAM disk associated with the AMI.</p>
    pub fn ramdisk_id(&self) -> std::option::Option<&str> {
        self.ramdisk_id.as_deref()
    }
    /// <p>The security groups to assign to the instances in the Auto Scaling group.</p>
    pub fn security_groups(&self) -> std::option::Option<&[std::string::String]> {
        self.security_groups.as_deref()
    }
    /// <p>The maximum hourly price to be paid for any Spot Instance that is launched to fulfill the request.</p>
    pub fn spot_price(&self) -> std::option::Option<&str> {
        self.spot_price.as_deref()
    }
    /// <p>The user data to make available to the launched EC2 instances. Must be base64-encoded text.</p>
    pub fn user_data(&self) -> std::option::Option<&str> {
        self.user_data.as_deref()
    }
    /// <p>The metadata options for the instances.</p>
    pub fn metadata_options(
        &self,
    ) -> std::option::Option<&crate::model::AwsAutoScalingLaunchConfigurationMetadataOptions> {
        self.metadata_options.as_ref()
    }
}
impl std::fmt::Debug for AwsAutoScalingLaunchConfigurationDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsAutoScalingLaunchConfigurationDetails");
        formatter.field(
            "associate_public_ip_address",
            &self.associate_public_ip_address,
        );
        formatter.field("block_device_mappings", &self.block_device_mappings);
        formatter.field("classic_link_vpc_id", &self.classic_link_vpc_id);
        formatter.field(
            "classic_link_vpc_security_groups",
            &self.classic_link_vpc_security_groups,
        );
        formatter.field("created_time", &self.created_time);
        formatter.field("ebs_optimized", &self.ebs_optimized);
        formatter.field("iam_instance_profile", &self.iam_instance_profile);
        formatter.field("image_id", &self.image_id);
        formatter.field("instance_monitoring", &self.instance_monitoring);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("kernel_id", &self.kernel_id);
        formatter.field("key_name", &self.key_name);
        formatter.field("launch_configuration_name", &self.launch_configuration_name);
        formatter.field("placement_tenancy", &self.placement_tenancy);
        formatter.field("ramdisk_id", &self.ramdisk_id);
        formatter.field("security_groups", &self.security_groups);
        formatter.field("spot_price", &self.spot_price);
        formatter.field("user_data", &self.user_data);
        formatter.field("metadata_options", &self.metadata_options);
        formatter.finish()
    }
}
/// See [`AwsAutoScalingLaunchConfigurationDetails`](crate::model::AwsAutoScalingLaunchConfigurationDetails)
pub mod aws_auto_scaling_launch_configuration_details {

    /// A builder for [`AwsAutoScalingLaunchConfigurationDetails`](crate::model::AwsAutoScalingLaunchConfigurationDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) associate_public_ip_address: std::option::Option<bool>,
        pub(crate) block_device_mappings: std::option::Option<
            std::vec::Vec<
                crate::model::AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails,
            >,
        >,
        pub(crate) classic_link_vpc_id: std::option::Option<std::string::String>,
        pub(crate) classic_link_vpc_security_groups:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) created_time: std::option::Option<std::string::String>,
        pub(crate) ebs_optimized: std::option::Option<bool>,
        pub(crate) iam_instance_profile: std::option::Option<std::string::String>,
        pub(crate) image_id: std::option::Option<std::string::String>,
        pub(crate) instance_monitoring: std::option::Option<
            crate::model::AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails,
        >,
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) kernel_id: std::option::Option<std::string::String>,
        pub(crate) key_name: std::option::Option<std::string::String>,
        pub(crate) launch_configuration_name: std::option::Option<std::string::String>,
        pub(crate) placement_tenancy: std::option::Option<std::string::String>,
        pub(crate) ramdisk_id: std::option::Option<std::string::String>,
        pub(crate) security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) spot_price: std::option::Option<std::string::String>,
        pub(crate) user_data: std::option::Option<std::string::String>,
        pub(crate) metadata_options:
            std::option::Option<crate::model::AwsAutoScalingLaunchConfigurationMetadataOptions>,
    }
    impl Builder {
        /// <p>For Auto Scaling groups that run in a VPC, specifies whether to assign a public IP address to the group's instances.</p>
        pub fn associate_public_ip_address(mut self, input: bool) -> Self {
            self.associate_public_ip_address = Some(input);
            self
        }
        /// <p>For Auto Scaling groups that run in a VPC, specifies whether to assign a public IP address to the group's instances.</p>
        pub fn set_associate_public_ip_address(mut self, input: std::option::Option<bool>) -> Self {
            self.associate_public_ip_address = input;
            self
        }
        /// Appends an item to `block_device_mappings`.
        ///
        /// To override the contents of this collection use [`set_block_device_mappings`](Self::set_block_device_mappings).
        ///
        /// <p>Specifies the block devices for the instance.</p>
        pub fn block_device_mappings(
            mut self,
            input: crate::model::AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails,
        ) -> Self {
            let mut v = self.block_device_mappings.unwrap_or_default();
            v.push(input);
            self.block_device_mappings = Some(v);
            self
        }
        /// <p>Specifies the block devices for the instance.</p>
        pub fn set_block_device_mappings(
            mut self,
            input: std::option::Option<
                std::vec::Vec<
                    crate::model::AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails,
                >,
            >,
        ) -> Self {
            self.block_device_mappings = input;
            self
        }
        /// <p>The identifier of a ClassicLink-enabled VPC that EC2-Classic instances are linked to.</p>
        pub fn classic_link_vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.classic_link_vpc_id = Some(input.into());
            self
        }
        /// <p>The identifier of a ClassicLink-enabled VPC that EC2-Classic instances are linked to.</p>
        pub fn set_classic_link_vpc_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.classic_link_vpc_id = input;
            self
        }
        /// Appends an item to `classic_link_vpc_security_groups`.
        ///
        /// To override the contents of this collection use [`set_classic_link_vpc_security_groups`](Self::set_classic_link_vpc_security_groups).
        ///
        /// <p>The identifiers of one or more security groups for the VPC that is specified in <code>ClassicLinkVPCId</code>.</p>
        pub fn classic_link_vpc_security_groups(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.classic_link_vpc_security_groups.unwrap_or_default();
            v.push(input.into());
            self.classic_link_vpc_security_groups = Some(v);
            self
        }
        /// <p>The identifiers of one or more security groups for the VPC that is specified in <code>ClassicLinkVPCId</code>.</p>
        pub fn set_classic_link_vpc_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.classic_link_vpc_security_groups = input;
            self
        }
        /// <p>The creation date and time for the launch configuration.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn created_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_time = Some(input.into());
            self
        }
        /// <p>The creation date and time for the launch configuration.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_created_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_time = input;
            self
        }
        /// <p>Whether the launch configuration is optimized for Amazon EBS I/O.</p>
        pub fn ebs_optimized(mut self, input: bool) -> Self {
            self.ebs_optimized = Some(input);
            self
        }
        /// <p>Whether the launch configuration is optimized for Amazon EBS I/O.</p>
        pub fn set_ebs_optimized(mut self, input: std::option::Option<bool>) -> Self {
            self.ebs_optimized = input;
            self
        }
        /// <p>The name or the ARN of the instance profile associated with the IAM role for the instance. The instance profile contains the IAM role.</p>
        pub fn iam_instance_profile(mut self, input: impl Into<std::string::String>) -> Self {
            self.iam_instance_profile = Some(input.into());
            self
        }
        /// <p>The name or the ARN of the instance profile associated with the IAM role for the instance. The instance profile contains the IAM role.</p>
        pub fn set_iam_instance_profile(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.iam_instance_profile = input;
            self
        }
        /// <p>The identifier of the Amazon Machine Image (AMI) that is used to launch EC2 instances.</p>
        pub fn image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Machine Image (AMI) that is used to launch EC2 instances.</p>
        pub fn set_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_id = input;
            self
        }
        /// <p>Indicates the type of monitoring for instances in the group.</p>
        pub fn instance_monitoring(
            mut self,
            input: crate::model::AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails,
        ) -> Self {
            self.instance_monitoring = Some(input);
            self
        }
        /// <p>Indicates the type of monitoring for instances in the group.</p>
        pub fn set_instance_monitoring(
            mut self,
            input: std::option::Option<
                crate::model::AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails,
            >,
        ) -> Self {
            self.instance_monitoring = input;
            self
        }
        /// <p>The instance type for the instances.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        /// <p>The instance type for the instances.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The identifier of the kernel associated with the AMI.</p>
        pub fn kernel_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kernel_id = Some(input.into());
            self
        }
        /// <p>The identifier of the kernel associated with the AMI.</p>
        pub fn set_kernel_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kernel_id = input;
            self
        }
        /// <p>The name of the key pair.</p>
        pub fn key_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_name = Some(input.into());
            self
        }
        /// <p>The name of the key pair.</p>
        pub fn set_key_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_name = input;
            self
        }
        /// <p>The name of the launch configuration.</p>
        pub fn launch_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_configuration_name = Some(input.into());
            self
        }
        /// <p>The name of the launch configuration.</p>
        pub fn set_launch_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_configuration_name = input;
            self
        }
        /// <p>The tenancy of the instance. An instance with <code>dedicated</code> tenancy runs on isolated, single-tenant hardware and can only be launched into a VPC.</p>
        pub fn placement_tenancy(mut self, input: impl Into<std::string::String>) -> Self {
            self.placement_tenancy = Some(input.into());
            self
        }
        /// <p>The tenancy of the instance. An instance with <code>dedicated</code> tenancy runs on isolated, single-tenant hardware and can only be launched into a VPC.</p>
        pub fn set_placement_tenancy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.placement_tenancy = input;
            self
        }
        /// <p>The identifier of the RAM disk associated with the AMI.</p>
        pub fn ramdisk_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ramdisk_id = Some(input.into());
            self
        }
        /// <p>The identifier of the RAM disk associated with the AMI.</p>
        pub fn set_ramdisk_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ramdisk_id = input;
            self
        }
        /// Appends an item to `security_groups`.
        ///
        /// To override the contents of this collection use [`set_security_groups`](Self::set_security_groups).
        ///
        /// <p>The security groups to assign to the instances in the Auto Scaling group.</p>
        pub fn security_groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_groups.unwrap_or_default();
            v.push(input.into());
            self.security_groups = Some(v);
            self
        }
        /// <p>The security groups to assign to the instances in the Auto Scaling group.</p>
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_groups = input;
            self
        }
        /// <p>The maximum hourly price to be paid for any Spot Instance that is launched to fulfill the request.</p>
        pub fn spot_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.spot_price = Some(input.into());
            self
        }
        /// <p>The maximum hourly price to be paid for any Spot Instance that is launched to fulfill the request.</p>
        pub fn set_spot_price(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.spot_price = input;
            self
        }
        /// <p>The user data to make available to the launched EC2 instances. Must be base64-encoded text.</p>
        pub fn user_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_data = Some(input.into());
            self
        }
        /// <p>The user data to make available to the launched EC2 instances. Must be base64-encoded text.</p>
        pub fn set_user_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_data = input;
            self
        }
        /// <p>The metadata options for the instances.</p>
        pub fn metadata_options(
            mut self,
            input: crate::model::AwsAutoScalingLaunchConfigurationMetadataOptions,
        ) -> Self {
            self.metadata_options = Some(input);
            self
        }
        /// <p>The metadata options for the instances.</p>
        pub fn set_metadata_options(
            mut self,
            input: std::option::Option<
                crate::model::AwsAutoScalingLaunchConfigurationMetadataOptions,
            >,
        ) -> Self {
            self.metadata_options = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsAutoScalingLaunchConfigurationDetails`](crate::model::AwsAutoScalingLaunchConfigurationDetails)
        pub fn build(self) -> crate::model::AwsAutoScalingLaunchConfigurationDetails {
            crate::model::AwsAutoScalingLaunchConfigurationDetails {
                associate_public_ip_address: self.associate_public_ip_address.unwrap_or_default(),
                block_device_mappings: self.block_device_mappings,
                classic_link_vpc_id: self.classic_link_vpc_id,
                classic_link_vpc_security_groups: self.classic_link_vpc_security_groups,
                created_time: self.created_time,
                ebs_optimized: self.ebs_optimized.unwrap_or_default(),
                iam_instance_profile: self.iam_instance_profile,
                image_id: self.image_id,
                instance_monitoring: self.instance_monitoring,
                instance_type: self.instance_type,
                kernel_id: self.kernel_id,
                key_name: self.key_name,
                launch_configuration_name: self.launch_configuration_name,
                placement_tenancy: self.placement_tenancy,
                ramdisk_id: self.ramdisk_id,
                security_groups: self.security_groups,
                spot_price: self.spot_price,
                user_data: self.user_data,
                metadata_options: self.metadata_options,
            }
        }
    }
}
impl AwsAutoScalingLaunchConfigurationDetails {
    /// Creates a new builder-style object to manufacture [`AwsAutoScalingLaunchConfigurationDetails`](crate::model::AwsAutoScalingLaunchConfigurationDetails)
    pub fn builder() -> crate::model::aws_auto_scaling_launch_configuration_details::Builder {
        crate::model::aws_auto_scaling_launch_configuration_details::Builder::default()
    }
}

/// <p>The metadata options for the instances.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsAutoScalingLaunchConfigurationMetadataOptions {
    /// <p>Enables or disables the HTTP metadata endpoint on your instances. By default, the metadata endpoint is enabled.</p>
    pub http_endpoint: std::option::Option<std::string::String>,
    /// <p>The HTTP <code>PUT</code> response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.</p>
    pub http_put_response_hop_limit: i32,
    /// <p>Indicates whether token usage is <code>required</code> or <code>optional</code> for metadata requests. By default, token usage is <code>optional</code>.</p>
    pub http_tokens: std::option::Option<std::string::String>,
}
impl AwsAutoScalingLaunchConfigurationMetadataOptions {
    /// <p>Enables or disables the HTTP metadata endpoint on your instances. By default, the metadata endpoint is enabled.</p>
    pub fn http_endpoint(&self) -> std::option::Option<&str> {
        self.http_endpoint.as_deref()
    }
    /// <p>The HTTP <code>PUT</code> response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.</p>
    pub fn http_put_response_hop_limit(&self) -> i32 {
        self.http_put_response_hop_limit
    }
    /// <p>Indicates whether token usage is <code>required</code> or <code>optional</code> for metadata requests. By default, token usage is <code>optional</code>.</p>
    pub fn http_tokens(&self) -> std::option::Option<&str> {
        self.http_tokens.as_deref()
    }
}
impl std::fmt::Debug for AwsAutoScalingLaunchConfigurationMetadataOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsAutoScalingLaunchConfigurationMetadataOptions");
        formatter.field("http_endpoint", &self.http_endpoint);
        formatter.field(
            "http_put_response_hop_limit",
            &self.http_put_response_hop_limit,
        );
        formatter.field("http_tokens", &self.http_tokens);
        formatter.finish()
    }
}
/// See [`AwsAutoScalingLaunchConfigurationMetadataOptions`](crate::model::AwsAutoScalingLaunchConfigurationMetadataOptions)
pub mod aws_auto_scaling_launch_configuration_metadata_options {

    /// A builder for [`AwsAutoScalingLaunchConfigurationMetadataOptions`](crate::model::AwsAutoScalingLaunchConfigurationMetadataOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) http_endpoint: std::option::Option<std::string::String>,
        pub(crate) http_put_response_hop_limit: std::option::Option<i32>,
        pub(crate) http_tokens: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Enables or disables the HTTP metadata endpoint on your instances. By default, the metadata endpoint is enabled.</p>
        pub fn http_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.http_endpoint = Some(input.into());
            self
        }
        /// <p>Enables or disables the HTTP metadata endpoint on your instances. By default, the metadata endpoint is enabled.</p>
        pub fn set_http_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.http_endpoint = input;
            self
        }
        /// <p>The HTTP <code>PUT</code> response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.</p>
        pub fn http_put_response_hop_limit(mut self, input: i32) -> Self {
            self.http_put_response_hop_limit = Some(input);
            self
        }
        /// <p>The HTTP <code>PUT</code> response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.</p>
        pub fn set_http_put_response_hop_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.http_put_response_hop_limit = input;
            self
        }
        /// <p>Indicates whether token usage is <code>required</code> or <code>optional</code> for metadata requests. By default, token usage is <code>optional</code>.</p>
        pub fn http_tokens(mut self, input: impl Into<std::string::String>) -> Self {
            self.http_tokens = Some(input.into());
            self
        }
        /// <p>Indicates whether token usage is <code>required</code> or <code>optional</code> for metadata requests. By default, token usage is <code>optional</code>.</p>
        pub fn set_http_tokens(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.http_tokens = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsAutoScalingLaunchConfigurationMetadataOptions`](crate::model::AwsAutoScalingLaunchConfigurationMetadataOptions)
        pub fn build(self) -> crate::model::AwsAutoScalingLaunchConfigurationMetadataOptions {
            crate::model::AwsAutoScalingLaunchConfigurationMetadataOptions {
                http_endpoint: self.http_endpoint,
                http_put_response_hop_limit: self.http_put_response_hop_limit.unwrap_or_default(),
                http_tokens: self.http_tokens,
            }
        }
    }
}
impl AwsAutoScalingLaunchConfigurationMetadataOptions {
    /// Creates a new builder-style object to manufacture [`AwsAutoScalingLaunchConfigurationMetadataOptions`](crate::model::AwsAutoScalingLaunchConfigurationMetadataOptions)
    pub fn builder() -> crate::model::aws_auto_scaling_launch_configuration_metadata_options::Builder
    {
        crate::model::aws_auto_scaling_launch_configuration_metadata_options::Builder::default()
    }
}

/// <p>Information about the type of monitoring for instances in the group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails {
    /// <p>If set to <code>true</code>, then instances in the group launch with detailed monitoring.</p>
    /// <p>If set to <code>false</code>, then instances in the group launch with basic monitoring.</p>
    pub enabled: bool,
}
impl AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails {
    /// <p>If set to <code>true</code>, then instances in the group launch with detailed monitoring.</p>
    /// <p>If set to <code>false</code>, then instances in the group launch with basic monitoring.</p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
}
impl std::fmt::Debug for AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails");
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails`](crate::model::AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails)
pub mod aws_auto_scaling_launch_configuration_instance_monitoring_details {

    /// A builder for [`AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails`](crate::model::AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>If set to <code>true</code>, then instances in the group launch with detailed monitoring.</p>
        /// <p>If set to <code>false</code>, then instances in the group launch with basic monitoring.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>If set to <code>true</code>, then instances in the group launch with detailed monitoring.</p>
        /// <p>If set to <code>false</code>, then instances in the group launch with basic monitoring.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails`](crate::model::AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails {
            crate::model::AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails {
                enabled: self.enabled.unwrap_or_default(),
            }
        }
    }
}
impl AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails {
    /// Creates a new builder-style object to manufacture [`AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails`](crate::model::AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails)
    pub fn builder(
    ) -> crate::model::aws_auto_scaling_launch_configuration_instance_monitoring_details::Builder
    {
        crate::model::aws_auto_scaling_launch_configuration_instance_monitoring_details::Builder::default()
    }
}

/// <p>A block device for the instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails {
    /// <p>The device name that is exposed to the EC2 instance. For example, <code>/dev/sdh</code> or <code>xvdh</code>.</p>
    pub device_name: std::option::Option<std::string::String>,
    /// <p>Parameters that are used to automatically set up Amazon EBS volumes when an instance is launched.</p>
    pub ebs: std::option::Option<
        crate::model::AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails,
    >,
    /// <p>Whether to suppress the device that is included in the block device mapping of the Amazon Machine Image (AMI).</p>
    /// <p>If <code>NoDevice</code> is <code>true</code>, then you cannot specify <code>Ebs</code>.&gt;</p>
    pub no_device: bool,
    /// <p>The name of the virtual device (for example, <code>ephemeral0</code>).</p>
    /// <p>You can provide either <code>VirtualName</code> or <code>Ebs</code>, but not both.</p>
    pub virtual_name: std::option::Option<std::string::String>,
}
impl AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails {
    /// <p>The device name that is exposed to the EC2 instance. For example, <code>/dev/sdh</code> or <code>xvdh</code>.</p>
    pub fn device_name(&self) -> std::option::Option<&str> {
        self.device_name.as_deref()
    }
    /// <p>Parameters that are used to automatically set up Amazon EBS volumes when an instance is launched.</p>
    pub fn ebs(
        &self,
    ) -> std::option::Option<
        &crate::model::AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails,
    > {
        self.ebs.as_ref()
    }
    /// <p>Whether to suppress the device that is included in the block device mapping of the Amazon Machine Image (AMI).</p>
    /// <p>If <code>NoDevice</code> is <code>true</code>, then you cannot specify <code>Ebs</code>.&gt;</p>
    pub fn no_device(&self) -> bool {
        self.no_device
    }
    /// <p>The name of the virtual device (for example, <code>ephemeral0</code>).</p>
    /// <p>You can provide either <code>VirtualName</code> or <code>Ebs</code>, but not both.</p>
    pub fn virtual_name(&self) -> std::option::Option<&str> {
        self.virtual_name.as_deref()
    }
}
impl std::fmt::Debug for AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails");
        formatter.field("device_name", &self.device_name);
        formatter.field("ebs", &self.ebs);
        formatter.field("no_device", &self.no_device);
        formatter.field("virtual_name", &self.virtual_name);
        formatter.finish()
    }
}
/// See [`AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails`](crate::model::AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails)
pub mod aws_auto_scaling_launch_configuration_block_device_mappings_details {

    /// A builder for [`AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails`](crate::model::AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_name: std::option::Option<std::string::String>,
        pub(crate) ebs: std::option::Option<
            crate::model::AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails,
        >,
        pub(crate) no_device: std::option::Option<bool>,
        pub(crate) virtual_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The device name that is exposed to the EC2 instance. For example, <code>/dev/sdh</code> or <code>xvdh</code>.</p>
        pub fn device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_name = Some(input.into());
            self
        }
        /// <p>The device name that is exposed to the EC2 instance. For example, <code>/dev/sdh</code> or <code>xvdh</code>.</p>
        pub fn set_device_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_name = input;
            self
        }
        /// <p>Parameters that are used to automatically set up Amazon EBS volumes when an instance is launched.</p>
        pub fn ebs(
            mut self,
            input: crate::model::AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails,
        ) -> Self {
            self.ebs = Some(input);
            self
        }
        /// <p>Parameters that are used to automatically set up Amazon EBS volumes when an instance is launched.</p>
        pub fn set_ebs(
            mut self,
            input: std::option::Option<
                crate::model::AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails,
            >,
        ) -> Self {
            self.ebs = input;
            self
        }
        /// <p>Whether to suppress the device that is included in the block device mapping of the Amazon Machine Image (AMI).</p>
        /// <p>If <code>NoDevice</code> is <code>true</code>, then you cannot specify <code>Ebs</code>.&gt;</p>
        pub fn no_device(mut self, input: bool) -> Self {
            self.no_device = Some(input);
            self
        }
        /// <p>Whether to suppress the device that is included in the block device mapping of the Amazon Machine Image (AMI).</p>
        /// <p>If <code>NoDevice</code> is <code>true</code>, then you cannot specify <code>Ebs</code>.&gt;</p>
        pub fn set_no_device(mut self, input: std::option::Option<bool>) -> Self {
            self.no_device = input;
            self
        }
        /// <p>The name of the virtual device (for example, <code>ephemeral0</code>).</p>
        /// <p>You can provide either <code>VirtualName</code> or <code>Ebs</code>, but not both.</p>
        pub fn virtual_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.virtual_name = Some(input.into());
            self
        }
        /// <p>The name of the virtual device (for example, <code>ephemeral0</code>).</p>
        /// <p>You can provide either <code>VirtualName</code> or <code>Ebs</code>, but not both.</p>
        pub fn set_virtual_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.virtual_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails`](crate::model::AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails {
            crate::model::AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails {
                device_name: self.device_name,
                ebs: self.ebs,
                no_device: self.no_device.unwrap_or_default(),
                virtual_name: self.virtual_name,
            }
        }
    }
}
impl AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails {
    /// Creates a new builder-style object to manufacture [`AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails`](crate::model::AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails)
    pub fn builder(
    ) -> crate::model::aws_auto_scaling_launch_configuration_block_device_mappings_details::Builder
    {
        crate::model::aws_auto_scaling_launch_configuration_block_device_mappings_details::Builder::default()
    }
}

/// <p>Parameters that are used to automatically set up EBS volumes when an instance is launched.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails {
    /// <p>Whether to delete the volume when the instance is terminated.</p>
    pub delete_on_termination: bool,
    /// <p>Whether to encrypt the volume.</p>
    pub encrypted: bool,
    /// <p>The number of input/output (I/O) operations per second (IOPS) to provision for the volume.</p>
    /// <p>Only supported for <code>gp3</code> or <code>io1</code> volumes. Required for <code>io1</code> volumes. Not used with <code>standard</code>, <code>gp2</code>, <code>st1</code>, or <code>sc1</code> volumes.</p>
    pub iops: i32,
    /// <p>The snapshot ID of the volume to use.</p>
    /// <p>You must specify either <code>VolumeSize</code> or <code>SnapshotId</code>.</p>
    pub snapshot_id: std::option::Option<std::string::String>,
    /// <p>The volume size, in GiBs. The following are the supported volumes sizes for each volume type:</p>
    /// <ul>
    /// <li> <p>gp2 and gp3: 1-16,384</p> </li>
    /// <li> <p>io1: 4-16,384</p> </li>
    /// <li> <p>st1 and sc1: 125-16,384</p> </li>
    /// <li> <p>standard: 1-1,024</p> </li>
    /// </ul>
    /// <p>You must specify either <code>SnapshotId</code> or <code>VolumeSize</code>. If you specify both <code>SnapshotId</code> and <code>VolumeSize</code>, the volume size must be equal or greater than the size of the snapshot.</p>
    pub volume_size: i32,
    /// <p>The volume type.</p>
    pub volume_type: std::option::Option<std::string::String>,
}
impl AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails {
    /// <p>Whether to delete the volume when the instance is terminated.</p>
    pub fn delete_on_termination(&self) -> bool {
        self.delete_on_termination
    }
    /// <p>Whether to encrypt the volume.</p>
    pub fn encrypted(&self) -> bool {
        self.encrypted
    }
    /// <p>The number of input/output (I/O) operations per second (IOPS) to provision for the volume.</p>
    /// <p>Only supported for <code>gp3</code> or <code>io1</code> volumes. Required for <code>io1</code> volumes. Not used with <code>standard</code>, <code>gp2</code>, <code>st1</code>, or <code>sc1</code> volumes.</p>
    pub fn iops(&self) -> i32 {
        self.iops
    }
    /// <p>The snapshot ID of the volume to use.</p>
    /// <p>You must specify either <code>VolumeSize</code> or <code>SnapshotId</code>.</p>
    pub fn snapshot_id(&self) -> std::option::Option<&str> {
        self.snapshot_id.as_deref()
    }
    /// <p>The volume size, in GiBs. The following are the supported volumes sizes for each volume type:</p>
    /// <ul>
    /// <li> <p>gp2 and gp3: 1-16,384</p> </li>
    /// <li> <p>io1: 4-16,384</p> </li>
    /// <li> <p>st1 and sc1: 125-16,384</p> </li>
    /// <li> <p>standard: 1-1,024</p> </li>
    /// </ul>
    /// <p>You must specify either <code>SnapshotId</code> or <code>VolumeSize</code>. If you specify both <code>SnapshotId</code> and <code>VolumeSize</code>, the volume size must be equal or greater than the size of the snapshot.</p>
    pub fn volume_size(&self) -> i32 {
        self.volume_size
    }
    /// <p>The volume type.</p>
    pub fn volume_type(&self) -> std::option::Option<&str> {
        self.volume_type.as_deref()
    }
}
impl std::fmt::Debug for AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails");
        formatter.field("delete_on_termination", &self.delete_on_termination);
        formatter.field("encrypted", &self.encrypted);
        formatter.field("iops", &self.iops);
        formatter.field("snapshot_id", &self.snapshot_id);
        formatter.field("volume_size", &self.volume_size);
        formatter.field("volume_type", &self.volume_type);
        formatter.finish()
    }
}
/// See [`AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails`](crate::model::AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails)
pub mod aws_auto_scaling_launch_configuration_block_device_mappings_ebs_details {

    /// A builder for [`AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails`](crate::model::AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) delete_on_termination: std::option::Option<bool>,
        pub(crate) encrypted: std::option::Option<bool>,
        pub(crate) iops: std::option::Option<i32>,
        pub(crate) snapshot_id: std::option::Option<std::string::String>,
        pub(crate) volume_size: std::option::Option<i32>,
        pub(crate) volume_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Whether to delete the volume when the instance is terminated.</p>
        pub fn delete_on_termination(mut self, input: bool) -> Self {
            self.delete_on_termination = Some(input);
            self
        }
        /// <p>Whether to delete the volume when the instance is terminated.</p>
        pub fn set_delete_on_termination(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_on_termination = input;
            self
        }
        /// <p>Whether to encrypt the volume.</p>
        pub fn encrypted(mut self, input: bool) -> Self {
            self.encrypted = Some(input);
            self
        }
        /// <p>Whether to encrypt the volume.</p>
        pub fn set_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.encrypted = input;
            self
        }
        /// <p>The number of input/output (I/O) operations per second (IOPS) to provision for the volume.</p>
        /// <p>Only supported for <code>gp3</code> or <code>io1</code> volumes. Required for <code>io1</code> volumes. Not used with <code>standard</code>, <code>gp2</code>, <code>st1</code>, or <code>sc1</code> volumes.</p>
        pub fn iops(mut self, input: i32) -> Self {
            self.iops = Some(input);
            self
        }
        /// <p>The number of input/output (I/O) operations per second (IOPS) to provision for the volume.</p>
        /// <p>Only supported for <code>gp3</code> or <code>io1</code> volumes. Required for <code>io1</code> volumes. Not used with <code>standard</code>, <code>gp2</code>, <code>st1</code>, or <code>sc1</code> volumes.</p>
        pub fn set_iops(mut self, input: std::option::Option<i32>) -> Self {
            self.iops = input;
            self
        }
        /// <p>The snapshot ID of the volume to use.</p>
        /// <p>You must specify either <code>VolumeSize</code> or <code>SnapshotId</code>.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_id = Some(input.into());
            self
        }
        /// <p>The snapshot ID of the volume to use.</p>
        /// <p>You must specify either <code>VolumeSize</code> or <code>SnapshotId</code>.</p>
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.snapshot_id = input;
            self
        }
        /// <p>The volume size, in GiBs. The following are the supported volumes sizes for each volume type:</p>
        /// <ul>
        /// <li> <p>gp2 and gp3: 1-16,384</p> </li>
        /// <li> <p>io1: 4-16,384</p> </li>
        /// <li> <p>st1 and sc1: 125-16,384</p> </li>
        /// <li> <p>standard: 1-1,024</p> </li>
        /// </ul>
        /// <p>You must specify either <code>SnapshotId</code> or <code>VolumeSize</code>. If you specify both <code>SnapshotId</code> and <code>VolumeSize</code>, the volume size must be equal or greater than the size of the snapshot.</p>
        pub fn volume_size(mut self, input: i32) -> Self {
            self.volume_size = Some(input);
            self
        }
        /// <p>The volume size, in GiBs. The following are the supported volumes sizes for each volume type:</p>
        /// <ul>
        /// <li> <p>gp2 and gp3: 1-16,384</p> </li>
        /// <li> <p>io1: 4-16,384</p> </li>
        /// <li> <p>st1 and sc1: 125-16,384</p> </li>
        /// <li> <p>standard: 1-1,024</p> </li>
        /// </ul>
        /// <p>You must specify either <code>SnapshotId</code> or <code>VolumeSize</code>. If you specify both <code>SnapshotId</code> and <code>VolumeSize</code>, the volume size must be equal or greater than the size of the snapshot.</p>
        pub fn set_volume_size(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_size = input;
            self
        }
        /// <p>The volume type.</p>
        pub fn volume_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_type = Some(input.into());
            self
        }
        /// <p>The volume type.</p>
        pub fn set_volume_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.volume_type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails`](crate::model::AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails {
            crate::model::AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails {
                delete_on_termination: self.delete_on_termination.unwrap_or_default(),
                encrypted: self.encrypted.unwrap_or_default(),
                iops: self.iops.unwrap_or_default(),
                snapshot_id: self.snapshot_id,
                volume_size: self.volume_size.unwrap_or_default(),
                volume_type: self.volume_type,
            }
        }
    }
}
impl AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails {
    /// Creates a new builder-style object to manufacture [`AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails`](crate::model::AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails)
    pub fn builder() -> crate::model::aws_auto_scaling_launch_configuration_block_device_mappings_ebs_details::Builder{
        crate::model::aws_auto_scaling_launch_configuration_block_device_mappings_ebs_details::Builder::default()
    }
}

/// <p>Provides details about a service within an ECS cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsServiceDetails {
    /// <p>The capacity provider strategy that the service uses.</p>
    pub capacity_provider_strategy: std::option::Option<
        std::vec::Vec<crate::model::AwsEcsServiceCapacityProviderStrategyDetails>,
    >,
    /// <p>The ARN of the cluster that hosts the service.</p>
    pub cluster: std::option::Option<std::string::String>,
    /// <p>Deployment parameters for the service. Includes the number of tasks that run and the order in which to start and stop tasks.</p>
    pub deployment_configuration:
        std::option::Option<crate::model::AwsEcsServiceDeploymentConfigurationDetails>,
    /// <p>Contains the deployment controller type that the service uses.</p>
    pub deployment_controller:
        std::option::Option<crate::model::AwsEcsServiceDeploymentControllerDetails>,
    /// <p>The number of instantiations of the task definition to run on the service.</p>
    pub desired_count: i32,
    /// <p>Whether to enable Amazon ECS managed tags for the tasks in the service.</p>
    pub enable_ecs_managed_tags: bool,
    /// <p>Whether the execute command functionality is enabled for the service.</p>
    pub enable_execute_command: bool,
    /// <p>After a task starts, the amount of time in seconds that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks.</p>
    pub health_check_grace_period_seconds: i32,
    /// <p>The launch type that the service uses.</p>
    /// <p>Valid values: <code>EC2</code> | <code>FARGATE</code> | <code>EXTERNAL</code> </p>
    pub launch_type: std::option::Option<std::string::String>,
    /// <p>Information about the load balancers that the service uses.</p>
    pub load_balancers:
        std::option::Option<std::vec::Vec<crate::model::AwsEcsServiceLoadBalancersDetails>>,
    /// <p>The name of the service.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>For tasks that use the <code>awsvpc</code> networking mode, the VPC subnet and security group configuration.</p>
    pub network_configuration:
        std::option::Option<crate::model::AwsEcsServiceNetworkConfigurationDetails>,
    /// <p>The placement constraints for the tasks in the service.</p>
    pub placement_constraints:
        std::option::Option<std::vec::Vec<crate::model::AwsEcsServicePlacementConstraintsDetails>>,
    /// <p>Information about how tasks for the service are placed.</p>
    pub placement_strategies:
        std::option::Option<std::vec::Vec<crate::model::AwsEcsServicePlacementStrategiesDetails>>,
    /// <p>The platform version on which to run the service. Only specified for tasks that are hosted on Fargate. If a platform version is not specified, the <code>LATEST</code> platform version is used by default.</p>
    pub platform_version: std::option::Option<std::string::String>,
    /// <p>Indicates whether to propagate the tags from the task definition to the task or from the service to the task. If no value is provided, then tags are not propagated.</p>
    /// <p>Valid values: <code>TASK_DEFINITION</code> | <code>SERVICE</code> </p>
    pub propagate_tags: std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM role that is associated with the service. The role allows the Amazon ECS container agent to register container instances with an Elastic Load Balancing load balancer.</p>
    pub role: std::option::Option<std::string::String>,
    /// <p>The scheduling strategy to use for the service.</p>
    /// <p>The <code>REPLICA</code> scheduling strategy places and maintains the desired number of tasks across the cluster. By default, the service scheduler spreads tasks across Availability Zones. Task placement strategies and constraints are used to customize task placement decisions.</p>
    /// <p>The <code>DAEMON</code> scheduling strategy deploys exactly one task on each active container instance that meets all of the task placement constraints that are specified in the cluster. The service scheduler also evaluates the task placement constraints for running tasks and stops tasks that do not meet the placement constraints.</p>
    /// <p>Valid values: <code>REPLICA</code> | <code>DAEMON</code> </p>
    pub scheduling_strategy: std::option::Option<std::string::String>,
    /// <p>The ARN of the service.</p>
    pub service_arn: std::option::Option<std::string::String>,
    /// <p>The name of the service.</p>
    /// <p>The name can contain up to 255 characters. It can use letters, numbers, underscores, and hyphens.</p>
    pub service_name: std::option::Option<std::string::String>,
    /// <p>Information about the service discovery registries to assign to the service.</p>
    pub service_registries:
        std::option::Option<std::vec::Vec<crate::model::AwsEcsServiceServiceRegistriesDetails>>,
    /// <p>The task definition to use for tasks in the service.</p>
    pub task_definition: std::option::Option<std::string::String>,
}
impl AwsEcsServiceDetails {
    /// <p>The capacity provider strategy that the service uses.</p>
    pub fn capacity_provider_strategy(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEcsServiceCapacityProviderStrategyDetails]> {
        self.capacity_provider_strategy.as_deref()
    }
    /// <p>The ARN of the cluster that hosts the service.</p>
    pub fn cluster(&self) -> std::option::Option<&str> {
        self.cluster.as_deref()
    }
    /// <p>Deployment parameters for the service. Includes the number of tasks that run and the order in which to start and stop tasks.</p>
    pub fn deployment_configuration(
        &self,
    ) -> std::option::Option<&crate::model::AwsEcsServiceDeploymentConfigurationDetails> {
        self.deployment_configuration.as_ref()
    }
    /// <p>Contains the deployment controller type that the service uses.</p>
    pub fn deployment_controller(
        &self,
    ) -> std::option::Option<&crate::model::AwsEcsServiceDeploymentControllerDetails> {
        self.deployment_controller.as_ref()
    }
    /// <p>The number of instantiations of the task definition to run on the service.</p>
    pub fn desired_count(&self) -> i32 {
        self.desired_count
    }
    /// <p>Whether to enable Amazon ECS managed tags for the tasks in the service.</p>
    pub fn enable_ecs_managed_tags(&self) -> bool {
        self.enable_ecs_managed_tags
    }
    /// <p>Whether the execute command functionality is enabled for the service.</p>
    pub fn enable_execute_command(&self) -> bool {
        self.enable_execute_command
    }
    /// <p>After a task starts, the amount of time in seconds that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks.</p>
    pub fn health_check_grace_period_seconds(&self) -> i32 {
        self.health_check_grace_period_seconds
    }
    /// <p>The launch type that the service uses.</p>
    /// <p>Valid values: <code>EC2</code> | <code>FARGATE</code> | <code>EXTERNAL</code> </p>
    pub fn launch_type(&self) -> std::option::Option<&str> {
        self.launch_type.as_deref()
    }
    /// <p>Information about the load balancers that the service uses.</p>
    pub fn load_balancers(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEcsServiceLoadBalancersDetails]> {
        self.load_balancers.as_deref()
    }
    /// <p>The name of the service.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>For tasks that use the <code>awsvpc</code> networking mode, the VPC subnet and security group configuration.</p>
    pub fn network_configuration(
        &self,
    ) -> std::option::Option<&crate::model::AwsEcsServiceNetworkConfigurationDetails> {
        self.network_configuration.as_ref()
    }
    /// <p>The placement constraints for the tasks in the service.</p>
    pub fn placement_constraints(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEcsServicePlacementConstraintsDetails]> {
        self.placement_constraints.as_deref()
    }
    /// <p>Information about how tasks for the service are placed.</p>
    pub fn placement_strategies(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEcsServicePlacementStrategiesDetails]> {
        self.placement_strategies.as_deref()
    }
    /// <p>The platform version on which to run the service. Only specified for tasks that are hosted on Fargate. If a platform version is not specified, the <code>LATEST</code> platform version is used by default.</p>
    pub fn platform_version(&self) -> std::option::Option<&str> {
        self.platform_version.as_deref()
    }
    /// <p>Indicates whether to propagate the tags from the task definition to the task or from the service to the task. If no value is provided, then tags are not propagated.</p>
    /// <p>Valid values: <code>TASK_DEFINITION</code> | <code>SERVICE</code> </p>
    pub fn propagate_tags(&self) -> std::option::Option<&str> {
        self.propagate_tags.as_deref()
    }
    /// <p>The ARN of the IAM role that is associated with the service. The role allows the Amazon ECS container agent to register container instances with an Elastic Load Balancing load balancer.</p>
    pub fn role(&self) -> std::option::Option<&str> {
        self.role.as_deref()
    }
    /// <p>The scheduling strategy to use for the service.</p>
    /// <p>The <code>REPLICA</code> scheduling strategy places and maintains the desired number of tasks across the cluster. By default, the service scheduler spreads tasks across Availability Zones. Task placement strategies and constraints are used to customize task placement decisions.</p>
    /// <p>The <code>DAEMON</code> scheduling strategy deploys exactly one task on each active container instance that meets all of the task placement constraints that are specified in the cluster. The service scheduler also evaluates the task placement constraints for running tasks and stops tasks that do not meet the placement constraints.</p>
    /// <p>Valid values: <code>REPLICA</code> | <code>DAEMON</code> </p>
    pub fn scheduling_strategy(&self) -> std::option::Option<&str> {
        self.scheduling_strategy.as_deref()
    }
    /// <p>The ARN of the service.</p>
    pub fn service_arn(&self) -> std::option::Option<&str> {
        self.service_arn.as_deref()
    }
    /// <p>The name of the service.</p>
    /// <p>The name can contain up to 255 characters. It can use letters, numbers, underscores, and hyphens.</p>
    pub fn service_name(&self) -> std::option::Option<&str> {
        self.service_name.as_deref()
    }
    /// <p>Information about the service discovery registries to assign to the service.</p>
    pub fn service_registries(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEcsServiceServiceRegistriesDetails]> {
        self.service_registries.as_deref()
    }
    /// <p>The task definition to use for tasks in the service.</p>
    pub fn task_definition(&self) -> std::option::Option<&str> {
        self.task_definition.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsServiceDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcsServiceDetails");
        formatter.field(
            "capacity_provider_strategy",
            &self.capacity_provider_strategy,
        );
        formatter.field("cluster", &self.cluster);
        formatter.field("deployment_configuration", &self.deployment_configuration);
        formatter.field("deployment_controller", &self.deployment_controller);
        formatter.field("desired_count", &self.desired_count);
        formatter.field("enable_ecs_managed_tags", &self.enable_ecs_managed_tags);
        formatter.field("enable_execute_command", &self.enable_execute_command);
        formatter.field(
            "health_check_grace_period_seconds",
            &self.health_check_grace_period_seconds,
        );
        formatter.field("launch_type", &self.launch_type);
        formatter.field("load_balancers", &self.load_balancers);
        formatter.field("name", &self.name);
        formatter.field("network_configuration", &self.network_configuration);
        formatter.field("placement_constraints", &self.placement_constraints);
        formatter.field("placement_strategies", &self.placement_strategies);
        formatter.field("platform_version", &self.platform_version);
        formatter.field("propagate_tags", &self.propagate_tags);
        formatter.field("role", &self.role);
        formatter.field("scheduling_strategy", &self.scheduling_strategy);
        formatter.field("service_arn", &self.service_arn);
        formatter.field("service_name", &self.service_name);
        formatter.field("service_registries", &self.service_registries);
        formatter.field("task_definition", &self.task_definition);
        formatter.finish()
    }
}
/// See [`AwsEcsServiceDetails`](crate::model::AwsEcsServiceDetails)
pub mod aws_ecs_service_details {

    /// A builder for [`AwsEcsServiceDetails`](crate::model::AwsEcsServiceDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) capacity_provider_strategy: std::option::Option<
            std::vec::Vec<crate::model::AwsEcsServiceCapacityProviderStrategyDetails>,
        >,
        pub(crate) cluster: std::option::Option<std::string::String>,
        pub(crate) deployment_configuration:
            std::option::Option<crate::model::AwsEcsServiceDeploymentConfigurationDetails>,
        pub(crate) deployment_controller:
            std::option::Option<crate::model::AwsEcsServiceDeploymentControllerDetails>,
        pub(crate) desired_count: std::option::Option<i32>,
        pub(crate) enable_ecs_managed_tags: std::option::Option<bool>,
        pub(crate) enable_execute_command: std::option::Option<bool>,
        pub(crate) health_check_grace_period_seconds: std::option::Option<i32>,
        pub(crate) launch_type: std::option::Option<std::string::String>,
        pub(crate) load_balancers:
            std::option::Option<std::vec::Vec<crate::model::AwsEcsServiceLoadBalancersDetails>>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) network_configuration:
            std::option::Option<crate::model::AwsEcsServiceNetworkConfigurationDetails>,
        pub(crate) placement_constraints: std::option::Option<
            std::vec::Vec<crate::model::AwsEcsServicePlacementConstraintsDetails>,
        >,
        pub(crate) placement_strategies: std::option::Option<
            std::vec::Vec<crate::model::AwsEcsServicePlacementStrategiesDetails>,
        >,
        pub(crate) platform_version: std::option::Option<std::string::String>,
        pub(crate) propagate_tags: std::option::Option<std::string::String>,
        pub(crate) role: std::option::Option<std::string::String>,
        pub(crate) scheduling_strategy: std::option::Option<std::string::String>,
        pub(crate) service_arn: std::option::Option<std::string::String>,
        pub(crate) service_name: std::option::Option<std::string::String>,
        pub(crate) service_registries:
            std::option::Option<std::vec::Vec<crate::model::AwsEcsServiceServiceRegistriesDetails>>,
        pub(crate) task_definition: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `capacity_provider_strategy`.
        ///
        /// To override the contents of this collection use [`set_capacity_provider_strategy`](Self::set_capacity_provider_strategy).
        ///
        /// <p>The capacity provider strategy that the service uses.</p>
        pub fn capacity_provider_strategy(
            mut self,
            input: crate::model::AwsEcsServiceCapacityProviderStrategyDetails,
        ) -> Self {
            let mut v = self.capacity_provider_strategy.unwrap_or_default();
            v.push(input);
            self.capacity_provider_strategy = Some(v);
            self
        }
        /// <p>The capacity provider strategy that the service uses.</p>
        pub fn set_capacity_provider_strategy(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEcsServiceCapacityProviderStrategyDetails>,
            >,
        ) -> Self {
            self.capacity_provider_strategy = input;
            self
        }
        /// <p>The ARN of the cluster that hosts the service.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster = Some(input.into());
            self
        }
        /// <p>The ARN of the cluster that hosts the service.</p>
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cluster = input;
            self
        }
        /// <p>Deployment parameters for the service. Includes the number of tasks that run and the order in which to start and stop tasks.</p>
        pub fn deployment_configuration(
            mut self,
            input: crate::model::AwsEcsServiceDeploymentConfigurationDetails,
        ) -> Self {
            self.deployment_configuration = Some(input);
            self
        }
        /// <p>Deployment parameters for the service. Includes the number of tasks that run and the order in which to start and stop tasks.</p>
        pub fn set_deployment_configuration(
            mut self,
            input: std::option::Option<crate::model::AwsEcsServiceDeploymentConfigurationDetails>,
        ) -> Self {
            self.deployment_configuration = input;
            self
        }
        /// <p>Contains the deployment controller type that the service uses.</p>
        pub fn deployment_controller(
            mut self,
            input: crate::model::AwsEcsServiceDeploymentControllerDetails,
        ) -> Self {
            self.deployment_controller = Some(input);
            self
        }
        /// <p>Contains the deployment controller type that the service uses.</p>
        pub fn set_deployment_controller(
            mut self,
            input: std::option::Option<crate::model::AwsEcsServiceDeploymentControllerDetails>,
        ) -> Self {
            self.deployment_controller = input;
            self
        }
        /// <p>The number of instantiations of the task definition to run on the service.</p>
        pub fn desired_count(mut self, input: i32) -> Self {
            self.desired_count = Some(input);
            self
        }
        /// <p>The number of instantiations of the task definition to run on the service.</p>
        pub fn set_desired_count(mut self, input: std::option::Option<i32>) -> Self {
            self.desired_count = input;
            self
        }
        /// <p>Whether to enable Amazon ECS managed tags for the tasks in the service.</p>
        pub fn enable_ecs_managed_tags(mut self, input: bool) -> Self {
            self.enable_ecs_managed_tags = Some(input);
            self
        }
        /// <p>Whether to enable Amazon ECS managed tags for the tasks in the service.</p>
        pub fn set_enable_ecs_managed_tags(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_ecs_managed_tags = input;
            self
        }
        /// <p>Whether the execute command functionality is enabled for the service.</p>
        pub fn enable_execute_command(mut self, input: bool) -> Self {
            self.enable_execute_command = Some(input);
            self
        }
        /// <p>Whether the execute command functionality is enabled for the service.</p>
        pub fn set_enable_execute_command(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_execute_command = input;
            self
        }
        /// <p>After a task starts, the amount of time in seconds that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks.</p>
        pub fn health_check_grace_period_seconds(mut self, input: i32) -> Self {
            self.health_check_grace_period_seconds = Some(input);
            self
        }
        /// <p>After a task starts, the amount of time in seconds that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks.</p>
        pub fn set_health_check_grace_period_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.health_check_grace_period_seconds = input;
            self
        }
        /// <p>The launch type that the service uses.</p>
        /// <p>Valid values: <code>EC2</code> | <code>FARGATE</code> | <code>EXTERNAL</code> </p>
        pub fn launch_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_type = Some(input.into());
            self
        }
        /// <p>The launch type that the service uses.</p>
        /// <p>Valid values: <code>EC2</code> | <code>FARGATE</code> | <code>EXTERNAL</code> </p>
        pub fn set_launch_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.launch_type = input;
            self
        }
        /// Appends an item to `load_balancers`.
        ///
        /// To override the contents of this collection use [`set_load_balancers`](Self::set_load_balancers).
        ///
        /// <p>Information about the load balancers that the service uses.</p>
        pub fn load_balancers(
            mut self,
            input: crate::model::AwsEcsServiceLoadBalancersDetails,
        ) -> Self {
            let mut v = self.load_balancers.unwrap_or_default();
            v.push(input);
            self.load_balancers = Some(v);
            self
        }
        /// <p>Information about the load balancers that the service uses.</p>
        pub fn set_load_balancers(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEcsServiceLoadBalancersDetails>,
            >,
        ) -> Self {
            self.load_balancers = input;
            self
        }
        /// <p>The name of the service.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the service.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>For tasks that use the <code>awsvpc</code> networking mode, the VPC subnet and security group configuration.</p>
        pub fn network_configuration(
            mut self,
            input: crate::model::AwsEcsServiceNetworkConfigurationDetails,
        ) -> Self {
            self.network_configuration = Some(input);
            self
        }
        /// <p>For tasks that use the <code>awsvpc</code> networking mode, the VPC subnet and security group configuration.</p>
        pub fn set_network_configuration(
            mut self,
            input: std::option::Option<crate::model::AwsEcsServiceNetworkConfigurationDetails>,
        ) -> Self {
            self.network_configuration = input;
            self
        }
        /// Appends an item to `placement_constraints`.
        ///
        /// To override the contents of this collection use [`set_placement_constraints`](Self::set_placement_constraints).
        ///
        /// <p>The placement constraints for the tasks in the service.</p>
        pub fn placement_constraints(
            mut self,
            input: crate::model::AwsEcsServicePlacementConstraintsDetails,
        ) -> Self {
            let mut v = self.placement_constraints.unwrap_or_default();
            v.push(input);
            self.placement_constraints = Some(v);
            self
        }
        /// <p>The placement constraints for the tasks in the service.</p>
        pub fn set_placement_constraints(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEcsServicePlacementConstraintsDetails>,
            >,
        ) -> Self {
            self.placement_constraints = input;
            self
        }
        /// Appends an item to `placement_strategies`.
        ///
        /// To override the contents of this collection use [`set_placement_strategies`](Self::set_placement_strategies).
        ///
        /// <p>Information about how tasks for the service are placed.</p>
        pub fn placement_strategies(
            mut self,
            input: crate::model::AwsEcsServicePlacementStrategiesDetails,
        ) -> Self {
            let mut v = self.placement_strategies.unwrap_or_default();
            v.push(input);
            self.placement_strategies = Some(v);
            self
        }
        /// <p>Information about how tasks for the service are placed.</p>
        pub fn set_placement_strategies(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEcsServicePlacementStrategiesDetails>,
            >,
        ) -> Self {
            self.placement_strategies = input;
            self
        }
        /// <p>The platform version on which to run the service. Only specified for tasks that are hosted on Fargate. If a platform version is not specified, the <code>LATEST</code> platform version is used by default.</p>
        pub fn platform_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform_version = Some(input.into());
            self
        }
        /// <p>The platform version on which to run the service. Only specified for tasks that are hosted on Fargate. If a platform version is not specified, the <code>LATEST</code> platform version is used by default.</p>
        pub fn set_platform_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.platform_version = input;
            self
        }
        /// <p>Indicates whether to propagate the tags from the task definition to the task or from the service to the task. If no value is provided, then tags are not propagated.</p>
        /// <p>Valid values: <code>TASK_DEFINITION</code> | <code>SERVICE</code> </p>
        pub fn propagate_tags(mut self, input: impl Into<std::string::String>) -> Self {
            self.propagate_tags = Some(input.into());
            self
        }
        /// <p>Indicates whether to propagate the tags from the task definition to the task or from the service to the task. If no value is provided, then tags are not propagated.</p>
        /// <p>Valid values: <code>TASK_DEFINITION</code> | <code>SERVICE</code> </p>
        pub fn set_propagate_tags(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.propagate_tags = input;
            self
        }
        /// <p>The ARN of the IAM role that is associated with the service. The role allows the Amazon ECS container agent to register container instances with an Elastic Load Balancing load balancer.</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.role = Some(input.into());
            self
        }
        /// <p>The ARN of the IAM role that is associated with the service. The role allows the Amazon ECS container agent to register container instances with an Elastic Load Balancing load balancer.</p>
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role = input;
            self
        }
        /// <p>The scheduling strategy to use for the service.</p>
        /// <p>The <code>REPLICA</code> scheduling strategy places and maintains the desired number of tasks across the cluster. By default, the service scheduler spreads tasks across Availability Zones. Task placement strategies and constraints are used to customize task placement decisions.</p>
        /// <p>The <code>DAEMON</code> scheduling strategy deploys exactly one task on each active container instance that meets all of the task placement constraints that are specified in the cluster. The service scheduler also evaluates the task placement constraints for running tasks and stops tasks that do not meet the placement constraints.</p>
        /// <p>Valid values: <code>REPLICA</code> | <code>DAEMON</code> </p>
        pub fn scheduling_strategy(mut self, input: impl Into<std::string::String>) -> Self {
            self.scheduling_strategy = Some(input.into());
            self
        }
        /// <p>The scheduling strategy to use for the service.</p>
        /// <p>The <code>REPLICA</code> scheduling strategy places and maintains the desired number of tasks across the cluster. By default, the service scheduler spreads tasks across Availability Zones. Task placement strategies and constraints are used to customize task placement decisions.</p>
        /// <p>The <code>DAEMON</code> scheduling strategy deploys exactly one task on each active container instance that meets all of the task placement constraints that are specified in the cluster. The service scheduler also evaluates the task placement constraints for running tasks and stops tasks that do not meet the placement constraints.</p>
        /// <p>Valid values: <code>REPLICA</code> | <code>DAEMON</code> </p>
        pub fn set_scheduling_strategy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.scheduling_strategy = input;
            self
        }
        /// <p>The ARN of the service.</p>
        pub fn service_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the service.</p>
        pub fn set_service_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_arn = input;
            self
        }
        /// <p>The name of the service.</p>
        /// <p>The name can contain up to 255 characters. It can use letters, numbers, underscores, and hyphens.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_name = Some(input.into());
            self
        }
        /// <p>The name of the service.</p>
        /// <p>The name can contain up to 255 characters. It can use letters, numbers, underscores, and hyphens.</p>
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_name = input;
            self
        }
        /// Appends an item to `service_registries`.
        ///
        /// To override the contents of this collection use [`set_service_registries`](Self::set_service_registries).
        ///
        /// <p>Information about the service discovery registries to assign to the service.</p>
        pub fn service_registries(
            mut self,
            input: crate::model::AwsEcsServiceServiceRegistriesDetails,
        ) -> Self {
            let mut v = self.service_registries.unwrap_or_default();
            v.push(input);
            self.service_registries = Some(v);
            self
        }
        /// <p>Information about the service discovery registries to assign to the service.</p>
        pub fn set_service_registries(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEcsServiceServiceRegistriesDetails>,
            >,
        ) -> Self {
            self.service_registries = input;
            self
        }
        /// <p>The task definition to use for tasks in the service.</p>
        pub fn task_definition(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_definition = Some(input.into());
            self
        }
        /// <p>The task definition to use for tasks in the service.</p>
        pub fn set_task_definition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.task_definition = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsServiceDetails`](crate::model::AwsEcsServiceDetails)
        pub fn build(self) -> crate::model::AwsEcsServiceDetails {
            crate::model::AwsEcsServiceDetails {
                capacity_provider_strategy: self.capacity_provider_strategy,
                cluster: self.cluster,
                deployment_configuration: self.deployment_configuration,
                deployment_controller: self.deployment_controller,
                desired_count: self.desired_count.unwrap_or_default(),
                enable_ecs_managed_tags: self.enable_ecs_managed_tags.unwrap_or_default(),
                enable_execute_command: self.enable_execute_command.unwrap_or_default(),
                health_check_grace_period_seconds: self
                    .health_check_grace_period_seconds
                    .unwrap_or_default(),
                launch_type: self.launch_type,
                load_balancers: self.load_balancers,
                name: self.name,
                network_configuration: self.network_configuration,
                placement_constraints: self.placement_constraints,
                placement_strategies: self.placement_strategies,
                platform_version: self.platform_version,
                propagate_tags: self.propagate_tags,
                role: self.role,
                scheduling_strategy: self.scheduling_strategy,
                service_arn: self.service_arn,
                service_name: self.service_name,
                service_registries: self.service_registries,
                task_definition: self.task_definition,
            }
        }
    }
}
impl AwsEcsServiceDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsServiceDetails`](crate::model::AwsEcsServiceDetails)
    pub fn builder() -> crate::model::aws_ecs_service_details::Builder {
        crate::model::aws_ecs_service_details::Builder::default()
    }
}

/// <p>Information about a service discovery registry to assign to the service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsServiceServiceRegistriesDetails {
    /// <p>The container name value to use for the service discovery service.</p>
    /// <p>If the task definition uses the <code>bridge</code> or <code>host</code> network mode, you must specify <code>ContainerName</code> and <code>ContainerPort</code>.</p>
    /// <p>If the task definition uses the <code>awsvpc</code> network mode and a type SRV DNS record, you must specify either <code>ContainerName</code> and <code>ContainerPort</code>, or <code>Port</code> , but not both.</p>
    pub container_name: std::option::Option<std::string::String>,
    /// <p>The port value to use for the service discovery service.</p>
    /// <p>If the task definition uses the <code>bridge</code> or <code>host</code> network mode, you must specify <code>ContainerName</code> and <code>ContainerPort</code>.</p>
    /// <p>If the task definition uses the <code>awsvpc</code> network mode and a type SRV DNS record, you must specify either <code>ContainerName</code> and <code>ContainerPort</code>, or <code>Port</code> , but not both.</p>
    pub container_port: i32,
    /// <p>The port value to use for a service discovery service that specifies an SRV record. This field can be used if both the <code>awsvpc</code>awsvpc network mode and SRV records are used.</p>
    pub port: i32,
    /// <p>The ARN of the service registry.</p>
    pub registry_arn: std::option::Option<std::string::String>,
}
impl AwsEcsServiceServiceRegistriesDetails {
    /// <p>The container name value to use for the service discovery service.</p>
    /// <p>If the task definition uses the <code>bridge</code> or <code>host</code> network mode, you must specify <code>ContainerName</code> and <code>ContainerPort</code>.</p>
    /// <p>If the task definition uses the <code>awsvpc</code> network mode and a type SRV DNS record, you must specify either <code>ContainerName</code> and <code>ContainerPort</code>, or <code>Port</code> , but not both.</p>
    pub fn container_name(&self) -> std::option::Option<&str> {
        self.container_name.as_deref()
    }
    /// <p>The port value to use for the service discovery service.</p>
    /// <p>If the task definition uses the <code>bridge</code> or <code>host</code> network mode, you must specify <code>ContainerName</code> and <code>ContainerPort</code>.</p>
    /// <p>If the task definition uses the <code>awsvpc</code> network mode and a type SRV DNS record, you must specify either <code>ContainerName</code> and <code>ContainerPort</code>, or <code>Port</code> , but not both.</p>
    pub fn container_port(&self) -> i32 {
        self.container_port
    }
    /// <p>The port value to use for a service discovery service that specifies an SRV record. This field can be used if both the <code>awsvpc</code>awsvpc network mode and SRV records are used.</p>
    pub fn port(&self) -> i32 {
        self.port
    }
    /// <p>The ARN of the service registry.</p>
    pub fn registry_arn(&self) -> std::option::Option<&str> {
        self.registry_arn.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsServiceServiceRegistriesDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcsServiceServiceRegistriesDetails");
        formatter.field("container_name", &self.container_name);
        formatter.field("container_port", &self.container_port);
        formatter.field("port", &self.port);
        formatter.field("registry_arn", &self.registry_arn);
        formatter.finish()
    }
}
/// See [`AwsEcsServiceServiceRegistriesDetails`](crate::model::AwsEcsServiceServiceRegistriesDetails)
pub mod aws_ecs_service_service_registries_details {

    /// A builder for [`AwsEcsServiceServiceRegistriesDetails`](crate::model::AwsEcsServiceServiceRegistriesDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) container_name: std::option::Option<std::string::String>,
        pub(crate) container_port: std::option::Option<i32>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) registry_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The container name value to use for the service discovery service.</p>
        /// <p>If the task definition uses the <code>bridge</code> or <code>host</code> network mode, you must specify <code>ContainerName</code> and <code>ContainerPort</code>.</p>
        /// <p>If the task definition uses the <code>awsvpc</code> network mode and a type SRV DNS record, you must specify either <code>ContainerName</code> and <code>ContainerPort</code>, or <code>Port</code> , but not both.</p>
        pub fn container_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.container_name = Some(input.into());
            self
        }
        /// <p>The container name value to use for the service discovery service.</p>
        /// <p>If the task definition uses the <code>bridge</code> or <code>host</code> network mode, you must specify <code>ContainerName</code> and <code>ContainerPort</code>.</p>
        /// <p>If the task definition uses the <code>awsvpc</code> network mode and a type SRV DNS record, you must specify either <code>ContainerName</code> and <code>ContainerPort</code>, or <code>Port</code> , but not both.</p>
        pub fn set_container_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.container_name = input;
            self
        }
        /// <p>The port value to use for the service discovery service.</p>
        /// <p>If the task definition uses the <code>bridge</code> or <code>host</code> network mode, you must specify <code>ContainerName</code> and <code>ContainerPort</code>.</p>
        /// <p>If the task definition uses the <code>awsvpc</code> network mode and a type SRV DNS record, you must specify either <code>ContainerName</code> and <code>ContainerPort</code>, or <code>Port</code> , but not both.</p>
        pub fn container_port(mut self, input: i32) -> Self {
            self.container_port = Some(input);
            self
        }
        /// <p>The port value to use for the service discovery service.</p>
        /// <p>If the task definition uses the <code>bridge</code> or <code>host</code> network mode, you must specify <code>ContainerName</code> and <code>ContainerPort</code>.</p>
        /// <p>If the task definition uses the <code>awsvpc</code> network mode and a type SRV DNS record, you must specify either <code>ContainerName</code> and <code>ContainerPort</code>, or <code>Port</code> , but not both.</p>
        pub fn set_container_port(mut self, input: std::option::Option<i32>) -> Self {
            self.container_port = input;
            self
        }
        /// <p>The port value to use for a service discovery service that specifies an SRV record. This field can be used if both the <code>awsvpc</code>awsvpc network mode and SRV records are used.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>The port value to use for a service discovery service that specifies an SRV record. This field can be used if both the <code>awsvpc</code>awsvpc network mode and SRV records are used.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// <p>The ARN of the service registry.</p>
        pub fn registry_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.registry_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the service registry.</p>
        pub fn set_registry_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.registry_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsServiceServiceRegistriesDetails`](crate::model::AwsEcsServiceServiceRegistriesDetails)
        pub fn build(self) -> crate::model::AwsEcsServiceServiceRegistriesDetails {
            crate::model::AwsEcsServiceServiceRegistriesDetails {
                container_name: self.container_name,
                container_port: self.container_port.unwrap_or_default(),
                port: self.port.unwrap_or_default(),
                registry_arn: self.registry_arn,
            }
        }
    }
}
impl AwsEcsServiceServiceRegistriesDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsServiceServiceRegistriesDetails`](crate::model::AwsEcsServiceServiceRegistriesDetails)
    pub fn builder() -> crate::model::aws_ecs_service_service_registries_details::Builder {
        crate::model::aws_ecs_service_service_registries_details::Builder::default()
    }
}

/// <p>A placement strategy that determines how to place the tasks for the service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsServicePlacementStrategiesDetails {
    /// <p>The field to apply the placement strategy against.</p>
    /// <p>For the <code>spread</code> placement strategy, valid values are <code>instanceId</code> (or <code>host</code>, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as <code>attribute:ecs.availability-zone</code>.</p>
    /// <p>For the <code>binpack</code> placement strategy, valid values are <code>cpu</code> and <code>memory</code>.</p>
    /// <p>For the <code>random</code> placement strategy, this attribute is not used.</p>
    pub field: std::option::Option<std::string::String>,
    /// <p>The type of placement strategy.</p>
    /// <p>The <code>random</code> placement strategy randomly places tasks on available candidates.</p>
    /// <p>The <code>spread</code> placement strategy spreads placement across available candidates evenly based on the value of <code>Field</code>.</p>
    /// <p>The <code>binpack</code> strategy places tasks on available candidates that have the least available amount of the resource that is specified in <code>Field</code>.</p>
    /// <p>Valid values: <code>random</code> | <code>spread</code> | <code>binpack</code> </p>
    pub r#type: std::option::Option<std::string::String>,
}
impl AwsEcsServicePlacementStrategiesDetails {
    /// <p>The field to apply the placement strategy against.</p>
    /// <p>For the <code>spread</code> placement strategy, valid values are <code>instanceId</code> (or <code>host</code>, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as <code>attribute:ecs.availability-zone</code>.</p>
    /// <p>For the <code>binpack</code> placement strategy, valid values are <code>cpu</code> and <code>memory</code>.</p>
    /// <p>For the <code>random</code> placement strategy, this attribute is not used.</p>
    pub fn field(&self) -> std::option::Option<&str> {
        self.field.as_deref()
    }
    /// <p>The type of placement strategy.</p>
    /// <p>The <code>random</code> placement strategy randomly places tasks on available candidates.</p>
    /// <p>The <code>spread</code> placement strategy spreads placement across available candidates evenly based on the value of <code>Field</code>.</p>
    /// <p>The <code>binpack</code> strategy places tasks on available candidates that have the least available amount of the resource that is specified in <code>Field</code>.</p>
    /// <p>Valid values: <code>random</code> | <code>spread</code> | <code>binpack</code> </p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsServicePlacementStrategiesDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcsServicePlacementStrategiesDetails");
        formatter.field("field", &self.field);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AwsEcsServicePlacementStrategiesDetails`](crate::model::AwsEcsServicePlacementStrategiesDetails)
pub mod aws_ecs_service_placement_strategies_details {

    /// A builder for [`AwsEcsServicePlacementStrategiesDetails`](crate::model::AwsEcsServicePlacementStrategiesDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The field to apply the placement strategy against.</p>
        /// <p>For the <code>spread</code> placement strategy, valid values are <code>instanceId</code> (or <code>host</code>, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as <code>attribute:ecs.availability-zone</code>.</p>
        /// <p>For the <code>binpack</code> placement strategy, valid values are <code>cpu</code> and <code>memory</code>.</p>
        /// <p>For the <code>random</code> placement strategy, this attribute is not used.</p>
        pub fn field(mut self, input: impl Into<std::string::String>) -> Self {
            self.field = Some(input.into());
            self
        }
        /// <p>The field to apply the placement strategy against.</p>
        /// <p>For the <code>spread</code> placement strategy, valid values are <code>instanceId</code> (or <code>host</code>, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as <code>attribute:ecs.availability-zone</code>.</p>
        /// <p>For the <code>binpack</code> placement strategy, valid values are <code>cpu</code> and <code>memory</code>.</p>
        /// <p>For the <code>random</code> placement strategy, this attribute is not used.</p>
        pub fn set_field(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field = input;
            self
        }
        /// <p>The type of placement strategy.</p>
        /// <p>The <code>random</code> placement strategy randomly places tasks on available candidates.</p>
        /// <p>The <code>spread</code> placement strategy spreads placement across available candidates evenly based on the value of <code>Field</code>.</p>
        /// <p>The <code>binpack</code> strategy places tasks on available candidates that have the least available amount of the resource that is specified in <code>Field</code>.</p>
        /// <p>Valid values: <code>random</code> | <code>spread</code> | <code>binpack</code> </p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of placement strategy.</p>
        /// <p>The <code>random</code> placement strategy randomly places tasks on available candidates.</p>
        /// <p>The <code>spread</code> placement strategy spreads placement across available candidates evenly based on the value of <code>Field</code>.</p>
        /// <p>The <code>binpack</code> strategy places tasks on available candidates that have the least available amount of the resource that is specified in <code>Field</code>.</p>
        /// <p>Valid values: <code>random</code> | <code>spread</code> | <code>binpack</code> </p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsServicePlacementStrategiesDetails`](crate::model::AwsEcsServicePlacementStrategiesDetails)
        pub fn build(self) -> crate::model::AwsEcsServicePlacementStrategiesDetails {
            crate::model::AwsEcsServicePlacementStrategiesDetails {
                field: self.field,
                r#type: self.r#type,
            }
        }
    }
}
impl AwsEcsServicePlacementStrategiesDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsServicePlacementStrategiesDetails`](crate::model::AwsEcsServicePlacementStrategiesDetails)
    pub fn builder() -> crate::model::aws_ecs_service_placement_strategies_details::Builder {
        crate::model::aws_ecs_service_placement_strategies_details::Builder::default()
    }
}

/// <p>A placement constraint for the tasks in the service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsServicePlacementConstraintsDetails {
    /// <p>A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is <code>distinctInstance</code>.</p>
    pub expression: std::option::Option<std::string::String>,
    /// <p>The type of constraint. Use <code>distinctInstance</code> to run each task in a particular group on a different container instance. Use <code>memberOf</code> to restrict the selection to a group of valid candidates.</p>
    /// <p>Valid values: <code>distinctInstance</code> | <code>memberOf</code> </p>
    pub r#type: std::option::Option<std::string::String>,
}
impl AwsEcsServicePlacementConstraintsDetails {
    /// <p>A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is <code>distinctInstance</code>.</p>
    pub fn expression(&self) -> std::option::Option<&str> {
        self.expression.as_deref()
    }
    /// <p>The type of constraint. Use <code>distinctInstance</code> to run each task in a particular group on a different container instance. Use <code>memberOf</code> to restrict the selection to a group of valid candidates.</p>
    /// <p>Valid values: <code>distinctInstance</code> | <code>memberOf</code> </p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsServicePlacementConstraintsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcsServicePlacementConstraintsDetails");
        formatter.field("expression", &self.expression);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AwsEcsServicePlacementConstraintsDetails`](crate::model::AwsEcsServicePlacementConstraintsDetails)
pub mod aws_ecs_service_placement_constraints_details {

    /// A builder for [`AwsEcsServicePlacementConstraintsDetails`](crate::model::AwsEcsServicePlacementConstraintsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) expression: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is <code>distinctInstance</code>.</p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.expression = Some(input.into());
            self
        }
        /// <p>A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is <code>distinctInstance</code>.</p>
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.expression = input;
            self
        }
        /// <p>The type of constraint. Use <code>distinctInstance</code> to run each task in a particular group on a different container instance. Use <code>memberOf</code> to restrict the selection to a group of valid candidates.</p>
        /// <p>Valid values: <code>distinctInstance</code> | <code>memberOf</code> </p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of constraint. Use <code>distinctInstance</code> to run each task in a particular group on a different container instance. Use <code>memberOf</code> to restrict the selection to a group of valid candidates.</p>
        /// <p>Valid values: <code>distinctInstance</code> | <code>memberOf</code> </p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsServicePlacementConstraintsDetails`](crate::model::AwsEcsServicePlacementConstraintsDetails)
        pub fn build(self) -> crate::model::AwsEcsServicePlacementConstraintsDetails {
            crate::model::AwsEcsServicePlacementConstraintsDetails {
                expression: self.expression,
                r#type: self.r#type,
            }
        }
    }
}
impl AwsEcsServicePlacementConstraintsDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsServicePlacementConstraintsDetails`](crate::model::AwsEcsServicePlacementConstraintsDetails)
    pub fn builder() -> crate::model::aws_ecs_service_placement_constraints_details::Builder {
        crate::model::aws_ecs_service_placement_constraints_details::Builder::default()
    }
}

/// <p>For tasks that use the <code>awsvpc</code> networking mode, the VPC subnet and security group configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsServiceNetworkConfigurationDetails {
    /// <p>The VPC subnet and security group configuration.</p>
    pub aws_vpc_configuration: std::option::Option<
        crate::model::AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails,
    >,
}
impl AwsEcsServiceNetworkConfigurationDetails {
    /// <p>The VPC subnet and security group configuration.</p>
    pub fn aws_vpc_configuration(
        &self,
    ) -> std::option::Option<
        &crate::model::AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails,
    > {
        self.aws_vpc_configuration.as_ref()
    }
}
impl std::fmt::Debug for AwsEcsServiceNetworkConfigurationDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcsServiceNetworkConfigurationDetails");
        formatter.field("aws_vpc_configuration", &self.aws_vpc_configuration);
        formatter.finish()
    }
}
/// See [`AwsEcsServiceNetworkConfigurationDetails`](crate::model::AwsEcsServiceNetworkConfigurationDetails)
pub mod aws_ecs_service_network_configuration_details {

    /// A builder for [`AwsEcsServiceNetworkConfigurationDetails`](crate::model::AwsEcsServiceNetworkConfigurationDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) aws_vpc_configuration: std::option::Option<
            crate::model::AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails,
        >,
    }
    impl Builder {
        /// <p>The VPC subnet and security group configuration.</p>
        pub fn aws_vpc_configuration(
            mut self,
            input: crate::model::AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails,
        ) -> Self {
            self.aws_vpc_configuration = Some(input);
            self
        }
        /// <p>The VPC subnet and security group configuration.</p>
        pub fn set_aws_vpc_configuration(
            mut self,
            input: std::option::Option<
                crate::model::AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails,
            >,
        ) -> Self {
            self.aws_vpc_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsServiceNetworkConfigurationDetails`](crate::model::AwsEcsServiceNetworkConfigurationDetails)
        pub fn build(self) -> crate::model::AwsEcsServiceNetworkConfigurationDetails {
            crate::model::AwsEcsServiceNetworkConfigurationDetails {
                aws_vpc_configuration: self.aws_vpc_configuration,
            }
        }
    }
}
impl AwsEcsServiceNetworkConfigurationDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsServiceNetworkConfigurationDetails`](crate::model::AwsEcsServiceNetworkConfigurationDetails)
    pub fn builder() -> crate::model::aws_ecs_service_network_configuration_details::Builder {
        crate::model::aws_ecs_service_network_configuration_details::Builder::default()
    }
}

/// <p>For tasks that use the <code>awsvpc</code> networking mode, the VPC subnet and security group configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails {
    /// <p>Whether the task's elastic network interface receives a public IP address. The default value is <code>DISABLED</code>.</p>
    /// <p>Valid values: <code>ENABLED</code> | <code>DISABLED</code> </p>
    pub assign_public_ip: std::option::Option<std::string::String>,
    /// <p>The IDs of the security groups associated with the task or service.</p>
    /// <p>You can provide up to five security groups.</p>
    pub security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The IDs of the subnets associated with the task or service.</p>
    /// <p>You can provide up to 16 subnets.</p>
    pub subnets: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails {
    /// <p>Whether the task's elastic network interface receives a public IP address. The default value is <code>DISABLED</code>.</p>
    /// <p>Valid values: <code>ENABLED</code> | <code>DISABLED</code> </p>
    pub fn assign_public_ip(&self) -> std::option::Option<&str> {
        self.assign_public_ip.as_deref()
    }
    /// <p>The IDs of the security groups associated with the task or service.</p>
    /// <p>You can provide up to five security groups.</p>
    pub fn security_groups(&self) -> std::option::Option<&[std::string::String]> {
        self.security_groups.as_deref()
    }
    /// <p>The IDs of the subnets associated with the task or service.</p>
    /// <p>You can provide up to 16 subnets.</p>
    pub fn subnets(&self) -> std::option::Option<&[std::string::String]> {
        self.subnets.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails");
        formatter.field("assign_public_ip", &self.assign_public_ip);
        formatter.field("security_groups", &self.security_groups);
        formatter.field("subnets", &self.subnets);
        formatter.finish()
    }
}
/// See [`AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails`](crate::model::AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails)
pub mod aws_ecs_service_network_configuration_aws_vpc_configuration_details {

    /// A builder for [`AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails`](crate::model::AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assign_public_ip: std::option::Option<std::string::String>,
        pub(crate) security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) subnets: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>Whether the task's elastic network interface receives a public IP address. The default value is <code>DISABLED</code>.</p>
        /// <p>Valid values: <code>ENABLED</code> | <code>DISABLED</code> </p>
        pub fn assign_public_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.assign_public_ip = Some(input.into());
            self
        }
        /// <p>Whether the task's elastic network interface receives a public IP address. The default value is <code>DISABLED</code>.</p>
        /// <p>Valid values: <code>ENABLED</code> | <code>DISABLED</code> </p>
        pub fn set_assign_public_ip(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assign_public_ip = input;
            self
        }
        /// Appends an item to `security_groups`.
        ///
        /// To override the contents of this collection use [`set_security_groups`](Self::set_security_groups).
        ///
        /// <p>The IDs of the security groups associated with the task or service.</p>
        /// <p>You can provide up to five security groups.</p>
        pub fn security_groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_groups.unwrap_or_default();
            v.push(input.into());
            self.security_groups = Some(v);
            self
        }
        /// <p>The IDs of the security groups associated with the task or service.</p>
        /// <p>You can provide up to five security groups.</p>
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_groups = input;
            self
        }
        /// Appends an item to `subnets`.
        ///
        /// To override the contents of this collection use [`set_subnets`](Self::set_subnets).
        ///
        /// <p>The IDs of the subnets associated with the task or service.</p>
        /// <p>You can provide up to 16 subnets.</p>
        pub fn subnets(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnets.unwrap_or_default();
            v.push(input.into());
            self.subnets = Some(v);
            self
        }
        /// <p>The IDs of the subnets associated with the task or service.</p>
        /// <p>You can provide up to 16 subnets.</p>
        pub fn set_subnets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnets = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails`](crate::model::AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails {
            crate::model::AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails {
                assign_public_ip: self.assign_public_ip,
                security_groups: self.security_groups,
                subnets: self.subnets,
            }
        }
    }
}
impl AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails`](crate::model::AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails)
    pub fn builder(
    ) -> crate::model::aws_ecs_service_network_configuration_aws_vpc_configuration_details::Builder
    {
        crate::model::aws_ecs_service_network_configuration_aws_vpc_configuration_details::Builder::default()
    }
}

/// <p>Information about a load balancer that the service uses.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsServiceLoadBalancersDetails {
    /// <p>The name of the container to associate with the load balancer.</p>
    pub container_name: std::option::Option<std::string::String>,
    /// <p>The port on the container to associate with the load balancer. This port must correspond to a <code>containerPort</code> in the task definition the tasks in the service are using. For tasks that use the EC2 launch type, the container instance they are launched on must allow ingress traffic on the <code>hostPort</code> of the port mapping.</p>
    pub container_port: i32,
    /// <p>The name of the load balancer to associate with the Amazon ECS service or task set.</p>
    /// <p>Only specified when using a Classic Load Balancer. For an Application Load Balancer or a Network Load Balancer, the load balancer name is omitted.</p>
    pub load_balancer_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the Elastic Load Balancing target group or groups associated with a service or task set.</p>
    /// <p>Only specified when using an Application Load Balancer or a Network Load Balancer. For a Classic Load Balancer, the target group ARN is omitted.</p>
    pub target_group_arn: std::option::Option<std::string::String>,
}
impl AwsEcsServiceLoadBalancersDetails {
    /// <p>The name of the container to associate with the load balancer.</p>
    pub fn container_name(&self) -> std::option::Option<&str> {
        self.container_name.as_deref()
    }
    /// <p>The port on the container to associate with the load balancer. This port must correspond to a <code>containerPort</code> in the task definition the tasks in the service are using. For tasks that use the EC2 launch type, the container instance they are launched on must allow ingress traffic on the <code>hostPort</code> of the port mapping.</p>
    pub fn container_port(&self) -> i32 {
        self.container_port
    }
    /// <p>The name of the load balancer to associate with the Amazon ECS service or task set.</p>
    /// <p>Only specified when using a Classic Load Balancer. For an Application Load Balancer or a Network Load Balancer, the load balancer name is omitted.</p>
    pub fn load_balancer_name(&self) -> std::option::Option<&str> {
        self.load_balancer_name.as_deref()
    }
    /// <p>The ARN of the Elastic Load Balancing target group or groups associated with a service or task set.</p>
    /// <p>Only specified when using an Application Load Balancer or a Network Load Balancer. For a Classic Load Balancer, the target group ARN is omitted.</p>
    pub fn target_group_arn(&self) -> std::option::Option<&str> {
        self.target_group_arn.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsServiceLoadBalancersDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcsServiceLoadBalancersDetails");
        formatter.field("container_name", &self.container_name);
        formatter.field("container_port", &self.container_port);
        formatter.field("load_balancer_name", &self.load_balancer_name);
        formatter.field("target_group_arn", &self.target_group_arn);
        formatter.finish()
    }
}
/// See [`AwsEcsServiceLoadBalancersDetails`](crate::model::AwsEcsServiceLoadBalancersDetails)
pub mod aws_ecs_service_load_balancers_details {

    /// A builder for [`AwsEcsServiceLoadBalancersDetails`](crate::model::AwsEcsServiceLoadBalancersDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) container_name: std::option::Option<std::string::String>,
        pub(crate) container_port: std::option::Option<i32>,
        pub(crate) load_balancer_name: std::option::Option<std::string::String>,
        pub(crate) target_group_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the container to associate with the load balancer.</p>
        pub fn container_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.container_name = Some(input.into());
            self
        }
        /// <p>The name of the container to associate with the load balancer.</p>
        pub fn set_container_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.container_name = input;
            self
        }
        /// <p>The port on the container to associate with the load balancer. This port must correspond to a <code>containerPort</code> in the task definition the tasks in the service are using. For tasks that use the EC2 launch type, the container instance they are launched on must allow ingress traffic on the <code>hostPort</code> of the port mapping.</p>
        pub fn container_port(mut self, input: i32) -> Self {
            self.container_port = Some(input);
            self
        }
        /// <p>The port on the container to associate with the load balancer. This port must correspond to a <code>containerPort</code> in the task definition the tasks in the service are using. For tasks that use the EC2 launch type, the container instance they are launched on must allow ingress traffic on the <code>hostPort</code> of the port mapping.</p>
        pub fn set_container_port(mut self, input: std::option::Option<i32>) -> Self {
            self.container_port = input;
            self
        }
        /// <p>The name of the load balancer to associate with the Amazon ECS service or task set.</p>
        /// <p>Only specified when using a Classic Load Balancer. For an Application Load Balancer or a Network Load Balancer, the load balancer name is omitted.</p>
        pub fn load_balancer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.load_balancer_name = Some(input.into());
            self
        }
        /// <p>The name of the load balancer to associate with the Amazon ECS service or task set.</p>
        /// <p>Only specified when using a Classic Load Balancer. For an Application Load Balancer or a Network Load Balancer, the load balancer name is omitted.</p>
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.load_balancer_name = input;
            self
        }
        /// <p>The ARN of the Elastic Load Balancing target group or groups associated with a service or task set.</p>
        /// <p>Only specified when using an Application Load Balancer or a Network Load Balancer. For a Classic Load Balancer, the target group ARN is omitted.</p>
        pub fn target_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_group_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the Elastic Load Balancing target group or groups associated with a service or task set.</p>
        /// <p>Only specified when using an Application Load Balancer or a Network Load Balancer. For a Classic Load Balancer, the target group ARN is omitted.</p>
        pub fn set_target_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_group_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsServiceLoadBalancersDetails`](crate::model::AwsEcsServiceLoadBalancersDetails)
        pub fn build(self) -> crate::model::AwsEcsServiceLoadBalancersDetails {
            crate::model::AwsEcsServiceLoadBalancersDetails {
                container_name: self.container_name,
                container_port: self.container_port.unwrap_or_default(),
                load_balancer_name: self.load_balancer_name,
                target_group_arn: self.target_group_arn,
            }
        }
    }
}
impl AwsEcsServiceLoadBalancersDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsServiceLoadBalancersDetails`](crate::model::AwsEcsServiceLoadBalancersDetails)
    pub fn builder() -> crate::model::aws_ecs_service_load_balancers_details::Builder {
        crate::model::aws_ecs_service_load_balancers_details::Builder::default()
    }
}

/// <p>Information about the deployment controller type that the service uses.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsServiceDeploymentControllerDetails {
    /// <p>The rolling update (<code>ECS</code>) deployment type replaces the current running version of the container with the latest version.</p>
    /// <p>The blue/green (<code>CODE_DEPLOY</code>) deployment type uses the blue/green deployment model that is powered by CodeDeploy. This deployment model a new deployment of a service can be verified before production traffic is sent to it.</p>
    /// <p>The external (<code>EXTERNAL</code>) deployment type allows the use of any third-party deployment controller for full control over the deployment process for an Amazon ECS service.</p>
    /// <p>Valid values: <code>ECS</code> | <code>CODE_DEPLOY</code> | <code>EXTERNAL</code> </p>
    pub r#type: std::option::Option<std::string::String>,
}
impl AwsEcsServiceDeploymentControllerDetails {
    /// <p>The rolling update (<code>ECS</code>) deployment type replaces the current running version of the container with the latest version.</p>
    /// <p>The blue/green (<code>CODE_DEPLOY</code>) deployment type uses the blue/green deployment model that is powered by CodeDeploy. This deployment model a new deployment of a service can be verified before production traffic is sent to it.</p>
    /// <p>The external (<code>EXTERNAL</code>) deployment type allows the use of any third-party deployment controller for full control over the deployment process for an Amazon ECS service.</p>
    /// <p>Valid values: <code>ECS</code> | <code>CODE_DEPLOY</code> | <code>EXTERNAL</code> </p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsServiceDeploymentControllerDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcsServiceDeploymentControllerDetails");
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AwsEcsServiceDeploymentControllerDetails`](crate::model::AwsEcsServiceDeploymentControllerDetails)
pub mod aws_ecs_service_deployment_controller_details {

    /// A builder for [`AwsEcsServiceDeploymentControllerDetails`](crate::model::AwsEcsServiceDeploymentControllerDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The rolling update (<code>ECS</code>) deployment type replaces the current running version of the container with the latest version.</p>
        /// <p>The blue/green (<code>CODE_DEPLOY</code>) deployment type uses the blue/green deployment model that is powered by CodeDeploy. This deployment model a new deployment of a service can be verified before production traffic is sent to it.</p>
        /// <p>The external (<code>EXTERNAL</code>) deployment type allows the use of any third-party deployment controller for full control over the deployment process for an Amazon ECS service.</p>
        /// <p>Valid values: <code>ECS</code> | <code>CODE_DEPLOY</code> | <code>EXTERNAL</code> </p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The rolling update (<code>ECS</code>) deployment type replaces the current running version of the container with the latest version.</p>
        /// <p>The blue/green (<code>CODE_DEPLOY</code>) deployment type uses the blue/green deployment model that is powered by CodeDeploy. This deployment model a new deployment of a service can be verified before production traffic is sent to it.</p>
        /// <p>The external (<code>EXTERNAL</code>) deployment type allows the use of any third-party deployment controller for full control over the deployment process for an Amazon ECS service.</p>
        /// <p>Valid values: <code>ECS</code> | <code>CODE_DEPLOY</code> | <code>EXTERNAL</code> </p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsServiceDeploymentControllerDetails`](crate::model::AwsEcsServiceDeploymentControllerDetails)
        pub fn build(self) -> crate::model::AwsEcsServiceDeploymentControllerDetails {
            crate::model::AwsEcsServiceDeploymentControllerDetails {
                r#type: self.r#type,
            }
        }
    }
}
impl AwsEcsServiceDeploymentControllerDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsServiceDeploymentControllerDetails`](crate::model::AwsEcsServiceDeploymentControllerDetails)
    pub fn builder() -> crate::model::aws_ecs_service_deployment_controller_details::Builder {
        crate::model::aws_ecs_service_deployment_controller_details::Builder::default()
    }
}

/// <p>Optional deployment parameters for the service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsServiceDeploymentConfigurationDetails {
    /// <p>Determines whether a service deployment fails if a service cannot reach a steady state.</p>
    pub deployment_circuit_breaker: std::option::Option<
        crate::model::AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails,
    >,
    /// <p>For a service that uses the rolling update (<code>ECS</code>) deployment type, the maximum number of tasks in a service that are allowed in the <code>RUNNING</code> or <code>PENDING</code> state during a deployment, and for tasks that use the EC2 launch type, when any container instances are in the <code>DRAINING</code> state. Provided as a percentage of the desired number of tasks. The default value is 200%.</p>
    /// <p>For a service that uses the blue/green (<code>CODE_DEPLOY</code>) or <code>EXTERNAL</code> deployment types, and tasks that use the EC2 launch type, the maximum number of tasks in the service that remain in the <code>RUNNING</code> state while the container instances are in the <code>DRAINING</code> state.</p>
    /// <p>For the Fargate launch type, the maximum percent value is not used.</p>
    pub maximum_percent: i32,
    /// <p>For a service that uses the rolling update (<code>ECS</code>) deployment type, the minimum number of tasks in a service that must remain in the <code>RUNNING</code> state during a deployment, and while any container instances are in the <code>DRAINING</code> state if the service contains tasks using the EC2 launch type. Expressed as a percentage of the desired number of tasks. The default value is 100%.</p>
    /// <p>For a service that uses the blue/green (<code>CODE_DEPLOY</code>) or <code>EXTERNAL</code> deployment types and tasks that use the EC2 launch type, the minimum number of the tasks in the service that remain in the <code>RUNNING</code> state while the container instances are in the <code>DRAINING</code> state.</p>
    /// <p>For the Fargate launch type, the minimum healthy percent value is not used.</p>
    pub minimum_healthy_percent: i32,
}
impl AwsEcsServiceDeploymentConfigurationDetails {
    /// <p>Determines whether a service deployment fails if a service cannot reach a steady state.</p>
    pub fn deployment_circuit_breaker(
        &self,
    ) -> std::option::Option<
        &crate::model::AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails,
    > {
        self.deployment_circuit_breaker.as_ref()
    }
    /// <p>For a service that uses the rolling update (<code>ECS</code>) deployment type, the maximum number of tasks in a service that are allowed in the <code>RUNNING</code> or <code>PENDING</code> state during a deployment, and for tasks that use the EC2 launch type, when any container instances are in the <code>DRAINING</code> state. Provided as a percentage of the desired number of tasks. The default value is 200%.</p>
    /// <p>For a service that uses the blue/green (<code>CODE_DEPLOY</code>) or <code>EXTERNAL</code> deployment types, and tasks that use the EC2 launch type, the maximum number of tasks in the service that remain in the <code>RUNNING</code> state while the container instances are in the <code>DRAINING</code> state.</p>
    /// <p>For the Fargate launch type, the maximum percent value is not used.</p>
    pub fn maximum_percent(&self) -> i32 {
        self.maximum_percent
    }
    /// <p>For a service that uses the rolling update (<code>ECS</code>) deployment type, the minimum number of tasks in a service that must remain in the <code>RUNNING</code> state during a deployment, and while any container instances are in the <code>DRAINING</code> state if the service contains tasks using the EC2 launch type. Expressed as a percentage of the desired number of tasks. The default value is 100%.</p>
    /// <p>For a service that uses the blue/green (<code>CODE_DEPLOY</code>) or <code>EXTERNAL</code> deployment types and tasks that use the EC2 launch type, the minimum number of the tasks in the service that remain in the <code>RUNNING</code> state while the container instances are in the <code>DRAINING</code> state.</p>
    /// <p>For the Fargate launch type, the minimum healthy percent value is not used.</p>
    pub fn minimum_healthy_percent(&self) -> i32 {
        self.minimum_healthy_percent
    }
}
impl std::fmt::Debug for AwsEcsServiceDeploymentConfigurationDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcsServiceDeploymentConfigurationDetails");
        formatter.field(
            "deployment_circuit_breaker",
            &self.deployment_circuit_breaker,
        );
        formatter.field("maximum_percent", &self.maximum_percent);
        formatter.field("minimum_healthy_percent", &self.minimum_healthy_percent);
        formatter.finish()
    }
}
/// See [`AwsEcsServiceDeploymentConfigurationDetails`](crate::model::AwsEcsServiceDeploymentConfigurationDetails)
pub mod aws_ecs_service_deployment_configuration_details {

    /// A builder for [`AwsEcsServiceDeploymentConfigurationDetails`](crate::model::AwsEcsServiceDeploymentConfigurationDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) deployment_circuit_breaker: std::option::Option<
            crate::model::AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails,
        >,
        pub(crate) maximum_percent: std::option::Option<i32>,
        pub(crate) minimum_healthy_percent: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Determines whether a service deployment fails if a service cannot reach a steady state.</p>
        pub fn deployment_circuit_breaker(
            mut self,
            input: crate::model::AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails,
        ) -> Self {
            self.deployment_circuit_breaker = Some(input);
            self
        }
        /// <p>Determines whether a service deployment fails if a service cannot reach a steady state.</p>
        pub fn set_deployment_circuit_breaker(
            mut self,
            input: std::option::Option<
                crate::model::AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails,
            >,
        ) -> Self {
            self.deployment_circuit_breaker = input;
            self
        }
        /// <p>For a service that uses the rolling update (<code>ECS</code>) deployment type, the maximum number of tasks in a service that are allowed in the <code>RUNNING</code> or <code>PENDING</code> state during a deployment, and for tasks that use the EC2 launch type, when any container instances are in the <code>DRAINING</code> state. Provided as a percentage of the desired number of tasks. The default value is 200%.</p>
        /// <p>For a service that uses the blue/green (<code>CODE_DEPLOY</code>) or <code>EXTERNAL</code> deployment types, and tasks that use the EC2 launch type, the maximum number of tasks in the service that remain in the <code>RUNNING</code> state while the container instances are in the <code>DRAINING</code> state.</p>
        /// <p>For the Fargate launch type, the maximum percent value is not used.</p>
        pub fn maximum_percent(mut self, input: i32) -> Self {
            self.maximum_percent = Some(input);
            self
        }
        /// <p>For a service that uses the rolling update (<code>ECS</code>) deployment type, the maximum number of tasks in a service that are allowed in the <code>RUNNING</code> or <code>PENDING</code> state during a deployment, and for tasks that use the EC2 launch type, when any container instances are in the <code>DRAINING</code> state. Provided as a percentage of the desired number of tasks. The default value is 200%.</p>
        /// <p>For a service that uses the blue/green (<code>CODE_DEPLOY</code>) or <code>EXTERNAL</code> deployment types, and tasks that use the EC2 launch type, the maximum number of tasks in the service that remain in the <code>RUNNING</code> state while the container instances are in the <code>DRAINING</code> state.</p>
        /// <p>For the Fargate launch type, the maximum percent value is not used.</p>
        pub fn set_maximum_percent(mut self, input: std::option::Option<i32>) -> Self {
            self.maximum_percent = input;
            self
        }
        /// <p>For a service that uses the rolling update (<code>ECS</code>) deployment type, the minimum number of tasks in a service that must remain in the <code>RUNNING</code> state during a deployment, and while any container instances are in the <code>DRAINING</code> state if the service contains tasks using the EC2 launch type. Expressed as a percentage of the desired number of tasks. The default value is 100%.</p>
        /// <p>For a service that uses the blue/green (<code>CODE_DEPLOY</code>) or <code>EXTERNAL</code> deployment types and tasks that use the EC2 launch type, the minimum number of the tasks in the service that remain in the <code>RUNNING</code> state while the container instances are in the <code>DRAINING</code> state.</p>
        /// <p>For the Fargate launch type, the minimum healthy percent value is not used.</p>
        pub fn minimum_healthy_percent(mut self, input: i32) -> Self {
            self.minimum_healthy_percent = Some(input);
            self
        }
        /// <p>For a service that uses the rolling update (<code>ECS</code>) deployment type, the minimum number of tasks in a service that must remain in the <code>RUNNING</code> state during a deployment, and while any container instances are in the <code>DRAINING</code> state if the service contains tasks using the EC2 launch type. Expressed as a percentage of the desired number of tasks. The default value is 100%.</p>
        /// <p>For a service that uses the blue/green (<code>CODE_DEPLOY</code>) or <code>EXTERNAL</code> deployment types and tasks that use the EC2 launch type, the minimum number of the tasks in the service that remain in the <code>RUNNING</code> state while the container instances are in the <code>DRAINING</code> state.</p>
        /// <p>For the Fargate launch type, the minimum healthy percent value is not used.</p>
        pub fn set_minimum_healthy_percent(mut self, input: std::option::Option<i32>) -> Self {
            self.minimum_healthy_percent = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsServiceDeploymentConfigurationDetails`](crate::model::AwsEcsServiceDeploymentConfigurationDetails)
        pub fn build(self) -> crate::model::AwsEcsServiceDeploymentConfigurationDetails {
            crate::model::AwsEcsServiceDeploymentConfigurationDetails {
                deployment_circuit_breaker: self.deployment_circuit_breaker,
                maximum_percent: self.maximum_percent.unwrap_or_default(),
                minimum_healthy_percent: self.minimum_healthy_percent.unwrap_or_default(),
            }
        }
    }
}
impl AwsEcsServiceDeploymentConfigurationDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsServiceDeploymentConfigurationDetails`](crate::model::AwsEcsServiceDeploymentConfigurationDetails)
    pub fn builder() -> crate::model::aws_ecs_service_deployment_configuration_details::Builder {
        crate::model::aws_ecs_service_deployment_configuration_details::Builder::default()
    }
}

/// <p>Determines whether a service deployment fails if a service cannot reach a steady state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails {
    /// <p>Whether to enable the deployment circuit breaker logic for the service.</p>
    pub enable: bool,
    /// <p>Whether to roll back the service if a service deployment fails. If rollback is enabled, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.</p>
    pub rollback: bool,
}
impl AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails {
    /// <p>Whether to enable the deployment circuit breaker logic for the service.</p>
    pub fn enable(&self) -> bool {
        self.enable
    }
    /// <p>Whether to roll back the service if a service deployment fails. If rollback is enabled, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.</p>
    pub fn rollback(&self) -> bool {
        self.rollback
    }
}
impl std::fmt::Debug for AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails");
        formatter.field("enable", &self.enable);
        formatter.field("rollback", &self.rollback);
        formatter.finish()
    }
}
/// See [`AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails`](crate::model::AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails)
pub mod aws_ecs_service_deployment_configuration_deployment_circuit_breaker_details {

    /// A builder for [`AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails`](crate::model::AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enable: std::option::Option<bool>,
        pub(crate) rollback: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Whether to enable the deployment circuit breaker logic for the service.</p>
        pub fn enable(mut self, input: bool) -> Self {
            self.enable = Some(input);
            self
        }
        /// <p>Whether to enable the deployment circuit breaker logic for the service.</p>
        pub fn set_enable(mut self, input: std::option::Option<bool>) -> Self {
            self.enable = input;
            self
        }
        /// <p>Whether to roll back the service if a service deployment fails. If rollback is enabled, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.</p>
        pub fn rollback(mut self, input: bool) -> Self {
            self.rollback = Some(input);
            self
        }
        /// <p>Whether to roll back the service if a service deployment fails. If rollback is enabled, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.</p>
        pub fn set_rollback(mut self, input: std::option::Option<bool>) -> Self {
            self.rollback = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails`](crate::model::AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails
        {
            crate::model::AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails {
                enable: self.enable.unwrap_or_default(),
                rollback: self.rollback.unwrap_or_default(),
            }
        }
    }
}
impl AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails`](crate::model::AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails)
    pub fn builder() -> crate::model::aws_ecs_service_deployment_configuration_deployment_circuit_breaker_details::Builder{
        crate::model::aws_ecs_service_deployment_configuration_deployment_circuit_breaker_details::Builder::default()
    }
}

/// <p>Strategy item for the capacity provider strategy that the service uses.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsServiceCapacityProviderStrategyDetails {
    /// <p>The minimum number of tasks to run on the capacity provider. Only one strategy item can specify a value for <code>Base</code>.</p>
    /// <p>The value must be between 0 and 100000.</p>
    pub base: i32,
    /// <p>The short name of the capacity provider.</p>
    pub capacity_provider: std::option::Option<std::string::String>,
    /// <p>The relative percentage of the total number of tasks that should use the capacity provider.</p>
    /// <p>If no weight is specified, the default value is 0. At least one capacity provider must have a weight greater than 0.</p>
    /// <p>The value can be between 0 and 1000.</p>
    pub weight: i32,
}
impl AwsEcsServiceCapacityProviderStrategyDetails {
    /// <p>The minimum number of tasks to run on the capacity provider. Only one strategy item can specify a value for <code>Base</code>.</p>
    /// <p>The value must be between 0 and 100000.</p>
    pub fn base(&self) -> i32 {
        self.base
    }
    /// <p>The short name of the capacity provider.</p>
    pub fn capacity_provider(&self) -> std::option::Option<&str> {
        self.capacity_provider.as_deref()
    }
    /// <p>The relative percentage of the total number of tasks that should use the capacity provider.</p>
    /// <p>If no weight is specified, the default value is 0. At least one capacity provider must have a weight greater than 0.</p>
    /// <p>The value can be between 0 and 1000.</p>
    pub fn weight(&self) -> i32 {
        self.weight
    }
}
impl std::fmt::Debug for AwsEcsServiceCapacityProviderStrategyDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcsServiceCapacityProviderStrategyDetails");
        formatter.field("base", &self.base);
        formatter.field("capacity_provider", &self.capacity_provider);
        formatter.field("weight", &self.weight);
        formatter.finish()
    }
}
/// See [`AwsEcsServiceCapacityProviderStrategyDetails`](crate::model::AwsEcsServiceCapacityProviderStrategyDetails)
pub mod aws_ecs_service_capacity_provider_strategy_details {

    /// A builder for [`AwsEcsServiceCapacityProviderStrategyDetails`](crate::model::AwsEcsServiceCapacityProviderStrategyDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) base: std::option::Option<i32>,
        pub(crate) capacity_provider: std::option::Option<std::string::String>,
        pub(crate) weight: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The minimum number of tasks to run on the capacity provider. Only one strategy item can specify a value for <code>Base</code>.</p>
        /// <p>The value must be between 0 and 100000.</p>
        pub fn base(mut self, input: i32) -> Self {
            self.base = Some(input);
            self
        }
        /// <p>The minimum number of tasks to run on the capacity provider. Only one strategy item can specify a value for <code>Base</code>.</p>
        /// <p>The value must be between 0 and 100000.</p>
        pub fn set_base(mut self, input: std::option::Option<i32>) -> Self {
            self.base = input;
            self
        }
        /// <p>The short name of the capacity provider.</p>
        pub fn capacity_provider(mut self, input: impl Into<std::string::String>) -> Self {
            self.capacity_provider = Some(input.into());
            self
        }
        /// <p>The short name of the capacity provider.</p>
        pub fn set_capacity_provider(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.capacity_provider = input;
            self
        }
        /// <p>The relative percentage of the total number of tasks that should use the capacity provider.</p>
        /// <p>If no weight is specified, the default value is 0. At least one capacity provider must have a weight greater than 0.</p>
        /// <p>The value can be between 0 and 1000.</p>
        pub fn weight(mut self, input: i32) -> Self {
            self.weight = Some(input);
            self
        }
        /// <p>The relative percentage of the total number of tasks that should use the capacity provider.</p>
        /// <p>If no weight is specified, the default value is 0. At least one capacity provider must have a weight greater than 0.</p>
        /// <p>The value can be between 0 and 1000.</p>
        pub fn set_weight(mut self, input: std::option::Option<i32>) -> Self {
            self.weight = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsServiceCapacityProviderStrategyDetails`](crate::model::AwsEcsServiceCapacityProviderStrategyDetails)
        pub fn build(self) -> crate::model::AwsEcsServiceCapacityProviderStrategyDetails {
            crate::model::AwsEcsServiceCapacityProviderStrategyDetails {
                base: self.base.unwrap_or_default(),
                capacity_provider: self.capacity_provider,
                weight: self.weight.unwrap_or_default(),
            }
        }
    }
}
impl AwsEcsServiceCapacityProviderStrategyDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsServiceCapacityProviderStrategyDetails`](crate::model::AwsEcsServiceCapacityProviderStrategyDetails)
    pub fn builder() -> crate::model::aws_ecs_service_capacity_provider_strategy_details::Builder {
        crate::model::aws_ecs_service_capacity_provider_strategy_details::Builder::default()
    }
}

/// <p>Details about an Amazon RDS event notification subscription. The subscription allows Amazon RDS to post events to an SNS topic.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRdsEventSubscriptionDetails {
    /// <p>The identifier of the account that is associated with the event notification subscription.</p>
    pub cust_subscription_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the event notification subscription.</p>
    pub customer_aws_id: std::option::Option<std::string::String>,
    /// <p>Whether the event notification subscription is enabled.</p>
    pub enabled: bool,
    /// <p>The list of event categories for the event notification subscription.</p>
    pub event_categories_list: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ARN of the event notification subscription.</p>
    pub event_subscription_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the SNS topic to post the event notifications to.</p>
    pub sns_topic_arn: std::option::Option<std::string::String>,
    /// <p>A list of source identifiers for the event notification subscription.</p>
    pub source_ids_list: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The source type for the event notification subscription.</p>
    pub source_type: std::option::Option<std::string::String>,
    /// <p>The status of the event notification subscription.</p>
    /// <p>Valid values: <code>creating</code> | <code>modifying</code> | <code>deleting</code> | <code>active</code> | <code>no-permission</code> | <code>topic-not-exist</code> </p>
    pub status: std::option::Option<std::string::String>,
    /// <p>The datetime when the event notification subscription was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub subscription_creation_time: std::option::Option<std::string::String>,
}
impl AwsRdsEventSubscriptionDetails {
    /// <p>The identifier of the account that is associated with the event notification subscription.</p>
    pub fn cust_subscription_id(&self) -> std::option::Option<&str> {
        self.cust_subscription_id.as_deref()
    }
    /// <p>The identifier of the event notification subscription.</p>
    pub fn customer_aws_id(&self) -> std::option::Option<&str> {
        self.customer_aws_id.as_deref()
    }
    /// <p>Whether the event notification subscription is enabled.</p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
    /// <p>The list of event categories for the event notification subscription.</p>
    pub fn event_categories_list(&self) -> std::option::Option<&[std::string::String]> {
        self.event_categories_list.as_deref()
    }
    /// <p>The ARN of the event notification subscription.</p>
    pub fn event_subscription_arn(&self) -> std::option::Option<&str> {
        self.event_subscription_arn.as_deref()
    }
    /// <p>The ARN of the SNS topic to post the event notifications to.</p>
    pub fn sns_topic_arn(&self) -> std::option::Option<&str> {
        self.sns_topic_arn.as_deref()
    }
    /// <p>A list of source identifiers for the event notification subscription.</p>
    pub fn source_ids_list(&self) -> std::option::Option<&[std::string::String]> {
        self.source_ids_list.as_deref()
    }
    /// <p>The source type for the event notification subscription.</p>
    pub fn source_type(&self) -> std::option::Option<&str> {
        self.source_type.as_deref()
    }
    /// <p>The status of the event notification subscription.</p>
    /// <p>Valid values: <code>creating</code> | <code>modifying</code> | <code>deleting</code> | <code>active</code> | <code>no-permission</code> | <code>topic-not-exist</code> </p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>The datetime when the event notification subscription was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn subscription_creation_time(&self) -> std::option::Option<&str> {
        self.subscription_creation_time.as_deref()
    }
}
impl std::fmt::Debug for AwsRdsEventSubscriptionDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRdsEventSubscriptionDetails");
        formatter.field("cust_subscription_id", &self.cust_subscription_id);
        formatter.field("customer_aws_id", &self.customer_aws_id);
        formatter.field("enabled", &self.enabled);
        formatter.field("event_categories_list", &self.event_categories_list);
        formatter.field("event_subscription_arn", &self.event_subscription_arn);
        formatter.field("sns_topic_arn", &self.sns_topic_arn);
        formatter.field("source_ids_list", &self.source_ids_list);
        formatter.field("source_type", &self.source_type);
        formatter.field("status", &self.status);
        formatter.field(
            "subscription_creation_time",
            &self.subscription_creation_time,
        );
        formatter.finish()
    }
}
/// See [`AwsRdsEventSubscriptionDetails`](crate::model::AwsRdsEventSubscriptionDetails)
pub mod aws_rds_event_subscription_details {

    /// A builder for [`AwsRdsEventSubscriptionDetails`](crate::model::AwsRdsEventSubscriptionDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cust_subscription_id: std::option::Option<std::string::String>,
        pub(crate) customer_aws_id: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) event_categories_list: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) event_subscription_arn: std::option::Option<std::string::String>,
        pub(crate) sns_topic_arn: std::option::Option<std::string::String>,
        pub(crate) source_ids_list: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) source_type: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) subscription_creation_time: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the account that is associated with the event notification subscription.</p>
        pub fn cust_subscription_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.cust_subscription_id = Some(input.into());
            self
        }
        /// <p>The identifier of the account that is associated with the event notification subscription.</p>
        pub fn set_cust_subscription_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cust_subscription_id = input;
            self
        }
        /// <p>The identifier of the event notification subscription.</p>
        pub fn customer_aws_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.customer_aws_id = Some(input.into());
            self
        }
        /// <p>The identifier of the event notification subscription.</p>
        pub fn set_customer_aws_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.customer_aws_id = input;
            self
        }
        /// <p>Whether the event notification subscription is enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Whether the event notification subscription is enabled.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Appends an item to `event_categories_list`.
        ///
        /// To override the contents of this collection use [`set_event_categories_list`](Self::set_event_categories_list).
        ///
        /// <p>The list of event categories for the event notification subscription.</p>
        pub fn event_categories_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.event_categories_list.unwrap_or_default();
            v.push(input.into());
            self.event_categories_list = Some(v);
            self
        }
        /// <p>The list of event categories for the event notification subscription.</p>
        pub fn set_event_categories_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.event_categories_list = input;
            self
        }
        /// <p>The ARN of the event notification subscription.</p>
        pub fn event_subscription_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_subscription_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the event notification subscription.</p>
        pub fn set_event_subscription_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.event_subscription_arn = input;
            self
        }
        /// <p>The ARN of the SNS topic to post the event notifications to.</p>
        pub fn sns_topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.sns_topic_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the SNS topic to post the event notifications to.</p>
        pub fn set_sns_topic_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sns_topic_arn = input;
            self
        }
        /// Appends an item to `source_ids_list`.
        ///
        /// To override the contents of this collection use [`set_source_ids_list`](Self::set_source_ids_list).
        ///
        /// <p>A list of source identifiers for the event notification subscription.</p>
        pub fn source_ids_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.source_ids_list.unwrap_or_default();
            v.push(input.into());
            self.source_ids_list = Some(v);
            self
        }
        /// <p>A list of source identifiers for the event notification subscription.</p>
        pub fn set_source_ids_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.source_ids_list = input;
            self
        }
        /// <p>The source type for the event notification subscription.</p>
        pub fn source_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_type = Some(input.into());
            self
        }
        /// <p>The source type for the event notification subscription.</p>
        pub fn set_source_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_type = input;
            self
        }
        /// <p>The status of the event notification subscription.</p>
        /// <p>Valid values: <code>creating</code> | <code>modifying</code> | <code>deleting</code> | <code>active</code> | <code>no-permission</code> | <code>topic-not-exist</code> </p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the event notification subscription.</p>
        /// <p>Valid values: <code>creating</code> | <code>modifying</code> | <code>deleting</code> | <code>active</code> | <code>no-permission</code> | <code>topic-not-exist</code> </p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>The datetime when the event notification subscription was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn subscription_creation_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscription_creation_time = Some(input.into());
            self
        }
        /// <p>The datetime when the event notification subscription was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_subscription_creation_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.subscription_creation_time = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRdsEventSubscriptionDetails`](crate::model::AwsRdsEventSubscriptionDetails)
        pub fn build(self) -> crate::model::AwsRdsEventSubscriptionDetails {
            crate::model::AwsRdsEventSubscriptionDetails {
                cust_subscription_id: self.cust_subscription_id,
                customer_aws_id: self.customer_aws_id,
                enabled: self.enabled.unwrap_or_default(),
                event_categories_list: self.event_categories_list,
                event_subscription_arn: self.event_subscription_arn,
                sns_topic_arn: self.sns_topic_arn,
                source_ids_list: self.source_ids_list,
                source_type: self.source_type,
                status: self.status,
                subscription_creation_time: self.subscription_creation_time,
            }
        }
    }
}
impl AwsRdsEventSubscriptionDetails {
    /// Creates a new builder-style object to manufacture [`AwsRdsEventSubscriptionDetails`](crate::model::AwsRdsEventSubscriptionDetails)
    pub fn builder() -> crate::model::aws_rds_event_subscription_details::Builder {
        crate::model::aws_rds_event_subscription_details::Builder::default()
    }
}

/// <p>Container details related to a finding.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContainerDetails {
    /// <p>The runtime of the container. </p>
    pub container_runtime: std::option::Option<std::string::String>,
    /// <p>The name of the container related to a finding.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The identifier of the container image related to a finding.</p>
    pub image_id: std::option::Option<std::string::String>,
    /// <p>The name of the container image related to a finding.</p>
    pub image_name: std::option::Option<std::string::String>,
    /// <p>Indicates when the container started.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub launched_at: std::option::Option<std::string::String>,
    /// <p>Provides information about the mounting of a volume in a container. </p>
    pub volume_mounts: std::option::Option<std::vec::Vec<crate::model::VolumeMount>>,
    /// <p>When this parameter is <code>true</code>, the container is given elevated privileges on the host container instance (similar to the root user). </p>
    pub privileged: bool,
}
impl ContainerDetails {
    /// <p>The runtime of the container. </p>
    pub fn container_runtime(&self) -> std::option::Option<&str> {
        self.container_runtime.as_deref()
    }
    /// <p>The name of the container related to a finding.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The identifier of the container image related to a finding.</p>
    pub fn image_id(&self) -> std::option::Option<&str> {
        self.image_id.as_deref()
    }
    /// <p>The name of the container image related to a finding.</p>
    pub fn image_name(&self) -> std::option::Option<&str> {
        self.image_name.as_deref()
    }
    /// <p>Indicates when the container started.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn launched_at(&self) -> std::option::Option<&str> {
        self.launched_at.as_deref()
    }
    /// <p>Provides information about the mounting of a volume in a container. </p>
    pub fn volume_mounts(&self) -> std::option::Option<&[crate::model::VolumeMount]> {
        self.volume_mounts.as_deref()
    }
    /// <p>When this parameter is <code>true</code>, the container is given elevated privileges on the host container instance (similar to the root user). </p>
    pub fn privileged(&self) -> bool {
        self.privileged
    }
}
impl std::fmt::Debug for ContainerDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContainerDetails");
        formatter.field("container_runtime", &self.container_runtime);
        formatter.field("name", &self.name);
        formatter.field("image_id", &self.image_id);
        formatter.field("image_name", &self.image_name);
        formatter.field("launched_at", &self.launched_at);
        formatter.field("volume_mounts", &self.volume_mounts);
        formatter.field("privileged", &self.privileged);
        formatter.finish()
    }
}
/// See [`ContainerDetails`](crate::model::ContainerDetails)
pub mod container_details {

    /// A builder for [`ContainerDetails`](crate::model::ContainerDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) container_runtime: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) image_id: std::option::Option<std::string::String>,
        pub(crate) image_name: std::option::Option<std::string::String>,
        pub(crate) launched_at: std::option::Option<std::string::String>,
        pub(crate) volume_mounts: std::option::Option<std::vec::Vec<crate::model::VolumeMount>>,
        pub(crate) privileged: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The runtime of the container. </p>
        pub fn container_runtime(mut self, input: impl Into<std::string::String>) -> Self {
            self.container_runtime = Some(input.into());
            self
        }
        /// <p>The runtime of the container. </p>
        pub fn set_container_runtime(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.container_runtime = input;
            self
        }
        /// <p>The name of the container related to a finding.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the container related to a finding.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The identifier of the container image related to a finding.</p>
        pub fn image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_id = Some(input.into());
            self
        }
        /// <p>The identifier of the container image related to a finding.</p>
        pub fn set_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_id = input;
            self
        }
        /// <p>The name of the container image related to a finding.</p>
        pub fn image_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_name = Some(input.into());
            self
        }
        /// <p>The name of the container image related to a finding.</p>
        pub fn set_image_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_name = input;
            self
        }
        /// <p>Indicates when the container started.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn launched_at(mut self, input: impl Into<std::string::String>) -> Self {
            self.launched_at = Some(input.into());
            self
        }
        /// <p>Indicates when the container started.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_launched_at(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.launched_at = input;
            self
        }
        /// Appends an item to `volume_mounts`.
        ///
        /// To override the contents of this collection use [`set_volume_mounts`](Self::set_volume_mounts).
        ///
        /// <p>Provides information about the mounting of a volume in a container. </p>
        pub fn volume_mounts(mut self, input: crate::model::VolumeMount) -> Self {
            let mut v = self.volume_mounts.unwrap_or_default();
            v.push(input);
            self.volume_mounts = Some(v);
            self
        }
        /// <p>Provides information about the mounting of a volume in a container. </p>
        pub fn set_volume_mounts(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VolumeMount>>,
        ) -> Self {
            self.volume_mounts = input;
            self
        }
        /// <p>When this parameter is <code>true</code>, the container is given elevated privileges on the host container instance (similar to the root user). </p>
        pub fn privileged(mut self, input: bool) -> Self {
            self.privileged = Some(input);
            self
        }
        /// <p>When this parameter is <code>true</code>, the container is given elevated privileges on the host container instance (similar to the root user). </p>
        pub fn set_privileged(mut self, input: std::option::Option<bool>) -> Self {
            self.privileged = input;
            self
        }
        /// Consumes the builder and constructs a [`ContainerDetails`](crate::model::ContainerDetails)
        pub fn build(self) -> crate::model::ContainerDetails {
            crate::model::ContainerDetails {
                container_runtime: self.container_runtime,
                name: self.name,
                image_id: self.image_id,
                image_name: self.image_name,
                launched_at: self.launched_at,
                volume_mounts: self.volume_mounts,
                privileged: self.privileged.unwrap_or_default(),
            }
        }
    }
}
impl ContainerDetails {
    /// Creates a new builder-style object to manufacture [`ContainerDetails`](crate::model::ContainerDetails)
    pub fn builder() -> crate::model::container_details::Builder {
        crate::model::container_details::Builder::default()
    }
}

/// <p>Describes the mounting of a volume in a container. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VolumeMount {
    /// <p>The name of the volume. </p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The path in the container at which the volume should be mounted. </p>
    pub mount_path: std::option::Option<std::string::String>,
}
impl VolumeMount {
    /// <p>The name of the volume. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The path in the container at which the volume should be mounted. </p>
    pub fn mount_path(&self) -> std::option::Option<&str> {
        self.mount_path.as_deref()
    }
}
impl std::fmt::Debug for VolumeMount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VolumeMount");
        formatter.field("name", &self.name);
        formatter.field("mount_path", &self.mount_path);
        formatter.finish()
    }
}
/// See [`VolumeMount`](crate::model::VolumeMount)
pub mod volume_mount {

    /// A builder for [`VolumeMount`](crate::model::VolumeMount)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) mount_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the volume. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the volume. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The path in the container at which the volume should be mounted. </p>
        pub fn mount_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.mount_path = Some(input.into());
            self
        }
        /// <p>The path in the container at which the volume should be mounted. </p>
        pub fn set_mount_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mount_path = input;
            self
        }
        /// Consumes the builder and constructs a [`VolumeMount`](crate::model::VolumeMount)
        pub fn build(self) -> crate::model::VolumeMount {
            crate::model::VolumeMount {
                name: self.name,
                mount_path: self.mount_path,
            }
        }
    }
}
impl VolumeMount {
    /// Creates a new builder-style object to manufacture [`VolumeMount`](crate::model::VolumeMount)
    pub fn builder() -> crate::model::volume_mount::Builder {
        crate::model::volume_mount::Builder::default()
    }
}

/// <p>Details about a task definition. A task definition describes the container and volume definitions of an Amazon Elastic Container Service task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionDetails {
    /// <p>The container definitions that describe the containers that make up the task.</p>
    pub container_definitions: std::option::Option<
        std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsDetails>,
    >,
    /// <p>The number of CPU units used by the task.</p>
    pub cpu: std::option::Option<std::string::String>,
    /// <p>The ARN of the task execution role that grants the container agent permission to make API calls on behalf of the container user.</p>
    pub execution_role_arn: std::option::Option<std::string::String>,
    /// <p>The name of a family that this task definition is registered to.</p>
    pub family: std::option::Option<std::string::String>,
    /// <p>The Elastic Inference accelerators to use for the containers in the task.</p>
    pub inference_accelerators: std::option::Option<
        std::vec::Vec<crate::model::AwsEcsTaskDefinitionInferenceAcceleratorsDetails>,
    >,
    /// <p>The IPC resource namespace to use for the containers in the task.</p>
    pub ipc_mode: std::option::Option<std::string::String>,
    /// <p>The amount (in MiB) of memory used by the task.</p>
    pub memory: std::option::Option<std::string::String>,
    /// <p>The Docker networking mode to use for the containers in the task.</p>
    pub network_mode: std::option::Option<std::string::String>,
    /// <p>The process namespace to use for the containers in the task.</p>
    pub pid_mode: std::option::Option<std::string::String>,
    /// <p>The placement constraint objects to use for tasks.</p>
    pub placement_constraints: std::option::Option<
        std::vec::Vec<crate::model::AwsEcsTaskDefinitionPlacementConstraintsDetails>,
    >,
    /// <p>The configuration details for the App Mesh proxy.</p>
    pub proxy_configuration:
        std::option::Option<crate::model::AwsEcsTaskDefinitionProxyConfigurationDetails>,
    /// <p>The task launch types that the task definition was validated against.</p>
    pub requires_compatibilities: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The short name or ARN of the IAM role that grants containers in the task permission to call Amazon Web Services API operations on your behalf.</p>
    pub task_role_arn: std::option::Option<std::string::String>,
    /// <p>The data volume definitions for the task.</p>
    pub volumes:
        std::option::Option<std::vec::Vec<crate::model::AwsEcsTaskDefinitionVolumesDetails>>,
}
impl AwsEcsTaskDefinitionDetails {
    /// <p>The container definitions that describe the containers that make up the task.</p>
    pub fn container_definitions(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEcsTaskDefinitionContainerDefinitionsDetails]> {
        self.container_definitions.as_deref()
    }
    /// <p>The number of CPU units used by the task.</p>
    pub fn cpu(&self) -> std::option::Option<&str> {
        self.cpu.as_deref()
    }
    /// <p>The ARN of the task execution role that grants the container agent permission to make API calls on behalf of the container user.</p>
    pub fn execution_role_arn(&self) -> std::option::Option<&str> {
        self.execution_role_arn.as_deref()
    }
    /// <p>The name of a family that this task definition is registered to.</p>
    pub fn family(&self) -> std::option::Option<&str> {
        self.family.as_deref()
    }
    /// <p>The Elastic Inference accelerators to use for the containers in the task.</p>
    pub fn inference_accelerators(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEcsTaskDefinitionInferenceAcceleratorsDetails]>
    {
        self.inference_accelerators.as_deref()
    }
    /// <p>The IPC resource namespace to use for the containers in the task.</p>
    pub fn ipc_mode(&self) -> std::option::Option<&str> {
        self.ipc_mode.as_deref()
    }
    /// <p>The amount (in MiB) of memory used by the task.</p>
    pub fn memory(&self) -> std::option::Option<&str> {
        self.memory.as_deref()
    }
    /// <p>The Docker networking mode to use for the containers in the task.</p>
    pub fn network_mode(&self) -> std::option::Option<&str> {
        self.network_mode.as_deref()
    }
    /// <p>The process namespace to use for the containers in the task.</p>
    pub fn pid_mode(&self) -> std::option::Option<&str> {
        self.pid_mode.as_deref()
    }
    /// <p>The placement constraint objects to use for tasks.</p>
    pub fn placement_constraints(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEcsTaskDefinitionPlacementConstraintsDetails]> {
        self.placement_constraints.as_deref()
    }
    /// <p>The configuration details for the App Mesh proxy.</p>
    pub fn proxy_configuration(
        &self,
    ) -> std::option::Option<&crate::model::AwsEcsTaskDefinitionProxyConfigurationDetails> {
        self.proxy_configuration.as_ref()
    }
    /// <p>The task launch types that the task definition was validated against.</p>
    pub fn requires_compatibilities(&self) -> std::option::Option<&[std::string::String]> {
        self.requires_compatibilities.as_deref()
    }
    /// <p>The short name or ARN of the IAM role that grants containers in the task permission to call Amazon Web Services API operations on your behalf.</p>
    pub fn task_role_arn(&self) -> std::option::Option<&str> {
        self.task_role_arn.as_deref()
    }
    /// <p>The data volume definitions for the task.</p>
    pub fn volumes(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEcsTaskDefinitionVolumesDetails]> {
        self.volumes.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcsTaskDefinitionDetails");
        formatter.field("container_definitions", &self.container_definitions);
        formatter.field("cpu", &self.cpu);
        formatter.field("execution_role_arn", &self.execution_role_arn);
        formatter.field("family", &self.family);
        formatter.field("inference_accelerators", &self.inference_accelerators);
        formatter.field("ipc_mode", &self.ipc_mode);
        formatter.field("memory", &self.memory);
        formatter.field("network_mode", &self.network_mode);
        formatter.field("pid_mode", &self.pid_mode);
        formatter.field("placement_constraints", &self.placement_constraints);
        formatter.field("proxy_configuration", &self.proxy_configuration);
        formatter.field("requires_compatibilities", &self.requires_compatibilities);
        formatter.field("task_role_arn", &self.task_role_arn);
        formatter.field("volumes", &self.volumes);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionDetails`](crate::model::AwsEcsTaskDefinitionDetails)
pub mod aws_ecs_task_definition_details {

    /// A builder for [`AwsEcsTaskDefinitionDetails`](crate::model::AwsEcsTaskDefinitionDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) container_definitions: std::option::Option<
            std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsDetails>,
        >,
        pub(crate) cpu: std::option::Option<std::string::String>,
        pub(crate) execution_role_arn: std::option::Option<std::string::String>,
        pub(crate) family: std::option::Option<std::string::String>,
        pub(crate) inference_accelerators: std::option::Option<
            std::vec::Vec<crate::model::AwsEcsTaskDefinitionInferenceAcceleratorsDetails>,
        >,
        pub(crate) ipc_mode: std::option::Option<std::string::String>,
        pub(crate) memory: std::option::Option<std::string::String>,
        pub(crate) network_mode: std::option::Option<std::string::String>,
        pub(crate) pid_mode: std::option::Option<std::string::String>,
        pub(crate) placement_constraints: std::option::Option<
            std::vec::Vec<crate::model::AwsEcsTaskDefinitionPlacementConstraintsDetails>,
        >,
        pub(crate) proxy_configuration:
            std::option::Option<crate::model::AwsEcsTaskDefinitionProxyConfigurationDetails>,
        pub(crate) requires_compatibilities:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) task_role_arn: std::option::Option<std::string::String>,
        pub(crate) volumes:
            std::option::Option<std::vec::Vec<crate::model::AwsEcsTaskDefinitionVolumesDetails>>,
    }
    impl Builder {
        /// Appends an item to `container_definitions`.
        ///
        /// To override the contents of this collection use [`set_container_definitions`](Self::set_container_definitions).
        ///
        /// <p>The container definitions that describe the containers that make up the task.</p>
        pub fn container_definitions(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionContainerDefinitionsDetails,
        ) -> Self {
            let mut v = self.container_definitions.unwrap_or_default();
            v.push(input);
            self.container_definitions = Some(v);
            self
        }
        /// <p>The container definitions that describe the containers that make up the task.</p>
        pub fn set_container_definitions(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsDetails>,
            >,
        ) -> Self {
            self.container_definitions = input;
            self
        }
        /// <p>The number of CPU units used by the task.</p>
        pub fn cpu(mut self, input: impl Into<std::string::String>) -> Self {
            self.cpu = Some(input.into());
            self
        }
        /// <p>The number of CPU units used by the task.</p>
        pub fn set_cpu(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cpu = input;
            self
        }
        /// <p>The ARN of the task execution role that grants the container agent permission to make API calls on behalf of the container user.</p>
        pub fn execution_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.execution_role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the task execution role that grants the container agent permission to make API calls on behalf of the container user.</p>
        pub fn set_execution_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.execution_role_arn = input;
            self
        }
        /// <p>The name of a family that this task definition is registered to.</p>
        pub fn family(mut self, input: impl Into<std::string::String>) -> Self {
            self.family = Some(input.into());
            self
        }
        /// <p>The name of a family that this task definition is registered to.</p>
        pub fn set_family(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.family = input;
            self
        }
        /// Appends an item to `inference_accelerators`.
        ///
        /// To override the contents of this collection use [`set_inference_accelerators`](Self::set_inference_accelerators).
        ///
        /// <p>The Elastic Inference accelerators to use for the containers in the task.</p>
        pub fn inference_accelerators(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionInferenceAcceleratorsDetails,
        ) -> Self {
            let mut v = self.inference_accelerators.unwrap_or_default();
            v.push(input);
            self.inference_accelerators = Some(v);
            self
        }
        /// <p>The Elastic Inference accelerators to use for the containers in the task.</p>
        pub fn set_inference_accelerators(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEcsTaskDefinitionInferenceAcceleratorsDetails>,
            >,
        ) -> Self {
            self.inference_accelerators = input;
            self
        }
        /// <p>The IPC resource namespace to use for the containers in the task.</p>
        pub fn ipc_mode(mut self, input: impl Into<std::string::String>) -> Self {
            self.ipc_mode = Some(input.into());
            self
        }
        /// <p>The IPC resource namespace to use for the containers in the task.</p>
        pub fn set_ipc_mode(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ipc_mode = input;
            self
        }
        /// <p>The amount (in MiB) of memory used by the task.</p>
        pub fn memory(mut self, input: impl Into<std::string::String>) -> Self {
            self.memory = Some(input.into());
            self
        }
        /// <p>The amount (in MiB) of memory used by the task.</p>
        pub fn set_memory(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.memory = input;
            self
        }
        /// <p>The Docker networking mode to use for the containers in the task.</p>
        pub fn network_mode(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_mode = Some(input.into());
            self
        }
        /// <p>The Docker networking mode to use for the containers in the task.</p>
        pub fn set_network_mode(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.network_mode = input;
            self
        }
        /// <p>The process namespace to use for the containers in the task.</p>
        pub fn pid_mode(mut self, input: impl Into<std::string::String>) -> Self {
            self.pid_mode = Some(input.into());
            self
        }
        /// <p>The process namespace to use for the containers in the task.</p>
        pub fn set_pid_mode(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pid_mode = input;
            self
        }
        /// Appends an item to `placement_constraints`.
        ///
        /// To override the contents of this collection use [`set_placement_constraints`](Self::set_placement_constraints).
        ///
        /// <p>The placement constraint objects to use for tasks.</p>
        pub fn placement_constraints(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionPlacementConstraintsDetails,
        ) -> Self {
            let mut v = self.placement_constraints.unwrap_or_default();
            v.push(input);
            self.placement_constraints = Some(v);
            self
        }
        /// <p>The placement constraint objects to use for tasks.</p>
        pub fn set_placement_constraints(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEcsTaskDefinitionPlacementConstraintsDetails>,
            >,
        ) -> Self {
            self.placement_constraints = input;
            self
        }
        /// <p>The configuration details for the App Mesh proxy.</p>
        pub fn proxy_configuration(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionProxyConfigurationDetails,
        ) -> Self {
            self.proxy_configuration = Some(input);
            self
        }
        /// <p>The configuration details for the App Mesh proxy.</p>
        pub fn set_proxy_configuration(
            mut self,
            input: std::option::Option<crate::model::AwsEcsTaskDefinitionProxyConfigurationDetails>,
        ) -> Self {
            self.proxy_configuration = input;
            self
        }
        /// Appends an item to `requires_compatibilities`.
        ///
        /// To override the contents of this collection use [`set_requires_compatibilities`](Self::set_requires_compatibilities).
        ///
        /// <p>The task launch types that the task definition was validated against.</p>
        pub fn requires_compatibilities(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.requires_compatibilities.unwrap_or_default();
            v.push(input.into());
            self.requires_compatibilities = Some(v);
            self
        }
        /// <p>The task launch types that the task definition was validated against.</p>
        pub fn set_requires_compatibilities(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.requires_compatibilities = input;
            self
        }
        /// <p>The short name or ARN of the IAM role that grants containers in the task permission to call Amazon Web Services API operations on your behalf.</p>
        pub fn task_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_role_arn = Some(input.into());
            self
        }
        /// <p>The short name or ARN of the IAM role that grants containers in the task permission to call Amazon Web Services API operations on your behalf.</p>
        pub fn set_task_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.task_role_arn = input;
            self
        }
        /// Appends an item to `volumes`.
        ///
        /// To override the contents of this collection use [`set_volumes`](Self::set_volumes).
        ///
        /// <p>The data volume definitions for the task.</p>
        pub fn volumes(mut self, input: crate::model::AwsEcsTaskDefinitionVolumesDetails) -> Self {
            let mut v = self.volumes.unwrap_or_default();
            v.push(input);
            self.volumes = Some(v);
            self
        }
        /// <p>The data volume definitions for the task.</p>
        pub fn set_volumes(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEcsTaskDefinitionVolumesDetails>,
            >,
        ) -> Self {
            self.volumes = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionDetails`](crate::model::AwsEcsTaskDefinitionDetails)
        pub fn build(self) -> crate::model::AwsEcsTaskDefinitionDetails {
            crate::model::AwsEcsTaskDefinitionDetails {
                container_definitions: self.container_definitions,
                cpu: self.cpu,
                execution_role_arn: self.execution_role_arn,
                family: self.family,
                inference_accelerators: self.inference_accelerators,
                ipc_mode: self.ipc_mode,
                memory: self.memory,
                network_mode: self.network_mode,
                pid_mode: self.pid_mode,
                placement_constraints: self.placement_constraints,
                proxy_configuration: self.proxy_configuration,
                requires_compatibilities: self.requires_compatibilities,
                task_role_arn: self.task_role_arn,
                volumes: self.volumes,
            }
        }
    }
}
impl AwsEcsTaskDefinitionDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionDetails`](crate::model::AwsEcsTaskDefinitionDetails)
    pub fn builder() -> crate::model::aws_ecs_task_definition_details::Builder {
        crate::model::aws_ecs_task_definition_details::Builder::default()
    }
}

/// <p>A data volume to mount from another container.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionVolumesDetails {
    /// <p>Information about a Docker volume.</p>
    pub docker_volume_configuration: std::option::Option<
        crate::model::AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails,
    >,
    /// <p>Information about the Amazon Elastic File System file system that is used for task storage.</p>
    pub efs_volume_configuration:
        std::option::Option<crate::model::AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails>,
    /// <p>Information about a bind mount host volume.</p>
    pub host: std::option::Option<crate::model::AwsEcsTaskDefinitionVolumesHostDetails>,
    /// <p>The name of the data volume.</p>
    pub name: std::option::Option<std::string::String>,
}
impl AwsEcsTaskDefinitionVolumesDetails {
    /// <p>Information about a Docker volume.</p>
    pub fn docker_volume_configuration(
        &self,
    ) -> std::option::Option<
        &crate::model::AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails,
    > {
        self.docker_volume_configuration.as_ref()
    }
    /// <p>Information about the Amazon Elastic File System file system that is used for task storage.</p>
    pub fn efs_volume_configuration(
        &self,
    ) -> std::option::Option<&crate::model::AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails>
    {
        self.efs_volume_configuration.as_ref()
    }
    /// <p>Information about a bind mount host volume.</p>
    pub fn host(
        &self,
    ) -> std::option::Option<&crate::model::AwsEcsTaskDefinitionVolumesHostDetails> {
        self.host.as_ref()
    }
    /// <p>The name of the data volume.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionVolumesDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcsTaskDefinitionVolumesDetails");
        formatter.field(
            "docker_volume_configuration",
            &self.docker_volume_configuration,
        );
        formatter.field("efs_volume_configuration", &self.efs_volume_configuration);
        formatter.field("host", &self.host);
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionVolumesDetails`](crate::model::AwsEcsTaskDefinitionVolumesDetails)
pub mod aws_ecs_task_definition_volumes_details {

    /// A builder for [`AwsEcsTaskDefinitionVolumesDetails`](crate::model::AwsEcsTaskDefinitionVolumesDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) docker_volume_configuration: std::option::Option<
            crate::model::AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails,
        >,
        pub(crate) efs_volume_configuration: std::option::Option<
            crate::model::AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails,
        >,
        pub(crate) host: std::option::Option<crate::model::AwsEcsTaskDefinitionVolumesHostDetails>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Information about a Docker volume.</p>
        pub fn docker_volume_configuration(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails,
        ) -> Self {
            self.docker_volume_configuration = Some(input);
            self
        }
        /// <p>Information about a Docker volume.</p>
        pub fn set_docker_volume_configuration(
            mut self,
            input: std::option::Option<
                crate::model::AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails,
            >,
        ) -> Self {
            self.docker_volume_configuration = input;
            self
        }
        /// <p>Information about the Amazon Elastic File System file system that is used for task storage.</p>
        pub fn efs_volume_configuration(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails,
        ) -> Self {
            self.efs_volume_configuration = Some(input);
            self
        }
        /// <p>Information about the Amazon Elastic File System file system that is used for task storage.</p>
        pub fn set_efs_volume_configuration(
            mut self,
            input: std::option::Option<
                crate::model::AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails,
            >,
        ) -> Self {
            self.efs_volume_configuration = input;
            self
        }
        /// <p>Information about a bind mount host volume.</p>
        pub fn host(mut self, input: crate::model::AwsEcsTaskDefinitionVolumesHostDetails) -> Self {
            self.host = Some(input);
            self
        }
        /// <p>Information about a bind mount host volume.</p>
        pub fn set_host(
            mut self,
            input: std::option::Option<crate::model::AwsEcsTaskDefinitionVolumesHostDetails>,
        ) -> Self {
            self.host = input;
            self
        }
        /// <p>The name of the data volume.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data volume.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionVolumesDetails`](crate::model::AwsEcsTaskDefinitionVolumesDetails)
        pub fn build(self) -> crate::model::AwsEcsTaskDefinitionVolumesDetails {
            crate::model::AwsEcsTaskDefinitionVolumesDetails {
                docker_volume_configuration: self.docker_volume_configuration,
                efs_volume_configuration: self.efs_volume_configuration,
                host: self.host,
                name: self.name,
            }
        }
    }
}
impl AwsEcsTaskDefinitionVolumesDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionVolumesDetails`](crate::model::AwsEcsTaskDefinitionVolumesDetails)
    pub fn builder() -> crate::model::aws_ecs_task_definition_volumes_details::Builder {
        crate::model::aws_ecs_task_definition_volumes_details::Builder::default()
    }
}

/// <p>Information about a bind mount host volume.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionVolumesHostDetails {
    /// <p>The path on the host container instance that is presented to the container.</p>
    pub source_path: std::option::Option<std::string::String>,
}
impl AwsEcsTaskDefinitionVolumesHostDetails {
    /// <p>The path on the host container instance that is presented to the container.</p>
    pub fn source_path(&self) -> std::option::Option<&str> {
        self.source_path.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionVolumesHostDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcsTaskDefinitionVolumesHostDetails");
        formatter.field("source_path", &self.source_path);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionVolumesHostDetails`](crate::model::AwsEcsTaskDefinitionVolumesHostDetails)
pub mod aws_ecs_task_definition_volumes_host_details {

    /// A builder for [`AwsEcsTaskDefinitionVolumesHostDetails`](crate::model::AwsEcsTaskDefinitionVolumesHostDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The path on the host container instance that is presented to the container.</p>
        pub fn source_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_path = Some(input.into());
            self
        }
        /// <p>The path on the host container instance that is presented to the container.</p>
        pub fn set_source_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_path = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionVolumesHostDetails`](crate::model::AwsEcsTaskDefinitionVolumesHostDetails)
        pub fn build(self) -> crate::model::AwsEcsTaskDefinitionVolumesHostDetails {
            crate::model::AwsEcsTaskDefinitionVolumesHostDetails {
                source_path: self.source_path,
            }
        }
    }
}
impl AwsEcsTaskDefinitionVolumesHostDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionVolumesHostDetails`](crate::model::AwsEcsTaskDefinitionVolumesHostDetails)
    pub fn builder() -> crate::model::aws_ecs_task_definition_volumes_host_details::Builder {
        crate::model::aws_ecs_task_definition_volumes_host_details::Builder::default()
    }
}

/// <p>Information about the Amazon Elastic File System file system that is used for task storage.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails {
    /// <p>The authorization configuration details for the Amazon EFS file system.</p>
    pub authorization_config: std::option::Option<
        crate::model::AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails,
    >,
    /// <p>The Amazon EFS file system identifier to use.</p>
    pub filesystem_id: std::option::Option<std::string::String>,
    /// <p>The directory within the Amazon EFS file system to mount as the root directory inside the host.</p>
    pub root_directory: std::option::Option<std::string::String>,
    /// <p>Whether to enable encryption for Amazon EFS data in transit between the Amazon ECS host and the Amazon EFS server. </p>
    pub transit_encryption: std::option::Option<std::string::String>,
    /// <p>The port to use when sending encrypted data between the Amazon ECS host and the Amazon EFS server.</p>
    pub transit_encryption_port: i32,
}
impl AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails {
    /// <p>The authorization configuration details for the Amazon EFS file system.</p>
    pub fn authorization_config(
        &self,
    ) -> std::option::Option<
        &crate::model::AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails,
    > {
        self.authorization_config.as_ref()
    }
    /// <p>The Amazon EFS file system identifier to use.</p>
    pub fn filesystem_id(&self) -> std::option::Option<&str> {
        self.filesystem_id.as_deref()
    }
    /// <p>The directory within the Amazon EFS file system to mount as the root directory inside the host.</p>
    pub fn root_directory(&self) -> std::option::Option<&str> {
        self.root_directory.as_deref()
    }
    /// <p>Whether to enable encryption for Amazon EFS data in transit between the Amazon ECS host and the Amazon EFS server. </p>
    pub fn transit_encryption(&self) -> std::option::Option<&str> {
        self.transit_encryption.as_deref()
    }
    /// <p>The port to use when sending encrypted data between the Amazon ECS host and the Amazon EFS server.</p>
    pub fn transit_encryption_port(&self) -> i32 {
        self.transit_encryption_port
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails");
        formatter.field("authorization_config", &self.authorization_config);
        formatter.field("filesystem_id", &self.filesystem_id);
        formatter.field("root_directory", &self.root_directory);
        formatter.field("transit_encryption", &self.transit_encryption);
        formatter.field("transit_encryption_port", &self.transit_encryption_port);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails`](crate::model::AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails)
pub mod aws_ecs_task_definition_volumes_efs_volume_configuration_details {

    /// A builder for [`AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails`](crate::model::AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) authorization_config: std::option::Option<crate::model::AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails>,
        pub(crate) filesystem_id: std::option::Option<std::string::String>,
        pub(crate) root_directory: std::option::Option<std::string::String>,
        pub(crate) transit_encryption: std::option::Option<std::string::String>,
        pub(crate) transit_encryption_port: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The authorization configuration details for the Amazon EFS file system.</p>
        pub fn authorization_config(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails,
        ) -> Self {
            self.authorization_config = Some(input);
            self
        }
        /// <p>The authorization configuration details for the Amazon EFS file system.</p>
        pub fn set_authorization_config(
            mut self,
            input: std::option::Option<crate::model::AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails>,
        ) -> Self {
            self.authorization_config = input;
            self
        }
        /// <p>The Amazon EFS file system identifier to use.</p>
        pub fn filesystem_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.filesystem_id = Some(input.into());
            self
        }
        /// <p>The Amazon EFS file system identifier to use.</p>
        pub fn set_filesystem_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.filesystem_id = input;
            self
        }
        /// <p>The directory within the Amazon EFS file system to mount as the root directory inside the host.</p>
        pub fn root_directory(mut self, input: impl Into<std::string::String>) -> Self {
            self.root_directory = Some(input.into());
            self
        }
        /// <p>The directory within the Amazon EFS file system to mount as the root directory inside the host.</p>
        pub fn set_root_directory(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.root_directory = input;
            self
        }
        /// <p>Whether to enable encryption for Amazon EFS data in transit between the Amazon ECS host and the Amazon EFS server. </p>
        pub fn transit_encryption(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_encryption = Some(input.into());
            self
        }
        /// <p>Whether to enable encryption for Amazon EFS data in transit between the Amazon ECS host and the Amazon EFS server. </p>
        pub fn set_transit_encryption(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_encryption = input;
            self
        }
        /// <p>The port to use when sending encrypted data between the Amazon ECS host and the Amazon EFS server.</p>
        pub fn transit_encryption_port(mut self, input: i32) -> Self {
            self.transit_encryption_port = Some(input);
            self
        }
        /// <p>The port to use when sending encrypted data between the Amazon ECS host and the Amazon EFS server.</p>
        pub fn set_transit_encryption_port(mut self, input: std::option::Option<i32>) -> Self {
            self.transit_encryption_port = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails`](crate::model::AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails {
            crate::model::AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails {
                authorization_config: self.authorization_config,
                filesystem_id: self.filesystem_id,
                root_directory: self.root_directory,
                transit_encryption: self.transit_encryption,
                transit_encryption_port: self.transit_encryption_port.unwrap_or_default(),
            }
        }
    }
}
impl AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails`](crate::model::AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails)
    pub fn builder(
    ) -> crate::model::aws_ecs_task_definition_volumes_efs_volume_configuration_details::Builder
    {
        crate::model::aws_ecs_task_definition_volumes_efs_volume_configuration_details::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails {
    /// <p>The Amazon EFS access point identifier to use.</p>
    pub access_point_id: std::option::Option<std::string::String>,
    /// <p>Whether to use the Amazon ECS task IAM role defined in a task definition when mounting the Amazon EFS file system.</p>
    pub iam: std::option::Option<std::string::String>,
}
impl AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails {
    /// <p>The Amazon EFS access point identifier to use.</p>
    pub fn access_point_id(&self) -> std::option::Option<&str> {
        self.access_point_id.as_deref()
    }
    /// <p>Whether to use the Amazon ECS task IAM role defined in a task definition when mounting the Amazon EFS file system.</p>
    pub fn iam(&self) -> std::option::Option<&str> {
        self.iam.as_deref()
    }
}
impl std::fmt::Debug
    for AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct(
            "AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails",
        );
        formatter.field("access_point_id", &self.access_point_id);
        formatter.field("iam", &self.iam);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails`](crate::model::AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails)
pub mod aws_ecs_task_definition_volumes_efs_volume_configuration_authorization_config_details {

    /// A builder for [`AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails`](crate::model::AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) access_point_id: std::option::Option<std::string::String>,
        pub(crate) iam: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon EFS access point identifier to use.</p>
        pub fn access_point_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.access_point_id = Some(input.into());
            self
        }
        /// <p>The Amazon EFS access point identifier to use.</p>
        pub fn set_access_point_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.access_point_id = input;
            self
        }
        /// <p>Whether to use the Amazon ECS task IAM role defined in a task definition when mounting the Amazon EFS file system.</p>
        pub fn iam(mut self, input: impl Into<std::string::String>) -> Self {
            self.iam = Some(input.into());
            self
        }
        /// <p>Whether to use the Amazon ECS task IAM role defined in a task definition when mounting the Amazon EFS file system.</p>
        pub fn set_iam(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.iam = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails`](crate::model::AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails
        {
            crate::model::AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails {
                access_point_id: self.access_point_id
                ,
                iam: self.iam
                ,
            }
        }
    }
}
impl AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails`](crate::model::AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails)
    pub fn builder() -> crate::model::aws_ecs_task_definition_volumes_efs_volume_configuration_authorization_config_details::Builder{
        crate::model::aws_ecs_task_definition_volumes_efs_volume_configuration_authorization_config_details::Builder::default()
    }
}

/// <p>Information about a Docker volume.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails {
    /// <p>Whether to create the Docker volume automatically if it does not already exist.</p>
    pub autoprovision: bool,
    /// <p>The Docker volume driver to use.</p>
    pub driver: std::option::Option<std::string::String>,
    /// <p>A map of Docker driver-specific options that are passed through.</p>
    pub driver_opts:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Custom metadata to add to the Docker volume.</p>
    pub labels:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The scope for the Docker volume that determines its lifecycle. Docker volumes that are scoped to a task are provisioned automatically when the task starts and destroyed when the task stops. Docker volumes that are shared persist after the task stops.</p>
    pub scope: std::option::Option<std::string::String>,
}
impl AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails {
    /// <p>Whether to create the Docker volume automatically if it does not already exist.</p>
    pub fn autoprovision(&self) -> bool {
        self.autoprovision
    }
    /// <p>The Docker volume driver to use.</p>
    pub fn driver(&self) -> std::option::Option<&str> {
        self.driver.as_deref()
    }
    /// <p>A map of Docker driver-specific options that are passed through.</p>
    pub fn driver_opts(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.driver_opts.as_ref()
    }
    /// <p>Custom metadata to add to the Docker volume.</p>
    pub fn labels(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.labels.as_ref()
    }
    /// <p>The scope for the Docker volume that determines its lifecycle. Docker volumes that are scoped to a task are provisioned automatically when the task starts and destroyed when the task stops. Docker volumes that are shared persist after the task stops.</p>
    pub fn scope(&self) -> std::option::Option<&str> {
        self.scope.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails");
        formatter.field("autoprovision", &self.autoprovision);
        formatter.field("driver", &self.driver);
        formatter.field("driver_opts", &self.driver_opts);
        formatter.field("labels", &self.labels);
        formatter.field("scope", &self.scope);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails`](crate::model::AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails)
pub mod aws_ecs_task_definition_volumes_docker_volume_configuration_details {

    /// A builder for [`AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails`](crate::model::AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) autoprovision: std::option::Option<bool>,
        pub(crate) driver: std::option::Option<std::string::String>,
        pub(crate) driver_opts: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) labels: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) scope: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Whether to create the Docker volume automatically if it does not already exist.</p>
        pub fn autoprovision(mut self, input: bool) -> Self {
            self.autoprovision = Some(input);
            self
        }
        /// <p>Whether to create the Docker volume automatically if it does not already exist.</p>
        pub fn set_autoprovision(mut self, input: std::option::Option<bool>) -> Self {
            self.autoprovision = input;
            self
        }
        /// <p>The Docker volume driver to use.</p>
        pub fn driver(mut self, input: impl Into<std::string::String>) -> Self {
            self.driver = Some(input.into());
            self
        }
        /// <p>The Docker volume driver to use.</p>
        pub fn set_driver(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.driver = input;
            self
        }
        /// Adds a key-value pair to `driver_opts`.
        ///
        /// To override the contents of this collection use [`set_driver_opts`](Self::set_driver_opts).
        ///
        /// <p>A map of Docker driver-specific options that are passed through.</p>
        pub fn driver_opts(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.driver_opts.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.driver_opts = Some(hash_map);
            self
        }
        /// <p>A map of Docker driver-specific options that are passed through.</p>
        pub fn set_driver_opts(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.driver_opts = input;
            self
        }
        /// Adds a key-value pair to `labels`.
        ///
        /// To override the contents of this collection use [`set_labels`](Self::set_labels).
        ///
        /// <p>Custom metadata to add to the Docker volume.</p>
        pub fn labels(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.labels.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.labels = Some(hash_map);
            self
        }
        /// <p>Custom metadata to add to the Docker volume.</p>
        pub fn set_labels(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.labels = input;
            self
        }
        /// <p>The scope for the Docker volume that determines its lifecycle. Docker volumes that are scoped to a task are provisioned automatically when the task starts and destroyed when the task stops. Docker volumes that are shared persist after the task stops.</p>
        pub fn scope(mut self, input: impl Into<std::string::String>) -> Self {
            self.scope = Some(input.into());
            self
        }
        /// <p>The scope for the Docker volume that determines its lifecycle. Docker volumes that are scoped to a task are provisioned automatically when the task starts and destroyed when the task stops. Docker volumes that are shared persist after the task stops.</p>
        pub fn set_scope(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.scope = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails`](crate::model::AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails {
            crate::model::AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails {
                autoprovision: self.autoprovision.unwrap_or_default(),
                driver: self.driver,
                driver_opts: self.driver_opts,
                labels: self.labels,
                scope: self.scope,
            }
        }
    }
}
impl AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails`](crate::model::AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails)
    pub fn builder(
    ) -> crate::model::aws_ecs_task_definition_volumes_docker_volume_configuration_details::Builder
    {
        crate::model::aws_ecs_task_definition_volumes_docker_volume_configuration_details::Builder::default()
    }
}

/// <p>The configuration details for the App Mesh proxy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionProxyConfigurationDetails {
    /// <p>The name of the container that will serve as the App Mesh proxy.</p>
    pub container_name: std::option::Option<std::string::String>,
    /// <p>The set of network configuration parameters to provide to the Container Network Interface (CNI) plugin, specified as key-value pairs.</p>
    pub proxy_configuration_properties: std::option::Option<
        std::vec::Vec<
            crate::model::AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails,
        >,
    >,
    /// <p>The proxy type.</p>
    pub r#type: std::option::Option<std::string::String>,
}
impl AwsEcsTaskDefinitionProxyConfigurationDetails {
    /// <p>The name of the container that will serve as the App Mesh proxy.</p>
    pub fn container_name(&self) -> std::option::Option<&str> {
        self.container_name.as_deref()
    }
    /// <p>The set of network configuration parameters to provide to the Container Network Interface (CNI) plugin, specified as key-value pairs.</p>
    pub fn proxy_configuration_properties(&self) -> std::option::Option<& [crate::model::AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails]>{
        self.proxy_configuration_properties.as_deref()
    }
    /// <p>The proxy type.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionProxyConfigurationDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcsTaskDefinitionProxyConfigurationDetails");
        formatter.field("container_name", &self.container_name);
        formatter.field(
            "proxy_configuration_properties",
            &self.proxy_configuration_properties,
        );
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionProxyConfigurationDetails`](crate::model::AwsEcsTaskDefinitionProxyConfigurationDetails)
pub mod aws_ecs_task_definition_proxy_configuration_details {

    /// A builder for [`AwsEcsTaskDefinitionProxyConfigurationDetails`](crate::model::AwsEcsTaskDefinitionProxyConfigurationDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) container_name: std::option::Option<std::string::String>,
        pub(crate) proxy_configuration_properties: std::option::Option<std::vec::Vec<crate::model::AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails>>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the container that will serve as the App Mesh proxy.</p>
        pub fn container_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.container_name = Some(input.into());
            self
        }
        /// <p>The name of the container that will serve as the App Mesh proxy.</p>
        pub fn set_container_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.container_name = input;
            self
        }
        /// Appends an item to `proxy_configuration_properties`.
        ///
        /// To override the contents of this collection use [`set_proxy_configuration_properties`](Self::set_proxy_configuration_properties).
        ///
        /// <p>The set of network configuration parameters to provide to the Container Network Interface (CNI) plugin, specified as key-value pairs.</p>
        pub fn proxy_configuration_properties(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails,
        ) -> Self {
            let mut v = self.proxy_configuration_properties.unwrap_or_default();
            v.push(input);
            self.proxy_configuration_properties = Some(v);
            self
        }
        /// <p>The set of network configuration parameters to provide to the Container Network Interface (CNI) plugin, specified as key-value pairs.</p>
        pub fn set_proxy_configuration_properties(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails>>,
        ) -> Self {
            self.proxy_configuration_properties = input;
            self
        }
        /// <p>The proxy type.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The proxy type.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionProxyConfigurationDetails`](crate::model::AwsEcsTaskDefinitionProxyConfigurationDetails)
        pub fn build(self) -> crate::model::AwsEcsTaskDefinitionProxyConfigurationDetails {
            crate::model::AwsEcsTaskDefinitionProxyConfigurationDetails {
                container_name: self.container_name,
                proxy_configuration_properties: self.proxy_configuration_properties,
                r#type: self.r#type,
            }
        }
    }
}
impl AwsEcsTaskDefinitionProxyConfigurationDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionProxyConfigurationDetails`](crate::model::AwsEcsTaskDefinitionProxyConfigurationDetails)
    pub fn builder() -> crate::model::aws_ecs_task_definition_proxy_configuration_details::Builder {
        crate::model::aws_ecs_task_definition_proxy_configuration_details::Builder::default()
    }
}

/// <p>A network configuration parameter to provide to the Container Network Interface (CNI) plugin.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails {
    /// <p>The name of the property.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The value of the property.</p>
    pub value: std::option::Option<std::string::String>,
}
impl AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails {
    /// <p>The name of the property.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The value of the property.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct(
            "AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails",
        );
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails`](crate::model::AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails)
pub mod aws_ecs_task_definition_proxy_configuration_proxy_configuration_properties_details {

    /// A builder for [`AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails`](crate::model::AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the property.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the property.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The value of the property.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the property.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails`](crate::model::AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails
        {
            crate::model::AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails {
                name: self.name
                ,
                value: self.value
                ,
            }
        }
    }
}
impl AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails`](crate::model::AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails)
    pub fn builder() -> crate::model::aws_ecs_task_definition_proxy_configuration_proxy_configuration_properties_details::Builder{
        crate::model::aws_ecs_task_definition_proxy_configuration_proxy_configuration_properties_details::Builder::default()
    }
}

/// <p>A placement constraint object to use for tasks.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionPlacementConstraintsDetails {
    /// <p>A cluster query language expression to apply to the constraint.</p>
    pub expression: std::option::Option<std::string::String>,
    /// <p>The type of constraint.</p>
    pub r#type: std::option::Option<std::string::String>,
}
impl AwsEcsTaskDefinitionPlacementConstraintsDetails {
    /// <p>A cluster query language expression to apply to the constraint.</p>
    pub fn expression(&self) -> std::option::Option<&str> {
        self.expression.as_deref()
    }
    /// <p>The type of constraint.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionPlacementConstraintsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcsTaskDefinitionPlacementConstraintsDetails");
        formatter.field("expression", &self.expression);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionPlacementConstraintsDetails`](crate::model::AwsEcsTaskDefinitionPlacementConstraintsDetails)
pub mod aws_ecs_task_definition_placement_constraints_details {

    /// A builder for [`AwsEcsTaskDefinitionPlacementConstraintsDetails`](crate::model::AwsEcsTaskDefinitionPlacementConstraintsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) expression: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A cluster query language expression to apply to the constraint.</p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.expression = Some(input.into());
            self
        }
        /// <p>A cluster query language expression to apply to the constraint.</p>
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.expression = input;
            self
        }
        /// <p>The type of constraint.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of constraint.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionPlacementConstraintsDetails`](crate::model::AwsEcsTaskDefinitionPlacementConstraintsDetails)
        pub fn build(self) -> crate::model::AwsEcsTaskDefinitionPlacementConstraintsDetails {
            crate::model::AwsEcsTaskDefinitionPlacementConstraintsDetails {
                expression: self.expression,
                r#type: self.r#type,
            }
        }
    }
}
impl AwsEcsTaskDefinitionPlacementConstraintsDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionPlacementConstraintsDetails`](crate::model::AwsEcsTaskDefinitionPlacementConstraintsDetails)
    pub fn builder() -> crate::model::aws_ecs_task_definition_placement_constraints_details::Builder
    {
        crate::model::aws_ecs_task_definition_placement_constraints_details::Builder::default()
    }
}

/// <p>An Elastic Inference accelerator to use for the containers in the task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionInferenceAcceleratorsDetails {
    /// <p>The Elastic Inference accelerator device name.</p>
    pub device_name: std::option::Option<std::string::String>,
    /// <p>The Elastic Inference accelerator type to use.</p>
    pub device_type: std::option::Option<std::string::String>,
}
impl AwsEcsTaskDefinitionInferenceAcceleratorsDetails {
    /// <p>The Elastic Inference accelerator device name.</p>
    pub fn device_name(&self) -> std::option::Option<&str> {
        self.device_name.as_deref()
    }
    /// <p>The Elastic Inference accelerator type to use.</p>
    pub fn device_type(&self) -> std::option::Option<&str> {
        self.device_type.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionInferenceAcceleratorsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcsTaskDefinitionInferenceAcceleratorsDetails");
        formatter.field("device_name", &self.device_name);
        formatter.field("device_type", &self.device_type);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionInferenceAcceleratorsDetails`](crate::model::AwsEcsTaskDefinitionInferenceAcceleratorsDetails)
pub mod aws_ecs_task_definition_inference_accelerators_details {

    /// A builder for [`AwsEcsTaskDefinitionInferenceAcceleratorsDetails`](crate::model::AwsEcsTaskDefinitionInferenceAcceleratorsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_name: std::option::Option<std::string::String>,
        pub(crate) device_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Elastic Inference accelerator device name.</p>
        pub fn device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_name = Some(input.into());
            self
        }
        /// <p>The Elastic Inference accelerator device name.</p>
        pub fn set_device_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_name = input;
            self
        }
        /// <p>The Elastic Inference accelerator type to use.</p>
        pub fn device_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_type = Some(input.into());
            self
        }
        /// <p>The Elastic Inference accelerator type to use.</p>
        pub fn set_device_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionInferenceAcceleratorsDetails`](crate::model::AwsEcsTaskDefinitionInferenceAcceleratorsDetails)
        pub fn build(self) -> crate::model::AwsEcsTaskDefinitionInferenceAcceleratorsDetails {
            crate::model::AwsEcsTaskDefinitionInferenceAcceleratorsDetails {
                device_name: self.device_name,
                device_type: self.device_type,
            }
        }
    }
}
impl AwsEcsTaskDefinitionInferenceAcceleratorsDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionInferenceAcceleratorsDetails`](crate::model::AwsEcsTaskDefinitionInferenceAcceleratorsDetails)
    pub fn builder() -> crate::model::aws_ecs_task_definition_inference_accelerators_details::Builder
    {
        crate::model::aws_ecs_task_definition_inference_accelerators_details::Builder::default()
    }
}

/// <p>A container definition that describes a container in the task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionContainerDefinitionsDetails {
    /// <p>The command that is passed to the container.</p>
    pub command: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The number of CPU units reserved for the container.</p>
    pub cpu: i32,
    /// <p>The dependencies that are defined for container startup and shutdown.</p>
    pub depends_on: std::option::Option<
        std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails>,
    >,
    /// <p>Whether to disable networking within the container.</p>
    pub disable_networking: bool,
    /// <p>A list of DNS search domains that are presented to the container.</p>
    pub dns_search_domains: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of DNS servers that are presented to the container.</p>
    pub dns_servers: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A key-value map of labels to add to the container.</p>
    pub docker_labels:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A list of strings to provide custom labels for SELinux and AppArmor multi-level security systems.</p>
    pub docker_security_options: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The entry point that is passed to the container.</p>
    pub entry_point: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The environment variables to pass to a container.</p>
    pub environment: std::option::Option<
        std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails>,
    >,
    /// <p>A list of files containing the environment variables to pass to a container.</p>
    pub environment_files: std::option::Option<
        std::vec::Vec<
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails,
        >,
    >,
    /// <p>Whether the container is essential. All tasks must have at least one essential container.</p>
    pub essential: bool,
    /// <p>A list of hostnames and IP address mappings to append to the <b>/etc/hosts</b> file on the container.</p>
    pub extra_hosts: std::option::Option<
        std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails>,
    >,
    /// <p>The FireLens configuration for the container. Specifies and configures a log router for container logs.</p>
    pub firelens_configuration: std::option::Option<
        crate::model::AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails,
    >,
    /// <p>The container health check command and associated configuration parameters for the container.</p>
    pub health_check: std::option::Option<
        crate::model::AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails,
    >,
    /// <p>The hostname to use for the container.</p>
    pub hostname: std::option::Option<std::string::String>,
    /// <p>The image used to start the container.</p>
    pub image: std::option::Option<std::string::String>,
    /// <p>If set to true, then containerized applications can be deployed that require <code>stdin</code> or a <code>tty</code> to be allocated.</p>
    pub interactive: bool,
    /// <p>A list of links for the container in the form <code> <i>container_name</i>:<i>alias</i> </code>. Allows containers to communicate with each other without the need for port mappings.</p>
    pub links: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Linux-specific modifications that are applied to the container, such as Linux kernel capabilities.</p>
    pub linux_parameters: std::option::Option<
        crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails,
    >,
    /// <p>The log configuration specification for the container.</p>
    pub log_configuration: std::option::Option<
        crate::model::AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails,
    >,
    /// <p>The amount (in MiB) of memory to present to the container. If the container attempts to exceed the memory specified here, the container is shut down. The total amount of memory reserved for all containers within a task must be lower than the task memory value, if one is specified.</p>
    pub memory: i32,
    /// <p>The soft limit (in MiB) of memory to reserve for the container.</p>
    pub memory_reservation: i32,
    /// <p>The mount points for the data volumes in the container.</p>
    pub mount_points: std::option::Option<
        std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails>,
    >,
    /// <p>The name of the container.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The list of port mappings for the container.</p>
    pub port_mappings: std::option::Option<
        std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails>,
    >,
    /// <p>Whether the container is given elevated privileges on the host container instance. The elevated privileges are similar to the root user.</p>
    pub privileged: bool,
    /// <p>Whether to allocate a TTY to the container.</p>
    pub pseudo_terminal: bool,
    /// <p>Whether the container is given read-only access to its root file system.</p>
    pub readonly_root_filesystem: bool,
    /// <p>The private repository authentication credentials to use.</p>
    pub repository_credentials: std::option::Option<
        crate::model::AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails,
    >,
    /// <p>The type and amount of a resource to assign to a container. The only supported resource is a GPU.</p>
    pub resource_requirements: std::option::Option<
        std::vec::Vec<
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails,
        >,
    >,
    /// <p>The secrets to pass to the container.</p>
    pub secrets: std::option::Option<
        std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails>,
    >,
    /// <p>The number of seconds to wait before giving up on resolving dependencies for a container. </p>
    pub start_timeout: i32,
    /// <p>The number of seconds to wait before the container is stopped if it doesn't shut down normally on its own.</p>
    pub stop_timeout: i32,
    /// <p>A list of namespaced kernel parameters to set in the container.</p>
    pub system_controls: std::option::Option<
        std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails>,
    >,
    /// <p>A list of ulimits to set in the container. </p>
    pub ulimits: std::option::Option<
        std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails>,
    >,
    /// <p>The user to use inside the container.</p>
    /// <p>The value can use one of the following formats.</p>
    /// <ul>
    /// <li> <p> <code> <i>user</i> </code> </p> </li>
    /// <li> <p> <code> <i>user</i> </code>:<code> <i>group</i> </code> </p> </li>
    /// <li> <p> <code> <i>uid</i> </code> </p> </li>
    /// <li> <p> <code> <i>uid</i> </code>:<code> <i>gid</i> </code> </p> </li>
    /// <li> <p> <code> <i>user</i> </code>:<code> <i>gid</i> </code> </p> </li>
    /// <li> <p> <code> <i>uid</i> </code>:<code> <i>group</i> </code> </p> </li>
    /// </ul>
    pub user: std::option::Option<std::string::String>,
    /// <p>Data volumes to mount from another container.</p>
    pub volumes_from: std::option::Option<
        std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails>,
    >,
    /// <p>The working directory in which to run commands inside the container.</p>
    pub working_directory: std::option::Option<std::string::String>,
}
impl AwsEcsTaskDefinitionContainerDefinitionsDetails {
    /// <p>The command that is passed to the container.</p>
    pub fn command(&self) -> std::option::Option<&[std::string::String]> {
        self.command.as_deref()
    }
    /// <p>The number of CPU units reserved for the container.</p>
    pub fn cpu(&self) -> i32 {
        self.cpu
    }
    /// <p>The dependencies that are defined for container startup and shutdown.</p>
    pub fn depends_on(
        &self,
    ) -> std::option::Option<
        &[crate::model::AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails],
    > {
        self.depends_on.as_deref()
    }
    /// <p>Whether to disable networking within the container.</p>
    pub fn disable_networking(&self) -> bool {
        self.disable_networking
    }
    /// <p>A list of DNS search domains that are presented to the container.</p>
    pub fn dns_search_domains(&self) -> std::option::Option<&[std::string::String]> {
        self.dns_search_domains.as_deref()
    }
    /// <p>A list of DNS servers that are presented to the container.</p>
    pub fn dns_servers(&self) -> std::option::Option<&[std::string::String]> {
        self.dns_servers.as_deref()
    }
    /// <p>A key-value map of labels to add to the container.</p>
    pub fn docker_labels(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.docker_labels.as_ref()
    }
    /// <p>A list of strings to provide custom labels for SELinux and AppArmor multi-level security systems.</p>
    pub fn docker_security_options(&self) -> std::option::Option<&[std::string::String]> {
        self.docker_security_options.as_deref()
    }
    /// <p>The entry point that is passed to the container.</p>
    pub fn entry_point(&self) -> std::option::Option<&[std::string::String]> {
        self.entry_point.as_deref()
    }
    /// <p>The environment variables to pass to a container.</p>
    pub fn environment(
        &self,
    ) -> std::option::Option<
        &[crate::model::AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails],
    > {
        self.environment.as_deref()
    }
    /// <p>A list of files containing the environment variables to pass to a container.</p>
    pub fn environment_files(
        &self,
    ) -> std::option::Option<
        &[crate::model::AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails],
    > {
        self.environment_files.as_deref()
    }
    /// <p>Whether the container is essential. All tasks must have at least one essential container.</p>
    pub fn essential(&self) -> bool {
        self.essential
    }
    /// <p>A list of hostnames and IP address mappings to append to the <b>/etc/hosts</b> file on the container.</p>
    pub fn extra_hosts(
        &self,
    ) -> std::option::Option<
        &[crate::model::AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails],
    > {
        self.extra_hosts.as_deref()
    }
    /// <p>The FireLens configuration for the container. Specifies and configures a log router for container logs.</p>
    pub fn firelens_configuration(
        &self,
    ) -> std::option::Option<
        &crate::model::AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails,
    > {
        self.firelens_configuration.as_ref()
    }
    /// <p>The container health check command and associated configuration parameters for the container.</p>
    pub fn health_check(
        &self,
    ) -> std::option::Option<
        &crate::model::AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails,
    > {
        self.health_check.as_ref()
    }
    /// <p>The hostname to use for the container.</p>
    pub fn hostname(&self) -> std::option::Option<&str> {
        self.hostname.as_deref()
    }
    /// <p>The image used to start the container.</p>
    pub fn image(&self) -> std::option::Option<&str> {
        self.image.as_deref()
    }
    /// <p>If set to true, then containerized applications can be deployed that require <code>stdin</code> or a <code>tty</code> to be allocated.</p>
    pub fn interactive(&self) -> bool {
        self.interactive
    }
    /// <p>A list of links for the container in the form <code> <i>container_name</i>:<i>alias</i> </code>. Allows containers to communicate with each other without the need for port mappings.</p>
    pub fn links(&self) -> std::option::Option<&[std::string::String]> {
        self.links.as_deref()
    }
    /// <p>Linux-specific modifications that are applied to the container, such as Linux kernel capabilities.</p>
    pub fn linux_parameters(
        &self,
    ) -> std::option::Option<
        &crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails,
    > {
        self.linux_parameters.as_ref()
    }
    /// <p>The log configuration specification for the container.</p>
    pub fn log_configuration(
        &self,
    ) -> std::option::Option<
        &crate::model::AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails,
    > {
        self.log_configuration.as_ref()
    }
    /// <p>The amount (in MiB) of memory to present to the container. If the container attempts to exceed the memory specified here, the container is shut down. The total amount of memory reserved for all containers within a task must be lower than the task memory value, if one is specified.</p>
    pub fn memory(&self) -> i32 {
        self.memory
    }
    /// <p>The soft limit (in MiB) of memory to reserve for the container.</p>
    pub fn memory_reservation(&self) -> i32 {
        self.memory_reservation
    }
    /// <p>The mount points for the data volumes in the container.</p>
    pub fn mount_points(
        &self,
    ) -> std::option::Option<
        &[crate::model::AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails],
    > {
        self.mount_points.as_deref()
    }
    /// <p>The name of the container.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The list of port mappings for the container.</p>
    pub fn port_mappings(
        &self,
    ) -> std::option::Option<
        &[crate::model::AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails],
    > {
        self.port_mappings.as_deref()
    }
    /// <p>Whether the container is given elevated privileges on the host container instance. The elevated privileges are similar to the root user.</p>
    pub fn privileged(&self) -> bool {
        self.privileged
    }
    /// <p>Whether to allocate a TTY to the container.</p>
    pub fn pseudo_terminal(&self) -> bool {
        self.pseudo_terminal
    }
    /// <p>Whether the container is given read-only access to its root file system.</p>
    pub fn readonly_root_filesystem(&self) -> bool {
        self.readonly_root_filesystem
    }
    /// <p>The private repository authentication credentials to use.</p>
    pub fn repository_credentials(
        &self,
    ) -> std::option::Option<
        &crate::model::AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails,
    > {
        self.repository_credentials.as_ref()
    }
    /// <p>The type and amount of a resource to assign to a container. The only supported resource is a GPU.</p>
    pub fn resource_requirements(
        &self,
    ) -> std::option::Option<
        &[crate::model::AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails],
    > {
        self.resource_requirements.as_deref()
    }
    /// <p>The secrets to pass to the container.</p>
    pub fn secrets(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails]>
    {
        self.secrets.as_deref()
    }
    /// <p>The number of seconds to wait before giving up on resolving dependencies for a container. </p>
    pub fn start_timeout(&self) -> i32 {
        self.start_timeout
    }
    /// <p>The number of seconds to wait before the container is stopped if it doesn't shut down normally on its own.</p>
    pub fn stop_timeout(&self) -> i32 {
        self.stop_timeout
    }
    /// <p>A list of namespaced kernel parameters to set in the container.</p>
    pub fn system_controls(
        &self,
    ) -> std::option::Option<
        &[crate::model::AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails],
    > {
        self.system_controls.as_deref()
    }
    /// <p>A list of ulimits to set in the container. </p>
    pub fn ulimits(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails]>
    {
        self.ulimits.as_deref()
    }
    /// <p>The user to use inside the container.</p>
    /// <p>The value can use one of the following formats.</p>
    /// <ul>
    /// <li> <p> <code> <i>user</i> </code> </p> </li>
    /// <li> <p> <code> <i>user</i> </code>:<code> <i>group</i> </code> </p> </li>
    /// <li> <p> <code> <i>uid</i> </code> </p> </li>
    /// <li> <p> <code> <i>uid</i> </code>:<code> <i>gid</i> </code> </p> </li>
    /// <li> <p> <code> <i>user</i> </code>:<code> <i>gid</i> </code> </p> </li>
    /// <li> <p> <code> <i>uid</i> </code>:<code> <i>group</i> </code> </p> </li>
    /// </ul>
    pub fn user(&self) -> std::option::Option<&str> {
        self.user.as_deref()
    }
    /// <p>Data volumes to mount from another container.</p>
    pub fn volumes_from(
        &self,
    ) -> std::option::Option<
        &[crate::model::AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails],
    > {
        self.volumes_from.as_deref()
    }
    /// <p>The working directory in which to run commands inside the container.</p>
    pub fn working_directory(&self) -> std::option::Option<&str> {
        self.working_directory.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionContainerDefinitionsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcsTaskDefinitionContainerDefinitionsDetails");
        formatter.field("command", &self.command);
        formatter.field("cpu", &self.cpu);
        formatter.field("depends_on", &self.depends_on);
        formatter.field("disable_networking", &self.disable_networking);
        formatter.field("dns_search_domains", &self.dns_search_domains);
        formatter.field("dns_servers", &self.dns_servers);
        formatter.field("docker_labels", &self.docker_labels);
        formatter.field("docker_security_options", &self.docker_security_options);
        formatter.field("entry_point", &self.entry_point);
        formatter.field("environment", &self.environment);
        formatter.field("environment_files", &self.environment_files);
        formatter.field("essential", &self.essential);
        formatter.field("extra_hosts", &self.extra_hosts);
        formatter.field("firelens_configuration", &self.firelens_configuration);
        formatter.field("health_check", &self.health_check);
        formatter.field("hostname", &self.hostname);
        formatter.field("image", &self.image);
        formatter.field("interactive", &self.interactive);
        formatter.field("links", &self.links);
        formatter.field("linux_parameters", &self.linux_parameters);
        formatter.field("log_configuration", &self.log_configuration);
        formatter.field("memory", &self.memory);
        formatter.field("memory_reservation", &self.memory_reservation);
        formatter.field("mount_points", &self.mount_points);
        formatter.field("name", &self.name);
        formatter.field("port_mappings", &self.port_mappings);
        formatter.field("privileged", &self.privileged);
        formatter.field("pseudo_terminal", &self.pseudo_terminal);
        formatter.field("readonly_root_filesystem", &self.readonly_root_filesystem);
        formatter.field("repository_credentials", &self.repository_credentials);
        formatter.field("resource_requirements", &self.resource_requirements);
        formatter.field("secrets", &self.secrets);
        formatter.field("start_timeout", &self.start_timeout);
        formatter.field("stop_timeout", &self.stop_timeout);
        formatter.field("system_controls", &self.system_controls);
        formatter.field("ulimits", &self.ulimits);
        formatter.field("user", &self.user);
        formatter.field("volumes_from", &self.volumes_from);
        formatter.field("working_directory", &self.working_directory);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionContainerDefinitionsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsDetails)
pub mod aws_ecs_task_definition_container_definitions_details {

    /// A builder for [`AwsEcsTaskDefinitionContainerDefinitionsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) command: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) cpu: std::option::Option<i32>,
        pub(crate) depends_on: std::option::Option<
            std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails>,
        >,
        pub(crate) disable_networking: std::option::Option<bool>,
        pub(crate) dns_search_domains: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) dns_servers: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) docker_labels: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) docker_security_options: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) entry_point: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) environment: std::option::Option<
            std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails>,
        >,
        pub(crate) environment_files: std::option::Option<
            std::vec::Vec<
                crate::model::AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails,
            >,
        >,
        pub(crate) essential: std::option::Option<bool>,
        pub(crate) extra_hosts: std::option::Option<
            std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails>,
        >,
        pub(crate) firelens_configuration: std::option::Option<
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails,
        >,
        pub(crate) health_check: std::option::Option<
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails,
        >,
        pub(crate) hostname: std::option::Option<std::string::String>,
        pub(crate) image: std::option::Option<std::string::String>,
        pub(crate) interactive: std::option::Option<bool>,
        pub(crate) links: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) linux_parameters: std::option::Option<
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails,
        >,
        pub(crate) log_configuration: std::option::Option<
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails,
        >,
        pub(crate) memory: std::option::Option<i32>,
        pub(crate) memory_reservation: std::option::Option<i32>,
        pub(crate) mount_points: std::option::Option<
            std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails>,
        >,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) port_mappings: std::option::Option<
            std::vec::Vec<
                crate::model::AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails,
            >,
        >,
        pub(crate) privileged: std::option::Option<bool>,
        pub(crate) pseudo_terminal: std::option::Option<bool>,
        pub(crate) readonly_root_filesystem: std::option::Option<bool>,
        pub(crate) repository_credentials: std::option::Option<
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails,
        >,
        pub(crate) resource_requirements: std::option::Option<
            std::vec::Vec<
                crate::model::AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails,
            >,
        >,
        pub(crate) secrets: std::option::Option<
            std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails>,
        >,
        pub(crate) start_timeout: std::option::Option<i32>,
        pub(crate) stop_timeout: std::option::Option<i32>,
        pub(crate) system_controls: std::option::Option<
            std::vec::Vec<
                crate::model::AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails,
            >,
        >,
        pub(crate) ulimits: std::option::Option<
            std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails>,
        >,
        pub(crate) user: std::option::Option<std::string::String>,
        pub(crate) volumes_from: std::option::Option<
            std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails>,
        >,
        pub(crate) working_directory: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `command`.
        ///
        /// To override the contents of this collection use [`set_command`](Self::set_command).
        ///
        /// <p>The command that is passed to the container.</p>
        pub fn command(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.command.unwrap_or_default();
            v.push(input.into());
            self.command = Some(v);
            self
        }
        /// <p>The command that is passed to the container.</p>
        pub fn set_command(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.command = input;
            self
        }
        /// <p>The number of CPU units reserved for the container.</p>
        pub fn cpu(mut self, input: i32) -> Self {
            self.cpu = Some(input);
            self
        }
        /// <p>The number of CPU units reserved for the container.</p>
        pub fn set_cpu(mut self, input: std::option::Option<i32>) -> Self {
            self.cpu = input;
            self
        }
        /// Appends an item to `depends_on`.
        ///
        /// To override the contents of this collection use [`set_depends_on`](Self::set_depends_on).
        ///
        /// <p>The dependencies that are defined for container startup and shutdown.</p>
        pub fn depends_on(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails,
        ) -> Self {
            let mut v = self.depends_on.unwrap_or_default();
            v.push(input);
            self.depends_on = Some(v);
            self
        }
        /// <p>The dependencies that are defined for container startup and shutdown.</p>
        pub fn set_depends_on(
            mut self,
            input: std::option::Option<
                std::vec::Vec<
                    crate::model::AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails,
                >,
            >,
        ) -> Self {
            self.depends_on = input;
            self
        }
        /// <p>Whether to disable networking within the container.</p>
        pub fn disable_networking(mut self, input: bool) -> Self {
            self.disable_networking = Some(input);
            self
        }
        /// <p>Whether to disable networking within the container.</p>
        pub fn set_disable_networking(mut self, input: std::option::Option<bool>) -> Self {
            self.disable_networking = input;
            self
        }
        /// Appends an item to `dns_search_domains`.
        ///
        /// To override the contents of this collection use [`set_dns_search_domains`](Self::set_dns_search_domains).
        ///
        /// <p>A list of DNS search domains that are presented to the container.</p>
        pub fn dns_search_domains(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.dns_search_domains.unwrap_or_default();
            v.push(input.into());
            self.dns_search_domains = Some(v);
            self
        }
        /// <p>A list of DNS search domains that are presented to the container.</p>
        pub fn set_dns_search_domains(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.dns_search_domains = input;
            self
        }
        /// Appends an item to `dns_servers`.
        ///
        /// To override the contents of this collection use [`set_dns_servers`](Self::set_dns_servers).
        ///
        /// <p>A list of DNS servers that are presented to the container.</p>
        pub fn dns_servers(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.dns_servers.unwrap_or_default();
            v.push(input.into());
            self.dns_servers = Some(v);
            self
        }
        /// <p>A list of DNS servers that are presented to the container.</p>
        pub fn set_dns_servers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.dns_servers = input;
            self
        }
        /// Adds a key-value pair to `docker_labels`.
        ///
        /// To override the contents of this collection use [`set_docker_labels`](Self::set_docker_labels).
        ///
        /// <p>A key-value map of labels to add to the container.</p>
        pub fn docker_labels(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.docker_labels.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.docker_labels = Some(hash_map);
            self
        }
        /// <p>A key-value map of labels to add to the container.</p>
        pub fn set_docker_labels(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.docker_labels = input;
            self
        }
        /// Appends an item to `docker_security_options`.
        ///
        /// To override the contents of this collection use [`set_docker_security_options`](Self::set_docker_security_options).
        ///
        /// <p>A list of strings to provide custom labels for SELinux and AppArmor multi-level security systems.</p>
        pub fn docker_security_options(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.docker_security_options.unwrap_or_default();
            v.push(input.into());
            self.docker_security_options = Some(v);
            self
        }
        /// <p>A list of strings to provide custom labels for SELinux and AppArmor multi-level security systems.</p>
        pub fn set_docker_security_options(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.docker_security_options = input;
            self
        }
        /// Appends an item to `entry_point`.
        ///
        /// To override the contents of this collection use [`set_entry_point`](Self::set_entry_point).
        ///
        /// <p>The entry point that is passed to the container.</p>
        pub fn entry_point(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.entry_point.unwrap_or_default();
            v.push(input.into());
            self.entry_point = Some(v);
            self
        }
        /// <p>The entry point that is passed to the container.</p>
        pub fn set_entry_point(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.entry_point = input;
            self
        }
        /// Appends an item to `environment`.
        ///
        /// To override the contents of this collection use [`set_environment`](Self::set_environment).
        ///
        /// <p>The environment variables to pass to a container.</p>
        pub fn environment(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails,
        ) -> Self {
            let mut v = self.environment.unwrap_or_default();
            v.push(input);
            self.environment = Some(v);
            self
        }
        /// <p>The environment variables to pass to a container.</p>
        pub fn set_environment(
            mut self,
            input: std::option::Option<
                std::vec::Vec<
                    crate::model::AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails,
                >,
            >,
        ) -> Self {
            self.environment = input;
            self
        }
        /// Appends an item to `environment_files`.
        ///
        /// To override the contents of this collection use [`set_environment_files`](Self::set_environment_files).
        ///
        /// <p>A list of files containing the environment variables to pass to a container.</p>
        pub fn environment_files(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails,
        ) -> Self {
            let mut v = self.environment_files.unwrap_or_default();
            v.push(input);
            self.environment_files = Some(v);
            self
        }
        /// <p>A list of files containing the environment variables to pass to a container.</p>
        pub fn set_environment_files(
            mut self,
            input: std::option::Option<
                std::vec::Vec<
                    crate::model::AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails,
                >,
            >,
        ) -> Self {
            self.environment_files = input;
            self
        }
        /// <p>Whether the container is essential. All tasks must have at least one essential container.</p>
        pub fn essential(mut self, input: bool) -> Self {
            self.essential = Some(input);
            self
        }
        /// <p>Whether the container is essential. All tasks must have at least one essential container.</p>
        pub fn set_essential(mut self, input: std::option::Option<bool>) -> Self {
            self.essential = input;
            self
        }
        /// Appends an item to `extra_hosts`.
        ///
        /// To override the contents of this collection use [`set_extra_hosts`](Self::set_extra_hosts).
        ///
        /// <p>A list of hostnames and IP address mappings to append to the <b>/etc/hosts</b> file on the container.</p>
        pub fn extra_hosts(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails,
        ) -> Self {
            let mut v = self.extra_hosts.unwrap_or_default();
            v.push(input);
            self.extra_hosts = Some(v);
            self
        }
        /// <p>A list of hostnames and IP address mappings to append to the <b>/etc/hosts</b> file on the container.</p>
        pub fn set_extra_hosts(
            mut self,
            input: std::option::Option<
                std::vec::Vec<
                    crate::model::AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails,
                >,
            >,
        ) -> Self {
            self.extra_hosts = input;
            self
        }
        /// <p>The FireLens configuration for the container. Specifies and configures a log router for container logs.</p>
        pub fn firelens_configuration(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails,
        ) -> Self {
            self.firelens_configuration = Some(input);
            self
        }
        /// <p>The FireLens configuration for the container. Specifies and configures a log router for container logs.</p>
        pub fn set_firelens_configuration(
            mut self,
            input: std::option::Option<
                crate::model::AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails,
            >,
        ) -> Self {
            self.firelens_configuration = input;
            self
        }
        /// <p>The container health check command and associated configuration parameters for the container.</p>
        pub fn health_check(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails,
        ) -> Self {
            self.health_check = Some(input);
            self
        }
        /// <p>The container health check command and associated configuration parameters for the container.</p>
        pub fn set_health_check(
            mut self,
            input: std::option::Option<
                crate::model::AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails,
            >,
        ) -> Self {
            self.health_check = input;
            self
        }
        /// <p>The hostname to use for the container.</p>
        pub fn hostname(mut self, input: impl Into<std::string::String>) -> Self {
            self.hostname = Some(input.into());
            self
        }
        /// <p>The hostname to use for the container.</p>
        pub fn set_hostname(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hostname = input;
            self
        }
        /// <p>The image used to start the container.</p>
        pub fn image(mut self, input: impl Into<std::string::String>) -> Self {
            self.image = Some(input.into());
            self
        }
        /// <p>The image used to start the container.</p>
        pub fn set_image(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image = input;
            self
        }
        /// <p>If set to true, then containerized applications can be deployed that require <code>stdin</code> or a <code>tty</code> to be allocated.</p>
        pub fn interactive(mut self, input: bool) -> Self {
            self.interactive = Some(input);
            self
        }
        /// <p>If set to true, then containerized applications can be deployed that require <code>stdin</code> or a <code>tty</code> to be allocated.</p>
        pub fn set_interactive(mut self, input: std::option::Option<bool>) -> Self {
            self.interactive = input;
            self
        }
        /// Appends an item to `links`.
        ///
        /// To override the contents of this collection use [`set_links`](Self::set_links).
        ///
        /// <p>A list of links for the container in the form <code> <i>container_name</i>:<i>alias</i> </code>. Allows containers to communicate with each other without the need for port mappings.</p>
        pub fn links(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.links.unwrap_or_default();
            v.push(input.into());
            self.links = Some(v);
            self
        }
        /// <p>A list of links for the container in the form <code> <i>container_name</i>:<i>alias</i> </code>. Allows containers to communicate with each other without the need for port mappings.</p>
        pub fn set_links(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.links = input;
            self
        }
        /// <p>Linux-specific modifications that are applied to the container, such as Linux kernel capabilities.</p>
        pub fn linux_parameters(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails,
        ) -> Self {
            self.linux_parameters = Some(input);
            self
        }
        /// <p>Linux-specific modifications that are applied to the container, such as Linux kernel capabilities.</p>
        pub fn set_linux_parameters(
            mut self,
            input: std::option::Option<
                crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails,
            >,
        ) -> Self {
            self.linux_parameters = input;
            self
        }
        /// <p>The log configuration specification for the container.</p>
        pub fn log_configuration(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails,
        ) -> Self {
            self.log_configuration = Some(input);
            self
        }
        /// <p>The log configuration specification for the container.</p>
        pub fn set_log_configuration(
            mut self,
            input: std::option::Option<
                crate::model::AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails,
            >,
        ) -> Self {
            self.log_configuration = input;
            self
        }
        /// <p>The amount (in MiB) of memory to present to the container. If the container attempts to exceed the memory specified here, the container is shut down. The total amount of memory reserved for all containers within a task must be lower than the task memory value, if one is specified.</p>
        pub fn memory(mut self, input: i32) -> Self {
            self.memory = Some(input);
            self
        }
        /// <p>The amount (in MiB) of memory to present to the container. If the container attempts to exceed the memory specified here, the container is shut down. The total amount of memory reserved for all containers within a task must be lower than the task memory value, if one is specified.</p>
        pub fn set_memory(mut self, input: std::option::Option<i32>) -> Self {
            self.memory = input;
            self
        }
        /// <p>The soft limit (in MiB) of memory to reserve for the container.</p>
        pub fn memory_reservation(mut self, input: i32) -> Self {
            self.memory_reservation = Some(input);
            self
        }
        /// <p>The soft limit (in MiB) of memory to reserve for the container.</p>
        pub fn set_memory_reservation(mut self, input: std::option::Option<i32>) -> Self {
            self.memory_reservation = input;
            self
        }
        /// Appends an item to `mount_points`.
        ///
        /// To override the contents of this collection use [`set_mount_points`](Self::set_mount_points).
        ///
        /// <p>The mount points for the data volumes in the container.</p>
        pub fn mount_points(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails,
        ) -> Self {
            let mut v = self.mount_points.unwrap_or_default();
            v.push(input);
            self.mount_points = Some(v);
            self
        }
        /// <p>The mount points for the data volumes in the container.</p>
        pub fn set_mount_points(
            mut self,
            input: std::option::Option<
                std::vec::Vec<
                    crate::model::AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails,
                >,
            >,
        ) -> Self {
            self.mount_points = input;
            self
        }
        /// <p>The name of the container.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the container.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `port_mappings`.
        ///
        /// To override the contents of this collection use [`set_port_mappings`](Self::set_port_mappings).
        ///
        /// <p>The list of port mappings for the container.</p>
        pub fn port_mappings(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails,
        ) -> Self {
            let mut v = self.port_mappings.unwrap_or_default();
            v.push(input);
            self.port_mappings = Some(v);
            self
        }
        /// <p>The list of port mappings for the container.</p>
        pub fn set_port_mappings(
            mut self,
            input: std::option::Option<
                std::vec::Vec<
                    crate::model::AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails,
                >,
            >,
        ) -> Self {
            self.port_mappings = input;
            self
        }
        /// <p>Whether the container is given elevated privileges on the host container instance. The elevated privileges are similar to the root user.</p>
        pub fn privileged(mut self, input: bool) -> Self {
            self.privileged = Some(input);
            self
        }
        /// <p>Whether the container is given elevated privileges on the host container instance. The elevated privileges are similar to the root user.</p>
        pub fn set_privileged(mut self, input: std::option::Option<bool>) -> Self {
            self.privileged = input;
            self
        }
        /// <p>Whether to allocate a TTY to the container.</p>
        pub fn pseudo_terminal(mut self, input: bool) -> Self {
            self.pseudo_terminal = Some(input);
            self
        }
        /// <p>Whether to allocate a TTY to the container.</p>
        pub fn set_pseudo_terminal(mut self, input: std::option::Option<bool>) -> Self {
            self.pseudo_terminal = input;
            self
        }
        /// <p>Whether the container is given read-only access to its root file system.</p>
        pub fn readonly_root_filesystem(mut self, input: bool) -> Self {
            self.readonly_root_filesystem = Some(input);
            self
        }
        /// <p>Whether the container is given read-only access to its root file system.</p>
        pub fn set_readonly_root_filesystem(mut self, input: std::option::Option<bool>) -> Self {
            self.readonly_root_filesystem = input;
            self
        }
        /// <p>The private repository authentication credentials to use.</p>
        pub fn repository_credentials(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails,
        ) -> Self {
            self.repository_credentials = Some(input);
            self
        }
        /// <p>The private repository authentication credentials to use.</p>
        pub fn set_repository_credentials(
            mut self,
            input: std::option::Option<
                crate::model::AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails,
            >,
        ) -> Self {
            self.repository_credentials = input;
            self
        }
        /// Appends an item to `resource_requirements`.
        ///
        /// To override the contents of this collection use [`set_resource_requirements`](Self::set_resource_requirements).
        ///
        /// <p>The type and amount of a resource to assign to a container. The only supported resource is a GPU.</p>
        pub fn resource_requirements(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails,
        ) -> Self {
            let mut v = self.resource_requirements.unwrap_or_default();
            v.push(input);
            self.resource_requirements = Some(v);
            self
        }
        /// <p>The type and amount of a resource to assign to a container. The only supported resource is a GPU.</p>
        pub fn set_resource_requirements(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails>>,
        ) -> Self {
            self.resource_requirements = input;
            self
        }
        /// Appends an item to `secrets`.
        ///
        /// To override the contents of this collection use [`set_secrets`](Self::set_secrets).
        ///
        /// <p>The secrets to pass to the container.</p>
        pub fn secrets(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails,
        ) -> Self {
            let mut v = self.secrets.unwrap_or_default();
            v.push(input);
            self.secrets = Some(v);
            self
        }
        /// <p>The secrets to pass to the container.</p>
        pub fn set_secrets(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails>,
            >,
        ) -> Self {
            self.secrets = input;
            self
        }
        /// <p>The number of seconds to wait before giving up on resolving dependencies for a container. </p>
        pub fn start_timeout(mut self, input: i32) -> Self {
            self.start_timeout = Some(input);
            self
        }
        /// <p>The number of seconds to wait before giving up on resolving dependencies for a container. </p>
        pub fn set_start_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.start_timeout = input;
            self
        }
        /// <p>The number of seconds to wait before the container is stopped if it doesn't shut down normally on its own.</p>
        pub fn stop_timeout(mut self, input: i32) -> Self {
            self.stop_timeout = Some(input);
            self
        }
        /// <p>The number of seconds to wait before the container is stopped if it doesn't shut down normally on its own.</p>
        pub fn set_stop_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.stop_timeout = input;
            self
        }
        /// Appends an item to `system_controls`.
        ///
        /// To override the contents of this collection use [`set_system_controls`](Self::set_system_controls).
        ///
        /// <p>A list of namespaced kernel parameters to set in the container.</p>
        pub fn system_controls(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails,
        ) -> Self {
            let mut v = self.system_controls.unwrap_or_default();
            v.push(input);
            self.system_controls = Some(v);
            self
        }
        /// <p>A list of namespaced kernel parameters to set in the container.</p>
        pub fn set_system_controls(
            mut self,
            input: std::option::Option<
                std::vec::Vec<
                    crate::model::AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails,
                >,
            >,
        ) -> Self {
            self.system_controls = input;
            self
        }
        /// Appends an item to `ulimits`.
        ///
        /// To override the contents of this collection use [`set_ulimits`](Self::set_ulimits).
        ///
        /// <p>A list of ulimits to set in the container. </p>
        pub fn ulimits(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails,
        ) -> Self {
            let mut v = self.ulimits.unwrap_or_default();
            v.push(input);
            self.ulimits = Some(v);
            self
        }
        /// <p>A list of ulimits to set in the container. </p>
        pub fn set_ulimits(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails>,
            >,
        ) -> Self {
            self.ulimits = input;
            self
        }
        /// <p>The user to use inside the container.</p>
        /// <p>The value can use one of the following formats.</p>
        /// <ul>
        /// <li> <p> <code> <i>user</i> </code> </p> </li>
        /// <li> <p> <code> <i>user</i> </code>:<code> <i>group</i> </code> </p> </li>
        /// <li> <p> <code> <i>uid</i> </code> </p> </li>
        /// <li> <p> <code> <i>uid</i> </code>:<code> <i>gid</i> </code> </p> </li>
        /// <li> <p> <code> <i>user</i> </code>:<code> <i>gid</i> </code> </p> </li>
        /// <li> <p> <code> <i>uid</i> </code>:<code> <i>group</i> </code> </p> </li>
        /// </ul>
        pub fn user(mut self, input: impl Into<std::string::String>) -> Self {
            self.user = Some(input.into());
            self
        }
        /// <p>The user to use inside the container.</p>
        /// <p>The value can use one of the following formats.</p>
        /// <ul>
        /// <li> <p> <code> <i>user</i> </code> </p> </li>
        /// <li> <p> <code> <i>user</i> </code>:<code> <i>group</i> </code> </p> </li>
        /// <li> <p> <code> <i>uid</i> </code> </p> </li>
        /// <li> <p> <code> <i>uid</i> </code>:<code> <i>gid</i> </code> </p> </li>
        /// <li> <p> <code> <i>user</i> </code>:<code> <i>gid</i> </code> </p> </li>
        /// <li> <p> <code> <i>uid</i> </code>:<code> <i>group</i> </code> </p> </li>
        /// </ul>
        pub fn set_user(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user = input;
            self
        }
        /// Appends an item to `volumes_from`.
        ///
        /// To override the contents of this collection use [`set_volumes_from`](Self::set_volumes_from).
        ///
        /// <p>Data volumes to mount from another container.</p>
        pub fn volumes_from(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails,
        ) -> Self {
            let mut v = self.volumes_from.unwrap_or_default();
            v.push(input);
            self.volumes_from = Some(v);
            self
        }
        /// <p>Data volumes to mount from another container.</p>
        pub fn set_volumes_from(
            mut self,
            input: std::option::Option<
                std::vec::Vec<
                    crate::model::AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails,
                >,
            >,
        ) -> Self {
            self.volumes_from = input;
            self
        }
        /// <p>The working directory in which to run commands inside the container.</p>
        pub fn working_directory(mut self, input: impl Into<std::string::String>) -> Self {
            self.working_directory = Some(input.into());
            self
        }
        /// <p>The working directory in which to run commands inside the container.</p>
        pub fn set_working_directory(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.working_directory = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionContainerDefinitionsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsDetails)
        pub fn build(self) -> crate::model::AwsEcsTaskDefinitionContainerDefinitionsDetails {
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsDetails {
                command: self.command,
                cpu: self.cpu.unwrap_or_default(),
                depends_on: self.depends_on,
                disable_networking: self.disable_networking.unwrap_or_default(),
                dns_search_domains: self.dns_search_domains,
                dns_servers: self.dns_servers,
                docker_labels: self.docker_labels,
                docker_security_options: self.docker_security_options,
                entry_point: self.entry_point,
                environment: self.environment,
                environment_files: self.environment_files,
                essential: self.essential.unwrap_or_default(),
                extra_hosts: self.extra_hosts,
                firelens_configuration: self.firelens_configuration,
                health_check: self.health_check,
                hostname: self.hostname,
                image: self.image,
                interactive: self.interactive.unwrap_or_default(),
                links: self.links,
                linux_parameters: self.linux_parameters,
                log_configuration: self.log_configuration,
                memory: self.memory.unwrap_or_default(),
                memory_reservation: self.memory_reservation.unwrap_or_default(),
                mount_points: self.mount_points,
                name: self.name,
                port_mappings: self.port_mappings,
                privileged: self.privileged.unwrap_or_default(),
                pseudo_terminal: self.pseudo_terminal.unwrap_or_default(),
                readonly_root_filesystem: self.readonly_root_filesystem.unwrap_or_default(),
                repository_credentials: self.repository_credentials,
                resource_requirements: self.resource_requirements,
                secrets: self.secrets,
                start_timeout: self.start_timeout.unwrap_or_default(),
                stop_timeout: self.stop_timeout.unwrap_or_default(),
                system_controls: self.system_controls,
                ulimits: self.ulimits,
                user: self.user,
                volumes_from: self.volumes_from,
                working_directory: self.working_directory,
            }
        }
    }
}
impl AwsEcsTaskDefinitionContainerDefinitionsDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionContainerDefinitionsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsDetails)
    pub fn builder() -> crate::model::aws_ecs_task_definition_container_definitions_details::Builder
    {
        crate::model::aws_ecs_task_definition_container_definitions_details::Builder::default()
    }
}

/// <p>A data volume to mount from another container.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails {
    /// <p>Whether the container has read-only access to the volume.</p>
    pub read_only: bool,
    /// <p>The name of another container within the same task definition from which to mount volumes.</p>
    pub source_container: std::option::Option<std::string::String>,
}
impl AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails {
    /// <p>Whether the container has read-only access to the volume.</p>
    pub fn read_only(&self) -> bool {
        self.read_only
    }
    /// <p>The name of another container within the same task definition from which to mount volumes.</p>
    pub fn source_container(&self) -> std::option::Option<&str> {
        self.source_container.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails");
        formatter.field("read_only", &self.read_only);
        formatter.field("source_container", &self.source_container);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails)
pub mod aws_ecs_task_definition_container_definitions_volumes_from_details {

    /// A builder for [`AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) read_only: std::option::Option<bool>,
        pub(crate) source_container: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Whether the container has read-only access to the volume.</p>
        pub fn read_only(mut self, input: bool) -> Self {
            self.read_only = Some(input);
            self
        }
        /// <p>Whether the container has read-only access to the volume.</p>
        pub fn set_read_only(mut self, input: std::option::Option<bool>) -> Self {
            self.read_only = input;
            self
        }
        /// <p>The name of another container within the same task definition from which to mount volumes.</p>
        pub fn source_container(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_container = Some(input.into());
            self
        }
        /// <p>The name of another container within the same task definition from which to mount volumes.</p>
        pub fn set_source_container(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_container = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails {
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails {
                read_only: self.read_only.unwrap_or_default(),
                source_container: self.source_container,
            }
        }
    }
}
impl AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails)
    pub fn builder(
    ) -> crate::model::aws_ecs_task_definition_container_definitions_volumes_from_details::Builder
    {
        crate::model::aws_ecs_task_definition_container_definitions_volumes_from_details::Builder::default()
    }
}

/// <p>A ulimit to set in the container.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails {
    /// <p>The hard limit for the ulimit type.</p>
    pub hard_limit: i32,
    /// <p>The type of the ulimit.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The soft limit for the ulimit type.</p>
    pub soft_limit: i32,
}
impl AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails {
    /// <p>The hard limit for the ulimit type.</p>
    pub fn hard_limit(&self) -> i32 {
        self.hard_limit
    }
    /// <p>The type of the ulimit.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The soft limit for the ulimit type.</p>
    pub fn soft_limit(&self) -> i32 {
        self.soft_limit
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails");
        formatter.field("hard_limit", &self.hard_limit);
        formatter.field("name", &self.name);
        formatter.field("soft_limit", &self.soft_limit);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails)
pub mod aws_ecs_task_definition_container_definitions_ulimits_details {

    /// A builder for [`AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hard_limit: std::option::Option<i32>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) soft_limit: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The hard limit for the ulimit type.</p>
        pub fn hard_limit(mut self, input: i32) -> Self {
            self.hard_limit = Some(input);
            self
        }
        /// <p>The hard limit for the ulimit type.</p>
        pub fn set_hard_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.hard_limit = input;
            self
        }
        /// <p>The type of the ulimit.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The type of the ulimit.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The soft limit for the ulimit type.</p>
        pub fn soft_limit(mut self, input: i32) -> Self {
            self.soft_limit = Some(input);
            self
        }
        /// <p>The soft limit for the ulimit type.</p>
        pub fn set_soft_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.soft_limit = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails)
        pub fn build(self) -> crate::model::AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails {
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails {
                hard_limit: self.hard_limit.unwrap_or_default(),
                name: self.name,
                soft_limit: self.soft_limit.unwrap_or_default(),
            }
        }
    }
}
impl AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails)
    pub fn builder(
    ) -> crate::model::aws_ecs_task_definition_container_definitions_ulimits_details::Builder {
        crate::model::aws_ecs_task_definition_container_definitions_ulimits_details::Builder::default()
    }
}

/// <p>A namespaced kernel parameter to set in the container.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails {
    /// <p>The namespaced kernel parameter for which to set a value.</p>
    pub namespace: std::option::Option<std::string::String>,
    /// <p>The value of the parameter.</p>
    pub value: std::option::Option<std::string::String>,
}
impl AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails {
    /// <p>The namespaced kernel parameter for which to set a value.</p>
    pub fn namespace(&self) -> std::option::Option<&str> {
        self.namespace.as_deref()
    }
    /// <p>The value of the parameter.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails");
        formatter.field("namespace", &self.namespace);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails)
pub mod aws_ecs_task_definition_container_definitions_system_controls_details {

    /// A builder for [`AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The namespaced kernel parameter for which to set a value.</p>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>The namespaced kernel parameter for which to set a value.</p>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// <p>The value of the parameter.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the parameter.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails {
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails {
                namespace: self.namespace,
                value: self.value,
            }
        }
    }
}
impl AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails)
    pub fn builder(
    ) -> crate::model::aws_ecs_task_definition_container_definitions_system_controls_details::Builder
    {
        crate::model::aws_ecs_task_definition_container_definitions_system_controls_details::Builder::default()
    }
}

/// <p>A secret to pass to the container.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails {
    /// <p>The name of the secret.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The secret to expose to the container. The value is either the full ARN of the Secrets Manager secret or the full ARN of the parameter in the Systems Manager Parameter Store.</p>
    pub value_from: std::option::Option<std::string::String>,
}
impl AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails {
    /// <p>The name of the secret.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The secret to expose to the container. The value is either the full ARN of the Secrets Manager secret or the full ARN of the parameter in the Systems Manager Parameter Store.</p>
    pub fn value_from(&self) -> std::option::Option<&str> {
        self.value_from.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails");
        formatter.field("name", &self.name);
        formatter.field("value_from", &self.value_from);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails)
pub mod aws_ecs_task_definition_container_definitions_secrets_details {

    /// A builder for [`AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value_from: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the secret.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the secret.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The secret to expose to the container. The value is either the full ARN of the Secrets Manager secret or the full ARN of the parameter in the Systems Manager Parameter Store.</p>
        pub fn value_from(mut self, input: impl Into<std::string::String>) -> Self {
            self.value_from = Some(input.into());
            self
        }
        /// <p>The secret to expose to the container. The value is either the full ARN of the Secrets Manager secret or the full ARN of the parameter in the Systems Manager Parameter Store.</p>
        pub fn set_value_from(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value_from = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails)
        pub fn build(self) -> crate::model::AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails {
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails {
                name: self.name,
                value_from: self.value_from,
            }
        }
    }
}
impl AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails)
    pub fn builder(
    ) -> crate::model::aws_ecs_task_definition_container_definitions_secrets_details::Builder {
        crate::model::aws_ecs_task_definition_container_definitions_secrets_details::Builder::default()
    }
}

/// <p>A resource to assign to a container.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails {
    /// <p>The type of resource to assign to a container.</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The value for the specified resource type.</p>
    /// <p>For <code>GPU</code>, the value is the number of physical GPUs the Amazon ECS container agent reserves for the container.</p>
    /// <p>For <code>InferenceAccelerator</code>, the value should match the <code>DeviceName</code> attribute of an entry in <code>InferenceAccelerators</code>.</p>
    pub value: std::option::Option<std::string::String>,
}
impl AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails {
    /// <p>The type of resource to assign to a container.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The value for the specified resource type.</p>
    /// <p>For <code>GPU</code>, the value is the number of physical GPUs the Amazon ECS container agent reserves for the container.</p>
    /// <p>For <code>InferenceAccelerator</code>, the value should match the <code>DeviceName</code> attribute of an entry in <code>InferenceAccelerators</code>.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails");
        formatter.field("r#type", &self.r#type);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails)
pub mod aws_ecs_task_definition_container_definitions_resource_requirements_details {

    /// A builder for [`AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of resource to assign to a container.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of resource to assign to a container.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The value for the specified resource type.</p>
        /// <p>For <code>GPU</code>, the value is the number of physical GPUs the Amazon ECS container agent reserves for the container.</p>
        /// <p>For <code>InferenceAccelerator</code>, the value should match the <code>DeviceName</code> attribute of an entry in <code>InferenceAccelerators</code>.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value for the specified resource type.</p>
        /// <p>For <code>GPU</code>, the value is the number of physical GPUs the Amazon ECS container agent reserves for the container.</p>
        /// <p>For <code>InferenceAccelerator</code>, the value should match the <code>DeviceName</code> attribute of an entry in <code>InferenceAccelerators</code>.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails
        {
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails {
                r#type: self.r#type,
                value: self.value,
            }
        }
    }
}
impl AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails)
    pub fn builder() -> crate::model::aws_ecs_task_definition_container_definitions_resource_requirements_details::Builder{
        crate::model::aws_ecs_task_definition_container_definitions_resource_requirements_details::Builder::default()
    }
}

/// <p>The private repository authentication credentials to use.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails {
    /// <p>The ARN of the secret that contains the private repository credentials.</p>
    pub credentials_parameter: std::option::Option<std::string::String>,
}
impl AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails {
    /// <p>The ARN of the secret that contains the private repository credentials.</p>
    pub fn credentials_parameter(&self) -> std::option::Option<&str> {
        self.credentials_parameter.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails");
        formatter.field("credentials_parameter", &self.credentials_parameter);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails)
pub mod aws_ecs_task_definition_container_definitions_repository_credentials_details {

    /// A builder for [`AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) credentials_parameter: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the secret that contains the private repository credentials.</p>
        pub fn credentials_parameter(mut self, input: impl Into<std::string::String>) -> Self {
            self.credentials_parameter = Some(input.into());
            self
        }
        /// <p>The ARN of the secret that contains the private repository credentials.</p>
        pub fn set_credentials_parameter(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.credentials_parameter = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails
        {
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails {
                credentials_parameter: self.credentials_parameter,
            }
        }
    }
}
impl AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails)
    pub fn builder() -> crate::model::aws_ecs_task_definition_container_definitions_repository_credentials_details::Builder{
        crate::model::aws_ecs_task_definition_container_definitions_repository_credentials_details::Builder::default()
    }
}

/// <p>A port mapping for the container.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails {
    /// <p>The port number on the container that is bound to the user-specified or automatically assigned host port.</p>
    pub container_port: i32,
    /// <p>The port number on the container instance to reserve for the container.</p>
    pub host_port: i32,
    /// <p>The protocol used for the port mapping. The default is <code>tcp</code>.</p>
    pub protocol: std::option::Option<std::string::String>,
}
impl AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails {
    /// <p>The port number on the container that is bound to the user-specified or automatically assigned host port.</p>
    pub fn container_port(&self) -> i32 {
        self.container_port
    }
    /// <p>The port number on the container instance to reserve for the container.</p>
    pub fn host_port(&self) -> i32 {
        self.host_port
    }
    /// <p>The protocol used for the port mapping. The default is <code>tcp</code>.</p>
    pub fn protocol(&self) -> std::option::Option<&str> {
        self.protocol.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails");
        formatter.field("container_port", &self.container_port);
        formatter.field("host_port", &self.host_port);
        formatter.field("protocol", &self.protocol);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails)
pub mod aws_ecs_task_definition_container_definitions_port_mappings_details {

    /// A builder for [`AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) container_port: std::option::Option<i32>,
        pub(crate) host_port: std::option::Option<i32>,
        pub(crate) protocol: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The port number on the container that is bound to the user-specified or automatically assigned host port.</p>
        pub fn container_port(mut self, input: i32) -> Self {
            self.container_port = Some(input);
            self
        }
        /// <p>The port number on the container that is bound to the user-specified or automatically assigned host port.</p>
        pub fn set_container_port(mut self, input: std::option::Option<i32>) -> Self {
            self.container_port = input;
            self
        }
        /// <p>The port number on the container instance to reserve for the container.</p>
        pub fn host_port(mut self, input: i32) -> Self {
            self.host_port = Some(input);
            self
        }
        /// <p>The port number on the container instance to reserve for the container.</p>
        pub fn set_host_port(mut self, input: std::option::Option<i32>) -> Self {
            self.host_port = input;
            self
        }
        /// <p>The protocol used for the port mapping. The default is <code>tcp</code>.</p>
        pub fn protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.protocol = Some(input.into());
            self
        }
        /// <p>The protocol used for the port mapping. The default is <code>tcp</code>.</p>
        pub fn set_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.protocol = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails {
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails {
                container_port: self.container_port.unwrap_or_default(),
                host_port: self.host_port.unwrap_or_default(),
                protocol: self.protocol,
            }
        }
    }
}
impl AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails)
    pub fn builder(
    ) -> crate::model::aws_ecs_task_definition_container_definitions_port_mappings_details::Builder
    {
        crate::model::aws_ecs_task_definition_container_definitions_port_mappings_details::Builder::default()
    }
}

/// <p>A mount point for the data volumes in the container.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails {
    /// <p>The path on the container to mount the host volume at.</p>
    pub container_path: std::option::Option<std::string::String>,
    /// <p>Whether the container has read-only access to the volume.</p>
    pub read_only: bool,
    /// <p>The name of the volume to mount. Must match the name of a volume listed in <code>VolumeDetails</code> for the task definition.</p>
    pub source_volume: std::option::Option<std::string::String>,
}
impl AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails {
    /// <p>The path on the container to mount the host volume at.</p>
    pub fn container_path(&self) -> std::option::Option<&str> {
        self.container_path.as_deref()
    }
    /// <p>Whether the container has read-only access to the volume.</p>
    pub fn read_only(&self) -> bool {
        self.read_only
    }
    /// <p>The name of the volume to mount. Must match the name of a volume listed in <code>VolumeDetails</code> for the task definition.</p>
    pub fn source_volume(&self) -> std::option::Option<&str> {
        self.source_volume.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails");
        formatter.field("container_path", &self.container_path);
        formatter.field("read_only", &self.read_only);
        formatter.field("source_volume", &self.source_volume);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails)
pub mod aws_ecs_task_definition_container_definitions_mount_points_details {

    /// A builder for [`AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) container_path: std::option::Option<std::string::String>,
        pub(crate) read_only: std::option::Option<bool>,
        pub(crate) source_volume: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The path on the container to mount the host volume at.</p>
        pub fn container_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.container_path = Some(input.into());
            self
        }
        /// <p>The path on the container to mount the host volume at.</p>
        pub fn set_container_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.container_path = input;
            self
        }
        /// <p>Whether the container has read-only access to the volume.</p>
        pub fn read_only(mut self, input: bool) -> Self {
            self.read_only = Some(input);
            self
        }
        /// <p>Whether the container has read-only access to the volume.</p>
        pub fn set_read_only(mut self, input: std::option::Option<bool>) -> Self {
            self.read_only = input;
            self
        }
        /// <p>The name of the volume to mount. Must match the name of a volume listed in <code>VolumeDetails</code> for the task definition.</p>
        pub fn source_volume(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_volume = Some(input.into());
            self
        }
        /// <p>The name of the volume to mount. Must match the name of a volume listed in <code>VolumeDetails</code> for the task definition.</p>
        pub fn set_source_volume(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_volume = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails {
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails {
                container_path: self.container_path,
                read_only: self.read_only.unwrap_or_default(),
                source_volume: self.source_volume,
            }
        }
    }
}
impl AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails)
    pub fn builder(
    ) -> crate::model::aws_ecs_task_definition_container_definitions_mount_points_details::Builder
    {
        crate::model::aws_ecs_task_definition_container_definitions_mount_points_details::Builder::default()
    }
}

/// <p>The log configuration specification for the container.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails  {
    /// <p>The log driver to use for the container.</p>
    pub log_driver: std::option::Option<std::string::String>,
    /// <p>The configuration options to send to the log driver. Requires version 1.19 of the Docker Remote API or greater on your container instance.</p>
    pub options: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The secrets to pass to the log configuration.</p>
    pub secret_options: std::option::Option<std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails>>,
}
impl AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails {
    /// <p>The log driver to use for the container.</p>
    pub fn log_driver(&self) -> std::option::Option<&str> {
        self.log_driver.as_deref()
    }
    /// <p>The configuration options to send to the log driver. Requires version 1.19 of the Docker Remote API or greater on your container instance.</p>
    pub fn options(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.options.as_ref()
    }
    /// <p>The secrets to pass to the log configuration.</p>
    pub fn secret_options(&self) -> std::option::Option<& [crate::model::AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails]>{
        self.secret_options.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails");
        formatter.field("log_driver", &self.log_driver);
        formatter.field("options", &self.options);
        formatter.field("secret_options", &self.secret_options);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails)
pub mod aws_ecs_task_definition_container_definitions_log_configuration_details {

    /// A builder for [`AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_driver: std::option::Option<std::string::String>,
        pub(crate) options: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) secret_options: std::option::Option<std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails>>,
    }
    impl Builder {
        /// <p>The log driver to use for the container.</p>
        pub fn log_driver(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_driver = Some(input.into());
            self
        }
        /// <p>The log driver to use for the container.</p>
        pub fn set_log_driver(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.log_driver = input;
            self
        }
        /// Adds a key-value pair to `options`.
        ///
        /// To override the contents of this collection use [`set_options`](Self::set_options).
        ///
        /// <p>The configuration options to send to the log driver. Requires version 1.19 of the Docker Remote API or greater on your container instance.</p>
        pub fn options(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.options.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.options = Some(hash_map);
            self
        }
        /// <p>The configuration options to send to the log driver. Requires version 1.19 of the Docker Remote API or greater on your container instance.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.options = input;
            self
        }
        /// Appends an item to `secret_options`.
        ///
        /// To override the contents of this collection use [`set_secret_options`](Self::set_secret_options).
        ///
        /// <p>The secrets to pass to the log configuration.</p>
        pub fn secret_options(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails,
        ) -> Self {
            let mut v = self.secret_options.unwrap_or_default();
            v.push(input);
            self.secret_options = Some(v);
            self
        }
        /// <p>The secrets to pass to the log configuration.</p>
        pub fn set_secret_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails>>,
        ) -> Self {
            self.secret_options = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails {
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails {
                log_driver: self.log_driver,
                options: self.options,
                secret_options: self.secret_options,
            }
        }
    }
}
impl AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails)
    pub fn builder() -> crate::model::aws_ecs_task_definition_container_definitions_log_configuration_details::Builder{
        crate::model::aws_ecs_task_definition_container_definitions_log_configuration_details::Builder::default()
    }
}

/// <p>A secret to pass to the log configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails {
    /// <p>The name of the secret.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The secret to expose to the container.</p>
    /// <p>The value is either the full ARN of the Secrets Manager secret or the full ARN of the parameter in the Systems Manager Parameter Store.</p>
    pub value_from: std::option::Option<std::string::String>,
}
impl AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails {
    /// <p>The name of the secret.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The secret to expose to the container.</p>
    /// <p>The value is either the full ARN of the Secrets Manager secret or the full ARN of the parameter in the Systems Manager Parameter Store.</p>
    pub fn value_from(&self) -> std::option::Option<&str> {
        self.value_from.as_deref()
    }
}
impl std::fmt::Debug
    for AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct(
            "AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails",
        );
        formatter.field("name", &self.name);
        formatter.field("value_from", &self.value_from);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails)
pub mod aws_ecs_task_definition_container_definitions_log_configuration_secret_options_details {

    /// A builder for [`AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value_from: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the secret.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the secret.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The secret to expose to the container.</p>
        /// <p>The value is either the full ARN of the Secrets Manager secret or the full ARN of the parameter in the Systems Manager Parameter Store.</p>
        pub fn value_from(mut self, input: impl Into<std::string::String>) -> Self {
            self.value_from = Some(input.into());
            self
        }
        /// <p>The secret to expose to the container.</p>
        /// <p>The value is either the full ARN of the Secrets Manager secret or the full ARN of the parameter in the Systems Manager Parameter Store.</p>
        pub fn set_value_from(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value_from = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails)
        pub fn build(self) -> crate::model::AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails{
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails {
                name: self.name
                ,
                value_from: self.value_from
                ,
            }
        }
    }
}
impl AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails)
    pub fn builder() -> crate::model::aws_ecs_task_definition_container_definitions_log_configuration_secret_options_details::Builder{
        crate::model::aws_ecs_task_definition_container_definitions_log_configuration_secret_options_details::Builder::default()
    }
}

/// <p>&gt;Linux-specific modifications that are applied to the container, such as Linux kernel capabilities.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails {
    /// <p>The Linux capabilities for the container that are added to or dropped from the default configuration provided by Docker.</p>
    pub capabilities: std::option::Option<
        crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails,
    >,
    /// <p>The host devices to expose to the container.</p>
    pub devices: std::option::Option<
        std::vec::Vec<
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails,
        >,
    >,
    /// <p>Whether to run an <code>init</code> process inside the container that forwards signals and reaps processes. </p>
    pub init_process_enabled: bool,
    /// <p>The total amount of swap memory (in MiB) that a container can use.</p>
    pub max_swap: i32,
    /// <p>The value for the size (in MiB) of the <b>/dev/shm</b> volume.</p>
    pub shared_memory_size: i32,
    /// <p>Configures the container's memory swappiness behavior. Determines how aggressively pages are swapped. The higher the value, the more aggressive the swappiness. The default is 60.</p>
    pub swappiness: i32,
    /// <p>The container path, mount options, and size (in MiB) of the tmpfs mount.</p>
    pub tmpfs: std::option::Option<
        std::vec::Vec<
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails,
        >,
    >,
}
impl AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails {
    /// <p>The Linux capabilities for the container that are added to or dropped from the default configuration provided by Docker.</p>
    pub fn capabilities(
        &self,
    ) -> std::option::Option<
        &crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails,
    > {
        self.capabilities.as_ref()
    }
    /// <p>The host devices to expose to the container.</p>
    pub fn devices(
        &self,
    ) -> std::option::Option<
        &[crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails],
    > {
        self.devices.as_deref()
    }
    /// <p>Whether to run an <code>init</code> process inside the container that forwards signals and reaps processes. </p>
    pub fn init_process_enabled(&self) -> bool {
        self.init_process_enabled
    }
    /// <p>The total amount of swap memory (in MiB) that a container can use.</p>
    pub fn max_swap(&self) -> i32 {
        self.max_swap
    }
    /// <p>The value for the size (in MiB) of the <b>/dev/shm</b> volume.</p>
    pub fn shared_memory_size(&self) -> i32 {
        self.shared_memory_size
    }
    /// <p>Configures the container's memory swappiness behavior. Determines how aggressively pages are swapped. The higher the value, the more aggressive the swappiness. The default is 60.</p>
    pub fn swappiness(&self) -> i32 {
        self.swappiness
    }
    /// <p>The container path, mount options, and size (in MiB) of the tmpfs mount.</p>
    pub fn tmpfs(
        &self,
    ) -> std::option::Option<
        &[crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails],
    > {
        self.tmpfs.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails");
        formatter.field("capabilities", &self.capabilities);
        formatter.field("devices", &self.devices);
        formatter.field("init_process_enabled", &self.init_process_enabled);
        formatter.field("max_swap", &self.max_swap);
        formatter.field("shared_memory_size", &self.shared_memory_size);
        formatter.field("swappiness", &self.swappiness);
        formatter.field("tmpfs", &self.tmpfs);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails)
pub mod aws_ecs_task_definition_container_definitions_linux_parameters_details {

    /// A builder for [`AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) capabilities: std::option::Option<crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails>,
        pub(crate) devices: std::option::Option<std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails>>,
        pub(crate) init_process_enabled: std::option::Option<bool>,
        pub(crate) max_swap: std::option::Option<i32>,
        pub(crate) shared_memory_size: std::option::Option<i32>,
        pub(crate) swappiness: std::option::Option<i32>,
        pub(crate) tmpfs: std::option::Option<std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails>>,
    }
    impl Builder {
        /// <p>The Linux capabilities for the container that are added to or dropped from the default configuration provided by Docker.</p>
        pub fn capabilities(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails,
        ) -> Self {
            self.capabilities = Some(input);
            self
        }
        /// <p>The Linux capabilities for the container that are added to or dropped from the default configuration provided by Docker.</p>
        pub fn set_capabilities(
            mut self,
            input: std::option::Option<crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails>,
        ) -> Self {
            self.capabilities = input;
            self
        }
        /// Appends an item to `devices`.
        ///
        /// To override the contents of this collection use [`set_devices`](Self::set_devices).
        ///
        /// <p>The host devices to expose to the container.</p>
        pub fn devices(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails,
        ) -> Self {
            let mut v = self.devices.unwrap_or_default();
            v.push(input);
            self.devices = Some(v);
            self
        }
        /// <p>The host devices to expose to the container.</p>
        pub fn set_devices(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails>>,
        ) -> Self {
            self.devices = input;
            self
        }
        /// <p>Whether to run an <code>init</code> process inside the container that forwards signals and reaps processes. </p>
        pub fn init_process_enabled(mut self, input: bool) -> Self {
            self.init_process_enabled = Some(input);
            self
        }
        /// <p>Whether to run an <code>init</code> process inside the container that forwards signals and reaps processes. </p>
        pub fn set_init_process_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.init_process_enabled = input;
            self
        }
        /// <p>The total amount of swap memory (in MiB) that a container can use.</p>
        pub fn max_swap(mut self, input: i32) -> Self {
            self.max_swap = Some(input);
            self
        }
        /// <p>The total amount of swap memory (in MiB) that a container can use.</p>
        pub fn set_max_swap(mut self, input: std::option::Option<i32>) -> Self {
            self.max_swap = input;
            self
        }
        /// <p>The value for the size (in MiB) of the <b>/dev/shm</b> volume.</p>
        pub fn shared_memory_size(mut self, input: i32) -> Self {
            self.shared_memory_size = Some(input);
            self
        }
        /// <p>The value for the size (in MiB) of the <b>/dev/shm</b> volume.</p>
        pub fn set_shared_memory_size(mut self, input: std::option::Option<i32>) -> Self {
            self.shared_memory_size = input;
            self
        }
        /// <p>Configures the container's memory swappiness behavior. Determines how aggressively pages are swapped. The higher the value, the more aggressive the swappiness. The default is 60.</p>
        pub fn swappiness(mut self, input: i32) -> Self {
            self.swappiness = Some(input);
            self
        }
        /// <p>Configures the container's memory swappiness behavior. Determines how aggressively pages are swapped. The higher the value, the more aggressive the swappiness. The default is 60.</p>
        pub fn set_swappiness(mut self, input: std::option::Option<i32>) -> Self {
            self.swappiness = input;
            self
        }
        /// Appends an item to `tmpfs`.
        ///
        /// To override the contents of this collection use [`set_tmpfs`](Self::set_tmpfs).
        ///
        /// <p>The container path, mount options, and size (in MiB) of the tmpfs mount.</p>
        pub fn tmpfs(
            mut self,
            input: crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails,
        ) -> Self {
            let mut v = self.tmpfs.unwrap_or_default();
            v.push(input);
            self.tmpfs = Some(v);
            self
        }
        /// <p>The container path, mount options, and size (in MiB) of the tmpfs mount.</p>
        pub fn set_tmpfs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails>>,
        ) -> Self {
            self.tmpfs = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails {
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails {
                capabilities: self.capabilities,
                devices: self.devices,
                init_process_enabled: self.init_process_enabled.unwrap_or_default(),
                max_swap: self.max_swap.unwrap_or_default(),
                shared_memory_size: self.shared_memory_size.unwrap_or_default(),
                swappiness: self.swappiness.unwrap_or_default(),
                tmpfs: self.tmpfs,
            }
        }
    }
}
impl AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails)
    pub fn builder(
    ) -> crate::model::aws_ecs_task_definition_container_definitions_linux_parameters_details::Builder
    {
        crate::model::aws_ecs_task_definition_container_definitions_linux_parameters_details::Builder::default()
    }
}

/// <p>The container path, mount options, and size (in MiB) of a tmpfs mount.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails {
    /// <p>The absolute file path where the tmpfs volume is to be mounted.</p>
    pub container_path: std::option::Option<std::string::String>,
    /// <p>The list of tmpfs volume mount options.</p>
    pub mount_options: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The maximum size (in MiB) of the tmpfs volume.</p>
    pub size: i32,
}
impl AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails {
    /// <p>The absolute file path where the tmpfs volume is to be mounted.</p>
    pub fn container_path(&self) -> std::option::Option<&str> {
        self.container_path.as_deref()
    }
    /// <p>The list of tmpfs volume mount options.</p>
    pub fn mount_options(&self) -> std::option::Option<&[std::string::String]> {
        self.mount_options.as_deref()
    }
    /// <p>The maximum size (in MiB) of the tmpfs volume.</p>
    pub fn size(&self) -> i32 {
        self.size
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails");
        formatter.field("container_path", &self.container_path);
        formatter.field("mount_options", &self.mount_options);
        formatter.field("size", &self.size);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails)
pub mod aws_ecs_task_definition_container_definitions_linux_parameters_tmpfs_details {

    /// A builder for [`AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) container_path: std::option::Option<std::string::String>,
        pub(crate) mount_options: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) size: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The absolute file path where the tmpfs volume is to be mounted.</p>
        pub fn container_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.container_path = Some(input.into());
            self
        }
        /// <p>The absolute file path where the tmpfs volume is to be mounted.</p>
        pub fn set_container_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.container_path = input;
            self
        }
        /// Appends an item to `mount_options`.
        ///
        /// To override the contents of this collection use [`set_mount_options`](Self::set_mount_options).
        ///
        /// <p>The list of tmpfs volume mount options.</p>
        pub fn mount_options(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.mount_options.unwrap_or_default();
            v.push(input.into());
            self.mount_options = Some(v);
            self
        }
        /// <p>The list of tmpfs volume mount options.</p>
        pub fn set_mount_options(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.mount_options = input;
            self
        }
        /// <p>The maximum size (in MiB) of the tmpfs volume.</p>
        pub fn size(mut self, input: i32) -> Self {
            self.size = Some(input);
            self
        }
        /// <p>The maximum size (in MiB) of the tmpfs volume.</p>
        pub fn set_size(mut self, input: std::option::Option<i32>) -> Self {
            self.size = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails
        {
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails {
                container_path: self.container_path,
                mount_options: self.mount_options,
                size: self.size.unwrap_or_default(),
            }
        }
    }
}
impl AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails)
    pub fn builder() -> crate::model::aws_ecs_task_definition_container_definitions_linux_parameters_tmpfs_details::Builder{
        crate::model::aws_ecs_task_definition_container_definitions_linux_parameters_tmpfs_details::Builder::default()
    }
}

/// <p>A host device to expose to the container.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails {
    /// <p>The path inside the container at which to expose the host device.</p>
    pub container_path: std::option::Option<std::string::String>,
    /// <p>The path for the device on the host container instance.</p>
    pub host_path: std::option::Option<std::string::String>,
    /// <p>The explicit permissions to provide to the container for the device. By default, the container has permissions for read, write, and <code>mknod</code> for the device.</p>
    pub permissions: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails {
    /// <p>The path inside the container at which to expose the host device.</p>
    pub fn container_path(&self) -> std::option::Option<&str> {
        self.container_path.as_deref()
    }
    /// <p>The path for the device on the host container instance.</p>
    pub fn host_path(&self) -> std::option::Option<&str> {
        self.host_path.as_deref()
    }
    /// <p>The explicit permissions to provide to the container for the device. By default, the container has permissions for read, write, and <code>mknod</code> for the device.</p>
    pub fn permissions(&self) -> std::option::Option<&[std::string::String]> {
        self.permissions.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails");
        formatter.field("container_path", &self.container_path);
        formatter.field("host_path", &self.host_path);
        formatter.field("permissions", &self.permissions);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails)
pub mod aws_ecs_task_definition_container_definitions_linux_parameters_devices_details {

    /// A builder for [`AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) container_path: std::option::Option<std::string::String>,
        pub(crate) host_path: std::option::Option<std::string::String>,
        pub(crate) permissions: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The path inside the container at which to expose the host device.</p>
        pub fn container_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.container_path = Some(input.into());
            self
        }
        /// <p>The path inside the container at which to expose the host device.</p>
        pub fn set_container_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.container_path = input;
            self
        }
        /// <p>The path for the device on the host container instance.</p>
        pub fn host_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.host_path = Some(input.into());
            self
        }
        /// <p>The path for the device on the host container instance.</p>
        pub fn set_host_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host_path = input;
            self
        }
        /// Appends an item to `permissions`.
        ///
        /// To override the contents of this collection use [`set_permissions`](Self::set_permissions).
        ///
        /// <p>The explicit permissions to provide to the container for the device. By default, the container has permissions for read, write, and <code>mknod</code> for the device.</p>
        pub fn permissions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.permissions.unwrap_or_default();
            v.push(input.into());
            self.permissions = Some(v);
            self
        }
        /// <p>The explicit permissions to provide to the container for the device. By default, the container has permissions for read, write, and <code>mknod</code> for the device.</p>
        pub fn set_permissions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.permissions = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails
        {
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails {
                container_path: self.container_path,
                host_path: self.host_path,
                permissions: self.permissions,
            }
        }
    }
}
impl AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails)
    pub fn builder() -> crate::model::aws_ecs_task_definition_container_definitions_linux_parameters_devices_details::Builder{
        crate::model::aws_ecs_task_definition_container_definitions_linux_parameters_devices_details::Builder::default()
    }
}

/// <p>The Linux capabilities for the container that are added to or dropped from the default configuration provided by Docker.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails {
    /// <p>The Linux capabilities for the container that are added to the default configuration provided by Docker.</p>
    pub add: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The Linux capabilities for the container that are dropped from the default configuration provided by Docker.</p>
    pub drop: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails {
    /// <p>The Linux capabilities for the container that are added to the default configuration provided by Docker.</p>
    pub fn add(&self) -> std::option::Option<&[std::string::String]> {
        self.add.as_deref()
    }
    /// <p>The Linux capabilities for the container that are dropped from the default configuration provided by Docker.</p>
    pub fn drop(&self) -> std::option::Option<&[std::string::String]> {
        self.drop.as_deref()
    }
}
impl std::fmt::Debug
    for AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct(
            "AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails",
        );
        formatter.field("add", &self.add);
        formatter.field("drop", &self.drop);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails)
pub mod aws_ecs_task_definition_container_definitions_linux_parameters_capabilities_details {

    /// A builder for [`AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) add: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) drop: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `add`.
        ///
        /// To override the contents of this collection use [`set_add`](Self::set_add).
        ///
        /// <p>The Linux capabilities for the container that are added to the default configuration provided by Docker.</p>
        pub fn add(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.add.unwrap_or_default();
            v.push(input.into());
            self.add = Some(v);
            self
        }
        /// <p>The Linux capabilities for the container that are added to the default configuration provided by Docker.</p>
        pub fn set_add(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.add = input;
            self
        }
        /// Appends an item to `drop`.
        ///
        /// To override the contents of this collection use [`set_drop`](Self::set_drop).
        ///
        /// <p>The Linux capabilities for the container that are dropped from the default configuration provided by Docker.</p>
        pub fn drop(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.drop.unwrap_or_default();
            v.push(input.into());
            self.drop = Some(v);
            self
        }
        /// <p>The Linux capabilities for the container that are dropped from the default configuration provided by Docker.</p>
        pub fn set_drop(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.drop = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails
        {
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails {
                add: self.add
                ,
                drop: self.drop
                ,
            }
        }
    }
}
impl AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails)
    pub fn builder() -> crate::model::aws_ecs_task_definition_container_definitions_linux_parameters_capabilities_details::Builder{
        crate::model::aws_ecs_task_definition_container_definitions_linux_parameters_capabilities_details::Builder::default()
    }
}

/// <p>The container health check command and associated configuration parameters for the container.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails {
    /// <p>The command that the container runs to determine whether it is healthy.</p>
    pub command: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The time period in seconds between each health check execution. The default value is 30 seconds.</p>
    pub interval: i32,
    /// <p>The number of times to retry a failed health check before the container is considered unhealthy. The default value is 3.</p>
    pub retries: i32,
    /// <p>The optional grace period in seconds that allows containers time to bootstrap before failed health checks count towards the maximum number of retries.</p>
    pub start_period: i32,
    /// <p>The time period in seconds to wait for a health check to succeed before it is considered a failure. The default value is 5.</p>
    pub timeout: i32,
}
impl AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails {
    /// <p>The command that the container runs to determine whether it is healthy.</p>
    pub fn command(&self) -> std::option::Option<&[std::string::String]> {
        self.command.as_deref()
    }
    /// <p>The time period in seconds between each health check execution. The default value is 30 seconds.</p>
    pub fn interval(&self) -> i32 {
        self.interval
    }
    /// <p>The number of times to retry a failed health check before the container is considered unhealthy. The default value is 3.</p>
    pub fn retries(&self) -> i32 {
        self.retries
    }
    /// <p>The optional grace period in seconds that allows containers time to bootstrap before failed health checks count towards the maximum number of retries.</p>
    pub fn start_period(&self) -> i32 {
        self.start_period
    }
    /// <p>The time period in seconds to wait for a health check to succeed before it is considered a failure. The default value is 5.</p>
    pub fn timeout(&self) -> i32 {
        self.timeout
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails");
        formatter.field("command", &self.command);
        formatter.field("interval", &self.interval);
        formatter.field("retries", &self.retries);
        formatter.field("start_period", &self.start_period);
        formatter.field("timeout", &self.timeout);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails)
pub mod aws_ecs_task_definition_container_definitions_health_check_details {

    /// A builder for [`AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) command: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) interval: std::option::Option<i32>,
        pub(crate) retries: std::option::Option<i32>,
        pub(crate) start_period: std::option::Option<i32>,
        pub(crate) timeout: std::option::Option<i32>,
    }
    impl Builder {
        /// Appends an item to `command`.
        ///
        /// To override the contents of this collection use [`set_command`](Self::set_command).
        ///
        /// <p>The command that the container runs to determine whether it is healthy.</p>
        pub fn command(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.command.unwrap_or_default();
            v.push(input.into());
            self.command = Some(v);
            self
        }
        /// <p>The command that the container runs to determine whether it is healthy.</p>
        pub fn set_command(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.command = input;
            self
        }
        /// <p>The time period in seconds between each health check execution. The default value is 30 seconds.</p>
        pub fn interval(mut self, input: i32) -> Self {
            self.interval = Some(input);
            self
        }
        /// <p>The time period in seconds between each health check execution. The default value is 30 seconds.</p>
        pub fn set_interval(mut self, input: std::option::Option<i32>) -> Self {
            self.interval = input;
            self
        }
        /// <p>The number of times to retry a failed health check before the container is considered unhealthy. The default value is 3.</p>
        pub fn retries(mut self, input: i32) -> Self {
            self.retries = Some(input);
            self
        }
        /// <p>The number of times to retry a failed health check before the container is considered unhealthy. The default value is 3.</p>
        pub fn set_retries(mut self, input: std::option::Option<i32>) -> Self {
            self.retries = input;
            self
        }
        /// <p>The optional grace period in seconds that allows containers time to bootstrap before failed health checks count towards the maximum number of retries.</p>
        pub fn start_period(mut self, input: i32) -> Self {
            self.start_period = Some(input);
            self
        }
        /// <p>The optional grace period in seconds that allows containers time to bootstrap before failed health checks count towards the maximum number of retries.</p>
        pub fn set_start_period(mut self, input: std::option::Option<i32>) -> Self {
            self.start_period = input;
            self
        }
        /// <p>The time period in seconds to wait for a health check to succeed before it is considered a failure. The default value is 5.</p>
        pub fn timeout(mut self, input: i32) -> Self {
            self.timeout = Some(input);
            self
        }
        /// <p>The time period in seconds to wait for a health check to succeed before it is considered a failure. The default value is 5.</p>
        pub fn set_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.timeout = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails {
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails {
                command: self.command,
                interval: self.interval.unwrap_or_default(),
                retries: self.retries.unwrap_or_default(),
                start_period: self.start_period.unwrap_or_default(),
                timeout: self.timeout.unwrap_or_default(),
            }
        }
    }
}
impl AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails)
    pub fn builder(
    ) -> crate::model::aws_ecs_task_definition_container_definitions_health_check_details::Builder
    {
        crate::model::aws_ecs_task_definition_container_definitions_health_check_details::Builder::default()
    }
}

/// <p>The FireLens configuration for the container. The configuration specifies and configures a log router for container logs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails {
    /// <p>The options to use to configure the log router.</p>
    /// <p>The valid option keys are as follows:</p>
    /// <ul>
    /// <li> <p> <code>enable-ecs-log-metadata</code>. The value can be <code>true</code> or <code>false</code>.</p> </li>
    /// <li> <p> <code>config-file-type</code>. The value can be <code>s3</code> or <code>file</code>.</p> </li>
    /// <li> <p> <code>config-file-value</code>. The value is either an S3 ARN or a file path.</p> </li>
    /// </ul>
    pub options:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The log router to use. </p>
    pub r#type: std::option::Option<std::string::String>,
}
impl AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails {
    /// <p>The options to use to configure the log router.</p>
    /// <p>The valid option keys are as follows:</p>
    /// <ul>
    /// <li> <p> <code>enable-ecs-log-metadata</code>. The value can be <code>true</code> or <code>false</code>.</p> </li>
    /// <li> <p> <code>config-file-type</code>. The value can be <code>s3</code> or <code>file</code>.</p> </li>
    /// <li> <p> <code>config-file-value</code>. The value is either an S3 ARN or a file path.</p> </li>
    /// </ul>
    pub fn options(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.options.as_ref()
    }
    /// <p>The log router to use. </p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails");
        formatter.field("options", &self.options);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails)
pub mod aws_ecs_task_definition_container_definitions_firelens_configuration_details {

    /// A builder for [`AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) options: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Adds a key-value pair to `options`.
        ///
        /// To override the contents of this collection use [`set_options`](Self::set_options).
        ///
        /// <p>The options to use to configure the log router.</p>
        /// <p>The valid option keys are as follows:</p>
        /// <ul>
        /// <li> <p> <code>enable-ecs-log-metadata</code>. The value can be <code>true</code> or <code>false</code>.</p> </li>
        /// <li> <p> <code>config-file-type</code>. The value can be <code>s3</code> or <code>file</code>.</p> </li>
        /// <li> <p> <code>config-file-value</code>. The value is either an S3 ARN or a file path.</p> </li>
        /// </ul>
        pub fn options(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.options.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.options = Some(hash_map);
            self
        }
        /// <p>The options to use to configure the log router.</p>
        /// <p>The valid option keys are as follows:</p>
        /// <ul>
        /// <li> <p> <code>enable-ecs-log-metadata</code>. The value can be <code>true</code> or <code>false</code>.</p> </li>
        /// <li> <p> <code>config-file-type</code>. The value can be <code>s3</code> or <code>file</code>.</p> </li>
        /// <li> <p> <code>config-file-value</code>. The value is either an S3 ARN or a file path.</p> </li>
        /// </ul>
        pub fn set_options(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.options = input;
            self
        }
        /// <p>The log router to use. </p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The log router to use. </p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails
        {
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails {
                options: self.options,
                r#type: self.r#type,
            }
        }
    }
}
impl AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails)
    pub fn builder() -> crate::model::aws_ecs_task_definition_container_definitions_firelens_configuration_details::Builder{
        crate::model::aws_ecs_task_definition_container_definitions_firelens_configuration_details::Builder::default()
    }
}

/// <p>A hostname and IP address mapping to append to the <b>/etc/hosts</b> file on the container.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails {
    /// <p>The hostname to use in the <b>/etc/hosts</b> entry.</p>
    pub hostname: std::option::Option<std::string::String>,
    /// <p>The IP address to use in the <b>/etc/hosts</b> entry.</p>
    pub ip_address: std::option::Option<std::string::String>,
}
impl AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails {
    /// <p>The hostname to use in the <b>/etc/hosts</b> entry.</p>
    pub fn hostname(&self) -> std::option::Option<&str> {
        self.hostname.as_deref()
    }
    /// <p>The IP address to use in the <b>/etc/hosts</b> entry.</p>
    pub fn ip_address(&self) -> std::option::Option<&str> {
        self.ip_address.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails");
        formatter.field("hostname", &self.hostname);
        formatter.field("ip_address", &self.ip_address);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails)
pub mod aws_ecs_task_definition_container_definitions_extra_hosts_details {

    /// A builder for [`AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hostname: std::option::Option<std::string::String>,
        pub(crate) ip_address: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The hostname to use in the <b>/etc/hosts</b> entry.</p>
        pub fn hostname(mut self, input: impl Into<std::string::String>) -> Self {
            self.hostname = Some(input.into());
            self
        }
        /// <p>The hostname to use in the <b>/etc/hosts</b> entry.</p>
        pub fn set_hostname(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hostname = input;
            self
        }
        /// <p>The IP address to use in the <b>/etc/hosts</b> entry.</p>
        pub fn ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.ip_address = Some(input.into());
            self
        }
        /// <p>The IP address to use in the <b>/etc/hosts</b> entry.</p>
        pub fn set_ip_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ip_address = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails {
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails {
                hostname: self.hostname,
                ip_address: self.ip_address,
            }
        }
    }
}
impl AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails)
    pub fn builder(
    ) -> crate::model::aws_ecs_task_definition_container_definitions_extra_hosts_details::Builder
    {
        crate::model::aws_ecs_task_definition_container_definitions_extra_hosts_details::Builder::default()
    }
}

/// <p>A file that contain environment variables to pass to a container.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails {
    /// <p>The type of environment file.</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The ARN of the S3 object that contains the environment variable file.</p>
    pub value: std::option::Option<std::string::String>,
}
impl AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails {
    /// <p>The type of environment file.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The ARN of the S3 object that contains the environment variable file.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails");
        formatter.field("r#type", &self.r#type);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails)
pub mod aws_ecs_task_definition_container_definitions_environment_files_details {

    /// A builder for [`AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of environment file.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of environment file.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The ARN of the S3 object that contains the environment variable file.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The ARN of the S3 object that contains the environment variable file.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails {
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails {
                r#type: self.r#type,
                value: self.value,
            }
        }
    }
}
impl AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails)
    pub fn builder() -> crate::model::aws_ecs_task_definition_container_definitions_environment_files_details::Builder{
        crate::model::aws_ecs_task_definition_container_definitions_environment_files_details::Builder::default()
    }
}

/// <p>An environment variable to pass to the container.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails {
    /// <p>The name of the environment variable.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The value of the environment variable.</p>
    pub value: std::option::Option<std::string::String>,
}
impl AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails {
    /// <p>The name of the environment variable.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The value of the environment variable.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails)
pub mod aws_ecs_task_definition_container_definitions_environment_details {

    /// A builder for [`AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the environment variable.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the environment variable.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The value of the environment variable.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the environment variable.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails {
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails)
    pub fn builder(
    ) -> crate::model::aws_ecs_task_definition_container_definitions_environment_details::Builder
    {
        crate::model::aws_ecs_task_definition_container_definitions_environment_details::Builder::default()
    }
}

/// <p>A dependency that is defined for container startup and shutdown.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails {
    /// <p>The dependency condition of the dependent container. Indicates the required status of the dependent container before the current container can start.</p>
    pub condition: std::option::Option<std::string::String>,
    /// <p>The name of the dependent container.</p>
    pub container_name: std::option::Option<std::string::String>,
}
impl AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails {
    /// <p>The dependency condition of the dependent container. Indicates the required status of the dependent container before the current container can start.</p>
    pub fn condition(&self) -> std::option::Option<&str> {
        self.condition.as_deref()
    }
    /// <p>The name of the dependent container.</p>
    pub fn container_name(&self) -> std::option::Option<&str> {
        self.container_name.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails");
        formatter.field("condition", &self.condition);
        formatter.field("container_name", &self.container_name);
        formatter.finish()
    }
}
/// See [`AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails)
pub mod aws_ecs_task_definition_container_definitions_depends_on_details {

    /// A builder for [`AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) condition: std::option::Option<std::string::String>,
        pub(crate) container_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The dependency condition of the dependent container. Indicates the required status of the dependent container before the current container can start.</p>
        pub fn condition(mut self, input: impl Into<std::string::String>) -> Self {
            self.condition = Some(input.into());
            self
        }
        /// <p>The dependency condition of the dependent container. Indicates the required status of the dependent container before the current container can start.</p>
        pub fn set_condition(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.condition = input;
            self
        }
        /// <p>The name of the dependent container.</p>
        pub fn container_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.container_name = Some(input.into());
            self
        }
        /// <p>The name of the dependent container.</p>
        pub fn set_container_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.container_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails {
            crate::model::AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails {
                condition: self.condition,
                container_name: self.container_name,
            }
        }
    }
}
impl AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails`](crate::model::AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails)
    pub fn builder(
    ) -> crate::model::aws_ecs_task_definition_container_definitions_depends_on_details::Builder
    {
        crate::model::aws_ecs_task_definition_container_definitions_depends_on_details::Builder::default()
    }
}

/// <p>Provides details about an Amazon ECS cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsClusterDetails {
    /// <p>The Amazon Resource Name (ARN) that identifies the cluster. </p>
    pub cluster_arn: std::option::Option<std::string::String>,
    /// <p>The number of services that are running on the cluster in an <code>ACTIVE</code> state. You can view these services with the Amazon ECS <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ListServices.html"> <code>ListServices</code> </a> API operation. </p>
    pub active_services_count: i32,
    /// <p>The short name of one or more capacity providers to associate with the cluster.</p>
    pub capacity_providers: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The setting to use to create the cluster. Specifically used to configure whether to enable CloudWatch Container Insights for the cluster.</p>
    pub cluster_settings:
        std::option::Option<std::vec::Vec<crate::model::AwsEcsClusterClusterSettingsDetails>>,
    /// <p>The run command configuration for the cluster.</p>
    pub configuration: std::option::Option<crate::model::AwsEcsClusterConfigurationDetails>,
    /// <p>The default capacity provider strategy for the cluster. The default capacity provider strategy is used when services or tasks are run without a specified launch type or capacity provider strategy.</p>
    pub default_capacity_provider_strategy: std::option::Option<
        std::vec::Vec<crate::model::AwsEcsClusterDefaultCapacityProviderStrategyDetails>,
    >,
    /// <p>A name that you use to identify your cluster. </p>
    pub cluster_name: std::option::Option<std::string::String>,
    /// <p>The number of container instances registered into the cluster. This includes container instances in both <code>ACTIVE</code> and <code>DRAINING</code> status. </p>
    pub registered_container_instances_count: i32,
    /// <p>The number of tasks in the cluster that are in the <code>RUNNING</code> state. </p>
    pub running_tasks_count: i32,
    /// <p>The status of the cluster. </p>
    pub status: std::option::Option<std::string::String>,
}
impl AwsEcsClusterDetails {
    /// <p>The Amazon Resource Name (ARN) that identifies the cluster. </p>
    pub fn cluster_arn(&self) -> std::option::Option<&str> {
        self.cluster_arn.as_deref()
    }
    /// <p>The number of services that are running on the cluster in an <code>ACTIVE</code> state. You can view these services with the Amazon ECS <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ListServices.html"> <code>ListServices</code> </a> API operation. </p>
    pub fn active_services_count(&self) -> i32 {
        self.active_services_count
    }
    /// <p>The short name of one or more capacity providers to associate with the cluster.</p>
    pub fn capacity_providers(&self) -> std::option::Option<&[std::string::String]> {
        self.capacity_providers.as_deref()
    }
    /// <p>The setting to use to create the cluster. Specifically used to configure whether to enable CloudWatch Container Insights for the cluster.</p>
    pub fn cluster_settings(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEcsClusterClusterSettingsDetails]> {
        self.cluster_settings.as_deref()
    }
    /// <p>The run command configuration for the cluster.</p>
    pub fn configuration(
        &self,
    ) -> std::option::Option<&crate::model::AwsEcsClusterConfigurationDetails> {
        self.configuration.as_ref()
    }
    /// <p>The default capacity provider strategy for the cluster. The default capacity provider strategy is used when services or tasks are run without a specified launch type or capacity provider strategy.</p>
    pub fn default_capacity_provider_strategy(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEcsClusterDefaultCapacityProviderStrategyDetails]>
    {
        self.default_capacity_provider_strategy.as_deref()
    }
    /// <p>A name that you use to identify your cluster. </p>
    pub fn cluster_name(&self) -> std::option::Option<&str> {
        self.cluster_name.as_deref()
    }
    /// <p>The number of container instances registered into the cluster. This includes container instances in both <code>ACTIVE</code> and <code>DRAINING</code> status. </p>
    pub fn registered_container_instances_count(&self) -> i32 {
        self.registered_container_instances_count
    }
    /// <p>The number of tasks in the cluster that are in the <code>RUNNING</code> state. </p>
    pub fn running_tasks_count(&self) -> i32 {
        self.running_tasks_count
    }
    /// <p>The status of the cluster. </p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsClusterDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcsClusterDetails");
        formatter.field("cluster_arn", &self.cluster_arn);
        formatter.field("active_services_count", &self.active_services_count);
        formatter.field("capacity_providers", &self.capacity_providers);
        formatter.field("cluster_settings", &self.cluster_settings);
        formatter.field("configuration", &self.configuration);
        formatter.field(
            "default_capacity_provider_strategy",
            &self.default_capacity_provider_strategy,
        );
        formatter.field("cluster_name", &self.cluster_name);
        formatter.field(
            "registered_container_instances_count",
            &self.registered_container_instances_count,
        );
        formatter.field("running_tasks_count", &self.running_tasks_count);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`AwsEcsClusterDetails`](crate::model::AwsEcsClusterDetails)
pub mod aws_ecs_cluster_details {

    /// A builder for [`AwsEcsClusterDetails`](crate::model::AwsEcsClusterDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cluster_arn: std::option::Option<std::string::String>,
        pub(crate) active_services_count: std::option::Option<i32>,
        pub(crate) capacity_providers: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) cluster_settings:
            std::option::Option<std::vec::Vec<crate::model::AwsEcsClusterClusterSettingsDetails>>,
        pub(crate) configuration:
            std::option::Option<crate::model::AwsEcsClusterConfigurationDetails>,
        pub(crate) default_capacity_provider_strategy: std::option::Option<
            std::vec::Vec<crate::model::AwsEcsClusterDefaultCapacityProviderStrategyDetails>,
        >,
        pub(crate) cluster_name: std::option::Option<std::string::String>,
        pub(crate) registered_container_instances_count: std::option::Option<i32>,
        pub(crate) running_tasks_count: std::option::Option<i32>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) that identifies the cluster. </p>
        pub fn cluster_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that identifies the cluster. </p>
        pub fn set_cluster_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cluster_arn = input;
            self
        }
        /// <p>The number of services that are running on the cluster in an <code>ACTIVE</code> state. You can view these services with the Amazon ECS <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ListServices.html"> <code>ListServices</code> </a> API operation. </p>
        pub fn active_services_count(mut self, input: i32) -> Self {
            self.active_services_count = Some(input);
            self
        }
        /// <p>The number of services that are running on the cluster in an <code>ACTIVE</code> state. You can view these services with the Amazon ECS <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ListServices.html"> <code>ListServices</code> </a> API operation. </p>
        pub fn set_active_services_count(mut self, input: std::option::Option<i32>) -> Self {
            self.active_services_count = input;
            self
        }
        /// Appends an item to `capacity_providers`.
        ///
        /// To override the contents of this collection use [`set_capacity_providers`](Self::set_capacity_providers).
        ///
        /// <p>The short name of one or more capacity providers to associate with the cluster.</p>
        pub fn capacity_providers(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.capacity_providers.unwrap_or_default();
            v.push(input.into());
            self.capacity_providers = Some(v);
            self
        }
        /// <p>The short name of one or more capacity providers to associate with the cluster.</p>
        pub fn set_capacity_providers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.capacity_providers = input;
            self
        }
        /// Appends an item to `cluster_settings`.
        ///
        /// To override the contents of this collection use [`set_cluster_settings`](Self::set_cluster_settings).
        ///
        /// <p>The setting to use to create the cluster. Specifically used to configure whether to enable CloudWatch Container Insights for the cluster.</p>
        pub fn cluster_settings(
            mut self,
            input: crate::model::AwsEcsClusterClusterSettingsDetails,
        ) -> Self {
            let mut v = self.cluster_settings.unwrap_or_default();
            v.push(input);
            self.cluster_settings = Some(v);
            self
        }
        /// <p>The setting to use to create the cluster. Specifically used to configure whether to enable CloudWatch Container Insights for the cluster.</p>
        pub fn set_cluster_settings(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEcsClusterClusterSettingsDetails>,
            >,
        ) -> Self {
            self.cluster_settings = input;
            self
        }
        /// <p>The run command configuration for the cluster.</p>
        pub fn configuration(
            mut self,
            input: crate::model::AwsEcsClusterConfigurationDetails,
        ) -> Self {
            self.configuration = Some(input);
            self
        }
        /// <p>The run command configuration for the cluster.</p>
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::AwsEcsClusterConfigurationDetails>,
        ) -> Self {
            self.configuration = input;
            self
        }
        /// Appends an item to `default_capacity_provider_strategy`.
        ///
        /// To override the contents of this collection use [`set_default_capacity_provider_strategy`](Self::set_default_capacity_provider_strategy).
        ///
        /// <p>The default capacity provider strategy for the cluster. The default capacity provider strategy is used when services or tasks are run without a specified launch type or capacity provider strategy.</p>
        pub fn default_capacity_provider_strategy(
            mut self,
            input: crate::model::AwsEcsClusterDefaultCapacityProviderStrategyDetails,
        ) -> Self {
            let mut v = self.default_capacity_provider_strategy.unwrap_or_default();
            v.push(input);
            self.default_capacity_provider_strategy = Some(v);
            self
        }
        /// <p>The default capacity provider strategy for the cluster. The default capacity provider strategy is used when services or tasks are run without a specified launch type or capacity provider strategy.</p>
        pub fn set_default_capacity_provider_strategy(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEcsClusterDefaultCapacityProviderStrategyDetails>,
            >,
        ) -> Self {
            self.default_capacity_provider_strategy = input;
            self
        }
        /// <p>A name that you use to identify your cluster. </p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_name = Some(input.into());
            self
        }
        /// <p>A name that you use to identify your cluster. </p>
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cluster_name = input;
            self
        }
        /// <p>The number of container instances registered into the cluster. This includes container instances in both <code>ACTIVE</code> and <code>DRAINING</code> status. </p>
        pub fn registered_container_instances_count(mut self, input: i32) -> Self {
            self.registered_container_instances_count = Some(input);
            self
        }
        /// <p>The number of container instances registered into the cluster. This includes container instances in both <code>ACTIVE</code> and <code>DRAINING</code> status. </p>
        pub fn set_registered_container_instances_count(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.registered_container_instances_count = input;
            self
        }
        /// <p>The number of tasks in the cluster that are in the <code>RUNNING</code> state. </p>
        pub fn running_tasks_count(mut self, input: i32) -> Self {
            self.running_tasks_count = Some(input);
            self
        }
        /// <p>The number of tasks in the cluster that are in the <code>RUNNING</code> state. </p>
        pub fn set_running_tasks_count(mut self, input: std::option::Option<i32>) -> Self {
            self.running_tasks_count = input;
            self
        }
        /// <p>The status of the cluster. </p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the cluster. </p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsClusterDetails`](crate::model::AwsEcsClusterDetails)
        pub fn build(self) -> crate::model::AwsEcsClusterDetails {
            crate::model::AwsEcsClusterDetails {
                cluster_arn: self.cluster_arn,
                active_services_count: self.active_services_count.unwrap_or_default(),
                capacity_providers: self.capacity_providers,
                cluster_settings: self.cluster_settings,
                configuration: self.configuration,
                default_capacity_provider_strategy: self.default_capacity_provider_strategy,
                cluster_name: self.cluster_name,
                registered_container_instances_count: self
                    .registered_container_instances_count
                    .unwrap_or_default(),
                running_tasks_count: self.running_tasks_count.unwrap_or_default(),
                status: self.status,
            }
        }
    }
}
impl AwsEcsClusterDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsClusterDetails`](crate::model::AwsEcsClusterDetails)
    pub fn builder() -> crate::model::aws_ecs_cluster_details::Builder {
        crate::model::aws_ecs_cluster_details::Builder::default()
    }
}

/// <p>The default capacity provider strategy for the cluster. The default capacity provider strategy is used when services or tasks are run without a specified launch type or capacity provider strategy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsClusterDefaultCapacityProviderStrategyDetails {
    /// <p>The minimum number of tasks to run on the specified capacity provider.</p>
    pub base: i32,
    /// <p>The name of the capacity provider.</p>
    pub capacity_provider: std::option::Option<std::string::String>,
    /// <p>The relative percentage of the total number of tasks launched that should use the capacity provider.</p>
    pub weight: i32,
}
impl AwsEcsClusterDefaultCapacityProviderStrategyDetails {
    /// <p>The minimum number of tasks to run on the specified capacity provider.</p>
    pub fn base(&self) -> i32 {
        self.base
    }
    /// <p>The name of the capacity provider.</p>
    pub fn capacity_provider(&self) -> std::option::Option<&str> {
        self.capacity_provider.as_deref()
    }
    /// <p>The relative percentage of the total number of tasks launched that should use the capacity provider.</p>
    pub fn weight(&self) -> i32 {
        self.weight
    }
}
impl std::fmt::Debug for AwsEcsClusterDefaultCapacityProviderStrategyDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcsClusterDefaultCapacityProviderStrategyDetails");
        formatter.field("base", &self.base);
        formatter.field("capacity_provider", &self.capacity_provider);
        formatter.field("weight", &self.weight);
        formatter.finish()
    }
}
/// See [`AwsEcsClusterDefaultCapacityProviderStrategyDetails`](crate::model::AwsEcsClusterDefaultCapacityProviderStrategyDetails)
pub mod aws_ecs_cluster_default_capacity_provider_strategy_details {

    /// A builder for [`AwsEcsClusterDefaultCapacityProviderStrategyDetails`](crate::model::AwsEcsClusterDefaultCapacityProviderStrategyDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) base: std::option::Option<i32>,
        pub(crate) capacity_provider: std::option::Option<std::string::String>,
        pub(crate) weight: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The minimum number of tasks to run on the specified capacity provider.</p>
        pub fn base(mut self, input: i32) -> Self {
            self.base = Some(input);
            self
        }
        /// <p>The minimum number of tasks to run on the specified capacity provider.</p>
        pub fn set_base(mut self, input: std::option::Option<i32>) -> Self {
            self.base = input;
            self
        }
        /// <p>The name of the capacity provider.</p>
        pub fn capacity_provider(mut self, input: impl Into<std::string::String>) -> Self {
            self.capacity_provider = Some(input.into());
            self
        }
        /// <p>The name of the capacity provider.</p>
        pub fn set_capacity_provider(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.capacity_provider = input;
            self
        }
        /// <p>The relative percentage of the total number of tasks launched that should use the capacity provider.</p>
        pub fn weight(mut self, input: i32) -> Self {
            self.weight = Some(input);
            self
        }
        /// <p>The relative percentage of the total number of tasks launched that should use the capacity provider.</p>
        pub fn set_weight(mut self, input: std::option::Option<i32>) -> Self {
            self.weight = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsClusterDefaultCapacityProviderStrategyDetails`](crate::model::AwsEcsClusterDefaultCapacityProviderStrategyDetails)
        pub fn build(self) -> crate::model::AwsEcsClusterDefaultCapacityProviderStrategyDetails {
            crate::model::AwsEcsClusterDefaultCapacityProviderStrategyDetails {
                base: self.base.unwrap_or_default(),
                capacity_provider: self.capacity_provider,
                weight: self.weight.unwrap_or_default(),
            }
        }
    }
}
impl AwsEcsClusterDefaultCapacityProviderStrategyDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsClusterDefaultCapacityProviderStrategyDetails`](crate::model::AwsEcsClusterDefaultCapacityProviderStrategyDetails)
    pub fn builder(
    ) -> crate::model::aws_ecs_cluster_default_capacity_provider_strategy_details::Builder {
        crate::model::aws_ecs_cluster_default_capacity_provider_strategy_details::Builder::default()
    }
}

/// <p>The run command configuration for the cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsClusterConfigurationDetails {
    /// <p>Contains the run command configuration for the cluster.</p>
    pub execute_command_configuration: std::option::Option<
        crate::model::AwsEcsClusterConfigurationExecuteCommandConfigurationDetails,
    >,
}
impl AwsEcsClusterConfigurationDetails {
    /// <p>Contains the run command configuration for the cluster.</p>
    pub fn execute_command_configuration(
        &self,
    ) -> std::option::Option<
        &crate::model::AwsEcsClusterConfigurationExecuteCommandConfigurationDetails,
    > {
        self.execute_command_configuration.as_ref()
    }
}
impl std::fmt::Debug for AwsEcsClusterConfigurationDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcsClusterConfigurationDetails");
        formatter.field(
            "execute_command_configuration",
            &self.execute_command_configuration,
        );
        formatter.finish()
    }
}
/// See [`AwsEcsClusterConfigurationDetails`](crate::model::AwsEcsClusterConfigurationDetails)
pub mod aws_ecs_cluster_configuration_details {

    /// A builder for [`AwsEcsClusterConfigurationDetails`](crate::model::AwsEcsClusterConfigurationDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) execute_command_configuration: std::option::Option<
            crate::model::AwsEcsClusterConfigurationExecuteCommandConfigurationDetails,
        >,
    }
    impl Builder {
        /// <p>Contains the run command configuration for the cluster.</p>
        pub fn execute_command_configuration(
            mut self,
            input: crate::model::AwsEcsClusterConfigurationExecuteCommandConfigurationDetails,
        ) -> Self {
            self.execute_command_configuration = Some(input);
            self
        }
        /// <p>Contains the run command configuration for the cluster.</p>
        pub fn set_execute_command_configuration(
            mut self,
            input: std::option::Option<
                crate::model::AwsEcsClusterConfigurationExecuteCommandConfigurationDetails,
            >,
        ) -> Self {
            self.execute_command_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsClusterConfigurationDetails`](crate::model::AwsEcsClusterConfigurationDetails)
        pub fn build(self) -> crate::model::AwsEcsClusterConfigurationDetails {
            crate::model::AwsEcsClusterConfigurationDetails {
                execute_command_configuration: self.execute_command_configuration,
            }
        }
    }
}
impl AwsEcsClusterConfigurationDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsClusterConfigurationDetails`](crate::model::AwsEcsClusterConfigurationDetails)
    pub fn builder() -> crate::model::aws_ecs_cluster_configuration_details::Builder {
        crate::model::aws_ecs_cluster_configuration_details::Builder::default()
    }
}

/// <p>Contains the run command configuration for the cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsClusterConfigurationExecuteCommandConfigurationDetails {
    /// <p>The identifier of the KMS key that is used to encrypt the data between the local client and the container.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The log configuration for the results of the run command actions. Required if <code>Logging</code> is <code>NONE</code>.</p>
    pub log_configuration: std::option::Option<
        crate::model::AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails,
    >,
    /// <p>The log setting to use for redirecting logs for run command results.</p>
    pub logging: std::option::Option<std::string::String>,
}
impl AwsEcsClusterConfigurationExecuteCommandConfigurationDetails {
    /// <p>The identifier of the KMS key that is used to encrypt the data between the local client and the container.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>The log configuration for the results of the run command actions. Required if <code>Logging</code> is <code>NONE</code>.</p>
    pub fn log_configuration(
        &self,
    ) -> std::option::Option<
        &crate::model::AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails,
    > {
        self.log_configuration.as_ref()
    }
    /// <p>The log setting to use for redirecting logs for run command results.</p>
    pub fn logging(&self) -> std::option::Option<&str> {
        self.logging.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsClusterConfigurationExecuteCommandConfigurationDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsEcsClusterConfigurationExecuteCommandConfigurationDetails");
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("log_configuration", &self.log_configuration);
        formatter.field("logging", &self.logging);
        formatter.finish()
    }
}
/// See [`AwsEcsClusterConfigurationExecuteCommandConfigurationDetails`](crate::model::AwsEcsClusterConfigurationExecuteCommandConfigurationDetails)
pub mod aws_ecs_cluster_configuration_execute_command_configuration_details {

    /// A builder for [`AwsEcsClusterConfigurationExecuteCommandConfigurationDetails`](crate::model::AwsEcsClusterConfigurationExecuteCommandConfigurationDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) log_configuration: std::option::Option<crate::model::AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails>,
        pub(crate) logging: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the KMS key that is used to encrypt the data between the local client and the container.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The identifier of the KMS key that is used to encrypt the data between the local client and the container.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The log configuration for the results of the run command actions. Required if <code>Logging</code> is <code>NONE</code>.</p>
        pub fn log_configuration(
            mut self,
            input: crate::model::AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails,
        ) -> Self {
            self.log_configuration = Some(input);
            self
        }
        /// <p>The log configuration for the results of the run command actions. Required if <code>Logging</code> is <code>NONE</code>.</p>
        pub fn set_log_configuration(
            mut self,
            input: std::option::Option<crate::model::AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails>,
        ) -> Self {
            self.log_configuration = input;
            self
        }
        /// <p>The log setting to use for redirecting logs for run command results.</p>
        pub fn logging(mut self, input: impl Into<std::string::String>) -> Self {
            self.logging = Some(input.into());
            self
        }
        /// <p>The log setting to use for redirecting logs for run command results.</p>
        pub fn set_logging(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logging = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsClusterConfigurationExecuteCommandConfigurationDetails`](crate::model::AwsEcsClusterConfigurationExecuteCommandConfigurationDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsEcsClusterConfigurationExecuteCommandConfigurationDetails {
            crate::model::AwsEcsClusterConfigurationExecuteCommandConfigurationDetails {
                kms_key_id: self.kms_key_id,
                log_configuration: self.log_configuration,
                logging: self.logging,
            }
        }
    }
}
impl AwsEcsClusterConfigurationExecuteCommandConfigurationDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsClusterConfigurationExecuteCommandConfigurationDetails`](crate::model::AwsEcsClusterConfigurationExecuteCommandConfigurationDetails)
    pub fn builder(
    ) -> crate::model::aws_ecs_cluster_configuration_execute_command_configuration_details::Builder
    {
        crate::model::aws_ecs_cluster_configuration_execute_command_configuration_details::Builder::default()
    }
}

/// <p>The log configuration for the results of the run command actions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails {
    /// <p>Whether to enable encryption on the CloudWatch logs.</p>
    pub cloud_watch_encryption_enabled: bool,
    /// <p>The name of the CloudWatch log group to send the logs to.</p>
    pub cloud_watch_log_group_name: std::option::Option<std::string::String>,
    /// <p>The name of the S3 bucket to send logs to.</p>
    pub s3_bucket_name: std::option::Option<std::string::String>,
    /// <p>Whether to encrypt the logs that are sent to the S3 bucket.</p>
    pub s3_encryption_enabled: bool,
    /// <p>Identifies the folder in the S3 bucket to send the logs to.</p>
    pub s3_key_prefix: std::option::Option<std::string::String>,
}
impl AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails {
    /// <p>Whether to enable encryption on the CloudWatch logs.</p>
    pub fn cloud_watch_encryption_enabled(&self) -> bool {
        self.cloud_watch_encryption_enabled
    }
    /// <p>The name of the CloudWatch log group to send the logs to.</p>
    pub fn cloud_watch_log_group_name(&self) -> std::option::Option<&str> {
        self.cloud_watch_log_group_name.as_deref()
    }
    /// <p>The name of the S3 bucket to send logs to.</p>
    pub fn s3_bucket_name(&self) -> std::option::Option<&str> {
        self.s3_bucket_name.as_deref()
    }
    /// <p>Whether to encrypt the logs that are sent to the S3 bucket.</p>
    pub fn s3_encryption_enabled(&self) -> bool {
        self.s3_encryption_enabled
    }
    /// <p>Identifies the folder in the S3 bucket to send the logs to.</p>
    pub fn s3_key_prefix(&self) -> std::option::Option<&str> {
        self.s3_key_prefix.as_deref()
    }
}
impl std::fmt::Debug
    for AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct(
            "AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails",
        );
        formatter.field(
            "cloud_watch_encryption_enabled",
            &self.cloud_watch_encryption_enabled,
        );
        formatter.field(
            "cloud_watch_log_group_name",
            &self.cloud_watch_log_group_name,
        );
        formatter.field("s3_bucket_name", &self.s3_bucket_name);
        formatter.field("s3_encryption_enabled", &self.s3_encryption_enabled);
        formatter.field("s3_key_prefix", &self.s3_key_prefix);
        formatter.finish()
    }
}
/// See [`AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails`](crate::model::AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails)
pub mod aws_ecs_cluster_configuration_execute_command_configuration_log_configuration_details {

    /// A builder for [`AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails`](crate::model::AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cloud_watch_encryption_enabled: std::option::Option<bool>,
        pub(crate) cloud_watch_log_group_name: std::option::Option<std::string::String>,
        pub(crate) s3_bucket_name: std::option::Option<std::string::String>,
        pub(crate) s3_encryption_enabled: std::option::Option<bool>,
        pub(crate) s3_key_prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Whether to enable encryption on the CloudWatch logs.</p>
        pub fn cloud_watch_encryption_enabled(mut self, input: bool) -> Self {
            self.cloud_watch_encryption_enabled = Some(input);
            self
        }
        /// <p>Whether to enable encryption on the CloudWatch logs.</p>
        pub fn set_cloud_watch_encryption_enabled(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.cloud_watch_encryption_enabled = input;
            self
        }
        /// <p>The name of the CloudWatch log group to send the logs to.</p>
        pub fn cloud_watch_log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.cloud_watch_log_group_name = Some(input.into());
            self
        }
        /// <p>The name of the CloudWatch log group to send the logs to.</p>
        pub fn set_cloud_watch_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cloud_watch_log_group_name = input;
            self
        }
        /// <p>The name of the S3 bucket to send logs to.</p>
        pub fn s3_bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket_name = Some(input.into());
            self
        }
        /// <p>The name of the S3 bucket to send logs to.</p>
        pub fn set_s3_bucket_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_bucket_name = input;
            self
        }
        /// <p>Whether to encrypt the logs that are sent to the S3 bucket.</p>
        pub fn s3_encryption_enabled(mut self, input: bool) -> Self {
            self.s3_encryption_enabled = Some(input);
            self
        }
        /// <p>Whether to encrypt the logs that are sent to the S3 bucket.</p>
        pub fn set_s3_encryption_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.s3_encryption_enabled = input;
            self
        }
        /// <p>Identifies the folder in the S3 bucket to send the logs to.</p>
        pub fn s3_key_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_key_prefix = Some(input.into());
            self
        }
        /// <p>Identifies the folder in the S3 bucket to send the logs to.</p>
        pub fn set_s3_key_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_key_prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails`](crate::model::AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails)
        pub fn build(self) -> crate::model::AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails{
            crate::model::AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails {
                cloud_watch_encryption_enabled: self.cloud_watch_encryption_enabled
                    .unwrap_or_default()
                ,
                cloud_watch_log_group_name: self.cloud_watch_log_group_name
                ,
                s3_bucket_name: self.s3_bucket_name
                ,
                s3_encryption_enabled: self.s3_encryption_enabled
                    .unwrap_or_default()
                ,
                s3_key_prefix: self.s3_key_prefix
                ,
            }
        }
    }
}
impl AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails`](crate::model::AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails)
    pub fn builder() -> crate::model::aws_ecs_cluster_configuration_execute_command_configuration_log_configuration_details::Builder{
        crate::model::aws_ecs_cluster_configuration_execute_command_configuration_log_configuration_details::Builder::default()
    }
}

/// <p>Indicates whether to enable CloudWatch Container Insights for the ECS cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEcsClusterClusterSettingsDetails {
    /// <p>The name of the setting.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The value of the setting.</p>
    pub value: std::option::Option<std::string::String>,
}
impl AwsEcsClusterClusterSettingsDetails {
    /// <p>The name of the setting.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The value of the setting.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for AwsEcsClusterClusterSettingsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEcsClusterClusterSettingsDetails");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`AwsEcsClusterClusterSettingsDetails`](crate::model::AwsEcsClusterClusterSettingsDetails)
pub mod aws_ecs_cluster_cluster_settings_details {

    /// A builder for [`AwsEcsClusterClusterSettingsDetails`](crate::model::AwsEcsClusterClusterSettingsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the setting.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the setting.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The value of the setting.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the setting.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEcsClusterClusterSettingsDetails`](crate::model::AwsEcsClusterClusterSettingsDetails)
        pub fn build(self) -> crate::model::AwsEcsClusterClusterSettingsDetails {
            crate::model::AwsEcsClusterClusterSettingsDetails {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl AwsEcsClusterClusterSettingsDetails {
    /// Creates a new builder-style object to manufacture [`AwsEcsClusterClusterSettingsDetails`](crate::model::AwsEcsClusterClusterSettingsDetails)
    pub fn builder() -> crate::model::aws_ecs_cluster_cluster_settings_details::Builder {
        crate::model::aws_ecs_cluster_cluster_settings_details::Builder::default()
    }
}

/// <p>Information about an Amazon RDS DB cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRdsDbClusterDetails {
    /// <p>For all database engines except Aurora, specifies the allocated storage size in gibibytes (GiB).</p>
    pub allocated_storage: i32,
    /// <p>A list of Availability Zones (AZs) where instances in the DB cluster can be created.</p>
    pub availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The number of days for which automated backups are retained.</p>
    pub backup_retention_period: i32,
    /// <p>The name of the database.</p>
    pub database_name: std::option::Option<std::string::String>,
    /// <p>The current status of this DB cluster.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>The connection endpoint for the primary instance of the DB cluster.</p>
    pub endpoint: std::option::Option<std::string::String>,
    /// <p>The reader endpoint for the DB cluster.</p>
    pub reader_endpoint: std::option::Option<std::string::String>,
    /// <p>A list of custom endpoints for the DB cluster.</p>
    pub custom_endpoints: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Whether the DB cluster has instances in multiple Availability Zones.</p>
    pub multi_az: bool,
    /// <p>The name of the database engine to use for this DB cluster.</p>
    pub engine: std::option::Option<std::string::String>,
    /// <p>The version number of the database engine to use.</p>
    pub engine_version: std::option::Option<std::string::String>,
    /// <p>The port number on which the DB instances in the DB cluster accept connections.</p>
    pub port: i32,
    /// <p>The name of the master user for the DB cluster.</p>
    pub master_username: std::option::Option<std::string::String>,
    /// <p>The range of time each day when automated backups are created, if automated backups are enabled.</p>
    /// <p>Uses the format <code>HH:MM-HH:MM</code>. For example, <code>04:52-05:22</code>.</p>
    pub preferred_backup_window: std::option::Option<std::string::String>,
    /// <p>The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).</p>
    /// <p>Uses the format <code>
    /// <day>
    /// :HH:MM-
    /// <day>
    /// :HH:MM
    /// </day>
    /// </day></code>.</p>
    /// <p>For the day values, use <code>mon</code>|<code>tue</code>|<code>wed</code>|<code>thu</code>|<code>fri</code>|<code>sat</code>|<code>sun</code>.</p>
    /// <p>For example, <code>sun:09:32-sun:10:02</code>.</p>
    pub preferred_maintenance_window: std::option::Option<std::string::String>,
    /// <p>The identifiers of the read replicas that are associated with this DB cluster.</p>
    pub read_replica_identifiers: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of VPC security groups that the DB cluster belongs to.</p>
    pub vpc_security_groups:
        std::option::Option<std::vec::Vec<crate::model::AwsRdsDbInstanceVpcSecurityGroup>>,
    /// <p>Specifies the identifier that Amazon Route 53 assigns when you create a hosted zone.</p>
    pub hosted_zone_id: std::option::Option<std::string::String>,
    /// <p>Whether the DB cluster is encrypted.</p>
    pub storage_encrypted: bool,
    /// <p>The ARN of the KMS master key that is used to encrypt the database instances in the DB cluster.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the DB cluster. The identifier must be unique within each Amazon Web Services Region and is immutable.</p>
    pub db_cluster_resource_id: std::option::Option<std::string::String>,
    /// <p>A list of the IAM roles that are associated with the DB cluster.</p>
    pub associated_roles:
        std::option::Option<std::vec::Vec<crate::model::AwsRdsDbClusterAssociatedRole>>,
    /// <p>Indicates when the DB cluster was created, in Universal Coordinated Time (UTC).</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub cluster_create_time: std::option::Option<std::string::String>,
    /// <p>A list of log types that this DB cluster is configured to export to CloudWatch Logs.</p>
    pub enabled_cloud_watch_logs_exports: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The database engine mode of the DB cluster.</p>
    pub engine_mode: std::option::Option<std::string::String>,
    /// <p>Whether the DB cluster has deletion protection enabled.</p>
    pub deletion_protection: bool,
    /// <p>Whether the HTTP endpoint for an Aurora Serverless DB cluster is enabled.</p>
    pub http_endpoint_enabled: bool,
    /// <p>The status of the database activity stream.</p>
    pub activity_stream_status: std::option::Option<std::string::String>,
    /// <p>Whether tags are copied from the DB cluster to snapshots of the DB cluster.</p>
    pub copy_tags_to_snapshot: bool,
    /// <p>Whether the DB cluster is a clone of a DB cluster owned by a different Amazon Web Services account.</p>
    pub cross_account_clone: bool,
    /// <p>The Active Directory domain membership records that are associated with the DB cluster.</p>
    pub domain_memberships:
        std::option::Option<std::vec::Vec<crate::model::AwsRdsDbDomainMembership>>,
    /// <p>The name of the DB cluster parameter group for the DB cluster.</p>
    pub db_cluster_parameter_group: std::option::Option<std::string::String>,
    /// <p>The subnet group that is associated with the DB cluster, including the name, description, and subnets in the subnet group.</p>
    pub db_subnet_group: std::option::Option<std::string::String>,
    /// <p>The list of option group memberships for this DB cluster.</p>
    pub db_cluster_option_group_memberships:
        std::option::Option<std::vec::Vec<crate::model::AwsRdsDbClusterOptionGroupMembership>>,
    /// <p>The DB cluster identifier that the user assigned to the cluster. This identifier is the unique key that identifies a DB cluster.</p>
    pub db_cluster_identifier: std::option::Option<std::string::String>,
    /// <p>The list of instances that make up the DB cluster.</p>
    pub db_cluster_members: std::option::Option<std::vec::Vec<crate::model::AwsRdsDbClusterMember>>,
    /// <p>Whether the mapping of IAM accounts to database accounts is enabled.</p>
    pub iam_database_authentication_enabled: bool,
}
impl AwsRdsDbClusterDetails {
    /// <p>For all database engines except Aurora, specifies the allocated storage size in gibibytes (GiB).</p>
    pub fn allocated_storage(&self) -> i32 {
        self.allocated_storage
    }
    /// <p>A list of Availability Zones (AZs) where instances in the DB cluster can be created.</p>
    pub fn availability_zones(&self) -> std::option::Option<&[std::string::String]> {
        self.availability_zones.as_deref()
    }
    /// <p>The number of days for which automated backups are retained.</p>
    pub fn backup_retention_period(&self) -> i32 {
        self.backup_retention_period
    }
    /// <p>The name of the database.</p>
    pub fn database_name(&self) -> std::option::Option<&str> {
        self.database_name.as_deref()
    }
    /// <p>The current status of this DB cluster.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>The connection endpoint for the primary instance of the DB cluster.</p>
    pub fn endpoint(&self) -> std::option::Option<&str> {
        self.endpoint.as_deref()
    }
    /// <p>The reader endpoint for the DB cluster.</p>
    pub fn reader_endpoint(&self) -> std::option::Option<&str> {
        self.reader_endpoint.as_deref()
    }
    /// <p>A list of custom endpoints for the DB cluster.</p>
    pub fn custom_endpoints(&self) -> std::option::Option<&[std::string::String]> {
        self.custom_endpoints.as_deref()
    }
    /// <p>Whether the DB cluster has instances in multiple Availability Zones.</p>
    pub fn multi_az(&self) -> bool {
        self.multi_az
    }
    /// <p>The name of the database engine to use for this DB cluster.</p>
    pub fn engine(&self) -> std::option::Option<&str> {
        self.engine.as_deref()
    }
    /// <p>The version number of the database engine to use.</p>
    pub fn engine_version(&self) -> std::option::Option<&str> {
        self.engine_version.as_deref()
    }
    /// <p>The port number on which the DB instances in the DB cluster accept connections.</p>
    pub fn port(&self) -> i32 {
        self.port
    }
    /// <p>The name of the master user for the DB cluster.</p>
    pub fn master_username(&self) -> std::option::Option<&str> {
        self.master_username.as_deref()
    }
    /// <p>The range of time each day when automated backups are created, if automated backups are enabled.</p>
    /// <p>Uses the format <code>HH:MM-HH:MM</code>. For example, <code>04:52-05:22</code>.</p>
    pub fn preferred_backup_window(&self) -> std::option::Option<&str> {
        self.preferred_backup_window.as_deref()
    }
    /// <p>The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).</p>
    /// <p>Uses the format <code>
    /// <day>
    /// :HH:MM-
    /// <day>
    /// :HH:MM
    /// </day>
    /// </day></code>.</p>
    /// <p>For the day values, use <code>mon</code>|<code>tue</code>|<code>wed</code>|<code>thu</code>|<code>fri</code>|<code>sat</code>|<code>sun</code>.</p>
    /// <p>For example, <code>sun:09:32-sun:10:02</code>.</p>
    pub fn preferred_maintenance_window(&self) -> std::option::Option<&str> {
        self.preferred_maintenance_window.as_deref()
    }
    /// <p>The identifiers of the read replicas that are associated with this DB cluster.</p>
    pub fn read_replica_identifiers(&self) -> std::option::Option<&[std::string::String]> {
        self.read_replica_identifiers.as_deref()
    }
    /// <p>A list of VPC security groups that the DB cluster belongs to.</p>
    pub fn vpc_security_groups(
        &self,
    ) -> std::option::Option<&[crate::model::AwsRdsDbInstanceVpcSecurityGroup]> {
        self.vpc_security_groups.as_deref()
    }
    /// <p>Specifies the identifier that Amazon Route 53 assigns when you create a hosted zone.</p>
    pub fn hosted_zone_id(&self) -> std::option::Option<&str> {
        self.hosted_zone_id.as_deref()
    }
    /// <p>Whether the DB cluster is encrypted.</p>
    pub fn storage_encrypted(&self) -> bool {
        self.storage_encrypted
    }
    /// <p>The ARN of the KMS master key that is used to encrypt the database instances in the DB cluster.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>The identifier of the DB cluster. The identifier must be unique within each Amazon Web Services Region and is immutable.</p>
    pub fn db_cluster_resource_id(&self) -> std::option::Option<&str> {
        self.db_cluster_resource_id.as_deref()
    }
    /// <p>A list of the IAM roles that are associated with the DB cluster.</p>
    pub fn associated_roles(
        &self,
    ) -> std::option::Option<&[crate::model::AwsRdsDbClusterAssociatedRole]> {
        self.associated_roles.as_deref()
    }
    /// <p>Indicates when the DB cluster was created, in Universal Coordinated Time (UTC).</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn cluster_create_time(&self) -> std::option::Option<&str> {
        self.cluster_create_time.as_deref()
    }
    /// <p>A list of log types that this DB cluster is configured to export to CloudWatch Logs.</p>
    pub fn enabled_cloud_watch_logs_exports(&self) -> std::option::Option<&[std::string::String]> {
        self.enabled_cloud_watch_logs_exports.as_deref()
    }
    /// <p>The database engine mode of the DB cluster.</p>
    pub fn engine_mode(&self) -> std::option::Option<&str> {
        self.engine_mode.as_deref()
    }
    /// <p>Whether the DB cluster has deletion protection enabled.</p>
    pub fn deletion_protection(&self) -> bool {
        self.deletion_protection
    }
    /// <p>Whether the HTTP endpoint for an Aurora Serverless DB cluster is enabled.</p>
    pub fn http_endpoint_enabled(&self) -> bool {
        self.http_endpoint_enabled
    }
    /// <p>The status of the database activity stream.</p>
    pub fn activity_stream_status(&self) -> std::option::Option<&str> {
        self.activity_stream_status.as_deref()
    }
    /// <p>Whether tags are copied from the DB cluster to snapshots of the DB cluster.</p>
    pub fn copy_tags_to_snapshot(&self) -> bool {
        self.copy_tags_to_snapshot
    }
    /// <p>Whether the DB cluster is a clone of a DB cluster owned by a different Amazon Web Services account.</p>
    pub fn cross_account_clone(&self) -> bool {
        self.cross_account_clone
    }
    /// <p>The Active Directory domain membership records that are associated with the DB cluster.</p>
    pub fn domain_memberships(
        &self,
    ) -> std::option::Option<&[crate::model::AwsRdsDbDomainMembership]> {
        self.domain_memberships.as_deref()
    }
    /// <p>The name of the DB cluster parameter group for the DB cluster.</p>
    pub fn db_cluster_parameter_group(&self) -> std::option::Option<&str> {
        self.db_cluster_parameter_group.as_deref()
    }
    /// <p>The subnet group that is associated with the DB cluster, including the name, description, and subnets in the subnet group.</p>
    pub fn db_subnet_group(&self) -> std::option::Option<&str> {
        self.db_subnet_group.as_deref()
    }
    /// <p>The list of option group memberships for this DB cluster.</p>
    pub fn db_cluster_option_group_memberships(
        &self,
    ) -> std::option::Option<&[crate::model::AwsRdsDbClusterOptionGroupMembership]> {
        self.db_cluster_option_group_memberships.as_deref()
    }
    /// <p>The DB cluster identifier that the user assigned to the cluster. This identifier is the unique key that identifies a DB cluster.</p>
    pub fn db_cluster_identifier(&self) -> std::option::Option<&str> {
        self.db_cluster_identifier.as_deref()
    }
    /// <p>The list of instances that make up the DB cluster.</p>
    pub fn db_cluster_members(
        &self,
    ) -> std::option::Option<&[crate::model::AwsRdsDbClusterMember]> {
        self.db_cluster_members.as_deref()
    }
    /// <p>Whether the mapping of IAM accounts to database accounts is enabled.</p>
    pub fn iam_database_authentication_enabled(&self) -> bool {
        self.iam_database_authentication_enabled
    }
}
impl std::fmt::Debug for AwsRdsDbClusterDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRdsDbClusterDetails");
        formatter.field("allocated_storage", &self.allocated_storage);
        formatter.field("availability_zones", &self.availability_zones);
        formatter.field("backup_retention_period", &self.backup_retention_period);
        formatter.field("database_name", &self.database_name);
        formatter.field("status", &self.status);
        formatter.field("endpoint", &self.endpoint);
        formatter.field("reader_endpoint", &self.reader_endpoint);
        formatter.field("custom_endpoints", &self.custom_endpoints);
        formatter.field("multi_az", &self.multi_az);
        formatter.field("engine", &self.engine);
        formatter.field("engine_version", &self.engine_version);
        formatter.field("port", &self.port);
        formatter.field("master_username", &self.master_username);
        formatter.field("preferred_backup_window", &self.preferred_backup_window);
        formatter.field(
            "preferred_maintenance_window",
            &self.preferred_maintenance_window,
        );
        formatter.field("read_replica_identifiers", &self.read_replica_identifiers);
        formatter.field("vpc_security_groups", &self.vpc_security_groups);
        formatter.field("hosted_zone_id", &self.hosted_zone_id);
        formatter.field("storage_encrypted", &self.storage_encrypted);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("db_cluster_resource_id", &self.db_cluster_resource_id);
        formatter.field("associated_roles", &self.associated_roles);
        formatter.field("cluster_create_time", &self.cluster_create_time);
        formatter.field(
            "enabled_cloud_watch_logs_exports",
            &self.enabled_cloud_watch_logs_exports,
        );
        formatter.field("engine_mode", &self.engine_mode);
        formatter.field("deletion_protection", &self.deletion_protection);
        formatter.field("http_endpoint_enabled", &self.http_endpoint_enabled);
        formatter.field("activity_stream_status", &self.activity_stream_status);
        formatter.field("copy_tags_to_snapshot", &self.copy_tags_to_snapshot);
        formatter.field("cross_account_clone", &self.cross_account_clone);
        formatter.field("domain_memberships", &self.domain_memberships);
        formatter.field(
            "db_cluster_parameter_group",
            &self.db_cluster_parameter_group,
        );
        formatter.field("db_subnet_group", &self.db_subnet_group);
        formatter.field(
            "db_cluster_option_group_memberships",
            &self.db_cluster_option_group_memberships,
        );
        formatter.field("db_cluster_identifier", &self.db_cluster_identifier);
        formatter.field("db_cluster_members", &self.db_cluster_members);
        formatter.field(
            "iam_database_authentication_enabled",
            &self.iam_database_authentication_enabled,
        );
        formatter.finish()
    }
}
/// See [`AwsRdsDbClusterDetails`](crate::model::AwsRdsDbClusterDetails)
pub mod aws_rds_db_cluster_details {

    /// A builder for [`AwsRdsDbClusterDetails`](crate::model::AwsRdsDbClusterDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) allocated_storage: std::option::Option<i32>,
        pub(crate) availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) backup_retention_period: std::option::Option<i32>,
        pub(crate) database_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) endpoint: std::option::Option<std::string::String>,
        pub(crate) reader_endpoint: std::option::Option<std::string::String>,
        pub(crate) custom_endpoints: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) multi_az: std::option::Option<bool>,
        pub(crate) engine: std::option::Option<std::string::String>,
        pub(crate) engine_version: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) master_username: std::option::Option<std::string::String>,
        pub(crate) preferred_backup_window: std::option::Option<std::string::String>,
        pub(crate) preferred_maintenance_window: std::option::Option<std::string::String>,
        pub(crate) read_replica_identifiers:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) vpc_security_groups:
            std::option::Option<std::vec::Vec<crate::model::AwsRdsDbInstanceVpcSecurityGroup>>,
        pub(crate) hosted_zone_id: std::option::Option<std::string::String>,
        pub(crate) storage_encrypted: std::option::Option<bool>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) db_cluster_resource_id: std::option::Option<std::string::String>,
        pub(crate) associated_roles:
            std::option::Option<std::vec::Vec<crate::model::AwsRdsDbClusterAssociatedRole>>,
        pub(crate) cluster_create_time: std::option::Option<std::string::String>,
        pub(crate) enabled_cloud_watch_logs_exports:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) engine_mode: std::option::Option<std::string::String>,
        pub(crate) deletion_protection: std::option::Option<bool>,
        pub(crate) http_endpoint_enabled: std::option::Option<bool>,
        pub(crate) activity_stream_status: std::option::Option<std::string::String>,
        pub(crate) copy_tags_to_snapshot: std::option::Option<bool>,
        pub(crate) cross_account_clone: std::option::Option<bool>,
        pub(crate) domain_memberships:
            std::option::Option<std::vec::Vec<crate::model::AwsRdsDbDomainMembership>>,
        pub(crate) db_cluster_parameter_group: std::option::Option<std::string::String>,
        pub(crate) db_subnet_group: std::option::Option<std::string::String>,
        pub(crate) db_cluster_option_group_memberships:
            std::option::Option<std::vec::Vec<crate::model::AwsRdsDbClusterOptionGroupMembership>>,
        pub(crate) db_cluster_identifier: std::option::Option<std::string::String>,
        pub(crate) db_cluster_members:
            std::option::Option<std::vec::Vec<crate::model::AwsRdsDbClusterMember>>,
        pub(crate) iam_database_authentication_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>For all database engines except Aurora, specifies the allocated storage size in gibibytes (GiB).</p>
        pub fn allocated_storage(mut self, input: i32) -> Self {
            self.allocated_storage = Some(input);
            self
        }
        /// <p>For all database engines except Aurora, specifies the allocated storage size in gibibytes (GiB).</p>
        pub fn set_allocated_storage(mut self, input: std::option::Option<i32>) -> Self {
            self.allocated_storage = input;
            self
        }
        /// Appends an item to `availability_zones`.
        ///
        /// To override the contents of this collection use [`set_availability_zones`](Self::set_availability_zones).
        ///
        /// <p>A list of Availability Zones (AZs) where instances in the DB cluster can be created.</p>
        pub fn availability_zones(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.availability_zones.unwrap_or_default();
            v.push(input.into());
            self.availability_zones = Some(v);
            self
        }
        /// <p>A list of Availability Zones (AZs) where instances in the DB cluster can be created.</p>
        pub fn set_availability_zones(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.availability_zones = input;
            self
        }
        /// <p>The number of days for which automated backups are retained.</p>
        pub fn backup_retention_period(mut self, input: i32) -> Self {
            self.backup_retention_period = Some(input);
            self
        }
        /// <p>The number of days for which automated backups are retained.</p>
        pub fn set_backup_retention_period(mut self, input: std::option::Option<i32>) -> Self {
            self.backup_retention_period = input;
            self
        }
        /// <p>The name of the database.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_name = Some(input.into());
            self
        }
        /// <p>The name of the database.</p>
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.database_name = input;
            self
        }
        /// <p>The current status of this DB cluster.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The current status of this DB cluster.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>The connection endpoint for the primary instance of the DB cluster.</p>
        pub fn endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint = Some(input.into());
            self
        }
        /// <p>The connection endpoint for the primary instance of the DB cluster.</p>
        pub fn set_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint = input;
            self
        }
        /// <p>The reader endpoint for the DB cluster.</p>
        pub fn reader_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.reader_endpoint = Some(input.into());
            self
        }
        /// <p>The reader endpoint for the DB cluster.</p>
        pub fn set_reader_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reader_endpoint = input;
            self
        }
        /// Appends an item to `custom_endpoints`.
        ///
        /// To override the contents of this collection use [`set_custom_endpoints`](Self::set_custom_endpoints).
        ///
        /// <p>A list of custom endpoints for the DB cluster.</p>
        pub fn custom_endpoints(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.custom_endpoints.unwrap_or_default();
            v.push(input.into());
            self.custom_endpoints = Some(v);
            self
        }
        /// <p>A list of custom endpoints for the DB cluster.</p>
        pub fn set_custom_endpoints(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.custom_endpoints = input;
            self
        }
        /// <p>Whether the DB cluster has instances in multiple Availability Zones.</p>
        pub fn multi_az(mut self, input: bool) -> Self {
            self.multi_az = Some(input);
            self
        }
        /// <p>Whether the DB cluster has instances in multiple Availability Zones.</p>
        pub fn set_multi_az(mut self, input: std::option::Option<bool>) -> Self {
            self.multi_az = input;
            self
        }
        /// <p>The name of the database engine to use for this DB cluster.</p>
        pub fn engine(mut self, input: impl Into<std::string::String>) -> Self {
            self.engine = Some(input.into());
            self
        }
        /// <p>The name of the database engine to use for this DB cluster.</p>
        pub fn set_engine(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.engine = input;
            self
        }
        /// <p>The version number of the database engine to use.</p>
        pub fn engine_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.engine_version = Some(input.into());
            self
        }
        /// <p>The version number of the database engine to use.</p>
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.engine_version = input;
            self
        }
        /// <p>The port number on which the DB instances in the DB cluster accept connections.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>The port number on which the DB instances in the DB cluster accept connections.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// <p>The name of the master user for the DB cluster.</p>
        pub fn master_username(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_username = Some(input.into());
            self
        }
        /// <p>The name of the master user for the DB cluster.</p>
        pub fn set_master_username(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_username = input;
            self
        }
        /// <p>The range of time each day when automated backups are created, if automated backups are enabled.</p>
        /// <p>Uses the format <code>HH:MM-HH:MM</code>. For example, <code>04:52-05:22</code>.</p>
        pub fn preferred_backup_window(mut self, input: impl Into<std::string::String>) -> Self {
            self.preferred_backup_window = Some(input.into());
            self
        }
        /// <p>The range of time each day when automated backups are created, if automated backups are enabled.</p>
        /// <p>Uses the format <code>HH:MM-HH:MM</code>. For example, <code>04:52-05:22</code>.</p>
        pub fn set_preferred_backup_window(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.preferred_backup_window = input;
            self
        }
        /// <p>The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).</p>
        /// <p>Uses the format <code>
        /// <day>
        /// :HH:MM-
        /// <day>
        /// :HH:MM
        /// </day>
        /// </day></code>.</p>
        /// <p>For the day values, use <code>mon</code>|<code>tue</code>|<code>wed</code>|<code>thu</code>|<code>fri</code>|<code>sat</code>|<code>sun</code>.</p>
        /// <p>For example, <code>sun:09:32-sun:10:02</code>.</p>
        pub fn preferred_maintenance_window(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.preferred_maintenance_window = Some(input.into());
            self
        }
        /// <p>The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).</p>
        /// <p>Uses the format <code>
        /// <day>
        /// :HH:MM-
        /// <day>
        /// :HH:MM
        /// </day>
        /// </day></code>.</p>
        /// <p>For the day values, use <code>mon</code>|<code>tue</code>|<code>wed</code>|<code>thu</code>|<code>fri</code>|<code>sat</code>|<code>sun</code>.</p>
        /// <p>For example, <code>sun:09:32-sun:10:02</code>.</p>
        pub fn set_preferred_maintenance_window(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.preferred_maintenance_window = input;
            self
        }
        /// Appends an item to `read_replica_identifiers`.
        ///
        /// To override the contents of this collection use [`set_read_replica_identifiers`](Self::set_read_replica_identifiers).
        ///
        /// <p>The identifiers of the read replicas that are associated with this DB cluster.</p>
        pub fn read_replica_identifiers(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.read_replica_identifiers.unwrap_or_default();
            v.push(input.into());
            self.read_replica_identifiers = Some(v);
            self
        }
        /// <p>The identifiers of the read replicas that are associated with this DB cluster.</p>
        pub fn set_read_replica_identifiers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.read_replica_identifiers = input;
            self
        }
        /// Appends an item to `vpc_security_groups`.
        ///
        /// To override the contents of this collection use [`set_vpc_security_groups`](Self::set_vpc_security_groups).
        ///
        /// <p>A list of VPC security groups that the DB cluster belongs to.</p>
        pub fn vpc_security_groups(
            mut self,
            input: crate::model::AwsRdsDbInstanceVpcSecurityGroup,
        ) -> Self {
            let mut v = self.vpc_security_groups.unwrap_or_default();
            v.push(input);
            self.vpc_security_groups = Some(v);
            self
        }
        /// <p>A list of VPC security groups that the DB cluster belongs to.</p>
        pub fn set_vpc_security_groups(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsRdsDbInstanceVpcSecurityGroup>,
            >,
        ) -> Self {
            self.vpc_security_groups = input;
            self
        }
        /// <p>Specifies the identifier that Amazon Route 53 assigns when you create a hosted zone.</p>
        pub fn hosted_zone_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hosted_zone_id = Some(input.into());
            self
        }
        /// <p>Specifies the identifier that Amazon Route 53 assigns when you create a hosted zone.</p>
        pub fn set_hosted_zone_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hosted_zone_id = input;
            self
        }
        /// <p>Whether the DB cluster is encrypted.</p>
        pub fn storage_encrypted(mut self, input: bool) -> Self {
            self.storage_encrypted = Some(input);
            self
        }
        /// <p>Whether the DB cluster is encrypted.</p>
        pub fn set_storage_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.storage_encrypted = input;
            self
        }
        /// <p>The ARN of the KMS master key that is used to encrypt the database instances in the DB cluster.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The ARN of the KMS master key that is used to encrypt the database instances in the DB cluster.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The identifier of the DB cluster. The identifier must be unique within each Amazon Web Services Region and is immutable.</p>
        pub fn db_cluster_resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_cluster_resource_id = Some(input.into());
            self
        }
        /// <p>The identifier of the DB cluster. The identifier must be unique within each Amazon Web Services Region and is immutable.</p>
        pub fn set_db_cluster_resource_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.db_cluster_resource_id = input;
            self
        }
        /// Appends an item to `associated_roles`.
        ///
        /// To override the contents of this collection use [`set_associated_roles`](Self::set_associated_roles).
        ///
        /// <p>A list of the IAM roles that are associated with the DB cluster.</p>
        pub fn associated_roles(
            mut self,
            input: crate::model::AwsRdsDbClusterAssociatedRole,
        ) -> Self {
            let mut v = self.associated_roles.unwrap_or_default();
            v.push(input);
            self.associated_roles = Some(v);
            self
        }
        /// <p>A list of the IAM roles that are associated with the DB cluster.</p>
        pub fn set_associated_roles(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsRdsDbClusterAssociatedRole>>,
        ) -> Self {
            self.associated_roles = input;
            self
        }
        /// <p>Indicates when the DB cluster was created, in Universal Coordinated Time (UTC).</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn cluster_create_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_create_time = Some(input.into());
            self
        }
        /// <p>Indicates when the DB cluster was created, in Universal Coordinated Time (UTC).</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_cluster_create_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_create_time = input;
            self
        }
        /// Appends an item to `enabled_cloud_watch_logs_exports`.
        ///
        /// To override the contents of this collection use [`set_enabled_cloud_watch_logs_exports`](Self::set_enabled_cloud_watch_logs_exports).
        ///
        /// <p>A list of log types that this DB cluster is configured to export to CloudWatch Logs.</p>
        pub fn enabled_cloud_watch_logs_exports(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.enabled_cloud_watch_logs_exports.unwrap_or_default();
            v.push(input.into());
            self.enabled_cloud_watch_logs_exports = Some(v);
            self
        }
        /// <p>A list of log types that this DB cluster is configured to export to CloudWatch Logs.</p>
        pub fn set_enabled_cloud_watch_logs_exports(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.enabled_cloud_watch_logs_exports = input;
            self
        }
        /// <p>The database engine mode of the DB cluster.</p>
        pub fn engine_mode(mut self, input: impl Into<std::string::String>) -> Self {
            self.engine_mode = Some(input.into());
            self
        }
        /// <p>The database engine mode of the DB cluster.</p>
        pub fn set_engine_mode(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.engine_mode = input;
            self
        }
        /// <p>Whether the DB cluster has deletion protection enabled.</p>
        pub fn deletion_protection(mut self, input: bool) -> Self {
            self.deletion_protection = Some(input);
            self
        }
        /// <p>Whether the DB cluster has deletion protection enabled.</p>
        pub fn set_deletion_protection(mut self, input: std::option::Option<bool>) -> Self {
            self.deletion_protection = input;
            self
        }
        /// <p>Whether the HTTP endpoint for an Aurora Serverless DB cluster is enabled.</p>
        pub fn http_endpoint_enabled(mut self, input: bool) -> Self {
            self.http_endpoint_enabled = Some(input);
            self
        }
        /// <p>Whether the HTTP endpoint for an Aurora Serverless DB cluster is enabled.</p>
        pub fn set_http_endpoint_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.http_endpoint_enabled = input;
            self
        }
        /// <p>The status of the database activity stream.</p>
        pub fn activity_stream_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.activity_stream_status = Some(input.into());
            self
        }
        /// <p>The status of the database activity stream.</p>
        pub fn set_activity_stream_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.activity_stream_status = input;
            self
        }
        /// <p>Whether tags are copied from the DB cluster to snapshots of the DB cluster.</p>
        pub fn copy_tags_to_snapshot(mut self, input: bool) -> Self {
            self.copy_tags_to_snapshot = Some(input);
            self
        }
        /// <p>Whether tags are copied from the DB cluster to snapshots of the DB cluster.</p>
        pub fn set_copy_tags_to_snapshot(mut self, input: std::option::Option<bool>) -> Self {
            self.copy_tags_to_snapshot = input;
            self
        }
        /// <p>Whether the DB cluster is a clone of a DB cluster owned by a different Amazon Web Services account.</p>
        pub fn cross_account_clone(mut self, input: bool) -> Self {
            self.cross_account_clone = Some(input);
            self
        }
        /// <p>Whether the DB cluster is a clone of a DB cluster owned by a different Amazon Web Services account.</p>
        pub fn set_cross_account_clone(mut self, input: std::option::Option<bool>) -> Self {
            self.cross_account_clone = input;
            self
        }
        /// Appends an item to `domain_memberships`.
        ///
        /// To override the contents of this collection use [`set_domain_memberships`](Self::set_domain_memberships).
        ///
        /// <p>The Active Directory domain membership records that are associated with the DB cluster.</p>
        pub fn domain_memberships(mut self, input: crate::model::AwsRdsDbDomainMembership) -> Self {
            let mut v = self.domain_memberships.unwrap_or_default();
            v.push(input);
            self.domain_memberships = Some(v);
            self
        }
        /// <p>The Active Directory domain membership records that are associated with the DB cluster.</p>
        pub fn set_domain_memberships(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsRdsDbDomainMembership>>,
        ) -> Self {
            self.domain_memberships = input;
            self
        }
        /// <p>The name of the DB cluster parameter group for the DB cluster.</p>
        pub fn db_cluster_parameter_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_cluster_parameter_group = Some(input.into());
            self
        }
        /// <p>The name of the DB cluster parameter group for the DB cluster.</p>
        pub fn set_db_cluster_parameter_group(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.db_cluster_parameter_group = input;
            self
        }
        /// <p>The subnet group that is associated with the DB cluster, including the name, description, and subnets in the subnet group.</p>
        pub fn db_subnet_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_subnet_group = Some(input.into());
            self
        }
        /// <p>The subnet group that is associated with the DB cluster, including the name, description, and subnets in the subnet group.</p>
        pub fn set_db_subnet_group(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.db_subnet_group = input;
            self
        }
        /// Appends an item to `db_cluster_option_group_memberships`.
        ///
        /// To override the contents of this collection use [`set_db_cluster_option_group_memberships`](Self::set_db_cluster_option_group_memberships).
        ///
        /// <p>The list of option group memberships for this DB cluster.</p>
        pub fn db_cluster_option_group_memberships(
            mut self,
            input: crate::model::AwsRdsDbClusterOptionGroupMembership,
        ) -> Self {
            let mut v = self.db_cluster_option_group_memberships.unwrap_or_default();
            v.push(input);
            self.db_cluster_option_group_memberships = Some(v);
            self
        }
        /// <p>The list of option group memberships for this DB cluster.</p>
        pub fn set_db_cluster_option_group_memberships(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsRdsDbClusterOptionGroupMembership>,
            >,
        ) -> Self {
            self.db_cluster_option_group_memberships = input;
            self
        }
        /// <p>The DB cluster identifier that the user assigned to the cluster. This identifier is the unique key that identifies a DB cluster.</p>
        pub fn db_cluster_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_cluster_identifier = Some(input.into());
            self
        }
        /// <p>The DB cluster identifier that the user assigned to the cluster. This identifier is the unique key that identifies a DB cluster.</p>
        pub fn set_db_cluster_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.db_cluster_identifier = input;
            self
        }
        /// Appends an item to `db_cluster_members`.
        ///
        /// To override the contents of this collection use [`set_db_cluster_members`](Self::set_db_cluster_members).
        ///
        /// <p>The list of instances that make up the DB cluster.</p>
        pub fn db_cluster_members(mut self, input: crate::model::AwsRdsDbClusterMember) -> Self {
            let mut v = self.db_cluster_members.unwrap_or_default();
            v.push(input);
            self.db_cluster_members = Some(v);
            self
        }
        /// <p>The list of instances that make up the DB cluster.</p>
        pub fn set_db_cluster_members(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsRdsDbClusterMember>>,
        ) -> Self {
            self.db_cluster_members = input;
            self
        }
        /// <p>Whether the mapping of IAM accounts to database accounts is enabled.</p>
        pub fn iam_database_authentication_enabled(mut self, input: bool) -> Self {
            self.iam_database_authentication_enabled = Some(input);
            self
        }
        /// <p>Whether the mapping of IAM accounts to database accounts is enabled.</p>
        pub fn set_iam_database_authentication_enabled(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.iam_database_authentication_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRdsDbClusterDetails`](crate::model::AwsRdsDbClusterDetails)
        pub fn build(self) -> crate::model::AwsRdsDbClusterDetails {
            crate::model::AwsRdsDbClusterDetails {
                allocated_storage: self.allocated_storage.unwrap_or_default(),
                availability_zones: self.availability_zones,
                backup_retention_period: self.backup_retention_period.unwrap_or_default(),
                database_name: self.database_name,
                status: self.status,
                endpoint: self.endpoint,
                reader_endpoint: self.reader_endpoint,
                custom_endpoints: self.custom_endpoints,
                multi_az: self.multi_az.unwrap_or_default(),
                engine: self.engine,
                engine_version: self.engine_version,
                port: self.port.unwrap_or_default(),
                master_username: self.master_username,
                preferred_backup_window: self.preferred_backup_window,
                preferred_maintenance_window: self.preferred_maintenance_window,
                read_replica_identifiers: self.read_replica_identifiers,
                vpc_security_groups: self.vpc_security_groups,
                hosted_zone_id: self.hosted_zone_id,
                storage_encrypted: self.storage_encrypted.unwrap_or_default(),
                kms_key_id: self.kms_key_id,
                db_cluster_resource_id: self.db_cluster_resource_id,
                associated_roles: self.associated_roles,
                cluster_create_time: self.cluster_create_time,
                enabled_cloud_watch_logs_exports: self.enabled_cloud_watch_logs_exports,
                engine_mode: self.engine_mode,
                deletion_protection: self.deletion_protection.unwrap_or_default(),
                http_endpoint_enabled: self.http_endpoint_enabled.unwrap_or_default(),
                activity_stream_status: self.activity_stream_status,
                copy_tags_to_snapshot: self.copy_tags_to_snapshot.unwrap_or_default(),
                cross_account_clone: self.cross_account_clone.unwrap_or_default(),
                domain_memberships: self.domain_memberships,
                db_cluster_parameter_group: self.db_cluster_parameter_group,
                db_subnet_group: self.db_subnet_group,
                db_cluster_option_group_memberships: self.db_cluster_option_group_memberships,
                db_cluster_identifier: self.db_cluster_identifier,
                db_cluster_members: self.db_cluster_members,
                iam_database_authentication_enabled: self
                    .iam_database_authentication_enabled
                    .unwrap_or_default(),
            }
        }
    }
}
impl AwsRdsDbClusterDetails {
    /// Creates a new builder-style object to manufacture [`AwsRdsDbClusterDetails`](crate::model::AwsRdsDbClusterDetails)
    pub fn builder() -> crate::model::aws_rds_db_cluster_details::Builder {
        crate::model::aws_rds_db_cluster_details::Builder::default()
    }
}

/// <p>Information about an instance in the DB cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRdsDbClusterMember {
    /// <p>Whether the cluster member is the primary instance for the DB cluster.</p>
    pub is_cluster_writer: bool,
    /// <p>Specifies the order in which an Aurora replica is promoted to the primary instance when the existing primary instance fails.</p>
    pub promotion_tier: i32,
    /// <p>The instance identifier for this member of the DB cluster.</p>
    pub db_instance_identifier: std::option::Option<std::string::String>,
    /// <p>The status of the DB cluster parameter group for this member of the DB cluster.</p>
    pub db_cluster_parameter_group_status: std::option::Option<std::string::String>,
}
impl AwsRdsDbClusterMember {
    /// <p>Whether the cluster member is the primary instance for the DB cluster.</p>
    pub fn is_cluster_writer(&self) -> bool {
        self.is_cluster_writer
    }
    /// <p>Specifies the order in which an Aurora replica is promoted to the primary instance when the existing primary instance fails.</p>
    pub fn promotion_tier(&self) -> i32 {
        self.promotion_tier
    }
    /// <p>The instance identifier for this member of the DB cluster.</p>
    pub fn db_instance_identifier(&self) -> std::option::Option<&str> {
        self.db_instance_identifier.as_deref()
    }
    /// <p>The status of the DB cluster parameter group for this member of the DB cluster.</p>
    pub fn db_cluster_parameter_group_status(&self) -> std::option::Option<&str> {
        self.db_cluster_parameter_group_status.as_deref()
    }
}
impl std::fmt::Debug for AwsRdsDbClusterMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRdsDbClusterMember");
        formatter.field("is_cluster_writer", &self.is_cluster_writer);
        formatter.field("promotion_tier", &self.promotion_tier);
        formatter.field("db_instance_identifier", &self.db_instance_identifier);
        formatter.field(
            "db_cluster_parameter_group_status",
            &self.db_cluster_parameter_group_status,
        );
        formatter.finish()
    }
}
/// See [`AwsRdsDbClusterMember`](crate::model::AwsRdsDbClusterMember)
pub mod aws_rds_db_cluster_member {

    /// A builder for [`AwsRdsDbClusterMember`](crate::model::AwsRdsDbClusterMember)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) is_cluster_writer: std::option::Option<bool>,
        pub(crate) promotion_tier: std::option::Option<i32>,
        pub(crate) db_instance_identifier: std::option::Option<std::string::String>,
        pub(crate) db_cluster_parameter_group_status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Whether the cluster member is the primary instance for the DB cluster.</p>
        pub fn is_cluster_writer(mut self, input: bool) -> Self {
            self.is_cluster_writer = Some(input);
            self
        }
        /// <p>Whether the cluster member is the primary instance for the DB cluster.</p>
        pub fn set_is_cluster_writer(mut self, input: std::option::Option<bool>) -> Self {
            self.is_cluster_writer = input;
            self
        }
        /// <p>Specifies the order in which an Aurora replica is promoted to the primary instance when the existing primary instance fails.</p>
        pub fn promotion_tier(mut self, input: i32) -> Self {
            self.promotion_tier = Some(input);
            self
        }
        /// <p>Specifies the order in which an Aurora replica is promoted to the primary instance when the existing primary instance fails.</p>
        pub fn set_promotion_tier(mut self, input: std::option::Option<i32>) -> Self {
            self.promotion_tier = input;
            self
        }
        /// <p>The instance identifier for this member of the DB cluster.</p>
        pub fn db_instance_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_instance_identifier = Some(input.into());
            self
        }
        /// <p>The instance identifier for this member of the DB cluster.</p>
        pub fn set_db_instance_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.db_instance_identifier = input;
            self
        }
        /// <p>The status of the DB cluster parameter group for this member of the DB cluster.</p>
        pub fn db_cluster_parameter_group_status(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.db_cluster_parameter_group_status = Some(input.into());
            self
        }
        /// <p>The status of the DB cluster parameter group for this member of the DB cluster.</p>
        pub fn set_db_cluster_parameter_group_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.db_cluster_parameter_group_status = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRdsDbClusterMember`](crate::model::AwsRdsDbClusterMember)
        pub fn build(self) -> crate::model::AwsRdsDbClusterMember {
            crate::model::AwsRdsDbClusterMember {
                is_cluster_writer: self.is_cluster_writer.unwrap_or_default(),
                promotion_tier: self.promotion_tier.unwrap_or_default(),
                db_instance_identifier: self.db_instance_identifier,
                db_cluster_parameter_group_status: self.db_cluster_parameter_group_status,
            }
        }
    }
}
impl AwsRdsDbClusterMember {
    /// Creates a new builder-style object to manufacture [`AwsRdsDbClusterMember`](crate::model::AwsRdsDbClusterMember)
    pub fn builder() -> crate::model::aws_rds_db_cluster_member::Builder {
        crate::model::aws_rds_db_cluster_member::Builder::default()
    }
}

/// <p>Information about an option group membership for a DB cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRdsDbClusterOptionGroupMembership {
    /// <p>The name of the DB cluster option group.</p>
    pub db_cluster_option_group_name: std::option::Option<std::string::String>,
    /// <p>The status of the DB cluster option group.</p>
    pub status: std::option::Option<std::string::String>,
}
impl AwsRdsDbClusterOptionGroupMembership {
    /// <p>The name of the DB cluster option group.</p>
    pub fn db_cluster_option_group_name(&self) -> std::option::Option<&str> {
        self.db_cluster_option_group_name.as_deref()
    }
    /// <p>The status of the DB cluster option group.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
}
impl std::fmt::Debug for AwsRdsDbClusterOptionGroupMembership {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRdsDbClusterOptionGroupMembership");
        formatter.field(
            "db_cluster_option_group_name",
            &self.db_cluster_option_group_name,
        );
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`AwsRdsDbClusterOptionGroupMembership`](crate::model::AwsRdsDbClusterOptionGroupMembership)
pub mod aws_rds_db_cluster_option_group_membership {

    /// A builder for [`AwsRdsDbClusterOptionGroupMembership`](crate::model::AwsRdsDbClusterOptionGroupMembership)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) db_cluster_option_group_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the DB cluster option group.</p>
        pub fn db_cluster_option_group_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.db_cluster_option_group_name = Some(input.into());
            self
        }
        /// <p>The name of the DB cluster option group.</p>
        pub fn set_db_cluster_option_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.db_cluster_option_group_name = input;
            self
        }
        /// <p>The status of the DB cluster option group.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the DB cluster option group.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRdsDbClusterOptionGroupMembership`](crate::model::AwsRdsDbClusterOptionGroupMembership)
        pub fn build(self) -> crate::model::AwsRdsDbClusterOptionGroupMembership {
            crate::model::AwsRdsDbClusterOptionGroupMembership {
                db_cluster_option_group_name: self.db_cluster_option_group_name,
                status: self.status,
            }
        }
    }
}
impl AwsRdsDbClusterOptionGroupMembership {
    /// Creates a new builder-style object to manufacture [`AwsRdsDbClusterOptionGroupMembership`](crate::model::AwsRdsDbClusterOptionGroupMembership)
    pub fn builder() -> crate::model::aws_rds_db_cluster_option_group_membership::Builder {
        crate::model::aws_rds_db_cluster_option_group_membership::Builder::default()
    }
}

/// <p>Information about an Active Directory domain membership record associated with the DB instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRdsDbDomainMembership {
    /// <p>The identifier of the Active Directory domain.</p>
    pub domain: std::option::Option<std::string::String>,
    /// <p>The status of the Active Directory Domain membership for the DB instance.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>The fully qualified domain name of the Active Directory domain.</p>
    pub fqdn: std::option::Option<std::string::String>,
    /// <p>The name of the IAM role to use when making API calls to the Directory Service.</p>
    pub iam_role_name: std::option::Option<std::string::String>,
}
impl AwsRdsDbDomainMembership {
    /// <p>The identifier of the Active Directory domain.</p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p>The status of the Active Directory Domain membership for the DB instance.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>The fully qualified domain name of the Active Directory domain.</p>
    pub fn fqdn(&self) -> std::option::Option<&str> {
        self.fqdn.as_deref()
    }
    /// <p>The name of the IAM role to use when making API calls to the Directory Service.</p>
    pub fn iam_role_name(&self) -> std::option::Option<&str> {
        self.iam_role_name.as_deref()
    }
}
impl std::fmt::Debug for AwsRdsDbDomainMembership {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRdsDbDomainMembership");
        formatter.field("domain", &self.domain);
        formatter.field("status", &self.status);
        formatter.field("fqdn", &self.fqdn);
        formatter.field("iam_role_name", &self.iam_role_name);
        formatter.finish()
    }
}
/// See [`AwsRdsDbDomainMembership`](crate::model::AwsRdsDbDomainMembership)
pub mod aws_rds_db_domain_membership {

    /// A builder for [`AwsRdsDbDomainMembership`](crate::model::AwsRdsDbDomainMembership)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) fqdn: std::option::Option<std::string::String>,
        pub(crate) iam_role_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Active Directory domain.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p>The identifier of the Active Directory domain.</p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p>The status of the Active Directory Domain membership for the DB instance.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the Active Directory Domain membership for the DB instance.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>The fully qualified domain name of the Active Directory domain.</p>
        pub fn fqdn(mut self, input: impl Into<std::string::String>) -> Self {
            self.fqdn = Some(input.into());
            self
        }
        /// <p>The fully qualified domain name of the Active Directory domain.</p>
        pub fn set_fqdn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.fqdn = input;
            self
        }
        /// <p>The name of the IAM role to use when making API calls to the Directory Service.</p>
        pub fn iam_role_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.iam_role_name = Some(input.into());
            self
        }
        /// <p>The name of the IAM role to use when making API calls to the Directory Service.</p>
        pub fn set_iam_role_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.iam_role_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRdsDbDomainMembership`](crate::model::AwsRdsDbDomainMembership)
        pub fn build(self) -> crate::model::AwsRdsDbDomainMembership {
            crate::model::AwsRdsDbDomainMembership {
                domain: self.domain,
                status: self.status,
                fqdn: self.fqdn,
                iam_role_name: self.iam_role_name,
            }
        }
    }
}
impl AwsRdsDbDomainMembership {
    /// Creates a new builder-style object to manufacture [`AwsRdsDbDomainMembership`](crate::model::AwsRdsDbDomainMembership)
    pub fn builder() -> crate::model::aws_rds_db_domain_membership::Builder {
        crate::model::aws_rds_db_domain_membership::Builder::default()
    }
}

/// <p>An IAM role that is associated with the Amazon RDS DB cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRdsDbClusterAssociatedRole {
    /// <p>The ARN of the IAM role.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The status of the association between the IAM role and the DB cluster.</p>
    pub status: std::option::Option<std::string::String>,
}
impl AwsRdsDbClusterAssociatedRole {
    /// <p>The ARN of the IAM role.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>The status of the association between the IAM role and the DB cluster.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
}
impl std::fmt::Debug for AwsRdsDbClusterAssociatedRole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRdsDbClusterAssociatedRole");
        formatter.field("role_arn", &self.role_arn);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`AwsRdsDbClusterAssociatedRole`](crate::model::AwsRdsDbClusterAssociatedRole)
pub mod aws_rds_db_cluster_associated_role {

    /// A builder for [`AwsRdsDbClusterAssociatedRole`](crate::model::AwsRdsDbClusterAssociatedRole)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the IAM role.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the IAM role.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The status of the association between the IAM role and the DB cluster.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the association between the IAM role and the DB cluster.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRdsDbClusterAssociatedRole`](crate::model::AwsRdsDbClusterAssociatedRole)
        pub fn build(self) -> crate::model::AwsRdsDbClusterAssociatedRole {
            crate::model::AwsRdsDbClusterAssociatedRole {
                role_arn: self.role_arn,
                status: self.status,
            }
        }
    }
}
impl AwsRdsDbClusterAssociatedRole {
    /// Creates a new builder-style object to manufacture [`AwsRdsDbClusterAssociatedRole`](crate::model::AwsRdsDbClusterAssociatedRole)
    pub fn builder() -> crate::model::aws_rds_db_cluster_associated_role::Builder {
        crate::model::aws_rds_db_cluster_associated_role::Builder::default()
    }
}

/// <p>A VPC security groups that the DB instance belongs to.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRdsDbInstanceVpcSecurityGroup {
    /// <p>The name of the VPC security group.</p>
    pub vpc_security_group_id: std::option::Option<std::string::String>,
    /// <p>The status of the VPC security group.</p>
    pub status: std::option::Option<std::string::String>,
}
impl AwsRdsDbInstanceVpcSecurityGroup {
    /// <p>The name of the VPC security group.</p>
    pub fn vpc_security_group_id(&self) -> std::option::Option<&str> {
        self.vpc_security_group_id.as_deref()
    }
    /// <p>The status of the VPC security group.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
}
impl std::fmt::Debug for AwsRdsDbInstanceVpcSecurityGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRdsDbInstanceVpcSecurityGroup");
        formatter.field("vpc_security_group_id", &self.vpc_security_group_id);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`AwsRdsDbInstanceVpcSecurityGroup`](crate::model::AwsRdsDbInstanceVpcSecurityGroup)
pub mod aws_rds_db_instance_vpc_security_group {

    /// A builder for [`AwsRdsDbInstanceVpcSecurityGroup`](crate::model::AwsRdsDbInstanceVpcSecurityGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vpc_security_group_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the VPC security group.</p>
        pub fn vpc_security_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_security_group_id = Some(input.into());
            self
        }
        /// <p>The name of the VPC security group.</p>
        pub fn set_vpc_security_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_security_group_id = input;
            self
        }
        /// <p>The status of the VPC security group.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the VPC security group.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRdsDbInstanceVpcSecurityGroup`](crate::model::AwsRdsDbInstanceVpcSecurityGroup)
        pub fn build(self) -> crate::model::AwsRdsDbInstanceVpcSecurityGroup {
            crate::model::AwsRdsDbInstanceVpcSecurityGroup {
                vpc_security_group_id: self.vpc_security_group_id,
                status: self.status,
            }
        }
    }
}
impl AwsRdsDbInstanceVpcSecurityGroup {
    /// Creates a new builder-style object to manufacture [`AwsRdsDbInstanceVpcSecurityGroup`](crate::model::AwsRdsDbInstanceVpcSecurityGroup)
    pub fn builder() -> crate::model::aws_rds_db_instance_vpc_security_group::Builder {
        crate::model::aws_rds_db_instance_vpc_security_group::Builder::default()
    }
}

/// <p>Information about an Amazon RDS DB cluster snapshot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRdsDbClusterSnapshotDetails {
    /// <p>A list of Availability Zones where instances in the DB cluster can be created.</p>
    pub availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Indicates when the snapshot was taken.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub snapshot_create_time: std::option::Option<std::string::String>,
    /// <p>The name of the database engine that you want to use for this DB instance.</p>
    pub engine: std::option::Option<std::string::String>,
    /// <p>Specifies the allocated storage size in gibibytes (GiB).</p>
    pub allocated_storage: i32,
    /// <p>The status of this DB cluster snapshot.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>The port number on which the DB instances in the DB cluster accept connections.</p>
    pub port: i32,
    /// <p>The VPC ID that is associated with the DB cluster snapshot.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>Indicates when the DB cluster was created, in Universal Coordinated Time (UTC).</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub cluster_create_time: std::option::Option<std::string::String>,
    /// <p>The name of the master user for the DB cluster.</p>
    pub master_username: std::option::Option<std::string::String>,
    /// <p>The version of the database engine to use.</p>
    pub engine_version: std::option::Option<std::string::String>,
    /// <p>The license model information for this DB cluster snapshot.</p>
    pub license_model: std::option::Option<std::string::String>,
    /// <p>The type of DB cluster snapshot.</p>
    pub snapshot_type: std::option::Option<std::string::String>,
    /// <p>Specifies the percentage of the estimated data that has been transferred.</p>
    pub percent_progress: i32,
    /// <p>Whether the DB cluster is encrypted.</p>
    pub storage_encrypted: bool,
    /// <p>The ARN of the KMS master key that is used to encrypt the database instances in the DB cluster.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The DB cluster identifier.</p>
    pub db_cluster_identifier: std::option::Option<std::string::String>,
    /// <p>The identifier of the DB cluster snapshot.</p>
    pub db_cluster_snapshot_identifier: std::option::Option<std::string::String>,
    /// <p>Whether mapping of IAM accounts to database accounts is enabled.</p>
    pub iam_database_authentication_enabled: bool,
}
impl AwsRdsDbClusterSnapshotDetails {
    /// <p>A list of Availability Zones where instances in the DB cluster can be created.</p>
    pub fn availability_zones(&self) -> std::option::Option<&[std::string::String]> {
        self.availability_zones.as_deref()
    }
    /// <p>Indicates when the snapshot was taken.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn snapshot_create_time(&self) -> std::option::Option<&str> {
        self.snapshot_create_time.as_deref()
    }
    /// <p>The name of the database engine that you want to use for this DB instance.</p>
    pub fn engine(&self) -> std::option::Option<&str> {
        self.engine.as_deref()
    }
    /// <p>Specifies the allocated storage size in gibibytes (GiB).</p>
    pub fn allocated_storage(&self) -> i32 {
        self.allocated_storage
    }
    /// <p>The status of this DB cluster snapshot.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>The port number on which the DB instances in the DB cluster accept connections.</p>
    pub fn port(&self) -> i32 {
        self.port
    }
    /// <p>The VPC ID that is associated with the DB cluster snapshot.</p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
    /// <p>Indicates when the DB cluster was created, in Universal Coordinated Time (UTC).</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn cluster_create_time(&self) -> std::option::Option<&str> {
        self.cluster_create_time.as_deref()
    }
    /// <p>The name of the master user for the DB cluster.</p>
    pub fn master_username(&self) -> std::option::Option<&str> {
        self.master_username.as_deref()
    }
    /// <p>The version of the database engine to use.</p>
    pub fn engine_version(&self) -> std::option::Option<&str> {
        self.engine_version.as_deref()
    }
    /// <p>The license model information for this DB cluster snapshot.</p>
    pub fn license_model(&self) -> std::option::Option<&str> {
        self.license_model.as_deref()
    }
    /// <p>The type of DB cluster snapshot.</p>
    pub fn snapshot_type(&self) -> std::option::Option<&str> {
        self.snapshot_type.as_deref()
    }
    /// <p>Specifies the percentage of the estimated data that has been transferred.</p>
    pub fn percent_progress(&self) -> i32 {
        self.percent_progress
    }
    /// <p>Whether the DB cluster is encrypted.</p>
    pub fn storage_encrypted(&self) -> bool {
        self.storage_encrypted
    }
    /// <p>The ARN of the KMS master key that is used to encrypt the database instances in the DB cluster.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>The DB cluster identifier.</p>
    pub fn db_cluster_identifier(&self) -> std::option::Option<&str> {
        self.db_cluster_identifier.as_deref()
    }
    /// <p>The identifier of the DB cluster snapshot.</p>
    pub fn db_cluster_snapshot_identifier(&self) -> std::option::Option<&str> {
        self.db_cluster_snapshot_identifier.as_deref()
    }
    /// <p>Whether mapping of IAM accounts to database accounts is enabled.</p>
    pub fn iam_database_authentication_enabled(&self) -> bool {
        self.iam_database_authentication_enabled
    }
}
impl std::fmt::Debug for AwsRdsDbClusterSnapshotDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRdsDbClusterSnapshotDetails");
        formatter.field("availability_zones", &self.availability_zones);
        formatter.field("snapshot_create_time", &self.snapshot_create_time);
        formatter.field("engine", &self.engine);
        formatter.field("allocated_storage", &self.allocated_storage);
        formatter.field("status", &self.status);
        formatter.field("port", &self.port);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("cluster_create_time", &self.cluster_create_time);
        formatter.field("master_username", &self.master_username);
        formatter.field("engine_version", &self.engine_version);
        formatter.field("license_model", &self.license_model);
        formatter.field("snapshot_type", &self.snapshot_type);
        formatter.field("percent_progress", &self.percent_progress);
        formatter.field("storage_encrypted", &self.storage_encrypted);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("db_cluster_identifier", &self.db_cluster_identifier);
        formatter.field(
            "db_cluster_snapshot_identifier",
            &self.db_cluster_snapshot_identifier,
        );
        formatter.field(
            "iam_database_authentication_enabled",
            &self.iam_database_authentication_enabled,
        );
        formatter.finish()
    }
}
/// See [`AwsRdsDbClusterSnapshotDetails`](crate::model::AwsRdsDbClusterSnapshotDetails)
pub mod aws_rds_db_cluster_snapshot_details {

    /// A builder for [`AwsRdsDbClusterSnapshotDetails`](crate::model::AwsRdsDbClusterSnapshotDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) snapshot_create_time: std::option::Option<std::string::String>,
        pub(crate) engine: std::option::Option<std::string::String>,
        pub(crate) allocated_storage: std::option::Option<i32>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) cluster_create_time: std::option::Option<std::string::String>,
        pub(crate) master_username: std::option::Option<std::string::String>,
        pub(crate) engine_version: std::option::Option<std::string::String>,
        pub(crate) license_model: std::option::Option<std::string::String>,
        pub(crate) snapshot_type: std::option::Option<std::string::String>,
        pub(crate) percent_progress: std::option::Option<i32>,
        pub(crate) storage_encrypted: std::option::Option<bool>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) db_cluster_identifier: std::option::Option<std::string::String>,
        pub(crate) db_cluster_snapshot_identifier: std::option::Option<std::string::String>,
        pub(crate) iam_database_authentication_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// Appends an item to `availability_zones`.
        ///
        /// To override the contents of this collection use [`set_availability_zones`](Self::set_availability_zones).
        ///
        /// <p>A list of Availability Zones where instances in the DB cluster can be created.</p>
        pub fn availability_zones(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.availability_zones.unwrap_or_default();
            v.push(input.into());
            self.availability_zones = Some(v);
            self
        }
        /// <p>A list of Availability Zones where instances in the DB cluster can be created.</p>
        pub fn set_availability_zones(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.availability_zones = input;
            self
        }
        /// <p>Indicates when the snapshot was taken.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn snapshot_create_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_create_time = Some(input.into());
            self
        }
        /// <p>Indicates when the snapshot was taken.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_snapshot_create_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.snapshot_create_time = input;
            self
        }
        /// <p>The name of the database engine that you want to use for this DB instance.</p>
        pub fn engine(mut self, input: impl Into<std::string::String>) -> Self {
            self.engine = Some(input.into());
            self
        }
        /// <p>The name of the database engine that you want to use for this DB instance.</p>
        pub fn set_engine(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.engine = input;
            self
        }
        /// <p>Specifies the allocated storage size in gibibytes (GiB).</p>
        pub fn allocated_storage(mut self, input: i32) -> Self {
            self.allocated_storage = Some(input);
            self
        }
        /// <p>Specifies the allocated storage size in gibibytes (GiB).</p>
        pub fn set_allocated_storage(mut self, input: std::option::Option<i32>) -> Self {
            self.allocated_storage = input;
            self
        }
        /// <p>The status of this DB cluster snapshot.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of this DB cluster snapshot.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>The port number on which the DB instances in the DB cluster accept connections.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>The port number on which the DB instances in the DB cluster accept connections.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// <p>The VPC ID that is associated with the DB cluster snapshot.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The VPC ID that is associated with the DB cluster snapshot.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// <p>Indicates when the DB cluster was created, in Universal Coordinated Time (UTC).</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn cluster_create_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_create_time = Some(input.into());
            self
        }
        /// <p>Indicates when the DB cluster was created, in Universal Coordinated Time (UTC).</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_cluster_create_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_create_time = input;
            self
        }
        /// <p>The name of the master user for the DB cluster.</p>
        pub fn master_username(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_username = Some(input.into());
            self
        }
        /// <p>The name of the master user for the DB cluster.</p>
        pub fn set_master_username(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_username = input;
            self
        }
        /// <p>The version of the database engine to use.</p>
        pub fn engine_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.engine_version = Some(input.into());
            self
        }
        /// <p>The version of the database engine to use.</p>
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.engine_version = input;
            self
        }
        /// <p>The license model information for this DB cluster snapshot.</p>
        pub fn license_model(mut self, input: impl Into<std::string::String>) -> Self {
            self.license_model = Some(input.into());
            self
        }
        /// <p>The license model information for this DB cluster snapshot.</p>
        pub fn set_license_model(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.license_model = input;
            self
        }
        /// <p>The type of DB cluster snapshot.</p>
        pub fn snapshot_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_type = Some(input.into());
            self
        }
        /// <p>The type of DB cluster snapshot.</p>
        pub fn set_snapshot_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.snapshot_type = input;
            self
        }
        /// <p>Specifies the percentage of the estimated data that has been transferred.</p>
        pub fn percent_progress(mut self, input: i32) -> Self {
            self.percent_progress = Some(input);
            self
        }
        /// <p>Specifies the percentage of the estimated data that has been transferred.</p>
        pub fn set_percent_progress(mut self, input: std::option::Option<i32>) -> Self {
            self.percent_progress = input;
            self
        }
        /// <p>Whether the DB cluster is encrypted.</p>
        pub fn storage_encrypted(mut self, input: bool) -> Self {
            self.storage_encrypted = Some(input);
            self
        }
        /// <p>Whether the DB cluster is encrypted.</p>
        pub fn set_storage_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.storage_encrypted = input;
            self
        }
        /// <p>The ARN of the KMS master key that is used to encrypt the database instances in the DB cluster.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The ARN of the KMS master key that is used to encrypt the database instances in the DB cluster.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The DB cluster identifier.</p>
        pub fn db_cluster_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_cluster_identifier = Some(input.into());
            self
        }
        /// <p>The DB cluster identifier.</p>
        pub fn set_db_cluster_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.db_cluster_identifier = input;
            self
        }
        /// <p>The identifier of the DB cluster snapshot.</p>
        pub fn db_cluster_snapshot_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.db_cluster_snapshot_identifier = Some(input.into());
            self
        }
        /// <p>The identifier of the DB cluster snapshot.</p>
        pub fn set_db_cluster_snapshot_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.db_cluster_snapshot_identifier = input;
            self
        }
        /// <p>Whether mapping of IAM accounts to database accounts is enabled.</p>
        pub fn iam_database_authentication_enabled(mut self, input: bool) -> Self {
            self.iam_database_authentication_enabled = Some(input);
            self
        }
        /// <p>Whether mapping of IAM accounts to database accounts is enabled.</p>
        pub fn set_iam_database_authentication_enabled(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.iam_database_authentication_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRdsDbClusterSnapshotDetails`](crate::model::AwsRdsDbClusterSnapshotDetails)
        pub fn build(self) -> crate::model::AwsRdsDbClusterSnapshotDetails {
            crate::model::AwsRdsDbClusterSnapshotDetails {
                availability_zones: self.availability_zones,
                snapshot_create_time: self.snapshot_create_time,
                engine: self.engine,
                allocated_storage: self.allocated_storage.unwrap_or_default(),
                status: self.status,
                port: self.port.unwrap_or_default(),
                vpc_id: self.vpc_id,
                cluster_create_time: self.cluster_create_time,
                master_username: self.master_username,
                engine_version: self.engine_version,
                license_model: self.license_model,
                snapshot_type: self.snapshot_type,
                percent_progress: self.percent_progress.unwrap_or_default(),
                storage_encrypted: self.storage_encrypted.unwrap_or_default(),
                kms_key_id: self.kms_key_id,
                db_cluster_identifier: self.db_cluster_identifier,
                db_cluster_snapshot_identifier: self.db_cluster_snapshot_identifier,
                iam_database_authentication_enabled: self
                    .iam_database_authentication_enabled
                    .unwrap_or_default(),
            }
        }
    }
}
impl AwsRdsDbClusterSnapshotDetails {
    /// Creates a new builder-style object to manufacture [`AwsRdsDbClusterSnapshotDetails`](crate::model::AwsRdsDbClusterSnapshotDetails)
    pub fn builder() -> crate::model::aws_rds_db_cluster_snapshot_details::Builder {
        crate::model::aws_rds_db_cluster_snapshot_details::Builder::default()
    }
}

/// <p>Provides details about an Amazon RDS DB cluster snapshot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRdsDbSnapshotDetails {
    /// <p>The name or ARN of the DB snapshot that is used to restore the DB instance.</p>
    pub db_snapshot_identifier: std::option::Option<std::string::String>,
    /// <p>A name for the DB instance.</p>
    pub db_instance_identifier: std::option::Option<std::string::String>,
    /// <p>When the snapshot was taken in Coordinated Universal Time (UTC).</p>
    pub snapshot_create_time: std::option::Option<std::string::String>,
    /// <p>The name of the database engine to use for this DB instance.</p>
    pub engine: std::option::Option<std::string::String>,
    /// <p>The amount of storage (in gigabytes) to be initially allocated for the database instance.</p>
    pub allocated_storage: i32,
    /// <p>The status of this DB snapshot.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>The port that the database engine was listening on at the time of the snapshot.</p>
    pub port: i32,
    /// <p>Specifies the name of the Availability Zone in which the DB instance was located at the time of the DB snapshot.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The VPC ID associated with the DB snapshot.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>Specifies the time in Coordinated Universal Time (UTC) when the DB instance, from which the snapshot was taken, was created.</p>
    pub instance_create_time: std::option::Option<std::string::String>,
    /// <p>The master user name for the DB snapshot.</p>
    pub master_username: std::option::Option<std::string::String>,
    /// <p>The version of the database engine.</p>
    pub engine_version: std::option::Option<std::string::String>,
    /// <p>License model information for the restored DB instance.</p>
    pub license_model: std::option::Option<std::string::String>,
    /// <p>The type of the DB snapshot.</p>
    pub snapshot_type: std::option::Option<std::string::String>,
    /// <p>The provisioned IOPS (I/O operations per second) value of the DB instance at the time of the snapshot.</p>
    pub iops: i32,
    /// <p>The option group name for the DB snapshot.</p>
    pub option_group_name: std::option::Option<std::string::String>,
    /// <p>The percentage of the estimated data that has been transferred.</p>
    pub percent_progress: i32,
    /// <p>The Amazon Web Services Region that the DB snapshot was created in or copied from.</p>
    pub source_region: std::option::Option<std::string::String>,
    /// <p>The DB snapshot ARN that the DB snapshot was copied from.</p>
    pub source_db_snapshot_identifier: std::option::Option<std::string::String>,
    /// <p>The storage type associated with the DB snapshot.</p>
    pub storage_type: std::option::Option<std::string::String>,
    /// <p>The ARN from the key store with which to associate the instance for TDE encryption.</p>
    pub tde_credential_arn: std::option::Option<std::string::String>,
    /// <p>Whether the DB snapshot is encrypted.</p>
    pub encrypted: bool,
    /// <p>If <code>Encrypted</code> is <code>true</code>, the KMS key identifier for the encrypted DB snapshot.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The time zone of the DB snapshot.</p>
    pub timezone: std::option::Option<std::string::String>,
    /// <p>Whether mapping of IAM accounts to database accounts is enabled.</p>
    pub iam_database_authentication_enabled: bool,
    /// <p>The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.</p>
    pub processor_features:
        std::option::Option<std::vec::Vec<crate::model::AwsRdsDbProcessorFeature>>,
    /// <p>The identifier for the source DB instance.</p>
    pub dbi_resource_id: std::option::Option<std::string::String>,
}
impl AwsRdsDbSnapshotDetails {
    /// <p>The name or ARN of the DB snapshot that is used to restore the DB instance.</p>
    pub fn db_snapshot_identifier(&self) -> std::option::Option<&str> {
        self.db_snapshot_identifier.as_deref()
    }
    /// <p>A name for the DB instance.</p>
    pub fn db_instance_identifier(&self) -> std::option::Option<&str> {
        self.db_instance_identifier.as_deref()
    }
    /// <p>When the snapshot was taken in Coordinated Universal Time (UTC).</p>
    pub fn snapshot_create_time(&self) -> std::option::Option<&str> {
        self.snapshot_create_time.as_deref()
    }
    /// <p>The name of the database engine to use for this DB instance.</p>
    pub fn engine(&self) -> std::option::Option<&str> {
        self.engine.as_deref()
    }
    /// <p>The amount of storage (in gigabytes) to be initially allocated for the database instance.</p>
    pub fn allocated_storage(&self) -> i32 {
        self.allocated_storage
    }
    /// <p>The status of this DB snapshot.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>The port that the database engine was listening on at the time of the snapshot.</p>
    pub fn port(&self) -> i32 {
        self.port
    }
    /// <p>Specifies the name of the Availability Zone in which the DB instance was located at the time of the DB snapshot.</p>
    pub fn availability_zone(&self) -> std::option::Option<&str> {
        self.availability_zone.as_deref()
    }
    /// <p>The VPC ID associated with the DB snapshot.</p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
    /// <p>Specifies the time in Coordinated Universal Time (UTC) when the DB instance, from which the snapshot was taken, was created.</p>
    pub fn instance_create_time(&self) -> std::option::Option<&str> {
        self.instance_create_time.as_deref()
    }
    /// <p>The master user name for the DB snapshot.</p>
    pub fn master_username(&self) -> std::option::Option<&str> {
        self.master_username.as_deref()
    }
    /// <p>The version of the database engine.</p>
    pub fn engine_version(&self) -> std::option::Option<&str> {
        self.engine_version.as_deref()
    }
    /// <p>License model information for the restored DB instance.</p>
    pub fn license_model(&self) -> std::option::Option<&str> {
        self.license_model.as_deref()
    }
    /// <p>The type of the DB snapshot.</p>
    pub fn snapshot_type(&self) -> std::option::Option<&str> {
        self.snapshot_type.as_deref()
    }
    /// <p>The provisioned IOPS (I/O operations per second) value of the DB instance at the time of the snapshot.</p>
    pub fn iops(&self) -> i32 {
        self.iops
    }
    /// <p>The option group name for the DB snapshot.</p>
    pub fn option_group_name(&self) -> std::option::Option<&str> {
        self.option_group_name.as_deref()
    }
    /// <p>The percentage of the estimated data that has been transferred.</p>
    pub fn percent_progress(&self) -> i32 {
        self.percent_progress
    }
    /// <p>The Amazon Web Services Region that the DB snapshot was created in or copied from.</p>
    pub fn source_region(&self) -> std::option::Option<&str> {
        self.source_region.as_deref()
    }
    /// <p>The DB snapshot ARN that the DB snapshot was copied from.</p>
    pub fn source_db_snapshot_identifier(&self) -> std::option::Option<&str> {
        self.source_db_snapshot_identifier.as_deref()
    }
    /// <p>The storage type associated with the DB snapshot.</p>
    pub fn storage_type(&self) -> std::option::Option<&str> {
        self.storage_type.as_deref()
    }
    /// <p>The ARN from the key store with which to associate the instance for TDE encryption.</p>
    pub fn tde_credential_arn(&self) -> std::option::Option<&str> {
        self.tde_credential_arn.as_deref()
    }
    /// <p>Whether the DB snapshot is encrypted.</p>
    pub fn encrypted(&self) -> bool {
        self.encrypted
    }
    /// <p>If <code>Encrypted</code> is <code>true</code>, the KMS key identifier for the encrypted DB snapshot.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>The time zone of the DB snapshot.</p>
    pub fn timezone(&self) -> std::option::Option<&str> {
        self.timezone.as_deref()
    }
    /// <p>Whether mapping of IAM accounts to database accounts is enabled.</p>
    pub fn iam_database_authentication_enabled(&self) -> bool {
        self.iam_database_authentication_enabled
    }
    /// <p>The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.</p>
    pub fn processor_features(
        &self,
    ) -> std::option::Option<&[crate::model::AwsRdsDbProcessorFeature]> {
        self.processor_features.as_deref()
    }
    /// <p>The identifier for the source DB instance.</p>
    pub fn dbi_resource_id(&self) -> std::option::Option<&str> {
        self.dbi_resource_id.as_deref()
    }
}
impl std::fmt::Debug for AwsRdsDbSnapshotDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRdsDbSnapshotDetails");
        formatter.field("db_snapshot_identifier", &self.db_snapshot_identifier);
        formatter.field("db_instance_identifier", &self.db_instance_identifier);
        formatter.field("snapshot_create_time", &self.snapshot_create_time);
        formatter.field("engine", &self.engine);
        formatter.field("allocated_storage", &self.allocated_storage);
        formatter.field("status", &self.status);
        formatter.field("port", &self.port);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("instance_create_time", &self.instance_create_time);
        formatter.field("master_username", &self.master_username);
        formatter.field("engine_version", &self.engine_version);
        formatter.field("license_model", &self.license_model);
        formatter.field("snapshot_type", &self.snapshot_type);
        formatter.field("iops", &self.iops);
        formatter.field("option_group_name", &self.option_group_name);
        formatter.field("percent_progress", &self.percent_progress);
        formatter.field("source_region", &self.source_region);
        formatter.field(
            "source_db_snapshot_identifier",
            &self.source_db_snapshot_identifier,
        );
        formatter.field("storage_type", &self.storage_type);
        formatter.field("tde_credential_arn", &self.tde_credential_arn);
        formatter.field("encrypted", &self.encrypted);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("timezone", &self.timezone);
        formatter.field(
            "iam_database_authentication_enabled",
            &self.iam_database_authentication_enabled,
        );
        formatter.field("processor_features", &self.processor_features);
        formatter.field("dbi_resource_id", &self.dbi_resource_id);
        formatter.finish()
    }
}
/// See [`AwsRdsDbSnapshotDetails`](crate::model::AwsRdsDbSnapshotDetails)
pub mod aws_rds_db_snapshot_details {

    /// A builder for [`AwsRdsDbSnapshotDetails`](crate::model::AwsRdsDbSnapshotDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) db_snapshot_identifier: std::option::Option<std::string::String>,
        pub(crate) db_instance_identifier: std::option::Option<std::string::String>,
        pub(crate) snapshot_create_time: std::option::Option<std::string::String>,
        pub(crate) engine: std::option::Option<std::string::String>,
        pub(crate) allocated_storage: std::option::Option<i32>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) instance_create_time: std::option::Option<std::string::String>,
        pub(crate) master_username: std::option::Option<std::string::String>,
        pub(crate) engine_version: std::option::Option<std::string::String>,
        pub(crate) license_model: std::option::Option<std::string::String>,
        pub(crate) snapshot_type: std::option::Option<std::string::String>,
        pub(crate) iops: std::option::Option<i32>,
        pub(crate) option_group_name: std::option::Option<std::string::String>,
        pub(crate) percent_progress: std::option::Option<i32>,
        pub(crate) source_region: std::option::Option<std::string::String>,
        pub(crate) source_db_snapshot_identifier: std::option::Option<std::string::String>,
        pub(crate) storage_type: std::option::Option<std::string::String>,
        pub(crate) tde_credential_arn: std::option::Option<std::string::String>,
        pub(crate) encrypted: std::option::Option<bool>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) timezone: std::option::Option<std::string::String>,
        pub(crate) iam_database_authentication_enabled: std::option::Option<bool>,
        pub(crate) processor_features:
            std::option::Option<std::vec::Vec<crate::model::AwsRdsDbProcessorFeature>>,
        pub(crate) dbi_resource_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name or ARN of the DB snapshot that is used to restore the DB instance.</p>
        pub fn db_snapshot_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_snapshot_identifier = Some(input.into());
            self
        }
        /// <p>The name or ARN of the DB snapshot that is used to restore the DB instance.</p>
        pub fn set_db_snapshot_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.db_snapshot_identifier = input;
            self
        }
        /// <p>A name for the DB instance.</p>
        pub fn db_instance_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_instance_identifier = Some(input.into());
            self
        }
        /// <p>A name for the DB instance.</p>
        pub fn set_db_instance_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.db_instance_identifier = input;
            self
        }
        /// <p>When the snapshot was taken in Coordinated Universal Time (UTC).</p>
        pub fn snapshot_create_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_create_time = Some(input.into());
            self
        }
        /// <p>When the snapshot was taken in Coordinated Universal Time (UTC).</p>
        pub fn set_snapshot_create_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.snapshot_create_time = input;
            self
        }
        /// <p>The name of the database engine to use for this DB instance.</p>
        pub fn engine(mut self, input: impl Into<std::string::String>) -> Self {
            self.engine = Some(input.into());
            self
        }
        /// <p>The name of the database engine to use for this DB instance.</p>
        pub fn set_engine(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.engine = input;
            self
        }
        /// <p>The amount of storage (in gigabytes) to be initially allocated for the database instance.</p>
        pub fn allocated_storage(mut self, input: i32) -> Self {
            self.allocated_storage = Some(input);
            self
        }
        /// <p>The amount of storage (in gigabytes) to be initially allocated for the database instance.</p>
        pub fn set_allocated_storage(mut self, input: std::option::Option<i32>) -> Self {
            self.allocated_storage = input;
            self
        }
        /// <p>The status of this DB snapshot.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of this DB snapshot.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>The port that the database engine was listening on at the time of the snapshot.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>The port that the database engine was listening on at the time of the snapshot.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// <p>Specifies the name of the Availability Zone in which the DB instance was located at the time of the DB snapshot.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        /// <p>Specifies the name of the Availability Zone in which the DB instance was located at the time of the DB snapshot.</p>
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The VPC ID associated with the DB snapshot.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The VPC ID associated with the DB snapshot.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// <p>Specifies the time in Coordinated Universal Time (UTC) when the DB instance, from which the snapshot was taken, was created.</p>
        pub fn instance_create_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_create_time = Some(input.into());
            self
        }
        /// <p>Specifies the time in Coordinated Universal Time (UTC) when the DB instance, from which the snapshot was taken, was created.</p>
        pub fn set_instance_create_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_create_time = input;
            self
        }
        /// <p>The master user name for the DB snapshot.</p>
        pub fn master_username(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_username = Some(input.into());
            self
        }
        /// <p>The master user name for the DB snapshot.</p>
        pub fn set_master_username(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_username = input;
            self
        }
        /// <p>The version of the database engine.</p>
        pub fn engine_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.engine_version = Some(input.into());
            self
        }
        /// <p>The version of the database engine.</p>
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.engine_version = input;
            self
        }
        /// <p>License model information for the restored DB instance.</p>
        pub fn license_model(mut self, input: impl Into<std::string::String>) -> Self {
            self.license_model = Some(input.into());
            self
        }
        /// <p>License model information for the restored DB instance.</p>
        pub fn set_license_model(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.license_model = input;
            self
        }
        /// <p>The type of the DB snapshot.</p>
        pub fn snapshot_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_type = Some(input.into());
            self
        }
        /// <p>The type of the DB snapshot.</p>
        pub fn set_snapshot_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.snapshot_type = input;
            self
        }
        /// <p>The provisioned IOPS (I/O operations per second) value of the DB instance at the time of the snapshot.</p>
        pub fn iops(mut self, input: i32) -> Self {
            self.iops = Some(input);
            self
        }
        /// <p>The provisioned IOPS (I/O operations per second) value of the DB instance at the time of the snapshot.</p>
        pub fn set_iops(mut self, input: std::option::Option<i32>) -> Self {
            self.iops = input;
            self
        }
        /// <p>The option group name for the DB snapshot.</p>
        pub fn option_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.option_group_name = Some(input.into());
            self
        }
        /// <p>The option group name for the DB snapshot.</p>
        pub fn set_option_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.option_group_name = input;
            self
        }
        /// <p>The percentage of the estimated data that has been transferred.</p>
        pub fn percent_progress(mut self, input: i32) -> Self {
            self.percent_progress = Some(input);
            self
        }
        /// <p>The percentage of the estimated data that has been transferred.</p>
        pub fn set_percent_progress(mut self, input: std::option::Option<i32>) -> Self {
            self.percent_progress = input;
            self
        }
        /// <p>The Amazon Web Services Region that the DB snapshot was created in or copied from.</p>
        pub fn source_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_region = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Region that the DB snapshot was created in or copied from.</p>
        pub fn set_source_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_region = input;
            self
        }
        /// <p>The DB snapshot ARN that the DB snapshot was copied from.</p>
        pub fn source_db_snapshot_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.source_db_snapshot_identifier = Some(input.into());
            self
        }
        /// <p>The DB snapshot ARN that the DB snapshot was copied from.</p>
        pub fn set_source_db_snapshot_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_db_snapshot_identifier = input;
            self
        }
        /// <p>The storage type associated with the DB snapshot.</p>
        pub fn storage_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.storage_type = Some(input.into());
            self
        }
        /// <p>The storage type associated with the DB snapshot.</p>
        pub fn set_storage_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.storage_type = input;
            self
        }
        /// <p>The ARN from the key store with which to associate the instance for TDE encryption.</p>
        pub fn tde_credential_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.tde_credential_arn = Some(input.into());
            self
        }
        /// <p>The ARN from the key store with which to associate the instance for TDE encryption.</p>
        pub fn set_tde_credential_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tde_credential_arn = input;
            self
        }
        /// <p>Whether the DB snapshot is encrypted.</p>
        pub fn encrypted(mut self, input: bool) -> Self {
            self.encrypted = Some(input);
            self
        }
        /// <p>Whether the DB snapshot is encrypted.</p>
        pub fn set_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.encrypted = input;
            self
        }
        /// <p>If <code>Encrypted</code> is <code>true</code>, the KMS key identifier for the encrypted DB snapshot.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>If <code>Encrypted</code> is <code>true</code>, the KMS key identifier for the encrypted DB snapshot.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The time zone of the DB snapshot.</p>
        pub fn timezone(mut self, input: impl Into<std::string::String>) -> Self {
            self.timezone = Some(input.into());
            self
        }
        /// <p>The time zone of the DB snapshot.</p>
        pub fn set_timezone(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.timezone = input;
            self
        }
        /// <p>Whether mapping of IAM accounts to database accounts is enabled.</p>
        pub fn iam_database_authentication_enabled(mut self, input: bool) -> Self {
            self.iam_database_authentication_enabled = Some(input);
            self
        }
        /// <p>Whether mapping of IAM accounts to database accounts is enabled.</p>
        pub fn set_iam_database_authentication_enabled(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.iam_database_authentication_enabled = input;
            self
        }
        /// Appends an item to `processor_features`.
        ///
        /// To override the contents of this collection use [`set_processor_features`](Self::set_processor_features).
        ///
        /// <p>The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.</p>
        pub fn processor_features(mut self, input: crate::model::AwsRdsDbProcessorFeature) -> Self {
            let mut v = self.processor_features.unwrap_or_default();
            v.push(input);
            self.processor_features = Some(v);
            self
        }
        /// <p>The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.</p>
        pub fn set_processor_features(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsRdsDbProcessorFeature>>,
        ) -> Self {
            self.processor_features = input;
            self
        }
        /// <p>The identifier for the source DB instance.</p>
        pub fn dbi_resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.dbi_resource_id = Some(input.into());
            self
        }
        /// <p>The identifier for the source DB instance.</p>
        pub fn set_dbi_resource_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dbi_resource_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRdsDbSnapshotDetails`](crate::model::AwsRdsDbSnapshotDetails)
        pub fn build(self) -> crate::model::AwsRdsDbSnapshotDetails {
            crate::model::AwsRdsDbSnapshotDetails {
                db_snapshot_identifier: self.db_snapshot_identifier,
                db_instance_identifier: self.db_instance_identifier,
                snapshot_create_time: self.snapshot_create_time,
                engine: self.engine,
                allocated_storage: self.allocated_storage.unwrap_or_default(),
                status: self.status,
                port: self.port.unwrap_or_default(),
                availability_zone: self.availability_zone,
                vpc_id: self.vpc_id,
                instance_create_time: self.instance_create_time,
                master_username: self.master_username,
                engine_version: self.engine_version,
                license_model: self.license_model,
                snapshot_type: self.snapshot_type,
                iops: self.iops.unwrap_or_default(),
                option_group_name: self.option_group_name,
                percent_progress: self.percent_progress.unwrap_or_default(),
                source_region: self.source_region,
                source_db_snapshot_identifier: self.source_db_snapshot_identifier,
                storage_type: self.storage_type,
                tde_credential_arn: self.tde_credential_arn,
                encrypted: self.encrypted.unwrap_or_default(),
                kms_key_id: self.kms_key_id,
                timezone: self.timezone,
                iam_database_authentication_enabled: self
                    .iam_database_authentication_enabled
                    .unwrap_or_default(),
                processor_features: self.processor_features,
                dbi_resource_id: self.dbi_resource_id,
            }
        }
    }
}
impl AwsRdsDbSnapshotDetails {
    /// Creates a new builder-style object to manufacture [`AwsRdsDbSnapshotDetails`](crate::model::AwsRdsDbSnapshotDetails)
    pub fn builder() -> crate::model::aws_rds_db_snapshot_details::Builder {
        crate::model::aws_rds_db_snapshot_details::Builder::default()
    }
}

/// <p>A processor feature.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRdsDbProcessorFeature {
    /// <p>The name of the processor feature.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The value of the processor feature.</p>
    pub value: std::option::Option<std::string::String>,
}
impl AwsRdsDbProcessorFeature {
    /// <p>The name of the processor feature.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The value of the processor feature.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for AwsRdsDbProcessorFeature {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRdsDbProcessorFeature");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`AwsRdsDbProcessorFeature`](crate::model::AwsRdsDbProcessorFeature)
pub mod aws_rds_db_processor_feature {

    /// A builder for [`AwsRdsDbProcessorFeature`](crate::model::AwsRdsDbProcessorFeature)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the processor feature.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the processor feature.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The value of the processor feature.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the processor feature.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRdsDbProcessorFeature`](crate::model::AwsRdsDbProcessorFeature)
        pub fn build(self) -> crate::model::AwsRdsDbProcessorFeature {
            crate::model::AwsRdsDbProcessorFeature {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl AwsRdsDbProcessorFeature {
    /// Creates a new builder-style object to manufacture [`AwsRdsDbProcessorFeature`](crate::model::AwsRdsDbProcessorFeature)
    pub fn builder() -> crate::model::aws_rds_db_processor_feature::Builder {
        crate::model::aws_rds_db_processor_feature::Builder::default()
    }
}

/// <p>Provides information about an WAF web access control list (web ACL).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsWafWebAclDetails {
    /// <p>A friendly name or description of the web ACL. You can't change the name of a web ACL after you create it.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The action to perform if none of the rules contained in the web ACL match.</p>
    pub default_action: std::option::Option<std::string::String>,
    /// <p>An array that contains the action for each rule in a web ACL, the priority of the rule, and the ID of the rule.</p>
    pub rules: std::option::Option<std::vec::Vec<crate::model::AwsWafWebAclRule>>,
    /// <p>A unique identifier for a web ACL.</p>
    pub web_acl_id: std::option::Option<std::string::String>,
}
impl AwsWafWebAclDetails {
    /// <p>A friendly name or description of the web ACL. You can't change the name of a web ACL after you create it.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The action to perform if none of the rules contained in the web ACL match.</p>
    pub fn default_action(&self) -> std::option::Option<&str> {
        self.default_action.as_deref()
    }
    /// <p>An array that contains the action for each rule in a web ACL, the priority of the rule, and the ID of the rule.</p>
    pub fn rules(&self) -> std::option::Option<&[crate::model::AwsWafWebAclRule]> {
        self.rules.as_deref()
    }
    /// <p>A unique identifier for a web ACL.</p>
    pub fn web_acl_id(&self) -> std::option::Option<&str> {
        self.web_acl_id.as_deref()
    }
}
impl std::fmt::Debug for AwsWafWebAclDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsWafWebAclDetails");
        formatter.field("name", &self.name);
        formatter.field("default_action", &self.default_action);
        formatter.field("rules", &self.rules);
        formatter.field("web_acl_id", &self.web_acl_id);
        formatter.finish()
    }
}
/// See [`AwsWafWebAclDetails`](crate::model::AwsWafWebAclDetails)
pub mod aws_waf_web_acl_details {

    /// A builder for [`AwsWafWebAclDetails`](crate::model::AwsWafWebAclDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) default_action: std::option::Option<std::string::String>,
        pub(crate) rules: std::option::Option<std::vec::Vec<crate::model::AwsWafWebAclRule>>,
        pub(crate) web_acl_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A friendly name or description of the web ACL. You can't change the name of a web ACL after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A friendly name or description of the web ACL. You can't change the name of a web ACL after you create it.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The action to perform if none of the rules contained in the web ACL match.</p>
        pub fn default_action(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_action = Some(input.into());
            self
        }
        /// <p>The action to perform if none of the rules contained in the web ACL match.</p>
        pub fn set_default_action(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_action = input;
            self
        }
        /// Appends an item to `rules`.
        ///
        /// To override the contents of this collection use [`set_rules`](Self::set_rules).
        ///
        /// <p>An array that contains the action for each rule in a web ACL, the priority of the rule, and the ID of the rule.</p>
        pub fn rules(mut self, input: crate::model::AwsWafWebAclRule) -> Self {
            let mut v = self.rules.unwrap_or_default();
            v.push(input);
            self.rules = Some(v);
            self
        }
        /// <p>An array that contains the action for each rule in a web ACL, the priority of the rule, and the ID of the rule.</p>
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsWafWebAclRule>>,
        ) -> Self {
            self.rules = input;
            self
        }
        /// <p>A unique identifier for a web ACL.</p>
        pub fn web_acl_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.web_acl_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for a web ACL.</p>
        pub fn set_web_acl_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.web_acl_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsWafWebAclDetails`](crate::model::AwsWafWebAclDetails)
        pub fn build(self) -> crate::model::AwsWafWebAclDetails {
            crate::model::AwsWafWebAclDetails {
                name: self.name,
                default_action: self.default_action,
                rules: self.rules,
                web_acl_id: self.web_acl_id,
            }
        }
    }
}
impl AwsWafWebAclDetails {
    /// Creates a new builder-style object to manufacture [`AwsWafWebAclDetails`](crate::model::AwsWafWebAclDetails)
    pub fn builder() -> crate::model::aws_waf_web_acl_details::Builder {
        crate::model::aws_waf_web_acl_details::Builder::default()
    }
}

/// <p>Details for a rule in an WAF web ACL.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsWafWebAclRule {
    /// <p>Specifies the action that CloudFront or WAF takes when a web request matches the conditions in the rule. </p>
    pub action: std::option::Option<crate::model::WafAction>,
    /// <p>Rules to exclude from a rule group.</p>
    pub excluded_rules: std::option::Option<std::vec::Vec<crate::model::WafExcludedRule>>,
    /// <p>Use the <code>OverrideAction</code> to test your <code>RuleGroup</code>.</p>
    /// <p>Any rule in a <code>RuleGroup</code> can potentially block a request. If you set the <code>OverrideAction</code> to <code>None</code>, the <code>RuleGroup</code> blocks a request if any individual rule in the <code>RuleGroup</code> matches the request and is configured to block that request.</p>
    /// <p>However, if you first want to test the <code>RuleGroup</code>, set the <code>OverrideAction</code> to <code>Count</code>. The <code>RuleGroup</code> then overrides any block action specified by individual rules contained within the group. Instead of blocking matching requests, those requests are counted.</p>
    /// <p> <code>ActivatedRule</code>|<code>OverrideAction</code> applies only when updating or adding a <code>RuleGroup</code> to a web ACL. In this case you do not use <code>ActivatedRule</code> <code>Action</code>. For all other update requests, <code>ActivatedRule</code> <code>Action</code> is used instead of <code>ActivatedRule</code> <code>OverrideAction</code>.</p>
    pub override_action: std::option::Option<crate::model::WafOverrideAction>,
    /// <p>Specifies the order in which the rules in a web ACL are evaluated. Rules with a lower value for <code>Priority</code> are evaluated before rules with a higher value. The value must be a unique integer. If you add multiple rules to a web ACL, the values do not need to be consecutive.</p>
    pub priority: i32,
    /// <p>The identifier for a rule.</p>
    pub rule_id: std::option::Option<std::string::String>,
    /// <p>The rule type.</p>
    /// <p>Valid values: <code>REGULAR</code> | <code>RATE_BASED</code> | <code>GROUP</code> </p>
    /// <p>The default is <code>REGULAR</code>.</p>
    pub r#type: std::option::Option<std::string::String>,
}
impl AwsWafWebAclRule {
    /// <p>Specifies the action that CloudFront or WAF takes when a web request matches the conditions in the rule. </p>
    pub fn action(&self) -> std::option::Option<&crate::model::WafAction> {
        self.action.as_ref()
    }
    /// <p>Rules to exclude from a rule group.</p>
    pub fn excluded_rules(&self) -> std::option::Option<&[crate::model::WafExcludedRule]> {
        self.excluded_rules.as_deref()
    }
    /// <p>Use the <code>OverrideAction</code> to test your <code>RuleGroup</code>.</p>
    /// <p>Any rule in a <code>RuleGroup</code> can potentially block a request. If you set the <code>OverrideAction</code> to <code>None</code>, the <code>RuleGroup</code> blocks a request if any individual rule in the <code>RuleGroup</code> matches the request and is configured to block that request.</p>
    /// <p>However, if you first want to test the <code>RuleGroup</code>, set the <code>OverrideAction</code> to <code>Count</code>. The <code>RuleGroup</code> then overrides any block action specified by individual rules contained within the group. Instead of blocking matching requests, those requests are counted.</p>
    /// <p> <code>ActivatedRule</code>|<code>OverrideAction</code> applies only when updating or adding a <code>RuleGroup</code> to a web ACL. In this case you do not use <code>ActivatedRule</code> <code>Action</code>. For all other update requests, <code>ActivatedRule</code> <code>Action</code> is used instead of <code>ActivatedRule</code> <code>OverrideAction</code>.</p>
    pub fn override_action(&self) -> std::option::Option<&crate::model::WafOverrideAction> {
        self.override_action.as_ref()
    }
    /// <p>Specifies the order in which the rules in a web ACL are evaluated. Rules with a lower value for <code>Priority</code> are evaluated before rules with a higher value. The value must be a unique integer. If you add multiple rules to a web ACL, the values do not need to be consecutive.</p>
    pub fn priority(&self) -> i32 {
        self.priority
    }
    /// <p>The identifier for a rule.</p>
    pub fn rule_id(&self) -> std::option::Option<&str> {
        self.rule_id.as_deref()
    }
    /// <p>The rule type.</p>
    /// <p>Valid values: <code>REGULAR</code> | <code>RATE_BASED</code> | <code>GROUP</code> </p>
    /// <p>The default is <code>REGULAR</code>.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for AwsWafWebAclRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsWafWebAclRule");
        formatter.field("action", &self.action);
        formatter.field("excluded_rules", &self.excluded_rules);
        formatter.field("override_action", &self.override_action);
        formatter.field("priority", &self.priority);
        formatter.field("rule_id", &self.rule_id);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AwsWafWebAclRule`](crate::model::AwsWafWebAclRule)
pub mod aws_waf_web_acl_rule {

    /// A builder for [`AwsWafWebAclRule`](crate::model::AwsWafWebAclRule)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action: std::option::Option<crate::model::WafAction>,
        pub(crate) excluded_rules:
            std::option::Option<std::vec::Vec<crate::model::WafExcludedRule>>,
        pub(crate) override_action: std::option::Option<crate::model::WafOverrideAction>,
        pub(crate) priority: std::option::Option<i32>,
        pub(crate) rule_id: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the action that CloudFront or WAF takes when a web request matches the conditions in the rule. </p>
        pub fn action(mut self, input: crate::model::WafAction) -> Self {
            self.action = Some(input);
            self
        }
        /// <p>Specifies the action that CloudFront or WAF takes when a web request matches the conditions in the rule. </p>
        pub fn set_action(mut self, input: std::option::Option<crate::model::WafAction>) -> Self {
            self.action = input;
            self
        }
        /// Appends an item to `excluded_rules`.
        ///
        /// To override the contents of this collection use [`set_excluded_rules`](Self::set_excluded_rules).
        ///
        /// <p>Rules to exclude from a rule group.</p>
        pub fn excluded_rules(mut self, input: crate::model::WafExcludedRule) -> Self {
            let mut v = self.excluded_rules.unwrap_or_default();
            v.push(input);
            self.excluded_rules = Some(v);
            self
        }
        /// <p>Rules to exclude from a rule group.</p>
        pub fn set_excluded_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::WafExcludedRule>>,
        ) -> Self {
            self.excluded_rules = input;
            self
        }
        /// <p>Use the <code>OverrideAction</code> to test your <code>RuleGroup</code>.</p>
        /// <p>Any rule in a <code>RuleGroup</code> can potentially block a request. If you set the <code>OverrideAction</code> to <code>None</code>, the <code>RuleGroup</code> blocks a request if any individual rule in the <code>RuleGroup</code> matches the request and is configured to block that request.</p>
        /// <p>However, if you first want to test the <code>RuleGroup</code>, set the <code>OverrideAction</code> to <code>Count</code>. The <code>RuleGroup</code> then overrides any block action specified by individual rules contained within the group. Instead of blocking matching requests, those requests are counted.</p>
        /// <p> <code>ActivatedRule</code>|<code>OverrideAction</code> applies only when updating or adding a <code>RuleGroup</code> to a web ACL. In this case you do not use <code>ActivatedRule</code> <code>Action</code>. For all other update requests, <code>ActivatedRule</code> <code>Action</code> is used instead of <code>ActivatedRule</code> <code>OverrideAction</code>.</p>
        pub fn override_action(mut self, input: crate::model::WafOverrideAction) -> Self {
            self.override_action = Some(input);
            self
        }
        /// <p>Use the <code>OverrideAction</code> to test your <code>RuleGroup</code>.</p>
        /// <p>Any rule in a <code>RuleGroup</code> can potentially block a request. If you set the <code>OverrideAction</code> to <code>None</code>, the <code>RuleGroup</code> blocks a request if any individual rule in the <code>RuleGroup</code> matches the request and is configured to block that request.</p>
        /// <p>However, if you first want to test the <code>RuleGroup</code>, set the <code>OverrideAction</code> to <code>Count</code>. The <code>RuleGroup</code> then overrides any block action specified by individual rules contained within the group. Instead of blocking matching requests, those requests are counted.</p>
        /// <p> <code>ActivatedRule</code>|<code>OverrideAction</code> applies only when updating or adding a <code>RuleGroup</code> to a web ACL. In this case you do not use <code>ActivatedRule</code> <code>Action</code>. For all other update requests, <code>ActivatedRule</code> <code>Action</code> is used instead of <code>ActivatedRule</code> <code>OverrideAction</code>.</p>
        pub fn set_override_action(
            mut self,
            input: std::option::Option<crate::model::WafOverrideAction>,
        ) -> Self {
            self.override_action = input;
            self
        }
        /// <p>Specifies the order in which the rules in a web ACL are evaluated. Rules with a lower value for <code>Priority</code> are evaluated before rules with a higher value. The value must be a unique integer. If you add multiple rules to a web ACL, the values do not need to be consecutive.</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        /// <p>Specifies the order in which the rules in a web ACL are evaluated. Rules with a lower value for <code>Priority</code> are evaluated before rules with a higher value. The value must be a unique integer. If you add multiple rules to a web ACL, the values do not need to be consecutive.</p>
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input;
            self
        }
        /// <p>The identifier for a rule.</p>
        pub fn rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_id = Some(input.into());
            self
        }
        /// <p>The identifier for a rule.</p>
        pub fn set_rule_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_id = input;
            self
        }
        /// <p>The rule type.</p>
        /// <p>Valid values: <code>REGULAR</code> | <code>RATE_BASED</code> | <code>GROUP</code> </p>
        /// <p>The default is <code>REGULAR</code>.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The rule type.</p>
        /// <p>Valid values: <code>REGULAR</code> | <code>RATE_BASED</code> | <code>GROUP</code> </p>
        /// <p>The default is <code>REGULAR</code>.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsWafWebAclRule`](crate::model::AwsWafWebAclRule)
        pub fn build(self) -> crate::model::AwsWafWebAclRule {
            crate::model::AwsWafWebAclRule {
                action: self.action,
                excluded_rules: self.excluded_rules,
                override_action: self.override_action,
                priority: self.priority.unwrap_or_default(),
                rule_id: self.rule_id,
                r#type: self.r#type,
            }
        }
    }
}
impl AwsWafWebAclRule {
    /// Creates a new builder-style object to manufacture [`AwsWafWebAclRule`](crate::model::AwsWafWebAclRule)
    pub fn builder() -> crate::model::aws_waf_web_acl_rule::Builder {
        crate::model::aws_waf_web_acl_rule::Builder::default()
    }
}

/// <p>Details about an override action for a rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WafOverrideAction {
    /// <p> <code>COUNT</code> overrides the action specified by the individual rule within a <code>RuleGroup</code> .</p>
    /// <p>If set to <code>NONE</code>, the rule's action takes place.</p>
    pub r#type: std::option::Option<std::string::String>,
}
impl WafOverrideAction {
    /// <p> <code>COUNT</code> overrides the action specified by the individual rule within a <code>RuleGroup</code> .</p>
    /// <p>If set to <code>NONE</code>, the rule's action takes place.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for WafOverrideAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WafOverrideAction");
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`WafOverrideAction`](crate::model::WafOverrideAction)
pub mod waf_override_action {

    /// A builder for [`WafOverrideAction`](crate::model::WafOverrideAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> <code>COUNT</code> overrides the action specified by the individual rule within a <code>RuleGroup</code> .</p>
        /// <p>If set to <code>NONE</code>, the rule's action takes place.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p> <code>COUNT</code> overrides the action specified by the individual rule within a <code>RuleGroup</code> .</p>
        /// <p>If set to <code>NONE</code>, the rule's action takes place.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`WafOverrideAction`](crate::model::WafOverrideAction)
        pub fn build(self) -> crate::model::WafOverrideAction {
            crate::model::WafOverrideAction {
                r#type: self.r#type,
            }
        }
    }
}
impl WafOverrideAction {
    /// Creates a new builder-style object to manufacture [`WafOverrideAction`](crate::model::WafOverrideAction)
    pub fn builder() -> crate::model::waf_override_action::Builder {
        crate::model::waf_override_action::Builder::default()
    }
}

/// <p>Details about a rule to exclude from a rule group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WafExcludedRule {
    /// <p>The unique identifier for the rule to exclude from the rule group.</p>
    pub rule_id: std::option::Option<std::string::String>,
}
impl WafExcludedRule {
    /// <p>The unique identifier for the rule to exclude from the rule group.</p>
    pub fn rule_id(&self) -> std::option::Option<&str> {
        self.rule_id.as_deref()
    }
}
impl std::fmt::Debug for WafExcludedRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WafExcludedRule");
        formatter.field("rule_id", &self.rule_id);
        formatter.finish()
    }
}
/// See [`WafExcludedRule`](crate::model::WafExcludedRule)
pub mod waf_excluded_rule {

    /// A builder for [`WafExcludedRule`](crate::model::WafExcludedRule)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for the rule to exclude from the rule group.</p>
        pub fn rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the rule to exclude from the rule group.</p>
        pub fn set_rule_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_id = input;
            self
        }
        /// Consumes the builder and constructs a [`WafExcludedRule`](crate::model::WafExcludedRule)
        pub fn build(self) -> crate::model::WafExcludedRule {
            crate::model::WafExcludedRule {
                rule_id: self.rule_id,
            }
        }
    }
}
impl WafExcludedRule {
    /// Creates a new builder-style object to manufacture [`WafExcludedRule`](crate::model::WafExcludedRule)
    pub fn builder() -> crate::model::waf_excluded_rule::Builder {
        crate::model::waf_excluded_rule::Builder::default()
    }
}

/// <p>Details about the action that CloudFront or WAF takes when a web request matches the conditions in the rule. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WafAction {
    /// <p>Specifies how you want WAF to respond to requests that match the settings in a rule.</p>
    /// <p>Valid settings include the following:</p>
    /// <ul>
    /// <li> <p> <code>ALLOW</code> - WAF allows requests</p> </li>
    /// <li> <p> <code>BLOCK</code> - WAF blocks requests</p> </li>
    /// <li> <p> <code>COUNT</code> - WAF increments a counter of the requests that match all of the conditions in the rule. WAF then continues to inspect the web request based on the remaining rules in the web ACL. You can't specify <code>COUNT</code> for the default action for a web ACL.</p> </li>
    /// </ul>
    pub r#type: std::option::Option<std::string::String>,
}
impl WafAction {
    /// <p>Specifies how you want WAF to respond to requests that match the settings in a rule.</p>
    /// <p>Valid settings include the following:</p>
    /// <ul>
    /// <li> <p> <code>ALLOW</code> - WAF allows requests</p> </li>
    /// <li> <p> <code>BLOCK</code> - WAF blocks requests</p> </li>
    /// <li> <p> <code>COUNT</code> - WAF increments a counter of the requests that match all of the conditions in the rule. WAF then continues to inspect the web request based on the remaining rules in the web ACL. You can't specify <code>COUNT</code> for the default action for a web ACL.</p> </li>
    /// </ul>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for WafAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WafAction");
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`WafAction`](crate::model::WafAction)
pub mod waf_action {

    /// A builder for [`WafAction`](crate::model::WafAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies how you want WAF to respond to requests that match the settings in a rule.</p>
        /// <p>Valid settings include the following:</p>
        /// <ul>
        /// <li> <p> <code>ALLOW</code> - WAF allows requests</p> </li>
        /// <li> <p> <code>BLOCK</code> - WAF blocks requests</p> </li>
        /// <li> <p> <code>COUNT</code> - WAF increments a counter of the requests that match all of the conditions in the rule. WAF then continues to inspect the web request based on the remaining rules in the web ACL. You can't specify <code>COUNT</code> for the default action for a web ACL.</p> </li>
        /// </ul>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>Specifies how you want WAF to respond to requests that match the settings in a rule.</p>
        /// <p>Valid settings include the following:</p>
        /// <ul>
        /// <li> <p> <code>ALLOW</code> - WAF allows requests</p> </li>
        /// <li> <p> <code>BLOCK</code> - WAF blocks requests</p> </li>
        /// <li> <p> <code>COUNT</code> - WAF increments a counter of the requests that match all of the conditions in the rule. WAF then continues to inspect the web request based on the remaining rules in the web ACL. You can't specify <code>COUNT</code> for the default action for a web ACL.</p> </li>
        /// </ul>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`WafAction`](crate::model::WafAction)
        pub fn build(self) -> crate::model::WafAction {
            crate::model::WafAction {
                r#type: self.r#type,
            }
        }
    }
}
impl WafAction {
    /// Creates a new builder-style object to manufacture [`WafAction`](crate::model::WafAction)
    pub fn builder() -> crate::model::waf_action::Builder {
        crate::model::waf_action::Builder::default()
    }
}

/// <p>Data about a queue.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsSqsQueueDetails {
    /// <p>The length of time, in seconds, for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling KMS again.</p>
    pub kms_data_key_reuse_period_seconds: i32,
    /// <p>The ID of an Amazon Web Services managed key for Amazon SQS or a custom KMS key.</p>
    pub kms_master_key_id: std::option::Option<std::string::String>,
    /// <p>The name of the new queue.</p>
    pub queue_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the dead-letter queue to which Amazon SQS moves messages after the value of <code>maxReceiveCount</code> is exceeded. </p>
    pub dead_letter_target_arn: std::option::Option<std::string::String>,
}
impl AwsSqsQueueDetails {
    /// <p>The length of time, in seconds, for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling KMS again.</p>
    pub fn kms_data_key_reuse_period_seconds(&self) -> i32 {
        self.kms_data_key_reuse_period_seconds
    }
    /// <p>The ID of an Amazon Web Services managed key for Amazon SQS or a custom KMS key.</p>
    pub fn kms_master_key_id(&self) -> std::option::Option<&str> {
        self.kms_master_key_id.as_deref()
    }
    /// <p>The name of the new queue.</p>
    pub fn queue_name(&self) -> std::option::Option<&str> {
        self.queue_name.as_deref()
    }
    /// <p>The ARN of the dead-letter queue to which Amazon SQS moves messages after the value of <code>maxReceiveCount</code> is exceeded. </p>
    pub fn dead_letter_target_arn(&self) -> std::option::Option<&str> {
        self.dead_letter_target_arn.as_deref()
    }
}
impl std::fmt::Debug for AwsSqsQueueDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsSqsQueueDetails");
        formatter.field(
            "kms_data_key_reuse_period_seconds",
            &self.kms_data_key_reuse_period_seconds,
        );
        formatter.field("kms_master_key_id", &self.kms_master_key_id);
        formatter.field("queue_name", &self.queue_name);
        formatter.field("dead_letter_target_arn", &self.dead_letter_target_arn);
        formatter.finish()
    }
}
/// See [`AwsSqsQueueDetails`](crate::model::AwsSqsQueueDetails)
pub mod aws_sqs_queue_details {

    /// A builder for [`AwsSqsQueueDetails`](crate::model::AwsSqsQueueDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) kms_data_key_reuse_period_seconds: std::option::Option<i32>,
        pub(crate) kms_master_key_id: std::option::Option<std::string::String>,
        pub(crate) queue_name: std::option::Option<std::string::String>,
        pub(crate) dead_letter_target_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The length of time, in seconds, for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling KMS again.</p>
        pub fn kms_data_key_reuse_period_seconds(mut self, input: i32) -> Self {
            self.kms_data_key_reuse_period_seconds = Some(input);
            self
        }
        /// <p>The length of time, in seconds, for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling KMS again.</p>
        pub fn set_kms_data_key_reuse_period_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.kms_data_key_reuse_period_seconds = input;
            self
        }
        /// <p>The ID of an Amazon Web Services managed key for Amazon SQS or a custom KMS key.</p>
        pub fn kms_master_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_master_key_id = Some(input.into());
            self
        }
        /// <p>The ID of an Amazon Web Services managed key for Amazon SQS or a custom KMS key.</p>
        pub fn set_kms_master_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.kms_master_key_id = input;
            self
        }
        /// <p>The name of the new queue.</p>
        pub fn queue_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.queue_name = Some(input.into());
            self
        }
        /// <p>The name of the new queue.</p>
        pub fn set_queue_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.queue_name = input;
            self
        }
        /// <p>The ARN of the dead-letter queue to which Amazon SQS moves messages after the value of <code>maxReceiveCount</code> is exceeded. </p>
        pub fn dead_letter_target_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.dead_letter_target_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the dead-letter queue to which Amazon SQS moves messages after the value of <code>maxReceiveCount</code> is exceeded. </p>
        pub fn set_dead_letter_target_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dead_letter_target_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsSqsQueueDetails`](crate::model::AwsSqsQueueDetails)
        pub fn build(self) -> crate::model::AwsSqsQueueDetails {
            crate::model::AwsSqsQueueDetails {
                kms_data_key_reuse_period_seconds: self
                    .kms_data_key_reuse_period_seconds
                    .unwrap_or_default(),
                kms_master_key_id: self.kms_master_key_id,
                queue_name: self.queue_name,
                dead_letter_target_arn: self.dead_letter_target_arn,
            }
        }
    }
}
impl AwsSqsQueueDetails {
    /// Creates a new builder-style object to manufacture [`AwsSqsQueueDetails`](crate::model::AwsSqsQueueDetails)
    pub fn builder() -> crate::model::aws_sqs_queue_details::Builder {
        crate::model::aws_sqs_queue_details::Builder::default()
    }
}

/// <p>Provides information about an Amazon SNS topic to which notifications can be published.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsSnsTopicDetails {
    /// <p>The ID of an Amazon Web Services managed key for Amazon SNS or a customer managed key.</p>
    pub kms_master_key_id: std::option::Option<std::string::String>,
    /// <p>Subscription is an embedded property that describes the subscription endpoints of an Amazon SNS topic.</p>
    pub subscription: std::option::Option<std::vec::Vec<crate::model::AwsSnsTopicSubscription>>,
    /// <p>The name of the Amazon SNS topic.</p>
    pub topic_name: std::option::Option<std::string::String>,
    /// <p>The subscription's owner.</p>
    pub owner: std::option::Option<std::string::String>,
    /// <p>Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an Amazon SQS endpoint. </p>
    pub sqs_success_feedback_role_arn: std::option::Option<std::string::String>,
    /// <p>Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an Amazon SQS endpoint. </p>
    pub sqs_failure_feedback_role_arn: std::option::Option<std::string::String>,
    /// <p>Indicates failed message delivery status for an Amazon SNS topic that is subscribed to a platform application endpoint. </p>
    pub application_success_feedback_role_arn: std::option::Option<std::string::String>,
    /// <p>Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an Amazon Kinesis Data Firehose endpoint. </p>
    pub firehose_success_feedback_role_arn: std::option::Option<std::string::String>,
    /// <p>Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an Amazon Kinesis Data Firehose endpoint. </p>
    pub firehose_failure_feedback_role_arn: std::option::Option<std::string::String>,
    /// <p>Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an HTTP endpoint. </p>
    pub http_success_feedback_role_arn: std::option::Option<std::string::String>,
    /// <p>Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an HTTP endpoint. </p>
    pub http_failure_feedback_role_arn: std::option::Option<std::string::String>,
}
impl AwsSnsTopicDetails {
    /// <p>The ID of an Amazon Web Services managed key for Amazon SNS or a customer managed key.</p>
    pub fn kms_master_key_id(&self) -> std::option::Option<&str> {
        self.kms_master_key_id.as_deref()
    }
    /// <p>Subscription is an embedded property that describes the subscription endpoints of an Amazon SNS topic.</p>
    pub fn subscription(&self) -> std::option::Option<&[crate::model::AwsSnsTopicSubscription]> {
        self.subscription.as_deref()
    }
    /// <p>The name of the Amazon SNS topic.</p>
    pub fn topic_name(&self) -> std::option::Option<&str> {
        self.topic_name.as_deref()
    }
    /// <p>The subscription's owner.</p>
    pub fn owner(&self) -> std::option::Option<&str> {
        self.owner.as_deref()
    }
    /// <p>Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an Amazon SQS endpoint. </p>
    pub fn sqs_success_feedback_role_arn(&self) -> std::option::Option<&str> {
        self.sqs_success_feedback_role_arn.as_deref()
    }
    /// <p>Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an Amazon SQS endpoint. </p>
    pub fn sqs_failure_feedback_role_arn(&self) -> std::option::Option<&str> {
        self.sqs_failure_feedback_role_arn.as_deref()
    }
    /// <p>Indicates failed message delivery status for an Amazon SNS topic that is subscribed to a platform application endpoint. </p>
    pub fn application_success_feedback_role_arn(&self) -> std::option::Option<&str> {
        self.application_success_feedback_role_arn.as_deref()
    }
    /// <p>Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an Amazon Kinesis Data Firehose endpoint. </p>
    pub fn firehose_success_feedback_role_arn(&self) -> std::option::Option<&str> {
        self.firehose_success_feedback_role_arn.as_deref()
    }
    /// <p>Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an Amazon Kinesis Data Firehose endpoint. </p>
    pub fn firehose_failure_feedback_role_arn(&self) -> std::option::Option<&str> {
        self.firehose_failure_feedback_role_arn.as_deref()
    }
    /// <p>Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an HTTP endpoint. </p>
    pub fn http_success_feedback_role_arn(&self) -> std::option::Option<&str> {
        self.http_success_feedback_role_arn.as_deref()
    }
    /// <p>Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an HTTP endpoint. </p>
    pub fn http_failure_feedback_role_arn(&self) -> std::option::Option<&str> {
        self.http_failure_feedback_role_arn.as_deref()
    }
}
impl std::fmt::Debug for AwsSnsTopicDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsSnsTopicDetails");
        formatter.field("kms_master_key_id", &self.kms_master_key_id);
        formatter.field("subscription", &self.subscription);
        formatter.field("topic_name", &self.topic_name);
        formatter.field("owner", &self.owner);
        formatter.field(
            "sqs_success_feedback_role_arn",
            &self.sqs_success_feedback_role_arn,
        );
        formatter.field(
            "sqs_failure_feedback_role_arn",
            &self.sqs_failure_feedback_role_arn,
        );
        formatter.field(
            "application_success_feedback_role_arn",
            &self.application_success_feedback_role_arn,
        );
        formatter.field(
            "firehose_success_feedback_role_arn",
            &self.firehose_success_feedback_role_arn,
        );
        formatter.field(
            "firehose_failure_feedback_role_arn",
            &self.firehose_failure_feedback_role_arn,
        );
        formatter.field(
            "http_success_feedback_role_arn",
            &self.http_success_feedback_role_arn,
        );
        formatter.field(
            "http_failure_feedback_role_arn",
            &self.http_failure_feedback_role_arn,
        );
        formatter.finish()
    }
}
/// See [`AwsSnsTopicDetails`](crate::model::AwsSnsTopicDetails)
pub mod aws_sns_topic_details {

    /// A builder for [`AwsSnsTopicDetails`](crate::model::AwsSnsTopicDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) kms_master_key_id: std::option::Option<std::string::String>,
        pub(crate) subscription:
            std::option::Option<std::vec::Vec<crate::model::AwsSnsTopicSubscription>>,
        pub(crate) topic_name: std::option::Option<std::string::String>,
        pub(crate) owner: std::option::Option<std::string::String>,
        pub(crate) sqs_success_feedback_role_arn: std::option::Option<std::string::String>,
        pub(crate) sqs_failure_feedback_role_arn: std::option::Option<std::string::String>,
        pub(crate) application_success_feedback_role_arn: std::option::Option<std::string::String>,
        pub(crate) firehose_success_feedback_role_arn: std::option::Option<std::string::String>,
        pub(crate) firehose_failure_feedback_role_arn: std::option::Option<std::string::String>,
        pub(crate) http_success_feedback_role_arn: std::option::Option<std::string::String>,
        pub(crate) http_failure_feedback_role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of an Amazon Web Services managed key for Amazon SNS or a customer managed key.</p>
        pub fn kms_master_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_master_key_id = Some(input.into());
            self
        }
        /// <p>The ID of an Amazon Web Services managed key for Amazon SNS or a customer managed key.</p>
        pub fn set_kms_master_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.kms_master_key_id = input;
            self
        }
        /// Appends an item to `subscription`.
        ///
        /// To override the contents of this collection use [`set_subscription`](Self::set_subscription).
        ///
        /// <p>Subscription is an embedded property that describes the subscription endpoints of an Amazon SNS topic.</p>
        pub fn subscription(mut self, input: crate::model::AwsSnsTopicSubscription) -> Self {
            let mut v = self.subscription.unwrap_or_default();
            v.push(input);
            self.subscription = Some(v);
            self
        }
        /// <p>Subscription is an embedded property that describes the subscription endpoints of an Amazon SNS topic.</p>
        pub fn set_subscription(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsSnsTopicSubscription>>,
        ) -> Self {
            self.subscription = input;
            self
        }
        /// <p>The name of the Amazon SNS topic.</p>
        pub fn topic_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.topic_name = Some(input.into());
            self
        }
        /// <p>The name of the Amazon SNS topic.</p>
        pub fn set_topic_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.topic_name = input;
            self
        }
        /// <p>The subscription's owner.</p>
        pub fn owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner = Some(input.into());
            self
        }
        /// <p>The subscription's owner.</p>
        pub fn set_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner = input;
            self
        }
        /// <p>Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an Amazon SQS endpoint. </p>
        pub fn sqs_success_feedback_role_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.sqs_success_feedback_role_arn = Some(input.into());
            self
        }
        /// <p>Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an Amazon SQS endpoint. </p>
        pub fn set_sqs_success_feedback_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sqs_success_feedback_role_arn = input;
            self
        }
        /// <p>Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an Amazon SQS endpoint. </p>
        pub fn sqs_failure_feedback_role_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.sqs_failure_feedback_role_arn = Some(input.into());
            self
        }
        /// <p>Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an Amazon SQS endpoint. </p>
        pub fn set_sqs_failure_feedback_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sqs_failure_feedback_role_arn = input;
            self
        }
        /// <p>Indicates failed message delivery status for an Amazon SNS topic that is subscribed to a platform application endpoint. </p>
        pub fn application_success_feedback_role_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.application_success_feedback_role_arn = Some(input.into());
            self
        }
        /// <p>Indicates failed message delivery status for an Amazon SNS topic that is subscribed to a platform application endpoint. </p>
        pub fn set_application_success_feedback_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_success_feedback_role_arn = input;
            self
        }
        /// <p>Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an Amazon Kinesis Data Firehose endpoint. </p>
        pub fn firehose_success_feedback_role_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.firehose_success_feedback_role_arn = Some(input.into());
            self
        }
        /// <p>Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an Amazon Kinesis Data Firehose endpoint. </p>
        pub fn set_firehose_success_feedback_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.firehose_success_feedback_role_arn = input;
            self
        }
        /// <p>Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an Amazon Kinesis Data Firehose endpoint. </p>
        pub fn firehose_failure_feedback_role_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.firehose_failure_feedback_role_arn = Some(input.into());
            self
        }
        /// <p>Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an Amazon Kinesis Data Firehose endpoint. </p>
        pub fn set_firehose_failure_feedback_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.firehose_failure_feedback_role_arn = input;
            self
        }
        /// <p>Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an HTTP endpoint. </p>
        pub fn http_success_feedback_role_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.http_success_feedback_role_arn = Some(input.into());
            self
        }
        /// <p>Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an HTTP endpoint. </p>
        pub fn set_http_success_feedback_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.http_success_feedback_role_arn = input;
            self
        }
        /// <p>Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an HTTP endpoint. </p>
        pub fn http_failure_feedback_role_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.http_failure_feedback_role_arn = Some(input.into());
            self
        }
        /// <p>Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an HTTP endpoint. </p>
        pub fn set_http_failure_feedback_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.http_failure_feedback_role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsSnsTopicDetails`](crate::model::AwsSnsTopicDetails)
        pub fn build(self) -> crate::model::AwsSnsTopicDetails {
            crate::model::AwsSnsTopicDetails {
                kms_master_key_id: self.kms_master_key_id,
                subscription: self.subscription,
                topic_name: self.topic_name,
                owner: self.owner,
                sqs_success_feedback_role_arn: self.sqs_success_feedback_role_arn,
                sqs_failure_feedback_role_arn: self.sqs_failure_feedback_role_arn,
                application_success_feedback_role_arn: self.application_success_feedback_role_arn,
                firehose_success_feedback_role_arn: self.firehose_success_feedback_role_arn,
                firehose_failure_feedback_role_arn: self.firehose_failure_feedback_role_arn,
                http_success_feedback_role_arn: self.http_success_feedback_role_arn,
                http_failure_feedback_role_arn: self.http_failure_feedback_role_arn,
            }
        }
    }
}
impl AwsSnsTopicDetails {
    /// Creates a new builder-style object to manufacture [`AwsSnsTopicDetails`](crate::model::AwsSnsTopicDetails)
    pub fn builder() -> crate::model::aws_sns_topic_details::Builder {
        crate::model::aws_sns_topic_details::Builder::default()
    }
}

/// <p>A wrapper type for the attributes of an Amazon SNS subscription.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsSnsTopicSubscription {
    /// <p>The subscription's endpoint (format depends on the protocol).</p>
    pub endpoint: std::option::Option<std::string::String>,
    /// <p>The subscription's protocol.</p>
    pub protocol: std::option::Option<std::string::String>,
}
impl AwsSnsTopicSubscription {
    /// <p>The subscription's endpoint (format depends on the protocol).</p>
    pub fn endpoint(&self) -> std::option::Option<&str> {
        self.endpoint.as_deref()
    }
    /// <p>The subscription's protocol.</p>
    pub fn protocol(&self) -> std::option::Option<&str> {
        self.protocol.as_deref()
    }
}
impl std::fmt::Debug for AwsSnsTopicSubscription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsSnsTopicSubscription");
        formatter.field("endpoint", &self.endpoint);
        formatter.field("protocol", &self.protocol);
        formatter.finish()
    }
}
/// See [`AwsSnsTopicSubscription`](crate::model::AwsSnsTopicSubscription)
pub mod aws_sns_topic_subscription {

    /// A builder for [`AwsSnsTopicSubscription`](crate::model::AwsSnsTopicSubscription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint: std::option::Option<std::string::String>,
        pub(crate) protocol: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The subscription's endpoint (format depends on the protocol).</p>
        pub fn endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint = Some(input.into());
            self
        }
        /// <p>The subscription's endpoint (format depends on the protocol).</p>
        pub fn set_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint = input;
            self
        }
        /// <p>The subscription's protocol.</p>
        pub fn protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.protocol = Some(input.into());
            self
        }
        /// <p>The subscription's protocol.</p>
        pub fn set_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.protocol = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsSnsTopicSubscription`](crate::model::AwsSnsTopicSubscription)
        pub fn build(self) -> crate::model::AwsSnsTopicSubscription {
            crate::model::AwsSnsTopicSubscription {
                endpoint: self.endpoint,
                protocol: self.protocol,
            }
        }
    }
}
impl AwsSnsTopicSubscription {
    /// Creates a new builder-style object to manufacture [`AwsSnsTopicSubscription`](crate::model::AwsSnsTopicSubscription)
    pub fn builder() -> crate::model::aws_sns_topic_subscription::Builder {
        crate::model::aws_sns_topic_subscription::Builder::default()
    }
}

/// <p>Contains the details of an Amazon RDS DB instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRdsDbInstanceDetails {
    /// <p>The IAM roles associated with the DB instance.</p>
    pub associated_roles:
        std::option::Option<std::vec::Vec<crate::model::AwsRdsDbInstanceAssociatedRole>>,
    /// <p>The identifier of the CA certificate for this DB instance.</p>
    pub ca_certificate_identifier: std::option::Option<std::string::String>,
    /// <p>If the DB instance is a member of a DB cluster, contains the name of the DB cluster that the DB instance is a member of.</p>
    pub db_cluster_identifier: std::option::Option<std::string::String>,
    /// <p>Contains a user-supplied database identifier. This identifier is the unique key that identifies a DB instance.</p>
    pub db_instance_identifier: std::option::Option<std::string::String>,
    /// <p>Contains the name of the compute and memory capacity class of the DB instance.</p>
    pub db_instance_class: std::option::Option<std::string::String>,
    /// <p>Specifies the port that the DB instance listens on. If the DB instance is part of a DB cluster, this can be a different port than the DB cluster port.</p>
    pub db_instance_port: i32,
    /// <p>The Amazon Web Services Region-unique, immutable identifier for the DB instance. This identifier is found in CloudTrail log entries whenever the KMS key for the DB instance is accessed. </p>
    pub dbi_resource_id: std::option::Option<std::string::String>,
    /// <p>The meaning of this parameter differs according to the database engine you use.</p>
    /// <p> <b>MySQL, MariaDB, SQL Server, PostgreSQL</b> </p>
    /// <p>Contains the name of the initial database of this instance that was provided at create time, if one was specified when the DB instance was created. This same name is returned for the life of the DB instance.</p>
    /// <p> <b>Oracle</b> </p>
    /// <p>Contains the Oracle System ID (SID) of the created DB instance. Not shown when the returned parameters do not apply to an Oracle DB instance. </p>
    pub db_name: std::option::Option<std::string::String>,
    /// <p>Indicates whether the DB instance has deletion protection enabled.</p>
    /// <p>When deletion protection is enabled, the database cannot be deleted.</p>
    pub deletion_protection: bool,
    /// <p>Specifies the connection endpoint.</p>
    pub endpoint: std::option::Option<crate::model::AwsRdsDbInstanceEndpoint>,
    /// <p>Provides the name of the database engine to use for this DB instance.</p>
    pub engine: std::option::Option<std::string::String>,
    /// <p>Indicates the database engine version.</p>
    pub engine_version: std::option::Option<std::string::String>,
    /// <p>True if mapping of IAM accounts to database accounts is enabled, and otherwise false.</p>
    /// <p>IAM database authentication can be enabled for the following database engines.</p>
    /// <ul>
    /// <li> <p>For MySQL 5.6, minor version 5.6.34 or higher</p> </li>
    /// <li> <p>For MySQL 5.7, minor version 5.7.16 or higher</p> </li>
    /// <li> <p>Aurora 5.6 or higher</p> </li>
    /// </ul>
    pub iam_database_authentication_enabled: bool,
    /// <p>Indicates when the DB instance was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub instance_create_time: std::option::Option<std::string::String>,
    /// <p>If <code>StorageEncrypted</code> is true, the KMS key identifier for the encrypted DB instance.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>Specifies the accessibility options for the DB instance.</p>
    /// <p>A value of true specifies an Internet-facing instance with a publicly resolvable DNS name, which resolves to a public IP address.</p>
    /// <p>A value of false specifies an internal instance with a DNS name that resolves to a private IP address. </p>
    pub publicly_accessible: bool,
    /// <p>Specifies whether the DB instance is encrypted.</p>
    pub storage_encrypted: bool,
    /// <p>The ARN from the key store with which the instance is associated for TDE encryption.</p>
    pub tde_credential_arn: std::option::Option<std::string::String>,
    /// <p>A list of VPC security groups that the DB instance belongs to.</p>
    pub vpc_security_groups:
        std::option::Option<std::vec::Vec<crate::model::AwsRdsDbInstanceVpcSecurityGroup>>,
    /// <p>Whether the DB instance is a multiple Availability Zone deployment.</p>
    pub multi_az: bool,
    /// <p>The ARN of the CloudWatch Logs log stream that receives the enhanced monitoring metrics data for the DB instance.</p>
    pub enhanced_monitoring_resource_arn: std::option::Option<std::string::String>,
    /// <p>The current status of the DB instance.</p>
    pub db_instance_status: std::option::Option<std::string::String>,
    /// <p>The master user name of the DB instance.</p>
    pub master_username: std::option::Option<std::string::String>,
    /// <p>The amount of storage (in gigabytes) to initially allocate for the DB instance.</p>
    pub allocated_storage: i32,
    /// <p>The range of time each day when automated backups are created, if automated backups are enabled.</p>
    /// <p>Uses the format <code>HH:MM-HH:MM</code>. For example, <code>04:52-05:22</code>.</p>
    pub preferred_backup_window: std::option::Option<std::string::String>,
    /// <p>The number of days for which to retain automated backups.</p>
    pub backup_retention_period: i32,
    /// <p>A list of the DB security groups to assign to the DB instance.</p>
    pub db_security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of the DB parameter groups to assign to the DB instance.</p>
    pub db_parameter_groups:
        std::option::Option<std::vec::Vec<crate::model::AwsRdsDbParameterGroup>>,
    /// <p>The Availability Zone where the DB instance will be created.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>Information about the subnet group that is associated with the DB instance.</p>
    pub db_subnet_group: std::option::Option<crate::model::AwsRdsDbSubnetGroup>,
    /// <p>The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).</p>
    /// <p>Uses the format <code>
    /// <day>
    /// :HH:MM-
    /// <day>
    /// :HH:MM
    /// </day>
    /// </day></code>.</p>
    /// <p>For the day values, use <code>mon</code>|<code>tue</code>|<code>wed</code>|<code>thu</code>|<code>fri</code>|<code>sat</code>|<code>sun</code>.</p>
    /// <p>For example, <code>sun:09:32-sun:10:02</code>.</p>
    pub preferred_maintenance_window: std::option::Option<std::string::String>,
    /// <p>Changes to the DB instance that are currently pending.</p>
    pub pending_modified_values: std::option::Option<crate::model::AwsRdsDbPendingModifiedValues>,
    /// <p>Specifies the latest time to which a database can be restored with point-in-time restore.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub latest_restorable_time: std::option::Option<std::string::String>,
    /// <p>Indicates whether minor version patches are applied automatically.</p>
    pub auto_minor_version_upgrade: bool,
    /// <p>If this DB instance is a read replica, contains the identifier of the source DB instance.</p>
    pub read_replica_source_db_instance_identifier: std::option::Option<std::string::String>,
    /// <p>List of identifiers of the read replicas associated with this DB instance.</p>
    pub read_replica_db_instance_identifiers:
        std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>List of identifiers of Aurora DB clusters to which the RDS DB instance is replicated as a read replica.</p>
    pub read_replica_db_cluster_identifiers:
        std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>License model information for this DB instance.</p>
    pub license_model: std::option::Option<std::string::String>,
    /// <p>Specifies the provisioned IOPS (I/O operations per second) for this DB instance.</p>
    pub iops: i32,
    /// <p>The list of option group memberships for this DB instance.</p>
    pub option_group_memberships:
        std::option::Option<std::vec::Vec<crate::model::AwsRdsDbOptionGroupMembership>>,
    /// <p>The name of the character set that this DB instance is associated with.</p>
    pub character_set_name: std::option::Option<std::string::String>,
    /// <p>For a DB instance with multi-Availability Zone support, the name of the secondary Availability Zone.</p>
    pub secondary_availability_zone: std::option::Option<std::string::String>,
    /// <p>The status of a read replica. If the instance isn't a read replica, this is empty.</p>
    pub status_infos: std::option::Option<std::vec::Vec<crate::model::AwsRdsDbStatusInfo>>,
    /// <p>The storage type for the DB instance.</p>
    pub storage_type: std::option::Option<std::string::String>,
    /// <p>The Active Directory domain membership records associated with the DB instance.</p>
    pub domain_memberships:
        std::option::Option<std::vec::Vec<crate::model::AwsRdsDbDomainMembership>>,
    /// <p>Whether to copy resource tags to snapshots of the DB instance.</p>
    pub copy_tags_to_snapshot: bool,
    /// <p>The interval, in seconds, between points when enhanced monitoring metrics are collected for the DB instance.</p>
    pub monitoring_interval: i32,
    /// <p>The ARN for the IAM role that permits Amazon RDS to send enhanced monitoring metrics to CloudWatch Logs.</p>
    pub monitoring_role_arn: std::option::Option<std::string::String>,
    /// <p>The order in which to promote an Aurora replica to the primary instance after a failure of the existing primary instance.</p>
    pub promotion_tier: i32,
    /// <p>The time zone of the DB instance.</p>
    pub timezone: std::option::Option<std::string::String>,
    /// <p>Indicates whether Performance Insights is enabled for the DB instance.</p>
    pub performance_insights_enabled: bool,
    /// <p>The identifier of the KMS key used to encrypt the Performance Insights data.</p>
    pub performance_insights_kms_key_id: std::option::Option<std::string::String>,
    /// <p>The number of days to retain Performance Insights data.</p>
    pub performance_insights_retention_period: i32,
    /// <p>A list of log types that this DB instance is configured to export to CloudWatch Logs.</p>
    pub enabled_cloud_watch_logs_exports: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.</p>
    pub processor_features:
        std::option::Option<std::vec::Vec<crate::model::AwsRdsDbProcessorFeature>>,
    /// <p>Specifies the connection endpoint.</p>
    pub listener_endpoint: std::option::Option<crate::model::AwsRdsDbInstanceEndpoint>,
    /// <p>The upper limit to which Amazon RDS can automatically scale the storage of the DB instance.</p>
    pub max_allocated_storage: i32,
}
impl AwsRdsDbInstanceDetails {
    /// <p>The IAM roles associated with the DB instance.</p>
    pub fn associated_roles(
        &self,
    ) -> std::option::Option<&[crate::model::AwsRdsDbInstanceAssociatedRole]> {
        self.associated_roles.as_deref()
    }
    /// <p>The identifier of the CA certificate for this DB instance.</p>
    pub fn ca_certificate_identifier(&self) -> std::option::Option<&str> {
        self.ca_certificate_identifier.as_deref()
    }
    /// <p>If the DB instance is a member of a DB cluster, contains the name of the DB cluster that the DB instance is a member of.</p>
    pub fn db_cluster_identifier(&self) -> std::option::Option<&str> {
        self.db_cluster_identifier.as_deref()
    }
    /// <p>Contains a user-supplied database identifier. This identifier is the unique key that identifies a DB instance.</p>
    pub fn db_instance_identifier(&self) -> std::option::Option<&str> {
        self.db_instance_identifier.as_deref()
    }
    /// <p>Contains the name of the compute and memory capacity class of the DB instance.</p>
    pub fn db_instance_class(&self) -> std::option::Option<&str> {
        self.db_instance_class.as_deref()
    }
    /// <p>Specifies the port that the DB instance listens on. If the DB instance is part of a DB cluster, this can be a different port than the DB cluster port.</p>
    pub fn db_instance_port(&self) -> i32 {
        self.db_instance_port
    }
    /// <p>The Amazon Web Services Region-unique, immutable identifier for the DB instance. This identifier is found in CloudTrail log entries whenever the KMS key for the DB instance is accessed. </p>
    pub fn dbi_resource_id(&self) -> std::option::Option<&str> {
        self.dbi_resource_id.as_deref()
    }
    /// <p>The meaning of this parameter differs according to the database engine you use.</p>
    /// <p> <b>MySQL, MariaDB, SQL Server, PostgreSQL</b> </p>
    /// <p>Contains the name of the initial database of this instance that was provided at create time, if one was specified when the DB instance was created. This same name is returned for the life of the DB instance.</p>
    /// <p> <b>Oracle</b> </p>
    /// <p>Contains the Oracle System ID (SID) of the created DB instance. Not shown when the returned parameters do not apply to an Oracle DB instance. </p>
    pub fn db_name(&self) -> std::option::Option<&str> {
        self.db_name.as_deref()
    }
    /// <p>Indicates whether the DB instance has deletion protection enabled.</p>
    /// <p>When deletion protection is enabled, the database cannot be deleted.</p>
    pub fn deletion_protection(&self) -> bool {
        self.deletion_protection
    }
    /// <p>Specifies the connection endpoint.</p>
    pub fn endpoint(&self) -> std::option::Option<&crate::model::AwsRdsDbInstanceEndpoint> {
        self.endpoint.as_ref()
    }
    /// <p>Provides the name of the database engine to use for this DB instance.</p>
    pub fn engine(&self) -> std::option::Option<&str> {
        self.engine.as_deref()
    }
    /// <p>Indicates the database engine version.</p>
    pub fn engine_version(&self) -> std::option::Option<&str> {
        self.engine_version.as_deref()
    }
    /// <p>True if mapping of IAM accounts to database accounts is enabled, and otherwise false.</p>
    /// <p>IAM database authentication can be enabled for the following database engines.</p>
    /// <ul>
    /// <li> <p>For MySQL 5.6, minor version 5.6.34 or higher</p> </li>
    /// <li> <p>For MySQL 5.7, minor version 5.7.16 or higher</p> </li>
    /// <li> <p>Aurora 5.6 or higher</p> </li>
    /// </ul>
    pub fn iam_database_authentication_enabled(&self) -> bool {
        self.iam_database_authentication_enabled
    }
    /// <p>Indicates when the DB instance was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn instance_create_time(&self) -> std::option::Option<&str> {
        self.instance_create_time.as_deref()
    }
    /// <p>If <code>StorageEncrypted</code> is true, the KMS key identifier for the encrypted DB instance.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>Specifies the accessibility options for the DB instance.</p>
    /// <p>A value of true specifies an Internet-facing instance with a publicly resolvable DNS name, which resolves to a public IP address.</p>
    /// <p>A value of false specifies an internal instance with a DNS name that resolves to a private IP address. </p>
    pub fn publicly_accessible(&self) -> bool {
        self.publicly_accessible
    }
    /// <p>Specifies whether the DB instance is encrypted.</p>
    pub fn storage_encrypted(&self) -> bool {
        self.storage_encrypted
    }
    /// <p>The ARN from the key store with which the instance is associated for TDE encryption.</p>
    pub fn tde_credential_arn(&self) -> std::option::Option<&str> {
        self.tde_credential_arn.as_deref()
    }
    /// <p>A list of VPC security groups that the DB instance belongs to.</p>
    pub fn vpc_security_groups(
        &self,
    ) -> std::option::Option<&[crate::model::AwsRdsDbInstanceVpcSecurityGroup]> {
        self.vpc_security_groups.as_deref()
    }
    /// <p>Whether the DB instance is a multiple Availability Zone deployment.</p>
    pub fn multi_az(&self) -> bool {
        self.multi_az
    }
    /// <p>The ARN of the CloudWatch Logs log stream that receives the enhanced monitoring metrics data for the DB instance.</p>
    pub fn enhanced_monitoring_resource_arn(&self) -> std::option::Option<&str> {
        self.enhanced_monitoring_resource_arn.as_deref()
    }
    /// <p>The current status of the DB instance.</p>
    pub fn db_instance_status(&self) -> std::option::Option<&str> {
        self.db_instance_status.as_deref()
    }
    /// <p>The master user name of the DB instance.</p>
    pub fn master_username(&self) -> std::option::Option<&str> {
        self.master_username.as_deref()
    }
    /// <p>The amount of storage (in gigabytes) to initially allocate for the DB instance.</p>
    pub fn allocated_storage(&self) -> i32 {
        self.allocated_storage
    }
    /// <p>The range of time each day when automated backups are created, if automated backups are enabled.</p>
    /// <p>Uses the format <code>HH:MM-HH:MM</code>. For example, <code>04:52-05:22</code>.</p>
    pub fn preferred_backup_window(&self) -> std::option::Option<&str> {
        self.preferred_backup_window.as_deref()
    }
    /// <p>The number of days for which to retain automated backups.</p>
    pub fn backup_retention_period(&self) -> i32 {
        self.backup_retention_period
    }
    /// <p>A list of the DB security groups to assign to the DB instance.</p>
    pub fn db_security_groups(&self) -> std::option::Option<&[std::string::String]> {
        self.db_security_groups.as_deref()
    }
    /// <p>A list of the DB parameter groups to assign to the DB instance.</p>
    pub fn db_parameter_groups(
        &self,
    ) -> std::option::Option<&[crate::model::AwsRdsDbParameterGroup]> {
        self.db_parameter_groups.as_deref()
    }
    /// <p>The Availability Zone where the DB instance will be created.</p>
    pub fn availability_zone(&self) -> std::option::Option<&str> {
        self.availability_zone.as_deref()
    }
    /// <p>Information about the subnet group that is associated with the DB instance.</p>
    pub fn db_subnet_group(&self) -> std::option::Option<&crate::model::AwsRdsDbSubnetGroup> {
        self.db_subnet_group.as_ref()
    }
    /// <p>The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).</p>
    /// <p>Uses the format <code>
    /// <day>
    /// :HH:MM-
    /// <day>
    /// :HH:MM
    /// </day>
    /// </day></code>.</p>
    /// <p>For the day values, use <code>mon</code>|<code>tue</code>|<code>wed</code>|<code>thu</code>|<code>fri</code>|<code>sat</code>|<code>sun</code>.</p>
    /// <p>For example, <code>sun:09:32-sun:10:02</code>.</p>
    pub fn preferred_maintenance_window(&self) -> std::option::Option<&str> {
        self.preferred_maintenance_window.as_deref()
    }
    /// <p>Changes to the DB instance that are currently pending.</p>
    pub fn pending_modified_values(
        &self,
    ) -> std::option::Option<&crate::model::AwsRdsDbPendingModifiedValues> {
        self.pending_modified_values.as_ref()
    }
    /// <p>Specifies the latest time to which a database can be restored with point-in-time restore.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn latest_restorable_time(&self) -> std::option::Option<&str> {
        self.latest_restorable_time.as_deref()
    }
    /// <p>Indicates whether minor version patches are applied automatically.</p>
    pub fn auto_minor_version_upgrade(&self) -> bool {
        self.auto_minor_version_upgrade
    }
    /// <p>If this DB instance is a read replica, contains the identifier of the source DB instance.</p>
    pub fn read_replica_source_db_instance_identifier(&self) -> std::option::Option<&str> {
        self.read_replica_source_db_instance_identifier.as_deref()
    }
    /// <p>List of identifiers of the read replicas associated with this DB instance.</p>
    pub fn read_replica_db_instance_identifiers(
        &self,
    ) -> std::option::Option<&[std::string::String]> {
        self.read_replica_db_instance_identifiers.as_deref()
    }
    /// <p>List of identifiers of Aurora DB clusters to which the RDS DB instance is replicated as a read replica.</p>
    pub fn read_replica_db_cluster_identifiers(
        &self,
    ) -> std::option::Option<&[std::string::String]> {
        self.read_replica_db_cluster_identifiers.as_deref()
    }
    /// <p>License model information for this DB instance.</p>
    pub fn license_model(&self) -> std::option::Option<&str> {
        self.license_model.as_deref()
    }
    /// <p>Specifies the provisioned IOPS (I/O operations per second) for this DB instance.</p>
    pub fn iops(&self) -> i32 {
        self.iops
    }
    /// <p>The list of option group memberships for this DB instance.</p>
    pub fn option_group_memberships(
        &self,
    ) -> std::option::Option<&[crate::model::AwsRdsDbOptionGroupMembership]> {
        self.option_group_memberships.as_deref()
    }
    /// <p>The name of the character set that this DB instance is associated with.</p>
    pub fn character_set_name(&self) -> std::option::Option<&str> {
        self.character_set_name.as_deref()
    }
    /// <p>For a DB instance with multi-Availability Zone support, the name of the secondary Availability Zone.</p>
    pub fn secondary_availability_zone(&self) -> std::option::Option<&str> {
        self.secondary_availability_zone.as_deref()
    }
    /// <p>The status of a read replica. If the instance isn't a read replica, this is empty.</p>
    pub fn status_infos(&self) -> std::option::Option<&[crate::model::AwsRdsDbStatusInfo]> {
        self.status_infos.as_deref()
    }
    /// <p>The storage type for the DB instance.</p>
    pub fn storage_type(&self) -> std::option::Option<&str> {
        self.storage_type.as_deref()
    }
    /// <p>The Active Directory domain membership records associated with the DB instance.</p>
    pub fn domain_memberships(
        &self,
    ) -> std::option::Option<&[crate::model::AwsRdsDbDomainMembership]> {
        self.domain_memberships.as_deref()
    }
    /// <p>Whether to copy resource tags to snapshots of the DB instance.</p>
    pub fn copy_tags_to_snapshot(&self) -> bool {
        self.copy_tags_to_snapshot
    }
    /// <p>The interval, in seconds, between points when enhanced monitoring metrics are collected for the DB instance.</p>
    pub fn monitoring_interval(&self) -> i32 {
        self.monitoring_interval
    }
    /// <p>The ARN for the IAM role that permits Amazon RDS to send enhanced monitoring metrics to CloudWatch Logs.</p>
    pub fn monitoring_role_arn(&self) -> std::option::Option<&str> {
        self.monitoring_role_arn.as_deref()
    }
    /// <p>The order in which to promote an Aurora replica to the primary instance after a failure of the existing primary instance.</p>
    pub fn promotion_tier(&self) -> i32 {
        self.promotion_tier
    }
    /// <p>The time zone of the DB instance.</p>
    pub fn timezone(&self) -> std::option::Option<&str> {
        self.timezone.as_deref()
    }
    /// <p>Indicates whether Performance Insights is enabled for the DB instance.</p>
    pub fn performance_insights_enabled(&self) -> bool {
        self.performance_insights_enabled
    }
    /// <p>The identifier of the KMS key used to encrypt the Performance Insights data.</p>
    pub fn performance_insights_kms_key_id(&self) -> std::option::Option<&str> {
        self.performance_insights_kms_key_id.as_deref()
    }
    /// <p>The number of days to retain Performance Insights data.</p>
    pub fn performance_insights_retention_period(&self) -> i32 {
        self.performance_insights_retention_period
    }
    /// <p>A list of log types that this DB instance is configured to export to CloudWatch Logs.</p>
    pub fn enabled_cloud_watch_logs_exports(&self) -> std::option::Option<&[std::string::String]> {
        self.enabled_cloud_watch_logs_exports.as_deref()
    }
    /// <p>The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.</p>
    pub fn processor_features(
        &self,
    ) -> std::option::Option<&[crate::model::AwsRdsDbProcessorFeature]> {
        self.processor_features.as_deref()
    }
    /// <p>Specifies the connection endpoint.</p>
    pub fn listener_endpoint(
        &self,
    ) -> std::option::Option<&crate::model::AwsRdsDbInstanceEndpoint> {
        self.listener_endpoint.as_ref()
    }
    /// <p>The upper limit to which Amazon RDS can automatically scale the storage of the DB instance.</p>
    pub fn max_allocated_storage(&self) -> i32 {
        self.max_allocated_storage
    }
}
impl std::fmt::Debug for AwsRdsDbInstanceDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRdsDbInstanceDetails");
        formatter.field("associated_roles", &self.associated_roles);
        formatter.field("ca_certificate_identifier", &self.ca_certificate_identifier);
        formatter.field("db_cluster_identifier", &self.db_cluster_identifier);
        formatter.field("db_instance_identifier", &self.db_instance_identifier);
        formatter.field("db_instance_class", &self.db_instance_class);
        formatter.field("db_instance_port", &self.db_instance_port);
        formatter.field("dbi_resource_id", &self.dbi_resource_id);
        formatter.field("db_name", &self.db_name);
        formatter.field("deletion_protection", &self.deletion_protection);
        formatter.field("endpoint", &self.endpoint);
        formatter.field("engine", &self.engine);
        formatter.field("engine_version", &self.engine_version);
        formatter.field(
            "iam_database_authentication_enabled",
            &self.iam_database_authentication_enabled,
        );
        formatter.field("instance_create_time", &self.instance_create_time);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("publicly_accessible", &self.publicly_accessible);
        formatter.field("storage_encrypted", &self.storage_encrypted);
        formatter.field("tde_credential_arn", &self.tde_credential_arn);
        formatter.field("vpc_security_groups", &self.vpc_security_groups);
        formatter.field("multi_az", &self.multi_az);
        formatter.field(
            "enhanced_monitoring_resource_arn",
            &self.enhanced_monitoring_resource_arn,
        );
        formatter.field("db_instance_status", &self.db_instance_status);
        formatter.field("master_username", &self.master_username);
        formatter.field("allocated_storage", &self.allocated_storage);
        formatter.field("preferred_backup_window", &self.preferred_backup_window);
        formatter.field("backup_retention_period", &self.backup_retention_period);
        formatter.field("db_security_groups", &self.db_security_groups);
        formatter.field("db_parameter_groups", &self.db_parameter_groups);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("db_subnet_group", &self.db_subnet_group);
        formatter.field(
            "preferred_maintenance_window",
            &self.preferred_maintenance_window,
        );
        formatter.field("pending_modified_values", &self.pending_modified_values);
        formatter.field("latest_restorable_time", &self.latest_restorable_time);
        formatter.field(
            "auto_minor_version_upgrade",
            &self.auto_minor_version_upgrade,
        );
        formatter.field(
            "read_replica_source_db_instance_identifier",
            &self.read_replica_source_db_instance_identifier,
        );
        formatter.field(
            "read_replica_db_instance_identifiers",
            &self.read_replica_db_instance_identifiers,
        );
        formatter.field(
            "read_replica_db_cluster_identifiers",
            &self.read_replica_db_cluster_identifiers,
        );
        formatter.field("license_model", &self.license_model);
        formatter.field("iops", &self.iops);
        formatter.field("option_group_memberships", &self.option_group_memberships);
        formatter.field("character_set_name", &self.character_set_name);
        formatter.field(
            "secondary_availability_zone",
            &self.secondary_availability_zone,
        );
        formatter.field("status_infos", &self.status_infos);
        formatter.field("storage_type", &self.storage_type);
        formatter.field("domain_memberships", &self.domain_memberships);
        formatter.field("copy_tags_to_snapshot", &self.copy_tags_to_snapshot);
        formatter.field("monitoring_interval", &self.monitoring_interval);
        formatter.field("monitoring_role_arn", &self.monitoring_role_arn);
        formatter.field("promotion_tier", &self.promotion_tier);
        formatter.field("timezone", &self.timezone);
        formatter.field(
            "performance_insights_enabled",
            &self.performance_insights_enabled,
        );
        formatter.field(
            "performance_insights_kms_key_id",
            &self.performance_insights_kms_key_id,
        );
        formatter.field(
            "performance_insights_retention_period",
            &self.performance_insights_retention_period,
        );
        formatter.field(
            "enabled_cloud_watch_logs_exports",
            &self.enabled_cloud_watch_logs_exports,
        );
        formatter.field("processor_features", &self.processor_features);
        formatter.field("listener_endpoint", &self.listener_endpoint);
        formatter.field("max_allocated_storage", &self.max_allocated_storage);
        formatter.finish()
    }
}
/// See [`AwsRdsDbInstanceDetails`](crate::model::AwsRdsDbInstanceDetails)
pub mod aws_rds_db_instance_details {

    /// A builder for [`AwsRdsDbInstanceDetails`](crate::model::AwsRdsDbInstanceDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) associated_roles:
            std::option::Option<std::vec::Vec<crate::model::AwsRdsDbInstanceAssociatedRole>>,
        pub(crate) ca_certificate_identifier: std::option::Option<std::string::String>,
        pub(crate) db_cluster_identifier: std::option::Option<std::string::String>,
        pub(crate) db_instance_identifier: std::option::Option<std::string::String>,
        pub(crate) db_instance_class: std::option::Option<std::string::String>,
        pub(crate) db_instance_port: std::option::Option<i32>,
        pub(crate) dbi_resource_id: std::option::Option<std::string::String>,
        pub(crate) db_name: std::option::Option<std::string::String>,
        pub(crate) deletion_protection: std::option::Option<bool>,
        pub(crate) endpoint: std::option::Option<crate::model::AwsRdsDbInstanceEndpoint>,
        pub(crate) engine: std::option::Option<std::string::String>,
        pub(crate) engine_version: std::option::Option<std::string::String>,
        pub(crate) iam_database_authentication_enabled: std::option::Option<bool>,
        pub(crate) instance_create_time: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) publicly_accessible: std::option::Option<bool>,
        pub(crate) storage_encrypted: std::option::Option<bool>,
        pub(crate) tde_credential_arn: std::option::Option<std::string::String>,
        pub(crate) vpc_security_groups:
            std::option::Option<std::vec::Vec<crate::model::AwsRdsDbInstanceVpcSecurityGroup>>,
        pub(crate) multi_az: std::option::Option<bool>,
        pub(crate) enhanced_monitoring_resource_arn: std::option::Option<std::string::String>,
        pub(crate) db_instance_status: std::option::Option<std::string::String>,
        pub(crate) master_username: std::option::Option<std::string::String>,
        pub(crate) allocated_storage: std::option::Option<i32>,
        pub(crate) preferred_backup_window: std::option::Option<std::string::String>,
        pub(crate) backup_retention_period: std::option::Option<i32>,
        pub(crate) db_security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) db_parameter_groups:
            std::option::Option<std::vec::Vec<crate::model::AwsRdsDbParameterGroup>>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) db_subnet_group: std::option::Option<crate::model::AwsRdsDbSubnetGroup>,
        pub(crate) preferred_maintenance_window: std::option::Option<std::string::String>,
        pub(crate) pending_modified_values:
            std::option::Option<crate::model::AwsRdsDbPendingModifiedValues>,
        pub(crate) latest_restorable_time: std::option::Option<std::string::String>,
        pub(crate) auto_minor_version_upgrade: std::option::Option<bool>,
        pub(crate) read_replica_source_db_instance_identifier:
            std::option::Option<std::string::String>,
        pub(crate) read_replica_db_instance_identifiers:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) read_replica_db_cluster_identifiers:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) license_model: std::option::Option<std::string::String>,
        pub(crate) iops: std::option::Option<i32>,
        pub(crate) option_group_memberships:
            std::option::Option<std::vec::Vec<crate::model::AwsRdsDbOptionGroupMembership>>,
        pub(crate) character_set_name: std::option::Option<std::string::String>,
        pub(crate) secondary_availability_zone: std::option::Option<std::string::String>,
        pub(crate) status_infos:
            std::option::Option<std::vec::Vec<crate::model::AwsRdsDbStatusInfo>>,
        pub(crate) storage_type: std::option::Option<std::string::String>,
        pub(crate) domain_memberships:
            std::option::Option<std::vec::Vec<crate::model::AwsRdsDbDomainMembership>>,
        pub(crate) copy_tags_to_snapshot: std::option::Option<bool>,
        pub(crate) monitoring_interval: std::option::Option<i32>,
        pub(crate) monitoring_role_arn: std::option::Option<std::string::String>,
        pub(crate) promotion_tier: std::option::Option<i32>,
        pub(crate) timezone: std::option::Option<std::string::String>,
        pub(crate) performance_insights_enabled: std::option::Option<bool>,
        pub(crate) performance_insights_kms_key_id: std::option::Option<std::string::String>,
        pub(crate) performance_insights_retention_period: std::option::Option<i32>,
        pub(crate) enabled_cloud_watch_logs_exports:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) processor_features:
            std::option::Option<std::vec::Vec<crate::model::AwsRdsDbProcessorFeature>>,
        pub(crate) listener_endpoint: std::option::Option<crate::model::AwsRdsDbInstanceEndpoint>,
        pub(crate) max_allocated_storage: std::option::Option<i32>,
    }
    impl Builder {
        /// Appends an item to `associated_roles`.
        ///
        /// To override the contents of this collection use [`set_associated_roles`](Self::set_associated_roles).
        ///
        /// <p>The IAM roles associated with the DB instance.</p>
        pub fn associated_roles(
            mut self,
            input: crate::model::AwsRdsDbInstanceAssociatedRole,
        ) -> Self {
            let mut v = self.associated_roles.unwrap_or_default();
            v.push(input);
            self.associated_roles = Some(v);
            self
        }
        /// <p>The IAM roles associated with the DB instance.</p>
        pub fn set_associated_roles(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsRdsDbInstanceAssociatedRole>>,
        ) -> Self {
            self.associated_roles = input;
            self
        }
        /// <p>The identifier of the CA certificate for this DB instance.</p>
        pub fn ca_certificate_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.ca_certificate_identifier = Some(input.into());
            self
        }
        /// <p>The identifier of the CA certificate for this DB instance.</p>
        pub fn set_ca_certificate_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ca_certificate_identifier = input;
            self
        }
        /// <p>If the DB instance is a member of a DB cluster, contains the name of the DB cluster that the DB instance is a member of.</p>
        pub fn db_cluster_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_cluster_identifier = Some(input.into());
            self
        }
        /// <p>If the DB instance is a member of a DB cluster, contains the name of the DB cluster that the DB instance is a member of.</p>
        pub fn set_db_cluster_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.db_cluster_identifier = input;
            self
        }
        /// <p>Contains a user-supplied database identifier. This identifier is the unique key that identifies a DB instance.</p>
        pub fn db_instance_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_instance_identifier = Some(input.into());
            self
        }
        /// <p>Contains a user-supplied database identifier. This identifier is the unique key that identifies a DB instance.</p>
        pub fn set_db_instance_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.db_instance_identifier = input;
            self
        }
        /// <p>Contains the name of the compute and memory capacity class of the DB instance.</p>
        pub fn db_instance_class(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_instance_class = Some(input.into());
            self
        }
        /// <p>Contains the name of the compute and memory capacity class of the DB instance.</p>
        pub fn set_db_instance_class(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.db_instance_class = input;
            self
        }
        /// <p>Specifies the port that the DB instance listens on. If the DB instance is part of a DB cluster, this can be a different port than the DB cluster port.</p>
        pub fn db_instance_port(mut self, input: i32) -> Self {
            self.db_instance_port = Some(input);
            self
        }
        /// <p>Specifies the port that the DB instance listens on. If the DB instance is part of a DB cluster, this can be a different port than the DB cluster port.</p>
        pub fn set_db_instance_port(mut self, input: std::option::Option<i32>) -> Self {
            self.db_instance_port = input;
            self
        }
        /// <p>The Amazon Web Services Region-unique, immutable identifier for the DB instance. This identifier is found in CloudTrail log entries whenever the KMS key for the DB instance is accessed. </p>
        pub fn dbi_resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.dbi_resource_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Region-unique, immutable identifier for the DB instance. This identifier is found in CloudTrail log entries whenever the KMS key for the DB instance is accessed. </p>
        pub fn set_dbi_resource_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dbi_resource_id = input;
            self
        }
        /// <p>The meaning of this parameter differs according to the database engine you use.</p>
        /// <p> <b>MySQL, MariaDB, SQL Server, PostgreSQL</b> </p>
        /// <p>Contains the name of the initial database of this instance that was provided at create time, if one was specified when the DB instance was created. This same name is returned for the life of the DB instance.</p>
        /// <p> <b>Oracle</b> </p>
        /// <p>Contains the Oracle System ID (SID) of the created DB instance. Not shown when the returned parameters do not apply to an Oracle DB instance. </p>
        pub fn db_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_name = Some(input.into());
            self
        }
        /// <p>The meaning of this parameter differs according to the database engine you use.</p>
        /// <p> <b>MySQL, MariaDB, SQL Server, PostgreSQL</b> </p>
        /// <p>Contains the name of the initial database of this instance that was provided at create time, if one was specified when the DB instance was created. This same name is returned for the life of the DB instance.</p>
        /// <p> <b>Oracle</b> </p>
        /// <p>Contains the Oracle System ID (SID) of the created DB instance. Not shown when the returned parameters do not apply to an Oracle DB instance. </p>
        pub fn set_db_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.db_name = input;
            self
        }
        /// <p>Indicates whether the DB instance has deletion protection enabled.</p>
        /// <p>When deletion protection is enabled, the database cannot be deleted.</p>
        pub fn deletion_protection(mut self, input: bool) -> Self {
            self.deletion_protection = Some(input);
            self
        }
        /// <p>Indicates whether the DB instance has deletion protection enabled.</p>
        /// <p>When deletion protection is enabled, the database cannot be deleted.</p>
        pub fn set_deletion_protection(mut self, input: std::option::Option<bool>) -> Self {
            self.deletion_protection = input;
            self
        }
        /// <p>Specifies the connection endpoint.</p>
        pub fn endpoint(mut self, input: crate::model::AwsRdsDbInstanceEndpoint) -> Self {
            self.endpoint = Some(input);
            self
        }
        /// <p>Specifies the connection endpoint.</p>
        pub fn set_endpoint(
            mut self,
            input: std::option::Option<crate::model::AwsRdsDbInstanceEndpoint>,
        ) -> Self {
            self.endpoint = input;
            self
        }
        /// <p>Provides the name of the database engine to use for this DB instance.</p>
        pub fn engine(mut self, input: impl Into<std::string::String>) -> Self {
            self.engine = Some(input.into());
            self
        }
        /// <p>Provides the name of the database engine to use for this DB instance.</p>
        pub fn set_engine(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.engine = input;
            self
        }
        /// <p>Indicates the database engine version.</p>
        pub fn engine_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.engine_version = Some(input.into());
            self
        }
        /// <p>Indicates the database engine version.</p>
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.engine_version = input;
            self
        }
        /// <p>True if mapping of IAM accounts to database accounts is enabled, and otherwise false.</p>
        /// <p>IAM database authentication can be enabled for the following database engines.</p>
        /// <ul>
        /// <li> <p>For MySQL 5.6, minor version 5.6.34 or higher</p> </li>
        /// <li> <p>For MySQL 5.7, minor version 5.7.16 or higher</p> </li>
        /// <li> <p>Aurora 5.6 or higher</p> </li>
        /// </ul>
        pub fn iam_database_authentication_enabled(mut self, input: bool) -> Self {
            self.iam_database_authentication_enabled = Some(input);
            self
        }
        /// <p>True if mapping of IAM accounts to database accounts is enabled, and otherwise false.</p>
        /// <p>IAM database authentication can be enabled for the following database engines.</p>
        /// <ul>
        /// <li> <p>For MySQL 5.6, minor version 5.6.34 or higher</p> </li>
        /// <li> <p>For MySQL 5.7, minor version 5.7.16 or higher</p> </li>
        /// <li> <p>Aurora 5.6 or higher</p> </li>
        /// </ul>
        pub fn set_iam_database_authentication_enabled(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.iam_database_authentication_enabled = input;
            self
        }
        /// <p>Indicates when the DB instance was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn instance_create_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_create_time = Some(input.into());
            self
        }
        /// <p>Indicates when the DB instance was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_instance_create_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_create_time = input;
            self
        }
        /// <p>If <code>StorageEncrypted</code> is true, the KMS key identifier for the encrypted DB instance.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>If <code>StorageEncrypted</code> is true, the KMS key identifier for the encrypted DB instance.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>Specifies the accessibility options for the DB instance.</p>
        /// <p>A value of true specifies an Internet-facing instance with a publicly resolvable DNS name, which resolves to a public IP address.</p>
        /// <p>A value of false specifies an internal instance with a DNS name that resolves to a private IP address. </p>
        pub fn publicly_accessible(mut self, input: bool) -> Self {
            self.publicly_accessible = Some(input);
            self
        }
        /// <p>Specifies the accessibility options for the DB instance.</p>
        /// <p>A value of true specifies an Internet-facing instance with a publicly resolvable DNS name, which resolves to a public IP address.</p>
        /// <p>A value of false specifies an internal instance with a DNS name that resolves to a private IP address. </p>
        pub fn set_publicly_accessible(mut self, input: std::option::Option<bool>) -> Self {
            self.publicly_accessible = input;
            self
        }
        /// <p>Specifies whether the DB instance is encrypted.</p>
        pub fn storage_encrypted(mut self, input: bool) -> Self {
            self.storage_encrypted = Some(input);
            self
        }
        /// <p>Specifies whether the DB instance is encrypted.</p>
        pub fn set_storage_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.storage_encrypted = input;
            self
        }
        /// <p>The ARN from the key store with which the instance is associated for TDE encryption.</p>
        pub fn tde_credential_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.tde_credential_arn = Some(input.into());
            self
        }
        /// <p>The ARN from the key store with which the instance is associated for TDE encryption.</p>
        pub fn set_tde_credential_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tde_credential_arn = input;
            self
        }
        /// Appends an item to `vpc_security_groups`.
        ///
        /// To override the contents of this collection use [`set_vpc_security_groups`](Self::set_vpc_security_groups).
        ///
        /// <p>A list of VPC security groups that the DB instance belongs to.</p>
        pub fn vpc_security_groups(
            mut self,
            input: crate::model::AwsRdsDbInstanceVpcSecurityGroup,
        ) -> Self {
            let mut v = self.vpc_security_groups.unwrap_or_default();
            v.push(input);
            self.vpc_security_groups = Some(v);
            self
        }
        /// <p>A list of VPC security groups that the DB instance belongs to.</p>
        pub fn set_vpc_security_groups(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsRdsDbInstanceVpcSecurityGroup>,
            >,
        ) -> Self {
            self.vpc_security_groups = input;
            self
        }
        /// <p>Whether the DB instance is a multiple Availability Zone deployment.</p>
        pub fn multi_az(mut self, input: bool) -> Self {
            self.multi_az = Some(input);
            self
        }
        /// <p>Whether the DB instance is a multiple Availability Zone deployment.</p>
        pub fn set_multi_az(mut self, input: std::option::Option<bool>) -> Self {
            self.multi_az = input;
            self
        }
        /// <p>The ARN of the CloudWatch Logs log stream that receives the enhanced monitoring metrics data for the DB instance.</p>
        pub fn enhanced_monitoring_resource_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.enhanced_monitoring_resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the CloudWatch Logs log stream that receives the enhanced monitoring metrics data for the DB instance.</p>
        pub fn set_enhanced_monitoring_resource_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.enhanced_monitoring_resource_arn = input;
            self
        }
        /// <p>The current status of the DB instance.</p>
        pub fn db_instance_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_instance_status = Some(input.into());
            self
        }
        /// <p>The current status of the DB instance.</p>
        pub fn set_db_instance_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.db_instance_status = input;
            self
        }
        /// <p>The master user name of the DB instance.</p>
        pub fn master_username(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_username = Some(input.into());
            self
        }
        /// <p>The master user name of the DB instance.</p>
        pub fn set_master_username(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_username = input;
            self
        }
        /// <p>The amount of storage (in gigabytes) to initially allocate for the DB instance.</p>
        pub fn allocated_storage(mut self, input: i32) -> Self {
            self.allocated_storage = Some(input);
            self
        }
        /// <p>The amount of storage (in gigabytes) to initially allocate for the DB instance.</p>
        pub fn set_allocated_storage(mut self, input: std::option::Option<i32>) -> Self {
            self.allocated_storage = input;
            self
        }
        /// <p>The range of time each day when automated backups are created, if automated backups are enabled.</p>
        /// <p>Uses the format <code>HH:MM-HH:MM</code>. For example, <code>04:52-05:22</code>.</p>
        pub fn preferred_backup_window(mut self, input: impl Into<std::string::String>) -> Self {
            self.preferred_backup_window = Some(input.into());
            self
        }
        /// <p>The range of time each day when automated backups are created, if automated backups are enabled.</p>
        /// <p>Uses the format <code>HH:MM-HH:MM</code>. For example, <code>04:52-05:22</code>.</p>
        pub fn set_preferred_backup_window(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.preferred_backup_window = input;
            self
        }
        /// <p>The number of days for which to retain automated backups.</p>
        pub fn backup_retention_period(mut self, input: i32) -> Self {
            self.backup_retention_period = Some(input);
            self
        }
        /// <p>The number of days for which to retain automated backups.</p>
        pub fn set_backup_retention_period(mut self, input: std::option::Option<i32>) -> Self {
            self.backup_retention_period = input;
            self
        }
        /// Appends an item to `db_security_groups`.
        ///
        /// To override the contents of this collection use [`set_db_security_groups`](Self::set_db_security_groups).
        ///
        /// <p>A list of the DB security groups to assign to the DB instance.</p>
        pub fn db_security_groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.db_security_groups.unwrap_or_default();
            v.push(input.into());
            self.db_security_groups = Some(v);
            self
        }
        /// <p>A list of the DB security groups to assign to the DB instance.</p>
        pub fn set_db_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.db_security_groups = input;
            self
        }
        /// Appends an item to `db_parameter_groups`.
        ///
        /// To override the contents of this collection use [`set_db_parameter_groups`](Self::set_db_parameter_groups).
        ///
        /// <p>A list of the DB parameter groups to assign to the DB instance.</p>
        pub fn db_parameter_groups(mut self, input: crate::model::AwsRdsDbParameterGroup) -> Self {
            let mut v = self.db_parameter_groups.unwrap_or_default();
            v.push(input);
            self.db_parameter_groups = Some(v);
            self
        }
        /// <p>A list of the DB parameter groups to assign to the DB instance.</p>
        pub fn set_db_parameter_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsRdsDbParameterGroup>>,
        ) -> Self {
            self.db_parameter_groups = input;
            self
        }
        /// <p>The Availability Zone where the DB instance will be created.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        /// <p>The Availability Zone where the DB instance will be created.</p>
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>Information about the subnet group that is associated with the DB instance.</p>
        pub fn db_subnet_group(mut self, input: crate::model::AwsRdsDbSubnetGroup) -> Self {
            self.db_subnet_group = Some(input);
            self
        }
        /// <p>Information about the subnet group that is associated with the DB instance.</p>
        pub fn set_db_subnet_group(
            mut self,
            input: std::option::Option<crate::model::AwsRdsDbSubnetGroup>,
        ) -> Self {
            self.db_subnet_group = input;
            self
        }
        /// <p>The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).</p>
        /// <p>Uses the format <code>
        /// <day>
        /// :HH:MM-
        /// <day>
        /// :HH:MM
        /// </day>
        /// </day></code>.</p>
        /// <p>For the day values, use <code>mon</code>|<code>tue</code>|<code>wed</code>|<code>thu</code>|<code>fri</code>|<code>sat</code>|<code>sun</code>.</p>
        /// <p>For example, <code>sun:09:32-sun:10:02</code>.</p>
        pub fn preferred_maintenance_window(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.preferred_maintenance_window = Some(input.into());
            self
        }
        /// <p>The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).</p>
        /// <p>Uses the format <code>
        /// <day>
        /// :HH:MM-
        /// <day>
        /// :HH:MM
        /// </day>
        /// </day></code>.</p>
        /// <p>For the day values, use <code>mon</code>|<code>tue</code>|<code>wed</code>|<code>thu</code>|<code>fri</code>|<code>sat</code>|<code>sun</code>.</p>
        /// <p>For example, <code>sun:09:32-sun:10:02</code>.</p>
        pub fn set_preferred_maintenance_window(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.preferred_maintenance_window = input;
            self
        }
        /// <p>Changes to the DB instance that are currently pending.</p>
        pub fn pending_modified_values(
            mut self,
            input: crate::model::AwsRdsDbPendingModifiedValues,
        ) -> Self {
            self.pending_modified_values = Some(input);
            self
        }
        /// <p>Changes to the DB instance that are currently pending.</p>
        pub fn set_pending_modified_values(
            mut self,
            input: std::option::Option<crate::model::AwsRdsDbPendingModifiedValues>,
        ) -> Self {
            self.pending_modified_values = input;
            self
        }
        /// <p>Specifies the latest time to which a database can be restored with point-in-time restore.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn latest_restorable_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.latest_restorable_time = Some(input.into());
            self
        }
        /// <p>Specifies the latest time to which a database can be restored with point-in-time restore.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_latest_restorable_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.latest_restorable_time = input;
            self
        }
        /// <p>Indicates whether minor version patches are applied automatically.</p>
        pub fn auto_minor_version_upgrade(mut self, input: bool) -> Self {
            self.auto_minor_version_upgrade = Some(input);
            self
        }
        /// <p>Indicates whether minor version patches are applied automatically.</p>
        pub fn set_auto_minor_version_upgrade(mut self, input: std::option::Option<bool>) -> Self {
            self.auto_minor_version_upgrade = input;
            self
        }
        /// <p>If this DB instance is a read replica, contains the identifier of the source DB instance.</p>
        pub fn read_replica_source_db_instance_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.read_replica_source_db_instance_identifier = Some(input.into());
            self
        }
        /// <p>If this DB instance is a read replica, contains the identifier of the source DB instance.</p>
        pub fn set_read_replica_source_db_instance_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.read_replica_source_db_instance_identifier = input;
            self
        }
        /// Appends an item to `read_replica_db_instance_identifiers`.
        ///
        /// To override the contents of this collection use [`set_read_replica_db_instance_identifiers`](Self::set_read_replica_db_instance_identifiers).
        ///
        /// <p>List of identifiers of the read replicas associated with this DB instance.</p>
        pub fn read_replica_db_instance_identifiers(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self
                .read_replica_db_instance_identifiers
                .unwrap_or_default();
            v.push(input.into());
            self.read_replica_db_instance_identifiers = Some(v);
            self
        }
        /// <p>List of identifiers of the read replicas associated with this DB instance.</p>
        pub fn set_read_replica_db_instance_identifiers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.read_replica_db_instance_identifiers = input;
            self
        }
        /// Appends an item to `read_replica_db_cluster_identifiers`.
        ///
        /// To override the contents of this collection use [`set_read_replica_db_cluster_identifiers`](Self::set_read_replica_db_cluster_identifiers).
        ///
        /// <p>List of identifiers of Aurora DB clusters to which the RDS DB instance is replicated as a read replica.</p>
        pub fn read_replica_db_cluster_identifiers(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.read_replica_db_cluster_identifiers.unwrap_or_default();
            v.push(input.into());
            self.read_replica_db_cluster_identifiers = Some(v);
            self
        }
        /// <p>List of identifiers of Aurora DB clusters to which the RDS DB instance is replicated as a read replica.</p>
        pub fn set_read_replica_db_cluster_identifiers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.read_replica_db_cluster_identifiers = input;
            self
        }
        /// <p>License model information for this DB instance.</p>
        pub fn license_model(mut self, input: impl Into<std::string::String>) -> Self {
            self.license_model = Some(input.into());
            self
        }
        /// <p>License model information for this DB instance.</p>
        pub fn set_license_model(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.license_model = input;
            self
        }
        /// <p>Specifies the provisioned IOPS (I/O operations per second) for this DB instance.</p>
        pub fn iops(mut self, input: i32) -> Self {
            self.iops = Some(input);
            self
        }
        /// <p>Specifies the provisioned IOPS (I/O operations per second) for this DB instance.</p>
        pub fn set_iops(mut self, input: std::option::Option<i32>) -> Self {
            self.iops = input;
            self
        }
        /// Appends an item to `option_group_memberships`.
        ///
        /// To override the contents of this collection use [`set_option_group_memberships`](Self::set_option_group_memberships).
        ///
        /// <p>The list of option group memberships for this DB instance.</p>
        pub fn option_group_memberships(
            mut self,
            input: crate::model::AwsRdsDbOptionGroupMembership,
        ) -> Self {
            let mut v = self.option_group_memberships.unwrap_or_default();
            v.push(input);
            self.option_group_memberships = Some(v);
            self
        }
        /// <p>The list of option group memberships for this DB instance.</p>
        pub fn set_option_group_memberships(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsRdsDbOptionGroupMembership>>,
        ) -> Self {
            self.option_group_memberships = input;
            self
        }
        /// <p>The name of the character set that this DB instance is associated with.</p>
        pub fn character_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.character_set_name = Some(input.into());
            self
        }
        /// <p>The name of the character set that this DB instance is associated with.</p>
        pub fn set_character_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.character_set_name = input;
            self
        }
        /// <p>For a DB instance with multi-Availability Zone support, the name of the secondary Availability Zone.</p>
        pub fn secondary_availability_zone(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.secondary_availability_zone = Some(input.into());
            self
        }
        /// <p>For a DB instance with multi-Availability Zone support, the name of the secondary Availability Zone.</p>
        pub fn set_secondary_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.secondary_availability_zone = input;
            self
        }
        /// Appends an item to `status_infos`.
        ///
        /// To override the contents of this collection use [`set_status_infos`](Self::set_status_infos).
        ///
        /// <p>The status of a read replica. If the instance isn't a read replica, this is empty.</p>
        pub fn status_infos(mut self, input: crate::model::AwsRdsDbStatusInfo) -> Self {
            let mut v = self.status_infos.unwrap_or_default();
            v.push(input);
            self.status_infos = Some(v);
            self
        }
        /// <p>The status of a read replica. If the instance isn't a read replica, this is empty.</p>
        pub fn set_status_infos(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsRdsDbStatusInfo>>,
        ) -> Self {
            self.status_infos = input;
            self
        }
        /// <p>The storage type for the DB instance.</p>
        pub fn storage_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.storage_type = Some(input.into());
            self
        }
        /// <p>The storage type for the DB instance.</p>
        pub fn set_storage_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.storage_type = input;
            self
        }
        /// Appends an item to `domain_memberships`.
        ///
        /// To override the contents of this collection use [`set_domain_memberships`](Self::set_domain_memberships).
        ///
        /// <p>The Active Directory domain membership records associated with the DB instance.</p>
        pub fn domain_memberships(mut self, input: crate::model::AwsRdsDbDomainMembership) -> Self {
            let mut v = self.domain_memberships.unwrap_or_default();
            v.push(input);
            self.domain_memberships = Some(v);
            self
        }
        /// <p>The Active Directory domain membership records associated with the DB instance.</p>
        pub fn set_domain_memberships(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsRdsDbDomainMembership>>,
        ) -> Self {
            self.domain_memberships = input;
            self
        }
        /// <p>Whether to copy resource tags to snapshots of the DB instance.</p>
        pub fn copy_tags_to_snapshot(mut self, input: bool) -> Self {
            self.copy_tags_to_snapshot = Some(input);
            self
        }
        /// <p>Whether to copy resource tags to snapshots of the DB instance.</p>
        pub fn set_copy_tags_to_snapshot(mut self, input: std::option::Option<bool>) -> Self {
            self.copy_tags_to_snapshot = input;
            self
        }
        /// <p>The interval, in seconds, between points when enhanced monitoring metrics are collected for the DB instance.</p>
        pub fn monitoring_interval(mut self, input: i32) -> Self {
            self.monitoring_interval = Some(input);
            self
        }
        /// <p>The interval, in seconds, between points when enhanced monitoring metrics are collected for the DB instance.</p>
        pub fn set_monitoring_interval(mut self, input: std::option::Option<i32>) -> Self {
            self.monitoring_interval = input;
            self
        }
        /// <p>The ARN for the IAM role that permits Amazon RDS to send enhanced monitoring metrics to CloudWatch Logs.</p>
        pub fn monitoring_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitoring_role_arn = Some(input.into());
            self
        }
        /// <p>The ARN for the IAM role that permits Amazon RDS to send enhanced monitoring metrics to CloudWatch Logs.</p>
        pub fn set_monitoring_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.monitoring_role_arn = input;
            self
        }
        /// <p>The order in which to promote an Aurora replica to the primary instance after a failure of the existing primary instance.</p>
        pub fn promotion_tier(mut self, input: i32) -> Self {
            self.promotion_tier = Some(input);
            self
        }
        /// <p>The order in which to promote an Aurora replica to the primary instance after a failure of the existing primary instance.</p>
        pub fn set_promotion_tier(mut self, input: std::option::Option<i32>) -> Self {
            self.promotion_tier = input;
            self
        }
        /// <p>The time zone of the DB instance.</p>
        pub fn timezone(mut self, input: impl Into<std::string::String>) -> Self {
            self.timezone = Some(input.into());
            self
        }
        /// <p>The time zone of the DB instance.</p>
        pub fn set_timezone(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.timezone = input;
            self
        }
        /// <p>Indicates whether Performance Insights is enabled for the DB instance.</p>
        pub fn performance_insights_enabled(mut self, input: bool) -> Self {
            self.performance_insights_enabled = Some(input);
            self
        }
        /// <p>Indicates whether Performance Insights is enabled for the DB instance.</p>
        pub fn set_performance_insights_enabled(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.performance_insights_enabled = input;
            self
        }
        /// <p>The identifier of the KMS key used to encrypt the Performance Insights data.</p>
        pub fn performance_insights_kms_key_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.performance_insights_kms_key_id = Some(input.into());
            self
        }
        /// <p>The identifier of the KMS key used to encrypt the Performance Insights data.</p>
        pub fn set_performance_insights_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.performance_insights_kms_key_id = input;
            self
        }
        /// <p>The number of days to retain Performance Insights data.</p>
        pub fn performance_insights_retention_period(mut self, input: i32) -> Self {
            self.performance_insights_retention_period = Some(input);
            self
        }
        /// <p>The number of days to retain Performance Insights data.</p>
        pub fn set_performance_insights_retention_period(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.performance_insights_retention_period = input;
            self
        }
        /// Appends an item to `enabled_cloud_watch_logs_exports`.
        ///
        /// To override the contents of this collection use [`set_enabled_cloud_watch_logs_exports`](Self::set_enabled_cloud_watch_logs_exports).
        ///
        /// <p>A list of log types that this DB instance is configured to export to CloudWatch Logs.</p>
        pub fn enabled_cloud_watch_logs_exports(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.enabled_cloud_watch_logs_exports.unwrap_or_default();
            v.push(input.into());
            self.enabled_cloud_watch_logs_exports = Some(v);
            self
        }
        /// <p>A list of log types that this DB instance is configured to export to CloudWatch Logs.</p>
        pub fn set_enabled_cloud_watch_logs_exports(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.enabled_cloud_watch_logs_exports = input;
            self
        }
        /// Appends an item to `processor_features`.
        ///
        /// To override the contents of this collection use [`set_processor_features`](Self::set_processor_features).
        ///
        /// <p>The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.</p>
        pub fn processor_features(mut self, input: crate::model::AwsRdsDbProcessorFeature) -> Self {
            let mut v = self.processor_features.unwrap_or_default();
            v.push(input);
            self.processor_features = Some(v);
            self
        }
        /// <p>The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.</p>
        pub fn set_processor_features(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsRdsDbProcessorFeature>>,
        ) -> Self {
            self.processor_features = input;
            self
        }
        /// <p>Specifies the connection endpoint.</p>
        pub fn listener_endpoint(mut self, input: crate::model::AwsRdsDbInstanceEndpoint) -> Self {
            self.listener_endpoint = Some(input);
            self
        }
        /// <p>Specifies the connection endpoint.</p>
        pub fn set_listener_endpoint(
            mut self,
            input: std::option::Option<crate::model::AwsRdsDbInstanceEndpoint>,
        ) -> Self {
            self.listener_endpoint = input;
            self
        }
        /// <p>The upper limit to which Amazon RDS can automatically scale the storage of the DB instance.</p>
        pub fn max_allocated_storage(mut self, input: i32) -> Self {
            self.max_allocated_storage = Some(input);
            self
        }
        /// <p>The upper limit to which Amazon RDS can automatically scale the storage of the DB instance.</p>
        pub fn set_max_allocated_storage(mut self, input: std::option::Option<i32>) -> Self {
            self.max_allocated_storage = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRdsDbInstanceDetails`](crate::model::AwsRdsDbInstanceDetails)
        pub fn build(self) -> crate::model::AwsRdsDbInstanceDetails {
            crate::model::AwsRdsDbInstanceDetails {
                associated_roles: self.associated_roles,
                ca_certificate_identifier: self.ca_certificate_identifier,
                db_cluster_identifier: self.db_cluster_identifier,
                db_instance_identifier: self.db_instance_identifier,
                db_instance_class: self.db_instance_class,
                db_instance_port: self.db_instance_port.unwrap_or_default(),
                dbi_resource_id: self.dbi_resource_id,
                db_name: self.db_name,
                deletion_protection: self.deletion_protection.unwrap_or_default(),
                endpoint: self.endpoint,
                engine: self.engine,
                engine_version: self.engine_version,
                iam_database_authentication_enabled: self
                    .iam_database_authentication_enabled
                    .unwrap_or_default(),
                instance_create_time: self.instance_create_time,
                kms_key_id: self.kms_key_id,
                publicly_accessible: self.publicly_accessible.unwrap_or_default(),
                storage_encrypted: self.storage_encrypted.unwrap_or_default(),
                tde_credential_arn: self.tde_credential_arn,
                vpc_security_groups: self.vpc_security_groups,
                multi_az: self.multi_az.unwrap_or_default(),
                enhanced_monitoring_resource_arn: self.enhanced_monitoring_resource_arn,
                db_instance_status: self.db_instance_status,
                master_username: self.master_username,
                allocated_storage: self.allocated_storage.unwrap_or_default(),
                preferred_backup_window: self.preferred_backup_window,
                backup_retention_period: self.backup_retention_period.unwrap_or_default(),
                db_security_groups: self.db_security_groups,
                db_parameter_groups: self.db_parameter_groups,
                availability_zone: self.availability_zone,
                db_subnet_group: self.db_subnet_group,
                preferred_maintenance_window: self.preferred_maintenance_window,
                pending_modified_values: self.pending_modified_values,
                latest_restorable_time: self.latest_restorable_time,
                auto_minor_version_upgrade: self.auto_minor_version_upgrade.unwrap_or_default(),
                read_replica_source_db_instance_identifier: self
                    .read_replica_source_db_instance_identifier,
                read_replica_db_instance_identifiers: self.read_replica_db_instance_identifiers,
                read_replica_db_cluster_identifiers: self.read_replica_db_cluster_identifiers,
                license_model: self.license_model,
                iops: self.iops.unwrap_or_default(),
                option_group_memberships: self.option_group_memberships,
                character_set_name: self.character_set_name,
                secondary_availability_zone: self.secondary_availability_zone,
                status_infos: self.status_infos,
                storage_type: self.storage_type,
                domain_memberships: self.domain_memberships,
                copy_tags_to_snapshot: self.copy_tags_to_snapshot.unwrap_or_default(),
                monitoring_interval: self.monitoring_interval.unwrap_or_default(),
                monitoring_role_arn: self.monitoring_role_arn,
                promotion_tier: self.promotion_tier.unwrap_or_default(),
                timezone: self.timezone,
                performance_insights_enabled: self.performance_insights_enabled.unwrap_or_default(),
                performance_insights_kms_key_id: self.performance_insights_kms_key_id,
                performance_insights_retention_period: self
                    .performance_insights_retention_period
                    .unwrap_or_default(),
                enabled_cloud_watch_logs_exports: self.enabled_cloud_watch_logs_exports,
                processor_features: self.processor_features,
                listener_endpoint: self.listener_endpoint,
                max_allocated_storage: self.max_allocated_storage.unwrap_or_default(),
            }
        }
    }
}
impl AwsRdsDbInstanceDetails {
    /// Creates a new builder-style object to manufacture [`AwsRdsDbInstanceDetails`](crate::model::AwsRdsDbInstanceDetails)
    pub fn builder() -> crate::model::aws_rds_db_instance_details::Builder {
        crate::model::aws_rds_db_instance_details::Builder::default()
    }
}

/// <p>Specifies the connection endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRdsDbInstanceEndpoint {
    /// <p>Specifies the DNS address of the DB instance.</p>
    pub address: std::option::Option<std::string::String>,
    /// <p>Specifies the port that the database engine is listening on.</p>
    pub port: i32,
    /// <p>Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.</p>
    pub hosted_zone_id: std::option::Option<std::string::String>,
}
impl AwsRdsDbInstanceEndpoint {
    /// <p>Specifies the DNS address of the DB instance.</p>
    pub fn address(&self) -> std::option::Option<&str> {
        self.address.as_deref()
    }
    /// <p>Specifies the port that the database engine is listening on.</p>
    pub fn port(&self) -> i32 {
        self.port
    }
    /// <p>Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.</p>
    pub fn hosted_zone_id(&self) -> std::option::Option<&str> {
        self.hosted_zone_id.as_deref()
    }
}
impl std::fmt::Debug for AwsRdsDbInstanceEndpoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRdsDbInstanceEndpoint");
        formatter.field("address", &self.address);
        formatter.field("port", &self.port);
        formatter.field("hosted_zone_id", &self.hosted_zone_id);
        formatter.finish()
    }
}
/// See [`AwsRdsDbInstanceEndpoint`](crate::model::AwsRdsDbInstanceEndpoint)
pub mod aws_rds_db_instance_endpoint {

    /// A builder for [`AwsRdsDbInstanceEndpoint`](crate::model::AwsRdsDbInstanceEndpoint)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) address: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) hosted_zone_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the DNS address of the DB instance.</p>
        pub fn address(mut self, input: impl Into<std::string::String>) -> Self {
            self.address = Some(input.into());
            self
        }
        /// <p>Specifies the DNS address of the DB instance.</p>
        pub fn set_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.address = input;
            self
        }
        /// <p>Specifies the port that the database engine is listening on.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>Specifies the port that the database engine is listening on.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// <p>Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.</p>
        pub fn hosted_zone_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hosted_zone_id = Some(input.into());
            self
        }
        /// <p>Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.</p>
        pub fn set_hosted_zone_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hosted_zone_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRdsDbInstanceEndpoint`](crate::model::AwsRdsDbInstanceEndpoint)
        pub fn build(self) -> crate::model::AwsRdsDbInstanceEndpoint {
            crate::model::AwsRdsDbInstanceEndpoint {
                address: self.address,
                port: self.port.unwrap_or_default(),
                hosted_zone_id: self.hosted_zone_id,
            }
        }
    }
}
impl AwsRdsDbInstanceEndpoint {
    /// Creates a new builder-style object to manufacture [`AwsRdsDbInstanceEndpoint`](crate::model::AwsRdsDbInstanceEndpoint)
    pub fn builder() -> crate::model::aws_rds_db_instance_endpoint::Builder {
        crate::model::aws_rds_db_instance_endpoint::Builder::default()
    }
}

/// <p>Information about the status of a read replica.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRdsDbStatusInfo {
    /// <p>The type of status. For a read replica, the status type is read replication.</p>
    pub status_type: std::option::Option<std::string::String>,
    /// <p>Whether the read replica instance is operating normally.</p>
    pub normal: bool,
    /// <p>The status of the read replica instance.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>If the read replica is currently in an error state, provides the error details.</p>
    pub message: std::option::Option<std::string::String>,
}
impl AwsRdsDbStatusInfo {
    /// <p>The type of status. For a read replica, the status type is read replication.</p>
    pub fn status_type(&self) -> std::option::Option<&str> {
        self.status_type.as_deref()
    }
    /// <p>Whether the read replica instance is operating normally.</p>
    pub fn normal(&self) -> bool {
        self.normal
    }
    /// <p>The status of the read replica instance.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>If the read replica is currently in an error state, provides the error details.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Debug for AwsRdsDbStatusInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRdsDbStatusInfo");
        formatter.field("status_type", &self.status_type);
        formatter.field("normal", &self.normal);
        formatter.field("status", &self.status);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`AwsRdsDbStatusInfo`](crate::model::AwsRdsDbStatusInfo)
pub mod aws_rds_db_status_info {

    /// A builder for [`AwsRdsDbStatusInfo`](crate::model::AwsRdsDbStatusInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status_type: std::option::Option<std::string::String>,
        pub(crate) normal: std::option::Option<bool>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of status. For a read replica, the status type is read replication.</p>
        pub fn status_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_type = Some(input.into());
            self
        }
        /// <p>The type of status. For a read replica, the status type is read replication.</p>
        pub fn set_status_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status_type = input;
            self
        }
        /// <p>Whether the read replica instance is operating normally.</p>
        pub fn normal(mut self, input: bool) -> Self {
            self.normal = Some(input);
            self
        }
        /// <p>Whether the read replica instance is operating normally.</p>
        pub fn set_normal(mut self, input: std::option::Option<bool>) -> Self {
            self.normal = input;
            self
        }
        /// <p>The status of the read replica instance.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the read replica instance.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>If the read replica is currently in an error state, provides the error details.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>If the read replica is currently in an error state, provides the error details.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRdsDbStatusInfo`](crate::model::AwsRdsDbStatusInfo)
        pub fn build(self) -> crate::model::AwsRdsDbStatusInfo {
            crate::model::AwsRdsDbStatusInfo {
                status_type: self.status_type,
                normal: self.normal.unwrap_or_default(),
                status: self.status,
                message: self.message,
            }
        }
    }
}
impl AwsRdsDbStatusInfo {
    /// Creates a new builder-style object to manufacture [`AwsRdsDbStatusInfo`](crate::model::AwsRdsDbStatusInfo)
    pub fn builder() -> crate::model::aws_rds_db_status_info::Builder {
        crate::model::aws_rds_db_status_info::Builder::default()
    }
}

/// <p>An option group membership.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRdsDbOptionGroupMembership {
    /// <p>The name of the option group.</p>
    pub option_group_name: std::option::Option<std::string::String>,
    /// <p>The status of the option group membership.</p>
    pub status: std::option::Option<std::string::String>,
}
impl AwsRdsDbOptionGroupMembership {
    /// <p>The name of the option group.</p>
    pub fn option_group_name(&self) -> std::option::Option<&str> {
        self.option_group_name.as_deref()
    }
    /// <p>The status of the option group membership.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
}
impl std::fmt::Debug for AwsRdsDbOptionGroupMembership {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRdsDbOptionGroupMembership");
        formatter.field("option_group_name", &self.option_group_name);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`AwsRdsDbOptionGroupMembership`](crate::model::AwsRdsDbOptionGroupMembership)
pub mod aws_rds_db_option_group_membership {

    /// A builder for [`AwsRdsDbOptionGroupMembership`](crate::model::AwsRdsDbOptionGroupMembership)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) option_group_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the option group.</p>
        pub fn option_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.option_group_name = Some(input.into());
            self
        }
        /// <p>The name of the option group.</p>
        pub fn set_option_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.option_group_name = input;
            self
        }
        /// <p>The status of the option group membership.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the option group membership.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRdsDbOptionGroupMembership`](crate::model::AwsRdsDbOptionGroupMembership)
        pub fn build(self) -> crate::model::AwsRdsDbOptionGroupMembership {
            crate::model::AwsRdsDbOptionGroupMembership {
                option_group_name: self.option_group_name,
                status: self.status,
            }
        }
    }
}
impl AwsRdsDbOptionGroupMembership {
    /// Creates a new builder-style object to manufacture [`AwsRdsDbOptionGroupMembership`](crate::model::AwsRdsDbOptionGroupMembership)
    pub fn builder() -> crate::model::aws_rds_db_option_group_membership::Builder {
        crate::model::aws_rds_db_option_group_membership::Builder::default()
    }
}

/// <p>Changes to a DB instance that are currently pending.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRdsDbPendingModifiedValues {
    /// <p>The new DB instance class for the DB instance.</p>
    pub db_instance_class: std::option::Option<std::string::String>,
    /// <p>The new value of the allocated storage for the DB instance.</p>
    pub allocated_storage: i32,
    /// <p>The new master user password for the DB instance.</p>
    pub master_user_password: std::option::Option<std::string::String>,
    /// <p>The new port for the DB instance.</p>
    pub port: i32,
    /// <p>The new backup retention period for the DB instance.</p>
    pub backup_retention_period: i32,
    /// <p>Indicates that a single Availability Zone DB instance is changing to a multiple Availability Zone deployment.</p>
    pub multi_az: bool,
    /// <p>The new engine version for the DB instance.</p>
    pub engine_version: std::option::Option<std::string::String>,
    /// <p>The new license model value for the DB instance.</p>
    pub license_model: std::option::Option<std::string::String>,
    /// <p>The new provisioned IOPS value for the DB instance.</p>
    pub iops: i32,
    /// <p>The new DB instance identifier for the DB instance.</p>
    pub db_instance_identifier: std::option::Option<std::string::String>,
    /// <p>The new storage type for the DB instance.</p>
    pub storage_type: std::option::Option<std::string::String>,
    /// <p>The new CA certificate identifier for the DB instance.</p>
    pub ca_certificate_identifier: std::option::Option<std::string::String>,
    /// <p>The name of the new subnet group for the DB instance.</p>
    pub db_subnet_group_name: std::option::Option<std::string::String>,
    /// <p>A list of log types that are being enabled or disabled.</p>
    pub pending_cloud_watch_logs_exports:
        std::option::Option<crate::model::AwsRdsPendingCloudWatchLogsExports>,
    /// <p>Processor features that are being updated.</p>
    pub processor_features:
        std::option::Option<std::vec::Vec<crate::model::AwsRdsDbProcessorFeature>>,
}
impl AwsRdsDbPendingModifiedValues {
    /// <p>The new DB instance class for the DB instance.</p>
    pub fn db_instance_class(&self) -> std::option::Option<&str> {
        self.db_instance_class.as_deref()
    }
    /// <p>The new value of the allocated storage for the DB instance.</p>
    pub fn allocated_storage(&self) -> i32 {
        self.allocated_storage
    }
    /// <p>The new master user password for the DB instance.</p>
    pub fn master_user_password(&self) -> std::option::Option<&str> {
        self.master_user_password.as_deref()
    }
    /// <p>The new port for the DB instance.</p>
    pub fn port(&self) -> i32 {
        self.port
    }
    /// <p>The new backup retention period for the DB instance.</p>
    pub fn backup_retention_period(&self) -> i32 {
        self.backup_retention_period
    }
    /// <p>Indicates that a single Availability Zone DB instance is changing to a multiple Availability Zone deployment.</p>
    pub fn multi_az(&self) -> bool {
        self.multi_az
    }
    /// <p>The new engine version for the DB instance.</p>
    pub fn engine_version(&self) -> std::option::Option<&str> {
        self.engine_version.as_deref()
    }
    /// <p>The new license model value for the DB instance.</p>
    pub fn license_model(&self) -> std::option::Option<&str> {
        self.license_model.as_deref()
    }
    /// <p>The new provisioned IOPS value for the DB instance.</p>
    pub fn iops(&self) -> i32 {
        self.iops
    }
    /// <p>The new DB instance identifier for the DB instance.</p>
    pub fn db_instance_identifier(&self) -> std::option::Option<&str> {
        self.db_instance_identifier.as_deref()
    }
    /// <p>The new storage type for the DB instance.</p>
    pub fn storage_type(&self) -> std::option::Option<&str> {
        self.storage_type.as_deref()
    }
    /// <p>The new CA certificate identifier for the DB instance.</p>
    pub fn ca_certificate_identifier(&self) -> std::option::Option<&str> {
        self.ca_certificate_identifier.as_deref()
    }
    /// <p>The name of the new subnet group for the DB instance.</p>
    pub fn db_subnet_group_name(&self) -> std::option::Option<&str> {
        self.db_subnet_group_name.as_deref()
    }
    /// <p>A list of log types that are being enabled or disabled.</p>
    pub fn pending_cloud_watch_logs_exports(
        &self,
    ) -> std::option::Option<&crate::model::AwsRdsPendingCloudWatchLogsExports> {
        self.pending_cloud_watch_logs_exports.as_ref()
    }
    /// <p>Processor features that are being updated.</p>
    pub fn processor_features(
        &self,
    ) -> std::option::Option<&[crate::model::AwsRdsDbProcessorFeature]> {
        self.processor_features.as_deref()
    }
}
impl std::fmt::Debug for AwsRdsDbPendingModifiedValues {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRdsDbPendingModifiedValues");
        formatter.field("db_instance_class", &self.db_instance_class);
        formatter.field("allocated_storage", &self.allocated_storage);
        formatter.field("master_user_password", &self.master_user_password);
        formatter.field("port", &self.port);
        formatter.field("backup_retention_period", &self.backup_retention_period);
        formatter.field("multi_az", &self.multi_az);
        formatter.field("engine_version", &self.engine_version);
        formatter.field("license_model", &self.license_model);
        formatter.field("iops", &self.iops);
        formatter.field("db_instance_identifier", &self.db_instance_identifier);
        formatter.field("storage_type", &self.storage_type);
        formatter.field("ca_certificate_identifier", &self.ca_certificate_identifier);
        formatter.field("db_subnet_group_name", &self.db_subnet_group_name);
        formatter.field(
            "pending_cloud_watch_logs_exports",
            &self.pending_cloud_watch_logs_exports,
        );
        formatter.field("processor_features", &self.processor_features);
        formatter.finish()
    }
}
/// See [`AwsRdsDbPendingModifiedValues`](crate::model::AwsRdsDbPendingModifiedValues)
pub mod aws_rds_db_pending_modified_values {

    /// A builder for [`AwsRdsDbPendingModifiedValues`](crate::model::AwsRdsDbPendingModifiedValues)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) db_instance_class: std::option::Option<std::string::String>,
        pub(crate) allocated_storage: std::option::Option<i32>,
        pub(crate) master_user_password: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) backup_retention_period: std::option::Option<i32>,
        pub(crate) multi_az: std::option::Option<bool>,
        pub(crate) engine_version: std::option::Option<std::string::String>,
        pub(crate) license_model: std::option::Option<std::string::String>,
        pub(crate) iops: std::option::Option<i32>,
        pub(crate) db_instance_identifier: std::option::Option<std::string::String>,
        pub(crate) storage_type: std::option::Option<std::string::String>,
        pub(crate) ca_certificate_identifier: std::option::Option<std::string::String>,
        pub(crate) db_subnet_group_name: std::option::Option<std::string::String>,
        pub(crate) pending_cloud_watch_logs_exports:
            std::option::Option<crate::model::AwsRdsPendingCloudWatchLogsExports>,
        pub(crate) processor_features:
            std::option::Option<std::vec::Vec<crate::model::AwsRdsDbProcessorFeature>>,
    }
    impl Builder {
        /// <p>The new DB instance class for the DB instance.</p>
        pub fn db_instance_class(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_instance_class = Some(input.into());
            self
        }
        /// <p>The new DB instance class for the DB instance.</p>
        pub fn set_db_instance_class(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.db_instance_class = input;
            self
        }
        /// <p>The new value of the allocated storage for the DB instance.</p>
        pub fn allocated_storage(mut self, input: i32) -> Self {
            self.allocated_storage = Some(input);
            self
        }
        /// <p>The new value of the allocated storage for the DB instance.</p>
        pub fn set_allocated_storage(mut self, input: std::option::Option<i32>) -> Self {
            self.allocated_storage = input;
            self
        }
        /// <p>The new master user password for the DB instance.</p>
        pub fn master_user_password(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_user_password = Some(input.into());
            self
        }
        /// <p>The new master user password for the DB instance.</p>
        pub fn set_master_user_password(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_user_password = input;
            self
        }
        /// <p>The new port for the DB instance.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>The new port for the DB instance.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// <p>The new backup retention period for the DB instance.</p>
        pub fn backup_retention_period(mut self, input: i32) -> Self {
            self.backup_retention_period = Some(input);
            self
        }
        /// <p>The new backup retention period for the DB instance.</p>
        pub fn set_backup_retention_period(mut self, input: std::option::Option<i32>) -> Self {
            self.backup_retention_period = input;
            self
        }
        /// <p>Indicates that a single Availability Zone DB instance is changing to a multiple Availability Zone deployment.</p>
        pub fn multi_az(mut self, input: bool) -> Self {
            self.multi_az = Some(input);
            self
        }
        /// <p>Indicates that a single Availability Zone DB instance is changing to a multiple Availability Zone deployment.</p>
        pub fn set_multi_az(mut self, input: std::option::Option<bool>) -> Self {
            self.multi_az = input;
            self
        }
        /// <p>The new engine version for the DB instance.</p>
        pub fn engine_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.engine_version = Some(input.into());
            self
        }
        /// <p>The new engine version for the DB instance.</p>
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.engine_version = input;
            self
        }
        /// <p>The new license model value for the DB instance.</p>
        pub fn license_model(mut self, input: impl Into<std::string::String>) -> Self {
            self.license_model = Some(input.into());
            self
        }
        /// <p>The new license model value for the DB instance.</p>
        pub fn set_license_model(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.license_model = input;
            self
        }
        /// <p>The new provisioned IOPS value for the DB instance.</p>
        pub fn iops(mut self, input: i32) -> Self {
            self.iops = Some(input);
            self
        }
        /// <p>The new provisioned IOPS value for the DB instance.</p>
        pub fn set_iops(mut self, input: std::option::Option<i32>) -> Self {
            self.iops = input;
            self
        }
        /// <p>The new DB instance identifier for the DB instance.</p>
        pub fn db_instance_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_instance_identifier = Some(input.into());
            self
        }
        /// <p>The new DB instance identifier for the DB instance.</p>
        pub fn set_db_instance_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.db_instance_identifier = input;
            self
        }
        /// <p>The new storage type for the DB instance.</p>
        pub fn storage_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.storage_type = Some(input.into());
            self
        }
        /// <p>The new storage type for the DB instance.</p>
        pub fn set_storage_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.storage_type = input;
            self
        }
        /// <p>The new CA certificate identifier for the DB instance.</p>
        pub fn ca_certificate_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.ca_certificate_identifier = Some(input.into());
            self
        }
        /// <p>The new CA certificate identifier for the DB instance.</p>
        pub fn set_ca_certificate_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ca_certificate_identifier = input;
            self
        }
        /// <p>The name of the new subnet group for the DB instance.</p>
        pub fn db_subnet_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_subnet_group_name = Some(input.into());
            self
        }
        /// <p>The name of the new subnet group for the DB instance.</p>
        pub fn set_db_subnet_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.db_subnet_group_name = input;
            self
        }
        /// <p>A list of log types that are being enabled or disabled.</p>
        pub fn pending_cloud_watch_logs_exports(
            mut self,
            input: crate::model::AwsRdsPendingCloudWatchLogsExports,
        ) -> Self {
            self.pending_cloud_watch_logs_exports = Some(input);
            self
        }
        /// <p>A list of log types that are being enabled or disabled.</p>
        pub fn set_pending_cloud_watch_logs_exports(
            mut self,
            input: std::option::Option<crate::model::AwsRdsPendingCloudWatchLogsExports>,
        ) -> Self {
            self.pending_cloud_watch_logs_exports = input;
            self
        }
        /// Appends an item to `processor_features`.
        ///
        /// To override the contents of this collection use [`set_processor_features`](Self::set_processor_features).
        ///
        /// <p>Processor features that are being updated.</p>
        pub fn processor_features(mut self, input: crate::model::AwsRdsDbProcessorFeature) -> Self {
            let mut v = self.processor_features.unwrap_or_default();
            v.push(input);
            self.processor_features = Some(v);
            self
        }
        /// <p>Processor features that are being updated.</p>
        pub fn set_processor_features(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsRdsDbProcessorFeature>>,
        ) -> Self {
            self.processor_features = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRdsDbPendingModifiedValues`](crate::model::AwsRdsDbPendingModifiedValues)
        pub fn build(self) -> crate::model::AwsRdsDbPendingModifiedValues {
            crate::model::AwsRdsDbPendingModifiedValues {
                db_instance_class: self.db_instance_class,
                allocated_storage: self.allocated_storage.unwrap_or_default(),
                master_user_password: self.master_user_password,
                port: self.port.unwrap_or_default(),
                backup_retention_period: self.backup_retention_period.unwrap_or_default(),
                multi_az: self.multi_az.unwrap_or_default(),
                engine_version: self.engine_version,
                license_model: self.license_model,
                iops: self.iops.unwrap_or_default(),
                db_instance_identifier: self.db_instance_identifier,
                storage_type: self.storage_type,
                ca_certificate_identifier: self.ca_certificate_identifier,
                db_subnet_group_name: self.db_subnet_group_name,
                pending_cloud_watch_logs_exports: self.pending_cloud_watch_logs_exports,
                processor_features: self.processor_features,
            }
        }
    }
}
impl AwsRdsDbPendingModifiedValues {
    /// Creates a new builder-style object to manufacture [`AwsRdsDbPendingModifiedValues`](crate::model::AwsRdsDbPendingModifiedValues)
    pub fn builder() -> crate::model::aws_rds_db_pending_modified_values::Builder {
        crate::model::aws_rds_db_pending_modified_values::Builder::default()
    }
}

/// <p>Identifies the log types to enable and disable.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRdsPendingCloudWatchLogsExports {
    /// <p>A list of log types that are being enabled.</p>
    pub log_types_to_enable: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of log types that are being disabled.</p>
    pub log_types_to_disable: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AwsRdsPendingCloudWatchLogsExports {
    /// <p>A list of log types that are being enabled.</p>
    pub fn log_types_to_enable(&self) -> std::option::Option<&[std::string::String]> {
        self.log_types_to_enable.as_deref()
    }
    /// <p>A list of log types that are being disabled.</p>
    pub fn log_types_to_disable(&self) -> std::option::Option<&[std::string::String]> {
        self.log_types_to_disable.as_deref()
    }
}
impl std::fmt::Debug for AwsRdsPendingCloudWatchLogsExports {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRdsPendingCloudWatchLogsExports");
        formatter.field("log_types_to_enable", &self.log_types_to_enable);
        formatter.field("log_types_to_disable", &self.log_types_to_disable);
        formatter.finish()
    }
}
/// See [`AwsRdsPendingCloudWatchLogsExports`](crate::model::AwsRdsPendingCloudWatchLogsExports)
pub mod aws_rds_pending_cloud_watch_logs_exports {

    /// A builder for [`AwsRdsPendingCloudWatchLogsExports`](crate::model::AwsRdsPendingCloudWatchLogsExports)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_types_to_enable: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) log_types_to_disable: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `log_types_to_enable`.
        ///
        /// To override the contents of this collection use [`set_log_types_to_enable`](Self::set_log_types_to_enable).
        ///
        /// <p>A list of log types that are being enabled.</p>
        pub fn log_types_to_enable(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.log_types_to_enable.unwrap_or_default();
            v.push(input.into());
            self.log_types_to_enable = Some(v);
            self
        }
        /// <p>A list of log types that are being enabled.</p>
        pub fn set_log_types_to_enable(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.log_types_to_enable = input;
            self
        }
        /// Appends an item to `log_types_to_disable`.
        ///
        /// To override the contents of this collection use [`set_log_types_to_disable`](Self::set_log_types_to_disable).
        ///
        /// <p>A list of log types that are being disabled.</p>
        pub fn log_types_to_disable(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.log_types_to_disable.unwrap_or_default();
            v.push(input.into());
            self.log_types_to_disable = Some(v);
            self
        }
        /// <p>A list of log types that are being disabled.</p>
        pub fn set_log_types_to_disable(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.log_types_to_disable = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRdsPendingCloudWatchLogsExports`](crate::model::AwsRdsPendingCloudWatchLogsExports)
        pub fn build(self) -> crate::model::AwsRdsPendingCloudWatchLogsExports {
            crate::model::AwsRdsPendingCloudWatchLogsExports {
                log_types_to_enable: self.log_types_to_enable,
                log_types_to_disable: self.log_types_to_disable,
            }
        }
    }
}
impl AwsRdsPendingCloudWatchLogsExports {
    /// Creates a new builder-style object to manufacture [`AwsRdsPendingCloudWatchLogsExports`](crate::model::AwsRdsPendingCloudWatchLogsExports)
    pub fn builder() -> crate::model::aws_rds_pending_cloud_watch_logs_exports::Builder {
        crate::model::aws_rds_pending_cloud_watch_logs_exports::Builder::default()
    }
}

/// <p>Information about the subnet group for the database instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRdsDbSubnetGroup {
    /// <p>The name of the subnet group.</p>
    pub db_subnet_group_name: std::option::Option<std::string::String>,
    /// <p>The description of the subnet group.</p>
    pub db_subnet_group_description: std::option::Option<std::string::String>,
    /// <p>The VPC ID of the subnet group.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The status of the subnet group.</p>
    pub subnet_group_status: std::option::Option<std::string::String>,
    /// <p>A list of subnets in the subnet group.</p>
    pub subnets: std::option::Option<std::vec::Vec<crate::model::AwsRdsDbSubnetGroupSubnet>>,
    /// <p>The ARN of the subnet group.</p>
    pub db_subnet_group_arn: std::option::Option<std::string::String>,
}
impl AwsRdsDbSubnetGroup {
    /// <p>The name of the subnet group.</p>
    pub fn db_subnet_group_name(&self) -> std::option::Option<&str> {
        self.db_subnet_group_name.as_deref()
    }
    /// <p>The description of the subnet group.</p>
    pub fn db_subnet_group_description(&self) -> std::option::Option<&str> {
        self.db_subnet_group_description.as_deref()
    }
    /// <p>The VPC ID of the subnet group.</p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
    /// <p>The status of the subnet group.</p>
    pub fn subnet_group_status(&self) -> std::option::Option<&str> {
        self.subnet_group_status.as_deref()
    }
    /// <p>A list of subnets in the subnet group.</p>
    pub fn subnets(&self) -> std::option::Option<&[crate::model::AwsRdsDbSubnetGroupSubnet]> {
        self.subnets.as_deref()
    }
    /// <p>The ARN of the subnet group.</p>
    pub fn db_subnet_group_arn(&self) -> std::option::Option<&str> {
        self.db_subnet_group_arn.as_deref()
    }
}
impl std::fmt::Debug for AwsRdsDbSubnetGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRdsDbSubnetGroup");
        formatter.field("db_subnet_group_name", &self.db_subnet_group_name);
        formatter.field(
            "db_subnet_group_description",
            &self.db_subnet_group_description,
        );
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("subnet_group_status", &self.subnet_group_status);
        formatter.field("subnets", &self.subnets);
        formatter.field("db_subnet_group_arn", &self.db_subnet_group_arn);
        formatter.finish()
    }
}
/// See [`AwsRdsDbSubnetGroup`](crate::model::AwsRdsDbSubnetGroup)
pub mod aws_rds_db_subnet_group {

    /// A builder for [`AwsRdsDbSubnetGroup`](crate::model::AwsRdsDbSubnetGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) db_subnet_group_name: std::option::Option<std::string::String>,
        pub(crate) db_subnet_group_description: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) subnet_group_status: std::option::Option<std::string::String>,
        pub(crate) subnets:
            std::option::Option<std::vec::Vec<crate::model::AwsRdsDbSubnetGroupSubnet>>,
        pub(crate) db_subnet_group_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the subnet group.</p>
        pub fn db_subnet_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_subnet_group_name = Some(input.into());
            self
        }
        /// <p>The name of the subnet group.</p>
        pub fn set_db_subnet_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.db_subnet_group_name = input;
            self
        }
        /// <p>The description of the subnet group.</p>
        pub fn db_subnet_group_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.db_subnet_group_description = Some(input.into());
            self
        }
        /// <p>The description of the subnet group.</p>
        pub fn set_db_subnet_group_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.db_subnet_group_description = input;
            self
        }
        /// <p>The VPC ID of the subnet group.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The VPC ID of the subnet group.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// <p>The status of the subnet group.</p>
        pub fn subnet_group_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_group_status = Some(input.into());
            self
        }
        /// <p>The status of the subnet group.</p>
        pub fn set_subnet_group_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.subnet_group_status = input;
            self
        }
        /// Appends an item to `subnets`.
        ///
        /// To override the contents of this collection use [`set_subnets`](Self::set_subnets).
        ///
        /// <p>A list of subnets in the subnet group.</p>
        pub fn subnets(mut self, input: crate::model::AwsRdsDbSubnetGroupSubnet) -> Self {
            let mut v = self.subnets.unwrap_or_default();
            v.push(input);
            self.subnets = Some(v);
            self
        }
        /// <p>A list of subnets in the subnet group.</p>
        pub fn set_subnets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsRdsDbSubnetGroupSubnet>>,
        ) -> Self {
            self.subnets = input;
            self
        }
        /// <p>The ARN of the subnet group.</p>
        pub fn db_subnet_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_subnet_group_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the subnet group.</p>
        pub fn set_db_subnet_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.db_subnet_group_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRdsDbSubnetGroup`](crate::model::AwsRdsDbSubnetGroup)
        pub fn build(self) -> crate::model::AwsRdsDbSubnetGroup {
            crate::model::AwsRdsDbSubnetGroup {
                db_subnet_group_name: self.db_subnet_group_name,
                db_subnet_group_description: self.db_subnet_group_description,
                vpc_id: self.vpc_id,
                subnet_group_status: self.subnet_group_status,
                subnets: self.subnets,
                db_subnet_group_arn: self.db_subnet_group_arn,
            }
        }
    }
}
impl AwsRdsDbSubnetGroup {
    /// Creates a new builder-style object to manufacture [`AwsRdsDbSubnetGroup`](crate::model::AwsRdsDbSubnetGroup)
    pub fn builder() -> crate::model::aws_rds_db_subnet_group::Builder {
        crate::model::aws_rds_db_subnet_group::Builder::default()
    }
}

/// <p>Information about a subnet in a subnet group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRdsDbSubnetGroupSubnet {
    /// <p>The identifier of a subnet in the subnet group.</p>
    pub subnet_identifier: std::option::Option<std::string::String>,
    /// <p>Information about the Availability Zone for a subnet in the subnet group.</p>
    pub subnet_availability_zone:
        std::option::Option<crate::model::AwsRdsDbSubnetGroupSubnetAvailabilityZone>,
    /// <p>The status of a subnet in the subnet group.</p>
    pub subnet_status: std::option::Option<std::string::String>,
}
impl AwsRdsDbSubnetGroupSubnet {
    /// <p>The identifier of a subnet in the subnet group.</p>
    pub fn subnet_identifier(&self) -> std::option::Option<&str> {
        self.subnet_identifier.as_deref()
    }
    /// <p>Information about the Availability Zone for a subnet in the subnet group.</p>
    pub fn subnet_availability_zone(
        &self,
    ) -> std::option::Option<&crate::model::AwsRdsDbSubnetGroupSubnetAvailabilityZone> {
        self.subnet_availability_zone.as_ref()
    }
    /// <p>The status of a subnet in the subnet group.</p>
    pub fn subnet_status(&self) -> std::option::Option<&str> {
        self.subnet_status.as_deref()
    }
}
impl std::fmt::Debug for AwsRdsDbSubnetGroupSubnet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRdsDbSubnetGroupSubnet");
        formatter.field("subnet_identifier", &self.subnet_identifier);
        formatter.field("subnet_availability_zone", &self.subnet_availability_zone);
        formatter.field("subnet_status", &self.subnet_status);
        formatter.finish()
    }
}
/// See [`AwsRdsDbSubnetGroupSubnet`](crate::model::AwsRdsDbSubnetGroupSubnet)
pub mod aws_rds_db_subnet_group_subnet {

    /// A builder for [`AwsRdsDbSubnetGroupSubnet`](crate::model::AwsRdsDbSubnetGroupSubnet)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subnet_identifier: std::option::Option<std::string::String>,
        pub(crate) subnet_availability_zone:
            std::option::Option<crate::model::AwsRdsDbSubnetGroupSubnetAvailabilityZone>,
        pub(crate) subnet_status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of a subnet in the subnet group.</p>
        pub fn subnet_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_identifier = Some(input.into());
            self
        }
        /// <p>The identifier of a subnet in the subnet group.</p>
        pub fn set_subnet_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.subnet_identifier = input;
            self
        }
        /// <p>Information about the Availability Zone for a subnet in the subnet group.</p>
        pub fn subnet_availability_zone(
            mut self,
            input: crate::model::AwsRdsDbSubnetGroupSubnetAvailabilityZone,
        ) -> Self {
            self.subnet_availability_zone = Some(input);
            self
        }
        /// <p>Information about the Availability Zone for a subnet in the subnet group.</p>
        pub fn set_subnet_availability_zone(
            mut self,
            input: std::option::Option<crate::model::AwsRdsDbSubnetGroupSubnetAvailabilityZone>,
        ) -> Self {
            self.subnet_availability_zone = input;
            self
        }
        /// <p>The status of a subnet in the subnet group.</p>
        pub fn subnet_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_status = Some(input.into());
            self
        }
        /// <p>The status of a subnet in the subnet group.</p>
        pub fn set_subnet_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.subnet_status = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRdsDbSubnetGroupSubnet`](crate::model::AwsRdsDbSubnetGroupSubnet)
        pub fn build(self) -> crate::model::AwsRdsDbSubnetGroupSubnet {
            crate::model::AwsRdsDbSubnetGroupSubnet {
                subnet_identifier: self.subnet_identifier,
                subnet_availability_zone: self.subnet_availability_zone,
                subnet_status: self.subnet_status,
            }
        }
    }
}
impl AwsRdsDbSubnetGroupSubnet {
    /// Creates a new builder-style object to manufacture [`AwsRdsDbSubnetGroupSubnet`](crate::model::AwsRdsDbSubnetGroupSubnet)
    pub fn builder() -> crate::model::aws_rds_db_subnet_group_subnet::Builder {
        crate::model::aws_rds_db_subnet_group_subnet::Builder::default()
    }
}

/// <p>An Availability Zone for a subnet in a subnet group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRdsDbSubnetGroupSubnetAvailabilityZone {
    /// <p>The name of the Availability Zone for a subnet in the subnet group.</p>
    pub name: std::option::Option<std::string::String>,
}
impl AwsRdsDbSubnetGroupSubnetAvailabilityZone {
    /// <p>The name of the Availability Zone for a subnet in the subnet group.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl std::fmt::Debug for AwsRdsDbSubnetGroupSubnetAvailabilityZone {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRdsDbSubnetGroupSubnetAvailabilityZone");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`AwsRdsDbSubnetGroupSubnetAvailabilityZone`](crate::model::AwsRdsDbSubnetGroupSubnetAvailabilityZone)
pub mod aws_rds_db_subnet_group_subnet_availability_zone {

    /// A builder for [`AwsRdsDbSubnetGroupSubnetAvailabilityZone`](crate::model::AwsRdsDbSubnetGroupSubnetAvailabilityZone)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Availability Zone for a subnet in the subnet group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the Availability Zone for a subnet in the subnet group.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRdsDbSubnetGroupSubnetAvailabilityZone`](crate::model::AwsRdsDbSubnetGroupSubnetAvailabilityZone)
        pub fn build(self) -> crate::model::AwsRdsDbSubnetGroupSubnetAvailabilityZone {
            crate::model::AwsRdsDbSubnetGroupSubnetAvailabilityZone { name: self.name }
        }
    }
}
impl AwsRdsDbSubnetGroupSubnetAvailabilityZone {
    /// Creates a new builder-style object to manufacture [`AwsRdsDbSubnetGroupSubnetAvailabilityZone`](crate::model::AwsRdsDbSubnetGroupSubnetAvailabilityZone)
    pub fn builder() -> crate::model::aws_rds_db_subnet_group_subnet_availability_zone::Builder {
        crate::model::aws_rds_db_subnet_group_subnet_availability_zone::Builder::default()
    }
}

/// <p>Provides information about a parameter group for a DB instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRdsDbParameterGroup {
    /// <p>The name of the parameter group.</p>
    pub db_parameter_group_name: std::option::Option<std::string::String>,
    /// <p>The status of parameter updates.</p>
    pub parameter_apply_status: std::option::Option<std::string::String>,
}
impl AwsRdsDbParameterGroup {
    /// <p>The name of the parameter group.</p>
    pub fn db_parameter_group_name(&self) -> std::option::Option<&str> {
        self.db_parameter_group_name.as_deref()
    }
    /// <p>The status of parameter updates.</p>
    pub fn parameter_apply_status(&self) -> std::option::Option<&str> {
        self.parameter_apply_status.as_deref()
    }
}
impl std::fmt::Debug for AwsRdsDbParameterGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRdsDbParameterGroup");
        formatter.field("db_parameter_group_name", &self.db_parameter_group_name);
        formatter.field("parameter_apply_status", &self.parameter_apply_status);
        formatter.finish()
    }
}
/// See [`AwsRdsDbParameterGroup`](crate::model::AwsRdsDbParameterGroup)
pub mod aws_rds_db_parameter_group {

    /// A builder for [`AwsRdsDbParameterGroup`](crate::model::AwsRdsDbParameterGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) db_parameter_group_name: std::option::Option<std::string::String>,
        pub(crate) parameter_apply_status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the parameter group.</p>
        pub fn db_parameter_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_parameter_group_name = Some(input.into());
            self
        }
        /// <p>The name of the parameter group.</p>
        pub fn set_db_parameter_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.db_parameter_group_name = input;
            self
        }
        /// <p>The status of parameter updates.</p>
        pub fn parameter_apply_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_apply_status = Some(input.into());
            self
        }
        /// <p>The status of parameter updates.</p>
        pub fn set_parameter_apply_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_apply_status = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRdsDbParameterGroup`](crate::model::AwsRdsDbParameterGroup)
        pub fn build(self) -> crate::model::AwsRdsDbParameterGroup {
            crate::model::AwsRdsDbParameterGroup {
                db_parameter_group_name: self.db_parameter_group_name,
                parameter_apply_status: self.parameter_apply_status,
            }
        }
    }
}
impl AwsRdsDbParameterGroup {
    /// Creates a new builder-style object to manufacture [`AwsRdsDbParameterGroup`](crate::model::AwsRdsDbParameterGroup)
    pub fn builder() -> crate::model::aws_rds_db_parameter_group::Builder {
        crate::model::aws_rds_db_parameter_group::Builder::default()
    }
}

/// <p>An IAM role associated with the DB instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRdsDbInstanceAssociatedRole {
    /// <p>The ARN of the IAM role that is associated with the DB instance.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The name of the feature associated with the IAM role.</p>
    pub feature_name: std::option::Option<std::string::String>,
    /// <p>Describes the state of the association between the IAM role and the DB instance. The <code>Status</code> property returns one of the following values:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> - The IAM role ARN is associated with the DB instance and can be used to access other Amazon Web Services services on your behalf.</p> </li>
    /// <li> <p> <code>PENDING</code> - The IAM role ARN is being associated with the DB instance.</p> </li>
    /// <li> <p> <code>INVALID</code> - The IAM role ARN is associated with the DB instance. But the DB instance is unable to assume the IAM role in order to access other Amazon Web Services services on your behalf. </p> </li>
    /// </ul>
    pub status: std::option::Option<std::string::String>,
}
impl AwsRdsDbInstanceAssociatedRole {
    /// <p>The ARN of the IAM role that is associated with the DB instance.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>The name of the feature associated with the IAM role.</p>
    pub fn feature_name(&self) -> std::option::Option<&str> {
        self.feature_name.as_deref()
    }
    /// <p>Describes the state of the association between the IAM role and the DB instance. The <code>Status</code> property returns one of the following values:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> - The IAM role ARN is associated with the DB instance and can be used to access other Amazon Web Services services on your behalf.</p> </li>
    /// <li> <p> <code>PENDING</code> - The IAM role ARN is being associated with the DB instance.</p> </li>
    /// <li> <p> <code>INVALID</code> - The IAM role ARN is associated with the DB instance. But the DB instance is unable to assume the IAM role in order to access other Amazon Web Services services on your behalf. </p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
}
impl std::fmt::Debug for AwsRdsDbInstanceAssociatedRole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRdsDbInstanceAssociatedRole");
        formatter.field("role_arn", &self.role_arn);
        formatter.field("feature_name", &self.feature_name);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`AwsRdsDbInstanceAssociatedRole`](crate::model::AwsRdsDbInstanceAssociatedRole)
pub mod aws_rds_db_instance_associated_role {

    /// A builder for [`AwsRdsDbInstanceAssociatedRole`](crate::model::AwsRdsDbInstanceAssociatedRole)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) feature_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the IAM role that is associated with the DB instance.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the IAM role that is associated with the DB instance.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The name of the feature associated with the IAM role.</p>
        pub fn feature_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.feature_name = Some(input.into());
            self
        }
        /// <p>The name of the feature associated with the IAM role.</p>
        pub fn set_feature_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.feature_name = input;
            self
        }
        /// <p>Describes the state of the association between the IAM role and the DB instance. The <code>Status</code> property returns one of the following values:</p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> - The IAM role ARN is associated with the DB instance and can be used to access other Amazon Web Services services on your behalf.</p> </li>
        /// <li> <p> <code>PENDING</code> - The IAM role ARN is being associated with the DB instance.</p> </li>
        /// <li> <p> <code>INVALID</code> - The IAM role ARN is associated with the DB instance. But the DB instance is unable to assume the IAM role in order to access other Amazon Web Services services on your behalf. </p> </li>
        /// </ul>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>Describes the state of the association between the IAM role and the DB instance. The <code>Status</code> property returns one of the following values:</p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> - The IAM role ARN is associated with the DB instance and can be used to access other Amazon Web Services services on your behalf.</p> </li>
        /// <li> <p> <code>PENDING</code> - The IAM role ARN is being associated with the DB instance.</p> </li>
        /// <li> <p> <code>INVALID</code> - The IAM role ARN is associated with the DB instance. But the DB instance is unable to assume the IAM role in order to access other Amazon Web Services services on your behalf. </p> </li>
        /// </ul>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRdsDbInstanceAssociatedRole`](crate::model::AwsRdsDbInstanceAssociatedRole)
        pub fn build(self) -> crate::model::AwsRdsDbInstanceAssociatedRole {
            crate::model::AwsRdsDbInstanceAssociatedRole {
                role_arn: self.role_arn,
                feature_name: self.feature_name,
                status: self.status,
            }
        }
    }
}
impl AwsRdsDbInstanceAssociatedRole {
    /// Creates a new builder-style object to manufacture [`AwsRdsDbInstanceAssociatedRole`](crate::model::AwsRdsDbInstanceAssociatedRole)
    pub fn builder() -> crate::model::aws_rds_db_instance_associated_role::Builder {
        crate::model::aws_rds_db_instance_associated_role::Builder::default()
    }
}

/// <p>Details about a Lambda layer version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsLambdaLayerVersionDetails {
    /// <p>The version number.</p>
    pub version: i64,
    /// <p>The layer's compatible runtimes. Maximum number of five items.</p>
    /// <p>Valid values: <code>nodejs10.x</code> | <code>nodejs12.x</code> | <code>java8</code> | <code>java11</code> | <code>python2.7</code> | <code>python3.6</code> | <code>python3.7</code> | <code>python3.8</code> | <code>dotnetcore1.0</code> | <code>dotnetcore2.1</code> | <code>go1.x</code> | <code>ruby2.5</code> | <code>provided</code> </p>
    pub compatible_runtimes: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Indicates when the version was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub created_date: std::option::Option<std::string::String>,
}
impl AwsLambdaLayerVersionDetails {
    /// <p>The version number.</p>
    pub fn version(&self) -> i64 {
        self.version
    }
    /// <p>The layer's compatible runtimes. Maximum number of five items.</p>
    /// <p>Valid values: <code>nodejs10.x</code> | <code>nodejs12.x</code> | <code>java8</code> | <code>java11</code> | <code>python2.7</code> | <code>python3.6</code> | <code>python3.7</code> | <code>python3.8</code> | <code>dotnetcore1.0</code> | <code>dotnetcore2.1</code> | <code>go1.x</code> | <code>ruby2.5</code> | <code>provided</code> </p>
    pub fn compatible_runtimes(&self) -> std::option::Option<&[std::string::String]> {
        self.compatible_runtimes.as_deref()
    }
    /// <p>Indicates when the version was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn created_date(&self) -> std::option::Option<&str> {
        self.created_date.as_deref()
    }
}
impl std::fmt::Debug for AwsLambdaLayerVersionDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsLambdaLayerVersionDetails");
        formatter.field("version", &self.version);
        formatter.field("compatible_runtimes", &self.compatible_runtimes);
        formatter.field("created_date", &self.created_date);
        formatter.finish()
    }
}
/// See [`AwsLambdaLayerVersionDetails`](crate::model::AwsLambdaLayerVersionDetails)
pub mod aws_lambda_layer_version_details {

    /// A builder for [`AwsLambdaLayerVersionDetails`](crate::model::AwsLambdaLayerVersionDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) version: std::option::Option<i64>,
        pub(crate) compatible_runtimes: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) created_date: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The version number.</p>
        pub fn version(mut self, input: i64) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>The version number.</p>
        pub fn set_version(mut self, input: std::option::Option<i64>) -> Self {
            self.version = input;
            self
        }
        /// Appends an item to `compatible_runtimes`.
        ///
        /// To override the contents of this collection use [`set_compatible_runtimes`](Self::set_compatible_runtimes).
        ///
        /// <p>The layer's compatible runtimes. Maximum number of five items.</p>
        /// <p>Valid values: <code>nodejs10.x</code> | <code>nodejs12.x</code> | <code>java8</code> | <code>java11</code> | <code>python2.7</code> | <code>python3.6</code> | <code>python3.7</code> | <code>python3.8</code> | <code>dotnetcore1.0</code> | <code>dotnetcore2.1</code> | <code>go1.x</code> | <code>ruby2.5</code> | <code>provided</code> </p>
        pub fn compatible_runtimes(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.compatible_runtimes.unwrap_or_default();
            v.push(input.into());
            self.compatible_runtimes = Some(v);
            self
        }
        /// <p>The layer's compatible runtimes. Maximum number of five items.</p>
        /// <p>Valid values: <code>nodejs10.x</code> | <code>nodejs12.x</code> | <code>java8</code> | <code>java11</code> | <code>python2.7</code> | <code>python3.6</code> | <code>python3.7</code> | <code>python3.8</code> | <code>dotnetcore1.0</code> | <code>dotnetcore2.1</code> | <code>go1.x</code> | <code>ruby2.5</code> | <code>provided</code> </p>
        pub fn set_compatible_runtimes(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.compatible_runtimes = input;
            self
        }
        /// <p>Indicates when the version was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn created_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_date = Some(input.into());
            self
        }
        /// <p>Indicates when the version was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_created_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_date = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsLambdaLayerVersionDetails`](crate::model::AwsLambdaLayerVersionDetails)
        pub fn build(self) -> crate::model::AwsLambdaLayerVersionDetails {
            crate::model::AwsLambdaLayerVersionDetails {
                version: self.version.unwrap_or_default(),
                compatible_runtimes: self.compatible_runtimes,
                created_date: self.created_date,
            }
        }
    }
}
impl AwsLambdaLayerVersionDetails {
    /// Creates a new builder-style object to manufacture [`AwsLambdaLayerVersionDetails`](crate::model::AwsLambdaLayerVersionDetails)
    pub fn builder() -> crate::model::aws_lambda_layer_version_details::Builder {
        crate::model::aws_lambda_layer_version_details::Builder::default()
    }
}

/// <p>Details about a function's configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsLambdaFunctionDetails {
    /// <p>An <code>AwsLambdaFunctionCode</code> object.</p>
    pub code: std::option::Option<crate::model::AwsLambdaFunctionCode>,
    /// <p>The SHA256 hash of the function's deployment package.</p>
    pub code_sha256: std::option::Option<std::string::String>,
    /// <p>The function's dead letter queue.</p>
    pub dead_letter_config: std::option::Option<crate::model::AwsLambdaFunctionDeadLetterConfig>,
    /// <p>The function's environment variables.</p>
    pub environment: std::option::Option<crate::model::AwsLambdaFunctionEnvironment>,
    /// <p>The name of the function.</p>
    pub function_name: std::option::Option<std::string::String>,
    /// <p>The function that Lambda calls to begin executing your function.</p>
    pub handler: std::option::Option<std::string::String>,
    /// <p>The KMS key that is used to encrypt the function's environment variables. This key is only returned if you've configured a customer managed customer managed key.</p>
    pub kms_key_arn: std::option::Option<std::string::String>,
    /// <p>Indicates when the function was last updated.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub last_modified: std::option::Option<std::string::String>,
    /// <p>The function's layers.</p>
    pub layers: std::option::Option<std::vec::Vec<crate::model::AwsLambdaFunctionLayer>>,
    /// <p>For Lambda@Edge functions, the ARN of the master function.</p>
    pub master_arn: std::option::Option<std::string::String>,
    /// <p>The memory that is allocated to the function.</p>
    pub memory_size: i32,
    /// <p>The latest updated revision of the function or alias.</p>
    pub revision_id: std::option::Option<std::string::String>,
    /// <p>The function's execution role.</p>
    pub role: std::option::Option<std::string::String>,
    /// <p>The runtime environment for the Lambda function.</p>
    pub runtime: std::option::Option<std::string::String>,
    /// <p>The amount of time that Lambda allows a function to run before stopping it.</p>
    pub timeout: i32,
    /// <p>The function's X-Ray tracing configuration.</p>
    pub tracing_config: std::option::Option<crate::model::AwsLambdaFunctionTracingConfig>,
    /// <p>The function's networking configuration.</p>
    pub vpc_config: std::option::Option<crate::model::AwsLambdaFunctionVpcConfig>,
    /// <p>The version of the Lambda function.</p>
    pub version: std::option::Option<std::string::String>,
}
impl AwsLambdaFunctionDetails {
    /// <p>An <code>AwsLambdaFunctionCode</code> object.</p>
    pub fn code(&self) -> std::option::Option<&crate::model::AwsLambdaFunctionCode> {
        self.code.as_ref()
    }
    /// <p>The SHA256 hash of the function's deployment package.</p>
    pub fn code_sha256(&self) -> std::option::Option<&str> {
        self.code_sha256.as_deref()
    }
    /// <p>The function's dead letter queue.</p>
    pub fn dead_letter_config(
        &self,
    ) -> std::option::Option<&crate::model::AwsLambdaFunctionDeadLetterConfig> {
        self.dead_letter_config.as_ref()
    }
    /// <p>The function's environment variables.</p>
    pub fn environment(&self) -> std::option::Option<&crate::model::AwsLambdaFunctionEnvironment> {
        self.environment.as_ref()
    }
    /// <p>The name of the function.</p>
    pub fn function_name(&self) -> std::option::Option<&str> {
        self.function_name.as_deref()
    }
    /// <p>The function that Lambda calls to begin executing your function.</p>
    pub fn handler(&self) -> std::option::Option<&str> {
        self.handler.as_deref()
    }
    /// <p>The KMS key that is used to encrypt the function's environment variables. This key is only returned if you've configured a customer managed customer managed key.</p>
    pub fn kms_key_arn(&self) -> std::option::Option<&str> {
        self.kms_key_arn.as_deref()
    }
    /// <p>Indicates when the function was last updated.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn last_modified(&self) -> std::option::Option<&str> {
        self.last_modified.as_deref()
    }
    /// <p>The function's layers.</p>
    pub fn layers(&self) -> std::option::Option<&[crate::model::AwsLambdaFunctionLayer]> {
        self.layers.as_deref()
    }
    /// <p>For Lambda@Edge functions, the ARN of the master function.</p>
    pub fn master_arn(&self) -> std::option::Option<&str> {
        self.master_arn.as_deref()
    }
    /// <p>The memory that is allocated to the function.</p>
    pub fn memory_size(&self) -> i32 {
        self.memory_size
    }
    /// <p>The latest updated revision of the function or alias.</p>
    pub fn revision_id(&self) -> std::option::Option<&str> {
        self.revision_id.as_deref()
    }
    /// <p>The function's execution role.</p>
    pub fn role(&self) -> std::option::Option<&str> {
        self.role.as_deref()
    }
    /// <p>The runtime environment for the Lambda function.</p>
    pub fn runtime(&self) -> std::option::Option<&str> {
        self.runtime.as_deref()
    }
    /// <p>The amount of time that Lambda allows a function to run before stopping it.</p>
    pub fn timeout(&self) -> i32 {
        self.timeout
    }
    /// <p>The function's X-Ray tracing configuration.</p>
    pub fn tracing_config(
        &self,
    ) -> std::option::Option<&crate::model::AwsLambdaFunctionTracingConfig> {
        self.tracing_config.as_ref()
    }
    /// <p>The function's networking configuration.</p>
    pub fn vpc_config(&self) -> std::option::Option<&crate::model::AwsLambdaFunctionVpcConfig> {
        self.vpc_config.as_ref()
    }
    /// <p>The version of the Lambda function.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
}
impl std::fmt::Debug for AwsLambdaFunctionDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsLambdaFunctionDetails");
        formatter.field("code", &self.code);
        formatter.field("code_sha256", &self.code_sha256);
        formatter.field("dead_letter_config", &self.dead_letter_config);
        formatter.field("environment", &self.environment);
        formatter.field("function_name", &self.function_name);
        formatter.field("handler", &self.handler);
        formatter.field("kms_key_arn", &self.kms_key_arn);
        formatter.field("last_modified", &self.last_modified);
        formatter.field("layers", &self.layers);
        formatter.field("master_arn", &self.master_arn);
        formatter.field("memory_size", &self.memory_size);
        formatter.field("revision_id", &self.revision_id);
        formatter.field("role", &self.role);
        formatter.field("runtime", &self.runtime);
        formatter.field("timeout", &self.timeout);
        formatter.field("tracing_config", &self.tracing_config);
        formatter.field("vpc_config", &self.vpc_config);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`AwsLambdaFunctionDetails`](crate::model::AwsLambdaFunctionDetails)
pub mod aws_lambda_function_details {

    /// A builder for [`AwsLambdaFunctionDetails`](crate::model::AwsLambdaFunctionDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::AwsLambdaFunctionCode>,
        pub(crate) code_sha256: std::option::Option<std::string::String>,
        pub(crate) dead_letter_config:
            std::option::Option<crate::model::AwsLambdaFunctionDeadLetterConfig>,
        pub(crate) environment: std::option::Option<crate::model::AwsLambdaFunctionEnvironment>,
        pub(crate) function_name: std::option::Option<std::string::String>,
        pub(crate) handler: std::option::Option<std::string::String>,
        pub(crate) kms_key_arn: std::option::Option<std::string::String>,
        pub(crate) last_modified: std::option::Option<std::string::String>,
        pub(crate) layers: std::option::Option<std::vec::Vec<crate::model::AwsLambdaFunctionLayer>>,
        pub(crate) master_arn: std::option::Option<std::string::String>,
        pub(crate) memory_size: std::option::Option<i32>,
        pub(crate) revision_id: std::option::Option<std::string::String>,
        pub(crate) role: std::option::Option<std::string::String>,
        pub(crate) runtime: std::option::Option<std::string::String>,
        pub(crate) timeout: std::option::Option<i32>,
        pub(crate) tracing_config:
            std::option::Option<crate::model::AwsLambdaFunctionTracingConfig>,
        pub(crate) vpc_config: std::option::Option<crate::model::AwsLambdaFunctionVpcConfig>,
        pub(crate) version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An <code>AwsLambdaFunctionCode</code> object.</p>
        pub fn code(mut self, input: crate::model::AwsLambdaFunctionCode) -> Self {
            self.code = Some(input);
            self
        }
        /// <p>An <code>AwsLambdaFunctionCode</code> object.</p>
        pub fn set_code(
            mut self,
            input: std::option::Option<crate::model::AwsLambdaFunctionCode>,
        ) -> Self {
            self.code = input;
            self
        }
        /// <p>The SHA256 hash of the function's deployment package.</p>
        pub fn code_sha256(mut self, input: impl Into<std::string::String>) -> Self {
            self.code_sha256 = Some(input.into());
            self
        }
        /// <p>The SHA256 hash of the function's deployment package.</p>
        pub fn set_code_sha256(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code_sha256 = input;
            self
        }
        /// <p>The function's dead letter queue.</p>
        pub fn dead_letter_config(
            mut self,
            input: crate::model::AwsLambdaFunctionDeadLetterConfig,
        ) -> Self {
            self.dead_letter_config = Some(input);
            self
        }
        /// <p>The function's dead letter queue.</p>
        pub fn set_dead_letter_config(
            mut self,
            input: std::option::Option<crate::model::AwsLambdaFunctionDeadLetterConfig>,
        ) -> Self {
            self.dead_letter_config = input;
            self
        }
        /// <p>The function's environment variables.</p>
        pub fn environment(mut self, input: crate::model::AwsLambdaFunctionEnvironment) -> Self {
            self.environment = Some(input);
            self
        }
        /// <p>The function's environment variables.</p>
        pub fn set_environment(
            mut self,
            input: std::option::Option<crate::model::AwsLambdaFunctionEnvironment>,
        ) -> Self {
            self.environment = input;
            self
        }
        /// <p>The name of the function.</p>
        pub fn function_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.function_name = Some(input.into());
            self
        }
        /// <p>The name of the function.</p>
        pub fn set_function_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.function_name = input;
            self
        }
        /// <p>The function that Lambda calls to begin executing your function.</p>
        pub fn handler(mut self, input: impl Into<std::string::String>) -> Self {
            self.handler = Some(input.into());
            self
        }
        /// <p>The function that Lambda calls to begin executing your function.</p>
        pub fn set_handler(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.handler = input;
            self
        }
        /// <p>The KMS key that is used to encrypt the function's environment variables. This key is only returned if you've configured a customer managed customer managed key.</p>
        pub fn kms_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_arn = Some(input.into());
            self
        }
        /// <p>The KMS key that is used to encrypt the function's environment variables. This key is only returned if you've configured a customer managed customer managed key.</p>
        pub fn set_kms_key_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_arn = input;
            self
        }
        /// <p>Indicates when the function was last updated.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn last_modified(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified = Some(input.into());
            self
        }
        /// <p>Indicates when the function was last updated.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_last_modified(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified = input;
            self
        }
        /// Appends an item to `layers`.
        ///
        /// To override the contents of this collection use [`set_layers`](Self::set_layers).
        ///
        /// <p>The function's layers.</p>
        pub fn layers(mut self, input: crate::model::AwsLambdaFunctionLayer) -> Self {
            let mut v = self.layers.unwrap_or_default();
            v.push(input);
            self.layers = Some(v);
            self
        }
        /// <p>The function's layers.</p>
        pub fn set_layers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsLambdaFunctionLayer>>,
        ) -> Self {
            self.layers = input;
            self
        }
        /// <p>For Lambda@Edge functions, the ARN of the master function.</p>
        pub fn master_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_arn = Some(input.into());
            self
        }
        /// <p>For Lambda@Edge functions, the ARN of the master function.</p>
        pub fn set_master_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.master_arn = input;
            self
        }
        /// <p>The memory that is allocated to the function.</p>
        pub fn memory_size(mut self, input: i32) -> Self {
            self.memory_size = Some(input);
            self
        }
        /// <p>The memory that is allocated to the function.</p>
        pub fn set_memory_size(mut self, input: std::option::Option<i32>) -> Self {
            self.memory_size = input;
            self
        }
        /// <p>The latest updated revision of the function or alias.</p>
        pub fn revision_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.revision_id = Some(input.into());
            self
        }
        /// <p>The latest updated revision of the function or alias.</p>
        pub fn set_revision_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.revision_id = input;
            self
        }
        /// <p>The function's execution role.</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.role = Some(input.into());
            self
        }
        /// <p>The function's execution role.</p>
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role = input;
            self
        }
        /// <p>The runtime environment for the Lambda function.</p>
        pub fn runtime(mut self, input: impl Into<std::string::String>) -> Self {
            self.runtime = Some(input.into());
            self
        }
        /// <p>The runtime environment for the Lambda function.</p>
        pub fn set_runtime(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.runtime = input;
            self
        }
        /// <p>The amount of time that Lambda allows a function to run before stopping it.</p>
        pub fn timeout(mut self, input: i32) -> Self {
            self.timeout = Some(input);
            self
        }
        /// <p>The amount of time that Lambda allows a function to run before stopping it.</p>
        pub fn set_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.timeout = input;
            self
        }
        /// <p>The function's X-Ray tracing configuration.</p>
        pub fn tracing_config(
            mut self,
            input: crate::model::AwsLambdaFunctionTracingConfig,
        ) -> Self {
            self.tracing_config = Some(input);
            self
        }
        /// <p>The function's X-Ray tracing configuration.</p>
        pub fn set_tracing_config(
            mut self,
            input: std::option::Option<crate::model::AwsLambdaFunctionTracingConfig>,
        ) -> Self {
            self.tracing_config = input;
            self
        }
        /// <p>The function's networking configuration.</p>
        pub fn vpc_config(mut self, input: crate::model::AwsLambdaFunctionVpcConfig) -> Self {
            self.vpc_config = Some(input);
            self
        }
        /// <p>The function's networking configuration.</p>
        pub fn set_vpc_config(
            mut self,
            input: std::option::Option<crate::model::AwsLambdaFunctionVpcConfig>,
        ) -> Self {
            self.vpc_config = input;
            self
        }
        /// <p>The version of the Lambda function.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The version of the Lambda function.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsLambdaFunctionDetails`](crate::model::AwsLambdaFunctionDetails)
        pub fn build(self) -> crate::model::AwsLambdaFunctionDetails {
            crate::model::AwsLambdaFunctionDetails {
                code: self.code,
                code_sha256: self.code_sha256,
                dead_letter_config: self.dead_letter_config,
                environment: self.environment,
                function_name: self.function_name,
                handler: self.handler,
                kms_key_arn: self.kms_key_arn,
                last_modified: self.last_modified,
                layers: self.layers,
                master_arn: self.master_arn,
                memory_size: self.memory_size.unwrap_or_default(),
                revision_id: self.revision_id,
                role: self.role,
                runtime: self.runtime,
                timeout: self.timeout.unwrap_or_default(),
                tracing_config: self.tracing_config,
                vpc_config: self.vpc_config,
                version: self.version,
            }
        }
    }
}
impl AwsLambdaFunctionDetails {
    /// Creates a new builder-style object to manufacture [`AwsLambdaFunctionDetails`](crate::model::AwsLambdaFunctionDetails)
    pub fn builder() -> crate::model::aws_lambda_function_details::Builder {
        crate::model::aws_lambda_function_details::Builder::default()
    }
}

/// <p>The VPC security groups and subnets that are attached to a Lambda function.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsLambdaFunctionVpcConfig {
    /// <p>A list of VPC security groups IDs.</p>
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of VPC subnet IDs.</p>
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the VPC.</p>
    pub vpc_id: std::option::Option<std::string::String>,
}
impl AwsLambdaFunctionVpcConfig {
    /// <p>A list of VPC security groups IDs.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
    /// <p>A list of VPC subnet IDs.</p>
    pub fn subnet_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_ids.as_deref()
    }
    /// <p>The ID of the VPC.</p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
}
impl std::fmt::Debug for AwsLambdaFunctionVpcConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsLambdaFunctionVpcConfig");
        formatter.field("security_group_ids", &self.security_group_ids);
        formatter.field("subnet_ids", &self.subnet_ids);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.finish()
    }
}
/// See [`AwsLambdaFunctionVpcConfig`](crate::model::AwsLambdaFunctionVpcConfig)
pub mod aws_lambda_function_vpc_config {

    /// A builder for [`AwsLambdaFunctionVpcConfig`](crate::model::AwsLambdaFunctionVpcConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
        ///
        /// <p>A list of VPC security groups IDs.</p>
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        /// <p>A list of VPC security groups IDs.</p>
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// Appends an item to `subnet_ids`.
        ///
        /// To override the contents of this collection use [`set_subnet_ids`](Self::set_subnet_ids).
        ///
        /// <p>A list of VPC subnet IDs.</p>
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        /// <p>A list of VPC subnet IDs.</p>
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsLambdaFunctionVpcConfig`](crate::model::AwsLambdaFunctionVpcConfig)
        pub fn build(self) -> crate::model::AwsLambdaFunctionVpcConfig {
            crate::model::AwsLambdaFunctionVpcConfig {
                security_group_ids: self.security_group_ids,
                subnet_ids: self.subnet_ids,
                vpc_id: self.vpc_id,
            }
        }
    }
}
impl AwsLambdaFunctionVpcConfig {
    /// Creates a new builder-style object to manufacture [`AwsLambdaFunctionVpcConfig`](crate::model::AwsLambdaFunctionVpcConfig)
    pub fn builder() -> crate::model::aws_lambda_function_vpc_config::Builder {
        crate::model::aws_lambda_function_vpc_config::Builder::default()
    }
}

/// <p>The function's X-Ray tracing configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsLambdaFunctionTracingConfig {
    /// <p>The tracing mode.</p>
    pub mode: std::option::Option<std::string::String>,
}
impl AwsLambdaFunctionTracingConfig {
    /// <p>The tracing mode.</p>
    pub fn mode(&self) -> std::option::Option<&str> {
        self.mode.as_deref()
    }
}
impl std::fmt::Debug for AwsLambdaFunctionTracingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsLambdaFunctionTracingConfig");
        formatter.field("mode", &self.mode);
        formatter.finish()
    }
}
/// See [`AwsLambdaFunctionTracingConfig`](crate::model::AwsLambdaFunctionTracingConfig)
pub mod aws_lambda_function_tracing_config {

    /// A builder for [`AwsLambdaFunctionTracingConfig`](crate::model::AwsLambdaFunctionTracingConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mode: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The tracing mode.</p>
        pub fn mode(mut self, input: impl Into<std::string::String>) -> Self {
            self.mode = Some(input.into());
            self
        }
        /// <p>The tracing mode.</p>
        pub fn set_mode(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mode = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsLambdaFunctionTracingConfig`](crate::model::AwsLambdaFunctionTracingConfig)
        pub fn build(self) -> crate::model::AwsLambdaFunctionTracingConfig {
            crate::model::AwsLambdaFunctionTracingConfig { mode: self.mode }
        }
    }
}
impl AwsLambdaFunctionTracingConfig {
    /// Creates a new builder-style object to manufacture [`AwsLambdaFunctionTracingConfig`](crate::model::AwsLambdaFunctionTracingConfig)
    pub fn builder() -> crate::model::aws_lambda_function_tracing_config::Builder {
        crate::model::aws_lambda_function_tracing_config::Builder::default()
    }
}

/// <p>An Lambda layer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsLambdaFunctionLayer {
    /// <p>The ARN of the function layer.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The size of the layer archive in bytes.</p>
    pub code_size: i32,
}
impl AwsLambdaFunctionLayer {
    /// <p>The ARN of the function layer.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The size of the layer archive in bytes.</p>
    pub fn code_size(&self) -> i32 {
        self.code_size
    }
}
impl std::fmt::Debug for AwsLambdaFunctionLayer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsLambdaFunctionLayer");
        formatter.field("arn", &self.arn);
        formatter.field("code_size", &self.code_size);
        formatter.finish()
    }
}
/// See [`AwsLambdaFunctionLayer`](crate::model::AwsLambdaFunctionLayer)
pub mod aws_lambda_function_layer {

    /// A builder for [`AwsLambdaFunctionLayer`](crate::model::AwsLambdaFunctionLayer)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) code_size: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ARN of the function layer.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the function layer.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The size of the layer archive in bytes.</p>
        pub fn code_size(mut self, input: i32) -> Self {
            self.code_size = Some(input);
            self
        }
        /// <p>The size of the layer archive in bytes.</p>
        pub fn set_code_size(mut self, input: std::option::Option<i32>) -> Self {
            self.code_size = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsLambdaFunctionLayer`](crate::model::AwsLambdaFunctionLayer)
        pub fn build(self) -> crate::model::AwsLambdaFunctionLayer {
            crate::model::AwsLambdaFunctionLayer {
                arn: self.arn,
                code_size: self.code_size.unwrap_or_default(),
            }
        }
    }
}
impl AwsLambdaFunctionLayer {
    /// Creates a new builder-style object to manufacture [`AwsLambdaFunctionLayer`](crate::model::AwsLambdaFunctionLayer)
    pub fn builder() -> crate::model::aws_lambda_function_layer::Builder {
        crate::model::aws_lambda_function_layer::Builder::default()
    }
}

/// <p>A function's environment variable settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsLambdaFunctionEnvironment {
    /// <p>Environment variable key-value pairs.</p>
    pub variables:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>An <code>AwsLambdaFunctionEnvironmentError</code> object.</p>
    pub error: std::option::Option<crate::model::AwsLambdaFunctionEnvironmentError>,
}
impl AwsLambdaFunctionEnvironment {
    /// <p>Environment variable key-value pairs.</p>
    pub fn variables(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.variables.as_ref()
    }
    /// <p>An <code>AwsLambdaFunctionEnvironmentError</code> object.</p>
    pub fn error(&self) -> std::option::Option<&crate::model::AwsLambdaFunctionEnvironmentError> {
        self.error.as_ref()
    }
}
impl std::fmt::Debug for AwsLambdaFunctionEnvironment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsLambdaFunctionEnvironment");
        formatter.field("variables", &self.variables);
        formatter.field("error", &self.error);
        formatter.finish()
    }
}
/// See [`AwsLambdaFunctionEnvironment`](crate::model::AwsLambdaFunctionEnvironment)
pub mod aws_lambda_function_environment {

    /// A builder for [`AwsLambdaFunctionEnvironment`](crate::model::AwsLambdaFunctionEnvironment)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) variables: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) error: std::option::Option<crate::model::AwsLambdaFunctionEnvironmentError>,
    }
    impl Builder {
        /// Adds a key-value pair to `variables`.
        ///
        /// To override the contents of this collection use [`set_variables`](Self::set_variables).
        ///
        /// <p>Environment variable key-value pairs.</p>
        pub fn variables(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.variables.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.variables = Some(hash_map);
            self
        }
        /// <p>Environment variable key-value pairs.</p>
        pub fn set_variables(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.variables = input;
            self
        }
        /// <p>An <code>AwsLambdaFunctionEnvironmentError</code> object.</p>
        pub fn error(mut self, input: crate::model::AwsLambdaFunctionEnvironmentError) -> Self {
            self.error = Some(input);
            self
        }
        /// <p>An <code>AwsLambdaFunctionEnvironmentError</code> object.</p>
        pub fn set_error(
            mut self,
            input: std::option::Option<crate::model::AwsLambdaFunctionEnvironmentError>,
        ) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsLambdaFunctionEnvironment`](crate::model::AwsLambdaFunctionEnvironment)
        pub fn build(self) -> crate::model::AwsLambdaFunctionEnvironment {
            crate::model::AwsLambdaFunctionEnvironment {
                variables: self.variables,
                error: self.error,
            }
        }
    }
}
impl AwsLambdaFunctionEnvironment {
    /// Creates a new builder-style object to manufacture [`AwsLambdaFunctionEnvironment`](crate::model::AwsLambdaFunctionEnvironment)
    pub fn builder() -> crate::model::aws_lambda_function_environment::Builder {
        crate::model::aws_lambda_function_environment::Builder::default()
    }
}

/// <p>Error messages for environment variables that could not be applied.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsLambdaFunctionEnvironmentError {
    /// <p>The error code.</p>
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl AwsLambdaFunctionEnvironmentError {
    /// <p>The error code.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>The error message.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Debug for AwsLambdaFunctionEnvironmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsLambdaFunctionEnvironmentError");
        formatter.field("error_code", &self.error_code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`AwsLambdaFunctionEnvironmentError`](crate::model::AwsLambdaFunctionEnvironmentError)
pub mod aws_lambda_function_environment_error {

    /// A builder for [`AwsLambdaFunctionEnvironmentError`](crate::model::AwsLambdaFunctionEnvironmentError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error code.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The error code.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsLambdaFunctionEnvironmentError`](crate::model::AwsLambdaFunctionEnvironmentError)
        pub fn build(self) -> crate::model::AwsLambdaFunctionEnvironmentError {
            crate::model::AwsLambdaFunctionEnvironmentError {
                error_code: self.error_code,
                message: self.message,
            }
        }
    }
}
impl AwsLambdaFunctionEnvironmentError {
    /// Creates a new builder-style object to manufacture [`AwsLambdaFunctionEnvironmentError`](crate::model::AwsLambdaFunctionEnvironmentError)
    pub fn builder() -> crate::model::aws_lambda_function_environment_error::Builder {
        crate::model::aws_lambda_function_environment_error::Builder::default()
    }
}

/// <p>The dead-letter queue for failed asynchronous invocations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsLambdaFunctionDeadLetterConfig {
    /// <p>The ARN of an SQS queue or SNS topic.</p>
    pub target_arn: std::option::Option<std::string::String>,
}
impl AwsLambdaFunctionDeadLetterConfig {
    /// <p>The ARN of an SQS queue or SNS topic.</p>
    pub fn target_arn(&self) -> std::option::Option<&str> {
        self.target_arn.as_deref()
    }
}
impl std::fmt::Debug for AwsLambdaFunctionDeadLetterConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsLambdaFunctionDeadLetterConfig");
        formatter.field("target_arn", &self.target_arn);
        formatter.finish()
    }
}
/// See [`AwsLambdaFunctionDeadLetterConfig`](crate::model::AwsLambdaFunctionDeadLetterConfig)
pub mod aws_lambda_function_dead_letter_config {

    /// A builder for [`AwsLambdaFunctionDeadLetterConfig`](crate::model::AwsLambdaFunctionDeadLetterConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of an SQS queue or SNS topic.</p>
        pub fn target_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_arn = Some(input.into());
            self
        }
        /// <p>The ARN of an SQS queue or SNS topic.</p>
        pub fn set_target_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsLambdaFunctionDeadLetterConfig`](crate::model::AwsLambdaFunctionDeadLetterConfig)
        pub fn build(self) -> crate::model::AwsLambdaFunctionDeadLetterConfig {
            crate::model::AwsLambdaFunctionDeadLetterConfig {
                target_arn: self.target_arn,
            }
        }
    }
}
impl AwsLambdaFunctionDeadLetterConfig {
    /// Creates a new builder-style object to manufacture [`AwsLambdaFunctionDeadLetterConfig`](crate::model::AwsLambdaFunctionDeadLetterConfig)
    pub fn builder() -> crate::model::aws_lambda_function_dead_letter_config::Builder {
        crate::model::aws_lambda_function_dead_letter_config::Builder::default()
    }
}

/// <p>The code for the Lambda function. You can specify either an object in Amazon S3, or upload a deployment package directly.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsLambdaFunctionCode {
    /// <p>An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.</p>
    pub s3_bucket: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 key of the deployment package.</p>
    pub s3_key: std::option::Option<std::string::String>,
    /// <p>For versioned objects, the version of the deployment package object to use.</p>
    pub s3_object_version: std::option::Option<std::string::String>,
    /// <p>The base64-encoded contents of the deployment package. Amazon Web Services SDK and Amazon Web Services CLI clients handle the encoding for you.</p>
    pub zip_file: std::option::Option<std::string::String>,
}
impl AwsLambdaFunctionCode {
    /// <p>An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.</p>
    pub fn s3_bucket(&self) -> std::option::Option<&str> {
        self.s3_bucket.as_deref()
    }
    /// <p>The Amazon S3 key of the deployment package.</p>
    pub fn s3_key(&self) -> std::option::Option<&str> {
        self.s3_key.as_deref()
    }
    /// <p>For versioned objects, the version of the deployment package object to use.</p>
    pub fn s3_object_version(&self) -> std::option::Option<&str> {
        self.s3_object_version.as_deref()
    }
    /// <p>The base64-encoded contents of the deployment package. Amazon Web Services SDK and Amazon Web Services CLI clients handle the encoding for you.</p>
    pub fn zip_file(&self) -> std::option::Option<&str> {
        self.zip_file.as_deref()
    }
}
impl std::fmt::Debug for AwsLambdaFunctionCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsLambdaFunctionCode");
        formatter.field("s3_bucket", &self.s3_bucket);
        formatter.field("s3_key", &self.s3_key);
        formatter.field("s3_object_version", &self.s3_object_version);
        formatter.field("zip_file", &self.zip_file);
        formatter.finish()
    }
}
/// See [`AwsLambdaFunctionCode`](crate::model::AwsLambdaFunctionCode)
pub mod aws_lambda_function_code {

    /// A builder for [`AwsLambdaFunctionCode`](crate::model::AwsLambdaFunctionCode)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_bucket: std::option::Option<std::string::String>,
        pub(crate) s3_key: std::option::Option<std::string::String>,
        pub(crate) s3_object_version: std::option::Option<std::string::String>,
        pub(crate) zip_file: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.</p>
        pub fn s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket = Some(input.into());
            self
        }
        /// <p>An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.</p>
        pub fn set_s3_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_bucket = input;
            self
        }
        /// <p>The Amazon S3 key of the deployment package.</p>
        pub fn s3_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_key = Some(input.into());
            self
        }
        /// <p>The Amazon S3 key of the deployment package.</p>
        pub fn set_s3_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_key = input;
            self
        }
        /// <p>For versioned objects, the version of the deployment package object to use.</p>
        pub fn s3_object_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_object_version = Some(input.into());
            self
        }
        /// <p>For versioned objects, the version of the deployment package object to use.</p>
        pub fn set_s3_object_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_object_version = input;
            self
        }
        /// <p>The base64-encoded contents of the deployment package. Amazon Web Services SDK and Amazon Web Services CLI clients handle the encoding for you.</p>
        pub fn zip_file(mut self, input: impl Into<std::string::String>) -> Self {
            self.zip_file = Some(input.into());
            self
        }
        /// <p>The base64-encoded contents of the deployment package. Amazon Web Services SDK and Amazon Web Services CLI clients handle the encoding for you.</p>
        pub fn set_zip_file(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.zip_file = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsLambdaFunctionCode`](crate::model::AwsLambdaFunctionCode)
        pub fn build(self) -> crate::model::AwsLambdaFunctionCode {
            crate::model::AwsLambdaFunctionCode {
                s3_bucket: self.s3_bucket,
                s3_key: self.s3_key,
                s3_object_version: self.s3_object_version,
                zip_file: self.zip_file,
            }
        }
    }
}
impl AwsLambdaFunctionCode {
    /// Creates a new builder-style object to manufacture [`AwsLambdaFunctionCode`](crate::model::AwsLambdaFunctionCode)
    pub fn builder() -> crate::model::aws_lambda_function_code::Builder {
        crate::model::aws_lambda_function_code::Builder::default()
    }
}

/// <p>Contains metadata about an KMS key.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsKmsKeyDetails {
    /// <p>The twelve-digit account ID of the Amazon Web Services account that owns the KMS key.</p>
    pub aws_account_id: std::option::Option<std::string::String>,
    /// <p>Indicates when the KMS key was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub creation_date: f64,
    /// <p>The globally unique identifier for the KMS key.</p>
    pub key_id: std::option::Option<std::string::String>,
    /// <p>The manager of the KMS key. KMS keys in your Amazon Web Services account are either customer managed or Amazon Web Services managed.</p>
    pub key_manager: std::option::Option<std::string::String>,
    /// <p>The state of the KMS key.</p>
    pub key_state: std::option::Option<std::string::String>,
    /// <p>The source of the KMS key material.</p>
    /// <p>When this value is <code>AWS_KMS</code>, KMS created the key material.</p>
    /// <p>When this value is <code>EXTERNAL</code>, the key material was imported from your existing key management infrastructure or the KMS key lacks key material.</p>
    /// <p>When this value is <code>AWS_CLOUDHSM</code>, the key material was created in the CloudHSM cluster associated with a custom key store.</p>
    pub origin: std::option::Option<std::string::String>,
    /// <p>A description of the KMS key.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Whether the key has key rotation enabled.</p>
    pub key_rotation_status: bool,
}
impl AwsKmsKeyDetails {
    /// <p>The twelve-digit account ID of the Amazon Web Services account that owns the KMS key.</p>
    pub fn aws_account_id(&self) -> std::option::Option<&str> {
        self.aws_account_id.as_deref()
    }
    /// <p>Indicates when the KMS key was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn creation_date(&self) -> f64 {
        self.creation_date
    }
    /// <p>The globally unique identifier for the KMS key.</p>
    pub fn key_id(&self) -> std::option::Option<&str> {
        self.key_id.as_deref()
    }
    /// <p>The manager of the KMS key. KMS keys in your Amazon Web Services account are either customer managed or Amazon Web Services managed.</p>
    pub fn key_manager(&self) -> std::option::Option<&str> {
        self.key_manager.as_deref()
    }
    /// <p>The state of the KMS key.</p>
    pub fn key_state(&self) -> std::option::Option<&str> {
        self.key_state.as_deref()
    }
    /// <p>The source of the KMS key material.</p>
    /// <p>When this value is <code>AWS_KMS</code>, KMS created the key material.</p>
    /// <p>When this value is <code>EXTERNAL</code>, the key material was imported from your existing key management infrastructure or the KMS key lacks key material.</p>
    /// <p>When this value is <code>AWS_CLOUDHSM</code>, the key material was created in the CloudHSM cluster associated with a custom key store.</p>
    pub fn origin(&self) -> std::option::Option<&str> {
        self.origin.as_deref()
    }
    /// <p>A description of the KMS key.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Whether the key has key rotation enabled.</p>
    pub fn key_rotation_status(&self) -> bool {
        self.key_rotation_status
    }
}
impl std::fmt::Debug for AwsKmsKeyDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsKmsKeyDetails");
        formatter.field("aws_account_id", &self.aws_account_id);
        formatter.field("creation_date", &self.creation_date);
        formatter.field("key_id", &self.key_id);
        formatter.field("key_manager", &self.key_manager);
        formatter.field("key_state", &self.key_state);
        formatter.field("origin", &self.origin);
        formatter.field("description", &self.description);
        formatter.field("key_rotation_status", &self.key_rotation_status);
        formatter.finish()
    }
}
/// See [`AwsKmsKeyDetails`](crate::model::AwsKmsKeyDetails)
pub mod aws_kms_key_details {

    /// A builder for [`AwsKmsKeyDetails`](crate::model::AwsKmsKeyDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) aws_account_id: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<f64>,
        pub(crate) key_id: std::option::Option<std::string::String>,
        pub(crate) key_manager: std::option::Option<std::string::String>,
        pub(crate) key_state: std::option::Option<std::string::String>,
        pub(crate) origin: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) key_rotation_status: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The twelve-digit account ID of the Amazon Web Services account that owns the KMS key.</p>
        pub fn aws_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_account_id = Some(input.into());
            self
        }
        /// <p>The twelve-digit account ID of the Amazon Web Services account that owns the KMS key.</p>
        pub fn set_aws_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.aws_account_id = input;
            self
        }
        /// <p>Indicates when the KMS key was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn creation_date(mut self, input: f64) -> Self {
            self.creation_date = Some(input);
            self
        }
        /// <p>Indicates when the KMS key was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_creation_date(mut self, input: std::option::Option<f64>) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The globally unique identifier for the KMS key.</p>
        pub fn key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_id = Some(input.into());
            self
        }
        /// <p>The globally unique identifier for the KMS key.</p>
        pub fn set_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_id = input;
            self
        }
        /// <p>The manager of the KMS key. KMS keys in your Amazon Web Services account are either customer managed or Amazon Web Services managed.</p>
        pub fn key_manager(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_manager = Some(input.into());
            self
        }
        /// <p>The manager of the KMS key. KMS keys in your Amazon Web Services account are either customer managed or Amazon Web Services managed.</p>
        pub fn set_key_manager(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_manager = input;
            self
        }
        /// <p>The state of the KMS key.</p>
        pub fn key_state(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_state = Some(input.into());
            self
        }
        /// <p>The state of the KMS key.</p>
        pub fn set_key_state(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_state = input;
            self
        }
        /// <p>The source of the KMS key material.</p>
        /// <p>When this value is <code>AWS_KMS</code>, KMS created the key material.</p>
        /// <p>When this value is <code>EXTERNAL</code>, the key material was imported from your existing key management infrastructure or the KMS key lacks key material.</p>
        /// <p>When this value is <code>AWS_CLOUDHSM</code>, the key material was created in the CloudHSM cluster associated with a custom key store.</p>
        pub fn origin(mut self, input: impl Into<std::string::String>) -> Self {
            self.origin = Some(input.into());
            self
        }
        /// <p>The source of the KMS key material.</p>
        /// <p>When this value is <code>AWS_KMS</code>, KMS created the key material.</p>
        /// <p>When this value is <code>EXTERNAL</code>, the key material was imported from your existing key management infrastructure or the KMS key lacks key material.</p>
        /// <p>When this value is <code>AWS_CLOUDHSM</code>, the key material was created in the CloudHSM cluster associated with a custom key store.</p>
        pub fn set_origin(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.origin = input;
            self
        }
        /// <p>A description of the KMS key.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the KMS key.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Whether the key has key rotation enabled.</p>
        pub fn key_rotation_status(mut self, input: bool) -> Self {
            self.key_rotation_status = Some(input);
            self
        }
        /// <p>Whether the key has key rotation enabled.</p>
        pub fn set_key_rotation_status(mut self, input: std::option::Option<bool>) -> Self {
            self.key_rotation_status = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsKmsKeyDetails`](crate::model::AwsKmsKeyDetails)
        pub fn build(self) -> crate::model::AwsKmsKeyDetails {
            crate::model::AwsKmsKeyDetails {
                aws_account_id: self.aws_account_id,
                creation_date: self.creation_date.unwrap_or_default(),
                key_id: self.key_id,
                key_manager: self.key_manager,
                key_state: self.key_state,
                origin: self.origin,
                description: self.description,
                key_rotation_status: self.key_rotation_status.unwrap_or_default(),
            }
        }
    }
}
impl AwsKmsKeyDetails {
    /// Creates a new builder-style object to manufacture [`AwsKmsKeyDetails`](crate::model::AwsKmsKeyDetails)
    pub fn builder() -> crate::model::aws_kms_key_details::Builder {
        crate::model::aws_kms_key_details::Builder::default()
    }
}

/// <p>Contains information about an IAM role, including all of the role's policies.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsIamRoleDetails {
    /// <p>The trust policy that grants permission to assume the role.</p>
    pub assume_role_policy_document: std::option::Option<std::string::String>,
    /// <p>The list of the managed policies that are attached to the role.</p>
    pub attached_managed_policies:
        std::option::Option<std::vec::Vec<crate::model::AwsIamAttachedManagedPolicy>>,
    /// <p>Indicates when the role was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub create_date: std::option::Option<std::string::String>,
    /// <p>The list of instance profiles that contain this role.</p>
    pub instance_profile_list:
        std::option::Option<std::vec::Vec<crate::model::AwsIamInstanceProfile>>,
    /// <p>Information about the policy used to set the permissions boundary for an IAM principal.</p>
    pub permissions_boundary: std::option::Option<crate::model::AwsIamPermissionsBoundary>,
    /// <p>The stable and unique string identifying the role.</p>
    pub role_id: std::option::Option<std::string::String>,
    /// <p>The friendly name that identifies the role.</p>
    pub role_name: std::option::Option<std::string::String>,
    /// <p>The list of inline policies that are embedded in the role.</p>
    pub role_policy_list: std::option::Option<std::vec::Vec<crate::model::AwsIamRolePolicy>>,
    /// <p>The maximum session duration (in seconds) that you want to set for the specified role.</p>
    pub max_session_duration: i32,
    /// <p>The path to the role.</p>
    pub path: std::option::Option<std::string::String>,
}
impl AwsIamRoleDetails {
    /// <p>The trust policy that grants permission to assume the role.</p>
    pub fn assume_role_policy_document(&self) -> std::option::Option<&str> {
        self.assume_role_policy_document.as_deref()
    }
    /// <p>The list of the managed policies that are attached to the role.</p>
    pub fn attached_managed_policies(
        &self,
    ) -> std::option::Option<&[crate::model::AwsIamAttachedManagedPolicy]> {
        self.attached_managed_policies.as_deref()
    }
    /// <p>Indicates when the role was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn create_date(&self) -> std::option::Option<&str> {
        self.create_date.as_deref()
    }
    /// <p>The list of instance profiles that contain this role.</p>
    pub fn instance_profile_list(
        &self,
    ) -> std::option::Option<&[crate::model::AwsIamInstanceProfile]> {
        self.instance_profile_list.as_deref()
    }
    /// <p>Information about the policy used to set the permissions boundary for an IAM principal.</p>
    pub fn permissions_boundary(
        &self,
    ) -> std::option::Option<&crate::model::AwsIamPermissionsBoundary> {
        self.permissions_boundary.as_ref()
    }
    /// <p>The stable and unique string identifying the role.</p>
    pub fn role_id(&self) -> std::option::Option<&str> {
        self.role_id.as_deref()
    }
    /// <p>The friendly name that identifies the role.</p>
    pub fn role_name(&self) -> std::option::Option<&str> {
        self.role_name.as_deref()
    }
    /// <p>The list of inline policies that are embedded in the role.</p>
    pub fn role_policy_list(&self) -> std::option::Option<&[crate::model::AwsIamRolePolicy]> {
        self.role_policy_list.as_deref()
    }
    /// <p>The maximum session duration (in seconds) that you want to set for the specified role.</p>
    pub fn max_session_duration(&self) -> i32 {
        self.max_session_duration
    }
    /// <p>The path to the role.</p>
    pub fn path(&self) -> std::option::Option<&str> {
        self.path.as_deref()
    }
}
impl std::fmt::Debug for AwsIamRoleDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsIamRoleDetails");
        formatter.field(
            "assume_role_policy_document",
            &self.assume_role_policy_document,
        );
        formatter.field("attached_managed_policies", &self.attached_managed_policies);
        formatter.field("create_date", &self.create_date);
        formatter.field("instance_profile_list", &self.instance_profile_list);
        formatter.field("permissions_boundary", &self.permissions_boundary);
        formatter.field("role_id", &self.role_id);
        formatter.field("role_name", &self.role_name);
        formatter.field("role_policy_list", &self.role_policy_list);
        formatter.field("max_session_duration", &self.max_session_duration);
        formatter.field("path", &self.path);
        formatter.finish()
    }
}
/// See [`AwsIamRoleDetails`](crate::model::AwsIamRoleDetails)
pub mod aws_iam_role_details {

    /// A builder for [`AwsIamRoleDetails`](crate::model::AwsIamRoleDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assume_role_policy_document: std::option::Option<std::string::String>,
        pub(crate) attached_managed_policies:
            std::option::Option<std::vec::Vec<crate::model::AwsIamAttachedManagedPolicy>>,
        pub(crate) create_date: std::option::Option<std::string::String>,
        pub(crate) instance_profile_list:
            std::option::Option<std::vec::Vec<crate::model::AwsIamInstanceProfile>>,
        pub(crate) permissions_boundary:
            std::option::Option<crate::model::AwsIamPermissionsBoundary>,
        pub(crate) role_id: std::option::Option<std::string::String>,
        pub(crate) role_name: std::option::Option<std::string::String>,
        pub(crate) role_policy_list:
            std::option::Option<std::vec::Vec<crate::model::AwsIamRolePolicy>>,
        pub(crate) max_session_duration: std::option::Option<i32>,
        pub(crate) path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The trust policy that grants permission to assume the role.</p>
        pub fn assume_role_policy_document(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.assume_role_policy_document = Some(input.into());
            self
        }
        /// <p>The trust policy that grants permission to assume the role.</p>
        pub fn set_assume_role_policy_document(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assume_role_policy_document = input;
            self
        }
        /// Appends an item to `attached_managed_policies`.
        ///
        /// To override the contents of this collection use [`set_attached_managed_policies`](Self::set_attached_managed_policies).
        ///
        /// <p>The list of the managed policies that are attached to the role.</p>
        pub fn attached_managed_policies(
            mut self,
            input: crate::model::AwsIamAttachedManagedPolicy,
        ) -> Self {
            let mut v = self.attached_managed_policies.unwrap_or_default();
            v.push(input);
            self.attached_managed_policies = Some(v);
            self
        }
        /// <p>The list of the managed policies that are attached to the role.</p>
        pub fn set_attached_managed_policies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsIamAttachedManagedPolicy>>,
        ) -> Self {
            self.attached_managed_policies = input;
            self
        }
        /// <p>Indicates when the role was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn create_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.create_date = Some(input.into());
            self
        }
        /// <p>Indicates when the role was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_create_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.create_date = input;
            self
        }
        /// Appends an item to `instance_profile_list`.
        ///
        /// To override the contents of this collection use [`set_instance_profile_list`](Self::set_instance_profile_list).
        ///
        /// <p>The list of instance profiles that contain this role.</p>
        pub fn instance_profile_list(mut self, input: crate::model::AwsIamInstanceProfile) -> Self {
            let mut v = self.instance_profile_list.unwrap_or_default();
            v.push(input);
            self.instance_profile_list = Some(v);
            self
        }
        /// <p>The list of instance profiles that contain this role.</p>
        pub fn set_instance_profile_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsIamInstanceProfile>>,
        ) -> Self {
            self.instance_profile_list = input;
            self
        }
        /// <p>Information about the policy used to set the permissions boundary for an IAM principal.</p>
        pub fn permissions_boundary(
            mut self,
            input: crate::model::AwsIamPermissionsBoundary,
        ) -> Self {
            self.permissions_boundary = Some(input);
            self
        }
        /// <p>Information about the policy used to set the permissions boundary for an IAM principal.</p>
        pub fn set_permissions_boundary(
            mut self,
            input: std::option::Option<crate::model::AwsIamPermissionsBoundary>,
        ) -> Self {
            self.permissions_boundary = input;
            self
        }
        /// <p>The stable and unique string identifying the role.</p>
        pub fn role_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_id = Some(input.into());
            self
        }
        /// <p>The stable and unique string identifying the role.</p>
        pub fn set_role_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_id = input;
            self
        }
        /// <p>The friendly name that identifies the role.</p>
        pub fn role_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_name = Some(input.into());
            self
        }
        /// <p>The friendly name that identifies the role.</p>
        pub fn set_role_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_name = input;
            self
        }
        /// Appends an item to `role_policy_list`.
        ///
        /// To override the contents of this collection use [`set_role_policy_list`](Self::set_role_policy_list).
        ///
        /// <p>The list of inline policies that are embedded in the role.</p>
        pub fn role_policy_list(mut self, input: crate::model::AwsIamRolePolicy) -> Self {
            let mut v = self.role_policy_list.unwrap_or_default();
            v.push(input);
            self.role_policy_list = Some(v);
            self
        }
        /// <p>The list of inline policies that are embedded in the role.</p>
        pub fn set_role_policy_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsIamRolePolicy>>,
        ) -> Self {
            self.role_policy_list = input;
            self
        }
        /// <p>The maximum session duration (in seconds) that you want to set for the specified role.</p>
        pub fn max_session_duration(mut self, input: i32) -> Self {
            self.max_session_duration = Some(input);
            self
        }
        /// <p>The maximum session duration (in seconds) that you want to set for the specified role.</p>
        pub fn set_max_session_duration(mut self, input: std::option::Option<i32>) -> Self {
            self.max_session_duration = input;
            self
        }
        /// <p>The path to the role.</p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.path = Some(input.into());
            self
        }
        /// <p>The path to the role.</p>
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsIamRoleDetails`](crate::model::AwsIamRoleDetails)
        pub fn build(self) -> crate::model::AwsIamRoleDetails {
            crate::model::AwsIamRoleDetails {
                assume_role_policy_document: self.assume_role_policy_document,
                attached_managed_policies: self.attached_managed_policies,
                create_date: self.create_date,
                instance_profile_list: self.instance_profile_list,
                permissions_boundary: self.permissions_boundary,
                role_id: self.role_id,
                role_name: self.role_name,
                role_policy_list: self.role_policy_list,
                max_session_duration: self.max_session_duration.unwrap_or_default(),
                path: self.path,
            }
        }
    }
}
impl AwsIamRoleDetails {
    /// Creates a new builder-style object to manufacture [`AwsIamRoleDetails`](crate::model::AwsIamRoleDetails)
    pub fn builder() -> crate::model::aws_iam_role_details::Builder {
        crate::model::aws_iam_role_details::Builder::default()
    }
}

/// <p>An inline policy that is embedded in the role.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsIamRolePolicy {
    /// <p>The name of the policy.</p>
    pub policy_name: std::option::Option<std::string::String>,
}
impl AwsIamRolePolicy {
    /// <p>The name of the policy.</p>
    pub fn policy_name(&self) -> std::option::Option<&str> {
        self.policy_name.as_deref()
    }
}
impl std::fmt::Debug for AwsIamRolePolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsIamRolePolicy");
        formatter.field("policy_name", &self.policy_name);
        formatter.finish()
    }
}
/// See [`AwsIamRolePolicy`](crate::model::AwsIamRolePolicy)
pub mod aws_iam_role_policy {

    /// A builder for [`AwsIamRolePolicy`](crate::model::AwsIamRolePolicy)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the policy.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        /// <p>The name of the policy.</p>
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsIamRolePolicy`](crate::model::AwsIamRolePolicy)
        pub fn build(self) -> crate::model::AwsIamRolePolicy {
            crate::model::AwsIamRolePolicy {
                policy_name: self.policy_name,
            }
        }
    }
}
impl AwsIamRolePolicy {
    /// Creates a new builder-style object to manufacture [`AwsIamRolePolicy`](crate::model::AwsIamRolePolicy)
    pub fn builder() -> crate::model::aws_iam_role_policy::Builder {
        crate::model::aws_iam_role_policy::Builder::default()
    }
}

/// <p>Information about the policy used to set the permissions boundary for an IAM principal.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsIamPermissionsBoundary {
    /// <p>The ARN of the policy used to set the permissions boundary.</p>
    pub permissions_boundary_arn: std::option::Option<std::string::String>,
    /// <p>The usage type for the permissions boundary.</p>
    pub permissions_boundary_type: std::option::Option<std::string::String>,
}
impl AwsIamPermissionsBoundary {
    /// <p>The ARN of the policy used to set the permissions boundary.</p>
    pub fn permissions_boundary_arn(&self) -> std::option::Option<&str> {
        self.permissions_boundary_arn.as_deref()
    }
    /// <p>The usage type for the permissions boundary.</p>
    pub fn permissions_boundary_type(&self) -> std::option::Option<&str> {
        self.permissions_boundary_type.as_deref()
    }
}
impl std::fmt::Debug for AwsIamPermissionsBoundary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsIamPermissionsBoundary");
        formatter.field("permissions_boundary_arn", &self.permissions_boundary_arn);
        formatter.field("permissions_boundary_type", &self.permissions_boundary_type);
        formatter.finish()
    }
}
/// See [`AwsIamPermissionsBoundary`](crate::model::AwsIamPermissionsBoundary)
pub mod aws_iam_permissions_boundary {

    /// A builder for [`AwsIamPermissionsBoundary`](crate::model::AwsIamPermissionsBoundary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) permissions_boundary_arn: std::option::Option<std::string::String>,
        pub(crate) permissions_boundary_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the policy used to set the permissions boundary.</p>
        pub fn permissions_boundary_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.permissions_boundary_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the policy used to set the permissions boundary.</p>
        pub fn set_permissions_boundary_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.permissions_boundary_arn = input;
            self
        }
        /// <p>The usage type for the permissions boundary.</p>
        pub fn permissions_boundary_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.permissions_boundary_type = Some(input.into());
            self
        }
        /// <p>The usage type for the permissions boundary.</p>
        pub fn set_permissions_boundary_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.permissions_boundary_type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsIamPermissionsBoundary`](crate::model::AwsIamPermissionsBoundary)
        pub fn build(self) -> crate::model::AwsIamPermissionsBoundary {
            crate::model::AwsIamPermissionsBoundary {
                permissions_boundary_arn: self.permissions_boundary_arn,
                permissions_boundary_type: self.permissions_boundary_type,
            }
        }
    }
}
impl AwsIamPermissionsBoundary {
    /// Creates a new builder-style object to manufacture [`AwsIamPermissionsBoundary`](crate::model::AwsIamPermissionsBoundary)
    pub fn builder() -> crate::model::aws_iam_permissions_boundary::Builder {
        crate::model::aws_iam_permissions_boundary::Builder::default()
    }
}

/// <p>Information about an instance profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsIamInstanceProfile {
    /// <p>The ARN of the instance profile.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>Indicates when the instance profile was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub create_date: std::option::Option<std::string::String>,
    /// <p>The identifier of the instance profile.</p>
    pub instance_profile_id: std::option::Option<std::string::String>,
    /// <p>The name of the instance profile.</p>
    pub instance_profile_name: std::option::Option<std::string::String>,
    /// <p>The path to the instance profile.</p>
    pub path: std::option::Option<std::string::String>,
    /// <p>The roles associated with the instance profile.</p>
    pub roles: std::option::Option<std::vec::Vec<crate::model::AwsIamInstanceProfileRole>>,
}
impl AwsIamInstanceProfile {
    /// <p>The ARN of the instance profile.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>Indicates when the instance profile was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn create_date(&self) -> std::option::Option<&str> {
        self.create_date.as_deref()
    }
    /// <p>The identifier of the instance profile.</p>
    pub fn instance_profile_id(&self) -> std::option::Option<&str> {
        self.instance_profile_id.as_deref()
    }
    /// <p>The name of the instance profile.</p>
    pub fn instance_profile_name(&self) -> std::option::Option<&str> {
        self.instance_profile_name.as_deref()
    }
    /// <p>The path to the instance profile.</p>
    pub fn path(&self) -> std::option::Option<&str> {
        self.path.as_deref()
    }
    /// <p>The roles associated with the instance profile.</p>
    pub fn roles(&self) -> std::option::Option<&[crate::model::AwsIamInstanceProfileRole]> {
        self.roles.as_deref()
    }
}
impl std::fmt::Debug for AwsIamInstanceProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsIamInstanceProfile");
        formatter.field("arn", &self.arn);
        formatter.field("create_date", &self.create_date);
        formatter.field("instance_profile_id", &self.instance_profile_id);
        formatter.field("instance_profile_name", &self.instance_profile_name);
        formatter.field("path", &self.path);
        formatter.field("roles", &self.roles);
        formatter.finish()
    }
}
/// See [`AwsIamInstanceProfile`](crate::model::AwsIamInstanceProfile)
pub mod aws_iam_instance_profile {

    /// A builder for [`AwsIamInstanceProfile`](crate::model::AwsIamInstanceProfile)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) create_date: std::option::Option<std::string::String>,
        pub(crate) instance_profile_id: std::option::Option<std::string::String>,
        pub(crate) instance_profile_name: std::option::Option<std::string::String>,
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) roles:
            std::option::Option<std::vec::Vec<crate::model::AwsIamInstanceProfileRole>>,
    }
    impl Builder {
        /// <p>The ARN of the instance profile.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the instance profile.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>Indicates when the instance profile was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn create_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.create_date = Some(input.into());
            self
        }
        /// <p>Indicates when the instance profile was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_create_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.create_date = input;
            self
        }
        /// <p>The identifier of the instance profile.</p>
        pub fn instance_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_profile_id = Some(input.into());
            self
        }
        /// <p>The identifier of the instance profile.</p>
        pub fn set_instance_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_profile_id = input;
            self
        }
        /// <p>The name of the instance profile.</p>
        pub fn instance_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_profile_name = Some(input.into());
            self
        }
        /// <p>The name of the instance profile.</p>
        pub fn set_instance_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_profile_name = input;
            self
        }
        /// <p>The path to the instance profile.</p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.path = Some(input.into());
            self
        }
        /// <p>The path to the instance profile.</p>
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path = input;
            self
        }
        /// Appends an item to `roles`.
        ///
        /// To override the contents of this collection use [`set_roles`](Self::set_roles).
        ///
        /// <p>The roles associated with the instance profile.</p>
        pub fn roles(mut self, input: crate::model::AwsIamInstanceProfileRole) -> Self {
            let mut v = self.roles.unwrap_or_default();
            v.push(input);
            self.roles = Some(v);
            self
        }
        /// <p>The roles associated with the instance profile.</p>
        pub fn set_roles(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsIamInstanceProfileRole>>,
        ) -> Self {
            self.roles = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsIamInstanceProfile`](crate::model::AwsIamInstanceProfile)
        pub fn build(self) -> crate::model::AwsIamInstanceProfile {
            crate::model::AwsIamInstanceProfile {
                arn: self.arn,
                create_date: self.create_date,
                instance_profile_id: self.instance_profile_id,
                instance_profile_name: self.instance_profile_name,
                path: self.path,
                roles: self.roles,
            }
        }
    }
}
impl AwsIamInstanceProfile {
    /// Creates a new builder-style object to manufacture [`AwsIamInstanceProfile`](crate::model::AwsIamInstanceProfile)
    pub fn builder() -> crate::model::aws_iam_instance_profile::Builder {
        crate::model::aws_iam_instance_profile::Builder::default()
    }
}

/// <p>Information about a role associated with an instance profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsIamInstanceProfileRole {
    /// <p>The ARN of the role.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The policy that grants an entity permission to assume the role.</p>
    pub assume_role_policy_document: std::option::Option<std::string::String>,
    /// <p>Indicates when the role was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub create_date: std::option::Option<std::string::String>,
    /// <p>The path to the role.</p>
    pub path: std::option::Option<std::string::String>,
    /// <p>The identifier of the role.</p>
    pub role_id: std::option::Option<std::string::String>,
    /// <p>The name of the role.</p>
    pub role_name: std::option::Option<std::string::String>,
}
impl AwsIamInstanceProfileRole {
    /// <p>The ARN of the role.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The policy that grants an entity permission to assume the role.</p>
    pub fn assume_role_policy_document(&self) -> std::option::Option<&str> {
        self.assume_role_policy_document.as_deref()
    }
    /// <p>Indicates when the role was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn create_date(&self) -> std::option::Option<&str> {
        self.create_date.as_deref()
    }
    /// <p>The path to the role.</p>
    pub fn path(&self) -> std::option::Option<&str> {
        self.path.as_deref()
    }
    /// <p>The identifier of the role.</p>
    pub fn role_id(&self) -> std::option::Option<&str> {
        self.role_id.as_deref()
    }
    /// <p>The name of the role.</p>
    pub fn role_name(&self) -> std::option::Option<&str> {
        self.role_name.as_deref()
    }
}
impl std::fmt::Debug for AwsIamInstanceProfileRole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsIamInstanceProfileRole");
        formatter.field("arn", &self.arn);
        formatter.field(
            "assume_role_policy_document",
            &self.assume_role_policy_document,
        );
        formatter.field("create_date", &self.create_date);
        formatter.field("path", &self.path);
        formatter.field("role_id", &self.role_id);
        formatter.field("role_name", &self.role_name);
        formatter.finish()
    }
}
/// See [`AwsIamInstanceProfileRole`](crate::model::AwsIamInstanceProfileRole)
pub mod aws_iam_instance_profile_role {

    /// A builder for [`AwsIamInstanceProfileRole`](crate::model::AwsIamInstanceProfileRole)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) assume_role_policy_document: std::option::Option<std::string::String>,
        pub(crate) create_date: std::option::Option<std::string::String>,
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) role_id: std::option::Option<std::string::String>,
        pub(crate) role_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the role.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the role.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The policy that grants an entity permission to assume the role.</p>
        pub fn assume_role_policy_document(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.assume_role_policy_document = Some(input.into());
            self
        }
        /// <p>The policy that grants an entity permission to assume the role.</p>
        pub fn set_assume_role_policy_document(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assume_role_policy_document = input;
            self
        }
        /// <p>Indicates when the role was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn create_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.create_date = Some(input.into());
            self
        }
        /// <p>Indicates when the role was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_create_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.create_date = input;
            self
        }
        /// <p>The path to the role.</p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.path = Some(input.into());
            self
        }
        /// <p>The path to the role.</p>
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path = input;
            self
        }
        /// <p>The identifier of the role.</p>
        pub fn role_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_id = Some(input.into());
            self
        }
        /// <p>The identifier of the role.</p>
        pub fn set_role_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_id = input;
            self
        }
        /// <p>The name of the role.</p>
        pub fn role_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_name = Some(input.into());
            self
        }
        /// <p>The name of the role.</p>
        pub fn set_role_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsIamInstanceProfileRole`](crate::model::AwsIamInstanceProfileRole)
        pub fn build(self) -> crate::model::AwsIamInstanceProfileRole {
            crate::model::AwsIamInstanceProfileRole {
                arn: self.arn,
                assume_role_policy_document: self.assume_role_policy_document,
                create_date: self.create_date,
                path: self.path,
                role_id: self.role_id,
                role_name: self.role_name,
            }
        }
    }
}
impl AwsIamInstanceProfileRole {
    /// Creates a new builder-style object to manufacture [`AwsIamInstanceProfileRole`](crate::model::AwsIamInstanceProfileRole)
    pub fn builder() -> crate::model::aws_iam_instance_profile_role::Builder {
        crate::model::aws_iam_instance_profile_role::Builder::default()
    }
}

/// <p>A managed policy that is attached to an IAM principal.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsIamAttachedManagedPolicy {
    /// <p>The name of the policy.</p>
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the policy.</p>
    pub policy_arn: std::option::Option<std::string::String>,
}
impl AwsIamAttachedManagedPolicy {
    /// <p>The name of the policy.</p>
    pub fn policy_name(&self) -> std::option::Option<&str> {
        self.policy_name.as_deref()
    }
    /// <p>The ARN of the policy.</p>
    pub fn policy_arn(&self) -> std::option::Option<&str> {
        self.policy_arn.as_deref()
    }
}
impl std::fmt::Debug for AwsIamAttachedManagedPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsIamAttachedManagedPolicy");
        formatter.field("policy_name", &self.policy_name);
        formatter.field("policy_arn", &self.policy_arn);
        formatter.finish()
    }
}
/// See [`AwsIamAttachedManagedPolicy`](crate::model::AwsIamAttachedManagedPolicy)
pub mod aws_iam_attached_managed_policy {

    /// A builder for [`AwsIamAttachedManagedPolicy`](crate::model::AwsIamAttachedManagedPolicy)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) policy_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the policy.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        /// <p>The name of the policy.</p>
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// <p>The ARN of the policy.</p>
        pub fn policy_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the policy.</p>
        pub fn set_policy_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsIamAttachedManagedPolicy`](crate::model::AwsIamAttachedManagedPolicy)
        pub fn build(self) -> crate::model::AwsIamAttachedManagedPolicy {
            crate::model::AwsIamAttachedManagedPolicy {
                policy_name: self.policy_name,
                policy_arn: self.policy_arn,
            }
        }
    }
}
impl AwsIamAttachedManagedPolicy {
    /// Creates a new builder-style object to manufacture [`AwsIamAttachedManagedPolicy`](crate::model::AwsIamAttachedManagedPolicy)
    pub fn builder() -> crate::model::aws_iam_attached_managed_policy::Builder {
        crate::model::aws_iam_attached_managed_policy::Builder::default()
    }
}

/// <p>Contains details about an IAM group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsIamGroupDetails {
    /// <p>A list of the managed policies that are attached to the IAM group.</p>
    pub attached_managed_policies:
        std::option::Option<std::vec::Vec<crate::model::AwsIamAttachedManagedPolicy>>,
    /// <p>Indicates when the IAM group was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub create_date: std::option::Option<std::string::String>,
    /// <p>The identifier of the IAM group.</p>
    pub group_id: std::option::Option<std::string::String>,
    /// <p>The name of the IAM group.</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The list of inline policies that are embedded in the group.</p>
    pub group_policy_list: std::option::Option<std::vec::Vec<crate::model::AwsIamGroupPolicy>>,
    /// <p>The path to the group.</p>
    pub path: std::option::Option<std::string::String>,
}
impl AwsIamGroupDetails {
    /// <p>A list of the managed policies that are attached to the IAM group.</p>
    pub fn attached_managed_policies(
        &self,
    ) -> std::option::Option<&[crate::model::AwsIamAttachedManagedPolicy]> {
        self.attached_managed_policies.as_deref()
    }
    /// <p>Indicates when the IAM group was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn create_date(&self) -> std::option::Option<&str> {
        self.create_date.as_deref()
    }
    /// <p>The identifier of the IAM group.</p>
    pub fn group_id(&self) -> std::option::Option<&str> {
        self.group_id.as_deref()
    }
    /// <p>The name of the IAM group.</p>
    pub fn group_name(&self) -> std::option::Option<&str> {
        self.group_name.as_deref()
    }
    /// <p>The list of inline policies that are embedded in the group.</p>
    pub fn group_policy_list(&self) -> std::option::Option<&[crate::model::AwsIamGroupPolicy]> {
        self.group_policy_list.as_deref()
    }
    /// <p>The path to the group.</p>
    pub fn path(&self) -> std::option::Option<&str> {
        self.path.as_deref()
    }
}
impl std::fmt::Debug for AwsIamGroupDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsIamGroupDetails");
        formatter.field("attached_managed_policies", &self.attached_managed_policies);
        formatter.field("create_date", &self.create_date);
        formatter.field("group_id", &self.group_id);
        formatter.field("group_name", &self.group_name);
        formatter.field("group_policy_list", &self.group_policy_list);
        formatter.field("path", &self.path);
        formatter.finish()
    }
}
/// See [`AwsIamGroupDetails`](crate::model::AwsIamGroupDetails)
pub mod aws_iam_group_details {

    /// A builder for [`AwsIamGroupDetails`](crate::model::AwsIamGroupDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attached_managed_policies:
            std::option::Option<std::vec::Vec<crate::model::AwsIamAttachedManagedPolicy>>,
        pub(crate) create_date: std::option::Option<std::string::String>,
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) group_policy_list:
            std::option::Option<std::vec::Vec<crate::model::AwsIamGroupPolicy>>,
        pub(crate) path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `attached_managed_policies`.
        ///
        /// To override the contents of this collection use [`set_attached_managed_policies`](Self::set_attached_managed_policies).
        ///
        /// <p>A list of the managed policies that are attached to the IAM group.</p>
        pub fn attached_managed_policies(
            mut self,
            input: crate::model::AwsIamAttachedManagedPolicy,
        ) -> Self {
            let mut v = self.attached_managed_policies.unwrap_or_default();
            v.push(input);
            self.attached_managed_policies = Some(v);
            self
        }
        /// <p>A list of the managed policies that are attached to the IAM group.</p>
        pub fn set_attached_managed_policies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsIamAttachedManagedPolicy>>,
        ) -> Self {
            self.attached_managed_policies = input;
            self
        }
        /// <p>Indicates when the IAM group was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn create_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.create_date = Some(input.into());
            self
        }
        /// <p>Indicates when the IAM group was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_create_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.create_date = input;
            self
        }
        /// <p>The identifier of the IAM group.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// <p>The identifier of the IAM group.</p>
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input;
            self
        }
        /// <p>The name of the IAM group.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        /// <p>The name of the IAM group.</p>
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// Appends an item to `group_policy_list`.
        ///
        /// To override the contents of this collection use [`set_group_policy_list`](Self::set_group_policy_list).
        ///
        /// <p>The list of inline policies that are embedded in the group.</p>
        pub fn group_policy_list(mut self, input: crate::model::AwsIamGroupPolicy) -> Self {
            let mut v = self.group_policy_list.unwrap_or_default();
            v.push(input);
            self.group_policy_list = Some(v);
            self
        }
        /// <p>The list of inline policies that are embedded in the group.</p>
        pub fn set_group_policy_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsIamGroupPolicy>>,
        ) -> Self {
            self.group_policy_list = input;
            self
        }
        /// <p>The path to the group.</p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.path = Some(input.into());
            self
        }
        /// <p>The path to the group.</p>
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsIamGroupDetails`](crate::model::AwsIamGroupDetails)
        pub fn build(self) -> crate::model::AwsIamGroupDetails {
            crate::model::AwsIamGroupDetails {
                attached_managed_policies: self.attached_managed_policies,
                create_date: self.create_date,
                group_id: self.group_id,
                group_name: self.group_name,
                group_policy_list: self.group_policy_list,
                path: self.path,
            }
        }
    }
}
impl AwsIamGroupDetails {
    /// Creates a new builder-style object to manufacture [`AwsIamGroupDetails`](crate::model::AwsIamGroupDetails)
    pub fn builder() -> crate::model::aws_iam_group_details::Builder {
        crate::model::aws_iam_group_details::Builder::default()
    }
}

/// <p>A managed policy that is attached to the IAM group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsIamGroupPolicy {
    /// <p>The name of the policy.</p>
    pub policy_name: std::option::Option<std::string::String>,
}
impl AwsIamGroupPolicy {
    /// <p>The name of the policy.</p>
    pub fn policy_name(&self) -> std::option::Option<&str> {
        self.policy_name.as_deref()
    }
}
impl std::fmt::Debug for AwsIamGroupPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsIamGroupPolicy");
        formatter.field("policy_name", &self.policy_name);
        formatter.finish()
    }
}
/// See [`AwsIamGroupPolicy`](crate::model::AwsIamGroupPolicy)
pub mod aws_iam_group_policy {

    /// A builder for [`AwsIamGroupPolicy`](crate::model::AwsIamGroupPolicy)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the policy.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        /// <p>The name of the policy.</p>
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsIamGroupPolicy`](crate::model::AwsIamGroupPolicy)
        pub fn build(self) -> crate::model::AwsIamGroupPolicy {
            crate::model::AwsIamGroupPolicy {
                policy_name: self.policy_name,
            }
        }
    }
}
impl AwsIamGroupPolicy {
    /// Creates a new builder-style object to manufacture [`AwsIamGroupPolicy`](crate::model::AwsIamGroupPolicy)
    pub fn builder() -> crate::model::aws_iam_group_policy::Builder {
        crate::model::aws_iam_group_policy::Builder::default()
    }
}

/// <p>Contains details about a Classic Load Balancer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElbLoadBalancerDetails {
    /// <p>The list of Availability Zones for the load balancer.</p>
    pub availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Information about the configuration of the EC2 instances.</p>
    pub backend_server_descriptions: std::option::Option<
        std::vec::Vec<crate::model::AwsElbLoadBalancerBackendServerDescription>,
    >,
    /// <p>The name of the Amazon Route&nbsp;53 hosted zone for the load balancer.</p>
    pub canonical_hosted_zone_name: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Route&nbsp;53 hosted zone for the load balancer.</p>
    pub canonical_hosted_zone_name_id: std::option::Option<std::string::String>,
    /// <p>Indicates when the load balancer was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub created_time: std::option::Option<std::string::String>,
    /// <p>The DNS name of the load balancer.</p>
    pub dns_name: std::option::Option<std::string::String>,
    /// <p>Information about the health checks that are conducted on the load balancer.</p>
    pub health_check: std::option::Option<crate::model::AwsElbLoadBalancerHealthCheck>,
    /// <p>List of EC2 instances for the load balancer.</p>
    pub instances: std::option::Option<std::vec::Vec<crate::model::AwsElbLoadBalancerInstance>>,
    /// <p>The policies that are enabled for the load balancer listeners.</p>
    pub listener_descriptions:
        std::option::Option<std::vec::Vec<crate::model::AwsElbLoadBalancerListenerDescription>>,
    /// <p>The attributes for a load balancer.</p>
    pub load_balancer_attributes: std::option::Option<crate::model::AwsElbLoadBalancerAttributes>,
    /// <p>The name of the load balancer.</p>
    pub load_balancer_name: std::option::Option<std::string::String>,
    /// <p>The policies for a load balancer.</p>
    pub policies: std::option::Option<crate::model::AwsElbLoadBalancerPolicies>,
    /// <p>The type of load balancer. Only provided if the load balancer is in a VPC.</p>
    /// <p>If <code>Scheme</code> is <code>internet-facing</code>, the load balancer has a public DNS name that resolves to a public IP address.</p>
    /// <p>If <code>Scheme</code> is <code>internal</code>, the load balancer has a public DNS name that resolves to a private IP address.</p>
    pub scheme: std::option::Option<std::string::String>,
    /// <p>The security groups for the load balancer. Only provided if the load balancer is in a VPC.</p>
    pub security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Information about the security group for the load balancer. This is the security group that is used for inbound rules.</p>
    pub source_security_group:
        std::option::Option<crate::model::AwsElbLoadBalancerSourceSecurityGroup>,
    /// <p>The list of subnet identifiers for the load balancer.</p>
    pub subnets: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The identifier of the VPC for the load balancer.</p>
    pub vpc_id: std::option::Option<std::string::String>,
}
impl AwsElbLoadBalancerDetails {
    /// <p>The list of Availability Zones for the load balancer.</p>
    pub fn availability_zones(&self) -> std::option::Option<&[std::string::String]> {
        self.availability_zones.as_deref()
    }
    /// <p>Information about the configuration of the EC2 instances.</p>
    pub fn backend_server_descriptions(
        &self,
    ) -> std::option::Option<&[crate::model::AwsElbLoadBalancerBackendServerDescription]> {
        self.backend_server_descriptions.as_deref()
    }
    /// <p>The name of the Amazon Route&nbsp;53 hosted zone for the load balancer.</p>
    pub fn canonical_hosted_zone_name(&self) -> std::option::Option<&str> {
        self.canonical_hosted_zone_name.as_deref()
    }
    /// <p>The ID of the Amazon Route&nbsp;53 hosted zone for the load balancer.</p>
    pub fn canonical_hosted_zone_name_id(&self) -> std::option::Option<&str> {
        self.canonical_hosted_zone_name_id.as_deref()
    }
    /// <p>Indicates when the load balancer was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn created_time(&self) -> std::option::Option<&str> {
        self.created_time.as_deref()
    }
    /// <p>The DNS name of the load balancer.</p>
    pub fn dns_name(&self) -> std::option::Option<&str> {
        self.dns_name.as_deref()
    }
    /// <p>Information about the health checks that are conducted on the load balancer.</p>
    pub fn health_check(
        &self,
    ) -> std::option::Option<&crate::model::AwsElbLoadBalancerHealthCheck> {
        self.health_check.as_ref()
    }
    /// <p>List of EC2 instances for the load balancer.</p>
    pub fn instances(&self) -> std::option::Option<&[crate::model::AwsElbLoadBalancerInstance]> {
        self.instances.as_deref()
    }
    /// <p>The policies that are enabled for the load balancer listeners.</p>
    pub fn listener_descriptions(
        &self,
    ) -> std::option::Option<&[crate::model::AwsElbLoadBalancerListenerDescription]> {
        self.listener_descriptions.as_deref()
    }
    /// <p>The attributes for a load balancer.</p>
    pub fn load_balancer_attributes(
        &self,
    ) -> std::option::Option<&crate::model::AwsElbLoadBalancerAttributes> {
        self.load_balancer_attributes.as_ref()
    }
    /// <p>The name of the load balancer.</p>
    pub fn load_balancer_name(&self) -> std::option::Option<&str> {
        self.load_balancer_name.as_deref()
    }
    /// <p>The policies for a load balancer.</p>
    pub fn policies(&self) -> std::option::Option<&crate::model::AwsElbLoadBalancerPolicies> {
        self.policies.as_ref()
    }
    /// <p>The type of load balancer. Only provided if the load balancer is in a VPC.</p>
    /// <p>If <code>Scheme</code> is <code>internet-facing</code>, the load balancer has a public DNS name that resolves to a public IP address.</p>
    /// <p>If <code>Scheme</code> is <code>internal</code>, the load balancer has a public DNS name that resolves to a private IP address.</p>
    pub fn scheme(&self) -> std::option::Option<&str> {
        self.scheme.as_deref()
    }
    /// <p>The security groups for the load balancer. Only provided if the load balancer is in a VPC.</p>
    pub fn security_groups(&self) -> std::option::Option<&[std::string::String]> {
        self.security_groups.as_deref()
    }
    /// <p>Information about the security group for the load balancer. This is the security group that is used for inbound rules.</p>
    pub fn source_security_group(
        &self,
    ) -> std::option::Option<&crate::model::AwsElbLoadBalancerSourceSecurityGroup> {
        self.source_security_group.as_ref()
    }
    /// <p>The list of subnet identifiers for the load balancer.</p>
    pub fn subnets(&self) -> std::option::Option<&[std::string::String]> {
        self.subnets.as_deref()
    }
    /// <p>The identifier of the VPC for the load balancer.</p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
}
impl std::fmt::Debug for AwsElbLoadBalancerDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElbLoadBalancerDetails");
        formatter.field("availability_zones", &self.availability_zones);
        formatter.field(
            "backend_server_descriptions",
            &self.backend_server_descriptions,
        );
        formatter.field(
            "canonical_hosted_zone_name",
            &self.canonical_hosted_zone_name,
        );
        formatter.field(
            "canonical_hosted_zone_name_id",
            &self.canonical_hosted_zone_name_id,
        );
        formatter.field("created_time", &self.created_time);
        formatter.field("dns_name", &self.dns_name);
        formatter.field("health_check", &self.health_check);
        formatter.field("instances", &self.instances);
        formatter.field("listener_descriptions", &self.listener_descriptions);
        formatter.field("load_balancer_attributes", &self.load_balancer_attributes);
        formatter.field("load_balancer_name", &self.load_balancer_name);
        formatter.field("policies", &self.policies);
        formatter.field("scheme", &self.scheme);
        formatter.field("security_groups", &self.security_groups);
        formatter.field("source_security_group", &self.source_security_group);
        formatter.field("subnets", &self.subnets);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.finish()
    }
}
/// See [`AwsElbLoadBalancerDetails`](crate::model::AwsElbLoadBalancerDetails)
pub mod aws_elb_load_balancer_details {

    /// A builder for [`AwsElbLoadBalancerDetails`](crate::model::AwsElbLoadBalancerDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) backend_server_descriptions: std::option::Option<
            std::vec::Vec<crate::model::AwsElbLoadBalancerBackendServerDescription>,
        >,
        pub(crate) canonical_hosted_zone_name: std::option::Option<std::string::String>,
        pub(crate) canonical_hosted_zone_name_id: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<std::string::String>,
        pub(crate) dns_name: std::option::Option<std::string::String>,
        pub(crate) health_check: std::option::Option<crate::model::AwsElbLoadBalancerHealthCheck>,
        pub(crate) instances:
            std::option::Option<std::vec::Vec<crate::model::AwsElbLoadBalancerInstance>>,
        pub(crate) listener_descriptions:
            std::option::Option<std::vec::Vec<crate::model::AwsElbLoadBalancerListenerDescription>>,
        pub(crate) load_balancer_attributes:
            std::option::Option<crate::model::AwsElbLoadBalancerAttributes>,
        pub(crate) load_balancer_name: std::option::Option<std::string::String>,
        pub(crate) policies: std::option::Option<crate::model::AwsElbLoadBalancerPolicies>,
        pub(crate) scheme: std::option::Option<std::string::String>,
        pub(crate) security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) source_security_group:
            std::option::Option<crate::model::AwsElbLoadBalancerSourceSecurityGroup>,
        pub(crate) subnets: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `availability_zones`.
        ///
        /// To override the contents of this collection use [`set_availability_zones`](Self::set_availability_zones).
        ///
        /// <p>The list of Availability Zones for the load balancer.</p>
        pub fn availability_zones(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.availability_zones.unwrap_or_default();
            v.push(input.into());
            self.availability_zones = Some(v);
            self
        }
        /// <p>The list of Availability Zones for the load balancer.</p>
        pub fn set_availability_zones(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.availability_zones = input;
            self
        }
        /// Appends an item to `backend_server_descriptions`.
        ///
        /// To override the contents of this collection use [`set_backend_server_descriptions`](Self::set_backend_server_descriptions).
        ///
        /// <p>Information about the configuration of the EC2 instances.</p>
        pub fn backend_server_descriptions(
            mut self,
            input: crate::model::AwsElbLoadBalancerBackendServerDescription,
        ) -> Self {
            let mut v = self.backend_server_descriptions.unwrap_or_default();
            v.push(input);
            self.backend_server_descriptions = Some(v);
            self
        }
        /// <p>Information about the configuration of the EC2 instances.</p>
        pub fn set_backend_server_descriptions(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsElbLoadBalancerBackendServerDescription>,
            >,
        ) -> Self {
            self.backend_server_descriptions = input;
            self
        }
        /// <p>The name of the Amazon Route&nbsp;53 hosted zone for the load balancer.</p>
        pub fn canonical_hosted_zone_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.canonical_hosted_zone_name = Some(input.into());
            self
        }
        /// <p>The name of the Amazon Route&nbsp;53 hosted zone for the load balancer.</p>
        pub fn set_canonical_hosted_zone_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.canonical_hosted_zone_name = input;
            self
        }
        /// <p>The ID of the Amazon Route&nbsp;53 hosted zone for the load balancer.</p>
        pub fn canonical_hosted_zone_name_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.canonical_hosted_zone_name_id = Some(input.into());
            self
        }
        /// <p>The ID of the Amazon Route&nbsp;53 hosted zone for the load balancer.</p>
        pub fn set_canonical_hosted_zone_name_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.canonical_hosted_zone_name_id = input;
            self
        }
        /// <p>Indicates when the load balancer was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn created_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_time = Some(input.into());
            self
        }
        /// <p>Indicates when the load balancer was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_created_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The DNS name of the load balancer.</p>
        pub fn dns_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.dns_name = Some(input.into());
            self
        }
        /// <p>The DNS name of the load balancer.</p>
        pub fn set_dns_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dns_name = input;
            self
        }
        /// <p>Information about the health checks that are conducted on the load balancer.</p>
        pub fn health_check(mut self, input: crate::model::AwsElbLoadBalancerHealthCheck) -> Self {
            self.health_check = Some(input);
            self
        }
        /// <p>Information about the health checks that are conducted on the load balancer.</p>
        pub fn set_health_check(
            mut self,
            input: std::option::Option<crate::model::AwsElbLoadBalancerHealthCheck>,
        ) -> Self {
            self.health_check = input;
            self
        }
        /// Appends an item to `instances`.
        ///
        /// To override the contents of this collection use [`set_instances`](Self::set_instances).
        ///
        /// <p>List of EC2 instances for the load balancer.</p>
        pub fn instances(mut self, input: crate::model::AwsElbLoadBalancerInstance) -> Self {
            let mut v = self.instances.unwrap_or_default();
            v.push(input);
            self.instances = Some(v);
            self
        }
        /// <p>List of EC2 instances for the load balancer.</p>
        pub fn set_instances(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsElbLoadBalancerInstance>>,
        ) -> Self {
            self.instances = input;
            self
        }
        /// Appends an item to `listener_descriptions`.
        ///
        /// To override the contents of this collection use [`set_listener_descriptions`](Self::set_listener_descriptions).
        ///
        /// <p>The policies that are enabled for the load balancer listeners.</p>
        pub fn listener_descriptions(
            mut self,
            input: crate::model::AwsElbLoadBalancerListenerDescription,
        ) -> Self {
            let mut v = self.listener_descriptions.unwrap_or_default();
            v.push(input);
            self.listener_descriptions = Some(v);
            self
        }
        /// <p>The policies that are enabled for the load balancer listeners.</p>
        pub fn set_listener_descriptions(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsElbLoadBalancerListenerDescription>,
            >,
        ) -> Self {
            self.listener_descriptions = input;
            self
        }
        /// <p>The attributes for a load balancer.</p>
        pub fn load_balancer_attributes(
            mut self,
            input: crate::model::AwsElbLoadBalancerAttributes,
        ) -> Self {
            self.load_balancer_attributes = Some(input);
            self
        }
        /// <p>The attributes for a load balancer.</p>
        pub fn set_load_balancer_attributes(
            mut self,
            input: std::option::Option<crate::model::AwsElbLoadBalancerAttributes>,
        ) -> Self {
            self.load_balancer_attributes = input;
            self
        }
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.load_balancer_name = Some(input.into());
            self
        }
        /// <p>The name of the load balancer.</p>
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.load_balancer_name = input;
            self
        }
        /// <p>The policies for a load balancer.</p>
        pub fn policies(mut self, input: crate::model::AwsElbLoadBalancerPolicies) -> Self {
            self.policies = Some(input);
            self
        }
        /// <p>The policies for a load balancer.</p>
        pub fn set_policies(
            mut self,
            input: std::option::Option<crate::model::AwsElbLoadBalancerPolicies>,
        ) -> Self {
            self.policies = input;
            self
        }
        /// <p>The type of load balancer. Only provided if the load balancer is in a VPC.</p>
        /// <p>If <code>Scheme</code> is <code>internet-facing</code>, the load balancer has a public DNS name that resolves to a public IP address.</p>
        /// <p>If <code>Scheme</code> is <code>internal</code>, the load balancer has a public DNS name that resolves to a private IP address.</p>
        pub fn scheme(mut self, input: impl Into<std::string::String>) -> Self {
            self.scheme = Some(input.into());
            self
        }
        /// <p>The type of load balancer. Only provided if the load balancer is in a VPC.</p>
        /// <p>If <code>Scheme</code> is <code>internet-facing</code>, the load balancer has a public DNS name that resolves to a public IP address.</p>
        /// <p>If <code>Scheme</code> is <code>internal</code>, the load balancer has a public DNS name that resolves to a private IP address.</p>
        pub fn set_scheme(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.scheme = input;
            self
        }
        /// Appends an item to `security_groups`.
        ///
        /// To override the contents of this collection use [`set_security_groups`](Self::set_security_groups).
        ///
        /// <p>The security groups for the load balancer. Only provided if the load balancer is in a VPC.</p>
        pub fn security_groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_groups.unwrap_or_default();
            v.push(input.into());
            self.security_groups = Some(v);
            self
        }
        /// <p>The security groups for the load balancer. Only provided if the load balancer is in a VPC.</p>
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_groups = input;
            self
        }
        /// <p>Information about the security group for the load balancer. This is the security group that is used for inbound rules.</p>
        pub fn source_security_group(
            mut self,
            input: crate::model::AwsElbLoadBalancerSourceSecurityGroup,
        ) -> Self {
            self.source_security_group = Some(input);
            self
        }
        /// <p>Information about the security group for the load balancer. This is the security group that is used for inbound rules.</p>
        pub fn set_source_security_group(
            mut self,
            input: std::option::Option<crate::model::AwsElbLoadBalancerSourceSecurityGroup>,
        ) -> Self {
            self.source_security_group = input;
            self
        }
        /// Appends an item to `subnets`.
        ///
        /// To override the contents of this collection use [`set_subnets`](Self::set_subnets).
        ///
        /// <p>The list of subnet identifiers for the load balancer.</p>
        pub fn subnets(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnets.unwrap_or_default();
            v.push(input.into());
            self.subnets = Some(v);
            self
        }
        /// <p>The list of subnet identifiers for the load balancer.</p>
        pub fn set_subnets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnets = input;
            self
        }
        /// <p>The identifier of the VPC for the load balancer.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The identifier of the VPC for the load balancer.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElbLoadBalancerDetails`](crate::model::AwsElbLoadBalancerDetails)
        pub fn build(self) -> crate::model::AwsElbLoadBalancerDetails {
            crate::model::AwsElbLoadBalancerDetails {
                availability_zones: self.availability_zones,
                backend_server_descriptions: self.backend_server_descriptions,
                canonical_hosted_zone_name: self.canonical_hosted_zone_name,
                canonical_hosted_zone_name_id: self.canonical_hosted_zone_name_id,
                created_time: self.created_time,
                dns_name: self.dns_name,
                health_check: self.health_check,
                instances: self.instances,
                listener_descriptions: self.listener_descriptions,
                load_balancer_attributes: self.load_balancer_attributes,
                load_balancer_name: self.load_balancer_name,
                policies: self.policies,
                scheme: self.scheme,
                security_groups: self.security_groups,
                source_security_group: self.source_security_group,
                subnets: self.subnets,
                vpc_id: self.vpc_id,
            }
        }
    }
}
impl AwsElbLoadBalancerDetails {
    /// Creates a new builder-style object to manufacture [`AwsElbLoadBalancerDetails`](crate::model::AwsElbLoadBalancerDetails)
    pub fn builder() -> crate::model::aws_elb_load_balancer_details::Builder {
        crate::model::aws_elb_load_balancer_details::Builder::default()
    }
}

/// <p>Contains information about the security group for the load balancer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElbLoadBalancerSourceSecurityGroup {
    /// <p>The name of the security group.</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The owner of the security group.</p>
    pub owner_alias: std::option::Option<std::string::String>,
}
impl AwsElbLoadBalancerSourceSecurityGroup {
    /// <p>The name of the security group.</p>
    pub fn group_name(&self) -> std::option::Option<&str> {
        self.group_name.as_deref()
    }
    /// <p>The owner of the security group.</p>
    pub fn owner_alias(&self) -> std::option::Option<&str> {
        self.owner_alias.as_deref()
    }
}
impl std::fmt::Debug for AwsElbLoadBalancerSourceSecurityGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElbLoadBalancerSourceSecurityGroup");
        formatter.field("group_name", &self.group_name);
        formatter.field("owner_alias", &self.owner_alias);
        formatter.finish()
    }
}
/// See [`AwsElbLoadBalancerSourceSecurityGroup`](crate::model::AwsElbLoadBalancerSourceSecurityGroup)
pub mod aws_elb_load_balancer_source_security_group {

    /// A builder for [`AwsElbLoadBalancerSourceSecurityGroup`](crate::model::AwsElbLoadBalancerSourceSecurityGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) owner_alias: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the security group.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        /// <p>The name of the security group.</p>
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// <p>The owner of the security group.</p>
        pub fn owner_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_alias = Some(input.into());
            self
        }
        /// <p>The owner of the security group.</p>
        pub fn set_owner_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_alias = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElbLoadBalancerSourceSecurityGroup`](crate::model::AwsElbLoadBalancerSourceSecurityGroup)
        pub fn build(self) -> crate::model::AwsElbLoadBalancerSourceSecurityGroup {
            crate::model::AwsElbLoadBalancerSourceSecurityGroup {
                group_name: self.group_name,
                owner_alias: self.owner_alias,
            }
        }
    }
}
impl AwsElbLoadBalancerSourceSecurityGroup {
    /// Creates a new builder-style object to manufacture [`AwsElbLoadBalancerSourceSecurityGroup`](crate::model::AwsElbLoadBalancerSourceSecurityGroup)
    pub fn builder() -> crate::model::aws_elb_load_balancer_source_security_group::Builder {
        crate::model::aws_elb_load_balancer_source_security_group::Builder::default()
    }
}

/// <p>Contains information about the policies for a load balancer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElbLoadBalancerPolicies {
    /// <p>The stickiness policies that are created using <code>CreateAppCookieStickinessPolicy</code>.</p>
    pub app_cookie_stickiness_policies:
        std::option::Option<std::vec::Vec<crate::model::AwsElbAppCookieStickinessPolicy>>,
    /// <p>The stickiness policies that are created using <code>CreateLBCookieStickinessPolicy</code>.</p>
    pub lb_cookie_stickiness_policies:
        std::option::Option<std::vec::Vec<crate::model::AwsElbLbCookieStickinessPolicy>>,
    /// <p>The policies other than the stickiness policies.</p>
    pub other_policies: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AwsElbLoadBalancerPolicies {
    /// <p>The stickiness policies that are created using <code>CreateAppCookieStickinessPolicy</code>.</p>
    pub fn app_cookie_stickiness_policies(
        &self,
    ) -> std::option::Option<&[crate::model::AwsElbAppCookieStickinessPolicy]> {
        self.app_cookie_stickiness_policies.as_deref()
    }
    /// <p>The stickiness policies that are created using <code>CreateLBCookieStickinessPolicy</code>.</p>
    pub fn lb_cookie_stickiness_policies(
        &self,
    ) -> std::option::Option<&[crate::model::AwsElbLbCookieStickinessPolicy]> {
        self.lb_cookie_stickiness_policies.as_deref()
    }
    /// <p>The policies other than the stickiness policies.</p>
    pub fn other_policies(&self) -> std::option::Option<&[std::string::String]> {
        self.other_policies.as_deref()
    }
}
impl std::fmt::Debug for AwsElbLoadBalancerPolicies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElbLoadBalancerPolicies");
        formatter.field(
            "app_cookie_stickiness_policies",
            &self.app_cookie_stickiness_policies,
        );
        formatter.field(
            "lb_cookie_stickiness_policies",
            &self.lb_cookie_stickiness_policies,
        );
        formatter.field("other_policies", &self.other_policies);
        formatter.finish()
    }
}
/// See [`AwsElbLoadBalancerPolicies`](crate::model::AwsElbLoadBalancerPolicies)
pub mod aws_elb_load_balancer_policies {

    /// A builder for [`AwsElbLoadBalancerPolicies`](crate::model::AwsElbLoadBalancerPolicies)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_cookie_stickiness_policies:
            std::option::Option<std::vec::Vec<crate::model::AwsElbAppCookieStickinessPolicy>>,
        pub(crate) lb_cookie_stickiness_policies:
            std::option::Option<std::vec::Vec<crate::model::AwsElbLbCookieStickinessPolicy>>,
        pub(crate) other_policies: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `app_cookie_stickiness_policies`.
        ///
        /// To override the contents of this collection use [`set_app_cookie_stickiness_policies`](Self::set_app_cookie_stickiness_policies).
        ///
        /// <p>The stickiness policies that are created using <code>CreateAppCookieStickinessPolicy</code>.</p>
        pub fn app_cookie_stickiness_policies(
            mut self,
            input: crate::model::AwsElbAppCookieStickinessPolicy,
        ) -> Self {
            let mut v = self.app_cookie_stickiness_policies.unwrap_or_default();
            v.push(input);
            self.app_cookie_stickiness_policies = Some(v);
            self
        }
        /// <p>The stickiness policies that are created using <code>CreateAppCookieStickinessPolicy</code>.</p>
        pub fn set_app_cookie_stickiness_policies(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsElbAppCookieStickinessPolicy>,
            >,
        ) -> Self {
            self.app_cookie_stickiness_policies = input;
            self
        }
        /// Appends an item to `lb_cookie_stickiness_policies`.
        ///
        /// To override the contents of this collection use [`set_lb_cookie_stickiness_policies`](Self::set_lb_cookie_stickiness_policies).
        ///
        /// <p>The stickiness policies that are created using <code>CreateLBCookieStickinessPolicy</code>.</p>
        pub fn lb_cookie_stickiness_policies(
            mut self,
            input: crate::model::AwsElbLbCookieStickinessPolicy,
        ) -> Self {
            let mut v = self.lb_cookie_stickiness_policies.unwrap_or_default();
            v.push(input);
            self.lb_cookie_stickiness_policies = Some(v);
            self
        }
        /// <p>The stickiness policies that are created using <code>CreateLBCookieStickinessPolicy</code>.</p>
        pub fn set_lb_cookie_stickiness_policies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsElbLbCookieStickinessPolicy>>,
        ) -> Self {
            self.lb_cookie_stickiness_policies = input;
            self
        }
        /// Appends an item to `other_policies`.
        ///
        /// To override the contents of this collection use [`set_other_policies`](Self::set_other_policies).
        ///
        /// <p>The policies other than the stickiness policies.</p>
        pub fn other_policies(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.other_policies.unwrap_or_default();
            v.push(input.into());
            self.other_policies = Some(v);
            self
        }
        /// <p>The policies other than the stickiness policies.</p>
        pub fn set_other_policies(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.other_policies = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElbLoadBalancerPolicies`](crate::model::AwsElbLoadBalancerPolicies)
        pub fn build(self) -> crate::model::AwsElbLoadBalancerPolicies {
            crate::model::AwsElbLoadBalancerPolicies {
                app_cookie_stickiness_policies: self.app_cookie_stickiness_policies,
                lb_cookie_stickiness_policies: self.lb_cookie_stickiness_policies,
                other_policies: self.other_policies,
            }
        }
    }
}
impl AwsElbLoadBalancerPolicies {
    /// Creates a new builder-style object to manufacture [`AwsElbLoadBalancerPolicies`](crate::model::AwsElbLoadBalancerPolicies)
    pub fn builder() -> crate::model::aws_elb_load_balancer_policies::Builder {
        crate::model::aws_elb_load_balancer_policies::Builder::default()
    }
}

/// <p>Contains information about a stickiness policy that was created using <code>CreateLBCookieStickinessPolicy</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElbLbCookieStickinessPolicy {
    /// <p>The amount of time, in seconds, after which the cookie is considered stale. If an expiration period is not specified, the stickiness session lasts for the duration of the browser session.</p>
    pub cookie_expiration_period: i64,
    /// <p>The name of the policy. The name must be unique within the set of policies for the load balancer.</p>
    pub policy_name: std::option::Option<std::string::String>,
}
impl AwsElbLbCookieStickinessPolicy {
    /// <p>The amount of time, in seconds, after which the cookie is considered stale. If an expiration period is not specified, the stickiness session lasts for the duration of the browser session.</p>
    pub fn cookie_expiration_period(&self) -> i64 {
        self.cookie_expiration_period
    }
    /// <p>The name of the policy. The name must be unique within the set of policies for the load balancer.</p>
    pub fn policy_name(&self) -> std::option::Option<&str> {
        self.policy_name.as_deref()
    }
}
impl std::fmt::Debug for AwsElbLbCookieStickinessPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElbLbCookieStickinessPolicy");
        formatter.field("cookie_expiration_period", &self.cookie_expiration_period);
        formatter.field("policy_name", &self.policy_name);
        formatter.finish()
    }
}
/// See [`AwsElbLbCookieStickinessPolicy`](crate::model::AwsElbLbCookieStickinessPolicy)
pub mod aws_elb_lb_cookie_stickiness_policy {

    /// A builder for [`AwsElbLbCookieStickinessPolicy`](crate::model::AwsElbLbCookieStickinessPolicy)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cookie_expiration_period: std::option::Option<i64>,
        pub(crate) policy_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The amount of time, in seconds, after which the cookie is considered stale. If an expiration period is not specified, the stickiness session lasts for the duration of the browser session.</p>
        pub fn cookie_expiration_period(mut self, input: i64) -> Self {
            self.cookie_expiration_period = Some(input);
            self
        }
        /// <p>The amount of time, in seconds, after which the cookie is considered stale. If an expiration period is not specified, the stickiness session lasts for the duration of the browser session.</p>
        pub fn set_cookie_expiration_period(mut self, input: std::option::Option<i64>) -> Self {
            self.cookie_expiration_period = input;
            self
        }
        /// <p>The name of the policy. The name must be unique within the set of policies for the load balancer.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        /// <p>The name of the policy. The name must be unique within the set of policies for the load balancer.</p>
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElbLbCookieStickinessPolicy`](crate::model::AwsElbLbCookieStickinessPolicy)
        pub fn build(self) -> crate::model::AwsElbLbCookieStickinessPolicy {
            crate::model::AwsElbLbCookieStickinessPolicy {
                cookie_expiration_period: self.cookie_expiration_period.unwrap_or_default(),
                policy_name: self.policy_name,
            }
        }
    }
}
impl AwsElbLbCookieStickinessPolicy {
    /// Creates a new builder-style object to manufacture [`AwsElbLbCookieStickinessPolicy`](crate::model::AwsElbLbCookieStickinessPolicy)
    pub fn builder() -> crate::model::aws_elb_lb_cookie_stickiness_policy::Builder {
        crate::model::aws_elb_lb_cookie_stickiness_policy::Builder::default()
    }
}

/// <p>Contains information about a stickiness policy that was created using <code>CreateAppCookieStickinessPolicy</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElbAppCookieStickinessPolicy {
    /// <p>The name of the application cookie used for stickiness.</p>
    pub cookie_name: std::option::Option<std::string::String>,
    /// <p>The mnemonic name for the policy being created. The name must be unique within the set of policies for the load balancer.</p>
    pub policy_name: std::option::Option<std::string::String>,
}
impl AwsElbAppCookieStickinessPolicy {
    /// <p>The name of the application cookie used for stickiness.</p>
    pub fn cookie_name(&self) -> std::option::Option<&str> {
        self.cookie_name.as_deref()
    }
    /// <p>The mnemonic name for the policy being created. The name must be unique within the set of policies for the load balancer.</p>
    pub fn policy_name(&self) -> std::option::Option<&str> {
        self.policy_name.as_deref()
    }
}
impl std::fmt::Debug for AwsElbAppCookieStickinessPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElbAppCookieStickinessPolicy");
        formatter.field("cookie_name", &self.cookie_name);
        formatter.field("policy_name", &self.policy_name);
        formatter.finish()
    }
}
/// See [`AwsElbAppCookieStickinessPolicy`](crate::model::AwsElbAppCookieStickinessPolicy)
pub mod aws_elb_app_cookie_stickiness_policy {

    /// A builder for [`AwsElbAppCookieStickinessPolicy`](crate::model::AwsElbAppCookieStickinessPolicy)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cookie_name: std::option::Option<std::string::String>,
        pub(crate) policy_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the application cookie used for stickiness.</p>
        pub fn cookie_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.cookie_name = Some(input.into());
            self
        }
        /// <p>The name of the application cookie used for stickiness.</p>
        pub fn set_cookie_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cookie_name = input;
            self
        }
        /// <p>The mnemonic name for the policy being created. The name must be unique within the set of policies for the load balancer.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        /// <p>The mnemonic name for the policy being created. The name must be unique within the set of policies for the load balancer.</p>
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElbAppCookieStickinessPolicy`](crate::model::AwsElbAppCookieStickinessPolicy)
        pub fn build(self) -> crate::model::AwsElbAppCookieStickinessPolicy {
            crate::model::AwsElbAppCookieStickinessPolicy {
                cookie_name: self.cookie_name,
                policy_name: self.policy_name,
            }
        }
    }
}
impl AwsElbAppCookieStickinessPolicy {
    /// Creates a new builder-style object to manufacture [`AwsElbAppCookieStickinessPolicy`](crate::model::AwsElbAppCookieStickinessPolicy)
    pub fn builder() -> crate::model::aws_elb_app_cookie_stickiness_policy::Builder {
        crate::model::aws_elb_app_cookie_stickiness_policy::Builder::default()
    }
}

/// <p>Contains attributes for the load balancer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElbLoadBalancerAttributes {
    /// <p>Information about the access log configuration for the load balancer.</p>
    /// <p>If the access log is enabled, the load balancer captures detailed information about all requests. It delivers the information to a specified S3 bucket.</p>
    pub access_log: std::option::Option<crate::model::AwsElbLoadBalancerAccessLog>,
    /// <p>Information about the connection draining configuration for the load balancer.</p>
    /// <p>If connection draining is enabled, the load balancer allows existing requests to complete before it shifts traffic away from a deregistered or unhealthy instance.</p>
    pub connection_draining:
        std::option::Option<crate::model::AwsElbLoadBalancerConnectionDraining>,
    /// <p>Connection settings for the load balancer.</p>
    /// <p>If an idle timeout is configured, the load balancer allows connections to remain idle for the specified duration. When a connection is idle, no data is sent over the connection.</p>
    pub connection_settings:
        std::option::Option<crate::model::AwsElbLoadBalancerConnectionSettings>,
    /// <p>Cross-zone load balancing settings for the load balancer.</p>
    /// <p>If cross-zone load balancing is enabled, the load balancer routes the request traffic evenly across all instances regardless of the Availability Zones.</p>
    pub cross_zone_load_balancing:
        std::option::Option<crate::model::AwsElbLoadBalancerCrossZoneLoadBalancing>,
    /// <p>Any additional attributes for a load balancer.</p>
    pub additional_attributes:
        std::option::Option<std::vec::Vec<crate::model::AwsElbLoadBalancerAdditionalAttribute>>,
}
impl AwsElbLoadBalancerAttributes {
    /// <p>Information about the access log configuration for the load balancer.</p>
    /// <p>If the access log is enabled, the load balancer captures detailed information about all requests. It delivers the information to a specified S3 bucket.</p>
    pub fn access_log(&self) -> std::option::Option<&crate::model::AwsElbLoadBalancerAccessLog> {
        self.access_log.as_ref()
    }
    /// <p>Information about the connection draining configuration for the load balancer.</p>
    /// <p>If connection draining is enabled, the load balancer allows existing requests to complete before it shifts traffic away from a deregistered or unhealthy instance.</p>
    pub fn connection_draining(
        &self,
    ) -> std::option::Option<&crate::model::AwsElbLoadBalancerConnectionDraining> {
        self.connection_draining.as_ref()
    }
    /// <p>Connection settings for the load balancer.</p>
    /// <p>If an idle timeout is configured, the load balancer allows connections to remain idle for the specified duration. When a connection is idle, no data is sent over the connection.</p>
    pub fn connection_settings(
        &self,
    ) -> std::option::Option<&crate::model::AwsElbLoadBalancerConnectionSettings> {
        self.connection_settings.as_ref()
    }
    /// <p>Cross-zone load balancing settings for the load balancer.</p>
    /// <p>If cross-zone load balancing is enabled, the load balancer routes the request traffic evenly across all instances regardless of the Availability Zones.</p>
    pub fn cross_zone_load_balancing(
        &self,
    ) -> std::option::Option<&crate::model::AwsElbLoadBalancerCrossZoneLoadBalancing> {
        self.cross_zone_load_balancing.as_ref()
    }
    /// <p>Any additional attributes for a load balancer.</p>
    pub fn additional_attributes(
        &self,
    ) -> std::option::Option<&[crate::model::AwsElbLoadBalancerAdditionalAttribute]> {
        self.additional_attributes.as_deref()
    }
}
impl std::fmt::Debug for AwsElbLoadBalancerAttributes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElbLoadBalancerAttributes");
        formatter.field("access_log", &self.access_log);
        formatter.field("connection_draining", &self.connection_draining);
        formatter.field("connection_settings", &self.connection_settings);
        formatter.field("cross_zone_load_balancing", &self.cross_zone_load_balancing);
        formatter.field("additional_attributes", &self.additional_attributes);
        formatter.finish()
    }
}
/// See [`AwsElbLoadBalancerAttributes`](crate::model::AwsElbLoadBalancerAttributes)
pub mod aws_elb_load_balancer_attributes {

    /// A builder for [`AwsElbLoadBalancerAttributes`](crate::model::AwsElbLoadBalancerAttributes)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) access_log: std::option::Option<crate::model::AwsElbLoadBalancerAccessLog>,
        pub(crate) connection_draining:
            std::option::Option<crate::model::AwsElbLoadBalancerConnectionDraining>,
        pub(crate) connection_settings:
            std::option::Option<crate::model::AwsElbLoadBalancerConnectionSettings>,
        pub(crate) cross_zone_load_balancing:
            std::option::Option<crate::model::AwsElbLoadBalancerCrossZoneLoadBalancing>,
        pub(crate) additional_attributes:
            std::option::Option<std::vec::Vec<crate::model::AwsElbLoadBalancerAdditionalAttribute>>,
    }
    impl Builder {
        /// <p>Information about the access log configuration for the load balancer.</p>
        /// <p>If the access log is enabled, the load balancer captures detailed information about all requests. It delivers the information to a specified S3 bucket.</p>
        pub fn access_log(mut self, input: crate::model::AwsElbLoadBalancerAccessLog) -> Self {
            self.access_log = Some(input);
            self
        }
        /// <p>Information about the access log configuration for the load balancer.</p>
        /// <p>If the access log is enabled, the load balancer captures detailed information about all requests. It delivers the information to a specified S3 bucket.</p>
        pub fn set_access_log(
            mut self,
            input: std::option::Option<crate::model::AwsElbLoadBalancerAccessLog>,
        ) -> Self {
            self.access_log = input;
            self
        }
        /// <p>Information about the connection draining configuration for the load balancer.</p>
        /// <p>If connection draining is enabled, the load balancer allows existing requests to complete before it shifts traffic away from a deregistered or unhealthy instance.</p>
        pub fn connection_draining(
            mut self,
            input: crate::model::AwsElbLoadBalancerConnectionDraining,
        ) -> Self {
            self.connection_draining = Some(input);
            self
        }
        /// <p>Information about the connection draining configuration for the load balancer.</p>
        /// <p>If connection draining is enabled, the load balancer allows existing requests to complete before it shifts traffic away from a deregistered or unhealthy instance.</p>
        pub fn set_connection_draining(
            mut self,
            input: std::option::Option<crate::model::AwsElbLoadBalancerConnectionDraining>,
        ) -> Self {
            self.connection_draining = input;
            self
        }
        /// <p>Connection settings for the load balancer.</p>
        /// <p>If an idle timeout is configured, the load balancer allows connections to remain idle for the specified duration. When a connection is idle, no data is sent over the connection.</p>
        pub fn connection_settings(
            mut self,
            input: crate::model::AwsElbLoadBalancerConnectionSettings,
        ) -> Self {
            self.connection_settings = Some(input);
            self
        }
        /// <p>Connection settings for the load balancer.</p>
        /// <p>If an idle timeout is configured, the load balancer allows connections to remain idle for the specified duration. When a connection is idle, no data is sent over the connection.</p>
        pub fn set_connection_settings(
            mut self,
            input: std::option::Option<crate::model::AwsElbLoadBalancerConnectionSettings>,
        ) -> Self {
            self.connection_settings = input;
            self
        }
        /// <p>Cross-zone load balancing settings for the load balancer.</p>
        /// <p>If cross-zone load balancing is enabled, the load balancer routes the request traffic evenly across all instances regardless of the Availability Zones.</p>
        pub fn cross_zone_load_balancing(
            mut self,
            input: crate::model::AwsElbLoadBalancerCrossZoneLoadBalancing,
        ) -> Self {
            self.cross_zone_load_balancing = Some(input);
            self
        }
        /// <p>Cross-zone load balancing settings for the load balancer.</p>
        /// <p>If cross-zone load balancing is enabled, the load balancer routes the request traffic evenly across all instances regardless of the Availability Zones.</p>
        pub fn set_cross_zone_load_balancing(
            mut self,
            input: std::option::Option<crate::model::AwsElbLoadBalancerCrossZoneLoadBalancing>,
        ) -> Self {
            self.cross_zone_load_balancing = input;
            self
        }
        /// Appends an item to `additional_attributes`.
        ///
        /// To override the contents of this collection use [`set_additional_attributes`](Self::set_additional_attributes).
        ///
        /// <p>Any additional attributes for a load balancer.</p>
        pub fn additional_attributes(
            mut self,
            input: crate::model::AwsElbLoadBalancerAdditionalAttribute,
        ) -> Self {
            let mut v = self.additional_attributes.unwrap_or_default();
            v.push(input);
            self.additional_attributes = Some(v);
            self
        }
        /// <p>Any additional attributes for a load balancer.</p>
        pub fn set_additional_attributes(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsElbLoadBalancerAdditionalAttribute>,
            >,
        ) -> Self {
            self.additional_attributes = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElbLoadBalancerAttributes`](crate::model::AwsElbLoadBalancerAttributes)
        pub fn build(self) -> crate::model::AwsElbLoadBalancerAttributes {
            crate::model::AwsElbLoadBalancerAttributes {
                access_log: self.access_log,
                connection_draining: self.connection_draining,
                connection_settings: self.connection_settings,
                cross_zone_load_balancing: self.cross_zone_load_balancing,
                additional_attributes: self.additional_attributes,
            }
        }
    }
}
impl AwsElbLoadBalancerAttributes {
    /// Creates a new builder-style object to manufacture [`AwsElbLoadBalancerAttributes`](crate::model::AwsElbLoadBalancerAttributes)
    pub fn builder() -> crate::model::aws_elb_load_balancer_attributes::Builder {
        crate::model::aws_elb_load_balancer_attributes::Builder::default()
    }
}

/// <p>Provides information about additional attributes for the load balancer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElbLoadBalancerAdditionalAttribute {
    /// <p>The name of the attribute.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The value of the attribute.</p>
    pub value: std::option::Option<std::string::String>,
}
impl AwsElbLoadBalancerAdditionalAttribute {
    /// <p>The name of the attribute.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The value of the attribute.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for AwsElbLoadBalancerAdditionalAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElbLoadBalancerAdditionalAttribute");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`AwsElbLoadBalancerAdditionalAttribute`](crate::model::AwsElbLoadBalancerAdditionalAttribute)
pub mod aws_elb_load_balancer_additional_attribute {

    /// A builder for [`AwsElbLoadBalancerAdditionalAttribute`](crate::model::AwsElbLoadBalancerAdditionalAttribute)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the attribute.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The name of the attribute.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value of the attribute.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the attribute.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElbLoadBalancerAdditionalAttribute`](crate::model::AwsElbLoadBalancerAdditionalAttribute)
        pub fn build(self) -> crate::model::AwsElbLoadBalancerAdditionalAttribute {
            crate::model::AwsElbLoadBalancerAdditionalAttribute {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl AwsElbLoadBalancerAdditionalAttribute {
    /// Creates a new builder-style object to manufacture [`AwsElbLoadBalancerAdditionalAttribute`](crate::model::AwsElbLoadBalancerAdditionalAttribute)
    pub fn builder() -> crate::model::aws_elb_load_balancer_additional_attribute::Builder {
        crate::model::aws_elb_load_balancer_additional_attribute::Builder::default()
    }
}

/// <p>Contains cross-zone load balancing settings for the load balancer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElbLoadBalancerCrossZoneLoadBalancing {
    /// <p>Indicates whether cross-zone load balancing is enabled for the load balancer.</p>
    pub enabled: bool,
}
impl AwsElbLoadBalancerCrossZoneLoadBalancing {
    /// <p>Indicates whether cross-zone load balancing is enabled for the load balancer.</p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
}
impl std::fmt::Debug for AwsElbLoadBalancerCrossZoneLoadBalancing {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElbLoadBalancerCrossZoneLoadBalancing");
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`AwsElbLoadBalancerCrossZoneLoadBalancing`](crate::model::AwsElbLoadBalancerCrossZoneLoadBalancing)
pub mod aws_elb_load_balancer_cross_zone_load_balancing {

    /// A builder for [`AwsElbLoadBalancerCrossZoneLoadBalancing`](crate::model::AwsElbLoadBalancerCrossZoneLoadBalancing)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Indicates whether cross-zone load balancing is enabled for the load balancer.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Indicates whether cross-zone load balancing is enabled for the load balancer.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElbLoadBalancerCrossZoneLoadBalancing`](crate::model::AwsElbLoadBalancerCrossZoneLoadBalancing)
        pub fn build(self) -> crate::model::AwsElbLoadBalancerCrossZoneLoadBalancing {
            crate::model::AwsElbLoadBalancerCrossZoneLoadBalancing {
                enabled: self.enabled.unwrap_or_default(),
            }
        }
    }
}
impl AwsElbLoadBalancerCrossZoneLoadBalancing {
    /// Creates a new builder-style object to manufacture [`AwsElbLoadBalancerCrossZoneLoadBalancing`](crate::model::AwsElbLoadBalancerCrossZoneLoadBalancing)
    pub fn builder() -> crate::model::aws_elb_load_balancer_cross_zone_load_balancing::Builder {
        crate::model::aws_elb_load_balancer_cross_zone_load_balancing::Builder::default()
    }
}

/// <p>Contains connection settings for the load balancer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElbLoadBalancerConnectionSettings {
    /// <p>The time, in seconds, that the connection can be idle (no data is sent over the connection) before it is closed by the load balancer.</p>
    pub idle_timeout: i32,
}
impl AwsElbLoadBalancerConnectionSettings {
    /// <p>The time, in seconds, that the connection can be idle (no data is sent over the connection) before it is closed by the load balancer.</p>
    pub fn idle_timeout(&self) -> i32 {
        self.idle_timeout
    }
}
impl std::fmt::Debug for AwsElbLoadBalancerConnectionSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElbLoadBalancerConnectionSettings");
        formatter.field("idle_timeout", &self.idle_timeout);
        formatter.finish()
    }
}
/// See [`AwsElbLoadBalancerConnectionSettings`](crate::model::AwsElbLoadBalancerConnectionSettings)
pub mod aws_elb_load_balancer_connection_settings {

    /// A builder for [`AwsElbLoadBalancerConnectionSettings`](crate::model::AwsElbLoadBalancerConnectionSettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) idle_timeout: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The time, in seconds, that the connection can be idle (no data is sent over the connection) before it is closed by the load balancer.</p>
        pub fn idle_timeout(mut self, input: i32) -> Self {
            self.idle_timeout = Some(input);
            self
        }
        /// <p>The time, in seconds, that the connection can be idle (no data is sent over the connection) before it is closed by the load balancer.</p>
        pub fn set_idle_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.idle_timeout = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElbLoadBalancerConnectionSettings`](crate::model::AwsElbLoadBalancerConnectionSettings)
        pub fn build(self) -> crate::model::AwsElbLoadBalancerConnectionSettings {
            crate::model::AwsElbLoadBalancerConnectionSettings {
                idle_timeout: self.idle_timeout.unwrap_or_default(),
            }
        }
    }
}
impl AwsElbLoadBalancerConnectionSettings {
    /// Creates a new builder-style object to manufacture [`AwsElbLoadBalancerConnectionSettings`](crate::model::AwsElbLoadBalancerConnectionSettings)
    pub fn builder() -> crate::model::aws_elb_load_balancer_connection_settings::Builder {
        crate::model::aws_elb_load_balancer_connection_settings::Builder::default()
    }
}

/// <p>Contains information about the connection draining configuration for the load balancer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElbLoadBalancerConnectionDraining {
    /// <p>Indicates whether connection draining is enabled for the load balancer.</p>
    pub enabled: bool,
    /// <p>The maximum time, in seconds, to keep the existing connections open before deregistering the instances.</p>
    pub timeout: i32,
}
impl AwsElbLoadBalancerConnectionDraining {
    /// <p>Indicates whether connection draining is enabled for the load balancer.</p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
    /// <p>The maximum time, in seconds, to keep the existing connections open before deregistering the instances.</p>
    pub fn timeout(&self) -> i32 {
        self.timeout
    }
}
impl std::fmt::Debug for AwsElbLoadBalancerConnectionDraining {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElbLoadBalancerConnectionDraining");
        formatter.field("enabled", &self.enabled);
        formatter.field("timeout", &self.timeout);
        formatter.finish()
    }
}
/// See [`AwsElbLoadBalancerConnectionDraining`](crate::model::AwsElbLoadBalancerConnectionDraining)
pub mod aws_elb_load_balancer_connection_draining {

    /// A builder for [`AwsElbLoadBalancerConnectionDraining`](crate::model::AwsElbLoadBalancerConnectionDraining)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) timeout: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Indicates whether connection draining is enabled for the load balancer.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Indicates whether connection draining is enabled for the load balancer.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The maximum time, in seconds, to keep the existing connections open before deregistering the instances.</p>
        pub fn timeout(mut self, input: i32) -> Self {
            self.timeout = Some(input);
            self
        }
        /// <p>The maximum time, in seconds, to keep the existing connections open before deregistering the instances.</p>
        pub fn set_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.timeout = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElbLoadBalancerConnectionDraining`](crate::model::AwsElbLoadBalancerConnectionDraining)
        pub fn build(self) -> crate::model::AwsElbLoadBalancerConnectionDraining {
            crate::model::AwsElbLoadBalancerConnectionDraining {
                enabled: self.enabled.unwrap_or_default(),
                timeout: self.timeout.unwrap_or_default(),
            }
        }
    }
}
impl AwsElbLoadBalancerConnectionDraining {
    /// Creates a new builder-style object to manufacture [`AwsElbLoadBalancerConnectionDraining`](crate::model::AwsElbLoadBalancerConnectionDraining)
    pub fn builder() -> crate::model::aws_elb_load_balancer_connection_draining::Builder {
        crate::model::aws_elb_load_balancer_connection_draining::Builder::default()
    }
}

/// <p>Contains information about the access log configuration for the load balancer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElbLoadBalancerAccessLog {
    /// <p>The interval in minutes for publishing the access logs.</p>
    /// <p>You can publish access logs either every 5 minutes or every 60 minutes.</p>
    pub emit_interval: i32,
    /// <p>Indicates whether access logs are enabled for the load balancer.</p>
    pub enabled: bool,
    /// <p>The name of the S3 bucket where the access logs are stored.</p>
    pub s3_bucket_name: std::option::Option<std::string::String>,
    /// <p>The logical hierarchy that was created for the S3 bucket.</p>
    /// <p>If a prefix is not provided, the log is placed at the root level of the bucket.</p>
    pub s3_bucket_prefix: std::option::Option<std::string::String>,
}
impl AwsElbLoadBalancerAccessLog {
    /// <p>The interval in minutes for publishing the access logs.</p>
    /// <p>You can publish access logs either every 5 minutes or every 60 minutes.</p>
    pub fn emit_interval(&self) -> i32 {
        self.emit_interval
    }
    /// <p>Indicates whether access logs are enabled for the load balancer.</p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
    /// <p>The name of the S3 bucket where the access logs are stored.</p>
    pub fn s3_bucket_name(&self) -> std::option::Option<&str> {
        self.s3_bucket_name.as_deref()
    }
    /// <p>The logical hierarchy that was created for the S3 bucket.</p>
    /// <p>If a prefix is not provided, the log is placed at the root level of the bucket.</p>
    pub fn s3_bucket_prefix(&self) -> std::option::Option<&str> {
        self.s3_bucket_prefix.as_deref()
    }
}
impl std::fmt::Debug for AwsElbLoadBalancerAccessLog {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElbLoadBalancerAccessLog");
        formatter.field("emit_interval", &self.emit_interval);
        formatter.field("enabled", &self.enabled);
        formatter.field("s3_bucket_name", &self.s3_bucket_name);
        formatter.field("s3_bucket_prefix", &self.s3_bucket_prefix);
        formatter.finish()
    }
}
/// See [`AwsElbLoadBalancerAccessLog`](crate::model::AwsElbLoadBalancerAccessLog)
pub mod aws_elb_load_balancer_access_log {

    /// A builder for [`AwsElbLoadBalancerAccessLog`](crate::model::AwsElbLoadBalancerAccessLog)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) emit_interval: std::option::Option<i32>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) s3_bucket_name: std::option::Option<std::string::String>,
        pub(crate) s3_bucket_prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The interval in minutes for publishing the access logs.</p>
        /// <p>You can publish access logs either every 5 minutes or every 60 minutes.</p>
        pub fn emit_interval(mut self, input: i32) -> Self {
            self.emit_interval = Some(input);
            self
        }
        /// <p>The interval in minutes for publishing the access logs.</p>
        /// <p>You can publish access logs either every 5 minutes or every 60 minutes.</p>
        pub fn set_emit_interval(mut self, input: std::option::Option<i32>) -> Self {
            self.emit_interval = input;
            self
        }
        /// <p>Indicates whether access logs are enabled for the load balancer.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Indicates whether access logs are enabled for the load balancer.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The name of the S3 bucket where the access logs are stored.</p>
        pub fn s3_bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket_name = Some(input.into());
            self
        }
        /// <p>The name of the S3 bucket where the access logs are stored.</p>
        pub fn set_s3_bucket_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_bucket_name = input;
            self
        }
        /// <p>The logical hierarchy that was created for the S3 bucket.</p>
        /// <p>If a prefix is not provided, the log is placed at the root level of the bucket.</p>
        pub fn s3_bucket_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket_prefix = Some(input.into());
            self
        }
        /// <p>The logical hierarchy that was created for the S3 bucket.</p>
        /// <p>If a prefix is not provided, the log is placed at the root level of the bucket.</p>
        pub fn set_s3_bucket_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_bucket_prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElbLoadBalancerAccessLog`](crate::model::AwsElbLoadBalancerAccessLog)
        pub fn build(self) -> crate::model::AwsElbLoadBalancerAccessLog {
            crate::model::AwsElbLoadBalancerAccessLog {
                emit_interval: self.emit_interval.unwrap_or_default(),
                enabled: self.enabled.unwrap_or_default(),
                s3_bucket_name: self.s3_bucket_name,
                s3_bucket_prefix: self.s3_bucket_prefix,
            }
        }
    }
}
impl AwsElbLoadBalancerAccessLog {
    /// Creates a new builder-style object to manufacture [`AwsElbLoadBalancerAccessLog`](crate::model::AwsElbLoadBalancerAccessLog)
    pub fn builder() -> crate::model::aws_elb_load_balancer_access_log::Builder {
        crate::model::aws_elb_load_balancer_access_log::Builder::default()
    }
}

/// <p>Lists the policies that are enabled for a load balancer listener.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElbLoadBalancerListenerDescription {
    /// <p>Information about the listener.</p>
    pub listener: std::option::Option<crate::model::AwsElbLoadBalancerListener>,
    /// <p>The policies enabled for the listener.</p>
    pub policy_names: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AwsElbLoadBalancerListenerDescription {
    /// <p>Information about the listener.</p>
    pub fn listener(&self) -> std::option::Option<&crate::model::AwsElbLoadBalancerListener> {
        self.listener.as_ref()
    }
    /// <p>The policies enabled for the listener.</p>
    pub fn policy_names(&self) -> std::option::Option<&[std::string::String]> {
        self.policy_names.as_deref()
    }
}
impl std::fmt::Debug for AwsElbLoadBalancerListenerDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElbLoadBalancerListenerDescription");
        formatter.field("listener", &self.listener);
        formatter.field("policy_names", &self.policy_names);
        formatter.finish()
    }
}
/// See [`AwsElbLoadBalancerListenerDescription`](crate::model::AwsElbLoadBalancerListenerDescription)
pub mod aws_elb_load_balancer_listener_description {

    /// A builder for [`AwsElbLoadBalancerListenerDescription`](crate::model::AwsElbLoadBalancerListenerDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) listener: std::option::Option<crate::model::AwsElbLoadBalancerListener>,
        pub(crate) policy_names: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>Information about the listener.</p>
        pub fn listener(mut self, input: crate::model::AwsElbLoadBalancerListener) -> Self {
            self.listener = Some(input);
            self
        }
        /// <p>Information about the listener.</p>
        pub fn set_listener(
            mut self,
            input: std::option::Option<crate::model::AwsElbLoadBalancerListener>,
        ) -> Self {
            self.listener = input;
            self
        }
        /// Appends an item to `policy_names`.
        ///
        /// To override the contents of this collection use [`set_policy_names`](Self::set_policy_names).
        ///
        /// <p>The policies enabled for the listener.</p>
        pub fn policy_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.policy_names.unwrap_or_default();
            v.push(input.into());
            self.policy_names = Some(v);
            self
        }
        /// <p>The policies enabled for the listener.</p>
        pub fn set_policy_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.policy_names = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElbLoadBalancerListenerDescription`](crate::model::AwsElbLoadBalancerListenerDescription)
        pub fn build(self) -> crate::model::AwsElbLoadBalancerListenerDescription {
            crate::model::AwsElbLoadBalancerListenerDescription {
                listener: self.listener,
                policy_names: self.policy_names,
            }
        }
    }
}
impl AwsElbLoadBalancerListenerDescription {
    /// Creates a new builder-style object to manufacture [`AwsElbLoadBalancerListenerDescription`](crate::model::AwsElbLoadBalancerListenerDescription)
    pub fn builder() -> crate::model::aws_elb_load_balancer_listener_description::Builder {
        crate::model::aws_elb_load_balancer_listener_description::Builder::default()
    }
}

/// <p>Information about a load balancer listener.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElbLoadBalancerListener {
    /// <p>The port on which the instance is listening.</p>
    pub instance_port: i32,
    /// <p>The protocol to use to route traffic to instances.</p>
    /// <p>Valid values: <code>HTTP</code> | <code>HTTPS</code> | <code>TCP</code> | <code>SSL</code> </p>
    pub instance_protocol: std::option::Option<std::string::String>,
    /// <p>The port on which the load balancer is listening.</p>
    /// <p>On EC2-VPC, you can specify any port from the range 1-65535.</p>
    /// <p>On EC2-Classic, you can specify any port from the following list: 25, 80, 443, 465, 587, 1024-65535.</p>
    pub load_balancer_port: i32,
    /// <p>The load balancer transport protocol to use for routing.</p>
    /// <p>Valid values: <code>HTTP</code> | <code>HTTPS</code> | <code>TCP</code> | <code>SSL</code> </p>
    pub protocol: std::option::Option<std::string::String>,
    /// <p>The ARN of the server certificate.</p>
    pub ssl_certificate_id: std::option::Option<std::string::String>,
}
impl AwsElbLoadBalancerListener {
    /// <p>The port on which the instance is listening.</p>
    pub fn instance_port(&self) -> i32 {
        self.instance_port
    }
    /// <p>The protocol to use to route traffic to instances.</p>
    /// <p>Valid values: <code>HTTP</code> | <code>HTTPS</code> | <code>TCP</code> | <code>SSL</code> </p>
    pub fn instance_protocol(&self) -> std::option::Option<&str> {
        self.instance_protocol.as_deref()
    }
    /// <p>The port on which the load balancer is listening.</p>
    /// <p>On EC2-VPC, you can specify any port from the range 1-65535.</p>
    /// <p>On EC2-Classic, you can specify any port from the following list: 25, 80, 443, 465, 587, 1024-65535.</p>
    pub fn load_balancer_port(&self) -> i32 {
        self.load_balancer_port
    }
    /// <p>The load balancer transport protocol to use for routing.</p>
    /// <p>Valid values: <code>HTTP</code> | <code>HTTPS</code> | <code>TCP</code> | <code>SSL</code> </p>
    pub fn protocol(&self) -> std::option::Option<&str> {
        self.protocol.as_deref()
    }
    /// <p>The ARN of the server certificate.</p>
    pub fn ssl_certificate_id(&self) -> std::option::Option<&str> {
        self.ssl_certificate_id.as_deref()
    }
}
impl std::fmt::Debug for AwsElbLoadBalancerListener {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElbLoadBalancerListener");
        formatter.field("instance_port", &self.instance_port);
        formatter.field("instance_protocol", &self.instance_protocol);
        formatter.field("load_balancer_port", &self.load_balancer_port);
        formatter.field("protocol", &self.protocol);
        formatter.field("ssl_certificate_id", &self.ssl_certificate_id);
        formatter.finish()
    }
}
/// See [`AwsElbLoadBalancerListener`](crate::model::AwsElbLoadBalancerListener)
pub mod aws_elb_load_balancer_listener {

    /// A builder for [`AwsElbLoadBalancerListener`](crate::model::AwsElbLoadBalancerListener)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_port: std::option::Option<i32>,
        pub(crate) instance_protocol: std::option::Option<std::string::String>,
        pub(crate) load_balancer_port: std::option::Option<i32>,
        pub(crate) protocol: std::option::Option<std::string::String>,
        pub(crate) ssl_certificate_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The port on which the instance is listening.</p>
        pub fn instance_port(mut self, input: i32) -> Self {
            self.instance_port = Some(input);
            self
        }
        /// <p>The port on which the instance is listening.</p>
        pub fn set_instance_port(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_port = input;
            self
        }
        /// <p>The protocol to use to route traffic to instances.</p>
        /// <p>Valid values: <code>HTTP</code> | <code>HTTPS</code> | <code>TCP</code> | <code>SSL</code> </p>
        pub fn instance_protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_protocol = Some(input.into());
            self
        }
        /// <p>The protocol to use to route traffic to instances.</p>
        /// <p>Valid values: <code>HTTP</code> | <code>HTTPS</code> | <code>TCP</code> | <code>SSL</code> </p>
        pub fn set_instance_protocol(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_protocol = input;
            self
        }
        /// <p>The port on which the load balancer is listening.</p>
        /// <p>On EC2-VPC, you can specify any port from the range 1-65535.</p>
        /// <p>On EC2-Classic, you can specify any port from the following list: 25, 80, 443, 465, 587, 1024-65535.</p>
        pub fn load_balancer_port(mut self, input: i32) -> Self {
            self.load_balancer_port = Some(input);
            self
        }
        /// <p>The port on which the load balancer is listening.</p>
        /// <p>On EC2-VPC, you can specify any port from the range 1-65535.</p>
        /// <p>On EC2-Classic, you can specify any port from the following list: 25, 80, 443, 465, 587, 1024-65535.</p>
        pub fn set_load_balancer_port(mut self, input: std::option::Option<i32>) -> Self {
            self.load_balancer_port = input;
            self
        }
        /// <p>The load balancer transport protocol to use for routing.</p>
        /// <p>Valid values: <code>HTTP</code> | <code>HTTPS</code> | <code>TCP</code> | <code>SSL</code> </p>
        pub fn protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.protocol = Some(input.into());
            self
        }
        /// <p>The load balancer transport protocol to use for routing.</p>
        /// <p>Valid values: <code>HTTP</code> | <code>HTTPS</code> | <code>TCP</code> | <code>SSL</code> </p>
        pub fn set_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.protocol = input;
            self
        }
        /// <p>The ARN of the server certificate.</p>
        pub fn ssl_certificate_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ssl_certificate_id = Some(input.into());
            self
        }
        /// <p>The ARN of the server certificate.</p>
        pub fn set_ssl_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ssl_certificate_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElbLoadBalancerListener`](crate::model::AwsElbLoadBalancerListener)
        pub fn build(self) -> crate::model::AwsElbLoadBalancerListener {
            crate::model::AwsElbLoadBalancerListener {
                instance_port: self.instance_port.unwrap_or_default(),
                instance_protocol: self.instance_protocol,
                load_balancer_port: self.load_balancer_port.unwrap_or_default(),
                protocol: self.protocol,
                ssl_certificate_id: self.ssl_certificate_id,
            }
        }
    }
}
impl AwsElbLoadBalancerListener {
    /// Creates a new builder-style object to manufacture [`AwsElbLoadBalancerListener`](crate::model::AwsElbLoadBalancerListener)
    pub fn builder() -> crate::model::aws_elb_load_balancer_listener::Builder {
        crate::model::aws_elb_load_balancer_listener::Builder::default()
    }
}

/// <p>Provides information about an EC2 instance for a load balancer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElbLoadBalancerInstance {
    /// <p>The instance identifier.</p>
    pub instance_id: std::option::Option<std::string::String>,
}
impl AwsElbLoadBalancerInstance {
    /// <p>The instance identifier.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
}
impl std::fmt::Debug for AwsElbLoadBalancerInstance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElbLoadBalancerInstance");
        formatter.field("instance_id", &self.instance_id);
        formatter.finish()
    }
}
/// See [`AwsElbLoadBalancerInstance`](crate::model::AwsElbLoadBalancerInstance)
pub mod aws_elb_load_balancer_instance {

    /// A builder for [`AwsElbLoadBalancerInstance`](crate::model::AwsElbLoadBalancerInstance)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The instance identifier.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The instance identifier.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElbLoadBalancerInstance`](crate::model::AwsElbLoadBalancerInstance)
        pub fn build(self) -> crate::model::AwsElbLoadBalancerInstance {
            crate::model::AwsElbLoadBalancerInstance {
                instance_id: self.instance_id,
            }
        }
    }
}
impl AwsElbLoadBalancerInstance {
    /// Creates a new builder-style object to manufacture [`AwsElbLoadBalancerInstance`](crate::model::AwsElbLoadBalancerInstance)
    pub fn builder() -> crate::model::aws_elb_load_balancer_instance::Builder {
        crate::model::aws_elb_load_balancer_instance::Builder::default()
    }
}

/// <p>Contains information about the health checks that are conducted on the load balancer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElbLoadBalancerHealthCheck {
    /// <p>The number of consecutive health check successes required before the instance is moved to the Healthy state.</p>
    pub healthy_threshold: i32,
    /// <p>The approximate interval, in seconds, between health checks of an individual instance.</p>
    pub interval: i32,
    /// <p>The instance that is being checked. The target specifies the protocol and port. The available protocols are TCP, SSL, HTTP, and HTTPS. The range of valid ports is 1 through 65535.</p>
    /// <p>For the HTTP and HTTPS protocols, the target also specifies the ping path.</p>
    /// <p>For the TCP protocol, the target is specified as <code>TCP: <i>
    /// <port></port></i> </code>.</p>
    /// <p>For the SSL protocol, the target is specified as <code>SSL.<i>
    /// <port></port></i> </code>.</p>
    /// <p>For the HTTP and HTTPS protocols, the target is specified as <code> <i>
    /// <protocol></protocol></i>:<i>
    /// <port></port></i>/<i>
    /// <path to ping></path></i> </code>.</p>
    pub target: std::option::Option<std::string::String>,
    /// <p>The amount of time, in seconds, during which no response means a failed health check.</p>
    pub timeout: i32,
    /// <p>The number of consecutive health check failures that must occur before the instance is moved to the Unhealthy state.</p>
    pub unhealthy_threshold: i32,
}
impl AwsElbLoadBalancerHealthCheck {
    /// <p>The number of consecutive health check successes required before the instance is moved to the Healthy state.</p>
    pub fn healthy_threshold(&self) -> i32 {
        self.healthy_threshold
    }
    /// <p>The approximate interval, in seconds, between health checks of an individual instance.</p>
    pub fn interval(&self) -> i32 {
        self.interval
    }
    /// <p>The instance that is being checked. The target specifies the protocol and port. The available protocols are TCP, SSL, HTTP, and HTTPS. The range of valid ports is 1 through 65535.</p>
    /// <p>For the HTTP and HTTPS protocols, the target also specifies the ping path.</p>
    /// <p>For the TCP protocol, the target is specified as <code>TCP: <i>
    /// <port></port></i> </code>.</p>
    /// <p>For the SSL protocol, the target is specified as <code>SSL.<i>
    /// <port></port></i> </code>.</p>
    /// <p>For the HTTP and HTTPS protocols, the target is specified as <code> <i>
    /// <protocol></protocol></i>:<i>
    /// <port></port></i>/<i>
    /// <path to ping></path></i> </code>.</p>
    pub fn target(&self) -> std::option::Option<&str> {
        self.target.as_deref()
    }
    /// <p>The amount of time, in seconds, during which no response means a failed health check.</p>
    pub fn timeout(&self) -> i32 {
        self.timeout
    }
    /// <p>The number of consecutive health check failures that must occur before the instance is moved to the Unhealthy state.</p>
    pub fn unhealthy_threshold(&self) -> i32 {
        self.unhealthy_threshold
    }
}
impl std::fmt::Debug for AwsElbLoadBalancerHealthCheck {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElbLoadBalancerHealthCheck");
        formatter.field("healthy_threshold", &self.healthy_threshold);
        formatter.field("interval", &self.interval);
        formatter.field("target", &self.target);
        formatter.field("timeout", &self.timeout);
        formatter.field("unhealthy_threshold", &self.unhealthy_threshold);
        formatter.finish()
    }
}
/// See [`AwsElbLoadBalancerHealthCheck`](crate::model::AwsElbLoadBalancerHealthCheck)
pub mod aws_elb_load_balancer_health_check {

    /// A builder for [`AwsElbLoadBalancerHealthCheck`](crate::model::AwsElbLoadBalancerHealthCheck)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) healthy_threshold: std::option::Option<i32>,
        pub(crate) interval: std::option::Option<i32>,
        pub(crate) target: std::option::Option<std::string::String>,
        pub(crate) timeout: std::option::Option<i32>,
        pub(crate) unhealthy_threshold: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The number of consecutive health check successes required before the instance is moved to the Healthy state.</p>
        pub fn healthy_threshold(mut self, input: i32) -> Self {
            self.healthy_threshold = Some(input);
            self
        }
        /// <p>The number of consecutive health check successes required before the instance is moved to the Healthy state.</p>
        pub fn set_healthy_threshold(mut self, input: std::option::Option<i32>) -> Self {
            self.healthy_threshold = input;
            self
        }
        /// <p>The approximate interval, in seconds, between health checks of an individual instance.</p>
        pub fn interval(mut self, input: i32) -> Self {
            self.interval = Some(input);
            self
        }
        /// <p>The approximate interval, in seconds, between health checks of an individual instance.</p>
        pub fn set_interval(mut self, input: std::option::Option<i32>) -> Self {
            self.interval = input;
            self
        }
        /// <p>The instance that is being checked. The target specifies the protocol and port. The available protocols are TCP, SSL, HTTP, and HTTPS. The range of valid ports is 1 through 65535.</p>
        /// <p>For the HTTP and HTTPS protocols, the target also specifies the ping path.</p>
        /// <p>For the TCP protocol, the target is specified as <code>TCP: <i>
        /// <port></port></i> </code>.</p>
        /// <p>For the SSL protocol, the target is specified as <code>SSL.<i>
        /// <port></port></i> </code>.</p>
        /// <p>For the HTTP and HTTPS protocols, the target is specified as <code> <i>
        /// <protocol></protocol></i>:<i>
        /// <port></port></i>/<i>
        /// <path to ping></path></i> </code>.</p>
        pub fn target(mut self, input: impl Into<std::string::String>) -> Self {
            self.target = Some(input.into());
            self
        }
        /// <p>The instance that is being checked. The target specifies the protocol and port. The available protocols are TCP, SSL, HTTP, and HTTPS. The range of valid ports is 1 through 65535.</p>
        /// <p>For the HTTP and HTTPS protocols, the target also specifies the ping path.</p>
        /// <p>For the TCP protocol, the target is specified as <code>TCP: <i>
        /// <port></port></i> </code>.</p>
        /// <p>For the SSL protocol, the target is specified as <code>SSL.<i>
        /// <port></port></i> </code>.</p>
        /// <p>For the HTTP and HTTPS protocols, the target is specified as <code> <i>
        /// <protocol></protocol></i>:<i>
        /// <port></port></i>/<i>
        /// <path to ping></path></i> </code>.</p>
        pub fn set_target(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target = input;
            self
        }
        /// <p>The amount of time, in seconds, during which no response means a failed health check.</p>
        pub fn timeout(mut self, input: i32) -> Self {
            self.timeout = Some(input);
            self
        }
        /// <p>The amount of time, in seconds, during which no response means a failed health check.</p>
        pub fn set_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.timeout = input;
            self
        }
        /// <p>The number of consecutive health check failures that must occur before the instance is moved to the Unhealthy state.</p>
        pub fn unhealthy_threshold(mut self, input: i32) -> Self {
            self.unhealthy_threshold = Some(input);
            self
        }
        /// <p>The number of consecutive health check failures that must occur before the instance is moved to the Unhealthy state.</p>
        pub fn set_unhealthy_threshold(mut self, input: std::option::Option<i32>) -> Self {
            self.unhealthy_threshold = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElbLoadBalancerHealthCheck`](crate::model::AwsElbLoadBalancerHealthCheck)
        pub fn build(self) -> crate::model::AwsElbLoadBalancerHealthCheck {
            crate::model::AwsElbLoadBalancerHealthCheck {
                healthy_threshold: self.healthy_threshold.unwrap_or_default(),
                interval: self.interval.unwrap_or_default(),
                target: self.target,
                timeout: self.timeout.unwrap_or_default(),
                unhealthy_threshold: self.unhealthy_threshold.unwrap_or_default(),
            }
        }
    }
}
impl AwsElbLoadBalancerHealthCheck {
    /// Creates a new builder-style object to manufacture [`AwsElbLoadBalancerHealthCheck`](crate::model::AwsElbLoadBalancerHealthCheck)
    pub fn builder() -> crate::model::aws_elb_load_balancer_health_check::Builder {
        crate::model::aws_elb_load_balancer_health_check::Builder::default()
    }
}

/// <p>Provides information about the configuration of an EC2 instance for the load balancer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElbLoadBalancerBackendServerDescription {
    /// <p>The port on which the EC2 instance is listening.</p>
    pub instance_port: i32,
    /// <p>The names of the policies that are enabled for the EC2 instance.</p>
    pub policy_names: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AwsElbLoadBalancerBackendServerDescription {
    /// <p>The port on which the EC2 instance is listening.</p>
    pub fn instance_port(&self) -> i32 {
        self.instance_port
    }
    /// <p>The names of the policies that are enabled for the EC2 instance.</p>
    pub fn policy_names(&self) -> std::option::Option<&[std::string::String]> {
        self.policy_names.as_deref()
    }
}
impl std::fmt::Debug for AwsElbLoadBalancerBackendServerDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElbLoadBalancerBackendServerDescription");
        formatter.field("instance_port", &self.instance_port);
        formatter.field("policy_names", &self.policy_names);
        formatter.finish()
    }
}
/// See [`AwsElbLoadBalancerBackendServerDescription`](crate::model::AwsElbLoadBalancerBackendServerDescription)
pub mod aws_elb_load_balancer_backend_server_description {

    /// A builder for [`AwsElbLoadBalancerBackendServerDescription`](crate::model::AwsElbLoadBalancerBackendServerDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_port: std::option::Option<i32>,
        pub(crate) policy_names: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The port on which the EC2 instance is listening.</p>
        pub fn instance_port(mut self, input: i32) -> Self {
            self.instance_port = Some(input);
            self
        }
        /// <p>The port on which the EC2 instance is listening.</p>
        pub fn set_instance_port(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_port = input;
            self
        }
        /// Appends an item to `policy_names`.
        ///
        /// To override the contents of this collection use [`set_policy_names`](Self::set_policy_names).
        ///
        /// <p>The names of the policies that are enabled for the EC2 instance.</p>
        pub fn policy_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.policy_names.unwrap_or_default();
            v.push(input.into());
            self.policy_names = Some(v);
            self
        }
        /// <p>The names of the policies that are enabled for the EC2 instance.</p>
        pub fn set_policy_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.policy_names = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElbLoadBalancerBackendServerDescription`](crate::model::AwsElbLoadBalancerBackendServerDescription)
        pub fn build(self) -> crate::model::AwsElbLoadBalancerBackendServerDescription {
            crate::model::AwsElbLoadBalancerBackendServerDescription {
                instance_port: self.instance_port.unwrap_or_default(),
                policy_names: self.policy_names,
            }
        }
    }
}
impl AwsElbLoadBalancerBackendServerDescription {
    /// Creates a new builder-style object to manufacture [`AwsElbLoadBalancerBackendServerDescription`](crate::model::AwsElbLoadBalancerBackendServerDescription)
    pub fn builder() -> crate::model::aws_elb_load_balancer_backend_server_description::Builder {
        crate::model::aws_elb_load_balancer_backend_server_description::Builder::default()
    }
}

/// <p>Details about an Amazon Redshift cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRedshiftClusterDetails {
    /// <p>Indicates whether major version upgrades are applied automatically to the cluster during the maintenance window.</p>
    pub allow_version_upgrade: bool,
    /// <p>The number of days that automatic cluster snapshots are retained.</p>
    pub automated_snapshot_retention_period: i32,
    /// <p>The name of the Availability Zone in which the cluster is located.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The availability status of the cluster for queries. Possible values are the following:</p>
    /// <ul>
    /// <li> <p> <code>Available</code> - The cluster is available for queries.</p> </li>
    /// <li> <p> <code>Unavailable</code> - The cluster is not available for queries.</p> </li>
    /// <li> <p> <code>Maintenance</code> - The cluster is intermittently available for queries due to maintenance activities.</p> </li>
    /// <li> <p> <code>Modifying</code> -The cluster is intermittently available for queries due to changes that modify the cluster.</p> </li>
    /// <li> <p> <code>Failed</code> - The cluster failed and is not available for queries.</p> </li>
    /// </ul>
    pub cluster_availability_status: std::option::Option<std::string::String>,
    /// <p>Indicates when the cluster was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub cluster_create_time: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the cluster.</p>
    pub cluster_identifier: std::option::Option<std::string::String>,
    /// <p>The nodes in the cluster.</p>
    pub cluster_nodes:
        std::option::Option<std::vec::Vec<crate::model::AwsRedshiftClusterClusterNode>>,
    /// <p>The list of cluster parameter groups that are associated with this cluster.</p>
    pub cluster_parameter_groups:
        std::option::Option<std::vec::Vec<crate::model::AwsRedshiftClusterClusterParameterGroup>>,
    /// <p>The public key for the cluster.</p>
    pub cluster_public_key: std::option::Option<std::string::String>,
    /// <p>The specific revision number of the database in the cluster.</p>
    pub cluster_revision_number: std::option::Option<std::string::String>,
    /// <p>A list of cluster security groups that are associated with the cluster.</p>
    pub cluster_security_groups:
        std::option::Option<std::vec::Vec<crate::model::AwsRedshiftClusterClusterSecurityGroup>>,
    /// <p>Information about the destination Region and retention period for the cross-Region snapshot copy.</p>
    pub cluster_snapshot_copy_status:
        std::option::Option<crate::model::AwsRedshiftClusterClusterSnapshotCopyStatus>,
    /// <p>The current status of the cluster.</p>
    /// <p>Valid values: <code>available</code> | <code>available, prep-for-resize</code> | <code>available, resize-cleanup</code> |<code> cancelling-resize</code> | <code>creating</code> | <code>deleting</code> | <code>final-snapshot</code> | <code>hardware-failure</code> | <code>incompatible-hsm</code> |<code> incompatible-network</code> | <code>incompatible-parameters</code> | <code>incompatible-restore</code> | <code>modifying</code> | <code>paused</code> | <code>rebooting</code> | <code>renaming</code> | <code>resizing</code> | <code>rotating-keys</code> | <code>storage-full</code> | <code>updating-hsm</code> </p>
    pub cluster_status: std::option::Option<std::string::String>,
    /// <p>The name of the subnet group that is associated with the cluster. This parameter is valid only when the cluster is in a VPC.</p>
    pub cluster_subnet_group_name: std::option::Option<std::string::String>,
    /// <p>The version ID of the Amazon Redshift engine that runs on the cluster.</p>
    pub cluster_version: std::option::Option<std::string::String>,
    /// <p>The name of the initial database that was created when the cluster was created.</p>
    /// <p>The same name is returned for the life of the cluster.</p>
    /// <p>If an initial database is not specified, a database named <code>devdev</code> is created by default.</p>
    pub db_name: std::option::Option<std::string::String>,
    /// <p>List of time windows during which maintenance was deferred.</p>
    pub deferred_maintenance_windows: std::option::Option<
        std::vec::Vec<crate::model::AwsRedshiftClusterDeferredMaintenanceWindow>,
    >,
    /// <p>Information about the status of the Elastic IP (EIP) address.</p>
    pub elastic_ip_status: std::option::Option<crate::model::AwsRedshiftClusterElasticIpStatus>,
    /// <p>The number of nodes that you can use the elastic resize method to resize the cluster to.</p>
    pub elastic_resize_number_of_node_options: std::option::Option<std::string::String>,
    /// <p>Indicates whether the data in the cluster is encrypted at rest.</p>
    pub encrypted: bool,
    /// <p>The connection endpoint.</p>
    pub endpoint: std::option::Option<crate::model::AwsRedshiftClusterEndpoint>,
    /// <p>Indicates whether to create the cluster with enhanced VPC routing enabled.</p>
    pub enhanced_vpc_routing: bool,
    /// <p>Indicates when the next snapshot is expected to be taken. The cluster must have a valid snapshot schedule and have backups enabled.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub expected_next_snapshot_schedule_time: std::option::Option<std::string::String>,
    /// <p>The status of the next expected snapshot.</p>
    /// <p>Valid values: <code>OnTrack</code> | <code>Pending</code> </p>
    pub expected_next_snapshot_schedule_time_status: std::option::Option<std::string::String>,
    /// <p>Information about whether the Amazon Redshift cluster finished applying any changes to hardware security module (HSM) settings that were specified in a modify cluster command.</p>
    pub hsm_status: std::option::Option<crate::model::AwsRedshiftClusterHsmStatus>,
    /// <p>A list of IAM roles that the cluster can use to access other Amazon Web Services services.</p>
    pub iam_roles: std::option::Option<std::vec::Vec<crate::model::AwsRedshiftClusterIamRole>>,
    /// <p>The identifier of the KMS encryption key that is used to encrypt data in the cluster.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The name of the maintenance track for the cluster.</p>
    pub maintenance_track_name: std::option::Option<std::string::String>,
    /// <p>The default number of days to retain a manual snapshot.</p>
    /// <p>If the value is <code>-1</code>, the snapshot is retained indefinitely.</p>
    /// <p>This setting doesn't change the retention period of existing snapshots.</p>
    /// <p>Valid values: Either <code>-1</code> or an integer between 1 and 3,653</p>
    pub manual_snapshot_retention_period: i32,
    /// <p>The master user name for the cluster. This name is used to connect to the database that is specified in as the value of <code>DBName</code>.</p>
    pub master_username: std::option::Option<std::string::String>,
    /// <p>Indicates the start of the next maintenance window.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub next_maintenance_window_start_time: std::option::Option<std::string::String>,
    /// <p>The node type for the nodes in the cluster.</p>
    pub node_type: std::option::Option<std::string::String>,
    /// <p>The number of compute nodes in the cluster.</p>
    pub number_of_nodes: i32,
    /// <p>A list of cluster operations that are waiting to start.</p>
    pub pending_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of changes to the cluster that are currently pending.</p>
    pub pending_modified_values:
        std::option::Option<crate::model::AwsRedshiftClusterPendingModifiedValues>,
    /// <p>The weekly time range, in Universal Coordinated Time (UTC), during which system maintenance can occur.</p>
    /// <p>Format: <code> <i>
    /// <day></day></i>:HH:MM-<i>
    /// <day></day></i>:HH:MM</code> </p>
    /// <p>For the day values, use <code>mon</code> | <code>tue</code> | <code>wed</code> | <code>thu</code> | <code>fri</code> | <code>sat</code> | <code>sun</code> </p>
    /// <p>For example, <code>sun:09:32-sun:10:02</code> </p>
    pub preferred_maintenance_window: std::option::Option<std::string::String>,
    /// <p>Whether the cluster can be accessed from a public network.</p>
    pub publicly_accessible: bool,
    /// <p>Information about the resize operation for the cluster.</p>
    pub resize_info: std::option::Option<crate::model::AwsRedshiftClusterResizeInfo>,
    /// <p>Information about the status of a cluster restore action. Only applies to a cluster that was created by restoring a snapshot.</p>
    pub restore_status: std::option::Option<crate::model::AwsRedshiftClusterRestoreStatus>,
    /// <p>A unique identifier for the cluster snapshot schedule.</p>
    pub snapshot_schedule_identifier: std::option::Option<std::string::String>,
    /// <p>The current state of the cluster snapshot schedule.</p>
    /// <p>Valid values: <code>MODIFYING</code> | <code>ACTIVE</code> | <code>FAILED</code> </p>
    pub snapshot_schedule_state: std::option::Option<std::string::String>,
    /// <p>The identifier of the VPC that the cluster is in, if the cluster is in a VPC.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The list of VPC security groups that the cluster belongs to, if the cluster is in a VPC.</p>
    pub vpc_security_groups:
        std::option::Option<std::vec::Vec<crate::model::AwsRedshiftClusterVpcSecurityGroup>>,
    /// <p>Information about the logging status of the cluster.</p>
    pub logging_status: std::option::Option<crate::model::AwsRedshiftClusterLoggingStatus>,
}
impl AwsRedshiftClusterDetails {
    /// <p>Indicates whether major version upgrades are applied automatically to the cluster during the maintenance window.</p>
    pub fn allow_version_upgrade(&self) -> bool {
        self.allow_version_upgrade
    }
    /// <p>The number of days that automatic cluster snapshots are retained.</p>
    pub fn automated_snapshot_retention_period(&self) -> i32 {
        self.automated_snapshot_retention_period
    }
    /// <p>The name of the Availability Zone in which the cluster is located.</p>
    pub fn availability_zone(&self) -> std::option::Option<&str> {
        self.availability_zone.as_deref()
    }
    /// <p>The availability status of the cluster for queries. Possible values are the following:</p>
    /// <ul>
    /// <li> <p> <code>Available</code> - The cluster is available for queries.</p> </li>
    /// <li> <p> <code>Unavailable</code> - The cluster is not available for queries.</p> </li>
    /// <li> <p> <code>Maintenance</code> - The cluster is intermittently available for queries due to maintenance activities.</p> </li>
    /// <li> <p> <code>Modifying</code> -The cluster is intermittently available for queries due to changes that modify the cluster.</p> </li>
    /// <li> <p> <code>Failed</code> - The cluster failed and is not available for queries.</p> </li>
    /// </ul>
    pub fn cluster_availability_status(&self) -> std::option::Option<&str> {
        self.cluster_availability_status.as_deref()
    }
    /// <p>Indicates when the cluster was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn cluster_create_time(&self) -> std::option::Option<&str> {
        self.cluster_create_time.as_deref()
    }
    /// <p>The unique identifier of the cluster.</p>
    pub fn cluster_identifier(&self) -> std::option::Option<&str> {
        self.cluster_identifier.as_deref()
    }
    /// <p>The nodes in the cluster.</p>
    pub fn cluster_nodes(
        &self,
    ) -> std::option::Option<&[crate::model::AwsRedshiftClusterClusterNode]> {
        self.cluster_nodes.as_deref()
    }
    /// <p>The list of cluster parameter groups that are associated with this cluster.</p>
    pub fn cluster_parameter_groups(
        &self,
    ) -> std::option::Option<&[crate::model::AwsRedshiftClusterClusterParameterGroup]> {
        self.cluster_parameter_groups.as_deref()
    }
    /// <p>The public key for the cluster.</p>
    pub fn cluster_public_key(&self) -> std::option::Option<&str> {
        self.cluster_public_key.as_deref()
    }
    /// <p>The specific revision number of the database in the cluster.</p>
    pub fn cluster_revision_number(&self) -> std::option::Option<&str> {
        self.cluster_revision_number.as_deref()
    }
    /// <p>A list of cluster security groups that are associated with the cluster.</p>
    pub fn cluster_security_groups(
        &self,
    ) -> std::option::Option<&[crate::model::AwsRedshiftClusterClusterSecurityGroup]> {
        self.cluster_security_groups.as_deref()
    }
    /// <p>Information about the destination Region and retention period for the cross-Region snapshot copy.</p>
    pub fn cluster_snapshot_copy_status(
        &self,
    ) -> std::option::Option<&crate::model::AwsRedshiftClusterClusterSnapshotCopyStatus> {
        self.cluster_snapshot_copy_status.as_ref()
    }
    /// <p>The current status of the cluster.</p>
    /// <p>Valid values: <code>available</code> | <code>available, prep-for-resize</code> | <code>available, resize-cleanup</code> |<code> cancelling-resize</code> | <code>creating</code> | <code>deleting</code> | <code>final-snapshot</code> | <code>hardware-failure</code> | <code>incompatible-hsm</code> |<code> incompatible-network</code> | <code>incompatible-parameters</code> | <code>incompatible-restore</code> | <code>modifying</code> | <code>paused</code> | <code>rebooting</code> | <code>renaming</code> | <code>resizing</code> | <code>rotating-keys</code> | <code>storage-full</code> | <code>updating-hsm</code> </p>
    pub fn cluster_status(&self) -> std::option::Option<&str> {
        self.cluster_status.as_deref()
    }
    /// <p>The name of the subnet group that is associated with the cluster. This parameter is valid only when the cluster is in a VPC.</p>
    pub fn cluster_subnet_group_name(&self) -> std::option::Option<&str> {
        self.cluster_subnet_group_name.as_deref()
    }
    /// <p>The version ID of the Amazon Redshift engine that runs on the cluster.</p>
    pub fn cluster_version(&self) -> std::option::Option<&str> {
        self.cluster_version.as_deref()
    }
    /// <p>The name of the initial database that was created when the cluster was created.</p>
    /// <p>The same name is returned for the life of the cluster.</p>
    /// <p>If an initial database is not specified, a database named <code>devdev</code> is created by default.</p>
    pub fn db_name(&self) -> std::option::Option<&str> {
        self.db_name.as_deref()
    }
    /// <p>List of time windows during which maintenance was deferred.</p>
    pub fn deferred_maintenance_windows(
        &self,
    ) -> std::option::Option<&[crate::model::AwsRedshiftClusterDeferredMaintenanceWindow]> {
        self.deferred_maintenance_windows.as_deref()
    }
    /// <p>Information about the status of the Elastic IP (EIP) address.</p>
    pub fn elastic_ip_status(
        &self,
    ) -> std::option::Option<&crate::model::AwsRedshiftClusterElasticIpStatus> {
        self.elastic_ip_status.as_ref()
    }
    /// <p>The number of nodes that you can use the elastic resize method to resize the cluster to.</p>
    pub fn elastic_resize_number_of_node_options(&self) -> std::option::Option<&str> {
        self.elastic_resize_number_of_node_options.as_deref()
    }
    /// <p>Indicates whether the data in the cluster is encrypted at rest.</p>
    pub fn encrypted(&self) -> bool {
        self.encrypted
    }
    /// <p>The connection endpoint.</p>
    pub fn endpoint(&self) -> std::option::Option<&crate::model::AwsRedshiftClusterEndpoint> {
        self.endpoint.as_ref()
    }
    /// <p>Indicates whether to create the cluster with enhanced VPC routing enabled.</p>
    pub fn enhanced_vpc_routing(&self) -> bool {
        self.enhanced_vpc_routing
    }
    /// <p>Indicates when the next snapshot is expected to be taken. The cluster must have a valid snapshot schedule and have backups enabled.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn expected_next_snapshot_schedule_time(&self) -> std::option::Option<&str> {
        self.expected_next_snapshot_schedule_time.as_deref()
    }
    /// <p>The status of the next expected snapshot.</p>
    /// <p>Valid values: <code>OnTrack</code> | <code>Pending</code> </p>
    pub fn expected_next_snapshot_schedule_time_status(&self) -> std::option::Option<&str> {
        self.expected_next_snapshot_schedule_time_status.as_deref()
    }
    /// <p>Information about whether the Amazon Redshift cluster finished applying any changes to hardware security module (HSM) settings that were specified in a modify cluster command.</p>
    pub fn hsm_status(&self) -> std::option::Option<&crate::model::AwsRedshiftClusterHsmStatus> {
        self.hsm_status.as_ref()
    }
    /// <p>A list of IAM roles that the cluster can use to access other Amazon Web Services services.</p>
    pub fn iam_roles(&self) -> std::option::Option<&[crate::model::AwsRedshiftClusterIamRole]> {
        self.iam_roles.as_deref()
    }
    /// <p>The identifier of the KMS encryption key that is used to encrypt data in the cluster.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>The name of the maintenance track for the cluster.</p>
    pub fn maintenance_track_name(&self) -> std::option::Option<&str> {
        self.maintenance_track_name.as_deref()
    }
    /// <p>The default number of days to retain a manual snapshot.</p>
    /// <p>If the value is <code>-1</code>, the snapshot is retained indefinitely.</p>
    /// <p>This setting doesn't change the retention period of existing snapshots.</p>
    /// <p>Valid values: Either <code>-1</code> or an integer between 1 and 3,653</p>
    pub fn manual_snapshot_retention_period(&self) -> i32 {
        self.manual_snapshot_retention_period
    }
    /// <p>The master user name for the cluster. This name is used to connect to the database that is specified in as the value of <code>DBName</code>.</p>
    pub fn master_username(&self) -> std::option::Option<&str> {
        self.master_username.as_deref()
    }
    /// <p>Indicates the start of the next maintenance window.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn next_maintenance_window_start_time(&self) -> std::option::Option<&str> {
        self.next_maintenance_window_start_time.as_deref()
    }
    /// <p>The node type for the nodes in the cluster.</p>
    pub fn node_type(&self) -> std::option::Option<&str> {
        self.node_type.as_deref()
    }
    /// <p>The number of compute nodes in the cluster.</p>
    pub fn number_of_nodes(&self) -> i32 {
        self.number_of_nodes
    }
    /// <p>A list of cluster operations that are waiting to start.</p>
    pub fn pending_actions(&self) -> std::option::Option<&[std::string::String]> {
        self.pending_actions.as_deref()
    }
    /// <p>A list of changes to the cluster that are currently pending.</p>
    pub fn pending_modified_values(
        &self,
    ) -> std::option::Option<&crate::model::AwsRedshiftClusterPendingModifiedValues> {
        self.pending_modified_values.as_ref()
    }
    /// <p>The weekly time range, in Universal Coordinated Time (UTC), during which system maintenance can occur.</p>
    /// <p>Format: <code> <i>
    /// <day></day></i>:HH:MM-<i>
    /// <day></day></i>:HH:MM</code> </p>
    /// <p>For the day values, use <code>mon</code> | <code>tue</code> | <code>wed</code> | <code>thu</code> | <code>fri</code> | <code>sat</code> | <code>sun</code> </p>
    /// <p>For example, <code>sun:09:32-sun:10:02</code> </p>
    pub fn preferred_maintenance_window(&self) -> std::option::Option<&str> {
        self.preferred_maintenance_window.as_deref()
    }
    /// <p>Whether the cluster can be accessed from a public network.</p>
    pub fn publicly_accessible(&self) -> bool {
        self.publicly_accessible
    }
    /// <p>Information about the resize operation for the cluster.</p>
    pub fn resize_info(&self) -> std::option::Option<&crate::model::AwsRedshiftClusterResizeInfo> {
        self.resize_info.as_ref()
    }
    /// <p>Information about the status of a cluster restore action. Only applies to a cluster that was created by restoring a snapshot.</p>
    pub fn restore_status(
        &self,
    ) -> std::option::Option<&crate::model::AwsRedshiftClusterRestoreStatus> {
        self.restore_status.as_ref()
    }
    /// <p>A unique identifier for the cluster snapshot schedule.</p>
    pub fn snapshot_schedule_identifier(&self) -> std::option::Option<&str> {
        self.snapshot_schedule_identifier.as_deref()
    }
    /// <p>The current state of the cluster snapshot schedule.</p>
    /// <p>Valid values: <code>MODIFYING</code> | <code>ACTIVE</code> | <code>FAILED</code> </p>
    pub fn snapshot_schedule_state(&self) -> std::option::Option<&str> {
        self.snapshot_schedule_state.as_deref()
    }
    /// <p>The identifier of the VPC that the cluster is in, if the cluster is in a VPC.</p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
    /// <p>The list of VPC security groups that the cluster belongs to, if the cluster is in a VPC.</p>
    pub fn vpc_security_groups(
        &self,
    ) -> std::option::Option<&[crate::model::AwsRedshiftClusterVpcSecurityGroup]> {
        self.vpc_security_groups.as_deref()
    }
    /// <p>Information about the logging status of the cluster.</p>
    pub fn logging_status(
        &self,
    ) -> std::option::Option<&crate::model::AwsRedshiftClusterLoggingStatus> {
        self.logging_status.as_ref()
    }
}
impl std::fmt::Debug for AwsRedshiftClusterDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRedshiftClusterDetails");
        formatter.field("allow_version_upgrade", &self.allow_version_upgrade);
        formatter.field(
            "automated_snapshot_retention_period",
            &self.automated_snapshot_retention_period,
        );
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field(
            "cluster_availability_status",
            &self.cluster_availability_status,
        );
        formatter.field("cluster_create_time", &self.cluster_create_time);
        formatter.field("cluster_identifier", &self.cluster_identifier);
        formatter.field("cluster_nodes", &self.cluster_nodes);
        formatter.field("cluster_parameter_groups", &self.cluster_parameter_groups);
        formatter.field("cluster_public_key", &self.cluster_public_key);
        formatter.field("cluster_revision_number", &self.cluster_revision_number);
        formatter.field("cluster_security_groups", &self.cluster_security_groups);
        formatter.field(
            "cluster_snapshot_copy_status",
            &self.cluster_snapshot_copy_status,
        );
        formatter.field("cluster_status", &self.cluster_status);
        formatter.field("cluster_subnet_group_name", &self.cluster_subnet_group_name);
        formatter.field("cluster_version", &self.cluster_version);
        formatter.field("db_name", &self.db_name);
        formatter.field(
            "deferred_maintenance_windows",
            &self.deferred_maintenance_windows,
        );
        formatter.field("elastic_ip_status", &self.elastic_ip_status);
        formatter.field(
            "elastic_resize_number_of_node_options",
            &self.elastic_resize_number_of_node_options,
        );
        formatter.field("encrypted", &self.encrypted);
        formatter.field("endpoint", &self.endpoint);
        formatter.field("enhanced_vpc_routing", &self.enhanced_vpc_routing);
        formatter.field(
            "expected_next_snapshot_schedule_time",
            &self.expected_next_snapshot_schedule_time,
        );
        formatter.field(
            "expected_next_snapshot_schedule_time_status",
            &self.expected_next_snapshot_schedule_time_status,
        );
        formatter.field("hsm_status", &self.hsm_status);
        formatter.field("iam_roles", &self.iam_roles);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("maintenance_track_name", &self.maintenance_track_name);
        formatter.field(
            "manual_snapshot_retention_period",
            &self.manual_snapshot_retention_period,
        );
        formatter.field("master_username", &self.master_username);
        formatter.field(
            "next_maintenance_window_start_time",
            &self.next_maintenance_window_start_time,
        );
        formatter.field("node_type", &self.node_type);
        formatter.field("number_of_nodes", &self.number_of_nodes);
        formatter.field("pending_actions", &self.pending_actions);
        formatter.field("pending_modified_values", &self.pending_modified_values);
        formatter.field(
            "preferred_maintenance_window",
            &self.preferred_maintenance_window,
        );
        formatter.field("publicly_accessible", &self.publicly_accessible);
        formatter.field("resize_info", &self.resize_info);
        formatter.field("restore_status", &self.restore_status);
        formatter.field(
            "snapshot_schedule_identifier",
            &self.snapshot_schedule_identifier,
        );
        formatter.field("snapshot_schedule_state", &self.snapshot_schedule_state);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("vpc_security_groups", &self.vpc_security_groups);
        formatter.field("logging_status", &self.logging_status);
        formatter.finish()
    }
}
/// See [`AwsRedshiftClusterDetails`](crate::model::AwsRedshiftClusterDetails)
pub mod aws_redshift_cluster_details {

    /// A builder for [`AwsRedshiftClusterDetails`](crate::model::AwsRedshiftClusterDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) allow_version_upgrade: std::option::Option<bool>,
        pub(crate) automated_snapshot_retention_period: std::option::Option<i32>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) cluster_availability_status: std::option::Option<std::string::String>,
        pub(crate) cluster_create_time: std::option::Option<std::string::String>,
        pub(crate) cluster_identifier: std::option::Option<std::string::String>,
        pub(crate) cluster_nodes:
            std::option::Option<std::vec::Vec<crate::model::AwsRedshiftClusterClusterNode>>,
        pub(crate) cluster_parameter_groups: std::option::Option<
            std::vec::Vec<crate::model::AwsRedshiftClusterClusterParameterGroup>,
        >,
        pub(crate) cluster_public_key: std::option::Option<std::string::String>,
        pub(crate) cluster_revision_number: std::option::Option<std::string::String>,
        pub(crate) cluster_security_groups: std::option::Option<
            std::vec::Vec<crate::model::AwsRedshiftClusterClusterSecurityGroup>,
        >,
        pub(crate) cluster_snapshot_copy_status:
            std::option::Option<crate::model::AwsRedshiftClusterClusterSnapshotCopyStatus>,
        pub(crate) cluster_status: std::option::Option<std::string::String>,
        pub(crate) cluster_subnet_group_name: std::option::Option<std::string::String>,
        pub(crate) cluster_version: std::option::Option<std::string::String>,
        pub(crate) db_name: std::option::Option<std::string::String>,
        pub(crate) deferred_maintenance_windows: std::option::Option<
            std::vec::Vec<crate::model::AwsRedshiftClusterDeferredMaintenanceWindow>,
        >,
        pub(crate) elastic_ip_status:
            std::option::Option<crate::model::AwsRedshiftClusterElasticIpStatus>,
        pub(crate) elastic_resize_number_of_node_options: std::option::Option<std::string::String>,
        pub(crate) encrypted: std::option::Option<bool>,
        pub(crate) endpoint: std::option::Option<crate::model::AwsRedshiftClusterEndpoint>,
        pub(crate) enhanced_vpc_routing: std::option::Option<bool>,
        pub(crate) expected_next_snapshot_schedule_time: std::option::Option<std::string::String>,
        pub(crate) expected_next_snapshot_schedule_time_status:
            std::option::Option<std::string::String>,
        pub(crate) hsm_status: std::option::Option<crate::model::AwsRedshiftClusterHsmStatus>,
        pub(crate) iam_roles:
            std::option::Option<std::vec::Vec<crate::model::AwsRedshiftClusterIamRole>>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) maintenance_track_name: std::option::Option<std::string::String>,
        pub(crate) manual_snapshot_retention_period: std::option::Option<i32>,
        pub(crate) master_username: std::option::Option<std::string::String>,
        pub(crate) next_maintenance_window_start_time: std::option::Option<std::string::String>,
        pub(crate) node_type: std::option::Option<std::string::String>,
        pub(crate) number_of_nodes: std::option::Option<i32>,
        pub(crate) pending_actions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) pending_modified_values:
            std::option::Option<crate::model::AwsRedshiftClusterPendingModifiedValues>,
        pub(crate) preferred_maintenance_window: std::option::Option<std::string::String>,
        pub(crate) publicly_accessible: std::option::Option<bool>,
        pub(crate) resize_info: std::option::Option<crate::model::AwsRedshiftClusterResizeInfo>,
        pub(crate) restore_status:
            std::option::Option<crate::model::AwsRedshiftClusterRestoreStatus>,
        pub(crate) snapshot_schedule_identifier: std::option::Option<std::string::String>,
        pub(crate) snapshot_schedule_state: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) vpc_security_groups:
            std::option::Option<std::vec::Vec<crate::model::AwsRedshiftClusterVpcSecurityGroup>>,
        pub(crate) logging_status:
            std::option::Option<crate::model::AwsRedshiftClusterLoggingStatus>,
    }
    impl Builder {
        /// <p>Indicates whether major version upgrades are applied automatically to the cluster during the maintenance window.</p>
        pub fn allow_version_upgrade(mut self, input: bool) -> Self {
            self.allow_version_upgrade = Some(input);
            self
        }
        /// <p>Indicates whether major version upgrades are applied automatically to the cluster during the maintenance window.</p>
        pub fn set_allow_version_upgrade(mut self, input: std::option::Option<bool>) -> Self {
            self.allow_version_upgrade = input;
            self
        }
        /// <p>The number of days that automatic cluster snapshots are retained.</p>
        pub fn automated_snapshot_retention_period(mut self, input: i32) -> Self {
            self.automated_snapshot_retention_period = Some(input);
            self
        }
        /// <p>The number of days that automatic cluster snapshots are retained.</p>
        pub fn set_automated_snapshot_retention_period(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.automated_snapshot_retention_period = input;
            self
        }
        /// <p>The name of the Availability Zone in which the cluster is located.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        /// <p>The name of the Availability Zone in which the cluster is located.</p>
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The availability status of the cluster for queries. Possible values are the following:</p>
        /// <ul>
        /// <li> <p> <code>Available</code> - The cluster is available for queries.</p> </li>
        /// <li> <p> <code>Unavailable</code> - The cluster is not available for queries.</p> </li>
        /// <li> <p> <code>Maintenance</code> - The cluster is intermittently available for queries due to maintenance activities.</p> </li>
        /// <li> <p> <code>Modifying</code> -The cluster is intermittently available for queries due to changes that modify the cluster.</p> </li>
        /// <li> <p> <code>Failed</code> - The cluster failed and is not available for queries.</p> </li>
        /// </ul>
        pub fn cluster_availability_status(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.cluster_availability_status = Some(input.into());
            self
        }
        /// <p>The availability status of the cluster for queries. Possible values are the following:</p>
        /// <ul>
        /// <li> <p> <code>Available</code> - The cluster is available for queries.</p> </li>
        /// <li> <p> <code>Unavailable</code> - The cluster is not available for queries.</p> </li>
        /// <li> <p> <code>Maintenance</code> - The cluster is intermittently available for queries due to maintenance activities.</p> </li>
        /// <li> <p> <code>Modifying</code> -The cluster is intermittently available for queries due to changes that modify the cluster.</p> </li>
        /// <li> <p> <code>Failed</code> - The cluster failed and is not available for queries.</p> </li>
        /// </ul>
        pub fn set_cluster_availability_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_availability_status = input;
            self
        }
        /// <p>Indicates when the cluster was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn cluster_create_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_create_time = Some(input.into());
            self
        }
        /// <p>Indicates when the cluster was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_cluster_create_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_create_time = input;
            self
        }
        /// <p>The unique identifier of the cluster.</p>
        pub fn cluster_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_identifier = Some(input.into());
            self
        }
        /// <p>The unique identifier of the cluster.</p>
        pub fn set_cluster_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_identifier = input;
            self
        }
        /// Appends an item to `cluster_nodes`.
        ///
        /// To override the contents of this collection use [`set_cluster_nodes`](Self::set_cluster_nodes).
        ///
        /// <p>The nodes in the cluster.</p>
        pub fn cluster_nodes(mut self, input: crate::model::AwsRedshiftClusterClusterNode) -> Self {
            let mut v = self.cluster_nodes.unwrap_or_default();
            v.push(input);
            self.cluster_nodes = Some(v);
            self
        }
        /// <p>The nodes in the cluster.</p>
        pub fn set_cluster_nodes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsRedshiftClusterClusterNode>>,
        ) -> Self {
            self.cluster_nodes = input;
            self
        }
        /// Appends an item to `cluster_parameter_groups`.
        ///
        /// To override the contents of this collection use [`set_cluster_parameter_groups`](Self::set_cluster_parameter_groups).
        ///
        /// <p>The list of cluster parameter groups that are associated with this cluster.</p>
        pub fn cluster_parameter_groups(
            mut self,
            input: crate::model::AwsRedshiftClusterClusterParameterGroup,
        ) -> Self {
            let mut v = self.cluster_parameter_groups.unwrap_or_default();
            v.push(input);
            self.cluster_parameter_groups = Some(v);
            self
        }
        /// <p>The list of cluster parameter groups that are associated with this cluster.</p>
        pub fn set_cluster_parameter_groups(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsRedshiftClusterClusterParameterGroup>,
            >,
        ) -> Self {
            self.cluster_parameter_groups = input;
            self
        }
        /// <p>The public key for the cluster.</p>
        pub fn cluster_public_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_public_key = Some(input.into());
            self
        }
        /// <p>The public key for the cluster.</p>
        pub fn set_cluster_public_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_public_key = input;
            self
        }
        /// <p>The specific revision number of the database in the cluster.</p>
        pub fn cluster_revision_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_revision_number = Some(input.into());
            self
        }
        /// <p>The specific revision number of the database in the cluster.</p>
        pub fn set_cluster_revision_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_revision_number = input;
            self
        }
        /// Appends an item to `cluster_security_groups`.
        ///
        /// To override the contents of this collection use [`set_cluster_security_groups`](Self::set_cluster_security_groups).
        ///
        /// <p>A list of cluster security groups that are associated with the cluster.</p>
        pub fn cluster_security_groups(
            mut self,
            input: crate::model::AwsRedshiftClusterClusterSecurityGroup,
        ) -> Self {
            let mut v = self.cluster_security_groups.unwrap_or_default();
            v.push(input);
            self.cluster_security_groups = Some(v);
            self
        }
        /// <p>A list of cluster security groups that are associated with the cluster.</p>
        pub fn set_cluster_security_groups(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsRedshiftClusterClusterSecurityGroup>,
            >,
        ) -> Self {
            self.cluster_security_groups = input;
            self
        }
        /// <p>Information about the destination Region and retention period for the cross-Region snapshot copy.</p>
        pub fn cluster_snapshot_copy_status(
            mut self,
            input: crate::model::AwsRedshiftClusterClusterSnapshotCopyStatus,
        ) -> Self {
            self.cluster_snapshot_copy_status = Some(input);
            self
        }
        /// <p>Information about the destination Region and retention period for the cross-Region snapshot copy.</p>
        pub fn set_cluster_snapshot_copy_status(
            mut self,
            input: std::option::Option<crate::model::AwsRedshiftClusterClusterSnapshotCopyStatus>,
        ) -> Self {
            self.cluster_snapshot_copy_status = input;
            self
        }
        /// <p>The current status of the cluster.</p>
        /// <p>Valid values: <code>available</code> | <code>available, prep-for-resize</code> | <code>available, resize-cleanup</code> |<code> cancelling-resize</code> | <code>creating</code> | <code>deleting</code> | <code>final-snapshot</code> | <code>hardware-failure</code> | <code>incompatible-hsm</code> |<code> incompatible-network</code> | <code>incompatible-parameters</code> | <code>incompatible-restore</code> | <code>modifying</code> | <code>paused</code> | <code>rebooting</code> | <code>renaming</code> | <code>resizing</code> | <code>rotating-keys</code> | <code>storage-full</code> | <code>updating-hsm</code> </p>
        pub fn cluster_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_status = Some(input.into());
            self
        }
        /// <p>The current status of the cluster.</p>
        /// <p>Valid values: <code>available</code> | <code>available, prep-for-resize</code> | <code>available, resize-cleanup</code> |<code> cancelling-resize</code> | <code>creating</code> | <code>deleting</code> | <code>final-snapshot</code> | <code>hardware-failure</code> | <code>incompatible-hsm</code> |<code> incompatible-network</code> | <code>incompatible-parameters</code> | <code>incompatible-restore</code> | <code>modifying</code> | <code>paused</code> | <code>rebooting</code> | <code>renaming</code> | <code>resizing</code> | <code>rotating-keys</code> | <code>storage-full</code> | <code>updating-hsm</code> </p>
        pub fn set_cluster_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_status = input;
            self
        }
        /// <p>The name of the subnet group that is associated with the cluster. This parameter is valid only when the cluster is in a VPC.</p>
        pub fn cluster_subnet_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_subnet_group_name = Some(input.into());
            self
        }
        /// <p>The name of the subnet group that is associated with the cluster. This parameter is valid only when the cluster is in a VPC.</p>
        pub fn set_cluster_subnet_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_subnet_group_name = input;
            self
        }
        /// <p>The version ID of the Amazon Redshift engine that runs on the cluster.</p>
        pub fn cluster_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_version = Some(input.into());
            self
        }
        /// <p>The version ID of the Amazon Redshift engine that runs on the cluster.</p>
        pub fn set_cluster_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_version = input;
            self
        }
        /// <p>The name of the initial database that was created when the cluster was created.</p>
        /// <p>The same name is returned for the life of the cluster.</p>
        /// <p>If an initial database is not specified, a database named <code>devdev</code> is created by default.</p>
        pub fn db_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_name = Some(input.into());
            self
        }
        /// <p>The name of the initial database that was created when the cluster was created.</p>
        /// <p>The same name is returned for the life of the cluster.</p>
        /// <p>If an initial database is not specified, a database named <code>devdev</code> is created by default.</p>
        pub fn set_db_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.db_name = input;
            self
        }
        /// Appends an item to `deferred_maintenance_windows`.
        ///
        /// To override the contents of this collection use [`set_deferred_maintenance_windows`](Self::set_deferred_maintenance_windows).
        ///
        /// <p>List of time windows during which maintenance was deferred.</p>
        pub fn deferred_maintenance_windows(
            mut self,
            input: crate::model::AwsRedshiftClusterDeferredMaintenanceWindow,
        ) -> Self {
            let mut v = self.deferred_maintenance_windows.unwrap_or_default();
            v.push(input);
            self.deferred_maintenance_windows = Some(v);
            self
        }
        /// <p>List of time windows during which maintenance was deferred.</p>
        pub fn set_deferred_maintenance_windows(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsRedshiftClusterDeferredMaintenanceWindow>,
            >,
        ) -> Self {
            self.deferred_maintenance_windows = input;
            self
        }
        /// <p>Information about the status of the Elastic IP (EIP) address.</p>
        pub fn elastic_ip_status(
            mut self,
            input: crate::model::AwsRedshiftClusterElasticIpStatus,
        ) -> Self {
            self.elastic_ip_status = Some(input);
            self
        }
        /// <p>Information about the status of the Elastic IP (EIP) address.</p>
        pub fn set_elastic_ip_status(
            mut self,
            input: std::option::Option<crate::model::AwsRedshiftClusterElasticIpStatus>,
        ) -> Self {
            self.elastic_ip_status = input;
            self
        }
        /// <p>The number of nodes that you can use the elastic resize method to resize the cluster to.</p>
        pub fn elastic_resize_number_of_node_options(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.elastic_resize_number_of_node_options = Some(input.into());
            self
        }
        /// <p>The number of nodes that you can use the elastic resize method to resize the cluster to.</p>
        pub fn set_elastic_resize_number_of_node_options(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.elastic_resize_number_of_node_options = input;
            self
        }
        /// <p>Indicates whether the data in the cluster is encrypted at rest.</p>
        pub fn encrypted(mut self, input: bool) -> Self {
            self.encrypted = Some(input);
            self
        }
        /// <p>Indicates whether the data in the cluster is encrypted at rest.</p>
        pub fn set_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.encrypted = input;
            self
        }
        /// <p>The connection endpoint.</p>
        pub fn endpoint(mut self, input: crate::model::AwsRedshiftClusterEndpoint) -> Self {
            self.endpoint = Some(input);
            self
        }
        /// <p>The connection endpoint.</p>
        pub fn set_endpoint(
            mut self,
            input: std::option::Option<crate::model::AwsRedshiftClusterEndpoint>,
        ) -> Self {
            self.endpoint = input;
            self
        }
        /// <p>Indicates whether to create the cluster with enhanced VPC routing enabled.</p>
        pub fn enhanced_vpc_routing(mut self, input: bool) -> Self {
            self.enhanced_vpc_routing = Some(input);
            self
        }
        /// <p>Indicates whether to create the cluster with enhanced VPC routing enabled.</p>
        pub fn set_enhanced_vpc_routing(mut self, input: std::option::Option<bool>) -> Self {
            self.enhanced_vpc_routing = input;
            self
        }
        /// <p>Indicates when the next snapshot is expected to be taken. The cluster must have a valid snapshot schedule and have backups enabled.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn expected_next_snapshot_schedule_time(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.expected_next_snapshot_schedule_time = Some(input.into());
            self
        }
        /// <p>Indicates when the next snapshot is expected to be taken. The cluster must have a valid snapshot schedule and have backups enabled.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_expected_next_snapshot_schedule_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_next_snapshot_schedule_time = input;
            self
        }
        /// <p>The status of the next expected snapshot.</p>
        /// <p>Valid values: <code>OnTrack</code> | <code>Pending</code> </p>
        pub fn expected_next_snapshot_schedule_time_status(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.expected_next_snapshot_schedule_time_status = Some(input.into());
            self
        }
        /// <p>The status of the next expected snapshot.</p>
        /// <p>Valid values: <code>OnTrack</code> | <code>Pending</code> </p>
        pub fn set_expected_next_snapshot_schedule_time_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_next_snapshot_schedule_time_status = input;
            self
        }
        /// <p>Information about whether the Amazon Redshift cluster finished applying any changes to hardware security module (HSM) settings that were specified in a modify cluster command.</p>
        pub fn hsm_status(mut self, input: crate::model::AwsRedshiftClusterHsmStatus) -> Self {
            self.hsm_status = Some(input);
            self
        }
        /// <p>Information about whether the Amazon Redshift cluster finished applying any changes to hardware security module (HSM) settings that were specified in a modify cluster command.</p>
        pub fn set_hsm_status(
            mut self,
            input: std::option::Option<crate::model::AwsRedshiftClusterHsmStatus>,
        ) -> Self {
            self.hsm_status = input;
            self
        }
        /// Appends an item to `iam_roles`.
        ///
        /// To override the contents of this collection use [`set_iam_roles`](Self::set_iam_roles).
        ///
        /// <p>A list of IAM roles that the cluster can use to access other Amazon Web Services services.</p>
        pub fn iam_roles(mut self, input: crate::model::AwsRedshiftClusterIamRole) -> Self {
            let mut v = self.iam_roles.unwrap_or_default();
            v.push(input);
            self.iam_roles = Some(v);
            self
        }
        /// <p>A list of IAM roles that the cluster can use to access other Amazon Web Services services.</p>
        pub fn set_iam_roles(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsRedshiftClusterIamRole>>,
        ) -> Self {
            self.iam_roles = input;
            self
        }
        /// <p>The identifier of the KMS encryption key that is used to encrypt data in the cluster.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The identifier of the KMS encryption key that is used to encrypt data in the cluster.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The name of the maintenance track for the cluster.</p>
        pub fn maintenance_track_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.maintenance_track_name = Some(input.into());
            self
        }
        /// <p>The name of the maintenance track for the cluster.</p>
        pub fn set_maintenance_track_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.maintenance_track_name = input;
            self
        }
        /// <p>The default number of days to retain a manual snapshot.</p>
        /// <p>If the value is <code>-1</code>, the snapshot is retained indefinitely.</p>
        /// <p>This setting doesn't change the retention period of existing snapshots.</p>
        /// <p>Valid values: Either <code>-1</code> or an integer between 1 and 3,653</p>
        pub fn manual_snapshot_retention_period(mut self, input: i32) -> Self {
            self.manual_snapshot_retention_period = Some(input);
            self
        }
        /// <p>The default number of days to retain a manual snapshot.</p>
        /// <p>If the value is <code>-1</code>, the snapshot is retained indefinitely.</p>
        /// <p>This setting doesn't change the retention period of existing snapshots.</p>
        /// <p>Valid values: Either <code>-1</code> or an integer between 1 and 3,653</p>
        pub fn set_manual_snapshot_retention_period(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.manual_snapshot_retention_period = input;
            self
        }
        /// <p>The master user name for the cluster. This name is used to connect to the database that is specified in as the value of <code>DBName</code>.</p>
        pub fn master_username(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_username = Some(input.into());
            self
        }
        /// <p>The master user name for the cluster. This name is used to connect to the database that is specified in as the value of <code>DBName</code>.</p>
        pub fn set_master_username(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_username = input;
            self
        }
        /// <p>Indicates the start of the next maintenance window.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn next_maintenance_window_start_time(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.next_maintenance_window_start_time = Some(input.into());
            self
        }
        /// <p>Indicates the start of the next maintenance window.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_next_maintenance_window_start_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_maintenance_window_start_time = input;
            self
        }
        /// <p>The node type for the nodes in the cluster.</p>
        pub fn node_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.node_type = Some(input.into());
            self
        }
        /// <p>The node type for the nodes in the cluster.</p>
        pub fn set_node_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.node_type = input;
            self
        }
        /// <p>The number of compute nodes in the cluster.</p>
        pub fn number_of_nodes(mut self, input: i32) -> Self {
            self.number_of_nodes = Some(input);
            self
        }
        /// <p>The number of compute nodes in the cluster.</p>
        pub fn set_number_of_nodes(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_nodes = input;
            self
        }
        /// Appends an item to `pending_actions`.
        ///
        /// To override the contents of this collection use [`set_pending_actions`](Self::set_pending_actions).
        ///
        /// <p>A list of cluster operations that are waiting to start.</p>
        pub fn pending_actions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.pending_actions.unwrap_or_default();
            v.push(input.into());
            self.pending_actions = Some(v);
            self
        }
        /// <p>A list of cluster operations that are waiting to start.</p>
        pub fn set_pending_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.pending_actions = input;
            self
        }
        /// <p>A list of changes to the cluster that are currently pending.</p>
        pub fn pending_modified_values(
            mut self,
            input: crate::model::AwsRedshiftClusterPendingModifiedValues,
        ) -> Self {
            self.pending_modified_values = Some(input);
            self
        }
        /// <p>A list of changes to the cluster that are currently pending.</p>
        pub fn set_pending_modified_values(
            mut self,
            input: std::option::Option<crate::model::AwsRedshiftClusterPendingModifiedValues>,
        ) -> Self {
            self.pending_modified_values = input;
            self
        }
        /// <p>The weekly time range, in Universal Coordinated Time (UTC), during which system maintenance can occur.</p>
        /// <p>Format: <code> <i>
        /// <day></day></i>:HH:MM-<i>
        /// <day></day></i>:HH:MM</code> </p>
        /// <p>For the day values, use <code>mon</code> | <code>tue</code> | <code>wed</code> | <code>thu</code> | <code>fri</code> | <code>sat</code> | <code>sun</code> </p>
        /// <p>For example, <code>sun:09:32-sun:10:02</code> </p>
        pub fn preferred_maintenance_window(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.preferred_maintenance_window = Some(input.into());
            self
        }
        /// <p>The weekly time range, in Universal Coordinated Time (UTC), during which system maintenance can occur.</p>
        /// <p>Format: <code> <i>
        /// <day></day></i>:HH:MM-<i>
        /// <day></day></i>:HH:MM</code> </p>
        /// <p>For the day values, use <code>mon</code> | <code>tue</code> | <code>wed</code> | <code>thu</code> | <code>fri</code> | <code>sat</code> | <code>sun</code> </p>
        /// <p>For example, <code>sun:09:32-sun:10:02</code> </p>
        pub fn set_preferred_maintenance_window(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.preferred_maintenance_window = input;
            self
        }
        /// <p>Whether the cluster can be accessed from a public network.</p>
        pub fn publicly_accessible(mut self, input: bool) -> Self {
            self.publicly_accessible = Some(input);
            self
        }
        /// <p>Whether the cluster can be accessed from a public network.</p>
        pub fn set_publicly_accessible(mut self, input: std::option::Option<bool>) -> Self {
            self.publicly_accessible = input;
            self
        }
        /// <p>Information about the resize operation for the cluster.</p>
        pub fn resize_info(mut self, input: crate::model::AwsRedshiftClusterResizeInfo) -> Self {
            self.resize_info = Some(input);
            self
        }
        /// <p>Information about the resize operation for the cluster.</p>
        pub fn set_resize_info(
            mut self,
            input: std::option::Option<crate::model::AwsRedshiftClusterResizeInfo>,
        ) -> Self {
            self.resize_info = input;
            self
        }
        /// <p>Information about the status of a cluster restore action. Only applies to a cluster that was created by restoring a snapshot.</p>
        pub fn restore_status(
            mut self,
            input: crate::model::AwsRedshiftClusterRestoreStatus,
        ) -> Self {
            self.restore_status = Some(input);
            self
        }
        /// <p>Information about the status of a cluster restore action. Only applies to a cluster that was created by restoring a snapshot.</p>
        pub fn set_restore_status(
            mut self,
            input: std::option::Option<crate::model::AwsRedshiftClusterRestoreStatus>,
        ) -> Self {
            self.restore_status = input;
            self
        }
        /// <p>A unique identifier for the cluster snapshot schedule.</p>
        pub fn snapshot_schedule_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.snapshot_schedule_identifier = Some(input.into());
            self
        }
        /// <p>A unique identifier for the cluster snapshot schedule.</p>
        pub fn set_snapshot_schedule_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.snapshot_schedule_identifier = input;
            self
        }
        /// <p>The current state of the cluster snapshot schedule.</p>
        /// <p>Valid values: <code>MODIFYING</code> | <code>ACTIVE</code> | <code>FAILED</code> </p>
        pub fn snapshot_schedule_state(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_schedule_state = Some(input.into());
            self
        }
        /// <p>The current state of the cluster snapshot schedule.</p>
        /// <p>Valid values: <code>MODIFYING</code> | <code>ACTIVE</code> | <code>FAILED</code> </p>
        pub fn set_snapshot_schedule_state(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.snapshot_schedule_state = input;
            self
        }
        /// <p>The identifier of the VPC that the cluster is in, if the cluster is in a VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The identifier of the VPC that the cluster is in, if the cluster is in a VPC.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Appends an item to `vpc_security_groups`.
        ///
        /// To override the contents of this collection use [`set_vpc_security_groups`](Self::set_vpc_security_groups).
        ///
        /// <p>The list of VPC security groups that the cluster belongs to, if the cluster is in a VPC.</p>
        pub fn vpc_security_groups(
            mut self,
            input: crate::model::AwsRedshiftClusterVpcSecurityGroup,
        ) -> Self {
            let mut v = self.vpc_security_groups.unwrap_or_default();
            v.push(input);
            self.vpc_security_groups = Some(v);
            self
        }
        /// <p>The list of VPC security groups that the cluster belongs to, if the cluster is in a VPC.</p>
        pub fn set_vpc_security_groups(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsRedshiftClusterVpcSecurityGroup>,
            >,
        ) -> Self {
            self.vpc_security_groups = input;
            self
        }
        /// <p>Information about the logging status of the cluster.</p>
        pub fn logging_status(
            mut self,
            input: crate::model::AwsRedshiftClusterLoggingStatus,
        ) -> Self {
            self.logging_status = Some(input);
            self
        }
        /// <p>Information about the logging status of the cluster.</p>
        pub fn set_logging_status(
            mut self,
            input: std::option::Option<crate::model::AwsRedshiftClusterLoggingStatus>,
        ) -> Self {
            self.logging_status = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRedshiftClusterDetails`](crate::model::AwsRedshiftClusterDetails)
        pub fn build(self) -> crate::model::AwsRedshiftClusterDetails {
            crate::model::AwsRedshiftClusterDetails {
                allow_version_upgrade: self.allow_version_upgrade.unwrap_or_default(),
                automated_snapshot_retention_period: self
                    .automated_snapshot_retention_period
                    .unwrap_or_default(),
                availability_zone: self.availability_zone,
                cluster_availability_status: self.cluster_availability_status,
                cluster_create_time: self.cluster_create_time,
                cluster_identifier: self.cluster_identifier,
                cluster_nodes: self.cluster_nodes,
                cluster_parameter_groups: self.cluster_parameter_groups,
                cluster_public_key: self.cluster_public_key,
                cluster_revision_number: self.cluster_revision_number,
                cluster_security_groups: self.cluster_security_groups,
                cluster_snapshot_copy_status: self.cluster_snapshot_copy_status,
                cluster_status: self.cluster_status,
                cluster_subnet_group_name: self.cluster_subnet_group_name,
                cluster_version: self.cluster_version,
                db_name: self.db_name,
                deferred_maintenance_windows: self.deferred_maintenance_windows,
                elastic_ip_status: self.elastic_ip_status,
                elastic_resize_number_of_node_options: self.elastic_resize_number_of_node_options,
                encrypted: self.encrypted.unwrap_or_default(),
                endpoint: self.endpoint,
                enhanced_vpc_routing: self.enhanced_vpc_routing.unwrap_or_default(),
                expected_next_snapshot_schedule_time: self.expected_next_snapshot_schedule_time,
                expected_next_snapshot_schedule_time_status: self
                    .expected_next_snapshot_schedule_time_status,
                hsm_status: self.hsm_status,
                iam_roles: self.iam_roles,
                kms_key_id: self.kms_key_id,
                maintenance_track_name: self.maintenance_track_name,
                manual_snapshot_retention_period: self
                    .manual_snapshot_retention_period
                    .unwrap_or_default(),
                master_username: self.master_username,
                next_maintenance_window_start_time: self.next_maintenance_window_start_time,
                node_type: self.node_type,
                number_of_nodes: self.number_of_nodes.unwrap_or_default(),
                pending_actions: self.pending_actions,
                pending_modified_values: self.pending_modified_values,
                preferred_maintenance_window: self.preferred_maintenance_window,
                publicly_accessible: self.publicly_accessible.unwrap_or_default(),
                resize_info: self.resize_info,
                restore_status: self.restore_status,
                snapshot_schedule_identifier: self.snapshot_schedule_identifier,
                snapshot_schedule_state: self.snapshot_schedule_state,
                vpc_id: self.vpc_id,
                vpc_security_groups: self.vpc_security_groups,
                logging_status: self.logging_status,
            }
        }
    }
}
impl AwsRedshiftClusterDetails {
    /// Creates a new builder-style object to manufacture [`AwsRedshiftClusterDetails`](crate::model::AwsRedshiftClusterDetails)
    pub fn builder() -> crate::model::aws_redshift_cluster_details::Builder {
        crate::model::aws_redshift_cluster_details::Builder::default()
    }
}

/// <p>Provides information about the logging status of the cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRedshiftClusterLoggingStatus {
    /// <p>The name of the S3 bucket where the log files are stored.</p>
    pub bucket_name: std::option::Option<std::string::String>,
    /// <p>The message indicating that the logs failed to be delivered.</p>
    pub last_failure_message: std::option::Option<std::string::String>,
    /// <p>The last time when logs failed to be delivered.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub last_failure_time: std::option::Option<std::string::String>,
    /// <p>The last time that logs were delivered successfully.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub last_successful_delivery_time: std::option::Option<std::string::String>,
    /// <p>Indicates whether logging is enabled.</p>
    pub logging_enabled: bool,
    /// <p>Provides the prefix applied to the log file names.</p>
    pub s3_key_prefix: std::option::Option<std::string::String>,
}
impl AwsRedshiftClusterLoggingStatus {
    /// <p>The name of the S3 bucket where the log files are stored.</p>
    pub fn bucket_name(&self) -> std::option::Option<&str> {
        self.bucket_name.as_deref()
    }
    /// <p>The message indicating that the logs failed to be delivered.</p>
    pub fn last_failure_message(&self) -> std::option::Option<&str> {
        self.last_failure_message.as_deref()
    }
    /// <p>The last time when logs failed to be delivered.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn last_failure_time(&self) -> std::option::Option<&str> {
        self.last_failure_time.as_deref()
    }
    /// <p>The last time that logs were delivered successfully.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn last_successful_delivery_time(&self) -> std::option::Option<&str> {
        self.last_successful_delivery_time.as_deref()
    }
    /// <p>Indicates whether logging is enabled.</p>
    pub fn logging_enabled(&self) -> bool {
        self.logging_enabled
    }
    /// <p>Provides the prefix applied to the log file names.</p>
    pub fn s3_key_prefix(&self) -> std::option::Option<&str> {
        self.s3_key_prefix.as_deref()
    }
}
impl std::fmt::Debug for AwsRedshiftClusterLoggingStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRedshiftClusterLoggingStatus");
        formatter.field("bucket_name", &self.bucket_name);
        formatter.field("last_failure_message", &self.last_failure_message);
        formatter.field("last_failure_time", &self.last_failure_time);
        formatter.field(
            "last_successful_delivery_time",
            &self.last_successful_delivery_time,
        );
        formatter.field("logging_enabled", &self.logging_enabled);
        formatter.field("s3_key_prefix", &self.s3_key_prefix);
        formatter.finish()
    }
}
/// See [`AwsRedshiftClusterLoggingStatus`](crate::model::AwsRedshiftClusterLoggingStatus)
pub mod aws_redshift_cluster_logging_status {

    /// A builder for [`AwsRedshiftClusterLoggingStatus`](crate::model::AwsRedshiftClusterLoggingStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_name: std::option::Option<std::string::String>,
        pub(crate) last_failure_message: std::option::Option<std::string::String>,
        pub(crate) last_failure_time: std::option::Option<std::string::String>,
        pub(crate) last_successful_delivery_time: std::option::Option<std::string::String>,
        pub(crate) logging_enabled: std::option::Option<bool>,
        pub(crate) s3_key_prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the S3 bucket where the log files are stored.</p>
        pub fn bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_name = Some(input.into());
            self
        }
        /// <p>The name of the S3 bucket where the log files are stored.</p>
        pub fn set_bucket_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket_name = input;
            self
        }
        /// <p>The message indicating that the logs failed to be delivered.</p>
        pub fn last_failure_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_failure_message = Some(input.into());
            self
        }
        /// <p>The message indicating that the logs failed to be delivered.</p>
        pub fn set_last_failure_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_failure_message = input;
            self
        }
        /// <p>The last time when logs failed to be delivered.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn last_failure_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_failure_time = Some(input.into());
            self
        }
        /// <p>The last time when logs failed to be delivered.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_last_failure_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_failure_time = input;
            self
        }
        /// <p>The last time that logs were delivered successfully.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn last_successful_delivery_time(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.last_successful_delivery_time = Some(input.into());
            self
        }
        /// <p>The last time that logs were delivered successfully.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_last_successful_delivery_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_successful_delivery_time = input;
            self
        }
        /// <p>Indicates whether logging is enabled.</p>
        pub fn logging_enabled(mut self, input: bool) -> Self {
            self.logging_enabled = Some(input);
            self
        }
        /// <p>Indicates whether logging is enabled.</p>
        pub fn set_logging_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.logging_enabled = input;
            self
        }
        /// <p>Provides the prefix applied to the log file names.</p>
        pub fn s3_key_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_key_prefix = Some(input.into());
            self
        }
        /// <p>Provides the prefix applied to the log file names.</p>
        pub fn set_s3_key_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_key_prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRedshiftClusterLoggingStatus`](crate::model::AwsRedshiftClusterLoggingStatus)
        pub fn build(self) -> crate::model::AwsRedshiftClusterLoggingStatus {
            crate::model::AwsRedshiftClusterLoggingStatus {
                bucket_name: self.bucket_name,
                last_failure_message: self.last_failure_message,
                last_failure_time: self.last_failure_time,
                last_successful_delivery_time: self.last_successful_delivery_time,
                logging_enabled: self.logging_enabled.unwrap_or_default(),
                s3_key_prefix: self.s3_key_prefix,
            }
        }
    }
}
impl AwsRedshiftClusterLoggingStatus {
    /// Creates a new builder-style object to manufacture [`AwsRedshiftClusterLoggingStatus`](crate::model::AwsRedshiftClusterLoggingStatus)
    pub fn builder() -> crate::model::aws_redshift_cluster_logging_status::Builder {
        crate::model::aws_redshift_cluster_logging_status::Builder::default()
    }
}

/// <p>A VPC security group that the cluster belongs to, if the cluster is in a VPC.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRedshiftClusterVpcSecurityGroup {
    /// <p>The status of the VPC security group.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>The identifier of the VPC security group.</p>
    pub vpc_security_group_id: std::option::Option<std::string::String>,
}
impl AwsRedshiftClusterVpcSecurityGroup {
    /// <p>The status of the VPC security group.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>The identifier of the VPC security group.</p>
    pub fn vpc_security_group_id(&self) -> std::option::Option<&str> {
        self.vpc_security_group_id.as_deref()
    }
}
impl std::fmt::Debug for AwsRedshiftClusterVpcSecurityGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRedshiftClusterVpcSecurityGroup");
        formatter.field("status", &self.status);
        formatter.field("vpc_security_group_id", &self.vpc_security_group_id);
        formatter.finish()
    }
}
/// See [`AwsRedshiftClusterVpcSecurityGroup`](crate::model::AwsRedshiftClusterVpcSecurityGroup)
pub mod aws_redshift_cluster_vpc_security_group {

    /// A builder for [`AwsRedshiftClusterVpcSecurityGroup`](crate::model::AwsRedshiftClusterVpcSecurityGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) vpc_security_group_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The status of the VPC security group.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the VPC security group.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>The identifier of the VPC security group.</p>
        pub fn vpc_security_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_security_group_id = Some(input.into());
            self
        }
        /// <p>The identifier of the VPC security group.</p>
        pub fn set_vpc_security_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_security_group_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRedshiftClusterVpcSecurityGroup`](crate::model::AwsRedshiftClusterVpcSecurityGroup)
        pub fn build(self) -> crate::model::AwsRedshiftClusterVpcSecurityGroup {
            crate::model::AwsRedshiftClusterVpcSecurityGroup {
                status: self.status,
                vpc_security_group_id: self.vpc_security_group_id,
            }
        }
    }
}
impl AwsRedshiftClusterVpcSecurityGroup {
    /// Creates a new builder-style object to manufacture [`AwsRedshiftClusterVpcSecurityGroup`](crate::model::AwsRedshiftClusterVpcSecurityGroup)
    pub fn builder() -> crate::model::aws_redshift_cluster_vpc_security_group::Builder {
        crate::model::aws_redshift_cluster_vpc_security_group::Builder::default()
    }
}

/// <p>Information about the status of a cluster restore action. It only applies if the cluster was created by restoring a snapshot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRedshiftClusterRestoreStatus {
    /// <p>The number of megabytes per second being transferred from the backup storage. Returns the average rate for a completed backup.</p>
    /// <p>This field is only updated when you restore to DC2 and DS2 node types.</p>
    pub current_restore_rate_in_mega_bytes_per_second: f64,
    /// <p>The amount of time an in-progress restore has been running, or the amount of time it took a completed restore to finish.</p>
    /// <p>This field is only updated when you restore to DC2 and DS2 node types.</p>
    pub elapsed_time_in_seconds: i64,
    /// <p>The estimate of the time remaining before the restore is complete. Returns 0 for a completed restore.</p>
    /// <p>This field is only updated when you restore to DC2 and DS2 node types.</p>
    pub estimated_time_to_completion_in_seconds: i64,
    /// <p>The number of megabytes that were transferred from snapshot storage.</p>
    /// <p>This field is only updated when you restore to DC2 and DS2 node types.</p>
    pub progress_in_mega_bytes: i64,
    /// <p>The size of the set of snapshot data that was used to restore the cluster.</p>
    /// <p>This field is only updated when you restore to DC2 and DS2 node types.</p>
    pub snapshot_size_in_mega_bytes: i64,
    /// <p>The status of the restore action.</p>
    /// <p>Valid values: <code>starting</code> | <code>restoring</code> | <code>completed</code> | <code>failed</code> </p>
    pub status: std::option::Option<std::string::String>,
}
impl AwsRedshiftClusterRestoreStatus {
    /// <p>The number of megabytes per second being transferred from the backup storage. Returns the average rate for a completed backup.</p>
    /// <p>This field is only updated when you restore to DC2 and DS2 node types.</p>
    pub fn current_restore_rate_in_mega_bytes_per_second(&self) -> f64 {
        self.current_restore_rate_in_mega_bytes_per_second
    }
    /// <p>The amount of time an in-progress restore has been running, or the amount of time it took a completed restore to finish.</p>
    /// <p>This field is only updated when you restore to DC2 and DS2 node types.</p>
    pub fn elapsed_time_in_seconds(&self) -> i64 {
        self.elapsed_time_in_seconds
    }
    /// <p>The estimate of the time remaining before the restore is complete. Returns 0 for a completed restore.</p>
    /// <p>This field is only updated when you restore to DC2 and DS2 node types.</p>
    pub fn estimated_time_to_completion_in_seconds(&self) -> i64 {
        self.estimated_time_to_completion_in_seconds
    }
    /// <p>The number of megabytes that were transferred from snapshot storage.</p>
    /// <p>This field is only updated when you restore to DC2 and DS2 node types.</p>
    pub fn progress_in_mega_bytes(&self) -> i64 {
        self.progress_in_mega_bytes
    }
    /// <p>The size of the set of snapshot data that was used to restore the cluster.</p>
    /// <p>This field is only updated when you restore to DC2 and DS2 node types.</p>
    pub fn snapshot_size_in_mega_bytes(&self) -> i64 {
        self.snapshot_size_in_mega_bytes
    }
    /// <p>The status of the restore action.</p>
    /// <p>Valid values: <code>starting</code> | <code>restoring</code> | <code>completed</code> | <code>failed</code> </p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
}
impl std::fmt::Debug for AwsRedshiftClusterRestoreStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRedshiftClusterRestoreStatus");
        formatter.field(
            "current_restore_rate_in_mega_bytes_per_second",
            &self.current_restore_rate_in_mega_bytes_per_second,
        );
        formatter.field("elapsed_time_in_seconds", &self.elapsed_time_in_seconds);
        formatter.field(
            "estimated_time_to_completion_in_seconds",
            &self.estimated_time_to_completion_in_seconds,
        );
        formatter.field("progress_in_mega_bytes", &self.progress_in_mega_bytes);
        formatter.field(
            "snapshot_size_in_mega_bytes",
            &self.snapshot_size_in_mega_bytes,
        );
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`AwsRedshiftClusterRestoreStatus`](crate::model::AwsRedshiftClusterRestoreStatus)
pub mod aws_redshift_cluster_restore_status {

    /// A builder for [`AwsRedshiftClusterRestoreStatus`](crate::model::AwsRedshiftClusterRestoreStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) current_restore_rate_in_mega_bytes_per_second: std::option::Option<f64>,
        pub(crate) elapsed_time_in_seconds: std::option::Option<i64>,
        pub(crate) estimated_time_to_completion_in_seconds: std::option::Option<i64>,
        pub(crate) progress_in_mega_bytes: std::option::Option<i64>,
        pub(crate) snapshot_size_in_mega_bytes: std::option::Option<i64>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The number of megabytes per second being transferred from the backup storage. Returns the average rate for a completed backup.</p>
        /// <p>This field is only updated when you restore to DC2 and DS2 node types.</p>
        pub fn current_restore_rate_in_mega_bytes_per_second(mut self, input: f64) -> Self {
            self.current_restore_rate_in_mega_bytes_per_second = Some(input);
            self
        }
        /// <p>The number of megabytes per second being transferred from the backup storage. Returns the average rate for a completed backup.</p>
        /// <p>This field is only updated when you restore to DC2 and DS2 node types.</p>
        pub fn set_current_restore_rate_in_mega_bytes_per_second(
            mut self,
            input: std::option::Option<f64>,
        ) -> Self {
            self.current_restore_rate_in_mega_bytes_per_second = input;
            self
        }
        /// <p>The amount of time an in-progress restore has been running, or the amount of time it took a completed restore to finish.</p>
        /// <p>This field is only updated when you restore to DC2 and DS2 node types.</p>
        pub fn elapsed_time_in_seconds(mut self, input: i64) -> Self {
            self.elapsed_time_in_seconds = Some(input);
            self
        }
        /// <p>The amount of time an in-progress restore has been running, or the amount of time it took a completed restore to finish.</p>
        /// <p>This field is only updated when you restore to DC2 and DS2 node types.</p>
        pub fn set_elapsed_time_in_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.elapsed_time_in_seconds = input;
            self
        }
        /// <p>The estimate of the time remaining before the restore is complete. Returns 0 for a completed restore.</p>
        /// <p>This field is only updated when you restore to DC2 and DS2 node types.</p>
        pub fn estimated_time_to_completion_in_seconds(mut self, input: i64) -> Self {
            self.estimated_time_to_completion_in_seconds = Some(input);
            self
        }
        /// <p>The estimate of the time remaining before the restore is complete. Returns 0 for a completed restore.</p>
        /// <p>This field is only updated when you restore to DC2 and DS2 node types.</p>
        pub fn set_estimated_time_to_completion_in_seconds(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.estimated_time_to_completion_in_seconds = input;
            self
        }
        /// <p>The number of megabytes that were transferred from snapshot storage.</p>
        /// <p>This field is only updated when you restore to DC2 and DS2 node types.</p>
        pub fn progress_in_mega_bytes(mut self, input: i64) -> Self {
            self.progress_in_mega_bytes = Some(input);
            self
        }
        /// <p>The number of megabytes that were transferred from snapshot storage.</p>
        /// <p>This field is only updated when you restore to DC2 and DS2 node types.</p>
        pub fn set_progress_in_mega_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.progress_in_mega_bytes = input;
            self
        }
        /// <p>The size of the set of snapshot data that was used to restore the cluster.</p>
        /// <p>This field is only updated when you restore to DC2 and DS2 node types.</p>
        pub fn snapshot_size_in_mega_bytes(mut self, input: i64) -> Self {
            self.snapshot_size_in_mega_bytes = Some(input);
            self
        }
        /// <p>The size of the set of snapshot data that was used to restore the cluster.</p>
        /// <p>This field is only updated when you restore to DC2 and DS2 node types.</p>
        pub fn set_snapshot_size_in_mega_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.snapshot_size_in_mega_bytes = input;
            self
        }
        /// <p>The status of the restore action.</p>
        /// <p>Valid values: <code>starting</code> | <code>restoring</code> | <code>completed</code> | <code>failed</code> </p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the restore action.</p>
        /// <p>Valid values: <code>starting</code> | <code>restoring</code> | <code>completed</code> | <code>failed</code> </p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRedshiftClusterRestoreStatus`](crate::model::AwsRedshiftClusterRestoreStatus)
        pub fn build(self) -> crate::model::AwsRedshiftClusterRestoreStatus {
            crate::model::AwsRedshiftClusterRestoreStatus {
                current_restore_rate_in_mega_bytes_per_second: self
                    .current_restore_rate_in_mega_bytes_per_second
                    .unwrap_or_default(),
                elapsed_time_in_seconds: self.elapsed_time_in_seconds.unwrap_or_default(),
                estimated_time_to_completion_in_seconds: self
                    .estimated_time_to_completion_in_seconds
                    .unwrap_or_default(),
                progress_in_mega_bytes: self.progress_in_mega_bytes.unwrap_or_default(),
                snapshot_size_in_mega_bytes: self.snapshot_size_in_mega_bytes.unwrap_or_default(),
                status: self.status,
            }
        }
    }
}
impl AwsRedshiftClusterRestoreStatus {
    /// Creates a new builder-style object to manufacture [`AwsRedshiftClusterRestoreStatus`](crate::model::AwsRedshiftClusterRestoreStatus)
    pub fn builder() -> crate::model::aws_redshift_cluster_restore_status::Builder {
        crate::model::aws_redshift_cluster_restore_status::Builder::default()
    }
}

/// <p>Information about the resize operation for the cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRedshiftClusterResizeInfo {
    /// <p>Indicates whether the resize operation can be canceled.</p>
    pub allow_cancel_resize: bool,
    /// <p>The type of resize operation.</p>
    /// <p>Valid values: <code>ClassicResize</code> </p>
    pub resize_type: std::option::Option<std::string::String>,
}
impl AwsRedshiftClusterResizeInfo {
    /// <p>Indicates whether the resize operation can be canceled.</p>
    pub fn allow_cancel_resize(&self) -> bool {
        self.allow_cancel_resize
    }
    /// <p>The type of resize operation.</p>
    /// <p>Valid values: <code>ClassicResize</code> </p>
    pub fn resize_type(&self) -> std::option::Option<&str> {
        self.resize_type.as_deref()
    }
}
impl std::fmt::Debug for AwsRedshiftClusterResizeInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRedshiftClusterResizeInfo");
        formatter.field("allow_cancel_resize", &self.allow_cancel_resize);
        formatter.field("resize_type", &self.resize_type);
        formatter.finish()
    }
}
/// See [`AwsRedshiftClusterResizeInfo`](crate::model::AwsRedshiftClusterResizeInfo)
pub mod aws_redshift_cluster_resize_info {

    /// A builder for [`AwsRedshiftClusterResizeInfo`](crate::model::AwsRedshiftClusterResizeInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) allow_cancel_resize: std::option::Option<bool>,
        pub(crate) resize_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates whether the resize operation can be canceled.</p>
        pub fn allow_cancel_resize(mut self, input: bool) -> Self {
            self.allow_cancel_resize = Some(input);
            self
        }
        /// <p>Indicates whether the resize operation can be canceled.</p>
        pub fn set_allow_cancel_resize(mut self, input: std::option::Option<bool>) -> Self {
            self.allow_cancel_resize = input;
            self
        }
        /// <p>The type of resize operation.</p>
        /// <p>Valid values: <code>ClassicResize</code> </p>
        pub fn resize_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resize_type = Some(input.into());
            self
        }
        /// <p>The type of resize operation.</p>
        /// <p>Valid values: <code>ClassicResize</code> </p>
        pub fn set_resize_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resize_type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRedshiftClusterResizeInfo`](crate::model::AwsRedshiftClusterResizeInfo)
        pub fn build(self) -> crate::model::AwsRedshiftClusterResizeInfo {
            crate::model::AwsRedshiftClusterResizeInfo {
                allow_cancel_resize: self.allow_cancel_resize.unwrap_or_default(),
                resize_type: self.resize_type,
            }
        }
    }
}
impl AwsRedshiftClusterResizeInfo {
    /// Creates a new builder-style object to manufacture [`AwsRedshiftClusterResizeInfo`](crate::model::AwsRedshiftClusterResizeInfo)
    pub fn builder() -> crate::model::aws_redshift_cluster_resize_info::Builder {
        crate::model::aws_redshift_cluster_resize_info::Builder::default()
    }
}

/// <p>Changes to the Amazon Redshift cluster that are currently pending.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRedshiftClusterPendingModifiedValues {
    /// <p>The pending or in-progress change to the automated snapshot retention period.</p>
    pub automated_snapshot_retention_period: i32,
    /// <p>The pending or in-progress change to the identifier for the cluster.</p>
    pub cluster_identifier: std::option::Option<std::string::String>,
    /// <p>The pending or in-progress change to the cluster type.</p>
    pub cluster_type: std::option::Option<std::string::String>,
    /// <p>The pending or in-progress change to the service version.</p>
    pub cluster_version: std::option::Option<std::string::String>,
    /// <p>The encryption type for a cluster.</p>
    pub encryption_type: std::option::Option<std::string::String>,
    /// <p>Indicates whether to create the cluster with enhanced VPC routing enabled.</p>
    pub enhanced_vpc_routing: bool,
    /// <p>The name of the maintenance track that the cluster changes to during the next maintenance window.</p>
    pub maintenance_track_name: std::option::Option<std::string::String>,
    /// <p>The pending or in-progress change to the master user password for the cluster.</p>
    pub master_user_password: std::option::Option<std::string::String>,
    /// <p>The pending or in-progress change to the cluster's node type.</p>
    pub node_type: std::option::Option<std::string::String>,
    /// <p>The pending or in-progress change to the number of nodes in the cluster.</p>
    pub number_of_nodes: i32,
    /// <p>The pending or in-progress change to whether the cluster can be connected to from the public network.</p>
    pub publicly_accessible: bool,
}
impl AwsRedshiftClusterPendingModifiedValues {
    /// <p>The pending or in-progress change to the automated snapshot retention period.</p>
    pub fn automated_snapshot_retention_period(&self) -> i32 {
        self.automated_snapshot_retention_period
    }
    /// <p>The pending or in-progress change to the identifier for the cluster.</p>
    pub fn cluster_identifier(&self) -> std::option::Option<&str> {
        self.cluster_identifier.as_deref()
    }
    /// <p>The pending or in-progress change to the cluster type.</p>
    pub fn cluster_type(&self) -> std::option::Option<&str> {
        self.cluster_type.as_deref()
    }
    /// <p>The pending or in-progress change to the service version.</p>
    pub fn cluster_version(&self) -> std::option::Option<&str> {
        self.cluster_version.as_deref()
    }
    /// <p>The encryption type for a cluster.</p>
    pub fn encryption_type(&self) -> std::option::Option<&str> {
        self.encryption_type.as_deref()
    }
    /// <p>Indicates whether to create the cluster with enhanced VPC routing enabled.</p>
    pub fn enhanced_vpc_routing(&self) -> bool {
        self.enhanced_vpc_routing
    }
    /// <p>The name of the maintenance track that the cluster changes to during the next maintenance window.</p>
    pub fn maintenance_track_name(&self) -> std::option::Option<&str> {
        self.maintenance_track_name.as_deref()
    }
    /// <p>The pending or in-progress change to the master user password for the cluster.</p>
    pub fn master_user_password(&self) -> std::option::Option<&str> {
        self.master_user_password.as_deref()
    }
    /// <p>The pending or in-progress change to the cluster's node type.</p>
    pub fn node_type(&self) -> std::option::Option<&str> {
        self.node_type.as_deref()
    }
    /// <p>The pending or in-progress change to the number of nodes in the cluster.</p>
    pub fn number_of_nodes(&self) -> i32 {
        self.number_of_nodes
    }
    /// <p>The pending or in-progress change to whether the cluster can be connected to from the public network.</p>
    pub fn publicly_accessible(&self) -> bool {
        self.publicly_accessible
    }
}
impl std::fmt::Debug for AwsRedshiftClusterPendingModifiedValues {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRedshiftClusterPendingModifiedValues");
        formatter.field(
            "automated_snapshot_retention_period",
            &self.automated_snapshot_retention_period,
        );
        formatter.field("cluster_identifier", &self.cluster_identifier);
        formatter.field("cluster_type", &self.cluster_type);
        formatter.field("cluster_version", &self.cluster_version);
        formatter.field("encryption_type", &self.encryption_type);
        formatter.field("enhanced_vpc_routing", &self.enhanced_vpc_routing);
        formatter.field("maintenance_track_name", &self.maintenance_track_name);
        formatter.field("master_user_password", &self.master_user_password);
        formatter.field("node_type", &self.node_type);
        formatter.field("number_of_nodes", &self.number_of_nodes);
        formatter.field("publicly_accessible", &self.publicly_accessible);
        formatter.finish()
    }
}
/// See [`AwsRedshiftClusterPendingModifiedValues`](crate::model::AwsRedshiftClusterPendingModifiedValues)
pub mod aws_redshift_cluster_pending_modified_values {

    /// A builder for [`AwsRedshiftClusterPendingModifiedValues`](crate::model::AwsRedshiftClusterPendingModifiedValues)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) automated_snapshot_retention_period: std::option::Option<i32>,
        pub(crate) cluster_identifier: std::option::Option<std::string::String>,
        pub(crate) cluster_type: std::option::Option<std::string::String>,
        pub(crate) cluster_version: std::option::Option<std::string::String>,
        pub(crate) encryption_type: std::option::Option<std::string::String>,
        pub(crate) enhanced_vpc_routing: std::option::Option<bool>,
        pub(crate) maintenance_track_name: std::option::Option<std::string::String>,
        pub(crate) master_user_password: std::option::Option<std::string::String>,
        pub(crate) node_type: std::option::Option<std::string::String>,
        pub(crate) number_of_nodes: std::option::Option<i32>,
        pub(crate) publicly_accessible: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The pending or in-progress change to the automated snapshot retention period.</p>
        pub fn automated_snapshot_retention_period(mut self, input: i32) -> Self {
            self.automated_snapshot_retention_period = Some(input);
            self
        }
        /// <p>The pending or in-progress change to the automated snapshot retention period.</p>
        pub fn set_automated_snapshot_retention_period(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.automated_snapshot_retention_period = input;
            self
        }
        /// <p>The pending or in-progress change to the identifier for the cluster.</p>
        pub fn cluster_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_identifier = Some(input.into());
            self
        }
        /// <p>The pending or in-progress change to the identifier for the cluster.</p>
        pub fn set_cluster_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_identifier = input;
            self
        }
        /// <p>The pending or in-progress change to the cluster type.</p>
        pub fn cluster_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_type = Some(input.into());
            self
        }
        /// <p>The pending or in-progress change to the cluster type.</p>
        pub fn set_cluster_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cluster_type = input;
            self
        }
        /// <p>The pending or in-progress change to the service version.</p>
        pub fn cluster_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_version = Some(input.into());
            self
        }
        /// <p>The pending or in-progress change to the service version.</p>
        pub fn set_cluster_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_version = input;
            self
        }
        /// <p>The encryption type for a cluster.</p>
        pub fn encryption_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.encryption_type = Some(input.into());
            self
        }
        /// <p>The encryption type for a cluster.</p>
        pub fn set_encryption_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.encryption_type = input;
            self
        }
        /// <p>Indicates whether to create the cluster with enhanced VPC routing enabled.</p>
        pub fn enhanced_vpc_routing(mut self, input: bool) -> Self {
            self.enhanced_vpc_routing = Some(input);
            self
        }
        /// <p>Indicates whether to create the cluster with enhanced VPC routing enabled.</p>
        pub fn set_enhanced_vpc_routing(mut self, input: std::option::Option<bool>) -> Self {
            self.enhanced_vpc_routing = input;
            self
        }
        /// <p>The name of the maintenance track that the cluster changes to during the next maintenance window.</p>
        pub fn maintenance_track_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.maintenance_track_name = Some(input.into());
            self
        }
        /// <p>The name of the maintenance track that the cluster changes to during the next maintenance window.</p>
        pub fn set_maintenance_track_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.maintenance_track_name = input;
            self
        }
        /// <p>The pending or in-progress change to the master user password for the cluster.</p>
        pub fn master_user_password(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_user_password = Some(input.into());
            self
        }
        /// <p>The pending or in-progress change to the master user password for the cluster.</p>
        pub fn set_master_user_password(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_user_password = input;
            self
        }
        /// <p>The pending or in-progress change to the cluster's node type.</p>
        pub fn node_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.node_type = Some(input.into());
            self
        }
        /// <p>The pending or in-progress change to the cluster's node type.</p>
        pub fn set_node_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.node_type = input;
            self
        }
        /// <p>The pending or in-progress change to the number of nodes in the cluster.</p>
        pub fn number_of_nodes(mut self, input: i32) -> Self {
            self.number_of_nodes = Some(input);
            self
        }
        /// <p>The pending or in-progress change to the number of nodes in the cluster.</p>
        pub fn set_number_of_nodes(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_nodes = input;
            self
        }
        /// <p>The pending or in-progress change to whether the cluster can be connected to from the public network.</p>
        pub fn publicly_accessible(mut self, input: bool) -> Self {
            self.publicly_accessible = Some(input);
            self
        }
        /// <p>The pending or in-progress change to whether the cluster can be connected to from the public network.</p>
        pub fn set_publicly_accessible(mut self, input: std::option::Option<bool>) -> Self {
            self.publicly_accessible = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRedshiftClusterPendingModifiedValues`](crate::model::AwsRedshiftClusterPendingModifiedValues)
        pub fn build(self) -> crate::model::AwsRedshiftClusterPendingModifiedValues {
            crate::model::AwsRedshiftClusterPendingModifiedValues {
                automated_snapshot_retention_period: self
                    .automated_snapshot_retention_period
                    .unwrap_or_default(),
                cluster_identifier: self.cluster_identifier,
                cluster_type: self.cluster_type,
                cluster_version: self.cluster_version,
                encryption_type: self.encryption_type,
                enhanced_vpc_routing: self.enhanced_vpc_routing.unwrap_or_default(),
                maintenance_track_name: self.maintenance_track_name,
                master_user_password: self.master_user_password,
                node_type: self.node_type,
                number_of_nodes: self.number_of_nodes.unwrap_or_default(),
                publicly_accessible: self.publicly_accessible.unwrap_or_default(),
            }
        }
    }
}
impl AwsRedshiftClusterPendingModifiedValues {
    /// Creates a new builder-style object to manufacture [`AwsRedshiftClusterPendingModifiedValues`](crate::model::AwsRedshiftClusterPendingModifiedValues)
    pub fn builder() -> crate::model::aws_redshift_cluster_pending_modified_values::Builder {
        crate::model::aws_redshift_cluster_pending_modified_values::Builder::default()
    }
}

/// <p>An IAM role that the cluster can use to access other Amazon Web Services services.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRedshiftClusterIamRole {
    /// <p>The status of the IAM role's association with the cluster.</p>
    /// <p>Valid values: <code>in-sync</code> | <code>adding</code> | <code>removing</code> </p>
    pub apply_status: std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM role.</p>
    pub iam_role_arn: std::option::Option<std::string::String>,
}
impl AwsRedshiftClusterIamRole {
    /// <p>The status of the IAM role's association with the cluster.</p>
    /// <p>Valid values: <code>in-sync</code> | <code>adding</code> | <code>removing</code> </p>
    pub fn apply_status(&self) -> std::option::Option<&str> {
        self.apply_status.as_deref()
    }
    /// <p>The ARN of the IAM role.</p>
    pub fn iam_role_arn(&self) -> std::option::Option<&str> {
        self.iam_role_arn.as_deref()
    }
}
impl std::fmt::Debug for AwsRedshiftClusterIamRole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRedshiftClusterIamRole");
        formatter.field("apply_status", &self.apply_status);
        formatter.field("iam_role_arn", &self.iam_role_arn);
        formatter.finish()
    }
}
/// See [`AwsRedshiftClusterIamRole`](crate::model::AwsRedshiftClusterIamRole)
pub mod aws_redshift_cluster_iam_role {

    /// A builder for [`AwsRedshiftClusterIamRole`](crate::model::AwsRedshiftClusterIamRole)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) apply_status: std::option::Option<std::string::String>,
        pub(crate) iam_role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The status of the IAM role's association with the cluster.</p>
        /// <p>Valid values: <code>in-sync</code> | <code>adding</code> | <code>removing</code> </p>
        pub fn apply_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.apply_status = Some(input.into());
            self
        }
        /// <p>The status of the IAM role's association with the cluster.</p>
        /// <p>Valid values: <code>in-sync</code> | <code>adding</code> | <code>removing</code> </p>
        pub fn set_apply_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.apply_status = input;
            self
        }
        /// <p>The ARN of the IAM role.</p>
        pub fn iam_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.iam_role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the IAM role.</p>
        pub fn set_iam_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.iam_role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRedshiftClusterIamRole`](crate::model::AwsRedshiftClusterIamRole)
        pub fn build(self) -> crate::model::AwsRedshiftClusterIamRole {
            crate::model::AwsRedshiftClusterIamRole {
                apply_status: self.apply_status,
                iam_role_arn: self.iam_role_arn,
            }
        }
    }
}
impl AwsRedshiftClusterIamRole {
    /// Creates a new builder-style object to manufacture [`AwsRedshiftClusterIamRole`](crate::model::AwsRedshiftClusterIamRole)
    pub fn builder() -> crate::model::aws_redshift_cluster_iam_role::Builder {
        crate::model::aws_redshift_cluster_iam_role::Builder::default()
    }
}

/// <p>Information about whether an Amazon Redshift cluster finished applying any hardware changes to security module (HSM) settings that were specified in a modify cluster command.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRedshiftClusterHsmStatus {
    /// <p>The name of the HSM client certificate that the Amazon Redshift cluster uses to retrieve the data encryption keys that are stored in an HSM.</p>
    pub hsm_client_certificate_identifier: std::option::Option<std::string::String>,
    /// <p>The name of the HSM configuration that contains the information that the Amazon Redshift cluster can use to retrieve and store keys in an HSM.</p>
    pub hsm_configuration_identifier: std::option::Option<std::string::String>,
    /// <p>Indicates whether the Amazon Redshift cluster has finished applying any HSM settings changes specified in a modify cluster command.</p>
    /// <p>Type: String</p>
    /// <p>Valid values: <code>active</code> | <code>applying</code> </p>
    pub status: std::option::Option<std::string::String>,
}
impl AwsRedshiftClusterHsmStatus {
    /// <p>The name of the HSM client certificate that the Amazon Redshift cluster uses to retrieve the data encryption keys that are stored in an HSM.</p>
    pub fn hsm_client_certificate_identifier(&self) -> std::option::Option<&str> {
        self.hsm_client_certificate_identifier.as_deref()
    }
    /// <p>The name of the HSM configuration that contains the information that the Amazon Redshift cluster can use to retrieve and store keys in an HSM.</p>
    pub fn hsm_configuration_identifier(&self) -> std::option::Option<&str> {
        self.hsm_configuration_identifier.as_deref()
    }
    /// <p>Indicates whether the Amazon Redshift cluster has finished applying any HSM settings changes specified in a modify cluster command.</p>
    /// <p>Type: String</p>
    /// <p>Valid values: <code>active</code> | <code>applying</code> </p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
}
impl std::fmt::Debug for AwsRedshiftClusterHsmStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRedshiftClusterHsmStatus");
        formatter.field(
            "hsm_client_certificate_identifier",
            &self.hsm_client_certificate_identifier,
        );
        formatter.field(
            "hsm_configuration_identifier",
            &self.hsm_configuration_identifier,
        );
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`AwsRedshiftClusterHsmStatus`](crate::model::AwsRedshiftClusterHsmStatus)
pub mod aws_redshift_cluster_hsm_status {

    /// A builder for [`AwsRedshiftClusterHsmStatus`](crate::model::AwsRedshiftClusterHsmStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hsm_client_certificate_identifier: std::option::Option<std::string::String>,
        pub(crate) hsm_configuration_identifier: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the HSM client certificate that the Amazon Redshift cluster uses to retrieve the data encryption keys that are stored in an HSM.</p>
        pub fn hsm_client_certificate_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.hsm_client_certificate_identifier = Some(input.into());
            self
        }
        /// <p>The name of the HSM client certificate that the Amazon Redshift cluster uses to retrieve the data encryption keys that are stored in an HSM.</p>
        pub fn set_hsm_client_certificate_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hsm_client_certificate_identifier = input;
            self
        }
        /// <p>The name of the HSM configuration that contains the information that the Amazon Redshift cluster can use to retrieve and store keys in an HSM.</p>
        pub fn hsm_configuration_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.hsm_configuration_identifier = Some(input.into());
            self
        }
        /// <p>The name of the HSM configuration that contains the information that the Amazon Redshift cluster can use to retrieve and store keys in an HSM.</p>
        pub fn set_hsm_configuration_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hsm_configuration_identifier = input;
            self
        }
        /// <p>Indicates whether the Amazon Redshift cluster has finished applying any HSM settings changes specified in a modify cluster command.</p>
        /// <p>Type: String</p>
        /// <p>Valid values: <code>active</code> | <code>applying</code> </p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>Indicates whether the Amazon Redshift cluster has finished applying any HSM settings changes specified in a modify cluster command.</p>
        /// <p>Type: String</p>
        /// <p>Valid values: <code>active</code> | <code>applying</code> </p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRedshiftClusterHsmStatus`](crate::model::AwsRedshiftClusterHsmStatus)
        pub fn build(self) -> crate::model::AwsRedshiftClusterHsmStatus {
            crate::model::AwsRedshiftClusterHsmStatus {
                hsm_client_certificate_identifier: self.hsm_client_certificate_identifier,
                hsm_configuration_identifier: self.hsm_configuration_identifier,
                status: self.status,
            }
        }
    }
}
impl AwsRedshiftClusterHsmStatus {
    /// Creates a new builder-style object to manufacture [`AwsRedshiftClusterHsmStatus`](crate::model::AwsRedshiftClusterHsmStatus)
    pub fn builder() -> crate::model::aws_redshift_cluster_hsm_status::Builder {
        crate::model::aws_redshift_cluster_hsm_status::Builder::default()
    }
}

/// <p>The connection endpoint for an Amazon Redshift cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRedshiftClusterEndpoint {
    /// <p>The DNS address of the cluster.</p>
    pub address: std::option::Option<std::string::String>,
    /// <p>The port that the database engine listens on.</p>
    pub port: i32,
}
impl AwsRedshiftClusterEndpoint {
    /// <p>The DNS address of the cluster.</p>
    pub fn address(&self) -> std::option::Option<&str> {
        self.address.as_deref()
    }
    /// <p>The port that the database engine listens on.</p>
    pub fn port(&self) -> i32 {
        self.port
    }
}
impl std::fmt::Debug for AwsRedshiftClusterEndpoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRedshiftClusterEndpoint");
        formatter.field("address", &self.address);
        formatter.field("port", &self.port);
        formatter.finish()
    }
}
/// See [`AwsRedshiftClusterEndpoint`](crate::model::AwsRedshiftClusterEndpoint)
pub mod aws_redshift_cluster_endpoint {

    /// A builder for [`AwsRedshiftClusterEndpoint`](crate::model::AwsRedshiftClusterEndpoint)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) address: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The DNS address of the cluster.</p>
        pub fn address(mut self, input: impl Into<std::string::String>) -> Self {
            self.address = Some(input.into());
            self
        }
        /// <p>The DNS address of the cluster.</p>
        pub fn set_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.address = input;
            self
        }
        /// <p>The port that the database engine listens on.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>The port that the database engine listens on.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRedshiftClusterEndpoint`](crate::model::AwsRedshiftClusterEndpoint)
        pub fn build(self) -> crate::model::AwsRedshiftClusterEndpoint {
            crate::model::AwsRedshiftClusterEndpoint {
                address: self.address,
                port: self.port.unwrap_or_default(),
            }
        }
    }
}
impl AwsRedshiftClusterEndpoint {
    /// Creates a new builder-style object to manufacture [`AwsRedshiftClusterEndpoint`](crate::model::AwsRedshiftClusterEndpoint)
    pub fn builder() -> crate::model::aws_redshift_cluster_endpoint::Builder {
        crate::model::aws_redshift_cluster_endpoint::Builder::default()
    }
}

/// <p>The status of the elastic IP (EIP) address for an Amazon Redshift cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRedshiftClusterElasticIpStatus {
    /// <p>The elastic IP address for the cluster.</p>
    pub elastic_ip: std::option::Option<std::string::String>,
    /// <p>The status of the elastic IP address.</p>
    pub status: std::option::Option<std::string::String>,
}
impl AwsRedshiftClusterElasticIpStatus {
    /// <p>The elastic IP address for the cluster.</p>
    pub fn elastic_ip(&self) -> std::option::Option<&str> {
        self.elastic_ip.as_deref()
    }
    /// <p>The status of the elastic IP address.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
}
impl std::fmt::Debug for AwsRedshiftClusterElasticIpStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRedshiftClusterElasticIpStatus");
        formatter.field("elastic_ip", &self.elastic_ip);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`AwsRedshiftClusterElasticIpStatus`](crate::model::AwsRedshiftClusterElasticIpStatus)
pub mod aws_redshift_cluster_elastic_ip_status {

    /// A builder for [`AwsRedshiftClusterElasticIpStatus`](crate::model::AwsRedshiftClusterElasticIpStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) elastic_ip: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The elastic IP address for the cluster.</p>
        pub fn elastic_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.elastic_ip = Some(input.into());
            self
        }
        /// <p>The elastic IP address for the cluster.</p>
        pub fn set_elastic_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.elastic_ip = input;
            self
        }
        /// <p>The status of the elastic IP address.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the elastic IP address.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRedshiftClusterElasticIpStatus`](crate::model::AwsRedshiftClusterElasticIpStatus)
        pub fn build(self) -> crate::model::AwsRedshiftClusterElasticIpStatus {
            crate::model::AwsRedshiftClusterElasticIpStatus {
                elastic_ip: self.elastic_ip,
                status: self.status,
            }
        }
    }
}
impl AwsRedshiftClusterElasticIpStatus {
    /// Creates a new builder-style object to manufacture [`AwsRedshiftClusterElasticIpStatus`](crate::model::AwsRedshiftClusterElasticIpStatus)
    pub fn builder() -> crate::model::aws_redshift_cluster_elastic_ip_status::Builder {
        crate::model::aws_redshift_cluster_elastic_ip_status::Builder::default()
    }
}

/// <p>A time windows during which maintenance was deferred for an Amazon Redshift cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRedshiftClusterDeferredMaintenanceWindow {
    /// <p>The end of the time window for which maintenance was deferred.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub defer_maintenance_end_time: std::option::Option<std::string::String>,
    /// <p>The identifier of the maintenance window.</p>
    pub defer_maintenance_identifier: std::option::Option<std::string::String>,
    /// <p>The start of the time window for which maintenance was deferred.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub defer_maintenance_start_time: std::option::Option<std::string::String>,
}
impl AwsRedshiftClusterDeferredMaintenanceWindow {
    /// <p>The end of the time window for which maintenance was deferred.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn defer_maintenance_end_time(&self) -> std::option::Option<&str> {
        self.defer_maintenance_end_time.as_deref()
    }
    /// <p>The identifier of the maintenance window.</p>
    pub fn defer_maintenance_identifier(&self) -> std::option::Option<&str> {
        self.defer_maintenance_identifier.as_deref()
    }
    /// <p>The start of the time window for which maintenance was deferred.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn defer_maintenance_start_time(&self) -> std::option::Option<&str> {
        self.defer_maintenance_start_time.as_deref()
    }
}
impl std::fmt::Debug for AwsRedshiftClusterDeferredMaintenanceWindow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRedshiftClusterDeferredMaintenanceWindow");
        formatter.field(
            "defer_maintenance_end_time",
            &self.defer_maintenance_end_time,
        );
        formatter.field(
            "defer_maintenance_identifier",
            &self.defer_maintenance_identifier,
        );
        formatter.field(
            "defer_maintenance_start_time",
            &self.defer_maintenance_start_time,
        );
        formatter.finish()
    }
}
/// See [`AwsRedshiftClusterDeferredMaintenanceWindow`](crate::model::AwsRedshiftClusterDeferredMaintenanceWindow)
pub mod aws_redshift_cluster_deferred_maintenance_window {

    /// A builder for [`AwsRedshiftClusterDeferredMaintenanceWindow`](crate::model::AwsRedshiftClusterDeferredMaintenanceWindow)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) defer_maintenance_end_time: std::option::Option<std::string::String>,
        pub(crate) defer_maintenance_identifier: std::option::Option<std::string::String>,
        pub(crate) defer_maintenance_start_time: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The end of the time window for which maintenance was deferred.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn defer_maintenance_end_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.defer_maintenance_end_time = Some(input.into());
            self
        }
        /// <p>The end of the time window for which maintenance was deferred.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_defer_maintenance_end_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.defer_maintenance_end_time = input;
            self
        }
        /// <p>The identifier of the maintenance window.</p>
        pub fn defer_maintenance_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.defer_maintenance_identifier = Some(input.into());
            self
        }
        /// <p>The identifier of the maintenance window.</p>
        pub fn set_defer_maintenance_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.defer_maintenance_identifier = input;
            self
        }
        /// <p>The start of the time window for which maintenance was deferred.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn defer_maintenance_start_time(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.defer_maintenance_start_time = Some(input.into());
            self
        }
        /// <p>The start of the time window for which maintenance was deferred.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_defer_maintenance_start_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.defer_maintenance_start_time = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRedshiftClusterDeferredMaintenanceWindow`](crate::model::AwsRedshiftClusterDeferredMaintenanceWindow)
        pub fn build(self) -> crate::model::AwsRedshiftClusterDeferredMaintenanceWindow {
            crate::model::AwsRedshiftClusterDeferredMaintenanceWindow {
                defer_maintenance_end_time: self.defer_maintenance_end_time,
                defer_maintenance_identifier: self.defer_maintenance_identifier,
                defer_maintenance_start_time: self.defer_maintenance_start_time,
            }
        }
    }
}
impl AwsRedshiftClusterDeferredMaintenanceWindow {
    /// Creates a new builder-style object to manufacture [`AwsRedshiftClusterDeferredMaintenanceWindow`](crate::model::AwsRedshiftClusterDeferredMaintenanceWindow)
    pub fn builder() -> crate::model::aws_redshift_cluster_deferred_maintenance_window::Builder {
        crate::model::aws_redshift_cluster_deferred_maintenance_window::Builder::default()
    }
}

/// <p>Information about a cross-Region snapshot copy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRedshiftClusterClusterSnapshotCopyStatus {
    /// <p>The destination Region that snapshots are automatically copied to when cross-Region snapshot copy is enabled.</p>
    pub destination_region: std::option::Option<std::string::String>,
    /// <p>The number of days that manual snapshots are retained in the destination region after they are copied from a source region.</p>
    /// <p>If the value is <code>-1</code>, then the manual snapshot is retained indefinitely.</p>
    /// <p>Valid values: Either <code>-1</code> or an integer between 1 and 3,653</p>
    pub manual_snapshot_retention_period: i32,
    /// <p>The number of days to retain automated snapshots in the destination Region after they are copied from a source Region.</p>
    pub retention_period: i32,
    /// <p>The name of the snapshot copy grant.</p>
    pub snapshot_copy_grant_name: std::option::Option<std::string::String>,
}
impl AwsRedshiftClusterClusterSnapshotCopyStatus {
    /// <p>The destination Region that snapshots are automatically copied to when cross-Region snapshot copy is enabled.</p>
    pub fn destination_region(&self) -> std::option::Option<&str> {
        self.destination_region.as_deref()
    }
    /// <p>The number of days that manual snapshots are retained in the destination region after they are copied from a source region.</p>
    /// <p>If the value is <code>-1</code>, then the manual snapshot is retained indefinitely.</p>
    /// <p>Valid values: Either <code>-1</code> or an integer between 1 and 3,653</p>
    pub fn manual_snapshot_retention_period(&self) -> i32 {
        self.manual_snapshot_retention_period
    }
    /// <p>The number of days to retain automated snapshots in the destination Region after they are copied from a source Region.</p>
    pub fn retention_period(&self) -> i32 {
        self.retention_period
    }
    /// <p>The name of the snapshot copy grant.</p>
    pub fn snapshot_copy_grant_name(&self) -> std::option::Option<&str> {
        self.snapshot_copy_grant_name.as_deref()
    }
}
impl std::fmt::Debug for AwsRedshiftClusterClusterSnapshotCopyStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRedshiftClusterClusterSnapshotCopyStatus");
        formatter.field("destination_region", &self.destination_region);
        formatter.field(
            "manual_snapshot_retention_period",
            &self.manual_snapshot_retention_period,
        );
        formatter.field("retention_period", &self.retention_period);
        formatter.field("snapshot_copy_grant_name", &self.snapshot_copy_grant_name);
        formatter.finish()
    }
}
/// See [`AwsRedshiftClusterClusterSnapshotCopyStatus`](crate::model::AwsRedshiftClusterClusterSnapshotCopyStatus)
pub mod aws_redshift_cluster_cluster_snapshot_copy_status {

    /// A builder for [`AwsRedshiftClusterClusterSnapshotCopyStatus`](crate::model::AwsRedshiftClusterClusterSnapshotCopyStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_region: std::option::Option<std::string::String>,
        pub(crate) manual_snapshot_retention_period: std::option::Option<i32>,
        pub(crate) retention_period: std::option::Option<i32>,
        pub(crate) snapshot_copy_grant_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The destination Region that snapshots are automatically copied to when cross-Region snapshot copy is enabled.</p>
        pub fn destination_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_region = Some(input.into());
            self
        }
        /// <p>The destination Region that snapshots are automatically copied to when cross-Region snapshot copy is enabled.</p>
        pub fn set_destination_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_region = input;
            self
        }
        /// <p>The number of days that manual snapshots are retained in the destination region after they are copied from a source region.</p>
        /// <p>If the value is <code>-1</code>, then the manual snapshot is retained indefinitely.</p>
        /// <p>Valid values: Either <code>-1</code> or an integer between 1 and 3,653</p>
        pub fn manual_snapshot_retention_period(mut self, input: i32) -> Self {
            self.manual_snapshot_retention_period = Some(input);
            self
        }
        /// <p>The number of days that manual snapshots are retained in the destination region after they are copied from a source region.</p>
        /// <p>If the value is <code>-1</code>, then the manual snapshot is retained indefinitely.</p>
        /// <p>Valid values: Either <code>-1</code> or an integer between 1 and 3,653</p>
        pub fn set_manual_snapshot_retention_period(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.manual_snapshot_retention_period = input;
            self
        }
        /// <p>The number of days to retain automated snapshots in the destination Region after they are copied from a source Region.</p>
        pub fn retention_period(mut self, input: i32) -> Self {
            self.retention_period = Some(input);
            self
        }
        /// <p>The number of days to retain automated snapshots in the destination Region after they are copied from a source Region.</p>
        pub fn set_retention_period(mut self, input: std::option::Option<i32>) -> Self {
            self.retention_period = input;
            self
        }
        /// <p>The name of the snapshot copy grant.</p>
        pub fn snapshot_copy_grant_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_copy_grant_name = Some(input.into());
            self
        }
        /// <p>The name of the snapshot copy grant.</p>
        pub fn set_snapshot_copy_grant_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.snapshot_copy_grant_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRedshiftClusterClusterSnapshotCopyStatus`](crate::model::AwsRedshiftClusterClusterSnapshotCopyStatus)
        pub fn build(self) -> crate::model::AwsRedshiftClusterClusterSnapshotCopyStatus {
            crate::model::AwsRedshiftClusterClusterSnapshotCopyStatus {
                destination_region: self.destination_region,
                manual_snapshot_retention_period: self
                    .manual_snapshot_retention_period
                    .unwrap_or_default(),
                retention_period: self.retention_period.unwrap_or_default(),
                snapshot_copy_grant_name: self.snapshot_copy_grant_name,
            }
        }
    }
}
impl AwsRedshiftClusterClusterSnapshotCopyStatus {
    /// Creates a new builder-style object to manufacture [`AwsRedshiftClusterClusterSnapshotCopyStatus`](crate::model::AwsRedshiftClusterClusterSnapshotCopyStatus)
    pub fn builder() -> crate::model::aws_redshift_cluster_cluster_snapshot_copy_status::Builder {
        crate::model::aws_redshift_cluster_cluster_snapshot_copy_status::Builder::default()
    }
}

/// <p>A security group that is associated with the cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRedshiftClusterClusterSecurityGroup {
    /// <p>The name of the cluster security group.</p>
    pub cluster_security_group_name: std::option::Option<std::string::String>,
    /// <p>The status of the cluster security group.</p>
    pub status: std::option::Option<std::string::String>,
}
impl AwsRedshiftClusterClusterSecurityGroup {
    /// <p>The name of the cluster security group.</p>
    pub fn cluster_security_group_name(&self) -> std::option::Option<&str> {
        self.cluster_security_group_name.as_deref()
    }
    /// <p>The status of the cluster security group.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
}
impl std::fmt::Debug for AwsRedshiftClusterClusterSecurityGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRedshiftClusterClusterSecurityGroup");
        formatter.field(
            "cluster_security_group_name",
            &self.cluster_security_group_name,
        );
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`AwsRedshiftClusterClusterSecurityGroup`](crate::model::AwsRedshiftClusterClusterSecurityGroup)
pub mod aws_redshift_cluster_cluster_security_group {

    /// A builder for [`AwsRedshiftClusterClusterSecurityGroup`](crate::model::AwsRedshiftClusterClusterSecurityGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cluster_security_group_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the cluster security group.</p>
        pub fn cluster_security_group_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.cluster_security_group_name = Some(input.into());
            self
        }
        /// <p>The name of the cluster security group.</p>
        pub fn set_cluster_security_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_security_group_name = input;
            self
        }
        /// <p>The status of the cluster security group.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the cluster security group.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRedshiftClusterClusterSecurityGroup`](crate::model::AwsRedshiftClusterClusterSecurityGroup)
        pub fn build(self) -> crate::model::AwsRedshiftClusterClusterSecurityGroup {
            crate::model::AwsRedshiftClusterClusterSecurityGroup {
                cluster_security_group_name: self.cluster_security_group_name,
                status: self.status,
            }
        }
    }
}
impl AwsRedshiftClusterClusterSecurityGroup {
    /// Creates a new builder-style object to manufacture [`AwsRedshiftClusterClusterSecurityGroup`](crate::model::AwsRedshiftClusterClusterSecurityGroup)
    pub fn builder() -> crate::model::aws_redshift_cluster_cluster_security_group::Builder {
        crate::model::aws_redshift_cluster_cluster_security_group::Builder::default()
    }
}

/// <p>A cluster parameter group that is associated with an Amazon Redshift cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRedshiftClusterClusterParameterGroup {
    /// <p>The list of parameter statuses.</p>
    pub cluster_parameter_status_list:
        std::option::Option<std::vec::Vec<crate::model::AwsRedshiftClusterClusterParameterStatus>>,
    /// <p>The status of updates to the parameters.</p>
    pub parameter_apply_status: std::option::Option<std::string::String>,
    /// <p>The name of the parameter group.</p>
    pub parameter_group_name: std::option::Option<std::string::String>,
}
impl AwsRedshiftClusterClusterParameterGroup {
    /// <p>The list of parameter statuses.</p>
    pub fn cluster_parameter_status_list(
        &self,
    ) -> std::option::Option<&[crate::model::AwsRedshiftClusterClusterParameterStatus]> {
        self.cluster_parameter_status_list.as_deref()
    }
    /// <p>The status of updates to the parameters.</p>
    pub fn parameter_apply_status(&self) -> std::option::Option<&str> {
        self.parameter_apply_status.as_deref()
    }
    /// <p>The name of the parameter group.</p>
    pub fn parameter_group_name(&self) -> std::option::Option<&str> {
        self.parameter_group_name.as_deref()
    }
}
impl std::fmt::Debug for AwsRedshiftClusterClusterParameterGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRedshiftClusterClusterParameterGroup");
        formatter.field(
            "cluster_parameter_status_list",
            &self.cluster_parameter_status_list,
        );
        formatter.field("parameter_apply_status", &self.parameter_apply_status);
        formatter.field("parameter_group_name", &self.parameter_group_name);
        formatter.finish()
    }
}
/// See [`AwsRedshiftClusterClusterParameterGroup`](crate::model::AwsRedshiftClusterClusterParameterGroup)
pub mod aws_redshift_cluster_cluster_parameter_group {

    /// A builder for [`AwsRedshiftClusterClusterParameterGroup`](crate::model::AwsRedshiftClusterClusterParameterGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cluster_parameter_status_list: std::option::Option<
            std::vec::Vec<crate::model::AwsRedshiftClusterClusterParameterStatus>,
        >,
        pub(crate) parameter_apply_status: std::option::Option<std::string::String>,
        pub(crate) parameter_group_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `cluster_parameter_status_list`.
        ///
        /// To override the contents of this collection use [`set_cluster_parameter_status_list`](Self::set_cluster_parameter_status_list).
        ///
        /// <p>The list of parameter statuses.</p>
        pub fn cluster_parameter_status_list(
            mut self,
            input: crate::model::AwsRedshiftClusterClusterParameterStatus,
        ) -> Self {
            let mut v = self.cluster_parameter_status_list.unwrap_or_default();
            v.push(input);
            self.cluster_parameter_status_list = Some(v);
            self
        }
        /// <p>The list of parameter statuses.</p>
        pub fn set_cluster_parameter_status_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsRedshiftClusterClusterParameterStatus>,
            >,
        ) -> Self {
            self.cluster_parameter_status_list = input;
            self
        }
        /// <p>The status of updates to the parameters.</p>
        pub fn parameter_apply_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_apply_status = Some(input.into());
            self
        }
        /// <p>The status of updates to the parameters.</p>
        pub fn set_parameter_apply_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_apply_status = input;
            self
        }
        /// <p>The name of the parameter group.</p>
        pub fn parameter_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_group_name = Some(input.into());
            self
        }
        /// <p>The name of the parameter group.</p>
        pub fn set_parameter_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_group_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRedshiftClusterClusterParameterGroup`](crate::model::AwsRedshiftClusterClusterParameterGroup)
        pub fn build(self) -> crate::model::AwsRedshiftClusterClusterParameterGroup {
            crate::model::AwsRedshiftClusterClusterParameterGroup {
                cluster_parameter_status_list: self.cluster_parameter_status_list,
                parameter_apply_status: self.parameter_apply_status,
                parameter_group_name: self.parameter_group_name,
            }
        }
    }
}
impl AwsRedshiftClusterClusterParameterGroup {
    /// Creates a new builder-style object to manufacture [`AwsRedshiftClusterClusterParameterGroup`](crate::model::AwsRedshiftClusterClusterParameterGroup)
    pub fn builder() -> crate::model::aws_redshift_cluster_cluster_parameter_group::Builder {
        crate::model::aws_redshift_cluster_cluster_parameter_group::Builder::default()
    }
}

/// <p>The status of a parameter in a cluster parameter group for an Amazon Redshift cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRedshiftClusterClusterParameterStatus {
    /// <p>The name of the parameter.</p>
    pub parameter_name: std::option::Option<std::string::String>,
    /// <p>The status of the parameter. Indicates whether the parameter is in sync with the database, waiting for a cluster reboot, or encountered an error when it was applied.</p>
    /// <p>Valid values: <code>in-sync</code> | <code>pending-reboot</code> | <code>applying</code> | <code>invalid-parameter</code> | <code>apply-deferred</code> | <code>apply-error</code> | <code>unknown-error</code> </p>
    pub parameter_apply_status: std::option::Option<std::string::String>,
    /// <p>The error that prevented the parameter from being applied to the database.</p>
    pub parameter_apply_error_description: std::option::Option<std::string::String>,
}
impl AwsRedshiftClusterClusterParameterStatus {
    /// <p>The name of the parameter.</p>
    pub fn parameter_name(&self) -> std::option::Option<&str> {
        self.parameter_name.as_deref()
    }
    /// <p>The status of the parameter. Indicates whether the parameter is in sync with the database, waiting for a cluster reboot, or encountered an error when it was applied.</p>
    /// <p>Valid values: <code>in-sync</code> | <code>pending-reboot</code> | <code>applying</code> | <code>invalid-parameter</code> | <code>apply-deferred</code> | <code>apply-error</code> | <code>unknown-error</code> </p>
    pub fn parameter_apply_status(&self) -> std::option::Option<&str> {
        self.parameter_apply_status.as_deref()
    }
    /// <p>The error that prevented the parameter from being applied to the database.</p>
    pub fn parameter_apply_error_description(&self) -> std::option::Option<&str> {
        self.parameter_apply_error_description.as_deref()
    }
}
impl std::fmt::Debug for AwsRedshiftClusterClusterParameterStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRedshiftClusterClusterParameterStatus");
        formatter.field("parameter_name", &self.parameter_name);
        formatter.field("parameter_apply_status", &self.parameter_apply_status);
        formatter.field(
            "parameter_apply_error_description",
            &self.parameter_apply_error_description,
        );
        formatter.finish()
    }
}
/// See [`AwsRedshiftClusterClusterParameterStatus`](crate::model::AwsRedshiftClusterClusterParameterStatus)
pub mod aws_redshift_cluster_cluster_parameter_status {

    /// A builder for [`AwsRedshiftClusterClusterParameterStatus`](crate::model::AwsRedshiftClusterClusterParameterStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter_name: std::option::Option<std::string::String>,
        pub(crate) parameter_apply_status: std::option::Option<std::string::String>,
        pub(crate) parameter_apply_error_description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the parameter.</p>
        pub fn parameter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_name = Some(input.into());
            self
        }
        /// <p>The name of the parameter.</p>
        pub fn set_parameter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_name = input;
            self
        }
        /// <p>The status of the parameter. Indicates whether the parameter is in sync with the database, waiting for a cluster reboot, or encountered an error when it was applied.</p>
        /// <p>Valid values: <code>in-sync</code> | <code>pending-reboot</code> | <code>applying</code> | <code>invalid-parameter</code> | <code>apply-deferred</code> | <code>apply-error</code> | <code>unknown-error</code> </p>
        pub fn parameter_apply_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_apply_status = Some(input.into());
            self
        }
        /// <p>The status of the parameter. Indicates whether the parameter is in sync with the database, waiting for a cluster reboot, or encountered an error when it was applied.</p>
        /// <p>Valid values: <code>in-sync</code> | <code>pending-reboot</code> | <code>applying</code> | <code>invalid-parameter</code> | <code>apply-deferred</code> | <code>apply-error</code> | <code>unknown-error</code> </p>
        pub fn set_parameter_apply_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_apply_status = input;
            self
        }
        /// <p>The error that prevented the parameter from being applied to the database.</p>
        pub fn parameter_apply_error_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.parameter_apply_error_description = Some(input.into());
            self
        }
        /// <p>The error that prevented the parameter from being applied to the database.</p>
        pub fn set_parameter_apply_error_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_apply_error_description = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRedshiftClusterClusterParameterStatus`](crate::model::AwsRedshiftClusterClusterParameterStatus)
        pub fn build(self) -> crate::model::AwsRedshiftClusterClusterParameterStatus {
            crate::model::AwsRedshiftClusterClusterParameterStatus {
                parameter_name: self.parameter_name,
                parameter_apply_status: self.parameter_apply_status,
                parameter_apply_error_description: self.parameter_apply_error_description,
            }
        }
    }
}
impl AwsRedshiftClusterClusterParameterStatus {
    /// Creates a new builder-style object to manufacture [`AwsRedshiftClusterClusterParameterStatus`](crate::model::AwsRedshiftClusterClusterParameterStatus)
    pub fn builder() -> crate::model::aws_redshift_cluster_cluster_parameter_status::Builder {
        crate::model::aws_redshift_cluster_cluster_parameter_status::Builder::default()
    }
}

/// <p>A node in an Amazon Redshift cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsRedshiftClusterClusterNode {
    /// <p>The role of the node. A node might be a leader node or a compute node.</p>
    pub node_role: std::option::Option<std::string::String>,
    /// <p>The private IP address of the node.</p>
    pub private_ip_address: std::option::Option<std::string::String>,
    /// <p>The public IP address of the node.</p>
    pub public_ip_address: std::option::Option<std::string::String>,
}
impl AwsRedshiftClusterClusterNode {
    /// <p>The role of the node. A node might be a leader node or a compute node.</p>
    pub fn node_role(&self) -> std::option::Option<&str> {
        self.node_role.as_deref()
    }
    /// <p>The private IP address of the node.</p>
    pub fn private_ip_address(&self) -> std::option::Option<&str> {
        self.private_ip_address.as_deref()
    }
    /// <p>The public IP address of the node.</p>
    pub fn public_ip_address(&self) -> std::option::Option<&str> {
        self.public_ip_address.as_deref()
    }
}
impl std::fmt::Debug for AwsRedshiftClusterClusterNode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsRedshiftClusterClusterNode");
        formatter.field("node_role", &self.node_role);
        formatter.field("private_ip_address", &self.private_ip_address);
        formatter.field("public_ip_address", &self.public_ip_address);
        formatter.finish()
    }
}
/// See [`AwsRedshiftClusterClusterNode`](crate::model::AwsRedshiftClusterClusterNode)
pub mod aws_redshift_cluster_cluster_node {

    /// A builder for [`AwsRedshiftClusterClusterNode`](crate::model::AwsRedshiftClusterClusterNode)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) node_role: std::option::Option<std::string::String>,
        pub(crate) private_ip_address: std::option::Option<std::string::String>,
        pub(crate) public_ip_address: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The role of the node. A node might be a leader node or a compute node.</p>
        pub fn node_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.node_role = Some(input.into());
            self
        }
        /// <p>The role of the node. A node might be a leader node or a compute node.</p>
        pub fn set_node_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.node_role = input;
            self
        }
        /// <p>The private IP address of the node.</p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_ip_address = Some(input.into());
            self
        }
        /// <p>The private IP address of the node.</p>
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_ip_address = input;
            self
        }
        /// <p>The public IP address of the node.</p>
        pub fn public_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.public_ip_address = Some(input.into());
            self
        }
        /// <p>The public IP address of the node.</p>
        pub fn set_public_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.public_ip_address = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsRedshiftClusterClusterNode`](crate::model::AwsRedshiftClusterClusterNode)
        pub fn build(self) -> crate::model::AwsRedshiftClusterClusterNode {
            crate::model::AwsRedshiftClusterClusterNode {
                node_role: self.node_role,
                private_ip_address: self.private_ip_address,
                public_ip_address: self.public_ip_address,
            }
        }
    }
}
impl AwsRedshiftClusterClusterNode {
    /// Creates a new builder-style object to manufacture [`AwsRedshiftClusterClusterNode`](crate::model::AwsRedshiftClusterClusterNode)
    pub fn builder() -> crate::model::aws_redshift_cluster_cluster_node::Builder {
        crate::model::aws_redshift_cluster_cluster_node::Builder::default()
    }
}

/// <p>Provides details about an Certificate Manager certificate.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCertificateManagerCertificateDetails {
    /// <p>The ARN of the private certificate authority (CA) that will be used to issue the certificate.</p>
    pub certificate_authority_arn: std::option::Option<std::string::String>,
    /// <p>Indicates when the certificate was requested.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub created_at: std::option::Option<std::string::String>,
    /// <p>The fully qualified domain name (FQDN), such as www.example.com, that is secured by the certificate.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>Contains information about the initial validation of each domain name that occurs as a result of the <code>RequestCertificate</code> request.</p>
    /// <p>Only provided if the certificate type is <code>AMAZON_ISSUED</code>.</p>
    pub domain_validation_options: std::option::Option<
        std::vec::Vec<crate::model::AwsCertificateManagerCertificateDomainValidationOption>,
    >,
    /// <p>Contains a list of Extended Key Usage X.509 v3 extension objects. Each object specifies a purpose for which the certificate public key can be used and consists of a name and an object identifier (OID).</p>
    pub extended_key_usages: std::option::Option<
        std::vec::Vec<crate::model::AwsCertificateManagerCertificateExtendedKeyUsage>,
    >,
    /// <p>For a failed certificate request, the reason for the failure.</p>
    /// <p>Valid values: <code>NO_AVAILABLE_CONTACTS</code> | <code>ADDITIONAL_VERIFICATION_REQUIRED</code> | <code>DOMAIN_NOT_ALLOWED</code> | <code>INVALID_PUBLIC_DOMAIN</code> | <code>DOMAIN_VALIDATION_DENIED</code> | <code>CAA_ERROR</code> | <code>PCA_LIMIT_EXCEEDED</code> | <code>PCA_INVALID_ARN</code> | <code>PCA_INVALID_STATE</code> | <code>PCA_REQUEST_FAILED</code> | <code>PCA_NAME_CONSTRAINTS_VALIDATION</code> | <code>PCA_RESOURCE_NOT_FOUND</code> | <code>PCA_INVALID_ARGS</code> | <code>PCA_INVALID_DURATION</code> | <code>PCA_ACCESS_DENIED</code> | <code>SLR_NOT_FOUND</code> | <code>OTHER</code> </p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>Indicates when the certificate was imported. Provided if the certificate type is <code>IMPORTED</code>.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub imported_at: std::option::Option<std::string::String>,
    /// <p>The list of ARNs for the Amazon Web Services resources that use the certificate.</p>
    pub in_use_by: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Indicates when the certificate was issued. Provided if the certificate type is <code>AMAZON_ISSUED</code>.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub issued_at: std::option::Option<std::string::String>,
    /// <p>The name of the certificate authority that issued and signed the certificate.</p>
    pub issuer: std::option::Option<std::string::String>,
    /// <p>The algorithm that was used to generate the public-private key pair.</p>
    /// <p>Valid values: <code>RSA_2048</code> | <code>RSA_1024</code> |<code> RSA_4096</code> | <code>EC_prime256v1</code> | <code>EC_secp384r1</code> | <code>EC_secp521r1</code> </p>
    pub key_algorithm: std::option::Option<std::string::String>,
    /// <p>A list of key usage X.509 v3 extension objects.</p>
    pub key_usages:
        std::option::Option<std::vec::Vec<crate::model::AwsCertificateManagerCertificateKeyUsage>>,
    /// <p>The time after which the certificate becomes invalid.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub not_after: std::option::Option<std::string::String>,
    /// <p>The time before which the certificate is not valid.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub not_before: std::option::Option<std::string::String>,
    /// <p>Provides a value that specifies whether to add the certificate to a transparency log.</p>
    pub options: std::option::Option<crate::model::AwsCertificateManagerCertificateOptions>,
    /// <p>Whether the certificate is eligible for renewal.</p>
    /// <p>Valid values: <code>ELIGIBLE</code> | <code>INELIGIBLE</code> </p>
    pub renewal_eligibility: std::option::Option<std::string::String>,
    /// <p>Information about the status of the Certificate Manager managed renewal for the certificate. Provided only when the certificate type is <code>AMAZON_ISSUED</code>.</p>
    pub renewal_summary:
        std::option::Option<crate::model::AwsCertificateManagerCertificateRenewalSummary>,
    /// <p>The serial number of the certificate.</p>
    pub serial: std::option::Option<std::string::String>,
    /// <p>The algorithm that was used to sign the certificate.</p>
    pub signature_algorithm: std::option::Option<std::string::String>,
    /// <p>The status of the certificate.</p>
    /// <p>Valid values: <code>PENDING_VALIDATION</code> | <code>ISSUED</code> | <code>INACTIVE</code> | <code>EXPIRED</code> | <code>VALIDATION_TIMED_OUT</code> | <code>REVOKED</code> | <code>FAILED</code> </p>
    pub status: std::option::Option<std::string::String>,
    /// <p>The name of the entity that is associated with the public key contained in the certificate.</p>
    pub subject: std::option::Option<std::string::String>,
    /// <p>One or more domain names (subject alternative names) included in the certificate. This list contains the domain names that are bound to the public key that is contained in the certificate.</p>
    /// <p>The subject alternative names include the canonical domain name (CN) of the certificate and additional domain names that can be used to connect to the website.</p>
    pub subject_alternative_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The source of the certificate. For certificates that Certificate Manager provides, <code>Type</code> is <code>AMAZON_ISSUED</code>. For certificates that are imported with <code>ImportCertificate</code>, <code>Type</code> is <code>IMPORTED</code>.</p>
    /// <p>Valid values: <code>IMPORTED</code> | <code>AMAZON_ISSUED</code> | <code>PRIVATE</code> </p>
    pub r#type: std::option::Option<std::string::String>,
}
impl AwsCertificateManagerCertificateDetails {
    /// <p>The ARN of the private certificate authority (CA) that will be used to issue the certificate.</p>
    pub fn certificate_authority_arn(&self) -> std::option::Option<&str> {
        self.certificate_authority_arn.as_deref()
    }
    /// <p>Indicates when the certificate was requested.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn created_at(&self) -> std::option::Option<&str> {
        self.created_at.as_deref()
    }
    /// <p>The fully qualified domain name (FQDN), such as www.example.com, that is secured by the certificate.</p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p>Contains information about the initial validation of each domain name that occurs as a result of the <code>RequestCertificate</code> request.</p>
    /// <p>Only provided if the certificate type is <code>AMAZON_ISSUED</code>.</p>
    pub fn domain_validation_options(
        &self,
    ) -> std::option::Option<&[crate::model::AwsCertificateManagerCertificateDomainValidationOption]>
    {
        self.domain_validation_options.as_deref()
    }
    /// <p>Contains a list of Extended Key Usage X.509 v3 extension objects. Each object specifies a purpose for which the certificate public key can be used and consists of a name and an object identifier (OID).</p>
    pub fn extended_key_usages(
        &self,
    ) -> std::option::Option<&[crate::model::AwsCertificateManagerCertificateExtendedKeyUsage]>
    {
        self.extended_key_usages.as_deref()
    }
    /// <p>For a failed certificate request, the reason for the failure.</p>
    /// <p>Valid values: <code>NO_AVAILABLE_CONTACTS</code> | <code>ADDITIONAL_VERIFICATION_REQUIRED</code> | <code>DOMAIN_NOT_ALLOWED</code> | <code>INVALID_PUBLIC_DOMAIN</code> | <code>DOMAIN_VALIDATION_DENIED</code> | <code>CAA_ERROR</code> | <code>PCA_LIMIT_EXCEEDED</code> | <code>PCA_INVALID_ARN</code> | <code>PCA_INVALID_STATE</code> | <code>PCA_REQUEST_FAILED</code> | <code>PCA_NAME_CONSTRAINTS_VALIDATION</code> | <code>PCA_RESOURCE_NOT_FOUND</code> | <code>PCA_INVALID_ARGS</code> | <code>PCA_INVALID_DURATION</code> | <code>PCA_ACCESS_DENIED</code> | <code>SLR_NOT_FOUND</code> | <code>OTHER</code> </p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>Indicates when the certificate was imported. Provided if the certificate type is <code>IMPORTED</code>.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn imported_at(&self) -> std::option::Option<&str> {
        self.imported_at.as_deref()
    }
    /// <p>The list of ARNs for the Amazon Web Services resources that use the certificate.</p>
    pub fn in_use_by(&self) -> std::option::Option<&[std::string::String]> {
        self.in_use_by.as_deref()
    }
    /// <p>Indicates when the certificate was issued. Provided if the certificate type is <code>AMAZON_ISSUED</code>.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn issued_at(&self) -> std::option::Option<&str> {
        self.issued_at.as_deref()
    }
    /// <p>The name of the certificate authority that issued and signed the certificate.</p>
    pub fn issuer(&self) -> std::option::Option<&str> {
        self.issuer.as_deref()
    }
    /// <p>The algorithm that was used to generate the public-private key pair.</p>
    /// <p>Valid values: <code>RSA_2048</code> | <code>RSA_1024</code> |<code> RSA_4096</code> | <code>EC_prime256v1</code> | <code>EC_secp384r1</code> | <code>EC_secp521r1</code> </p>
    pub fn key_algorithm(&self) -> std::option::Option<&str> {
        self.key_algorithm.as_deref()
    }
    /// <p>A list of key usage X.509 v3 extension objects.</p>
    pub fn key_usages(
        &self,
    ) -> std::option::Option<&[crate::model::AwsCertificateManagerCertificateKeyUsage]> {
        self.key_usages.as_deref()
    }
    /// <p>The time after which the certificate becomes invalid.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn not_after(&self) -> std::option::Option<&str> {
        self.not_after.as_deref()
    }
    /// <p>The time before which the certificate is not valid.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn not_before(&self) -> std::option::Option<&str> {
        self.not_before.as_deref()
    }
    /// <p>Provides a value that specifies whether to add the certificate to a transparency log.</p>
    pub fn options(
        &self,
    ) -> std::option::Option<&crate::model::AwsCertificateManagerCertificateOptions> {
        self.options.as_ref()
    }
    /// <p>Whether the certificate is eligible for renewal.</p>
    /// <p>Valid values: <code>ELIGIBLE</code> | <code>INELIGIBLE</code> </p>
    pub fn renewal_eligibility(&self) -> std::option::Option<&str> {
        self.renewal_eligibility.as_deref()
    }
    /// <p>Information about the status of the Certificate Manager managed renewal for the certificate. Provided only when the certificate type is <code>AMAZON_ISSUED</code>.</p>
    pub fn renewal_summary(
        &self,
    ) -> std::option::Option<&crate::model::AwsCertificateManagerCertificateRenewalSummary> {
        self.renewal_summary.as_ref()
    }
    /// <p>The serial number of the certificate.</p>
    pub fn serial(&self) -> std::option::Option<&str> {
        self.serial.as_deref()
    }
    /// <p>The algorithm that was used to sign the certificate.</p>
    pub fn signature_algorithm(&self) -> std::option::Option<&str> {
        self.signature_algorithm.as_deref()
    }
    /// <p>The status of the certificate.</p>
    /// <p>Valid values: <code>PENDING_VALIDATION</code> | <code>ISSUED</code> | <code>INACTIVE</code> | <code>EXPIRED</code> | <code>VALIDATION_TIMED_OUT</code> | <code>REVOKED</code> | <code>FAILED</code> </p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>The name of the entity that is associated with the public key contained in the certificate.</p>
    pub fn subject(&self) -> std::option::Option<&str> {
        self.subject.as_deref()
    }
    /// <p>One or more domain names (subject alternative names) included in the certificate. This list contains the domain names that are bound to the public key that is contained in the certificate.</p>
    /// <p>The subject alternative names include the canonical domain name (CN) of the certificate and additional domain names that can be used to connect to the website.</p>
    pub fn subject_alternative_names(&self) -> std::option::Option<&[std::string::String]> {
        self.subject_alternative_names.as_deref()
    }
    /// <p>The source of the certificate. For certificates that Certificate Manager provides, <code>Type</code> is <code>AMAZON_ISSUED</code>. For certificates that are imported with <code>ImportCertificate</code>, <code>Type</code> is <code>IMPORTED</code>.</p>
    /// <p>Valid values: <code>IMPORTED</code> | <code>AMAZON_ISSUED</code> | <code>PRIVATE</code> </p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for AwsCertificateManagerCertificateDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCertificateManagerCertificateDetails");
        formatter.field("certificate_authority_arn", &self.certificate_authority_arn);
        formatter.field("created_at", &self.created_at);
        formatter.field("domain_name", &self.domain_name);
        formatter.field("domain_validation_options", &self.domain_validation_options);
        formatter.field("extended_key_usages", &self.extended_key_usages);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("imported_at", &self.imported_at);
        formatter.field("in_use_by", &self.in_use_by);
        formatter.field("issued_at", &self.issued_at);
        formatter.field("issuer", &self.issuer);
        formatter.field("key_algorithm", &self.key_algorithm);
        formatter.field("key_usages", &self.key_usages);
        formatter.field("not_after", &self.not_after);
        formatter.field("not_before", &self.not_before);
        formatter.field("options", &self.options);
        formatter.field("renewal_eligibility", &self.renewal_eligibility);
        formatter.field("renewal_summary", &self.renewal_summary);
        formatter.field("serial", &self.serial);
        formatter.field("signature_algorithm", &self.signature_algorithm);
        formatter.field("status", &self.status);
        formatter.field("subject", &self.subject);
        formatter.field("subject_alternative_names", &self.subject_alternative_names);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AwsCertificateManagerCertificateDetails`](crate::model::AwsCertificateManagerCertificateDetails)
pub mod aws_certificate_manager_certificate_details {

    /// A builder for [`AwsCertificateManagerCertificateDetails`](crate::model::AwsCertificateManagerCertificateDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) certificate_authority_arn: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<std::string::String>,
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) domain_validation_options: std::option::Option<
            std::vec::Vec<crate::model::AwsCertificateManagerCertificateDomainValidationOption>,
        >,
        pub(crate) extended_key_usages: std::option::Option<
            std::vec::Vec<crate::model::AwsCertificateManagerCertificateExtendedKeyUsage>,
        >,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) imported_at: std::option::Option<std::string::String>,
        pub(crate) in_use_by: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) issued_at: std::option::Option<std::string::String>,
        pub(crate) issuer: std::option::Option<std::string::String>,
        pub(crate) key_algorithm: std::option::Option<std::string::String>,
        pub(crate) key_usages: std::option::Option<
            std::vec::Vec<crate::model::AwsCertificateManagerCertificateKeyUsage>,
        >,
        pub(crate) not_after: std::option::Option<std::string::String>,
        pub(crate) not_before: std::option::Option<std::string::String>,
        pub(crate) options:
            std::option::Option<crate::model::AwsCertificateManagerCertificateOptions>,
        pub(crate) renewal_eligibility: std::option::Option<std::string::String>,
        pub(crate) renewal_summary:
            std::option::Option<crate::model::AwsCertificateManagerCertificateRenewalSummary>,
        pub(crate) serial: std::option::Option<std::string::String>,
        pub(crate) signature_algorithm: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) subject: std::option::Option<std::string::String>,
        pub(crate) subject_alternative_names:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the private certificate authority (CA) that will be used to issue the certificate.</p>
        pub fn certificate_authority_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_authority_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the private certificate authority (CA) that will be used to issue the certificate.</p>
        pub fn set_certificate_authority_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_authority_arn = input;
            self
        }
        /// <p>Indicates when the certificate was requested.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn created_at(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_at = Some(input.into());
            self
        }
        /// <p>Indicates when the certificate was requested.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_created_at(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The fully qualified domain name (FQDN), such as www.example.com, that is secured by the certificate.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>The fully qualified domain name (FQDN), such as www.example.com, that is secured by the certificate.</p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// Appends an item to `domain_validation_options`.
        ///
        /// To override the contents of this collection use [`set_domain_validation_options`](Self::set_domain_validation_options).
        ///
        /// <p>Contains information about the initial validation of each domain name that occurs as a result of the <code>RequestCertificate</code> request.</p>
        /// <p>Only provided if the certificate type is <code>AMAZON_ISSUED</code>.</p>
        pub fn domain_validation_options(
            mut self,
            input: crate::model::AwsCertificateManagerCertificateDomainValidationOption,
        ) -> Self {
            let mut v = self.domain_validation_options.unwrap_or_default();
            v.push(input);
            self.domain_validation_options = Some(v);
            self
        }
        /// <p>Contains information about the initial validation of each domain name that occurs as a result of the <code>RequestCertificate</code> request.</p>
        /// <p>Only provided if the certificate type is <code>AMAZON_ISSUED</code>.</p>
        pub fn set_domain_validation_options(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsCertificateManagerCertificateDomainValidationOption>,
            >,
        ) -> Self {
            self.domain_validation_options = input;
            self
        }
        /// Appends an item to `extended_key_usages`.
        ///
        /// To override the contents of this collection use [`set_extended_key_usages`](Self::set_extended_key_usages).
        ///
        /// <p>Contains a list of Extended Key Usage X.509 v3 extension objects. Each object specifies a purpose for which the certificate public key can be used and consists of a name and an object identifier (OID).</p>
        pub fn extended_key_usages(
            mut self,
            input: crate::model::AwsCertificateManagerCertificateExtendedKeyUsage,
        ) -> Self {
            let mut v = self.extended_key_usages.unwrap_or_default();
            v.push(input);
            self.extended_key_usages = Some(v);
            self
        }
        /// <p>Contains a list of Extended Key Usage X.509 v3 extension objects. Each object specifies a purpose for which the certificate public key can be used and consists of a name and an object identifier (OID).</p>
        pub fn set_extended_key_usages(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsCertificateManagerCertificateExtendedKeyUsage>,
            >,
        ) -> Self {
            self.extended_key_usages = input;
            self
        }
        /// <p>For a failed certificate request, the reason for the failure.</p>
        /// <p>Valid values: <code>NO_AVAILABLE_CONTACTS</code> | <code>ADDITIONAL_VERIFICATION_REQUIRED</code> | <code>DOMAIN_NOT_ALLOWED</code> | <code>INVALID_PUBLIC_DOMAIN</code> | <code>DOMAIN_VALIDATION_DENIED</code> | <code>CAA_ERROR</code> | <code>PCA_LIMIT_EXCEEDED</code> | <code>PCA_INVALID_ARN</code> | <code>PCA_INVALID_STATE</code> | <code>PCA_REQUEST_FAILED</code> | <code>PCA_NAME_CONSTRAINTS_VALIDATION</code> | <code>PCA_RESOURCE_NOT_FOUND</code> | <code>PCA_INVALID_ARGS</code> | <code>PCA_INVALID_DURATION</code> | <code>PCA_ACCESS_DENIED</code> | <code>SLR_NOT_FOUND</code> | <code>OTHER</code> </p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>For a failed certificate request, the reason for the failure.</p>
        /// <p>Valid values: <code>NO_AVAILABLE_CONTACTS</code> | <code>ADDITIONAL_VERIFICATION_REQUIRED</code> | <code>DOMAIN_NOT_ALLOWED</code> | <code>INVALID_PUBLIC_DOMAIN</code> | <code>DOMAIN_VALIDATION_DENIED</code> | <code>CAA_ERROR</code> | <code>PCA_LIMIT_EXCEEDED</code> | <code>PCA_INVALID_ARN</code> | <code>PCA_INVALID_STATE</code> | <code>PCA_REQUEST_FAILED</code> | <code>PCA_NAME_CONSTRAINTS_VALIDATION</code> | <code>PCA_RESOURCE_NOT_FOUND</code> | <code>PCA_INVALID_ARGS</code> | <code>PCA_INVALID_DURATION</code> | <code>PCA_ACCESS_DENIED</code> | <code>SLR_NOT_FOUND</code> | <code>OTHER</code> </p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>Indicates when the certificate was imported. Provided if the certificate type is <code>IMPORTED</code>.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn imported_at(mut self, input: impl Into<std::string::String>) -> Self {
            self.imported_at = Some(input.into());
            self
        }
        /// <p>Indicates when the certificate was imported. Provided if the certificate type is <code>IMPORTED</code>.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_imported_at(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.imported_at = input;
            self
        }
        /// Appends an item to `in_use_by`.
        ///
        /// To override the contents of this collection use [`set_in_use_by`](Self::set_in_use_by).
        ///
        /// <p>The list of ARNs for the Amazon Web Services resources that use the certificate.</p>
        pub fn in_use_by(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.in_use_by.unwrap_or_default();
            v.push(input.into());
            self.in_use_by = Some(v);
            self
        }
        /// <p>The list of ARNs for the Amazon Web Services resources that use the certificate.</p>
        pub fn set_in_use_by(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.in_use_by = input;
            self
        }
        /// <p>Indicates when the certificate was issued. Provided if the certificate type is <code>AMAZON_ISSUED</code>.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn issued_at(mut self, input: impl Into<std::string::String>) -> Self {
            self.issued_at = Some(input.into());
            self
        }
        /// <p>Indicates when the certificate was issued. Provided if the certificate type is <code>AMAZON_ISSUED</code>.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_issued_at(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.issued_at = input;
            self
        }
        /// <p>The name of the certificate authority that issued and signed the certificate.</p>
        pub fn issuer(mut self, input: impl Into<std::string::String>) -> Self {
            self.issuer = Some(input.into());
            self
        }
        /// <p>The name of the certificate authority that issued and signed the certificate.</p>
        pub fn set_issuer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.issuer = input;
            self
        }
        /// <p>The algorithm that was used to generate the public-private key pair.</p>
        /// <p>Valid values: <code>RSA_2048</code> | <code>RSA_1024</code> |<code> RSA_4096</code> | <code>EC_prime256v1</code> | <code>EC_secp384r1</code> | <code>EC_secp521r1</code> </p>
        pub fn key_algorithm(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_algorithm = Some(input.into());
            self
        }
        /// <p>The algorithm that was used to generate the public-private key pair.</p>
        /// <p>Valid values: <code>RSA_2048</code> | <code>RSA_1024</code> |<code> RSA_4096</code> | <code>EC_prime256v1</code> | <code>EC_secp384r1</code> | <code>EC_secp521r1</code> </p>
        pub fn set_key_algorithm(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.key_algorithm = input;
            self
        }
        /// Appends an item to `key_usages`.
        ///
        /// To override the contents of this collection use [`set_key_usages`](Self::set_key_usages).
        ///
        /// <p>A list of key usage X.509 v3 extension objects.</p>
        pub fn key_usages(
            mut self,
            input: crate::model::AwsCertificateManagerCertificateKeyUsage,
        ) -> Self {
            let mut v = self.key_usages.unwrap_or_default();
            v.push(input);
            self.key_usages = Some(v);
            self
        }
        /// <p>A list of key usage X.509 v3 extension objects.</p>
        pub fn set_key_usages(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsCertificateManagerCertificateKeyUsage>,
            >,
        ) -> Self {
            self.key_usages = input;
            self
        }
        /// <p>The time after which the certificate becomes invalid.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn not_after(mut self, input: impl Into<std::string::String>) -> Self {
            self.not_after = Some(input.into());
            self
        }
        /// <p>The time after which the certificate becomes invalid.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_not_after(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.not_after = input;
            self
        }
        /// <p>The time before which the certificate is not valid.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn not_before(mut self, input: impl Into<std::string::String>) -> Self {
            self.not_before = Some(input.into());
            self
        }
        /// <p>The time before which the certificate is not valid.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_not_before(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.not_before = input;
            self
        }
        /// <p>Provides a value that specifies whether to add the certificate to a transparency log.</p>
        pub fn options(
            mut self,
            input: crate::model::AwsCertificateManagerCertificateOptions,
        ) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>Provides a value that specifies whether to add the certificate to a transparency log.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::AwsCertificateManagerCertificateOptions>,
        ) -> Self {
            self.options = input;
            self
        }
        /// <p>Whether the certificate is eligible for renewal.</p>
        /// <p>Valid values: <code>ELIGIBLE</code> | <code>INELIGIBLE</code> </p>
        pub fn renewal_eligibility(mut self, input: impl Into<std::string::String>) -> Self {
            self.renewal_eligibility = Some(input.into());
            self
        }
        /// <p>Whether the certificate is eligible for renewal.</p>
        /// <p>Valid values: <code>ELIGIBLE</code> | <code>INELIGIBLE</code> </p>
        pub fn set_renewal_eligibility(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.renewal_eligibility = input;
            self
        }
        /// <p>Information about the status of the Certificate Manager managed renewal for the certificate. Provided only when the certificate type is <code>AMAZON_ISSUED</code>.</p>
        pub fn renewal_summary(
            mut self,
            input: crate::model::AwsCertificateManagerCertificateRenewalSummary,
        ) -> Self {
            self.renewal_summary = Some(input);
            self
        }
        /// <p>Information about the status of the Certificate Manager managed renewal for the certificate. Provided only when the certificate type is <code>AMAZON_ISSUED</code>.</p>
        pub fn set_renewal_summary(
            mut self,
            input: std::option::Option<
                crate::model::AwsCertificateManagerCertificateRenewalSummary,
            >,
        ) -> Self {
            self.renewal_summary = input;
            self
        }
        /// <p>The serial number of the certificate.</p>
        pub fn serial(mut self, input: impl Into<std::string::String>) -> Self {
            self.serial = Some(input.into());
            self
        }
        /// <p>The serial number of the certificate.</p>
        pub fn set_serial(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.serial = input;
            self
        }
        /// <p>The algorithm that was used to sign the certificate.</p>
        pub fn signature_algorithm(mut self, input: impl Into<std::string::String>) -> Self {
            self.signature_algorithm = Some(input.into());
            self
        }
        /// <p>The algorithm that was used to sign the certificate.</p>
        pub fn set_signature_algorithm(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.signature_algorithm = input;
            self
        }
        /// <p>The status of the certificate.</p>
        /// <p>Valid values: <code>PENDING_VALIDATION</code> | <code>ISSUED</code> | <code>INACTIVE</code> | <code>EXPIRED</code> | <code>VALIDATION_TIMED_OUT</code> | <code>REVOKED</code> | <code>FAILED</code> </p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the certificate.</p>
        /// <p>Valid values: <code>PENDING_VALIDATION</code> | <code>ISSUED</code> | <code>INACTIVE</code> | <code>EXPIRED</code> | <code>VALIDATION_TIMED_OUT</code> | <code>REVOKED</code> | <code>FAILED</code> </p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>The name of the entity that is associated with the public key contained in the certificate.</p>
        pub fn subject(mut self, input: impl Into<std::string::String>) -> Self {
            self.subject = Some(input.into());
            self
        }
        /// <p>The name of the entity that is associated with the public key contained in the certificate.</p>
        pub fn set_subject(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subject = input;
            self
        }
        /// Appends an item to `subject_alternative_names`.
        ///
        /// To override the contents of this collection use [`set_subject_alternative_names`](Self::set_subject_alternative_names).
        ///
        /// <p>One or more domain names (subject alternative names) included in the certificate. This list contains the domain names that are bound to the public key that is contained in the certificate.</p>
        /// <p>The subject alternative names include the canonical domain name (CN) of the certificate and additional domain names that can be used to connect to the website.</p>
        pub fn subject_alternative_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subject_alternative_names.unwrap_or_default();
            v.push(input.into());
            self.subject_alternative_names = Some(v);
            self
        }
        /// <p>One or more domain names (subject alternative names) included in the certificate. This list contains the domain names that are bound to the public key that is contained in the certificate.</p>
        /// <p>The subject alternative names include the canonical domain name (CN) of the certificate and additional domain names that can be used to connect to the website.</p>
        pub fn set_subject_alternative_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subject_alternative_names = input;
            self
        }
        /// <p>The source of the certificate. For certificates that Certificate Manager provides, <code>Type</code> is <code>AMAZON_ISSUED</code>. For certificates that are imported with <code>ImportCertificate</code>, <code>Type</code> is <code>IMPORTED</code>.</p>
        /// <p>Valid values: <code>IMPORTED</code> | <code>AMAZON_ISSUED</code> | <code>PRIVATE</code> </p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The source of the certificate. For certificates that Certificate Manager provides, <code>Type</code> is <code>AMAZON_ISSUED</code>. For certificates that are imported with <code>ImportCertificate</code>, <code>Type</code> is <code>IMPORTED</code>.</p>
        /// <p>Valid values: <code>IMPORTED</code> | <code>AMAZON_ISSUED</code> | <code>PRIVATE</code> </p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCertificateManagerCertificateDetails`](crate::model::AwsCertificateManagerCertificateDetails)
        pub fn build(self) -> crate::model::AwsCertificateManagerCertificateDetails {
            crate::model::AwsCertificateManagerCertificateDetails {
                certificate_authority_arn: self.certificate_authority_arn,
                created_at: self.created_at,
                domain_name: self.domain_name,
                domain_validation_options: self.domain_validation_options,
                extended_key_usages: self.extended_key_usages,
                failure_reason: self.failure_reason,
                imported_at: self.imported_at,
                in_use_by: self.in_use_by,
                issued_at: self.issued_at,
                issuer: self.issuer,
                key_algorithm: self.key_algorithm,
                key_usages: self.key_usages,
                not_after: self.not_after,
                not_before: self.not_before,
                options: self.options,
                renewal_eligibility: self.renewal_eligibility,
                renewal_summary: self.renewal_summary,
                serial: self.serial,
                signature_algorithm: self.signature_algorithm,
                status: self.status,
                subject: self.subject,
                subject_alternative_names: self.subject_alternative_names,
                r#type: self.r#type,
            }
        }
    }
}
impl AwsCertificateManagerCertificateDetails {
    /// Creates a new builder-style object to manufacture [`AwsCertificateManagerCertificateDetails`](crate::model::AwsCertificateManagerCertificateDetails)
    pub fn builder() -> crate::model::aws_certificate_manager_certificate_details::Builder {
        crate::model::aws_certificate_manager_certificate_details::Builder::default()
    }
}

/// <p>Contains information about the Certificate Manager managed renewal for an <code>AMAZON_ISSUED</code> certificate.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCertificateManagerCertificateRenewalSummary {
    /// <p>Information about the validation of each domain name in the certificate, as it pertains to Certificate Manager managed renewal. Provided only when the certificate type is <code>AMAZON_ISSUED</code>.</p>
    pub domain_validation_options: std::option::Option<
        std::vec::Vec<crate::model::AwsCertificateManagerCertificateDomainValidationOption>,
    >,
    /// <p>The status of the Certificate Manager managed renewal of the certificate.</p>
    /// <p>Valid values: <code>PENDING_AUTO_RENEWAL</code> | <code>PENDING_VALIDATION</code> | <code>SUCCESS</code> | <code>FAILED</code> </p>
    pub renewal_status: std::option::Option<std::string::String>,
    /// <p>The reason that a renewal request was unsuccessful.</p>
    /// <p>Valid values: <code>NO_AVAILABLE_CONTACTS</code> | <code>ADDITIONAL_VERIFICATION_REQUIRED</code> | <code>DOMAIN_NOT_ALLOWED</code> | <code>INVALID_PUBLIC_DOMAIN</code> | <code>DOMAIN_VALIDATION_DENIED</code> | <code>CAA_ERROR</code> | <code>PCA_LIMIT_EXCEEDED</code> | <code>PCA_INVALID_ARN</code> | <code>PCA_INVALID_STATE</code> | <code>PCA_REQUEST_FAILED</code> | <code>PCA_NAME_CONSTRAINTS_VALIDATION</code> | <code>PCA_RESOURCE_NOT_FOUND</code> | <code>PCA_INVALID_ARGS</code> | <code>PCA_INVALID_DURATION</code> | <code>PCA_ACCESS_DENIED</code> | <code>SLR_NOT_FOUND</code> | <code>OTHER</code> </p>
    pub renewal_status_reason: std::option::Option<std::string::String>,
    /// <p>Indicates when the renewal summary was last updated.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub updated_at: std::option::Option<std::string::String>,
}
impl AwsCertificateManagerCertificateRenewalSummary {
    /// <p>Information about the validation of each domain name in the certificate, as it pertains to Certificate Manager managed renewal. Provided only when the certificate type is <code>AMAZON_ISSUED</code>.</p>
    pub fn domain_validation_options(
        &self,
    ) -> std::option::Option<&[crate::model::AwsCertificateManagerCertificateDomainValidationOption]>
    {
        self.domain_validation_options.as_deref()
    }
    /// <p>The status of the Certificate Manager managed renewal of the certificate.</p>
    /// <p>Valid values: <code>PENDING_AUTO_RENEWAL</code> | <code>PENDING_VALIDATION</code> | <code>SUCCESS</code> | <code>FAILED</code> </p>
    pub fn renewal_status(&self) -> std::option::Option<&str> {
        self.renewal_status.as_deref()
    }
    /// <p>The reason that a renewal request was unsuccessful.</p>
    /// <p>Valid values: <code>NO_AVAILABLE_CONTACTS</code> | <code>ADDITIONAL_VERIFICATION_REQUIRED</code> | <code>DOMAIN_NOT_ALLOWED</code> | <code>INVALID_PUBLIC_DOMAIN</code> | <code>DOMAIN_VALIDATION_DENIED</code> | <code>CAA_ERROR</code> | <code>PCA_LIMIT_EXCEEDED</code> | <code>PCA_INVALID_ARN</code> | <code>PCA_INVALID_STATE</code> | <code>PCA_REQUEST_FAILED</code> | <code>PCA_NAME_CONSTRAINTS_VALIDATION</code> | <code>PCA_RESOURCE_NOT_FOUND</code> | <code>PCA_INVALID_ARGS</code> | <code>PCA_INVALID_DURATION</code> | <code>PCA_ACCESS_DENIED</code> | <code>SLR_NOT_FOUND</code> | <code>OTHER</code> </p>
    pub fn renewal_status_reason(&self) -> std::option::Option<&str> {
        self.renewal_status_reason.as_deref()
    }
    /// <p>Indicates when the renewal summary was last updated.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn updated_at(&self) -> std::option::Option<&str> {
        self.updated_at.as_deref()
    }
}
impl std::fmt::Debug for AwsCertificateManagerCertificateRenewalSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCertificateManagerCertificateRenewalSummary");
        formatter.field("domain_validation_options", &self.domain_validation_options);
        formatter.field("renewal_status", &self.renewal_status);
        formatter.field("renewal_status_reason", &self.renewal_status_reason);
        formatter.field("updated_at", &self.updated_at);
        formatter.finish()
    }
}
/// See [`AwsCertificateManagerCertificateRenewalSummary`](crate::model::AwsCertificateManagerCertificateRenewalSummary)
pub mod aws_certificate_manager_certificate_renewal_summary {

    /// A builder for [`AwsCertificateManagerCertificateRenewalSummary`](crate::model::AwsCertificateManagerCertificateRenewalSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_validation_options: std::option::Option<
            std::vec::Vec<crate::model::AwsCertificateManagerCertificateDomainValidationOption>,
        >,
        pub(crate) renewal_status: std::option::Option<std::string::String>,
        pub(crate) renewal_status_reason: std::option::Option<std::string::String>,
        pub(crate) updated_at: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `domain_validation_options`.
        ///
        /// To override the contents of this collection use [`set_domain_validation_options`](Self::set_domain_validation_options).
        ///
        /// <p>Information about the validation of each domain name in the certificate, as it pertains to Certificate Manager managed renewal. Provided only when the certificate type is <code>AMAZON_ISSUED</code>.</p>
        pub fn domain_validation_options(
            mut self,
            input: crate::model::AwsCertificateManagerCertificateDomainValidationOption,
        ) -> Self {
            let mut v = self.domain_validation_options.unwrap_or_default();
            v.push(input);
            self.domain_validation_options = Some(v);
            self
        }
        /// <p>Information about the validation of each domain name in the certificate, as it pertains to Certificate Manager managed renewal. Provided only when the certificate type is <code>AMAZON_ISSUED</code>.</p>
        pub fn set_domain_validation_options(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsCertificateManagerCertificateDomainValidationOption>,
            >,
        ) -> Self {
            self.domain_validation_options = input;
            self
        }
        /// <p>The status of the Certificate Manager managed renewal of the certificate.</p>
        /// <p>Valid values: <code>PENDING_AUTO_RENEWAL</code> | <code>PENDING_VALIDATION</code> | <code>SUCCESS</code> | <code>FAILED</code> </p>
        pub fn renewal_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.renewal_status = Some(input.into());
            self
        }
        /// <p>The status of the Certificate Manager managed renewal of the certificate.</p>
        /// <p>Valid values: <code>PENDING_AUTO_RENEWAL</code> | <code>PENDING_VALIDATION</code> | <code>SUCCESS</code> | <code>FAILED</code> </p>
        pub fn set_renewal_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.renewal_status = input;
            self
        }
        /// <p>The reason that a renewal request was unsuccessful.</p>
        /// <p>Valid values: <code>NO_AVAILABLE_CONTACTS</code> | <code>ADDITIONAL_VERIFICATION_REQUIRED</code> | <code>DOMAIN_NOT_ALLOWED</code> | <code>INVALID_PUBLIC_DOMAIN</code> | <code>DOMAIN_VALIDATION_DENIED</code> | <code>CAA_ERROR</code> | <code>PCA_LIMIT_EXCEEDED</code> | <code>PCA_INVALID_ARN</code> | <code>PCA_INVALID_STATE</code> | <code>PCA_REQUEST_FAILED</code> | <code>PCA_NAME_CONSTRAINTS_VALIDATION</code> | <code>PCA_RESOURCE_NOT_FOUND</code> | <code>PCA_INVALID_ARGS</code> | <code>PCA_INVALID_DURATION</code> | <code>PCA_ACCESS_DENIED</code> | <code>SLR_NOT_FOUND</code> | <code>OTHER</code> </p>
        pub fn renewal_status_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.renewal_status_reason = Some(input.into());
            self
        }
        /// <p>The reason that a renewal request was unsuccessful.</p>
        /// <p>Valid values: <code>NO_AVAILABLE_CONTACTS</code> | <code>ADDITIONAL_VERIFICATION_REQUIRED</code> | <code>DOMAIN_NOT_ALLOWED</code> | <code>INVALID_PUBLIC_DOMAIN</code> | <code>DOMAIN_VALIDATION_DENIED</code> | <code>CAA_ERROR</code> | <code>PCA_LIMIT_EXCEEDED</code> | <code>PCA_INVALID_ARN</code> | <code>PCA_INVALID_STATE</code> | <code>PCA_REQUEST_FAILED</code> | <code>PCA_NAME_CONSTRAINTS_VALIDATION</code> | <code>PCA_RESOURCE_NOT_FOUND</code> | <code>PCA_INVALID_ARGS</code> | <code>PCA_INVALID_DURATION</code> | <code>PCA_ACCESS_DENIED</code> | <code>SLR_NOT_FOUND</code> | <code>OTHER</code> </p>
        pub fn set_renewal_status_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.renewal_status_reason = input;
            self
        }
        /// <p>Indicates when the renewal summary was last updated.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn updated_at(mut self, input: impl Into<std::string::String>) -> Self {
            self.updated_at = Some(input.into());
            self
        }
        /// <p>Indicates when the renewal summary was last updated.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_updated_at(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.updated_at = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCertificateManagerCertificateRenewalSummary`](crate::model::AwsCertificateManagerCertificateRenewalSummary)
        pub fn build(self) -> crate::model::AwsCertificateManagerCertificateRenewalSummary {
            crate::model::AwsCertificateManagerCertificateRenewalSummary {
                domain_validation_options: self.domain_validation_options,
                renewal_status: self.renewal_status,
                renewal_status_reason: self.renewal_status_reason,
                updated_at: self.updated_at,
            }
        }
    }
}
impl AwsCertificateManagerCertificateRenewalSummary {
    /// Creates a new builder-style object to manufacture [`AwsCertificateManagerCertificateRenewalSummary`](crate::model::AwsCertificateManagerCertificateRenewalSummary)
    pub fn builder() -> crate::model::aws_certificate_manager_certificate_renewal_summary::Builder {
        crate::model::aws_certificate_manager_certificate_renewal_summary::Builder::default()
    }
}

/// <p>Contains information about one of the following:</p>
/// <ul>
/// <li> <p>The initial validation of each domain name that occurs as a result of the <code>RequestCertificate</code> request</p> </li>
/// <li> <p>The validation of each domain name in the certificate, as it pertains to Certificate Manager managed renewal</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCertificateManagerCertificateDomainValidationOption {
    /// <p>A fully qualified domain name (FQDN) in the certificate.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The CNAME record that is added to the DNS database for domain validation.</p>
    pub resource_record:
        std::option::Option<crate::model::AwsCertificateManagerCertificateResourceRecord>,
    /// <p>The domain name that Certificate Manager uses to send domain validation emails.</p>
    pub validation_domain: std::option::Option<std::string::String>,
    /// <p>A list of email addresses that Certificate Manager uses to send domain validation emails.</p>
    pub validation_emails: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The method used to validate the domain name.</p>
    pub validation_method: std::option::Option<std::string::String>,
    /// <p>The validation status of the domain name.</p>
    pub validation_status: std::option::Option<std::string::String>,
}
impl AwsCertificateManagerCertificateDomainValidationOption {
    /// <p>A fully qualified domain name (FQDN) in the certificate.</p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p>The CNAME record that is added to the DNS database for domain validation.</p>
    pub fn resource_record(
        &self,
    ) -> std::option::Option<&crate::model::AwsCertificateManagerCertificateResourceRecord> {
        self.resource_record.as_ref()
    }
    /// <p>The domain name that Certificate Manager uses to send domain validation emails.</p>
    pub fn validation_domain(&self) -> std::option::Option<&str> {
        self.validation_domain.as_deref()
    }
    /// <p>A list of email addresses that Certificate Manager uses to send domain validation emails.</p>
    pub fn validation_emails(&self) -> std::option::Option<&[std::string::String]> {
        self.validation_emails.as_deref()
    }
    /// <p>The method used to validate the domain name.</p>
    pub fn validation_method(&self) -> std::option::Option<&str> {
        self.validation_method.as_deref()
    }
    /// <p>The validation status of the domain name.</p>
    pub fn validation_status(&self) -> std::option::Option<&str> {
        self.validation_status.as_deref()
    }
}
impl std::fmt::Debug for AwsCertificateManagerCertificateDomainValidationOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsCertificateManagerCertificateDomainValidationOption");
        formatter.field("domain_name", &self.domain_name);
        formatter.field("resource_record", &self.resource_record);
        formatter.field("validation_domain", &self.validation_domain);
        formatter.field("validation_emails", &self.validation_emails);
        formatter.field("validation_method", &self.validation_method);
        formatter.field("validation_status", &self.validation_status);
        formatter.finish()
    }
}
/// See [`AwsCertificateManagerCertificateDomainValidationOption`](crate::model::AwsCertificateManagerCertificateDomainValidationOption)
pub mod aws_certificate_manager_certificate_domain_validation_option {

    /// A builder for [`AwsCertificateManagerCertificateDomainValidationOption`](crate::model::AwsCertificateManagerCertificateDomainValidationOption)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) resource_record:
            std::option::Option<crate::model::AwsCertificateManagerCertificateResourceRecord>,
        pub(crate) validation_domain: std::option::Option<std::string::String>,
        pub(crate) validation_emails: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) validation_method: std::option::Option<std::string::String>,
        pub(crate) validation_status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A fully qualified domain name (FQDN) in the certificate.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>A fully qualified domain name (FQDN) in the certificate.</p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>The CNAME record that is added to the DNS database for domain validation.</p>
        pub fn resource_record(
            mut self,
            input: crate::model::AwsCertificateManagerCertificateResourceRecord,
        ) -> Self {
            self.resource_record = Some(input);
            self
        }
        /// <p>The CNAME record that is added to the DNS database for domain validation.</p>
        pub fn set_resource_record(
            mut self,
            input: std::option::Option<
                crate::model::AwsCertificateManagerCertificateResourceRecord,
            >,
        ) -> Self {
            self.resource_record = input;
            self
        }
        /// <p>The domain name that Certificate Manager uses to send domain validation emails.</p>
        pub fn validation_domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.validation_domain = Some(input.into());
            self
        }
        /// <p>The domain name that Certificate Manager uses to send domain validation emails.</p>
        pub fn set_validation_domain(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.validation_domain = input;
            self
        }
        /// Appends an item to `validation_emails`.
        ///
        /// To override the contents of this collection use [`set_validation_emails`](Self::set_validation_emails).
        ///
        /// <p>A list of email addresses that Certificate Manager uses to send domain validation emails.</p>
        pub fn validation_emails(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.validation_emails.unwrap_or_default();
            v.push(input.into());
            self.validation_emails = Some(v);
            self
        }
        /// <p>A list of email addresses that Certificate Manager uses to send domain validation emails.</p>
        pub fn set_validation_emails(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.validation_emails = input;
            self
        }
        /// <p>The method used to validate the domain name.</p>
        pub fn validation_method(mut self, input: impl Into<std::string::String>) -> Self {
            self.validation_method = Some(input.into());
            self
        }
        /// <p>The method used to validate the domain name.</p>
        pub fn set_validation_method(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.validation_method = input;
            self
        }
        /// <p>The validation status of the domain name.</p>
        pub fn validation_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.validation_status = Some(input.into());
            self
        }
        /// <p>The validation status of the domain name.</p>
        pub fn set_validation_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.validation_status = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCertificateManagerCertificateDomainValidationOption`](crate::model::AwsCertificateManagerCertificateDomainValidationOption)
        pub fn build(self) -> crate::model::AwsCertificateManagerCertificateDomainValidationOption {
            crate::model::AwsCertificateManagerCertificateDomainValidationOption {
                domain_name: self.domain_name,
                resource_record: self.resource_record,
                validation_domain: self.validation_domain,
                validation_emails: self.validation_emails,
                validation_method: self.validation_method,
                validation_status: self.validation_status,
            }
        }
    }
}
impl AwsCertificateManagerCertificateDomainValidationOption {
    /// Creates a new builder-style object to manufacture [`AwsCertificateManagerCertificateDomainValidationOption`](crate::model::AwsCertificateManagerCertificateDomainValidationOption)
    pub fn builder(
    ) -> crate::model::aws_certificate_manager_certificate_domain_validation_option::Builder {
        crate::model::aws_certificate_manager_certificate_domain_validation_option::Builder::default(
        )
    }
}

/// <p>Provides details about the CNAME record that is added to the DNS database for domain validation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCertificateManagerCertificateResourceRecord {
    /// <p>The name of the resource.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of resource.</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The value of the resource.</p>
    pub value: std::option::Option<std::string::String>,
}
impl AwsCertificateManagerCertificateResourceRecord {
    /// <p>The name of the resource.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of resource.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The value of the resource.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for AwsCertificateManagerCertificateResourceRecord {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCertificateManagerCertificateResourceRecord");
        formatter.field("name", &self.name);
        formatter.field("r#type", &self.r#type);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`AwsCertificateManagerCertificateResourceRecord`](crate::model::AwsCertificateManagerCertificateResourceRecord)
pub mod aws_certificate_manager_certificate_resource_record {

    /// A builder for [`AwsCertificateManagerCertificateResourceRecord`](crate::model::AwsCertificateManagerCertificateResourceRecord)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the resource.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the resource.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of resource.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of resource.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The value of the resource.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the resource.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCertificateManagerCertificateResourceRecord`](crate::model::AwsCertificateManagerCertificateResourceRecord)
        pub fn build(self) -> crate::model::AwsCertificateManagerCertificateResourceRecord {
            crate::model::AwsCertificateManagerCertificateResourceRecord {
                name: self.name,
                r#type: self.r#type,
                value: self.value,
            }
        }
    }
}
impl AwsCertificateManagerCertificateResourceRecord {
    /// Creates a new builder-style object to manufacture [`AwsCertificateManagerCertificateResourceRecord`](crate::model::AwsCertificateManagerCertificateResourceRecord)
    pub fn builder() -> crate::model::aws_certificate_manager_certificate_resource_record::Builder {
        crate::model::aws_certificate_manager_certificate_resource_record::Builder::default()
    }
}

/// <p>Contains other options for the certificate.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCertificateManagerCertificateOptions {
    /// <p>Whether to add the certificate to a transparency log.</p>
    /// <p>Valid values: <code>DISABLED</code> | <code>ENABLED</code> </p>
    pub certificate_transparency_logging_preference: std::option::Option<std::string::String>,
}
impl AwsCertificateManagerCertificateOptions {
    /// <p>Whether to add the certificate to a transparency log.</p>
    /// <p>Valid values: <code>DISABLED</code> | <code>ENABLED</code> </p>
    pub fn certificate_transparency_logging_preference(&self) -> std::option::Option<&str> {
        self.certificate_transparency_logging_preference.as_deref()
    }
}
impl std::fmt::Debug for AwsCertificateManagerCertificateOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCertificateManagerCertificateOptions");
        formatter.field(
            "certificate_transparency_logging_preference",
            &self.certificate_transparency_logging_preference,
        );
        formatter.finish()
    }
}
/// See [`AwsCertificateManagerCertificateOptions`](crate::model::AwsCertificateManagerCertificateOptions)
pub mod aws_certificate_manager_certificate_options {

    /// A builder for [`AwsCertificateManagerCertificateOptions`](crate::model::AwsCertificateManagerCertificateOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) certificate_transparency_logging_preference:
            std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Whether to add the certificate to a transparency log.</p>
        /// <p>Valid values: <code>DISABLED</code> | <code>ENABLED</code> </p>
        pub fn certificate_transparency_logging_preference(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.certificate_transparency_logging_preference = Some(input.into());
            self
        }
        /// <p>Whether to add the certificate to a transparency log.</p>
        /// <p>Valid values: <code>DISABLED</code> | <code>ENABLED</code> </p>
        pub fn set_certificate_transparency_logging_preference(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_transparency_logging_preference = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCertificateManagerCertificateOptions`](crate::model::AwsCertificateManagerCertificateOptions)
        pub fn build(self) -> crate::model::AwsCertificateManagerCertificateOptions {
            crate::model::AwsCertificateManagerCertificateOptions {
                certificate_transparency_logging_preference: self
                    .certificate_transparency_logging_preference,
            }
        }
    }
}
impl AwsCertificateManagerCertificateOptions {
    /// Creates a new builder-style object to manufacture [`AwsCertificateManagerCertificateOptions`](crate::model::AwsCertificateManagerCertificateOptions)
    pub fn builder() -> crate::model::aws_certificate_manager_certificate_options::Builder {
        crate::model::aws_certificate_manager_certificate_options::Builder::default()
    }
}

/// <p>Contains information about a key usage X.509 v3 extension object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCertificateManagerCertificateKeyUsage {
    /// <p>The key usage extension name.</p>
    pub name: std::option::Option<std::string::String>,
}
impl AwsCertificateManagerCertificateKeyUsage {
    /// <p>The key usage extension name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl std::fmt::Debug for AwsCertificateManagerCertificateKeyUsage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCertificateManagerCertificateKeyUsage");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`AwsCertificateManagerCertificateKeyUsage`](crate::model::AwsCertificateManagerCertificateKeyUsage)
pub mod aws_certificate_manager_certificate_key_usage {

    /// A builder for [`AwsCertificateManagerCertificateKeyUsage`](crate::model::AwsCertificateManagerCertificateKeyUsage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The key usage extension name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The key usage extension name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCertificateManagerCertificateKeyUsage`](crate::model::AwsCertificateManagerCertificateKeyUsage)
        pub fn build(self) -> crate::model::AwsCertificateManagerCertificateKeyUsage {
            crate::model::AwsCertificateManagerCertificateKeyUsage { name: self.name }
        }
    }
}
impl AwsCertificateManagerCertificateKeyUsage {
    /// Creates a new builder-style object to manufacture [`AwsCertificateManagerCertificateKeyUsage`](crate::model::AwsCertificateManagerCertificateKeyUsage)
    pub fn builder() -> crate::model::aws_certificate_manager_certificate_key_usage::Builder {
        crate::model::aws_certificate_manager_certificate_key_usage::Builder::default()
    }
}

/// <p>Contains information about an extended key usage X.509 v3 extension object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCertificateManagerCertificateExtendedKeyUsage {
    /// <p>The name of an extension value. Indicates the purpose for which the certificate public key can be used.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>An object identifier (OID) for the extension value.</p>
    /// <p>The format is numbers separated by periods.</p>
    pub o_id: std::option::Option<std::string::String>,
}
impl AwsCertificateManagerCertificateExtendedKeyUsage {
    /// <p>The name of an extension value. Indicates the purpose for which the certificate public key can be used.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>An object identifier (OID) for the extension value.</p>
    /// <p>The format is numbers separated by periods.</p>
    pub fn o_id(&self) -> std::option::Option<&str> {
        self.o_id.as_deref()
    }
}
impl std::fmt::Debug for AwsCertificateManagerCertificateExtendedKeyUsage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCertificateManagerCertificateExtendedKeyUsage");
        formatter.field("name", &self.name);
        formatter.field("o_id", &self.o_id);
        formatter.finish()
    }
}
/// See [`AwsCertificateManagerCertificateExtendedKeyUsage`](crate::model::AwsCertificateManagerCertificateExtendedKeyUsage)
pub mod aws_certificate_manager_certificate_extended_key_usage {

    /// A builder for [`AwsCertificateManagerCertificateExtendedKeyUsage`](crate::model::AwsCertificateManagerCertificateExtendedKeyUsage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) o_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of an extension value. Indicates the purpose for which the certificate public key can be used.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of an extension value. Indicates the purpose for which the certificate public key can be used.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>An object identifier (OID) for the extension value.</p>
        /// <p>The format is numbers separated by periods.</p>
        pub fn o_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.o_id = Some(input.into());
            self
        }
        /// <p>An object identifier (OID) for the extension value.</p>
        /// <p>The format is numbers separated by periods.</p>
        pub fn set_o_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.o_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCertificateManagerCertificateExtendedKeyUsage`](crate::model::AwsCertificateManagerCertificateExtendedKeyUsage)
        pub fn build(self) -> crate::model::AwsCertificateManagerCertificateExtendedKeyUsage {
            crate::model::AwsCertificateManagerCertificateExtendedKeyUsage {
                name: self.name,
                o_id: self.o_id,
            }
        }
    }
}
impl AwsCertificateManagerCertificateExtendedKeyUsage {
    /// Creates a new builder-style object to manufacture [`AwsCertificateManagerCertificateExtendedKeyUsage`](crate::model::AwsCertificateManagerCertificateExtendedKeyUsage)
    pub fn builder() -> crate::model::aws_certificate_manager_certificate_extended_key_usage::Builder
    {
        crate::model::aws_certificate_manager_certificate_extended_key_usage::Builder::default()
    }
}

/// <p>Provides information about the state of a patch on an instance based on the patch baseline that was used to patch the instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsSsmPatchComplianceDetails {
    /// <p>Information about the status of a patch.</p>
    pub patch: std::option::Option<crate::model::AwsSsmPatch>,
}
impl AwsSsmPatchComplianceDetails {
    /// <p>Information about the status of a patch.</p>
    pub fn patch(&self) -> std::option::Option<&crate::model::AwsSsmPatch> {
        self.patch.as_ref()
    }
}
impl std::fmt::Debug for AwsSsmPatchComplianceDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsSsmPatchComplianceDetails");
        formatter.field("patch", &self.patch);
        formatter.finish()
    }
}
/// See [`AwsSsmPatchComplianceDetails`](crate::model::AwsSsmPatchComplianceDetails)
pub mod aws_ssm_patch_compliance_details {

    /// A builder for [`AwsSsmPatchComplianceDetails`](crate::model::AwsSsmPatchComplianceDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) patch: std::option::Option<crate::model::AwsSsmPatch>,
    }
    impl Builder {
        /// <p>Information about the status of a patch.</p>
        pub fn patch(mut self, input: crate::model::AwsSsmPatch) -> Self {
            self.patch = Some(input);
            self
        }
        /// <p>Information about the status of a patch.</p>
        pub fn set_patch(mut self, input: std::option::Option<crate::model::AwsSsmPatch>) -> Self {
            self.patch = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsSsmPatchComplianceDetails`](crate::model::AwsSsmPatchComplianceDetails)
        pub fn build(self) -> crate::model::AwsSsmPatchComplianceDetails {
            crate::model::AwsSsmPatchComplianceDetails { patch: self.patch }
        }
    }
}
impl AwsSsmPatchComplianceDetails {
    /// Creates a new builder-style object to manufacture [`AwsSsmPatchComplianceDetails`](crate::model::AwsSsmPatchComplianceDetails)
    pub fn builder() -> crate::model::aws_ssm_patch_compliance_details::Builder {
        crate::model::aws_ssm_patch_compliance_details::Builder::default()
    }
}

/// <p>Provides details about the compliance for a patch.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsSsmPatch {
    /// <p>The compliance status details for the patch.</p>
    pub compliance_summary: std::option::Option<crate::model::AwsSsmComplianceSummary>,
}
impl AwsSsmPatch {
    /// <p>The compliance status details for the patch.</p>
    pub fn compliance_summary(
        &self,
    ) -> std::option::Option<&crate::model::AwsSsmComplianceSummary> {
        self.compliance_summary.as_ref()
    }
}
impl std::fmt::Debug for AwsSsmPatch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsSsmPatch");
        formatter.field("compliance_summary", &self.compliance_summary);
        formatter.finish()
    }
}
/// See [`AwsSsmPatch`](crate::model::AwsSsmPatch)
pub mod aws_ssm_patch {

    /// A builder for [`AwsSsmPatch`](crate::model::AwsSsmPatch)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) compliance_summary: std::option::Option<crate::model::AwsSsmComplianceSummary>,
    }
    impl Builder {
        /// <p>The compliance status details for the patch.</p>
        pub fn compliance_summary(mut self, input: crate::model::AwsSsmComplianceSummary) -> Self {
            self.compliance_summary = Some(input);
            self
        }
        /// <p>The compliance status details for the patch.</p>
        pub fn set_compliance_summary(
            mut self,
            input: std::option::Option<crate::model::AwsSsmComplianceSummary>,
        ) -> Self {
            self.compliance_summary = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsSsmPatch`](crate::model::AwsSsmPatch)
        pub fn build(self) -> crate::model::AwsSsmPatch {
            crate::model::AwsSsmPatch {
                compliance_summary: self.compliance_summary,
            }
        }
    }
}
impl AwsSsmPatch {
    /// Creates a new builder-style object to manufacture [`AwsSsmPatch`](crate::model::AwsSsmPatch)
    pub fn builder() -> crate::model::aws_ssm_patch::Builder {
        crate::model::aws_ssm_patch::Builder::default()
    }
}

/// <p>Provides the details about the compliance status for a patch.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsSsmComplianceSummary {
    /// <p>The current patch compliance status.</p>
    /// <p>The possible status values are:</p>
    /// <ul>
    /// <li> <p> <code>COMPLIANT</code> </p> </li>
    /// <li> <p> <code>NON_COMPLIANT</code> </p> </li>
    /// <li> <p> <code>UNSPECIFIED_DATA</code> </p> </li>
    /// </ul>
    pub status: std::option::Option<std::string::String>,
    /// <p>For the patches that are compliant, the number that have a severity of <code>CRITICAL</code>.</p>
    pub compliant_critical_count: i32,
    /// <p>For the patches that are compliant, the number that have a severity of <code>HIGH</code>.</p>
    pub compliant_high_count: i32,
    /// <p>For the patches that are compliant, the number that have a severity of <code>MEDIUM</code>.</p>
    pub compliant_medium_count: i32,
    /// <p>The type of execution that was used determine compliance.</p>
    pub execution_type: std::option::Option<std::string::String>,
    /// <p>For the patch items that are noncompliant, the number of items that have a severity of <code>CRITICAL</code>.</p>
    pub non_compliant_critical_count: i32,
    /// <p>For the patches that are compliant, the number that have a severity of <code>INFORMATIONAL</code>.</p>
    pub compliant_informational_count: i32,
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>INFORMATIONAL</code>.</p>
    pub non_compliant_informational_count: i32,
    /// <p>For the patches that are compliant, the number that have a severity of <code>UNSPECIFIED</code>.</p>
    pub compliant_unspecified_count: i32,
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>LOW</code>.</p>
    pub non_compliant_low_count: i32,
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>HIGH</code>.</p>
    pub non_compliant_high_count: i32,
    /// <p>For the patches that are compliant, the number that have a severity of <code>LOW</code>.</p>
    pub compliant_low_count: i32,
    /// <p>The type of resource for which the compliance was determined. For <code>AwsSsmPatchCompliance</code>, <code>ComplianceType</code> is <code>Patch</code>. </p>
    pub compliance_type: std::option::Option<std::string::String>,
    /// <p>The identifier of the patch baseline. The patch baseline lists the patches that are approved for installation.</p>
    pub patch_baseline_id: std::option::Option<std::string::String>,
    /// <p>The highest severity for the patches.</p>
    pub overall_severity: std::option::Option<std::string::String>,
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>MEDIUM</code>.</p>
    pub non_compliant_medium_count: i32,
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>UNSPECIFIED</code>.</p>
    pub non_compliant_unspecified_count: i32,
    /// <p>The identifier of the patch group for which compliance was determined. A patch group uses tags to group EC2 instances that should have the same patch compliance.</p>
    pub patch_group: std::option::Option<std::string::String>,
}
impl AwsSsmComplianceSummary {
    /// <p>The current patch compliance status.</p>
    /// <p>The possible status values are:</p>
    /// <ul>
    /// <li> <p> <code>COMPLIANT</code> </p> </li>
    /// <li> <p> <code>NON_COMPLIANT</code> </p> </li>
    /// <li> <p> <code>UNSPECIFIED_DATA</code> </p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>For the patches that are compliant, the number that have a severity of <code>CRITICAL</code>.</p>
    pub fn compliant_critical_count(&self) -> i32 {
        self.compliant_critical_count
    }
    /// <p>For the patches that are compliant, the number that have a severity of <code>HIGH</code>.</p>
    pub fn compliant_high_count(&self) -> i32 {
        self.compliant_high_count
    }
    /// <p>For the patches that are compliant, the number that have a severity of <code>MEDIUM</code>.</p>
    pub fn compliant_medium_count(&self) -> i32 {
        self.compliant_medium_count
    }
    /// <p>The type of execution that was used determine compliance.</p>
    pub fn execution_type(&self) -> std::option::Option<&str> {
        self.execution_type.as_deref()
    }
    /// <p>For the patch items that are noncompliant, the number of items that have a severity of <code>CRITICAL</code>.</p>
    pub fn non_compliant_critical_count(&self) -> i32 {
        self.non_compliant_critical_count
    }
    /// <p>For the patches that are compliant, the number that have a severity of <code>INFORMATIONAL</code>.</p>
    pub fn compliant_informational_count(&self) -> i32 {
        self.compliant_informational_count
    }
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>INFORMATIONAL</code>.</p>
    pub fn non_compliant_informational_count(&self) -> i32 {
        self.non_compliant_informational_count
    }
    /// <p>For the patches that are compliant, the number that have a severity of <code>UNSPECIFIED</code>.</p>
    pub fn compliant_unspecified_count(&self) -> i32 {
        self.compliant_unspecified_count
    }
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>LOW</code>.</p>
    pub fn non_compliant_low_count(&self) -> i32 {
        self.non_compliant_low_count
    }
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>HIGH</code>.</p>
    pub fn non_compliant_high_count(&self) -> i32 {
        self.non_compliant_high_count
    }
    /// <p>For the patches that are compliant, the number that have a severity of <code>LOW</code>.</p>
    pub fn compliant_low_count(&self) -> i32 {
        self.compliant_low_count
    }
    /// <p>The type of resource for which the compliance was determined. For <code>AwsSsmPatchCompliance</code>, <code>ComplianceType</code> is <code>Patch</code>. </p>
    pub fn compliance_type(&self) -> std::option::Option<&str> {
        self.compliance_type.as_deref()
    }
    /// <p>The identifier of the patch baseline. The patch baseline lists the patches that are approved for installation.</p>
    pub fn patch_baseline_id(&self) -> std::option::Option<&str> {
        self.patch_baseline_id.as_deref()
    }
    /// <p>The highest severity for the patches.</p>
    pub fn overall_severity(&self) -> std::option::Option<&str> {
        self.overall_severity.as_deref()
    }
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>MEDIUM</code>.</p>
    pub fn non_compliant_medium_count(&self) -> i32 {
        self.non_compliant_medium_count
    }
    /// <p>For the patches that are noncompliant, the number that have a severity of <code>UNSPECIFIED</code>.</p>
    pub fn non_compliant_unspecified_count(&self) -> i32 {
        self.non_compliant_unspecified_count
    }
    /// <p>The identifier of the patch group for which compliance was determined. A patch group uses tags to group EC2 instances that should have the same patch compliance.</p>
    pub fn patch_group(&self) -> std::option::Option<&str> {
        self.patch_group.as_deref()
    }
}
impl std::fmt::Debug for AwsSsmComplianceSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsSsmComplianceSummary");
        formatter.field("status", &self.status);
        formatter.field("compliant_critical_count", &self.compliant_critical_count);
        formatter.field("compliant_high_count", &self.compliant_high_count);
        formatter.field("compliant_medium_count", &self.compliant_medium_count);
        formatter.field("execution_type", &self.execution_type);
        formatter.field(
            "non_compliant_critical_count",
            &self.non_compliant_critical_count,
        );
        formatter.field(
            "compliant_informational_count",
            &self.compliant_informational_count,
        );
        formatter.field(
            "non_compliant_informational_count",
            &self.non_compliant_informational_count,
        );
        formatter.field(
            "compliant_unspecified_count",
            &self.compliant_unspecified_count,
        );
        formatter.field("non_compliant_low_count", &self.non_compliant_low_count);
        formatter.field("non_compliant_high_count", &self.non_compliant_high_count);
        formatter.field("compliant_low_count", &self.compliant_low_count);
        formatter.field("compliance_type", &self.compliance_type);
        formatter.field("patch_baseline_id", &self.patch_baseline_id);
        formatter.field("overall_severity", &self.overall_severity);
        formatter.field(
            "non_compliant_medium_count",
            &self.non_compliant_medium_count,
        );
        formatter.field(
            "non_compliant_unspecified_count",
            &self.non_compliant_unspecified_count,
        );
        formatter.field("patch_group", &self.patch_group);
        formatter.finish()
    }
}
/// See [`AwsSsmComplianceSummary`](crate::model::AwsSsmComplianceSummary)
pub mod aws_ssm_compliance_summary {

    /// A builder for [`AwsSsmComplianceSummary`](crate::model::AwsSsmComplianceSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) compliant_critical_count: std::option::Option<i32>,
        pub(crate) compliant_high_count: std::option::Option<i32>,
        pub(crate) compliant_medium_count: std::option::Option<i32>,
        pub(crate) execution_type: std::option::Option<std::string::String>,
        pub(crate) non_compliant_critical_count: std::option::Option<i32>,
        pub(crate) compliant_informational_count: std::option::Option<i32>,
        pub(crate) non_compliant_informational_count: std::option::Option<i32>,
        pub(crate) compliant_unspecified_count: std::option::Option<i32>,
        pub(crate) non_compliant_low_count: std::option::Option<i32>,
        pub(crate) non_compliant_high_count: std::option::Option<i32>,
        pub(crate) compliant_low_count: std::option::Option<i32>,
        pub(crate) compliance_type: std::option::Option<std::string::String>,
        pub(crate) patch_baseline_id: std::option::Option<std::string::String>,
        pub(crate) overall_severity: std::option::Option<std::string::String>,
        pub(crate) non_compliant_medium_count: std::option::Option<i32>,
        pub(crate) non_compliant_unspecified_count: std::option::Option<i32>,
        pub(crate) patch_group: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The current patch compliance status.</p>
        /// <p>The possible status values are:</p>
        /// <ul>
        /// <li> <p> <code>COMPLIANT</code> </p> </li>
        /// <li> <p> <code>NON_COMPLIANT</code> </p> </li>
        /// <li> <p> <code>UNSPECIFIED_DATA</code> </p> </li>
        /// </ul>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The current patch compliance status.</p>
        /// <p>The possible status values are:</p>
        /// <ul>
        /// <li> <p> <code>COMPLIANT</code> </p> </li>
        /// <li> <p> <code>NON_COMPLIANT</code> </p> </li>
        /// <li> <p> <code>UNSPECIFIED_DATA</code> </p> </li>
        /// </ul>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>For the patches that are compliant, the number that have a severity of <code>CRITICAL</code>.</p>
        pub fn compliant_critical_count(mut self, input: i32) -> Self {
            self.compliant_critical_count = Some(input);
            self
        }
        /// <p>For the patches that are compliant, the number that have a severity of <code>CRITICAL</code>.</p>
        pub fn set_compliant_critical_count(mut self, input: std::option::Option<i32>) -> Self {
            self.compliant_critical_count = input;
            self
        }
        /// <p>For the patches that are compliant, the number that have a severity of <code>HIGH</code>.</p>
        pub fn compliant_high_count(mut self, input: i32) -> Self {
            self.compliant_high_count = Some(input);
            self
        }
        /// <p>For the patches that are compliant, the number that have a severity of <code>HIGH</code>.</p>
        pub fn set_compliant_high_count(mut self, input: std::option::Option<i32>) -> Self {
            self.compliant_high_count = input;
            self
        }
        /// <p>For the patches that are compliant, the number that have a severity of <code>MEDIUM</code>.</p>
        pub fn compliant_medium_count(mut self, input: i32) -> Self {
            self.compliant_medium_count = Some(input);
            self
        }
        /// <p>For the patches that are compliant, the number that have a severity of <code>MEDIUM</code>.</p>
        pub fn set_compliant_medium_count(mut self, input: std::option::Option<i32>) -> Self {
            self.compliant_medium_count = input;
            self
        }
        /// <p>The type of execution that was used determine compliance.</p>
        pub fn execution_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.execution_type = Some(input.into());
            self
        }
        /// <p>The type of execution that was used determine compliance.</p>
        pub fn set_execution_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.execution_type = input;
            self
        }
        /// <p>For the patch items that are noncompliant, the number of items that have a severity of <code>CRITICAL</code>.</p>
        pub fn non_compliant_critical_count(mut self, input: i32) -> Self {
            self.non_compliant_critical_count = Some(input);
            self
        }
        /// <p>For the patch items that are noncompliant, the number of items that have a severity of <code>CRITICAL</code>.</p>
        pub fn set_non_compliant_critical_count(mut self, input: std::option::Option<i32>) -> Self {
            self.non_compliant_critical_count = input;
            self
        }
        /// <p>For the patches that are compliant, the number that have a severity of <code>INFORMATIONAL</code>.</p>
        pub fn compliant_informational_count(mut self, input: i32) -> Self {
            self.compliant_informational_count = Some(input);
            self
        }
        /// <p>For the patches that are compliant, the number that have a severity of <code>INFORMATIONAL</code>.</p>
        pub fn set_compliant_informational_count(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.compliant_informational_count = input;
            self
        }
        /// <p>For the patches that are noncompliant, the number that have a severity of <code>INFORMATIONAL</code>.</p>
        pub fn non_compliant_informational_count(mut self, input: i32) -> Self {
            self.non_compliant_informational_count = Some(input);
            self
        }
        /// <p>For the patches that are noncompliant, the number that have a severity of <code>INFORMATIONAL</code>.</p>
        pub fn set_non_compliant_informational_count(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.non_compliant_informational_count = input;
            self
        }
        /// <p>For the patches that are compliant, the number that have a severity of <code>UNSPECIFIED</code>.</p>
        pub fn compliant_unspecified_count(mut self, input: i32) -> Self {
            self.compliant_unspecified_count = Some(input);
            self
        }
        /// <p>For the patches that are compliant, the number that have a severity of <code>UNSPECIFIED</code>.</p>
        pub fn set_compliant_unspecified_count(mut self, input: std::option::Option<i32>) -> Self {
            self.compliant_unspecified_count = input;
            self
        }
        /// <p>For the patches that are noncompliant, the number that have a severity of <code>LOW</code>.</p>
        pub fn non_compliant_low_count(mut self, input: i32) -> Self {
            self.non_compliant_low_count = Some(input);
            self
        }
        /// <p>For the patches that are noncompliant, the number that have a severity of <code>LOW</code>.</p>
        pub fn set_non_compliant_low_count(mut self, input: std::option::Option<i32>) -> Self {
            self.non_compliant_low_count = input;
            self
        }
        /// <p>For the patches that are noncompliant, the number that have a severity of <code>HIGH</code>.</p>
        pub fn non_compliant_high_count(mut self, input: i32) -> Self {
            self.non_compliant_high_count = Some(input);
            self
        }
        /// <p>For the patches that are noncompliant, the number that have a severity of <code>HIGH</code>.</p>
        pub fn set_non_compliant_high_count(mut self, input: std::option::Option<i32>) -> Self {
            self.non_compliant_high_count = input;
            self
        }
        /// <p>For the patches that are compliant, the number that have a severity of <code>LOW</code>.</p>
        pub fn compliant_low_count(mut self, input: i32) -> Self {
            self.compliant_low_count = Some(input);
            self
        }
        /// <p>For the patches that are compliant, the number that have a severity of <code>LOW</code>.</p>
        pub fn set_compliant_low_count(mut self, input: std::option::Option<i32>) -> Self {
            self.compliant_low_count = input;
            self
        }
        /// <p>The type of resource for which the compliance was determined. For <code>AwsSsmPatchCompliance</code>, <code>ComplianceType</code> is <code>Patch</code>. </p>
        pub fn compliance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.compliance_type = Some(input.into());
            self
        }
        /// <p>The type of resource for which the compliance was determined. For <code>AwsSsmPatchCompliance</code>, <code>ComplianceType</code> is <code>Patch</code>. </p>
        pub fn set_compliance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.compliance_type = input;
            self
        }
        /// <p>The identifier of the patch baseline. The patch baseline lists the patches that are approved for installation.</p>
        pub fn patch_baseline_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.patch_baseline_id = Some(input.into());
            self
        }
        /// <p>The identifier of the patch baseline. The patch baseline lists the patches that are approved for installation.</p>
        pub fn set_patch_baseline_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.patch_baseline_id = input;
            self
        }
        /// <p>The highest severity for the patches.</p>
        pub fn overall_severity(mut self, input: impl Into<std::string::String>) -> Self {
            self.overall_severity = Some(input.into());
            self
        }
        /// <p>The highest severity for the patches.</p>
        pub fn set_overall_severity(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.overall_severity = input;
            self
        }
        /// <p>For the patches that are noncompliant, the number that have a severity of <code>MEDIUM</code>.</p>
        pub fn non_compliant_medium_count(mut self, input: i32) -> Self {
            self.non_compliant_medium_count = Some(input);
            self
        }
        /// <p>For the patches that are noncompliant, the number that have a severity of <code>MEDIUM</code>.</p>
        pub fn set_non_compliant_medium_count(mut self, input: std::option::Option<i32>) -> Self {
            self.non_compliant_medium_count = input;
            self
        }
        /// <p>For the patches that are noncompliant, the number that have a severity of <code>UNSPECIFIED</code>.</p>
        pub fn non_compliant_unspecified_count(mut self, input: i32) -> Self {
            self.non_compliant_unspecified_count = Some(input);
            self
        }
        /// <p>For the patches that are noncompliant, the number that have a severity of <code>UNSPECIFIED</code>.</p>
        pub fn set_non_compliant_unspecified_count(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.non_compliant_unspecified_count = input;
            self
        }
        /// <p>The identifier of the patch group for which compliance was determined. A patch group uses tags to group EC2 instances that should have the same patch compliance.</p>
        pub fn patch_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.patch_group = Some(input.into());
            self
        }
        /// <p>The identifier of the patch group for which compliance was determined. A patch group uses tags to group EC2 instances that should have the same patch compliance.</p>
        pub fn set_patch_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.patch_group = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsSsmComplianceSummary`](crate::model::AwsSsmComplianceSummary)
        pub fn build(self) -> crate::model::AwsSsmComplianceSummary {
            crate::model::AwsSsmComplianceSummary {
                status: self.status,
                compliant_critical_count: self.compliant_critical_count.unwrap_or_default(),
                compliant_high_count: self.compliant_high_count.unwrap_or_default(),
                compliant_medium_count: self.compliant_medium_count.unwrap_or_default(),
                execution_type: self.execution_type,
                non_compliant_critical_count: self.non_compliant_critical_count.unwrap_or_default(),
                compliant_informational_count: self
                    .compliant_informational_count
                    .unwrap_or_default(),
                non_compliant_informational_count: self
                    .non_compliant_informational_count
                    .unwrap_or_default(),
                compliant_unspecified_count: self.compliant_unspecified_count.unwrap_or_default(),
                non_compliant_low_count: self.non_compliant_low_count.unwrap_or_default(),
                non_compliant_high_count: self.non_compliant_high_count.unwrap_or_default(),
                compliant_low_count: self.compliant_low_count.unwrap_or_default(),
                compliance_type: self.compliance_type,
                patch_baseline_id: self.patch_baseline_id,
                overall_severity: self.overall_severity,
                non_compliant_medium_count: self.non_compliant_medium_count.unwrap_or_default(),
                non_compliant_unspecified_count: self
                    .non_compliant_unspecified_count
                    .unwrap_or_default(),
                patch_group: self.patch_group,
            }
        }
    }
}
impl AwsSsmComplianceSummary {
    /// Creates a new builder-style object to manufacture [`AwsSsmComplianceSummary`](crate::model::AwsSsmComplianceSummary)
    pub fn builder() -> crate::model::aws_ssm_compliance_summary::Builder {
        crate::model::aws_ssm_compliance_summary::Builder::default()
    }
}

/// <p>Provides details about a CloudTrail trail.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCloudTrailTrailDetails {
    /// <p>The ARN of the log group that CloudTrail logs are delivered to.</p>
    pub cloud_watch_logs_log_group_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the role that the CloudWatch Events endpoint assumes when it writes to the log group.</p>
    pub cloud_watch_logs_role_arn: std::option::Option<std::string::String>,
    /// <p>Indicates whether the trail has custom event selectors.</p>
    pub has_custom_event_selectors: bool,
    /// <p>The Region where the trail was created.</p>
    pub home_region: std::option::Option<std::string::String>,
    /// <p>Indicates whether the trail publishes events from global services such as IAM to the log files.</p>
    pub include_global_service_events: bool,
    /// <p>Indicates whether the trail applies only to the current Region or to all Regions.</p>
    pub is_multi_region_trail: bool,
    /// <p>Whether the trail is created for all accounts in an organization in Organizations, or only for the current Amazon Web Services account.</p>
    pub is_organization_trail: bool,
    /// <p>The KMS key ID to use to encrypt the logs.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>Indicates whether CloudTrail log file validation is enabled.</p>
    pub log_file_validation_enabled: bool,
    /// <p>The name of the trail.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the S3 bucket where the log files are published.</p>
    pub s3_bucket_name: std::option::Option<std::string::String>,
    /// <p>The S3 key prefix. The key prefix is added after the name of the S3 bucket where the log files are published.</p>
    pub s3_key_prefix: std::option::Option<std::string::String>,
    /// <p>The ARN of the SNS topic that is used for notifications of log file delivery.</p>
    pub sns_topic_arn: std::option::Option<std::string::String>,
    /// <p>The name of the SNS topic that is used for notifications of log file delivery.</p>
    pub sns_topic_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the trail.</p>
    pub trail_arn: std::option::Option<std::string::String>,
}
impl AwsCloudTrailTrailDetails {
    /// <p>The ARN of the log group that CloudTrail logs are delivered to.</p>
    pub fn cloud_watch_logs_log_group_arn(&self) -> std::option::Option<&str> {
        self.cloud_watch_logs_log_group_arn.as_deref()
    }
    /// <p>The ARN of the role that the CloudWatch Events endpoint assumes when it writes to the log group.</p>
    pub fn cloud_watch_logs_role_arn(&self) -> std::option::Option<&str> {
        self.cloud_watch_logs_role_arn.as_deref()
    }
    /// <p>Indicates whether the trail has custom event selectors.</p>
    pub fn has_custom_event_selectors(&self) -> bool {
        self.has_custom_event_selectors
    }
    /// <p>The Region where the trail was created.</p>
    pub fn home_region(&self) -> std::option::Option<&str> {
        self.home_region.as_deref()
    }
    /// <p>Indicates whether the trail publishes events from global services such as IAM to the log files.</p>
    pub fn include_global_service_events(&self) -> bool {
        self.include_global_service_events
    }
    /// <p>Indicates whether the trail applies only to the current Region or to all Regions.</p>
    pub fn is_multi_region_trail(&self) -> bool {
        self.is_multi_region_trail
    }
    /// <p>Whether the trail is created for all accounts in an organization in Organizations, or only for the current Amazon Web Services account.</p>
    pub fn is_organization_trail(&self) -> bool {
        self.is_organization_trail
    }
    /// <p>The KMS key ID to use to encrypt the logs.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>Indicates whether CloudTrail log file validation is enabled.</p>
    pub fn log_file_validation_enabled(&self) -> bool {
        self.log_file_validation_enabled
    }
    /// <p>The name of the trail.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the S3 bucket where the log files are published.</p>
    pub fn s3_bucket_name(&self) -> std::option::Option<&str> {
        self.s3_bucket_name.as_deref()
    }
    /// <p>The S3 key prefix. The key prefix is added after the name of the S3 bucket where the log files are published.</p>
    pub fn s3_key_prefix(&self) -> std::option::Option<&str> {
        self.s3_key_prefix.as_deref()
    }
    /// <p>The ARN of the SNS topic that is used for notifications of log file delivery.</p>
    pub fn sns_topic_arn(&self) -> std::option::Option<&str> {
        self.sns_topic_arn.as_deref()
    }
    /// <p>The name of the SNS topic that is used for notifications of log file delivery.</p>
    pub fn sns_topic_name(&self) -> std::option::Option<&str> {
        self.sns_topic_name.as_deref()
    }
    /// <p>The ARN of the trail.</p>
    pub fn trail_arn(&self) -> std::option::Option<&str> {
        self.trail_arn.as_deref()
    }
}
impl std::fmt::Debug for AwsCloudTrailTrailDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCloudTrailTrailDetails");
        formatter.field(
            "cloud_watch_logs_log_group_arn",
            &self.cloud_watch_logs_log_group_arn,
        );
        formatter.field("cloud_watch_logs_role_arn", &self.cloud_watch_logs_role_arn);
        formatter.field(
            "has_custom_event_selectors",
            &self.has_custom_event_selectors,
        );
        formatter.field("home_region", &self.home_region);
        formatter.field(
            "include_global_service_events",
            &self.include_global_service_events,
        );
        formatter.field("is_multi_region_trail", &self.is_multi_region_trail);
        formatter.field("is_organization_trail", &self.is_organization_trail);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field(
            "log_file_validation_enabled",
            &self.log_file_validation_enabled,
        );
        formatter.field("name", &self.name);
        formatter.field("s3_bucket_name", &self.s3_bucket_name);
        formatter.field("s3_key_prefix", &self.s3_key_prefix);
        formatter.field("sns_topic_arn", &self.sns_topic_arn);
        formatter.field("sns_topic_name", &self.sns_topic_name);
        formatter.field("trail_arn", &self.trail_arn);
        formatter.finish()
    }
}
/// See [`AwsCloudTrailTrailDetails`](crate::model::AwsCloudTrailTrailDetails)
pub mod aws_cloud_trail_trail_details {

    /// A builder for [`AwsCloudTrailTrailDetails`](crate::model::AwsCloudTrailTrailDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cloud_watch_logs_log_group_arn: std::option::Option<std::string::String>,
        pub(crate) cloud_watch_logs_role_arn: std::option::Option<std::string::String>,
        pub(crate) has_custom_event_selectors: std::option::Option<bool>,
        pub(crate) home_region: std::option::Option<std::string::String>,
        pub(crate) include_global_service_events: std::option::Option<bool>,
        pub(crate) is_multi_region_trail: std::option::Option<bool>,
        pub(crate) is_organization_trail: std::option::Option<bool>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) log_file_validation_enabled: std::option::Option<bool>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) s3_bucket_name: std::option::Option<std::string::String>,
        pub(crate) s3_key_prefix: std::option::Option<std::string::String>,
        pub(crate) sns_topic_arn: std::option::Option<std::string::String>,
        pub(crate) sns_topic_name: std::option::Option<std::string::String>,
        pub(crate) trail_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the log group that CloudTrail logs are delivered to.</p>
        pub fn cloud_watch_logs_log_group_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.cloud_watch_logs_log_group_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the log group that CloudTrail logs are delivered to.</p>
        pub fn set_cloud_watch_logs_log_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cloud_watch_logs_log_group_arn = input;
            self
        }
        /// <p>The ARN of the role that the CloudWatch Events endpoint assumes when it writes to the log group.</p>
        pub fn cloud_watch_logs_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.cloud_watch_logs_role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the role that the CloudWatch Events endpoint assumes when it writes to the log group.</p>
        pub fn set_cloud_watch_logs_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cloud_watch_logs_role_arn = input;
            self
        }
        /// <p>Indicates whether the trail has custom event selectors.</p>
        pub fn has_custom_event_selectors(mut self, input: bool) -> Self {
            self.has_custom_event_selectors = Some(input);
            self
        }
        /// <p>Indicates whether the trail has custom event selectors.</p>
        pub fn set_has_custom_event_selectors(mut self, input: std::option::Option<bool>) -> Self {
            self.has_custom_event_selectors = input;
            self
        }
        /// <p>The Region where the trail was created.</p>
        pub fn home_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.home_region = Some(input.into());
            self
        }
        /// <p>The Region where the trail was created.</p>
        pub fn set_home_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.home_region = input;
            self
        }
        /// <p>Indicates whether the trail publishes events from global services such as IAM to the log files.</p>
        pub fn include_global_service_events(mut self, input: bool) -> Self {
            self.include_global_service_events = Some(input);
            self
        }
        /// <p>Indicates whether the trail publishes events from global services such as IAM to the log files.</p>
        pub fn set_include_global_service_events(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.include_global_service_events = input;
            self
        }
        /// <p>Indicates whether the trail applies only to the current Region or to all Regions.</p>
        pub fn is_multi_region_trail(mut self, input: bool) -> Self {
            self.is_multi_region_trail = Some(input);
            self
        }
        /// <p>Indicates whether the trail applies only to the current Region or to all Regions.</p>
        pub fn set_is_multi_region_trail(mut self, input: std::option::Option<bool>) -> Self {
            self.is_multi_region_trail = input;
            self
        }
        /// <p>Whether the trail is created for all accounts in an organization in Organizations, or only for the current Amazon Web Services account.</p>
        pub fn is_organization_trail(mut self, input: bool) -> Self {
            self.is_organization_trail = Some(input);
            self
        }
        /// <p>Whether the trail is created for all accounts in an organization in Organizations, or only for the current Amazon Web Services account.</p>
        pub fn set_is_organization_trail(mut self, input: std::option::Option<bool>) -> Self {
            self.is_organization_trail = input;
            self
        }
        /// <p>The KMS key ID to use to encrypt the logs.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The KMS key ID to use to encrypt the logs.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>Indicates whether CloudTrail log file validation is enabled.</p>
        pub fn log_file_validation_enabled(mut self, input: bool) -> Self {
            self.log_file_validation_enabled = Some(input);
            self
        }
        /// <p>Indicates whether CloudTrail log file validation is enabled.</p>
        pub fn set_log_file_validation_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.log_file_validation_enabled = input;
            self
        }
        /// <p>The name of the trail.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the trail.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the S3 bucket where the log files are published.</p>
        pub fn s3_bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket_name = Some(input.into());
            self
        }
        /// <p>The name of the S3 bucket where the log files are published.</p>
        pub fn set_s3_bucket_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_bucket_name = input;
            self
        }
        /// <p>The S3 key prefix. The key prefix is added after the name of the S3 bucket where the log files are published.</p>
        pub fn s3_key_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_key_prefix = Some(input.into());
            self
        }
        /// <p>The S3 key prefix. The key prefix is added after the name of the S3 bucket where the log files are published.</p>
        pub fn set_s3_key_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_key_prefix = input;
            self
        }
        /// <p>The ARN of the SNS topic that is used for notifications of log file delivery.</p>
        pub fn sns_topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.sns_topic_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the SNS topic that is used for notifications of log file delivery.</p>
        pub fn set_sns_topic_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sns_topic_arn = input;
            self
        }
        /// <p>The name of the SNS topic that is used for notifications of log file delivery.</p>
        pub fn sns_topic_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.sns_topic_name = Some(input.into());
            self
        }
        /// <p>The name of the SNS topic that is used for notifications of log file delivery.</p>
        pub fn set_sns_topic_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sns_topic_name = input;
            self
        }
        /// <p>The ARN of the trail.</p>
        pub fn trail_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.trail_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the trail.</p>
        pub fn set_trail_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.trail_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCloudTrailTrailDetails`](crate::model::AwsCloudTrailTrailDetails)
        pub fn build(self) -> crate::model::AwsCloudTrailTrailDetails {
            crate::model::AwsCloudTrailTrailDetails {
                cloud_watch_logs_log_group_arn: self.cloud_watch_logs_log_group_arn,
                cloud_watch_logs_role_arn: self.cloud_watch_logs_role_arn,
                has_custom_event_selectors: self.has_custom_event_selectors.unwrap_or_default(),
                home_region: self.home_region,
                include_global_service_events: self
                    .include_global_service_events
                    .unwrap_or_default(),
                is_multi_region_trail: self.is_multi_region_trail.unwrap_or_default(),
                is_organization_trail: self.is_organization_trail.unwrap_or_default(),
                kms_key_id: self.kms_key_id,
                log_file_validation_enabled: self.log_file_validation_enabled.unwrap_or_default(),
                name: self.name,
                s3_bucket_name: self.s3_bucket_name,
                s3_key_prefix: self.s3_key_prefix,
                sns_topic_arn: self.sns_topic_arn,
                sns_topic_name: self.sns_topic_name,
                trail_arn: self.trail_arn,
            }
        }
    }
}
impl AwsCloudTrailTrailDetails {
    /// Creates a new builder-style object to manufacture [`AwsCloudTrailTrailDetails`](crate::model::AwsCloudTrailTrailDetails)
    pub fn builder() -> crate::model::aws_cloud_trail_trail_details::Builder {
        crate::model::aws_cloud_trail_trail_details::Builder::default()
    }
}

/// <p>Contains information about a REST API in version 1 of Amazon API Gateway.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsApiGatewayRestApiDetails {
    /// <p>The identifier of the REST API.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the REST API.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A description of the REST API.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Indicates when the API was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub created_date: std::option::Option<std::string::String>,
    /// <p>The version identifier for the REST API.</p>
    pub version: std::option::Option<std::string::String>,
    /// <p>The list of binary media types supported by the REST API.</p>
    pub binary_media_types: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The minimum size in bytes of a payload before compression is enabled.</p>
    /// <p>If <code>null</code>, then compression is disabled.</p>
    /// <p>If 0, then all payloads are compressed.</p>
    pub minimum_compression_size: i32,
    /// <p>The source of the API key for metering requests according to a usage plan.</p>
    /// <p> <code>HEADER</code> indicates whether to read the API key from the X-API-Key header of a request.</p>
    /// <p> <code>AUTHORIZER</code> indicates whether to read the API key from the <code>UsageIdentifierKey</code> from a custom authorizer.</p>
    pub api_key_source: std::option::Option<std::string::String>,
    /// <p>The endpoint configuration of the REST API.</p>
    pub endpoint_configuration:
        std::option::Option<crate::model::AwsApiGatewayEndpointConfiguration>,
}
impl AwsApiGatewayRestApiDetails {
    /// <p>The identifier of the REST API.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the REST API.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A description of the REST API.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Indicates when the API was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn created_date(&self) -> std::option::Option<&str> {
        self.created_date.as_deref()
    }
    /// <p>The version identifier for the REST API.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
    /// <p>The list of binary media types supported by the REST API.</p>
    pub fn binary_media_types(&self) -> std::option::Option<&[std::string::String]> {
        self.binary_media_types.as_deref()
    }
    /// <p>The minimum size in bytes of a payload before compression is enabled.</p>
    /// <p>If <code>null</code>, then compression is disabled.</p>
    /// <p>If 0, then all payloads are compressed.</p>
    pub fn minimum_compression_size(&self) -> i32 {
        self.minimum_compression_size
    }
    /// <p>The source of the API key for metering requests according to a usage plan.</p>
    /// <p> <code>HEADER</code> indicates whether to read the API key from the X-API-Key header of a request.</p>
    /// <p> <code>AUTHORIZER</code> indicates whether to read the API key from the <code>UsageIdentifierKey</code> from a custom authorizer.</p>
    pub fn api_key_source(&self) -> std::option::Option<&str> {
        self.api_key_source.as_deref()
    }
    /// <p>The endpoint configuration of the REST API.</p>
    pub fn endpoint_configuration(
        &self,
    ) -> std::option::Option<&crate::model::AwsApiGatewayEndpointConfiguration> {
        self.endpoint_configuration.as_ref()
    }
}
impl std::fmt::Debug for AwsApiGatewayRestApiDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsApiGatewayRestApiDetails");
        formatter.field("id", &self.id);
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("created_date", &self.created_date);
        formatter.field("version", &self.version);
        formatter.field("binary_media_types", &self.binary_media_types);
        formatter.field("minimum_compression_size", &self.minimum_compression_size);
        formatter.field("api_key_source", &self.api_key_source);
        formatter.field("endpoint_configuration", &self.endpoint_configuration);
        formatter.finish()
    }
}
/// See [`AwsApiGatewayRestApiDetails`](crate::model::AwsApiGatewayRestApiDetails)
pub mod aws_api_gateway_rest_api_details {

    /// A builder for [`AwsApiGatewayRestApiDetails`](crate::model::AwsApiGatewayRestApiDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) created_date: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
        pub(crate) binary_media_types: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) minimum_compression_size: std::option::Option<i32>,
        pub(crate) api_key_source: std::option::Option<std::string::String>,
        pub(crate) endpoint_configuration:
            std::option::Option<crate::model::AwsApiGatewayEndpointConfiguration>,
    }
    impl Builder {
        /// <p>The identifier of the REST API.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the REST API.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the REST API.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the REST API.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A description of the REST API.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the REST API.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Indicates when the API was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn created_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_date = Some(input.into());
            self
        }
        /// <p>Indicates when the API was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_created_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_date = input;
            self
        }
        /// <p>The version identifier for the REST API.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The version identifier for the REST API.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Appends an item to `binary_media_types`.
        ///
        /// To override the contents of this collection use [`set_binary_media_types`](Self::set_binary_media_types).
        ///
        /// <p>The list of binary media types supported by the REST API.</p>
        pub fn binary_media_types(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.binary_media_types.unwrap_or_default();
            v.push(input.into());
            self.binary_media_types = Some(v);
            self
        }
        /// <p>The list of binary media types supported by the REST API.</p>
        pub fn set_binary_media_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.binary_media_types = input;
            self
        }
        /// <p>The minimum size in bytes of a payload before compression is enabled.</p>
        /// <p>If <code>null</code>, then compression is disabled.</p>
        /// <p>If 0, then all payloads are compressed.</p>
        pub fn minimum_compression_size(mut self, input: i32) -> Self {
            self.minimum_compression_size = Some(input);
            self
        }
        /// <p>The minimum size in bytes of a payload before compression is enabled.</p>
        /// <p>If <code>null</code>, then compression is disabled.</p>
        /// <p>If 0, then all payloads are compressed.</p>
        pub fn set_minimum_compression_size(mut self, input: std::option::Option<i32>) -> Self {
            self.minimum_compression_size = input;
            self
        }
        /// <p>The source of the API key for metering requests according to a usage plan.</p>
        /// <p> <code>HEADER</code> indicates whether to read the API key from the X-API-Key header of a request.</p>
        /// <p> <code>AUTHORIZER</code> indicates whether to read the API key from the <code>UsageIdentifierKey</code> from a custom authorizer.</p>
        pub fn api_key_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.api_key_source = Some(input.into());
            self
        }
        /// <p>The source of the API key for metering requests according to a usage plan.</p>
        /// <p> <code>HEADER</code> indicates whether to read the API key from the X-API-Key header of a request.</p>
        /// <p> <code>AUTHORIZER</code> indicates whether to read the API key from the <code>UsageIdentifierKey</code> from a custom authorizer.</p>
        pub fn set_api_key_source(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.api_key_source = input;
            self
        }
        /// <p>The endpoint configuration of the REST API.</p>
        pub fn endpoint_configuration(
            mut self,
            input: crate::model::AwsApiGatewayEndpointConfiguration,
        ) -> Self {
            self.endpoint_configuration = Some(input);
            self
        }
        /// <p>The endpoint configuration of the REST API.</p>
        pub fn set_endpoint_configuration(
            mut self,
            input: std::option::Option<crate::model::AwsApiGatewayEndpointConfiguration>,
        ) -> Self {
            self.endpoint_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsApiGatewayRestApiDetails`](crate::model::AwsApiGatewayRestApiDetails)
        pub fn build(self) -> crate::model::AwsApiGatewayRestApiDetails {
            crate::model::AwsApiGatewayRestApiDetails {
                id: self.id,
                name: self.name,
                description: self.description,
                created_date: self.created_date,
                version: self.version,
                binary_media_types: self.binary_media_types,
                minimum_compression_size: self.minimum_compression_size.unwrap_or_default(),
                api_key_source: self.api_key_source,
                endpoint_configuration: self.endpoint_configuration,
            }
        }
    }
}
impl AwsApiGatewayRestApiDetails {
    /// Creates a new builder-style object to manufacture [`AwsApiGatewayRestApiDetails`](crate::model::AwsApiGatewayRestApiDetails)
    pub fn builder() -> crate::model::aws_api_gateway_rest_api_details::Builder {
        crate::model::aws_api_gateway_rest_api_details::Builder::default()
    }
}

/// <p>Contains information about the endpoints for the API.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsApiGatewayEndpointConfiguration {
    /// <p>A list of endpoint types for the REST API.</p>
    /// <p>For an edge-optimized API, the endpoint type is <code>EDGE</code>. For a Regional API, the endpoint type is <code>REGIONAL</code>. For a private API, the endpoint type is <code>PRIVATE</code>.</p>
    pub types: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AwsApiGatewayEndpointConfiguration {
    /// <p>A list of endpoint types for the REST API.</p>
    /// <p>For an edge-optimized API, the endpoint type is <code>EDGE</code>. For a Regional API, the endpoint type is <code>REGIONAL</code>. For a private API, the endpoint type is <code>PRIVATE</code>.</p>
    pub fn types(&self) -> std::option::Option<&[std::string::String]> {
        self.types.as_deref()
    }
}
impl std::fmt::Debug for AwsApiGatewayEndpointConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsApiGatewayEndpointConfiguration");
        formatter.field("types", &self.types);
        formatter.finish()
    }
}
/// See [`AwsApiGatewayEndpointConfiguration`](crate::model::AwsApiGatewayEndpointConfiguration)
pub mod aws_api_gateway_endpoint_configuration {

    /// A builder for [`AwsApiGatewayEndpointConfiguration`](crate::model::AwsApiGatewayEndpointConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) types: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `types`.
        ///
        /// To override the contents of this collection use [`set_types`](Self::set_types).
        ///
        /// <p>A list of endpoint types for the REST API.</p>
        /// <p>For an edge-optimized API, the endpoint type is <code>EDGE</code>. For a Regional API, the endpoint type is <code>REGIONAL</code>. For a private API, the endpoint type is <code>PRIVATE</code>.</p>
        pub fn types(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.types.unwrap_or_default();
            v.push(input.into());
            self.types = Some(v);
            self
        }
        /// <p>A list of endpoint types for the REST API.</p>
        /// <p>For an edge-optimized API, the endpoint type is <code>EDGE</code>. For a Regional API, the endpoint type is <code>REGIONAL</code>. For a private API, the endpoint type is <code>PRIVATE</code>.</p>
        pub fn set_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.types = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsApiGatewayEndpointConfiguration`](crate::model::AwsApiGatewayEndpointConfiguration)
        pub fn build(self) -> crate::model::AwsApiGatewayEndpointConfiguration {
            crate::model::AwsApiGatewayEndpointConfiguration { types: self.types }
        }
    }
}
impl AwsApiGatewayEndpointConfiguration {
    /// Creates a new builder-style object to manufacture [`AwsApiGatewayEndpointConfiguration`](crate::model::AwsApiGatewayEndpointConfiguration)
    pub fn builder() -> crate::model::aws_api_gateway_endpoint_configuration::Builder {
        crate::model::aws_api_gateway_endpoint_configuration::Builder::default()
    }
}

/// <p>Provides information about a version 1 Amazon API Gateway stage.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsApiGatewayStageDetails {
    /// <p>The identifier of the deployment that the stage points to.</p>
    pub deployment_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the client certificate for the stage.</p>
    pub client_certificate_id: std::option::Option<std::string::String>,
    /// <p>The name of the stage.</p>
    pub stage_name: std::option::Option<std::string::String>,
    /// <p>A description of the stage.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Indicates whether a cache cluster is enabled for the stage.</p>
    pub cache_cluster_enabled: bool,
    /// <p>If a cache cluster is enabled, the size of the cache cluster.</p>
    pub cache_cluster_size: std::option::Option<std::string::String>,
    /// <p>If a cache cluster is enabled, the status of the cache cluster.</p>
    pub cache_cluster_status: std::option::Option<std::string::String>,
    /// <p>Defines the method settings for the stage.</p>
    pub method_settings:
        std::option::Option<std::vec::Vec<crate::model::AwsApiGatewayMethodSettings>>,
    /// <p>A map that defines the stage variables for the stage.</p>
    /// <p>Variable names can have alphanumeric and underscore characters.</p>
    /// <p>Variable values can contain the following characters:</p>
    /// <ul>
    /// <li> <p>Uppercase and lowercase letters</p> </li>
    /// <li> <p>Numbers</p> </li>
    /// <li> <p>Special characters -._~:/?#&amp;=,</p> </li>
    /// </ul>
    pub variables:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The version of the API documentation that is associated with the stage.</p>
    pub documentation_version: std::option::Option<std::string::String>,
    /// <p>Settings for logging access for the stage.</p>
    pub access_log_settings: std::option::Option<crate::model::AwsApiGatewayAccessLogSettings>,
    /// <p>Information about settings for canary deployment in the stage.</p>
    pub canary_settings: std::option::Option<crate::model::AwsApiGatewayCanarySettings>,
    /// <p>Indicates whether active tracing with X-Ray is enabled for the stage.</p>
    pub tracing_enabled: bool,
    /// <p>Indicates when the stage was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub created_date: std::option::Option<std::string::String>,
    /// <p>Indicates when the stage was most recently updated.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub last_updated_date: std::option::Option<std::string::String>,
    /// <p>The ARN of the web ACL associated with the stage.</p>
    pub web_acl_arn: std::option::Option<std::string::String>,
}
impl AwsApiGatewayStageDetails {
    /// <p>The identifier of the deployment that the stage points to.</p>
    pub fn deployment_id(&self) -> std::option::Option<&str> {
        self.deployment_id.as_deref()
    }
    /// <p>The identifier of the client certificate for the stage.</p>
    pub fn client_certificate_id(&self) -> std::option::Option<&str> {
        self.client_certificate_id.as_deref()
    }
    /// <p>The name of the stage.</p>
    pub fn stage_name(&self) -> std::option::Option<&str> {
        self.stage_name.as_deref()
    }
    /// <p>A description of the stage.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Indicates whether a cache cluster is enabled for the stage.</p>
    pub fn cache_cluster_enabled(&self) -> bool {
        self.cache_cluster_enabled
    }
    /// <p>If a cache cluster is enabled, the size of the cache cluster.</p>
    pub fn cache_cluster_size(&self) -> std::option::Option<&str> {
        self.cache_cluster_size.as_deref()
    }
    /// <p>If a cache cluster is enabled, the status of the cache cluster.</p>
    pub fn cache_cluster_status(&self) -> std::option::Option<&str> {
        self.cache_cluster_status.as_deref()
    }
    /// <p>Defines the method settings for the stage.</p>
    pub fn method_settings(
        &self,
    ) -> std::option::Option<&[crate::model::AwsApiGatewayMethodSettings]> {
        self.method_settings.as_deref()
    }
    /// <p>A map that defines the stage variables for the stage.</p>
    /// <p>Variable names can have alphanumeric and underscore characters.</p>
    /// <p>Variable values can contain the following characters:</p>
    /// <ul>
    /// <li> <p>Uppercase and lowercase letters</p> </li>
    /// <li> <p>Numbers</p> </li>
    /// <li> <p>Special characters -._~:/?#&amp;=,</p> </li>
    /// </ul>
    pub fn variables(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.variables.as_ref()
    }
    /// <p>The version of the API documentation that is associated with the stage.</p>
    pub fn documentation_version(&self) -> std::option::Option<&str> {
        self.documentation_version.as_deref()
    }
    /// <p>Settings for logging access for the stage.</p>
    pub fn access_log_settings(
        &self,
    ) -> std::option::Option<&crate::model::AwsApiGatewayAccessLogSettings> {
        self.access_log_settings.as_ref()
    }
    /// <p>Information about settings for canary deployment in the stage.</p>
    pub fn canary_settings(
        &self,
    ) -> std::option::Option<&crate::model::AwsApiGatewayCanarySettings> {
        self.canary_settings.as_ref()
    }
    /// <p>Indicates whether active tracing with X-Ray is enabled for the stage.</p>
    pub fn tracing_enabled(&self) -> bool {
        self.tracing_enabled
    }
    /// <p>Indicates when the stage was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn created_date(&self) -> std::option::Option<&str> {
        self.created_date.as_deref()
    }
    /// <p>Indicates when the stage was most recently updated.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn last_updated_date(&self) -> std::option::Option<&str> {
        self.last_updated_date.as_deref()
    }
    /// <p>The ARN of the web ACL associated with the stage.</p>
    pub fn web_acl_arn(&self) -> std::option::Option<&str> {
        self.web_acl_arn.as_deref()
    }
}
impl std::fmt::Debug for AwsApiGatewayStageDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsApiGatewayStageDetails");
        formatter.field("deployment_id", &self.deployment_id);
        formatter.field("client_certificate_id", &self.client_certificate_id);
        formatter.field("stage_name", &self.stage_name);
        formatter.field("description", &self.description);
        formatter.field("cache_cluster_enabled", &self.cache_cluster_enabled);
        formatter.field("cache_cluster_size", &self.cache_cluster_size);
        formatter.field("cache_cluster_status", &self.cache_cluster_status);
        formatter.field("method_settings", &self.method_settings);
        formatter.field("variables", &self.variables);
        formatter.field("documentation_version", &self.documentation_version);
        formatter.field("access_log_settings", &self.access_log_settings);
        formatter.field("canary_settings", &self.canary_settings);
        formatter.field("tracing_enabled", &self.tracing_enabled);
        formatter.field("created_date", &self.created_date);
        formatter.field("last_updated_date", &self.last_updated_date);
        formatter.field("web_acl_arn", &self.web_acl_arn);
        formatter.finish()
    }
}
/// See [`AwsApiGatewayStageDetails`](crate::model::AwsApiGatewayStageDetails)
pub mod aws_api_gateway_stage_details {

    /// A builder for [`AwsApiGatewayStageDetails`](crate::model::AwsApiGatewayStageDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) deployment_id: std::option::Option<std::string::String>,
        pub(crate) client_certificate_id: std::option::Option<std::string::String>,
        pub(crate) stage_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) cache_cluster_enabled: std::option::Option<bool>,
        pub(crate) cache_cluster_size: std::option::Option<std::string::String>,
        pub(crate) cache_cluster_status: std::option::Option<std::string::String>,
        pub(crate) method_settings:
            std::option::Option<std::vec::Vec<crate::model::AwsApiGatewayMethodSettings>>,
        pub(crate) variables: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) documentation_version: std::option::Option<std::string::String>,
        pub(crate) access_log_settings:
            std::option::Option<crate::model::AwsApiGatewayAccessLogSettings>,
        pub(crate) canary_settings: std::option::Option<crate::model::AwsApiGatewayCanarySettings>,
        pub(crate) tracing_enabled: std::option::Option<bool>,
        pub(crate) created_date: std::option::Option<std::string::String>,
        pub(crate) last_updated_date: std::option::Option<std::string::String>,
        pub(crate) web_acl_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the deployment that the stage points to.</p>
        pub fn deployment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.deployment_id = Some(input.into());
            self
        }
        /// <p>The identifier of the deployment that the stage points to.</p>
        pub fn set_deployment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.deployment_id = input;
            self
        }
        /// <p>The identifier of the client certificate for the stage.</p>
        pub fn client_certificate_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_certificate_id = Some(input.into());
            self
        }
        /// <p>The identifier of the client certificate for the stage.</p>
        pub fn set_client_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_certificate_id = input;
            self
        }
        /// <p>The name of the stage.</p>
        pub fn stage_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.stage_name = Some(input.into());
            self
        }
        /// <p>The name of the stage.</p>
        pub fn set_stage_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stage_name = input;
            self
        }
        /// <p>A description of the stage.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the stage.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Indicates whether a cache cluster is enabled for the stage.</p>
        pub fn cache_cluster_enabled(mut self, input: bool) -> Self {
            self.cache_cluster_enabled = Some(input);
            self
        }
        /// <p>Indicates whether a cache cluster is enabled for the stage.</p>
        pub fn set_cache_cluster_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.cache_cluster_enabled = input;
            self
        }
        /// <p>If a cache cluster is enabled, the size of the cache cluster.</p>
        pub fn cache_cluster_size(mut self, input: impl Into<std::string::String>) -> Self {
            self.cache_cluster_size = Some(input.into());
            self
        }
        /// <p>If a cache cluster is enabled, the size of the cache cluster.</p>
        pub fn set_cache_cluster_size(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cache_cluster_size = input;
            self
        }
        /// <p>If a cache cluster is enabled, the status of the cache cluster.</p>
        pub fn cache_cluster_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.cache_cluster_status = Some(input.into());
            self
        }
        /// <p>If a cache cluster is enabled, the status of the cache cluster.</p>
        pub fn set_cache_cluster_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cache_cluster_status = input;
            self
        }
        /// Appends an item to `method_settings`.
        ///
        /// To override the contents of this collection use [`set_method_settings`](Self::set_method_settings).
        ///
        /// <p>Defines the method settings for the stage.</p>
        pub fn method_settings(mut self, input: crate::model::AwsApiGatewayMethodSettings) -> Self {
            let mut v = self.method_settings.unwrap_or_default();
            v.push(input);
            self.method_settings = Some(v);
            self
        }
        /// <p>Defines the method settings for the stage.</p>
        pub fn set_method_settings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsApiGatewayMethodSettings>>,
        ) -> Self {
            self.method_settings = input;
            self
        }
        /// Adds a key-value pair to `variables`.
        ///
        /// To override the contents of this collection use [`set_variables`](Self::set_variables).
        ///
        /// <p>A map that defines the stage variables for the stage.</p>
        /// <p>Variable names can have alphanumeric and underscore characters.</p>
        /// <p>Variable values can contain the following characters:</p>
        /// <ul>
        /// <li> <p>Uppercase and lowercase letters</p> </li>
        /// <li> <p>Numbers</p> </li>
        /// <li> <p>Special characters -._~:/?#&amp;=,</p> </li>
        /// </ul>
        pub fn variables(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.variables.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.variables = Some(hash_map);
            self
        }
        /// <p>A map that defines the stage variables for the stage.</p>
        /// <p>Variable names can have alphanumeric and underscore characters.</p>
        /// <p>Variable values can contain the following characters:</p>
        /// <ul>
        /// <li> <p>Uppercase and lowercase letters</p> </li>
        /// <li> <p>Numbers</p> </li>
        /// <li> <p>Special characters -._~:/?#&amp;=,</p> </li>
        /// </ul>
        pub fn set_variables(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.variables = input;
            self
        }
        /// <p>The version of the API documentation that is associated with the stage.</p>
        pub fn documentation_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.documentation_version = Some(input.into());
            self
        }
        /// <p>The version of the API documentation that is associated with the stage.</p>
        pub fn set_documentation_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.documentation_version = input;
            self
        }
        /// <p>Settings for logging access for the stage.</p>
        pub fn access_log_settings(
            mut self,
            input: crate::model::AwsApiGatewayAccessLogSettings,
        ) -> Self {
            self.access_log_settings = Some(input);
            self
        }
        /// <p>Settings for logging access for the stage.</p>
        pub fn set_access_log_settings(
            mut self,
            input: std::option::Option<crate::model::AwsApiGatewayAccessLogSettings>,
        ) -> Self {
            self.access_log_settings = input;
            self
        }
        /// <p>Information about settings for canary deployment in the stage.</p>
        pub fn canary_settings(mut self, input: crate::model::AwsApiGatewayCanarySettings) -> Self {
            self.canary_settings = Some(input);
            self
        }
        /// <p>Information about settings for canary deployment in the stage.</p>
        pub fn set_canary_settings(
            mut self,
            input: std::option::Option<crate::model::AwsApiGatewayCanarySettings>,
        ) -> Self {
            self.canary_settings = input;
            self
        }
        /// <p>Indicates whether active tracing with X-Ray is enabled for the stage.</p>
        pub fn tracing_enabled(mut self, input: bool) -> Self {
            self.tracing_enabled = Some(input);
            self
        }
        /// <p>Indicates whether active tracing with X-Ray is enabled for the stage.</p>
        pub fn set_tracing_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.tracing_enabled = input;
            self
        }
        /// <p>Indicates when the stage was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn created_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_date = Some(input.into());
            self
        }
        /// <p>Indicates when the stage was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_created_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_date = input;
            self
        }
        /// <p>Indicates when the stage was most recently updated.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn last_updated_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_updated_date = Some(input.into());
            self
        }
        /// <p>Indicates when the stage was most recently updated.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_last_updated_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_updated_date = input;
            self
        }
        /// <p>The ARN of the web ACL associated with the stage.</p>
        pub fn web_acl_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.web_acl_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the web ACL associated with the stage.</p>
        pub fn set_web_acl_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.web_acl_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsApiGatewayStageDetails`](crate::model::AwsApiGatewayStageDetails)
        pub fn build(self) -> crate::model::AwsApiGatewayStageDetails {
            crate::model::AwsApiGatewayStageDetails {
                deployment_id: self.deployment_id,
                client_certificate_id: self.client_certificate_id,
                stage_name: self.stage_name,
                description: self.description,
                cache_cluster_enabled: self.cache_cluster_enabled.unwrap_or_default(),
                cache_cluster_size: self.cache_cluster_size,
                cache_cluster_status: self.cache_cluster_status,
                method_settings: self.method_settings,
                variables: self.variables,
                documentation_version: self.documentation_version,
                access_log_settings: self.access_log_settings,
                canary_settings: self.canary_settings,
                tracing_enabled: self.tracing_enabled.unwrap_or_default(),
                created_date: self.created_date,
                last_updated_date: self.last_updated_date,
                web_acl_arn: self.web_acl_arn,
            }
        }
    }
}
impl AwsApiGatewayStageDetails {
    /// Creates a new builder-style object to manufacture [`AwsApiGatewayStageDetails`](crate::model::AwsApiGatewayStageDetails)
    pub fn builder() -> crate::model::aws_api_gateway_stage_details::Builder {
        crate::model::aws_api_gateway_stage_details::Builder::default()
    }
}

/// <p>Contains information about settings for canary deployment in the stage.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsApiGatewayCanarySettings {
    /// <p>The percentage of traffic that is diverted to a canary deployment.</p>
    pub percent_traffic: f64,
    /// <p>The deployment identifier for the canary deployment.</p>
    pub deployment_id: std::option::Option<std::string::String>,
    /// <p>Stage variables that are overridden in the canary release deployment. The variables include new stage variables that are introduced in the canary.</p>
    /// <p>Each variable is represented as a string-to-string map between the stage variable name and the variable value.</p>
    pub stage_variable_overrides:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Indicates whether the canary deployment uses the stage cache.</p>
    pub use_stage_cache: bool,
}
impl AwsApiGatewayCanarySettings {
    /// <p>The percentage of traffic that is diverted to a canary deployment.</p>
    pub fn percent_traffic(&self) -> f64 {
        self.percent_traffic
    }
    /// <p>The deployment identifier for the canary deployment.</p>
    pub fn deployment_id(&self) -> std::option::Option<&str> {
        self.deployment_id.as_deref()
    }
    /// <p>Stage variables that are overridden in the canary release deployment. The variables include new stage variables that are introduced in the canary.</p>
    /// <p>Each variable is represented as a string-to-string map between the stage variable name and the variable value.</p>
    pub fn stage_variable_overrides(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.stage_variable_overrides.as_ref()
    }
    /// <p>Indicates whether the canary deployment uses the stage cache.</p>
    pub fn use_stage_cache(&self) -> bool {
        self.use_stage_cache
    }
}
impl std::fmt::Debug for AwsApiGatewayCanarySettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsApiGatewayCanarySettings");
        formatter.field("percent_traffic", &self.percent_traffic);
        formatter.field("deployment_id", &self.deployment_id);
        formatter.field("stage_variable_overrides", &self.stage_variable_overrides);
        formatter.field("use_stage_cache", &self.use_stage_cache);
        formatter.finish()
    }
}
/// See [`AwsApiGatewayCanarySettings`](crate::model::AwsApiGatewayCanarySettings)
pub mod aws_api_gateway_canary_settings {

    /// A builder for [`AwsApiGatewayCanarySettings`](crate::model::AwsApiGatewayCanarySettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) percent_traffic: std::option::Option<f64>,
        pub(crate) deployment_id: std::option::Option<std::string::String>,
        pub(crate) stage_variable_overrides: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) use_stage_cache: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The percentage of traffic that is diverted to a canary deployment.</p>
        pub fn percent_traffic(mut self, input: f64) -> Self {
            self.percent_traffic = Some(input);
            self
        }
        /// <p>The percentage of traffic that is diverted to a canary deployment.</p>
        pub fn set_percent_traffic(mut self, input: std::option::Option<f64>) -> Self {
            self.percent_traffic = input;
            self
        }
        /// <p>The deployment identifier for the canary deployment.</p>
        pub fn deployment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.deployment_id = Some(input.into());
            self
        }
        /// <p>The deployment identifier for the canary deployment.</p>
        pub fn set_deployment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.deployment_id = input;
            self
        }
        /// Adds a key-value pair to `stage_variable_overrides`.
        ///
        /// To override the contents of this collection use [`set_stage_variable_overrides`](Self::set_stage_variable_overrides).
        ///
        /// <p>Stage variables that are overridden in the canary release deployment. The variables include new stage variables that are introduced in the canary.</p>
        /// <p>Each variable is represented as a string-to-string map between the stage variable name and the variable value.</p>
        pub fn stage_variable_overrides(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.stage_variable_overrides.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.stage_variable_overrides = Some(hash_map);
            self
        }
        /// <p>Stage variables that are overridden in the canary release deployment. The variables include new stage variables that are introduced in the canary.</p>
        /// <p>Each variable is represented as a string-to-string map between the stage variable name and the variable value.</p>
        pub fn set_stage_variable_overrides(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.stage_variable_overrides = input;
            self
        }
        /// <p>Indicates whether the canary deployment uses the stage cache.</p>
        pub fn use_stage_cache(mut self, input: bool) -> Self {
            self.use_stage_cache = Some(input);
            self
        }
        /// <p>Indicates whether the canary deployment uses the stage cache.</p>
        pub fn set_use_stage_cache(mut self, input: std::option::Option<bool>) -> Self {
            self.use_stage_cache = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsApiGatewayCanarySettings`](crate::model::AwsApiGatewayCanarySettings)
        pub fn build(self) -> crate::model::AwsApiGatewayCanarySettings {
            crate::model::AwsApiGatewayCanarySettings {
                percent_traffic: self.percent_traffic.unwrap_or_default(),
                deployment_id: self.deployment_id,
                stage_variable_overrides: self.stage_variable_overrides,
                use_stage_cache: self.use_stage_cache.unwrap_or_default(),
            }
        }
    }
}
impl AwsApiGatewayCanarySettings {
    /// Creates a new builder-style object to manufacture [`AwsApiGatewayCanarySettings`](crate::model::AwsApiGatewayCanarySettings)
    pub fn builder() -> crate::model::aws_api_gateway_canary_settings::Builder {
        crate::model::aws_api_gateway_canary_settings::Builder::default()
    }
}

/// <p>Contains information about settings for logging access for the stage.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsApiGatewayAccessLogSettings {
    /// <p>A single-line format of the access logs of data, as specified by selected <code>$context</code> variables. The format must include at least <code>$context.requestId</code>.</p>
    pub format: std::option::Option<std::string::String>,
    /// <p>The ARN of the CloudWatch Logs log group that receives the access logs.</p>
    pub destination_arn: std::option::Option<std::string::String>,
}
impl AwsApiGatewayAccessLogSettings {
    /// <p>A single-line format of the access logs of data, as specified by selected <code>$context</code> variables. The format must include at least <code>$context.requestId</code>.</p>
    pub fn format(&self) -> std::option::Option<&str> {
        self.format.as_deref()
    }
    /// <p>The ARN of the CloudWatch Logs log group that receives the access logs.</p>
    pub fn destination_arn(&self) -> std::option::Option<&str> {
        self.destination_arn.as_deref()
    }
}
impl std::fmt::Debug for AwsApiGatewayAccessLogSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsApiGatewayAccessLogSettings");
        formatter.field("format", &self.format);
        formatter.field("destination_arn", &self.destination_arn);
        formatter.finish()
    }
}
/// See [`AwsApiGatewayAccessLogSettings`](crate::model::AwsApiGatewayAccessLogSettings)
pub mod aws_api_gateway_access_log_settings {

    /// A builder for [`AwsApiGatewayAccessLogSettings`](crate::model::AwsApiGatewayAccessLogSettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) format: std::option::Option<std::string::String>,
        pub(crate) destination_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A single-line format of the access logs of data, as specified by selected <code>$context</code> variables. The format must include at least <code>$context.requestId</code>.</p>
        pub fn format(mut self, input: impl Into<std::string::String>) -> Self {
            self.format = Some(input.into());
            self
        }
        /// <p>A single-line format of the access logs of data, as specified by selected <code>$context</code> variables. The format must include at least <code>$context.requestId</code>.</p>
        pub fn set_format(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.format = input;
            self
        }
        /// <p>The ARN of the CloudWatch Logs log group that receives the access logs.</p>
        pub fn destination_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the CloudWatch Logs log group that receives the access logs.</p>
        pub fn set_destination_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsApiGatewayAccessLogSettings`](crate::model::AwsApiGatewayAccessLogSettings)
        pub fn build(self) -> crate::model::AwsApiGatewayAccessLogSettings {
            crate::model::AwsApiGatewayAccessLogSettings {
                format: self.format,
                destination_arn: self.destination_arn,
            }
        }
    }
}
impl AwsApiGatewayAccessLogSettings {
    /// Creates a new builder-style object to manufacture [`AwsApiGatewayAccessLogSettings`](crate::model::AwsApiGatewayAccessLogSettings)
    pub fn builder() -> crate::model::aws_api_gateway_access_log_settings::Builder {
        crate::model::aws_api_gateway_access_log_settings::Builder::default()
    }
}

/// <p>Defines settings for a method for the stage.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsApiGatewayMethodSettings {
    /// <p>Indicates whether CloudWatch metrics are enabled for the method. </p>
    pub metrics_enabled: bool,
    /// <p>The logging level for this method. The logging level affects the log entries that are pushed to CloudWatch Logs.</p>
    /// <p>If the logging level is <code>ERROR</code>, then the logs only include error-level entries.</p>
    /// <p>If the logging level is <code>INFO</code>, then the logs include both <code>ERROR</code> events and extra informational events.</p>
    /// <p>Valid values: <code>OFF</code> | <code>ERROR</code> | <code>INFO</code> </p>
    pub logging_level: std::option::Option<std::string::String>,
    /// <p>Indicates whether data trace logging is enabled for the method. Data trace logging affects the log entries that are pushed to CloudWatch Logs.</p>
    pub data_trace_enabled: bool,
    /// <p>The throttling burst limit for the method.</p>
    pub throttling_burst_limit: i32,
    /// <p>The throttling rate limit for the method.</p>
    pub throttling_rate_limit: f64,
    /// <p>Indicates whether responses are cached and returned for requests. For responses to be cached, a cache cluster must be enabled on the stage.</p>
    pub caching_enabled: bool,
    /// <p>Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response is cached.</p>
    pub cache_ttl_in_seconds: i32,
    /// <p>Indicates whether the cached responses are encrypted. </p>
    pub cache_data_encrypted: bool,
    /// <p>Indicates whether authorization is required for a cache invalidation request.</p>
    pub require_authorization_for_cache_control: bool,
    /// <p>Indicates how to handle unauthorized requests for cache invalidation.</p>
    /// <p>Valid values: <code>FAIL_WITH_403</code> | <code>SUCCEED_WITH_RESPONSE_HEADER</code> | <code>SUCCEED_WITHOUT_RESPONSE_HEADER</code> </p>
    pub unauthorized_cache_control_header_strategy: std::option::Option<std::string::String>,
    /// <p>The HTTP method. You can use an asterisk (*) as a wildcard to apply method settings to multiple methods.</p>
    pub http_method: std::option::Option<std::string::String>,
    /// <p>The resource path for this method. Forward slashes (/) are encoded as ~1 . The initial slash must include a forward slash.</p>
    /// <p>For example, the path value <code>/resource/subresource</code> must be encoded as <code>/~1resource~1subresource</code>.</p>
    /// <p>To specify the root path, use only a slash (/). You can use an asterisk (*) as a wildcard to apply method settings to multiple methods.</p>
    pub resource_path: std::option::Option<std::string::String>,
}
impl AwsApiGatewayMethodSettings {
    /// <p>Indicates whether CloudWatch metrics are enabled for the method. </p>
    pub fn metrics_enabled(&self) -> bool {
        self.metrics_enabled
    }
    /// <p>The logging level for this method. The logging level affects the log entries that are pushed to CloudWatch Logs.</p>
    /// <p>If the logging level is <code>ERROR</code>, then the logs only include error-level entries.</p>
    /// <p>If the logging level is <code>INFO</code>, then the logs include both <code>ERROR</code> events and extra informational events.</p>
    /// <p>Valid values: <code>OFF</code> | <code>ERROR</code> | <code>INFO</code> </p>
    pub fn logging_level(&self) -> std::option::Option<&str> {
        self.logging_level.as_deref()
    }
    /// <p>Indicates whether data trace logging is enabled for the method. Data trace logging affects the log entries that are pushed to CloudWatch Logs.</p>
    pub fn data_trace_enabled(&self) -> bool {
        self.data_trace_enabled
    }
    /// <p>The throttling burst limit for the method.</p>
    pub fn throttling_burst_limit(&self) -> i32 {
        self.throttling_burst_limit
    }
    /// <p>The throttling rate limit for the method.</p>
    pub fn throttling_rate_limit(&self) -> f64 {
        self.throttling_rate_limit
    }
    /// <p>Indicates whether responses are cached and returned for requests. For responses to be cached, a cache cluster must be enabled on the stage.</p>
    pub fn caching_enabled(&self) -> bool {
        self.caching_enabled
    }
    /// <p>Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response is cached.</p>
    pub fn cache_ttl_in_seconds(&self) -> i32 {
        self.cache_ttl_in_seconds
    }
    /// <p>Indicates whether the cached responses are encrypted. </p>
    pub fn cache_data_encrypted(&self) -> bool {
        self.cache_data_encrypted
    }
    /// <p>Indicates whether authorization is required for a cache invalidation request.</p>
    pub fn require_authorization_for_cache_control(&self) -> bool {
        self.require_authorization_for_cache_control
    }
    /// <p>Indicates how to handle unauthorized requests for cache invalidation.</p>
    /// <p>Valid values: <code>FAIL_WITH_403</code> | <code>SUCCEED_WITH_RESPONSE_HEADER</code> | <code>SUCCEED_WITHOUT_RESPONSE_HEADER</code> </p>
    pub fn unauthorized_cache_control_header_strategy(&self) -> std::option::Option<&str> {
        self.unauthorized_cache_control_header_strategy.as_deref()
    }
    /// <p>The HTTP method. You can use an asterisk (*) as a wildcard to apply method settings to multiple methods.</p>
    pub fn http_method(&self) -> std::option::Option<&str> {
        self.http_method.as_deref()
    }
    /// <p>The resource path for this method. Forward slashes (/) are encoded as ~1 . The initial slash must include a forward slash.</p>
    /// <p>For example, the path value <code>/resource/subresource</code> must be encoded as <code>/~1resource~1subresource</code>.</p>
    /// <p>To specify the root path, use only a slash (/). You can use an asterisk (*) as a wildcard to apply method settings to multiple methods.</p>
    pub fn resource_path(&self) -> std::option::Option<&str> {
        self.resource_path.as_deref()
    }
}
impl std::fmt::Debug for AwsApiGatewayMethodSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsApiGatewayMethodSettings");
        formatter.field("metrics_enabled", &self.metrics_enabled);
        formatter.field("logging_level", &self.logging_level);
        formatter.field("data_trace_enabled", &self.data_trace_enabled);
        formatter.field("throttling_burst_limit", &self.throttling_burst_limit);
        formatter.field("throttling_rate_limit", &self.throttling_rate_limit);
        formatter.field("caching_enabled", &self.caching_enabled);
        formatter.field("cache_ttl_in_seconds", &self.cache_ttl_in_seconds);
        formatter.field("cache_data_encrypted", &self.cache_data_encrypted);
        formatter.field(
            "require_authorization_for_cache_control",
            &self.require_authorization_for_cache_control,
        );
        formatter.field(
            "unauthorized_cache_control_header_strategy",
            &self.unauthorized_cache_control_header_strategy,
        );
        formatter.field("http_method", &self.http_method);
        formatter.field("resource_path", &self.resource_path);
        formatter.finish()
    }
}
/// See [`AwsApiGatewayMethodSettings`](crate::model::AwsApiGatewayMethodSettings)
pub mod aws_api_gateway_method_settings {

    /// A builder for [`AwsApiGatewayMethodSettings`](crate::model::AwsApiGatewayMethodSettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metrics_enabled: std::option::Option<bool>,
        pub(crate) logging_level: std::option::Option<std::string::String>,
        pub(crate) data_trace_enabled: std::option::Option<bool>,
        pub(crate) throttling_burst_limit: std::option::Option<i32>,
        pub(crate) throttling_rate_limit: std::option::Option<f64>,
        pub(crate) caching_enabled: std::option::Option<bool>,
        pub(crate) cache_ttl_in_seconds: std::option::Option<i32>,
        pub(crate) cache_data_encrypted: std::option::Option<bool>,
        pub(crate) require_authorization_for_cache_control: std::option::Option<bool>,
        pub(crate) unauthorized_cache_control_header_strategy:
            std::option::Option<std::string::String>,
        pub(crate) http_method: std::option::Option<std::string::String>,
        pub(crate) resource_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates whether CloudWatch metrics are enabled for the method. </p>
        pub fn metrics_enabled(mut self, input: bool) -> Self {
            self.metrics_enabled = Some(input);
            self
        }
        /// <p>Indicates whether CloudWatch metrics are enabled for the method. </p>
        pub fn set_metrics_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.metrics_enabled = input;
            self
        }
        /// <p>The logging level for this method. The logging level affects the log entries that are pushed to CloudWatch Logs.</p>
        /// <p>If the logging level is <code>ERROR</code>, then the logs only include error-level entries.</p>
        /// <p>If the logging level is <code>INFO</code>, then the logs include both <code>ERROR</code> events and extra informational events.</p>
        /// <p>Valid values: <code>OFF</code> | <code>ERROR</code> | <code>INFO</code> </p>
        pub fn logging_level(mut self, input: impl Into<std::string::String>) -> Self {
            self.logging_level = Some(input.into());
            self
        }
        /// <p>The logging level for this method. The logging level affects the log entries that are pushed to CloudWatch Logs.</p>
        /// <p>If the logging level is <code>ERROR</code>, then the logs only include error-level entries.</p>
        /// <p>If the logging level is <code>INFO</code>, then the logs include both <code>ERROR</code> events and extra informational events.</p>
        /// <p>Valid values: <code>OFF</code> | <code>ERROR</code> | <code>INFO</code> </p>
        pub fn set_logging_level(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.logging_level = input;
            self
        }
        /// <p>Indicates whether data trace logging is enabled for the method. Data trace logging affects the log entries that are pushed to CloudWatch Logs.</p>
        pub fn data_trace_enabled(mut self, input: bool) -> Self {
            self.data_trace_enabled = Some(input);
            self
        }
        /// <p>Indicates whether data trace logging is enabled for the method. Data trace logging affects the log entries that are pushed to CloudWatch Logs.</p>
        pub fn set_data_trace_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.data_trace_enabled = input;
            self
        }
        /// <p>The throttling burst limit for the method.</p>
        pub fn throttling_burst_limit(mut self, input: i32) -> Self {
            self.throttling_burst_limit = Some(input);
            self
        }
        /// <p>The throttling burst limit for the method.</p>
        pub fn set_throttling_burst_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.throttling_burst_limit = input;
            self
        }
        /// <p>The throttling rate limit for the method.</p>
        pub fn throttling_rate_limit(mut self, input: f64) -> Self {
            self.throttling_rate_limit = Some(input);
            self
        }
        /// <p>The throttling rate limit for the method.</p>
        pub fn set_throttling_rate_limit(mut self, input: std::option::Option<f64>) -> Self {
            self.throttling_rate_limit = input;
            self
        }
        /// <p>Indicates whether responses are cached and returned for requests. For responses to be cached, a cache cluster must be enabled on the stage.</p>
        pub fn caching_enabled(mut self, input: bool) -> Self {
            self.caching_enabled = Some(input);
            self
        }
        /// <p>Indicates whether responses are cached and returned for requests. For responses to be cached, a cache cluster must be enabled on the stage.</p>
        pub fn set_caching_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.caching_enabled = input;
            self
        }
        /// <p>Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response is cached.</p>
        pub fn cache_ttl_in_seconds(mut self, input: i32) -> Self {
            self.cache_ttl_in_seconds = Some(input);
            self
        }
        /// <p>Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response is cached.</p>
        pub fn set_cache_ttl_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.cache_ttl_in_seconds = input;
            self
        }
        /// <p>Indicates whether the cached responses are encrypted. </p>
        pub fn cache_data_encrypted(mut self, input: bool) -> Self {
            self.cache_data_encrypted = Some(input);
            self
        }
        /// <p>Indicates whether the cached responses are encrypted. </p>
        pub fn set_cache_data_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.cache_data_encrypted = input;
            self
        }
        /// <p>Indicates whether authorization is required for a cache invalidation request.</p>
        pub fn require_authorization_for_cache_control(mut self, input: bool) -> Self {
            self.require_authorization_for_cache_control = Some(input);
            self
        }
        /// <p>Indicates whether authorization is required for a cache invalidation request.</p>
        pub fn set_require_authorization_for_cache_control(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.require_authorization_for_cache_control = input;
            self
        }
        /// <p>Indicates how to handle unauthorized requests for cache invalidation.</p>
        /// <p>Valid values: <code>FAIL_WITH_403</code> | <code>SUCCEED_WITH_RESPONSE_HEADER</code> | <code>SUCCEED_WITHOUT_RESPONSE_HEADER</code> </p>
        pub fn unauthorized_cache_control_header_strategy(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.unauthorized_cache_control_header_strategy = Some(input.into());
            self
        }
        /// <p>Indicates how to handle unauthorized requests for cache invalidation.</p>
        /// <p>Valid values: <code>FAIL_WITH_403</code> | <code>SUCCEED_WITH_RESPONSE_HEADER</code> | <code>SUCCEED_WITHOUT_RESPONSE_HEADER</code> </p>
        pub fn set_unauthorized_cache_control_header_strategy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.unauthorized_cache_control_header_strategy = input;
            self
        }
        /// <p>The HTTP method. You can use an asterisk (*) as a wildcard to apply method settings to multiple methods.</p>
        pub fn http_method(mut self, input: impl Into<std::string::String>) -> Self {
            self.http_method = Some(input.into());
            self
        }
        /// <p>The HTTP method. You can use an asterisk (*) as a wildcard to apply method settings to multiple methods.</p>
        pub fn set_http_method(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.http_method = input;
            self
        }
        /// <p>The resource path for this method. Forward slashes (/) are encoded as ~1 . The initial slash must include a forward slash.</p>
        /// <p>For example, the path value <code>/resource/subresource</code> must be encoded as <code>/~1resource~1subresource</code>.</p>
        /// <p>To specify the root path, use only a slash (/). You can use an asterisk (*) as a wildcard to apply method settings to multiple methods.</p>
        pub fn resource_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_path = Some(input.into());
            self
        }
        /// <p>The resource path for this method. Forward slashes (/) are encoded as ~1 . The initial slash must include a forward slash.</p>
        /// <p>For example, the path value <code>/resource/subresource</code> must be encoded as <code>/~1resource~1subresource</code>.</p>
        /// <p>To specify the root path, use only a slash (/). You can use an asterisk (*) as a wildcard to apply method settings to multiple methods.</p>
        pub fn set_resource_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_path = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsApiGatewayMethodSettings`](crate::model::AwsApiGatewayMethodSettings)
        pub fn build(self) -> crate::model::AwsApiGatewayMethodSettings {
            crate::model::AwsApiGatewayMethodSettings {
                metrics_enabled: self.metrics_enabled.unwrap_or_default(),
                logging_level: self.logging_level,
                data_trace_enabled: self.data_trace_enabled.unwrap_or_default(),
                throttling_burst_limit: self.throttling_burst_limit.unwrap_or_default(),
                throttling_rate_limit: self.throttling_rate_limit.unwrap_or_default(),
                caching_enabled: self.caching_enabled.unwrap_or_default(),
                cache_ttl_in_seconds: self.cache_ttl_in_seconds.unwrap_or_default(),
                cache_data_encrypted: self.cache_data_encrypted.unwrap_or_default(),
                require_authorization_for_cache_control: self
                    .require_authorization_for_cache_control
                    .unwrap_or_default(),
                unauthorized_cache_control_header_strategy: self
                    .unauthorized_cache_control_header_strategy,
                http_method: self.http_method,
                resource_path: self.resource_path,
            }
        }
    }
}
impl AwsApiGatewayMethodSettings {
    /// Creates a new builder-style object to manufacture [`AwsApiGatewayMethodSettings`](crate::model::AwsApiGatewayMethodSettings)
    pub fn builder() -> crate::model::aws_api_gateway_method_settings::Builder {
        crate::model::aws_api_gateway_method_settings::Builder::default()
    }
}

/// <p>Provides details about a DynamoDB table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsDynamoDbTableDetails {
    /// <p>A list of attribute definitions for the table.</p>
    pub attribute_definitions:
        std::option::Option<std::vec::Vec<crate::model::AwsDynamoDbTableAttributeDefinition>>,
    /// <p>Information about the billing for read/write capacity on the table.</p>
    pub billing_mode_summary: std::option::Option<crate::model::AwsDynamoDbTableBillingModeSummary>,
    /// <p>Indicates when the table was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub creation_date_time: std::option::Option<std::string::String>,
    /// <p>List of global secondary indexes for the table.</p>
    pub global_secondary_indexes:
        std::option::Option<std::vec::Vec<crate::model::AwsDynamoDbTableGlobalSecondaryIndex>>,
    /// <p>The version of global tables being used.</p>
    pub global_table_version: std::option::Option<std::string::String>,
    /// <p>The number of items in the table.</p>
    pub item_count: i32,
    /// <p>The primary key structure for the table.</p>
    pub key_schema: std::option::Option<std::vec::Vec<crate::model::AwsDynamoDbTableKeySchema>>,
    /// <p>The ARN of the latest stream for the table.</p>
    pub latest_stream_arn: std::option::Option<std::string::String>,
    /// <p>The label of the latest stream. The label is not a unique identifier.</p>
    pub latest_stream_label: std::option::Option<std::string::String>,
    /// <p>The list of local secondary indexes for the table.</p>
    pub local_secondary_indexes:
        std::option::Option<std::vec::Vec<crate::model::AwsDynamoDbTableLocalSecondaryIndex>>,
    /// <p>Information about the provisioned throughput for the table.</p>
    pub provisioned_throughput:
        std::option::Option<crate::model::AwsDynamoDbTableProvisionedThroughput>,
    /// <p>The list of replicas of this table.</p>
    pub replicas: std::option::Option<std::vec::Vec<crate::model::AwsDynamoDbTableReplica>>,
    /// <p>Information about the restore for the table.</p>
    pub restore_summary: std::option::Option<crate::model::AwsDynamoDbTableRestoreSummary>,
    /// <p>Information about the server-side encryption for the table.</p>
    pub sse_description: std::option::Option<crate::model::AwsDynamoDbTableSseDescription>,
    /// <p>The current DynamoDB Streams configuration for the table.</p>
    pub stream_specification:
        std::option::Option<crate::model::AwsDynamoDbTableStreamSpecification>,
    /// <p>The identifier of the table.</p>
    pub table_id: std::option::Option<std::string::String>,
    /// <p>The name of the table.</p>
    pub table_name: std::option::Option<std::string::String>,
    /// <p>The total size of the table in bytes.</p>
    pub table_size_bytes: i64,
    /// <p>The current status of the table.</p>
    pub table_status: std::option::Option<std::string::String>,
}
impl AwsDynamoDbTableDetails {
    /// <p>A list of attribute definitions for the table.</p>
    pub fn attribute_definitions(
        &self,
    ) -> std::option::Option<&[crate::model::AwsDynamoDbTableAttributeDefinition]> {
        self.attribute_definitions.as_deref()
    }
    /// <p>Information about the billing for read/write capacity on the table.</p>
    pub fn billing_mode_summary(
        &self,
    ) -> std::option::Option<&crate::model::AwsDynamoDbTableBillingModeSummary> {
        self.billing_mode_summary.as_ref()
    }
    /// <p>Indicates when the table was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn creation_date_time(&self) -> std::option::Option<&str> {
        self.creation_date_time.as_deref()
    }
    /// <p>List of global secondary indexes for the table.</p>
    pub fn global_secondary_indexes(
        &self,
    ) -> std::option::Option<&[crate::model::AwsDynamoDbTableGlobalSecondaryIndex]> {
        self.global_secondary_indexes.as_deref()
    }
    /// <p>The version of global tables being used.</p>
    pub fn global_table_version(&self) -> std::option::Option<&str> {
        self.global_table_version.as_deref()
    }
    /// <p>The number of items in the table.</p>
    pub fn item_count(&self) -> i32 {
        self.item_count
    }
    /// <p>The primary key structure for the table.</p>
    pub fn key_schema(&self) -> std::option::Option<&[crate::model::AwsDynamoDbTableKeySchema]> {
        self.key_schema.as_deref()
    }
    /// <p>The ARN of the latest stream for the table.</p>
    pub fn latest_stream_arn(&self) -> std::option::Option<&str> {
        self.latest_stream_arn.as_deref()
    }
    /// <p>The label of the latest stream. The label is not a unique identifier.</p>
    pub fn latest_stream_label(&self) -> std::option::Option<&str> {
        self.latest_stream_label.as_deref()
    }
    /// <p>The list of local secondary indexes for the table.</p>
    pub fn local_secondary_indexes(
        &self,
    ) -> std::option::Option<&[crate::model::AwsDynamoDbTableLocalSecondaryIndex]> {
        self.local_secondary_indexes.as_deref()
    }
    /// <p>Information about the provisioned throughput for the table.</p>
    pub fn provisioned_throughput(
        &self,
    ) -> std::option::Option<&crate::model::AwsDynamoDbTableProvisionedThroughput> {
        self.provisioned_throughput.as_ref()
    }
    /// <p>The list of replicas of this table.</p>
    pub fn replicas(&self) -> std::option::Option<&[crate::model::AwsDynamoDbTableReplica]> {
        self.replicas.as_deref()
    }
    /// <p>Information about the restore for the table.</p>
    pub fn restore_summary(
        &self,
    ) -> std::option::Option<&crate::model::AwsDynamoDbTableRestoreSummary> {
        self.restore_summary.as_ref()
    }
    /// <p>Information about the server-side encryption for the table.</p>
    pub fn sse_description(
        &self,
    ) -> std::option::Option<&crate::model::AwsDynamoDbTableSseDescription> {
        self.sse_description.as_ref()
    }
    /// <p>The current DynamoDB Streams configuration for the table.</p>
    pub fn stream_specification(
        &self,
    ) -> std::option::Option<&crate::model::AwsDynamoDbTableStreamSpecification> {
        self.stream_specification.as_ref()
    }
    /// <p>The identifier of the table.</p>
    pub fn table_id(&self) -> std::option::Option<&str> {
        self.table_id.as_deref()
    }
    /// <p>The name of the table.</p>
    pub fn table_name(&self) -> std::option::Option<&str> {
        self.table_name.as_deref()
    }
    /// <p>The total size of the table in bytes.</p>
    pub fn table_size_bytes(&self) -> i64 {
        self.table_size_bytes
    }
    /// <p>The current status of the table.</p>
    pub fn table_status(&self) -> std::option::Option<&str> {
        self.table_status.as_deref()
    }
}
impl std::fmt::Debug for AwsDynamoDbTableDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsDynamoDbTableDetails");
        formatter.field("attribute_definitions", &self.attribute_definitions);
        formatter.field("billing_mode_summary", &self.billing_mode_summary);
        formatter.field("creation_date_time", &self.creation_date_time);
        formatter.field("global_secondary_indexes", &self.global_secondary_indexes);
        formatter.field("global_table_version", &self.global_table_version);
        formatter.field("item_count", &self.item_count);
        formatter.field("key_schema", &self.key_schema);
        formatter.field("latest_stream_arn", &self.latest_stream_arn);
        formatter.field("latest_stream_label", &self.latest_stream_label);
        formatter.field("local_secondary_indexes", &self.local_secondary_indexes);
        formatter.field("provisioned_throughput", &self.provisioned_throughput);
        formatter.field("replicas", &self.replicas);
        formatter.field("restore_summary", &self.restore_summary);
        formatter.field("sse_description", &self.sse_description);
        formatter.field("stream_specification", &self.stream_specification);
        formatter.field("table_id", &self.table_id);
        formatter.field("table_name", &self.table_name);
        formatter.field("table_size_bytes", &self.table_size_bytes);
        formatter.field("table_status", &self.table_status);
        formatter.finish()
    }
}
/// See [`AwsDynamoDbTableDetails`](crate::model::AwsDynamoDbTableDetails)
pub mod aws_dynamo_db_table_details {

    /// A builder for [`AwsDynamoDbTableDetails`](crate::model::AwsDynamoDbTableDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute_definitions:
            std::option::Option<std::vec::Vec<crate::model::AwsDynamoDbTableAttributeDefinition>>,
        pub(crate) billing_mode_summary:
            std::option::Option<crate::model::AwsDynamoDbTableBillingModeSummary>,
        pub(crate) creation_date_time: std::option::Option<std::string::String>,
        pub(crate) global_secondary_indexes:
            std::option::Option<std::vec::Vec<crate::model::AwsDynamoDbTableGlobalSecondaryIndex>>,
        pub(crate) global_table_version: std::option::Option<std::string::String>,
        pub(crate) item_count: std::option::Option<i32>,
        pub(crate) key_schema:
            std::option::Option<std::vec::Vec<crate::model::AwsDynamoDbTableKeySchema>>,
        pub(crate) latest_stream_arn: std::option::Option<std::string::String>,
        pub(crate) latest_stream_label: std::option::Option<std::string::String>,
        pub(crate) local_secondary_indexes:
            std::option::Option<std::vec::Vec<crate::model::AwsDynamoDbTableLocalSecondaryIndex>>,
        pub(crate) provisioned_throughput:
            std::option::Option<crate::model::AwsDynamoDbTableProvisionedThroughput>,
        pub(crate) replicas:
            std::option::Option<std::vec::Vec<crate::model::AwsDynamoDbTableReplica>>,
        pub(crate) restore_summary:
            std::option::Option<crate::model::AwsDynamoDbTableRestoreSummary>,
        pub(crate) sse_description:
            std::option::Option<crate::model::AwsDynamoDbTableSseDescription>,
        pub(crate) stream_specification:
            std::option::Option<crate::model::AwsDynamoDbTableStreamSpecification>,
        pub(crate) table_id: std::option::Option<std::string::String>,
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) table_size_bytes: std::option::Option<i64>,
        pub(crate) table_status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `attribute_definitions`.
        ///
        /// To override the contents of this collection use [`set_attribute_definitions`](Self::set_attribute_definitions).
        ///
        /// <p>A list of attribute definitions for the table.</p>
        pub fn attribute_definitions(
            mut self,
            input: crate::model::AwsDynamoDbTableAttributeDefinition,
        ) -> Self {
            let mut v = self.attribute_definitions.unwrap_or_default();
            v.push(input);
            self.attribute_definitions = Some(v);
            self
        }
        /// <p>A list of attribute definitions for the table.</p>
        pub fn set_attribute_definitions(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsDynamoDbTableAttributeDefinition>,
            >,
        ) -> Self {
            self.attribute_definitions = input;
            self
        }
        /// <p>Information about the billing for read/write capacity on the table.</p>
        pub fn billing_mode_summary(
            mut self,
            input: crate::model::AwsDynamoDbTableBillingModeSummary,
        ) -> Self {
            self.billing_mode_summary = Some(input);
            self
        }
        /// <p>Information about the billing for read/write capacity on the table.</p>
        pub fn set_billing_mode_summary(
            mut self,
            input: std::option::Option<crate::model::AwsDynamoDbTableBillingModeSummary>,
        ) -> Self {
            self.billing_mode_summary = input;
            self
        }
        /// <p>Indicates when the table was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn creation_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date_time = Some(input.into());
            self
        }
        /// <p>Indicates when the table was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_creation_date_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date_time = input;
            self
        }
        /// Appends an item to `global_secondary_indexes`.
        ///
        /// To override the contents of this collection use [`set_global_secondary_indexes`](Self::set_global_secondary_indexes).
        ///
        /// <p>List of global secondary indexes for the table.</p>
        pub fn global_secondary_indexes(
            mut self,
            input: crate::model::AwsDynamoDbTableGlobalSecondaryIndex,
        ) -> Self {
            let mut v = self.global_secondary_indexes.unwrap_or_default();
            v.push(input);
            self.global_secondary_indexes = Some(v);
            self
        }
        /// <p>List of global secondary indexes for the table.</p>
        pub fn set_global_secondary_indexes(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsDynamoDbTableGlobalSecondaryIndex>,
            >,
        ) -> Self {
            self.global_secondary_indexes = input;
            self
        }
        /// <p>The version of global tables being used.</p>
        pub fn global_table_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_table_version = Some(input.into());
            self
        }
        /// <p>The version of global tables being used.</p>
        pub fn set_global_table_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_table_version = input;
            self
        }
        /// <p>The number of items in the table.</p>
        pub fn item_count(mut self, input: i32) -> Self {
            self.item_count = Some(input);
            self
        }
        /// <p>The number of items in the table.</p>
        pub fn set_item_count(mut self, input: std::option::Option<i32>) -> Self {
            self.item_count = input;
            self
        }
        /// Appends an item to `key_schema`.
        ///
        /// To override the contents of this collection use [`set_key_schema`](Self::set_key_schema).
        ///
        /// <p>The primary key structure for the table.</p>
        pub fn key_schema(mut self, input: crate::model::AwsDynamoDbTableKeySchema) -> Self {
            let mut v = self.key_schema.unwrap_or_default();
            v.push(input);
            self.key_schema = Some(v);
            self
        }
        /// <p>The primary key structure for the table.</p>
        pub fn set_key_schema(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsDynamoDbTableKeySchema>>,
        ) -> Self {
            self.key_schema = input;
            self
        }
        /// <p>The ARN of the latest stream for the table.</p>
        pub fn latest_stream_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.latest_stream_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the latest stream for the table.</p>
        pub fn set_latest_stream_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.latest_stream_arn = input;
            self
        }
        /// <p>The label of the latest stream. The label is not a unique identifier.</p>
        pub fn latest_stream_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.latest_stream_label = Some(input.into());
            self
        }
        /// <p>The label of the latest stream. The label is not a unique identifier.</p>
        pub fn set_latest_stream_label(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.latest_stream_label = input;
            self
        }
        /// Appends an item to `local_secondary_indexes`.
        ///
        /// To override the contents of this collection use [`set_local_secondary_indexes`](Self::set_local_secondary_indexes).
        ///
        /// <p>The list of local secondary indexes for the table.</p>
        pub fn local_secondary_indexes(
            mut self,
            input: crate::model::AwsDynamoDbTableLocalSecondaryIndex,
        ) -> Self {
            let mut v = self.local_secondary_indexes.unwrap_or_default();
            v.push(input);
            self.local_secondary_indexes = Some(v);
            self
        }
        /// <p>The list of local secondary indexes for the table.</p>
        pub fn set_local_secondary_indexes(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsDynamoDbTableLocalSecondaryIndex>,
            >,
        ) -> Self {
            self.local_secondary_indexes = input;
            self
        }
        /// <p>Information about the provisioned throughput for the table.</p>
        pub fn provisioned_throughput(
            mut self,
            input: crate::model::AwsDynamoDbTableProvisionedThroughput,
        ) -> Self {
            self.provisioned_throughput = Some(input);
            self
        }
        /// <p>Information about the provisioned throughput for the table.</p>
        pub fn set_provisioned_throughput(
            mut self,
            input: std::option::Option<crate::model::AwsDynamoDbTableProvisionedThroughput>,
        ) -> Self {
            self.provisioned_throughput = input;
            self
        }
        /// Appends an item to `replicas`.
        ///
        /// To override the contents of this collection use [`set_replicas`](Self::set_replicas).
        ///
        /// <p>The list of replicas of this table.</p>
        pub fn replicas(mut self, input: crate::model::AwsDynamoDbTableReplica) -> Self {
            let mut v = self.replicas.unwrap_or_default();
            v.push(input);
            self.replicas = Some(v);
            self
        }
        /// <p>The list of replicas of this table.</p>
        pub fn set_replicas(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsDynamoDbTableReplica>>,
        ) -> Self {
            self.replicas = input;
            self
        }
        /// <p>Information about the restore for the table.</p>
        pub fn restore_summary(
            mut self,
            input: crate::model::AwsDynamoDbTableRestoreSummary,
        ) -> Self {
            self.restore_summary = Some(input);
            self
        }
        /// <p>Information about the restore for the table.</p>
        pub fn set_restore_summary(
            mut self,
            input: std::option::Option<crate::model::AwsDynamoDbTableRestoreSummary>,
        ) -> Self {
            self.restore_summary = input;
            self
        }
        /// <p>Information about the server-side encryption for the table.</p>
        pub fn sse_description(
            mut self,
            input: crate::model::AwsDynamoDbTableSseDescription,
        ) -> Self {
            self.sse_description = Some(input);
            self
        }
        /// <p>Information about the server-side encryption for the table.</p>
        pub fn set_sse_description(
            mut self,
            input: std::option::Option<crate::model::AwsDynamoDbTableSseDescription>,
        ) -> Self {
            self.sse_description = input;
            self
        }
        /// <p>The current DynamoDB Streams configuration for the table.</p>
        pub fn stream_specification(
            mut self,
            input: crate::model::AwsDynamoDbTableStreamSpecification,
        ) -> Self {
            self.stream_specification = Some(input);
            self
        }
        /// <p>The current DynamoDB Streams configuration for the table.</p>
        pub fn set_stream_specification(
            mut self,
            input: std::option::Option<crate::model::AwsDynamoDbTableStreamSpecification>,
        ) -> Self {
            self.stream_specification = input;
            self
        }
        /// <p>The identifier of the table.</p>
        pub fn table_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_id = Some(input.into());
            self
        }
        /// <p>The identifier of the table.</p>
        pub fn set_table_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table_id = input;
            self
        }
        /// <p>The name of the table.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_name = Some(input.into());
            self
        }
        /// <p>The name of the table.</p>
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table_name = input;
            self
        }
        /// <p>The total size of the table in bytes.</p>
        pub fn table_size_bytes(mut self, input: i64) -> Self {
            self.table_size_bytes = Some(input);
            self
        }
        /// <p>The total size of the table in bytes.</p>
        pub fn set_table_size_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.table_size_bytes = input;
            self
        }
        /// <p>The current status of the table.</p>
        pub fn table_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_status = Some(input.into());
            self
        }
        /// <p>The current status of the table.</p>
        pub fn set_table_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table_status = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsDynamoDbTableDetails`](crate::model::AwsDynamoDbTableDetails)
        pub fn build(self) -> crate::model::AwsDynamoDbTableDetails {
            crate::model::AwsDynamoDbTableDetails {
                attribute_definitions: self.attribute_definitions,
                billing_mode_summary: self.billing_mode_summary,
                creation_date_time: self.creation_date_time,
                global_secondary_indexes: self.global_secondary_indexes,
                global_table_version: self.global_table_version,
                item_count: self.item_count.unwrap_or_default(),
                key_schema: self.key_schema,
                latest_stream_arn: self.latest_stream_arn,
                latest_stream_label: self.latest_stream_label,
                local_secondary_indexes: self.local_secondary_indexes,
                provisioned_throughput: self.provisioned_throughput,
                replicas: self.replicas,
                restore_summary: self.restore_summary,
                sse_description: self.sse_description,
                stream_specification: self.stream_specification,
                table_id: self.table_id,
                table_name: self.table_name,
                table_size_bytes: self.table_size_bytes.unwrap_or_default(),
                table_status: self.table_status,
            }
        }
    }
}
impl AwsDynamoDbTableDetails {
    /// Creates a new builder-style object to manufacture [`AwsDynamoDbTableDetails`](crate::model::AwsDynamoDbTableDetails)
    pub fn builder() -> crate::model::aws_dynamo_db_table_details::Builder {
        crate::model::aws_dynamo_db_table_details::Builder::default()
    }
}

/// <p>The current DynamoDB Streams configuration for the table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsDynamoDbTableStreamSpecification {
    /// <p>Indicates whether DynamoDB Streams is enabled on the table.</p>
    pub stream_enabled: bool,
    /// <p>Determines the information that is written to the table.</p>
    pub stream_view_type: std::option::Option<std::string::String>,
}
impl AwsDynamoDbTableStreamSpecification {
    /// <p>Indicates whether DynamoDB Streams is enabled on the table.</p>
    pub fn stream_enabled(&self) -> bool {
        self.stream_enabled
    }
    /// <p>Determines the information that is written to the table.</p>
    pub fn stream_view_type(&self) -> std::option::Option<&str> {
        self.stream_view_type.as_deref()
    }
}
impl std::fmt::Debug for AwsDynamoDbTableStreamSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsDynamoDbTableStreamSpecification");
        formatter.field("stream_enabled", &self.stream_enabled);
        formatter.field("stream_view_type", &self.stream_view_type);
        formatter.finish()
    }
}
/// See [`AwsDynamoDbTableStreamSpecification`](crate::model::AwsDynamoDbTableStreamSpecification)
pub mod aws_dynamo_db_table_stream_specification {

    /// A builder for [`AwsDynamoDbTableStreamSpecification`](crate::model::AwsDynamoDbTableStreamSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stream_enabled: std::option::Option<bool>,
        pub(crate) stream_view_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates whether DynamoDB Streams is enabled on the table.</p>
        pub fn stream_enabled(mut self, input: bool) -> Self {
            self.stream_enabled = Some(input);
            self
        }
        /// <p>Indicates whether DynamoDB Streams is enabled on the table.</p>
        pub fn set_stream_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.stream_enabled = input;
            self
        }
        /// <p>Determines the information that is written to the table.</p>
        pub fn stream_view_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_view_type = Some(input.into());
            self
        }
        /// <p>Determines the information that is written to the table.</p>
        pub fn set_stream_view_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.stream_view_type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsDynamoDbTableStreamSpecification`](crate::model::AwsDynamoDbTableStreamSpecification)
        pub fn build(self) -> crate::model::AwsDynamoDbTableStreamSpecification {
            crate::model::AwsDynamoDbTableStreamSpecification {
                stream_enabled: self.stream_enabled.unwrap_or_default(),
                stream_view_type: self.stream_view_type,
            }
        }
    }
}
impl AwsDynamoDbTableStreamSpecification {
    /// Creates a new builder-style object to manufacture [`AwsDynamoDbTableStreamSpecification`](crate::model::AwsDynamoDbTableStreamSpecification)
    pub fn builder() -> crate::model::aws_dynamo_db_table_stream_specification::Builder {
        crate::model::aws_dynamo_db_table_stream_specification::Builder::default()
    }
}

/// <p>Information about the server-side encryption for the table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsDynamoDbTableSseDescription {
    /// <p>If the key is inaccessible, the date and time when DynamoDB detected that the key was inaccessible.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub inaccessible_encryption_date_time: std::option::Option<std::string::String>,
    /// <p>The status of the server-side encryption.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>The type of server-side encryption.</p>
    pub sse_type: std::option::Option<std::string::String>,
    /// <p>The ARN of the KMS key that is used for the KMS encryption.</p>
    pub kms_master_key_arn: std::option::Option<std::string::String>,
}
impl AwsDynamoDbTableSseDescription {
    /// <p>If the key is inaccessible, the date and time when DynamoDB detected that the key was inaccessible.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn inaccessible_encryption_date_time(&self) -> std::option::Option<&str> {
        self.inaccessible_encryption_date_time.as_deref()
    }
    /// <p>The status of the server-side encryption.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>The type of server-side encryption.</p>
    pub fn sse_type(&self) -> std::option::Option<&str> {
        self.sse_type.as_deref()
    }
    /// <p>The ARN of the KMS key that is used for the KMS encryption.</p>
    pub fn kms_master_key_arn(&self) -> std::option::Option<&str> {
        self.kms_master_key_arn.as_deref()
    }
}
impl std::fmt::Debug for AwsDynamoDbTableSseDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsDynamoDbTableSseDescription");
        formatter.field(
            "inaccessible_encryption_date_time",
            &self.inaccessible_encryption_date_time,
        );
        formatter.field("status", &self.status);
        formatter.field("sse_type", &self.sse_type);
        formatter.field("kms_master_key_arn", &self.kms_master_key_arn);
        formatter.finish()
    }
}
/// See [`AwsDynamoDbTableSseDescription`](crate::model::AwsDynamoDbTableSseDescription)
pub mod aws_dynamo_db_table_sse_description {

    /// A builder for [`AwsDynamoDbTableSseDescription`](crate::model::AwsDynamoDbTableSseDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) inaccessible_encryption_date_time: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) sse_type: std::option::Option<std::string::String>,
        pub(crate) kms_master_key_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>If the key is inaccessible, the date and time when DynamoDB detected that the key was inaccessible.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn inaccessible_encryption_date_time(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inaccessible_encryption_date_time = Some(input.into());
            self
        }
        /// <p>If the key is inaccessible, the date and time when DynamoDB detected that the key was inaccessible.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_inaccessible_encryption_date_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inaccessible_encryption_date_time = input;
            self
        }
        /// <p>The status of the server-side encryption.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the server-side encryption.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>The type of server-side encryption.</p>
        pub fn sse_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_type = Some(input.into());
            self
        }
        /// <p>The type of server-side encryption.</p>
        pub fn set_sse_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sse_type = input;
            self
        }
        /// <p>The ARN of the KMS key that is used for the KMS encryption.</p>
        pub fn kms_master_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_master_key_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the KMS key that is used for the KMS encryption.</p>
        pub fn set_kms_master_key_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.kms_master_key_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsDynamoDbTableSseDescription`](crate::model::AwsDynamoDbTableSseDescription)
        pub fn build(self) -> crate::model::AwsDynamoDbTableSseDescription {
            crate::model::AwsDynamoDbTableSseDescription {
                inaccessible_encryption_date_time: self.inaccessible_encryption_date_time,
                status: self.status,
                sse_type: self.sse_type,
                kms_master_key_arn: self.kms_master_key_arn,
            }
        }
    }
}
impl AwsDynamoDbTableSseDescription {
    /// Creates a new builder-style object to manufacture [`AwsDynamoDbTableSseDescription`](crate::model::AwsDynamoDbTableSseDescription)
    pub fn builder() -> crate::model::aws_dynamo_db_table_sse_description::Builder {
        crate::model::aws_dynamo_db_table_sse_description::Builder::default()
    }
}

/// <p>Information about the restore for the table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsDynamoDbTableRestoreSummary {
    /// <p>The ARN of the source backup from which the table was restored.</p>
    pub source_backup_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the source table for the backup.</p>
    pub source_table_arn: std::option::Option<std::string::String>,
    /// <p>Indicates the point in time that the table was restored to.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub restore_date_time: std::option::Option<std::string::String>,
    /// <p>Whether a restore is currently in progress.</p>
    pub restore_in_progress: bool,
}
impl AwsDynamoDbTableRestoreSummary {
    /// <p>The ARN of the source backup from which the table was restored.</p>
    pub fn source_backup_arn(&self) -> std::option::Option<&str> {
        self.source_backup_arn.as_deref()
    }
    /// <p>The ARN of the source table for the backup.</p>
    pub fn source_table_arn(&self) -> std::option::Option<&str> {
        self.source_table_arn.as_deref()
    }
    /// <p>Indicates the point in time that the table was restored to.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn restore_date_time(&self) -> std::option::Option<&str> {
        self.restore_date_time.as_deref()
    }
    /// <p>Whether a restore is currently in progress.</p>
    pub fn restore_in_progress(&self) -> bool {
        self.restore_in_progress
    }
}
impl std::fmt::Debug for AwsDynamoDbTableRestoreSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsDynamoDbTableRestoreSummary");
        formatter.field("source_backup_arn", &self.source_backup_arn);
        formatter.field("source_table_arn", &self.source_table_arn);
        formatter.field("restore_date_time", &self.restore_date_time);
        formatter.field("restore_in_progress", &self.restore_in_progress);
        formatter.finish()
    }
}
/// See [`AwsDynamoDbTableRestoreSummary`](crate::model::AwsDynamoDbTableRestoreSummary)
pub mod aws_dynamo_db_table_restore_summary {

    /// A builder for [`AwsDynamoDbTableRestoreSummary`](crate::model::AwsDynamoDbTableRestoreSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_backup_arn: std::option::Option<std::string::String>,
        pub(crate) source_table_arn: std::option::Option<std::string::String>,
        pub(crate) restore_date_time: std::option::Option<std::string::String>,
        pub(crate) restore_in_progress: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The ARN of the source backup from which the table was restored.</p>
        pub fn source_backup_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_backup_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the source backup from which the table was restored.</p>
        pub fn set_source_backup_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_backup_arn = input;
            self
        }
        /// <p>The ARN of the source table for the backup.</p>
        pub fn source_table_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_table_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the source table for the backup.</p>
        pub fn set_source_table_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_table_arn = input;
            self
        }
        /// <p>Indicates the point in time that the table was restored to.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn restore_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.restore_date_time = Some(input.into());
            self
        }
        /// <p>Indicates the point in time that the table was restored to.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_restore_date_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.restore_date_time = input;
            self
        }
        /// <p>Whether a restore is currently in progress.</p>
        pub fn restore_in_progress(mut self, input: bool) -> Self {
            self.restore_in_progress = Some(input);
            self
        }
        /// <p>Whether a restore is currently in progress.</p>
        pub fn set_restore_in_progress(mut self, input: std::option::Option<bool>) -> Self {
            self.restore_in_progress = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsDynamoDbTableRestoreSummary`](crate::model::AwsDynamoDbTableRestoreSummary)
        pub fn build(self) -> crate::model::AwsDynamoDbTableRestoreSummary {
            crate::model::AwsDynamoDbTableRestoreSummary {
                source_backup_arn: self.source_backup_arn,
                source_table_arn: self.source_table_arn,
                restore_date_time: self.restore_date_time,
                restore_in_progress: self.restore_in_progress.unwrap_or_default(),
            }
        }
    }
}
impl AwsDynamoDbTableRestoreSummary {
    /// Creates a new builder-style object to manufacture [`AwsDynamoDbTableRestoreSummary`](crate::model::AwsDynamoDbTableRestoreSummary)
    pub fn builder() -> crate::model::aws_dynamo_db_table_restore_summary::Builder {
        crate::model::aws_dynamo_db_table_restore_summary::Builder::default()
    }
}

/// <p>Information about a replica of a DynamoDB table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsDynamoDbTableReplica {
    /// <p>List of global secondary indexes for the replica.</p>
    pub global_secondary_indexes: std::option::Option<
        std::vec::Vec<crate::model::AwsDynamoDbTableReplicaGlobalSecondaryIndex>,
    >,
    /// <p>The identifier of the KMS key that will be used for KMS encryption for the replica.</p>
    pub kms_master_key_id: std::option::Option<std::string::String>,
    /// <p>Replica-specific configuration for the provisioned throughput.</p>
    pub provisioned_throughput_override:
        std::option::Option<crate::model::AwsDynamoDbTableProvisionedThroughputOverride>,
    /// <p>The name of the Region where the replica is located.</p>
    pub region_name: std::option::Option<std::string::String>,
    /// <p>The current status of the replica.</p>
    pub replica_status: std::option::Option<std::string::String>,
    /// <p>Detailed information about the replica status.</p>
    pub replica_status_description: std::option::Option<std::string::String>,
}
impl AwsDynamoDbTableReplica {
    /// <p>List of global secondary indexes for the replica.</p>
    pub fn global_secondary_indexes(
        &self,
    ) -> std::option::Option<&[crate::model::AwsDynamoDbTableReplicaGlobalSecondaryIndex]> {
        self.global_secondary_indexes.as_deref()
    }
    /// <p>The identifier of the KMS key that will be used for KMS encryption for the replica.</p>
    pub fn kms_master_key_id(&self) -> std::option::Option<&str> {
        self.kms_master_key_id.as_deref()
    }
    /// <p>Replica-specific configuration for the provisioned throughput.</p>
    pub fn provisioned_throughput_override(
        &self,
    ) -> std::option::Option<&crate::model::AwsDynamoDbTableProvisionedThroughputOverride> {
        self.provisioned_throughput_override.as_ref()
    }
    /// <p>The name of the Region where the replica is located.</p>
    pub fn region_name(&self) -> std::option::Option<&str> {
        self.region_name.as_deref()
    }
    /// <p>The current status of the replica.</p>
    pub fn replica_status(&self) -> std::option::Option<&str> {
        self.replica_status.as_deref()
    }
    /// <p>Detailed information about the replica status.</p>
    pub fn replica_status_description(&self) -> std::option::Option<&str> {
        self.replica_status_description.as_deref()
    }
}
impl std::fmt::Debug for AwsDynamoDbTableReplica {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsDynamoDbTableReplica");
        formatter.field("global_secondary_indexes", &self.global_secondary_indexes);
        formatter.field("kms_master_key_id", &self.kms_master_key_id);
        formatter.field(
            "provisioned_throughput_override",
            &self.provisioned_throughput_override,
        );
        formatter.field("region_name", &self.region_name);
        formatter.field("replica_status", &self.replica_status);
        formatter.field(
            "replica_status_description",
            &self.replica_status_description,
        );
        formatter.finish()
    }
}
/// See [`AwsDynamoDbTableReplica`](crate::model::AwsDynamoDbTableReplica)
pub mod aws_dynamo_db_table_replica {

    /// A builder for [`AwsDynamoDbTableReplica`](crate::model::AwsDynamoDbTableReplica)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_secondary_indexes: std::option::Option<
            std::vec::Vec<crate::model::AwsDynamoDbTableReplicaGlobalSecondaryIndex>,
        >,
        pub(crate) kms_master_key_id: std::option::Option<std::string::String>,
        pub(crate) provisioned_throughput_override:
            std::option::Option<crate::model::AwsDynamoDbTableProvisionedThroughputOverride>,
        pub(crate) region_name: std::option::Option<std::string::String>,
        pub(crate) replica_status: std::option::Option<std::string::String>,
        pub(crate) replica_status_description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `global_secondary_indexes`.
        ///
        /// To override the contents of this collection use [`set_global_secondary_indexes`](Self::set_global_secondary_indexes).
        ///
        /// <p>List of global secondary indexes for the replica.</p>
        pub fn global_secondary_indexes(
            mut self,
            input: crate::model::AwsDynamoDbTableReplicaGlobalSecondaryIndex,
        ) -> Self {
            let mut v = self.global_secondary_indexes.unwrap_or_default();
            v.push(input);
            self.global_secondary_indexes = Some(v);
            self
        }
        /// <p>List of global secondary indexes for the replica.</p>
        pub fn set_global_secondary_indexes(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsDynamoDbTableReplicaGlobalSecondaryIndex>,
            >,
        ) -> Self {
            self.global_secondary_indexes = input;
            self
        }
        /// <p>The identifier of the KMS key that will be used for KMS encryption for the replica.</p>
        pub fn kms_master_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_master_key_id = Some(input.into());
            self
        }
        /// <p>The identifier of the KMS key that will be used for KMS encryption for the replica.</p>
        pub fn set_kms_master_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.kms_master_key_id = input;
            self
        }
        /// <p>Replica-specific configuration for the provisioned throughput.</p>
        pub fn provisioned_throughput_override(
            mut self,
            input: crate::model::AwsDynamoDbTableProvisionedThroughputOverride,
        ) -> Self {
            self.provisioned_throughput_override = Some(input);
            self
        }
        /// <p>Replica-specific configuration for the provisioned throughput.</p>
        pub fn set_provisioned_throughput_override(
            mut self,
            input: std::option::Option<crate::model::AwsDynamoDbTableProvisionedThroughputOverride>,
        ) -> Self {
            self.provisioned_throughput_override = input;
            self
        }
        /// <p>The name of the Region where the replica is located.</p>
        pub fn region_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.region_name = Some(input.into());
            self
        }
        /// <p>The name of the Region where the replica is located.</p>
        pub fn set_region_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region_name = input;
            self
        }
        /// <p>The current status of the replica.</p>
        pub fn replica_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.replica_status = Some(input.into());
            self
        }
        /// <p>The current status of the replica.</p>
        pub fn set_replica_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.replica_status = input;
            self
        }
        /// <p>Detailed information about the replica status.</p>
        pub fn replica_status_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.replica_status_description = Some(input.into());
            self
        }
        /// <p>Detailed information about the replica status.</p>
        pub fn set_replica_status_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.replica_status_description = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsDynamoDbTableReplica`](crate::model::AwsDynamoDbTableReplica)
        pub fn build(self) -> crate::model::AwsDynamoDbTableReplica {
            crate::model::AwsDynamoDbTableReplica {
                global_secondary_indexes: self.global_secondary_indexes,
                kms_master_key_id: self.kms_master_key_id,
                provisioned_throughput_override: self.provisioned_throughput_override,
                region_name: self.region_name,
                replica_status: self.replica_status,
                replica_status_description: self.replica_status_description,
            }
        }
    }
}
impl AwsDynamoDbTableReplica {
    /// Creates a new builder-style object to manufacture [`AwsDynamoDbTableReplica`](crate::model::AwsDynamoDbTableReplica)
    pub fn builder() -> crate::model::aws_dynamo_db_table_replica::Builder {
        crate::model::aws_dynamo_db_table_replica::Builder::default()
    }
}

/// <p>Replica-specific configuration for the provisioned throughput.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsDynamoDbTableProvisionedThroughputOverride {
    /// <p>The read capacity units for the replica.</p>
    pub read_capacity_units: i32,
}
impl AwsDynamoDbTableProvisionedThroughputOverride {
    /// <p>The read capacity units for the replica.</p>
    pub fn read_capacity_units(&self) -> i32 {
        self.read_capacity_units
    }
}
impl std::fmt::Debug for AwsDynamoDbTableProvisionedThroughputOverride {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsDynamoDbTableProvisionedThroughputOverride");
        formatter.field("read_capacity_units", &self.read_capacity_units);
        formatter.finish()
    }
}
/// See [`AwsDynamoDbTableProvisionedThroughputOverride`](crate::model::AwsDynamoDbTableProvisionedThroughputOverride)
pub mod aws_dynamo_db_table_provisioned_throughput_override {

    /// A builder for [`AwsDynamoDbTableProvisionedThroughputOverride`](crate::model::AwsDynamoDbTableProvisionedThroughputOverride)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) read_capacity_units: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The read capacity units for the replica.</p>
        pub fn read_capacity_units(mut self, input: i32) -> Self {
            self.read_capacity_units = Some(input);
            self
        }
        /// <p>The read capacity units for the replica.</p>
        pub fn set_read_capacity_units(mut self, input: std::option::Option<i32>) -> Self {
            self.read_capacity_units = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsDynamoDbTableProvisionedThroughputOverride`](crate::model::AwsDynamoDbTableProvisionedThroughputOverride)
        pub fn build(self) -> crate::model::AwsDynamoDbTableProvisionedThroughputOverride {
            crate::model::AwsDynamoDbTableProvisionedThroughputOverride {
                read_capacity_units: self.read_capacity_units.unwrap_or_default(),
            }
        }
    }
}
impl AwsDynamoDbTableProvisionedThroughputOverride {
    /// Creates a new builder-style object to manufacture [`AwsDynamoDbTableProvisionedThroughputOverride`](crate::model::AwsDynamoDbTableProvisionedThroughputOverride)
    pub fn builder() -> crate::model::aws_dynamo_db_table_provisioned_throughput_override::Builder {
        crate::model::aws_dynamo_db_table_provisioned_throughput_override::Builder::default()
    }
}

/// <p>Information about a global secondary index for a DynamoDB table replica.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsDynamoDbTableReplicaGlobalSecondaryIndex {
    /// <p>The name of the index.</p>
    pub index_name: std::option::Option<std::string::String>,
    /// <p>Replica-specific configuration for the provisioned throughput for the index.</p>
    pub provisioned_throughput_override:
        std::option::Option<crate::model::AwsDynamoDbTableProvisionedThroughputOverride>,
}
impl AwsDynamoDbTableReplicaGlobalSecondaryIndex {
    /// <p>The name of the index.</p>
    pub fn index_name(&self) -> std::option::Option<&str> {
        self.index_name.as_deref()
    }
    /// <p>Replica-specific configuration for the provisioned throughput for the index.</p>
    pub fn provisioned_throughput_override(
        &self,
    ) -> std::option::Option<&crate::model::AwsDynamoDbTableProvisionedThroughputOverride> {
        self.provisioned_throughput_override.as_ref()
    }
}
impl std::fmt::Debug for AwsDynamoDbTableReplicaGlobalSecondaryIndex {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsDynamoDbTableReplicaGlobalSecondaryIndex");
        formatter.field("index_name", &self.index_name);
        formatter.field(
            "provisioned_throughput_override",
            &self.provisioned_throughput_override,
        );
        formatter.finish()
    }
}
/// See [`AwsDynamoDbTableReplicaGlobalSecondaryIndex`](crate::model::AwsDynamoDbTableReplicaGlobalSecondaryIndex)
pub mod aws_dynamo_db_table_replica_global_secondary_index {

    /// A builder for [`AwsDynamoDbTableReplicaGlobalSecondaryIndex`](crate::model::AwsDynamoDbTableReplicaGlobalSecondaryIndex)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) provisioned_throughput_override:
            std::option::Option<crate::model::AwsDynamoDbTableProvisionedThroughputOverride>,
    }
    impl Builder {
        /// <p>The name of the index.</p>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.index_name = Some(input.into());
            self
        }
        /// <p>The name of the index.</p>
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.index_name = input;
            self
        }
        /// <p>Replica-specific configuration for the provisioned throughput for the index.</p>
        pub fn provisioned_throughput_override(
            mut self,
            input: crate::model::AwsDynamoDbTableProvisionedThroughputOverride,
        ) -> Self {
            self.provisioned_throughput_override = Some(input);
            self
        }
        /// <p>Replica-specific configuration for the provisioned throughput for the index.</p>
        pub fn set_provisioned_throughput_override(
            mut self,
            input: std::option::Option<crate::model::AwsDynamoDbTableProvisionedThroughputOverride>,
        ) -> Self {
            self.provisioned_throughput_override = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsDynamoDbTableReplicaGlobalSecondaryIndex`](crate::model::AwsDynamoDbTableReplicaGlobalSecondaryIndex)
        pub fn build(self) -> crate::model::AwsDynamoDbTableReplicaGlobalSecondaryIndex {
            crate::model::AwsDynamoDbTableReplicaGlobalSecondaryIndex {
                index_name: self.index_name,
                provisioned_throughput_override: self.provisioned_throughput_override,
            }
        }
    }
}
impl AwsDynamoDbTableReplicaGlobalSecondaryIndex {
    /// Creates a new builder-style object to manufacture [`AwsDynamoDbTableReplicaGlobalSecondaryIndex`](crate::model::AwsDynamoDbTableReplicaGlobalSecondaryIndex)
    pub fn builder() -> crate::model::aws_dynamo_db_table_replica_global_secondary_index::Builder {
        crate::model::aws_dynamo_db_table_replica_global_secondary_index::Builder::default()
    }
}

/// <p>Information about the provisioned throughput for the table or for a global secondary index.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsDynamoDbTableProvisionedThroughput {
    /// <p>Indicates when the provisioned throughput was last decreased.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub last_decrease_date_time: std::option::Option<std::string::String>,
    /// <p>Indicates when the provisioned throughput was last increased.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub last_increase_date_time: std::option::Option<std::string::String>,
    /// <p>The number of times during the current UTC calendar day that the provisioned throughput was decreased.</p>
    pub number_of_decreases_today: i32,
    /// <p>The maximum number of strongly consistent reads consumed per second before DynamoDB returns a <code>ThrottlingException</code>.</p>
    pub read_capacity_units: i32,
    /// <p>The maximum number of writes consumed per second before DynamoDB returns a <code>ThrottlingException</code>.</p>
    pub write_capacity_units: i32,
}
impl AwsDynamoDbTableProvisionedThroughput {
    /// <p>Indicates when the provisioned throughput was last decreased.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn last_decrease_date_time(&self) -> std::option::Option<&str> {
        self.last_decrease_date_time.as_deref()
    }
    /// <p>Indicates when the provisioned throughput was last increased.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn last_increase_date_time(&self) -> std::option::Option<&str> {
        self.last_increase_date_time.as_deref()
    }
    /// <p>The number of times during the current UTC calendar day that the provisioned throughput was decreased.</p>
    pub fn number_of_decreases_today(&self) -> i32 {
        self.number_of_decreases_today
    }
    /// <p>The maximum number of strongly consistent reads consumed per second before DynamoDB returns a <code>ThrottlingException</code>.</p>
    pub fn read_capacity_units(&self) -> i32 {
        self.read_capacity_units
    }
    /// <p>The maximum number of writes consumed per second before DynamoDB returns a <code>ThrottlingException</code>.</p>
    pub fn write_capacity_units(&self) -> i32 {
        self.write_capacity_units
    }
}
impl std::fmt::Debug for AwsDynamoDbTableProvisionedThroughput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsDynamoDbTableProvisionedThroughput");
        formatter.field("last_decrease_date_time", &self.last_decrease_date_time);
        formatter.field("last_increase_date_time", &self.last_increase_date_time);
        formatter.field("number_of_decreases_today", &self.number_of_decreases_today);
        formatter.field("read_capacity_units", &self.read_capacity_units);
        formatter.field("write_capacity_units", &self.write_capacity_units);
        formatter.finish()
    }
}
/// See [`AwsDynamoDbTableProvisionedThroughput`](crate::model::AwsDynamoDbTableProvisionedThroughput)
pub mod aws_dynamo_db_table_provisioned_throughput {

    /// A builder for [`AwsDynamoDbTableProvisionedThroughput`](crate::model::AwsDynamoDbTableProvisionedThroughput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) last_decrease_date_time: std::option::Option<std::string::String>,
        pub(crate) last_increase_date_time: std::option::Option<std::string::String>,
        pub(crate) number_of_decreases_today: std::option::Option<i32>,
        pub(crate) read_capacity_units: std::option::Option<i32>,
        pub(crate) write_capacity_units: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Indicates when the provisioned throughput was last decreased.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn last_decrease_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_decrease_date_time = Some(input.into());
            self
        }
        /// <p>Indicates when the provisioned throughput was last decreased.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_last_decrease_date_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_decrease_date_time = input;
            self
        }
        /// <p>Indicates when the provisioned throughput was last increased.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn last_increase_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_increase_date_time = Some(input.into());
            self
        }
        /// <p>Indicates when the provisioned throughput was last increased.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_last_increase_date_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_increase_date_time = input;
            self
        }
        /// <p>The number of times during the current UTC calendar day that the provisioned throughput was decreased.</p>
        pub fn number_of_decreases_today(mut self, input: i32) -> Self {
            self.number_of_decreases_today = Some(input);
            self
        }
        /// <p>The number of times during the current UTC calendar day that the provisioned throughput was decreased.</p>
        pub fn set_number_of_decreases_today(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_decreases_today = input;
            self
        }
        /// <p>The maximum number of strongly consistent reads consumed per second before DynamoDB returns a <code>ThrottlingException</code>.</p>
        pub fn read_capacity_units(mut self, input: i32) -> Self {
            self.read_capacity_units = Some(input);
            self
        }
        /// <p>The maximum number of strongly consistent reads consumed per second before DynamoDB returns a <code>ThrottlingException</code>.</p>
        pub fn set_read_capacity_units(mut self, input: std::option::Option<i32>) -> Self {
            self.read_capacity_units = input;
            self
        }
        /// <p>The maximum number of writes consumed per second before DynamoDB returns a <code>ThrottlingException</code>.</p>
        pub fn write_capacity_units(mut self, input: i32) -> Self {
            self.write_capacity_units = Some(input);
            self
        }
        /// <p>The maximum number of writes consumed per second before DynamoDB returns a <code>ThrottlingException</code>.</p>
        pub fn set_write_capacity_units(mut self, input: std::option::Option<i32>) -> Self {
            self.write_capacity_units = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsDynamoDbTableProvisionedThroughput`](crate::model::AwsDynamoDbTableProvisionedThroughput)
        pub fn build(self) -> crate::model::AwsDynamoDbTableProvisionedThroughput {
            crate::model::AwsDynamoDbTableProvisionedThroughput {
                last_decrease_date_time: self.last_decrease_date_time,
                last_increase_date_time: self.last_increase_date_time,
                number_of_decreases_today: self.number_of_decreases_today.unwrap_or_default(),
                read_capacity_units: self.read_capacity_units.unwrap_or_default(),
                write_capacity_units: self.write_capacity_units.unwrap_or_default(),
            }
        }
    }
}
impl AwsDynamoDbTableProvisionedThroughput {
    /// Creates a new builder-style object to manufacture [`AwsDynamoDbTableProvisionedThroughput`](crate::model::AwsDynamoDbTableProvisionedThroughput)
    pub fn builder() -> crate::model::aws_dynamo_db_table_provisioned_throughput::Builder {
        crate::model::aws_dynamo_db_table_provisioned_throughput::Builder::default()
    }
}

/// <p>Information about a local secondary index for a DynamoDB table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsDynamoDbTableLocalSecondaryIndex {
    /// <p>The ARN of the index.</p>
    pub index_arn: std::option::Option<std::string::String>,
    /// <p>The name of the index.</p>
    pub index_name: std::option::Option<std::string::String>,
    /// <p>The complete key schema for the index.</p>
    pub key_schema: std::option::Option<std::vec::Vec<crate::model::AwsDynamoDbTableKeySchema>>,
    /// <p>Attributes that are copied from the table into the index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.</p>
    pub projection: std::option::Option<crate::model::AwsDynamoDbTableProjection>,
}
impl AwsDynamoDbTableLocalSecondaryIndex {
    /// <p>The ARN of the index.</p>
    pub fn index_arn(&self) -> std::option::Option<&str> {
        self.index_arn.as_deref()
    }
    /// <p>The name of the index.</p>
    pub fn index_name(&self) -> std::option::Option<&str> {
        self.index_name.as_deref()
    }
    /// <p>The complete key schema for the index.</p>
    pub fn key_schema(&self) -> std::option::Option<&[crate::model::AwsDynamoDbTableKeySchema]> {
        self.key_schema.as_deref()
    }
    /// <p>Attributes that are copied from the table into the index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.</p>
    pub fn projection(&self) -> std::option::Option<&crate::model::AwsDynamoDbTableProjection> {
        self.projection.as_ref()
    }
}
impl std::fmt::Debug for AwsDynamoDbTableLocalSecondaryIndex {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsDynamoDbTableLocalSecondaryIndex");
        formatter.field("index_arn", &self.index_arn);
        formatter.field("index_name", &self.index_name);
        formatter.field("key_schema", &self.key_schema);
        formatter.field("projection", &self.projection);
        formatter.finish()
    }
}
/// See [`AwsDynamoDbTableLocalSecondaryIndex`](crate::model::AwsDynamoDbTableLocalSecondaryIndex)
pub mod aws_dynamo_db_table_local_secondary_index {

    /// A builder for [`AwsDynamoDbTableLocalSecondaryIndex`](crate::model::AwsDynamoDbTableLocalSecondaryIndex)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_arn: std::option::Option<std::string::String>,
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) key_schema:
            std::option::Option<std::vec::Vec<crate::model::AwsDynamoDbTableKeySchema>>,
        pub(crate) projection: std::option::Option<crate::model::AwsDynamoDbTableProjection>,
    }
    impl Builder {
        /// <p>The ARN of the index.</p>
        pub fn index_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.index_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the index.</p>
        pub fn set_index_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.index_arn = input;
            self
        }
        /// <p>The name of the index.</p>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.index_name = Some(input.into());
            self
        }
        /// <p>The name of the index.</p>
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.index_name = input;
            self
        }
        /// Appends an item to `key_schema`.
        ///
        /// To override the contents of this collection use [`set_key_schema`](Self::set_key_schema).
        ///
        /// <p>The complete key schema for the index.</p>
        pub fn key_schema(mut self, input: crate::model::AwsDynamoDbTableKeySchema) -> Self {
            let mut v = self.key_schema.unwrap_or_default();
            v.push(input);
            self.key_schema = Some(v);
            self
        }
        /// <p>The complete key schema for the index.</p>
        pub fn set_key_schema(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsDynamoDbTableKeySchema>>,
        ) -> Self {
            self.key_schema = input;
            self
        }
        /// <p>Attributes that are copied from the table into the index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.</p>
        pub fn projection(mut self, input: crate::model::AwsDynamoDbTableProjection) -> Self {
            self.projection = Some(input);
            self
        }
        /// <p>Attributes that are copied from the table into the index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.</p>
        pub fn set_projection(
            mut self,
            input: std::option::Option<crate::model::AwsDynamoDbTableProjection>,
        ) -> Self {
            self.projection = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsDynamoDbTableLocalSecondaryIndex`](crate::model::AwsDynamoDbTableLocalSecondaryIndex)
        pub fn build(self) -> crate::model::AwsDynamoDbTableLocalSecondaryIndex {
            crate::model::AwsDynamoDbTableLocalSecondaryIndex {
                index_arn: self.index_arn,
                index_name: self.index_name,
                key_schema: self.key_schema,
                projection: self.projection,
            }
        }
    }
}
impl AwsDynamoDbTableLocalSecondaryIndex {
    /// Creates a new builder-style object to manufacture [`AwsDynamoDbTableLocalSecondaryIndex`](crate::model::AwsDynamoDbTableLocalSecondaryIndex)
    pub fn builder() -> crate::model::aws_dynamo_db_table_local_secondary_index::Builder {
        crate::model::aws_dynamo_db_table_local_secondary_index::Builder::default()
    }
}

/// <p>For global and local secondary indexes, identifies the attributes that are copied from the table into the index.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsDynamoDbTableProjection {
    /// <p>The nonkey attributes that are projected into the index. For each attribute, provide the attribute name.</p>
    pub non_key_attributes: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The types of attributes that are projected into the index.</p>
    pub projection_type: std::option::Option<std::string::String>,
}
impl AwsDynamoDbTableProjection {
    /// <p>The nonkey attributes that are projected into the index. For each attribute, provide the attribute name.</p>
    pub fn non_key_attributes(&self) -> std::option::Option<&[std::string::String]> {
        self.non_key_attributes.as_deref()
    }
    /// <p>The types of attributes that are projected into the index.</p>
    pub fn projection_type(&self) -> std::option::Option<&str> {
        self.projection_type.as_deref()
    }
}
impl std::fmt::Debug for AwsDynamoDbTableProjection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsDynamoDbTableProjection");
        formatter.field("non_key_attributes", &self.non_key_attributes);
        formatter.field("projection_type", &self.projection_type);
        formatter.finish()
    }
}
/// See [`AwsDynamoDbTableProjection`](crate::model::AwsDynamoDbTableProjection)
pub mod aws_dynamo_db_table_projection {

    /// A builder for [`AwsDynamoDbTableProjection`](crate::model::AwsDynamoDbTableProjection)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) non_key_attributes: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) projection_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `non_key_attributes`.
        ///
        /// To override the contents of this collection use [`set_non_key_attributes`](Self::set_non_key_attributes).
        ///
        /// <p>The nonkey attributes that are projected into the index. For each attribute, provide the attribute name.</p>
        pub fn non_key_attributes(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.non_key_attributes.unwrap_or_default();
            v.push(input.into());
            self.non_key_attributes = Some(v);
            self
        }
        /// <p>The nonkey attributes that are projected into the index. For each attribute, provide the attribute name.</p>
        pub fn set_non_key_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.non_key_attributes = input;
            self
        }
        /// <p>The types of attributes that are projected into the index.</p>
        pub fn projection_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.projection_type = Some(input.into());
            self
        }
        /// <p>The types of attributes that are projected into the index.</p>
        pub fn set_projection_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.projection_type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsDynamoDbTableProjection`](crate::model::AwsDynamoDbTableProjection)
        pub fn build(self) -> crate::model::AwsDynamoDbTableProjection {
            crate::model::AwsDynamoDbTableProjection {
                non_key_attributes: self.non_key_attributes,
                projection_type: self.projection_type,
            }
        }
    }
}
impl AwsDynamoDbTableProjection {
    /// Creates a new builder-style object to manufacture [`AwsDynamoDbTableProjection`](crate::model::AwsDynamoDbTableProjection)
    pub fn builder() -> crate::model::aws_dynamo_db_table_projection::Builder {
        crate::model::aws_dynamo_db_table_projection::Builder::default()
    }
}

/// <p>A component of the key schema for the DynamoDB table, a global secondary index, or a local secondary index.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsDynamoDbTableKeySchema {
    /// <p>The name of the key schema attribute.</p>
    pub attribute_name: std::option::Option<std::string::String>,
    /// <p>The type of key used for the key schema attribute.</p>
    pub key_type: std::option::Option<std::string::String>,
}
impl AwsDynamoDbTableKeySchema {
    /// <p>The name of the key schema attribute.</p>
    pub fn attribute_name(&self) -> std::option::Option<&str> {
        self.attribute_name.as_deref()
    }
    /// <p>The type of key used for the key schema attribute.</p>
    pub fn key_type(&self) -> std::option::Option<&str> {
        self.key_type.as_deref()
    }
}
impl std::fmt::Debug for AwsDynamoDbTableKeySchema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsDynamoDbTableKeySchema");
        formatter.field("attribute_name", &self.attribute_name);
        formatter.field("key_type", &self.key_type);
        formatter.finish()
    }
}
/// See [`AwsDynamoDbTableKeySchema`](crate::model::AwsDynamoDbTableKeySchema)
pub mod aws_dynamo_db_table_key_schema {

    /// A builder for [`AwsDynamoDbTableKeySchema`](crate::model::AwsDynamoDbTableKeySchema)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute_name: std::option::Option<std::string::String>,
        pub(crate) key_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the key schema attribute.</p>
        pub fn attribute_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.attribute_name = Some(input.into());
            self
        }
        /// <p>The name of the key schema attribute.</p>
        pub fn set_attribute_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attribute_name = input;
            self
        }
        /// <p>The type of key used for the key schema attribute.</p>
        pub fn key_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_type = Some(input.into());
            self
        }
        /// <p>The type of key used for the key schema attribute.</p>
        pub fn set_key_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsDynamoDbTableKeySchema`](crate::model::AwsDynamoDbTableKeySchema)
        pub fn build(self) -> crate::model::AwsDynamoDbTableKeySchema {
            crate::model::AwsDynamoDbTableKeySchema {
                attribute_name: self.attribute_name,
                key_type: self.key_type,
            }
        }
    }
}
impl AwsDynamoDbTableKeySchema {
    /// Creates a new builder-style object to manufacture [`AwsDynamoDbTableKeySchema`](crate::model::AwsDynamoDbTableKeySchema)
    pub fn builder() -> crate::model::aws_dynamo_db_table_key_schema::Builder {
        crate::model::aws_dynamo_db_table_key_schema::Builder::default()
    }
}

/// <p>Information abut a global secondary index for the table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsDynamoDbTableGlobalSecondaryIndex {
    /// <p>Whether the index is currently backfilling.</p>
    pub backfilling: bool,
    /// <p>The ARN of the index.</p>
    pub index_arn: std::option::Option<std::string::String>,
    /// <p>The name of the index.</p>
    pub index_name: std::option::Option<std::string::String>,
    /// <p>The total size in bytes of the index.</p>
    pub index_size_bytes: i64,
    /// <p>The current status of the index.</p>
    pub index_status: std::option::Option<std::string::String>,
    /// <p>The number of items in the index.</p>
    pub item_count: i32,
    /// <p>The key schema for the index.</p>
    pub key_schema: std::option::Option<std::vec::Vec<crate::model::AwsDynamoDbTableKeySchema>>,
    /// <p>Attributes that are copied from the table into an index.</p>
    pub projection: std::option::Option<crate::model::AwsDynamoDbTableProjection>,
    /// <p>Information about the provisioned throughput settings for the indexes.</p>
    pub provisioned_throughput:
        std::option::Option<crate::model::AwsDynamoDbTableProvisionedThroughput>,
}
impl AwsDynamoDbTableGlobalSecondaryIndex {
    /// <p>Whether the index is currently backfilling.</p>
    pub fn backfilling(&self) -> bool {
        self.backfilling
    }
    /// <p>The ARN of the index.</p>
    pub fn index_arn(&self) -> std::option::Option<&str> {
        self.index_arn.as_deref()
    }
    /// <p>The name of the index.</p>
    pub fn index_name(&self) -> std::option::Option<&str> {
        self.index_name.as_deref()
    }
    /// <p>The total size in bytes of the index.</p>
    pub fn index_size_bytes(&self) -> i64 {
        self.index_size_bytes
    }
    /// <p>The current status of the index.</p>
    pub fn index_status(&self) -> std::option::Option<&str> {
        self.index_status.as_deref()
    }
    /// <p>The number of items in the index.</p>
    pub fn item_count(&self) -> i32 {
        self.item_count
    }
    /// <p>The key schema for the index.</p>
    pub fn key_schema(&self) -> std::option::Option<&[crate::model::AwsDynamoDbTableKeySchema]> {
        self.key_schema.as_deref()
    }
    /// <p>Attributes that are copied from the table into an index.</p>
    pub fn projection(&self) -> std::option::Option<&crate::model::AwsDynamoDbTableProjection> {
        self.projection.as_ref()
    }
    /// <p>Information about the provisioned throughput settings for the indexes.</p>
    pub fn provisioned_throughput(
        &self,
    ) -> std::option::Option<&crate::model::AwsDynamoDbTableProvisionedThroughput> {
        self.provisioned_throughput.as_ref()
    }
}
impl std::fmt::Debug for AwsDynamoDbTableGlobalSecondaryIndex {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsDynamoDbTableGlobalSecondaryIndex");
        formatter.field("backfilling", &self.backfilling);
        formatter.field("index_arn", &self.index_arn);
        formatter.field("index_name", &self.index_name);
        formatter.field("index_size_bytes", &self.index_size_bytes);
        formatter.field("index_status", &self.index_status);
        formatter.field("item_count", &self.item_count);
        formatter.field("key_schema", &self.key_schema);
        formatter.field("projection", &self.projection);
        formatter.field("provisioned_throughput", &self.provisioned_throughput);
        formatter.finish()
    }
}
/// See [`AwsDynamoDbTableGlobalSecondaryIndex`](crate::model::AwsDynamoDbTableGlobalSecondaryIndex)
pub mod aws_dynamo_db_table_global_secondary_index {

    /// A builder for [`AwsDynamoDbTableGlobalSecondaryIndex`](crate::model::AwsDynamoDbTableGlobalSecondaryIndex)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backfilling: std::option::Option<bool>,
        pub(crate) index_arn: std::option::Option<std::string::String>,
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) index_size_bytes: std::option::Option<i64>,
        pub(crate) index_status: std::option::Option<std::string::String>,
        pub(crate) item_count: std::option::Option<i32>,
        pub(crate) key_schema:
            std::option::Option<std::vec::Vec<crate::model::AwsDynamoDbTableKeySchema>>,
        pub(crate) projection: std::option::Option<crate::model::AwsDynamoDbTableProjection>,
        pub(crate) provisioned_throughput:
            std::option::Option<crate::model::AwsDynamoDbTableProvisionedThroughput>,
    }
    impl Builder {
        /// <p>Whether the index is currently backfilling.</p>
        pub fn backfilling(mut self, input: bool) -> Self {
            self.backfilling = Some(input);
            self
        }
        /// <p>Whether the index is currently backfilling.</p>
        pub fn set_backfilling(mut self, input: std::option::Option<bool>) -> Self {
            self.backfilling = input;
            self
        }
        /// <p>The ARN of the index.</p>
        pub fn index_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.index_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the index.</p>
        pub fn set_index_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.index_arn = input;
            self
        }
        /// <p>The name of the index.</p>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.index_name = Some(input.into());
            self
        }
        /// <p>The name of the index.</p>
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.index_name = input;
            self
        }
        /// <p>The total size in bytes of the index.</p>
        pub fn index_size_bytes(mut self, input: i64) -> Self {
            self.index_size_bytes = Some(input);
            self
        }
        /// <p>The total size in bytes of the index.</p>
        pub fn set_index_size_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.index_size_bytes = input;
            self
        }
        /// <p>The current status of the index.</p>
        pub fn index_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.index_status = Some(input.into());
            self
        }
        /// <p>The current status of the index.</p>
        pub fn set_index_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.index_status = input;
            self
        }
        /// <p>The number of items in the index.</p>
        pub fn item_count(mut self, input: i32) -> Self {
            self.item_count = Some(input);
            self
        }
        /// <p>The number of items in the index.</p>
        pub fn set_item_count(mut self, input: std::option::Option<i32>) -> Self {
            self.item_count = input;
            self
        }
        /// Appends an item to `key_schema`.
        ///
        /// To override the contents of this collection use [`set_key_schema`](Self::set_key_schema).
        ///
        /// <p>The key schema for the index.</p>
        pub fn key_schema(mut self, input: crate::model::AwsDynamoDbTableKeySchema) -> Self {
            let mut v = self.key_schema.unwrap_or_default();
            v.push(input);
            self.key_schema = Some(v);
            self
        }
        /// <p>The key schema for the index.</p>
        pub fn set_key_schema(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsDynamoDbTableKeySchema>>,
        ) -> Self {
            self.key_schema = input;
            self
        }
        /// <p>Attributes that are copied from the table into an index.</p>
        pub fn projection(mut self, input: crate::model::AwsDynamoDbTableProjection) -> Self {
            self.projection = Some(input);
            self
        }
        /// <p>Attributes that are copied from the table into an index.</p>
        pub fn set_projection(
            mut self,
            input: std::option::Option<crate::model::AwsDynamoDbTableProjection>,
        ) -> Self {
            self.projection = input;
            self
        }
        /// <p>Information about the provisioned throughput settings for the indexes.</p>
        pub fn provisioned_throughput(
            mut self,
            input: crate::model::AwsDynamoDbTableProvisionedThroughput,
        ) -> Self {
            self.provisioned_throughput = Some(input);
            self
        }
        /// <p>Information about the provisioned throughput settings for the indexes.</p>
        pub fn set_provisioned_throughput(
            mut self,
            input: std::option::Option<crate::model::AwsDynamoDbTableProvisionedThroughput>,
        ) -> Self {
            self.provisioned_throughput = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsDynamoDbTableGlobalSecondaryIndex`](crate::model::AwsDynamoDbTableGlobalSecondaryIndex)
        pub fn build(self) -> crate::model::AwsDynamoDbTableGlobalSecondaryIndex {
            crate::model::AwsDynamoDbTableGlobalSecondaryIndex {
                backfilling: self.backfilling.unwrap_or_default(),
                index_arn: self.index_arn,
                index_name: self.index_name,
                index_size_bytes: self.index_size_bytes.unwrap_or_default(),
                index_status: self.index_status,
                item_count: self.item_count.unwrap_or_default(),
                key_schema: self.key_schema,
                projection: self.projection,
                provisioned_throughput: self.provisioned_throughput,
            }
        }
    }
}
impl AwsDynamoDbTableGlobalSecondaryIndex {
    /// Creates a new builder-style object to manufacture [`AwsDynamoDbTableGlobalSecondaryIndex`](crate::model::AwsDynamoDbTableGlobalSecondaryIndex)
    pub fn builder() -> crate::model::aws_dynamo_db_table_global_secondary_index::Builder {
        crate::model::aws_dynamo_db_table_global_secondary_index::Builder::default()
    }
}

/// <p>Provides information about the billing for read/write capacity on the table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsDynamoDbTableBillingModeSummary {
    /// <p>The method used to charge for read and write throughput and to manage capacity.</p>
    pub billing_mode: std::option::Option<std::string::String>,
    /// <p>If the billing mode is <code>PAY_PER_REQUEST</code>, indicates when the billing mode was set to that value.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub last_update_to_pay_per_request_date_time: std::option::Option<std::string::String>,
}
impl AwsDynamoDbTableBillingModeSummary {
    /// <p>The method used to charge for read and write throughput and to manage capacity.</p>
    pub fn billing_mode(&self) -> std::option::Option<&str> {
        self.billing_mode.as_deref()
    }
    /// <p>If the billing mode is <code>PAY_PER_REQUEST</code>, indicates when the billing mode was set to that value.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn last_update_to_pay_per_request_date_time(&self) -> std::option::Option<&str> {
        self.last_update_to_pay_per_request_date_time.as_deref()
    }
}
impl std::fmt::Debug for AwsDynamoDbTableBillingModeSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsDynamoDbTableBillingModeSummary");
        formatter.field("billing_mode", &self.billing_mode);
        formatter.field(
            "last_update_to_pay_per_request_date_time",
            &self.last_update_to_pay_per_request_date_time,
        );
        formatter.finish()
    }
}
/// See [`AwsDynamoDbTableBillingModeSummary`](crate::model::AwsDynamoDbTableBillingModeSummary)
pub mod aws_dynamo_db_table_billing_mode_summary {

    /// A builder for [`AwsDynamoDbTableBillingModeSummary`](crate::model::AwsDynamoDbTableBillingModeSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) billing_mode: std::option::Option<std::string::String>,
        pub(crate) last_update_to_pay_per_request_date_time:
            std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The method used to charge for read and write throughput and to manage capacity.</p>
        pub fn billing_mode(mut self, input: impl Into<std::string::String>) -> Self {
            self.billing_mode = Some(input.into());
            self
        }
        /// <p>The method used to charge for read and write throughput and to manage capacity.</p>
        pub fn set_billing_mode(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.billing_mode = input;
            self
        }
        /// <p>If the billing mode is <code>PAY_PER_REQUEST</code>, indicates when the billing mode was set to that value.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn last_update_to_pay_per_request_date_time(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.last_update_to_pay_per_request_date_time = Some(input.into());
            self
        }
        /// <p>If the billing mode is <code>PAY_PER_REQUEST</code>, indicates when the billing mode was set to that value.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_last_update_to_pay_per_request_date_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_update_to_pay_per_request_date_time = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsDynamoDbTableBillingModeSummary`](crate::model::AwsDynamoDbTableBillingModeSummary)
        pub fn build(self) -> crate::model::AwsDynamoDbTableBillingModeSummary {
            crate::model::AwsDynamoDbTableBillingModeSummary {
                billing_mode: self.billing_mode,
                last_update_to_pay_per_request_date_time: self
                    .last_update_to_pay_per_request_date_time,
            }
        }
    }
}
impl AwsDynamoDbTableBillingModeSummary {
    /// Creates a new builder-style object to manufacture [`AwsDynamoDbTableBillingModeSummary`](crate::model::AwsDynamoDbTableBillingModeSummary)
    pub fn builder() -> crate::model::aws_dynamo_db_table_billing_mode_summary::Builder {
        crate::model::aws_dynamo_db_table_billing_mode_summary::Builder::default()
    }
}

/// <p>Contains a definition of an attribute for the table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsDynamoDbTableAttributeDefinition {
    /// <p>The name of the attribute.</p>
    pub attribute_name: std::option::Option<std::string::String>,
    /// <p>The type of the attribute.</p>
    pub attribute_type: std::option::Option<std::string::String>,
}
impl AwsDynamoDbTableAttributeDefinition {
    /// <p>The name of the attribute.</p>
    pub fn attribute_name(&self) -> std::option::Option<&str> {
        self.attribute_name.as_deref()
    }
    /// <p>The type of the attribute.</p>
    pub fn attribute_type(&self) -> std::option::Option<&str> {
        self.attribute_type.as_deref()
    }
}
impl std::fmt::Debug for AwsDynamoDbTableAttributeDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsDynamoDbTableAttributeDefinition");
        formatter.field("attribute_name", &self.attribute_name);
        formatter.field("attribute_type", &self.attribute_type);
        formatter.finish()
    }
}
/// See [`AwsDynamoDbTableAttributeDefinition`](crate::model::AwsDynamoDbTableAttributeDefinition)
pub mod aws_dynamo_db_table_attribute_definition {

    /// A builder for [`AwsDynamoDbTableAttributeDefinition`](crate::model::AwsDynamoDbTableAttributeDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute_name: std::option::Option<std::string::String>,
        pub(crate) attribute_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the attribute.</p>
        pub fn attribute_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.attribute_name = Some(input.into());
            self
        }
        /// <p>The name of the attribute.</p>
        pub fn set_attribute_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attribute_name = input;
            self
        }
        /// <p>The type of the attribute.</p>
        pub fn attribute_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.attribute_type = Some(input.into());
            self
        }
        /// <p>The type of the attribute.</p>
        pub fn set_attribute_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attribute_type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsDynamoDbTableAttributeDefinition`](crate::model::AwsDynamoDbTableAttributeDefinition)
        pub fn build(self) -> crate::model::AwsDynamoDbTableAttributeDefinition {
            crate::model::AwsDynamoDbTableAttributeDefinition {
                attribute_name: self.attribute_name,
                attribute_type: self.attribute_type,
            }
        }
    }
}
impl AwsDynamoDbTableAttributeDefinition {
    /// Creates a new builder-style object to manufacture [`AwsDynamoDbTableAttributeDefinition`](crate::model::AwsDynamoDbTableAttributeDefinition)
    pub fn builder() -> crate::model::aws_dynamo_db_table_attribute_definition::Builder {
        crate::model::aws_dynamo_db_table_attribute_definition::Builder::default()
    }
}

/// <p>Contains information about a version 2 API in Amazon API Gateway.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsApiGatewayV2ApiDetails {
    /// <p>The URI of the API. </p>
    /// <p>Uses the format <code> <i>
    /// <api-id></api-id></i>.execute-api.<i>
    /// <region></region></i>.amazonaws.com</code> </p>
    /// <p>The stage name is typically appended to the URI to form a complete path to a deployed API stage.</p>
    pub api_endpoint: std::option::Option<std::string::String>,
    /// <p>The identifier of the API.</p>
    pub api_id: std::option::Option<std::string::String>,
    /// <p>An API key selection expression. Supported only for WebSocket APIs. </p>
    pub api_key_selection_expression: std::option::Option<std::string::String>,
    /// <p>Indicates when the API was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub created_date: std::option::Option<std::string::String>,
    /// <p>A description of the API.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The version identifier for the API.</p>
    pub version: std::option::Option<std::string::String>,
    /// <p>The name of the API.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The API protocol for the API.</p>
    /// <p>Valid values: <code>WEBSOCKET</code> | <code>HTTP</code> </p>
    pub protocol_type: std::option::Option<std::string::String>,
    /// <p>The route selection expression for the API.</p>
    /// <p>For HTTP APIs, must be <code>${request.method} ${request.path}</code>. This is the default value for HTTP APIs.</p>
    /// <p>For WebSocket APIs, there is no default value.</p>
    pub route_selection_expression: std::option::Option<std::string::String>,
    /// <p>A cross-origin resource sharing (CORS) configuration. Supported only for HTTP APIs.</p>
    pub cors_configuration: std::option::Option<crate::model::AwsCorsConfiguration>,
}
impl AwsApiGatewayV2ApiDetails {
    /// <p>The URI of the API. </p>
    /// <p>Uses the format <code> <i>
    /// <api-id></api-id></i>.execute-api.<i>
    /// <region></region></i>.amazonaws.com</code> </p>
    /// <p>The stage name is typically appended to the URI to form a complete path to a deployed API stage.</p>
    pub fn api_endpoint(&self) -> std::option::Option<&str> {
        self.api_endpoint.as_deref()
    }
    /// <p>The identifier of the API.</p>
    pub fn api_id(&self) -> std::option::Option<&str> {
        self.api_id.as_deref()
    }
    /// <p>An API key selection expression. Supported only for WebSocket APIs. </p>
    pub fn api_key_selection_expression(&self) -> std::option::Option<&str> {
        self.api_key_selection_expression.as_deref()
    }
    /// <p>Indicates when the API was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn created_date(&self) -> std::option::Option<&str> {
        self.created_date.as_deref()
    }
    /// <p>A description of the API.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The version identifier for the API.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
    /// <p>The name of the API.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The API protocol for the API.</p>
    /// <p>Valid values: <code>WEBSOCKET</code> | <code>HTTP</code> </p>
    pub fn protocol_type(&self) -> std::option::Option<&str> {
        self.protocol_type.as_deref()
    }
    /// <p>The route selection expression for the API.</p>
    /// <p>For HTTP APIs, must be <code>${request.method} ${request.path}</code>. This is the default value for HTTP APIs.</p>
    /// <p>For WebSocket APIs, there is no default value.</p>
    pub fn route_selection_expression(&self) -> std::option::Option<&str> {
        self.route_selection_expression.as_deref()
    }
    /// <p>A cross-origin resource sharing (CORS) configuration. Supported only for HTTP APIs.</p>
    pub fn cors_configuration(&self) -> std::option::Option<&crate::model::AwsCorsConfiguration> {
        self.cors_configuration.as_ref()
    }
}
impl std::fmt::Debug for AwsApiGatewayV2ApiDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsApiGatewayV2ApiDetails");
        formatter.field("api_endpoint", &self.api_endpoint);
        formatter.field("api_id", &self.api_id);
        formatter.field(
            "api_key_selection_expression",
            &self.api_key_selection_expression,
        );
        formatter.field("created_date", &self.created_date);
        formatter.field("description", &self.description);
        formatter.field("version", &self.version);
        formatter.field("name", &self.name);
        formatter.field("protocol_type", &self.protocol_type);
        formatter.field(
            "route_selection_expression",
            &self.route_selection_expression,
        );
        formatter.field("cors_configuration", &self.cors_configuration);
        formatter.finish()
    }
}
/// See [`AwsApiGatewayV2ApiDetails`](crate::model::AwsApiGatewayV2ApiDetails)
pub mod aws_api_gateway_v2_api_details {

    /// A builder for [`AwsApiGatewayV2ApiDetails`](crate::model::AwsApiGatewayV2ApiDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) api_endpoint: std::option::Option<std::string::String>,
        pub(crate) api_id: std::option::Option<std::string::String>,
        pub(crate) api_key_selection_expression: std::option::Option<std::string::String>,
        pub(crate) created_date: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) protocol_type: std::option::Option<std::string::String>,
        pub(crate) route_selection_expression: std::option::Option<std::string::String>,
        pub(crate) cors_configuration: std::option::Option<crate::model::AwsCorsConfiguration>,
    }
    impl Builder {
        /// <p>The URI of the API. </p>
        /// <p>Uses the format <code> <i>
        /// <api-id></api-id></i>.execute-api.<i>
        /// <region></region></i>.amazonaws.com</code> </p>
        /// <p>The stage name is typically appended to the URI to form a complete path to a deployed API stage.</p>
        pub fn api_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.api_endpoint = Some(input.into());
            self
        }
        /// <p>The URI of the API. </p>
        /// <p>Uses the format <code> <i>
        /// <api-id></api-id></i>.execute-api.<i>
        /// <region></region></i>.amazonaws.com</code> </p>
        /// <p>The stage name is typically appended to the URI to form a complete path to a deployed API stage.</p>
        pub fn set_api_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.api_endpoint = input;
            self
        }
        /// <p>The identifier of the API.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.api_id = Some(input.into());
            self
        }
        /// <p>The identifier of the API.</p>
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.api_id = input;
            self
        }
        /// <p>An API key selection expression. Supported only for WebSocket APIs. </p>
        pub fn api_key_selection_expression(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.api_key_selection_expression = Some(input.into());
            self
        }
        /// <p>An API key selection expression. Supported only for WebSocket APIs. </p>
        pub fn set_api_key_selection_expression(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.api_key_selection_expression = input;
            self
        }
        /// <p>Indicates when the API was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn created_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_date = Some(input.into());
            self
        }
        /// <p>Indicates when the API was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_created_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_date = input;
            self
        }
        /// <p>A description of the API.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the API.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The version identifier for the API.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The version identifier for the API.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// <p>The name of the API.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the API.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The API protocol for the API.</p>
        /// <p>Valid values: <code>WEBSOCKET</code> | <code>HTTP</code> </p>
        pub fn protocol_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.protocol_type = Some(input.into());
            self
        }
        /// <p>The API protocol for the API.</p>
        /// <p>Valid values: <code>WEBSOCKET</code> | <code>HTTP</code> </p>
        pub fn set_protocol_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.protocol_type = input;
            self
        }
        /// <p>The route selection expression for the API.</p>
        /// <p>For HTTP APIs, must be <code>${request.method} ${request.path}</code>. This is the default value for HTTP APIs.</p>
        /// <p>For WebSocket APIs, there is no default value.</p>
        pub fn route_selection_expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.route_selection_expression = Some(input.into());
            self
        }
        /// <p>The route selection expression for the API.</p>
        /// <p>For HTTP APIs, must be <code>${request.method} ${request.path}</code>. This is the default value for HTTP APIs.</p>
        /// <p>For WebSocket APIs, there is no default value.</p>
        pub fn set_route_selection_expression(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.route_selection_expression = input;
            self
        }
        /// <p>A cross-origin resource sharing (CORS) configuration. Supported only for HTTP APIs.</p>
        pub fn cors_configuration(mut self, input: crate::model::AwsCorsConfiguration) -> Self {
            self.cors_configuration = Some(input);
            self
        }
        /// <p>A cross-origin resource sharing (CORS) configuration. Supported only for HTTP APIs.</p>
        pub fn set_cors_configuration(
            mut self,
            input: std::option::Option<crate::model::AwsCorsConfiguration>,
        ) -> Self {
            self.cors_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsApiGatewayV2ApiDetails`](crate::model::AwsApiGatewayV2ApiDetails)
        pub fn build(self) -> crate::model::AwsApiGatewayV2ApiDetails {
            crate::model::AwsApiGatewayV2ApiDetails {
                api_endpoint: self.api_endpoint,
                api_id: self.api_id,
                api_key_selection_expression: self.api_key_selection_expression,
                created_date: self.created_date,
                description: self.description,
                version: self.version,
                name: self.name,
                protocol_type: self.protocol_type,
                route_selection_expression: self.route_selection_expression,
                cors_configuration: self.cors_configuration,
            }
        }
    }
}
impl AwsApiGatewayV2ApiDetails {
    /// Creates a new builder-style object to manufacture [`AwsApiGatewayV2ApiDetails`](crate::model::AwsApiGatewayV2ApiDetails)
    pub fn builder() -> crate::model::aws_api_gateway_v2_api_details::Builder {
        crate::model::aws_api_gateway_v2_api_details::Builder::default()
    }
}

/// <p>Contains the cross-origin resource sharing (CORS) configuration for the API. CORS is only supported for HTTP APIs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCorsConfiguration {
    /// <p>The allowed origins for CORS requests.</p>
    pub allow_origins: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Indicates whether the CORS request includes credentials.</p>
    pub allow_credentials: bool,
    /// <p>The exposed headers for CORS requests.</p>
    pub expose_headers: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The number of seconds for which the browser caches preflight request results.</p>
    pub max_age: i32,
    /// <p>The allowed methods for CORS requests.</p>
    pub allow_methods: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The allowed headers for CORS requests.</p>
    pub allow_headers: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AwsCorsConfiguration {
    /// <p>The allowed origins for CORS requests.</p>
    pub fn allow_origins(&self) -> std::option::Option<&[std::string::String]> {
        self.allow_origins.as_deref()
    }
    /// <p>Indicates whether the CORS request includes credentials.</p>
    pub fn allow_credentials(&self) -> bool {
        self.allow_credentials
    }
    /// <p>The exposed headers for CORS requests.</p>
    pub fn expose_headers(&self) -> std::option::Option<&[std::string::String]> {
        self.expose_headers.as_deref()
    }
    /// <p>The number of seconds for which the browser caches preflight request results.</p>
    pub fn max_age(&self) -> i32 {
        self.max_age
    }
    /// <p>The allowed methods for CORS requests.</p>
    pub fn allow_methods(&self) -> std::option::Option<&[std::string::String]> {
        self.allow_methods.as_deref()
    }
    /// <p>The allowed headers for CORS requests.</p>
    pub fn allow_headers(&self) -> std::option::Option<&[std::string::String]> {
        self.allow_headers.as_deref()
    }
}
impl std::fmt::Debug for AwsCorsConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCorsConfiguration");
        formatter.field("allow_origins", &self.allow_origins);
        formatter.field("allow_credentials", &self.allow_credentials);
        formatter.field("expose_headers", &self.expose_headers);
        formatter.field("max_age", &self.max_age);
        formatter.field("allow_methods", &self.allow_methods);
        formatter.field("allow_headers", &self.allow_headers);
        formatter.finish()
    }
}
/// See [`AwsCorsConfiguration`](crate::model::AwsCorsConfiguration)
pub mod aws_cors_configuration {

    /// A builder for [`AwsCorsConfiguration`](crate::model::AwsCorsConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) allow_origins: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) allow_credentials: std::option::Option<bool>,
        pub(crate) expose_headers: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) max_age: std::option::Option<i32>,
        pub(crate) allow_methods: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) allow_headers: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `allow_origins`.
        ///
        /// To override the contents of this collection use [`set_allow_origins`](Self::set_allow_origins).
        ///
        /// <p>The allowed origins for CORS requests.</p>
        pub fn allow_origins(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.allow_origins.unwrap_or_default();
            v.push(input.into());
            self.allow_origins = Some(v);
            self
        }
        /// <p>The allowed origins for CORS requests.</p>
        pub fn set_allow_origins(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.allow_origins = input;
            self
        }
        /// <p>Indicates whether the CORS request includes credentials.</p>
        pub fn allow_credentials(mut self, input: bool) -> Self {
            self.allow_credentials = Some(input);
            self
        }
        /// <p>Indicates whether the CORS request includes credentials.</p>
        pub fn set_allow_credentials(mut self, input: std::option::Option<bool>) -> Self {
            self.allow_credentials = input;
            self
        }
        /// Appends an item to `expose_headers`.
        ///
        /// To override the contents of this collection use [`set_expose_headers`](Self::set_expose_headers).
        ///
        /// <p>The exposed headers for CORS requests.</p>
        pub fn expose_headers(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.expose_headers.unwrap_or_default();
            v.push(input.into());
            self.expose_headers = Some(v);
            self
        }
        /// <p>The exposed headers for CORS requests.</p>
        pub fn set_expose_headers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.expose_headers = input;
            self
        }
        /// <p>The number of seconds for which the browser caches preflight request results.</p>
        pub fn max_age(mut self, input: i32) -> Self {
            self.max_age = Some(input);
            self
        }
        /// <p>The number of seconds for which the browser caches preflight request results.</p>
        pub fn set_max_age(mut self, input: std::option::Option<i32>) -> Self {
            self.max_age = input;
            self
        }
        /// Appends an item to `allow_methods`.
        ///
        /// To override the contents of this collection use [`set_allow_methods`](Self::set_allow_methods).
        ///
        /// <p>The allowed methods for CORS requests.</p>
        pub fn allow_methods(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.allow_methods.unwrap_or_default();
            v.push(input.into());
            self.allow_methods = Some(v);
            self
        }
        /// <p>The allowed methods for CORS requests.</p>
        pub fn set_allow_methods(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.allow_methods = input;
            self
        }
        /// Appends an item to `allow_headers`.
        ///
        /// To override the contents of this collection use [`set_allow_headers`](Self::set_allow_headers).
        ///
        /// <p>The allowed headers for CORS requests.</p>
        pub fn allow_headers(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.allow_headers.unwrap_or_default();
            v.push(input.into());
            self.allow_headers = Some(v);
            self
        }
        /// <p>The allowed headers for CORS requests.</p>
        pub fn set_allow_headers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.allow_headers = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCorsConfiguration`](crate::model::AwsCorsConfiguration)
        pub fn build(self) -> crate::model::AwsCorsConfiguration {
            crate::model::AwsCorsConfiguration {
                allow_origins: self.allow_origins,
                allow_credentials: self.allow_credentials.unwrap_or_default(),
                expose_headers: self.expose_headers,
                max_age: self.max_age.unwrap_or_default(),
                allow_methods: self.allow_methods,
                allow_headers: self.allow_headers,
            }
        }
    }
}
impl AwsCorsConfiguration {
    /// Creates a new builder-style object to manufacture [`AwsCorsConfiguration`](crate::model::AwsCorsConfiguration)
    pub fn builder() -> crate::model::aws_cors_configuration::Builder {
        crate::model::aws_cors_configuration::Builder::default()
    }
}

/// <p>Contains information about a version 2 stage for Amazon API Gateway.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsApiGatewayV2StageDetails {
    /// <p>The identifier of a client certificate for a stage. Supported only for WebSocket API calls.</p>
    pub client_certificate_id: std::option::Option<std::string::String>,
    /// <p>Indicates when the stage was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub created_date: std::option::Option<std::string::String>,
    /// <p>The description of the stage.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Default route settings for the stage.</p>
    pub default_route_settings: std::option::Option<crate::model::AwsApiGatewayV2RouteSettings>,
    /// <p>The identifier of the deployment that the stage is associated with. </p>
    pub deployment_id: std::option::Option<std::string::String>,
    /// <p>Indicates when the stage was most recently updated.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub last_updated_date: std::option::Option<std::string::String>,
    /// <p>The route settings for the stage.</p>
    pub route_settings: std::option::Option<crate::model::AwsApiGatewayV2RouteSettings>,
    /// <p>The name of the stage.</p>
    pub stage_name: std::option::Option<std::string::String>,
    /// <p>A map that defines the stage variables for the stage.</p>
    /// <p>Variable names can have alphanumeric and underscore characters.</p>
    /// <p>Variable values can contain the following characters:</p>
    /// <ul>
    /// <li> <p>Uppercase and lowercase letters</p> </li>
    /// <li> <p>Numbers</p> </li>
    /// <li> <p>Special characters -._~:/?#&amp;=,</p> </li>
    /// </ul>
    pub stage_variables:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Information about settings for logging access for the stage.</p>
    pub access_log_settings: std::option::Option<crate::model::AwsApiGatewayAccessLogSettings>,
    /// <p>Indicates whether updates to an API automatically trigger a new deployment.</p>
    pub auto_deploy: bool,
    /// <p>The status of the last deployment of a stage. Supported only if the stage has automatic deployment enabled.</p>
    pub last_deployment_status_message: std::option::Option<std::string::String>,
    /// <p>Indicates whether the stage is managed by API Gateway.</p>
    pub api_gateway_managed: bool,
}
impl AwsApiGatewayV2StageDetails {
    /// <p>The identifier of a client certificate for a stage. Supported only for WebSocket API calls.</p>
    pub fn client_certificate_id(&self) -> std::option::Option<&str> {
        self.client_certificate_id.as_deref()
    }
    /// <p>Indicates when the stage was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn created_date(&self) -> std::option::Option<&str> {
        self.created_date.as_deref()
    }
    /// <p>The description of the stage.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Default route settings for the stage.</p>
    pub fn default_route_settings(
        &self,
    ) -> std::option::Option<&crate::model::AwsApiGatewayV2RouteSettings> {
        self.default_route_settings.as_ref()
    }
    /// <p>The identifier of the deployment that the stage is associated with. </p>
    pub fn deployment_id(&self) -> std::option::Option<&str> {
        self.deployment_id.as_deref()
    }
    /// <p>Indicates when the stage was most recently updated.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn last_updated_date(&self) -> std::option::Option<&str> {
        self.last_updated_date.as_deref()
    }
    /// <p>The route settings for the stage.</p>
    pub fn route_settings(
        &self,
    ) -> std::option::Option<&crate::model::AwsApiGatewayV2RouteSettings> {
        self.route_settings.as_ref()
    }
    /// <p>The name of the stage.</p>
    pub fn stage_name(&self) -> std::option::Option<&str> {
        self.stage_name.as_deref()
    }
    /// <p>A map that defines the stage variables for the stage.</p>
    /// <p>Variable names can have alphanumeric and underscore characters.</p>
    /// <p>Variable values can contain the following characters:</p>
    /// <ul>
    /// <li> <p>Uppercase and lowercase letters</p> </li>
    /// <li> <p>Numbers</p> </li>
    /// <li> <p>Special characters -._~:/?#&amp;=,</p> </li>
    /// </ul>
    pub fn stage_variables(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.stage_variables.as_ref()
    }
    /// <p>Information about settings for logging access for the stage.</p>
    pub fn access_log_settings(
        &self,
    ) -> std::option::Option<&crate::model::AwsApiGatewayAccessLogSettings> {
        self.access_log_settings.as_ref()
    }
    /// <p>Indicates whether updates to an API automatically trigger a new deployment.</p>
    pub fn auto_deploy(&self) -> bool {
        self.auto_deploy
    }
    /// <p>The status of the last deployment of a stage. Supported only if the stage has automatic deployment enabled.</p>
    pub fn last_deployment_status_message(&self) -> std::option::Option<&str> {
        self.last_deployment_status_message.as_deref()
    }
    /// <p>Indicates whether the stage is managed by API Gateway.</p>
    pub fn api_gateway_managed(&self) -> bool {
        self.api_gateway_managed
    }
}
impl std::fmt::Debug for AwsApiGatewayV2StageDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsApiGatewayV2StageDetails");
        formatter.field("client_certificate_id", &self.client_certificate_id);
        formatter.field("created_date", &self.created_date);
        formatter.field("description", &self.description);
        formatter.field("default_route_settings", &self.default_route_settings);
        formatter.field("deployment_id", &self.deployment_id);
        formatter.field("last_updated_date", &self.last_updated_date);
        formatter.field("route_settings", &self.route_settings);
        formatter.field("stage_name", &self.stage_name);
        formatter.field("stage_variables", &self.stage_variables);
        formatter.field("access_log_settings", &self.access_log_settings);
        formatter.field("auto_deploy", &self.auto_deploy);
        formatter.field(
            "last_deployment_status_message",
            &self.last_deployment_status_message,
        );
        formatter.field("api_gateway_managed", &self.api_gateway_managed);
        formatter.finish()
    }
}
/// See [`AwsApiGatewayV2StageDetails`](crate::model::AwsApiGatewayV2StageDetails)
pub mod aws_api_gateway_v2_stage_details {

    /// A builder for [`AwsApiGatewayV2StageDetails`](crate::model::AwsApiGatewayV2StageDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_certificate_id: std::option::Option<std::string::String>,
        pub(crate) created_date: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) default_route_settings:
            std::option::Option<crate::model::AwsApiGatewayV2RouteSettings>,
        pub(crate) deployment_id: std::option::Option<std::string::String>,
        pub(crate) last_updated_date: std::option::Option<std::string::String>,
        pub(crate) route_settings: std::option::Option<crate::model::AwsApiGatewayV2RouteSettings>,
        pub(crate) stage_name: std::option::Option<std::string::String>,
        pub(crate) stage_variables: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) access_log_settings:
            std::option::Option<crate::model::AwsApiGatewayAccessLogSettings>,
        pub(crate) auto_deploy: std::option::Option<bool>,
        pub(crate) last_deployment_status_message: std::option::Option<std::string::String>,
        pub(crate) api_gateway_managed: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The identifier of a client certificate for a stage. Supported only for WebSocket API calls.</p>
        pub fn client_certificate_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_certificate_id = Some(input.into());
            self
        }
        /// <p>The identifier of a client certificate for a stage. Supported only for WebSocket API calls.</p>
        pub fn set_client_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_certificate_id = input;
            self
        }
        /// <p>Indicates when the stage was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn created_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_date = Some(input.into());
            self
        }
        /// <p>Indicates when the stage was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_created_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_date = input;
            self
        }
        /// <p>The description of the stage.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the stage.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Default route settings for the stage.</p>
        pub fn default_route_settings(
            mut self,
            input: crate::model::AwsApiGatewayV2RouteSettings,
        ) -> Self {
            self.default_route_settings = Some(input);
            self
        }
        /// <p>Default route settings for the stage.</p>
        pub fn set_default_route_settings(
            mut self,
            input: std::option::Option<crate::model::AwsApiGatewayV2RouteSettings>,
        ) -> Self {
            self.default_route_settings = input;
            self
        }
        /// <p>The identifier of the deployment that the stage is associated with. </p>
        pub fn deployment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.deployment_id = Some(input.into());
            self
        }
        /// <p>The identifier of the deployment that the stage is associated with. </p>
        pub fn set_deployment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.deployment_id = input;
            self
        }
        /// <p>Indicates when the stage was most recently updated.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn last_updated_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_updated_date = Some(input.into());
            self
        }
        /// <p>Indicates when the stage was most recently updated.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_last_updated_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_updated_date = input;
            self
        }
        /// <p>The route settings for the stage.</p>
        pub fn route_settings(mut self, input: crate::model::AwsApiGatewayV2RouteSettings) -> Self {
            self.route_settings = Some(input);
            self
        }
        /// <p>The route settings for the stage.</p>
        pub fn set_route_settings(
            mut self,
            input: std::option::Option<crate::model::AwsApiGatewayV2RouteSettings>,
        ) -> Self {
            self.route_settings = input;
            self
        }
        /// <p>The name of the stage.</p>
        pub fn stage_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.stage_name = Some(input.into());
            self
        }
        /// <p>The name of the stage.</p>
        pub fn set_stage_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stage_name = input;
            self
        }
        /// Adds a key-value pair to `stage_variables`.
        ///
        /// To override the contents of this collection use [`set_stage_variables`](Self::set_stage_variables).
        ///
        /// <p>A map that defines the stage variables for the stage.</p>
        /// <p>Variable names can have alphanumeric and underscore characters.</p>
        /// <p>Variable values can contain the following characters:</p>
        /// <ul>
        /// <li> <p>Uppercase and lowercase letters</p> </li>
        /// <li> <p>Numbers</p> </li>
        /// <li> <p>Special characters -._~:/?#&amp;=,</p> </li>
        /// </ul>
        pub fn stage_variables(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.stage_variables.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.stage_variables = Some(hash_map);
            self
        }
        /// <p>A map that defines the stage variables for the stage.</p>
        /// <p>Variable names can have alphanumeric and underscore characters.</p>
        /// <p>Variable values can contain the following characters:</p>
        /// <ul>
        /// <li> <p>Uppercase and lowercase letters</p> </li>
        /// <li> <p>Numbers</p> </li>
        /// <li> <p>Special characters -._~:/?#&amp;=,</p> </li>
        /// </ul>
        pub fn set_stage_variables(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.stage_variables = input;
            self
        }
        /// <p>Information about settings for logging access for the stage.</p>
        pub fn access_log_settings(
            mut self,
            input: crate::model::AwsApiGatewayAccessLogSettings,
        ) -> Self {
            self.access_log_settings = Some(input);
            self
        }
        /// <p>Information about settings for logging access for the stage.</p>
        pub fn set_access_log_settings(
            mut self,
            input: std::option::Option<crate::model::AwsApiGatewayAccessLogSettings>,
        ) -> Self {
            self.access_log_settings = input;
            self
        }
        /// <p>Indicates whether updates to an API automatically trigger a new deployment.</p>
        pub fn auto_deploy(mut self, input: bool) -> Self {
            self.auto_deploy = Some(input);
            self
        }
        /// <p>Indicates whether updates to an API automatically trigger a new deployment.</p>
        pub fn set_auto_deploy(mut self, input: std::option::Option<bool>) -> Self {
            self.auto_deploy = input;
            self
        }
        /// <p>The status of the last deployment of a stage. Supported only if the stage has automatic deployment enabled.</p>
        pub fn last_deployment_status_message(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.last_deployment_status_message = Some(input.into());
            self
        }
        /// <p>The status of the last deployment of a stage. Supported only if the stage has automatic deployment enabled.</p>
        pub fn set_last_deployment_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_deployment_status_message = input;
            self
        }
        /// <p>Indicates whether the stage is managed by API Gateway.</p>
        pub fn api_gateway_managed(mut self, input: bool) -> Self {
            self.api_gateway_managed = Some(input);
            self
        }
        /// <p>Indicates whether the stage is managed by API Gateway.</p>
        pub fn set_api_gateway_managed(mut self, input: std::option::Option<bool>) -> Self {
            self.api_gateway_managed = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsApiGatewayV2StageDetails`](crate::model::AwsApiGatewayV2StageDetails)
        pub fn build(self) -> crate::model::AwsApiGatewayV2StageDetails {
            crate::model::AwsApiGatewayV2StageDetails {
                client_certificate_id: self.client_certificate_id,
                created_date: self.created_date,
                description: self.description,
                default_route_settings: self.default_route_settings,
                deployment_id: self.deployment_id,
                last_updated_date: self.last_updated_date,
                route_settings: self.route_settings,
                stage_name: self.stage_name,
                stage_variables: self.stage_variables,
                access_log_settings: self.access_log_settings,
                auto_deploy: self.auto_deploy.unwrap_or_default(),
                last_deployment_status_message: self.last_deployment_status_message,
                api_gateway_managed: self.api_gateway_managed.unwrap_or_default(),
            }
        }
    }
}
impl AwsApiGatewayV2StageDetails {
    /// Creates a new builder-style object to manufacture [`AwsApiGatewayV2StageDetails`](crate::model::AwsApiGatewayV2StageDetails)
    pub fn builder() -> crate::model::aws_api_gateway_v2_stage_details::Builder {
        crate::model::aws_api_gateway_v2_stage_details::Builder::default()
    }
}

/// <p>Contains route settings for a stage.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsApiGatewayV2RouteSettings {
    /// <p>Indicates whether detailed metrics are enabled.</p>
    pub detailed_metrics_enabled: bool,
    /// <p>The logging level. The logging level affects the log entries that are pushed to CloudWatch Logs. Supported only for WebSocket APIs.</p>
    /// <p>If the logging level is <code>ERROR</code>, then the logs only include error-level entries.</p>
    /// <p>If the logging level is <code>INFO</code>, then the logs include both <code>ERROR</code> events and extra informational events.</p>
    /// <p>Valid values: <code>OFF</code> | <code>ERROR</code> | <code>INFO</code> </p>
    pub logging_level: std::option::Option<std::string::String>,
    /// <p>Indicates whether data trace logging is enabled. Data trace logging affects the log entries that are pushed to CloudWatch Logs. Supported only for WebSocket APIs.</p>
    pub data_trace_enabled: bool,
    /// <p>The throttling burst limit.</p>
    pub throttling_burst_limit: i32,
    /// <p>The throttling rate limit.</p>
    pub throttling_rate_limit: f64,
}
impl AwsApiGatewayV2RouteSettings {
    /// <p>Indicates whether detailed metrics are enabled.</p>
    pub fn detailed_metrics_enabled(&self) -> bool {
        self.detailed_metrics_enabled
    }
    /// <p>The logging level. The logging level affects the log entries that are pushed to CloudWatch Logs. Supported only for WebSocket APIs.</p>
    /// <p>If the logging level is <code>ERROR</code>, then the logs only include error-level entries.</p>
    /// <p>If the logging level is <code>INFO</code>, then the logs include both <code>ERROR</code> events and extra informational events.</p>
    /// <p>Valid values: <code>OFF</code> | <code>ERROR</code> | <code>INFO</code> </p>
    pub fn logging_level(&self) -> std::option::Option<&str> {
        self.logging_level.as_deref()
    }
    /// <p>Indicates whether data trace logging is enabled. Data trace logging affects the log entries that are pushed to CloudWatch Logs. Supported only for WebSocket APIs.</p>
    pub fn data_trace_enabled(&self) -> bool {
        self.data_trace_enabled
    }
    /// <p>The throttling burst limit.</p>
    pub fn throttling_burst_limit(&self) -> i32 {
        self.throttling_burst_limit
    }
    /// <p>The throttling rate limit.</p>
    pub fn throttling_rate_limit(&self) -> f64 {
        self.throttling_rate_limit
    }
}
impl std::fmt::Debug for AwsApiGatewayV2RouteSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsApiGatewayV2RouteSettings");
        formatter.field("detailed_metrics_enabled", &self.detailed_metrics_enabled);
        formatter.field("logging_level", &self.logging_level);
        formatter.field("data_trace_enabled", &self.data_trace_enabled);
        formatter.field("throttling_burst_limit", &self.throttling_burst_limit);
        formatter.field("throttling_rate_limit", &self.throttling_rate_limit);
        formatter.finish()
    }
}
/// See [`AwsApiGatewayV2RouteSettings`](crate::model::AwsApiGatewayV2RouteSettings)
pub mod aws_api_gateway_v2_route_settings {

    /// A builder for [`AwsApiGatewayV2RouteSettings`](crate::model::AwsApiGatewayV2RouteSettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) detailed_metrics_enabled: std::option::Option<bool>,
        pub(crate) logging_level: std::option::Option<std::string::String>,
        pub(crate) data_trace_enabled: std::option::Option<bool>,
        pub(crate) throttling_burst_limit: std::option::Option<i32>,
        pub(crate) throttling_rate_limit: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>Indicates whether detailed metrics are enabled.</p>
        pub fn detailed_metrics_enabled(mut self, input: bool) -> Self {
            self.detailed_metrics_enabled = Some(input);
            self
        }
        /// <p>Indicates whether detailed metrics are enabled.</p>
        pub fn set_detailed_metrics_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.detailed_metrics_enabled = input;
            self
        }
        /// <p>The logging level. The logging level affects the log entries that are pushed to CloudWatch Logs. Supported only for WebSocket APIs.</p>
        /// <p>If the logging level is <code>ERROR</code>, then the logs only include error-level entries.</p>
        /// <p>If the logging level is <code>INFO</code>, then the logs include both <code>ERROR</code> events and extra informational events.</p>
        /// <p>Valid values: <code>OFF</code> | <code>ERROR</code> | <code>INFO</code> </p>
        pub fn logging_level(mut self, input: impl Into<std::string::String>) -> Self {
            self.logging_level = Some(input.into());
            self
        }
        /// <p>The logging level. The logging level affects the log entries that are pushed to CloudWatch Logs. Supported only for WebSocket APIs.</p>
        /// <p>If the logging level is <code>ERROR</code>, then the logs only include error-level entries.</p>
        /// <p>If the logging level is <code>INFO</code>, then the logs include both <code>ERROR</code> events and extra informational events.</p>
        /// <p>Valid values: <code>OFF</code> | <code>ERROR</code> | <code>INFO</code> </p>
        pub fn set_logging_level(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.logging_level = input;
            self
        }
        /// <p>Indicates whether data trace logging is enabled. Data trace logging affects the log entries that are pushed to CloudWatch Logs. Supported only for WebSocket APIs.</p>
        pub fn data_trace_enabled(mut self, input: bool) -> Self {
            self.data_trace_enabled = Some(input);
            self
        }
        /// <p>Indicates whether data trace logging is enabled. Data trace logging affects the log entries that are pushed to CloudWatch Logs. Supported only for WebSocket APIs.</p>
        pub fn set_data_trace_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.data_trace_enabled = input;
            self
        }
        /// <p>The throttling burst limit.</p>
        pub fn throttling_burst_limit(mut self, input: i32) -> Self {
            self.throttling_burst_limit = Some(input);
            self
        }
        /// <p>The throttling burst limit.</p>
        pub fn set_throttling_burst_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.throttling_burst_limit = input;
            self
        }
        /// <p>The throttling rate limit.</p>
        pub fn throttling_rate_limit(mut self, input: f64) -> Self {
            self.throttling_rate_limit = Some(input);
            self
        }
        /// <p>The throttling rate limit.</p>
        pub fn set_throttling_rate_limit(mut self, input: std::option::Option<f64>) -> Self {
            self.throttling_rate_limit = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsApiGatewayV2RouteSettings`](crate::model::AwsApiGatewayV2RouteSettings)
        pub fn build(self) -> crate::model::AwsApiGatewayV2RouteSettings {
            crate::model::AwsApiGatewayV2RouteSettings {
                detailed_metrics_enabled: self.detailed_metrics_enabled.unwrap_or_default(),
                logging_level: self.logging_level,
                data_trace_enabled: self.data_trace_enabled.unwrap_or_default(),
                throttling_burst_limit: self.throttling_burst_limit.unwrap_or_default(),
                throttling_rate_limit: self.throttling_rate_limit.unwrap_or_default(),
            }
        }
    }
}
impl AwsApiGatewayV2RouteSettings {
    /// Creates a new builder-style object to manufacture [`AwsApiGatewayV2RouteSettings`](crate::model::AwsApiGatewayV2RouteSettings)
    pub fn builder() -> crate::model::aws_api_gateway_v2_route_settings::Builder {
        crate::model::aws_api_gateway_v2_route_settings::Builder::default()
    }
}

/// <p>Represents an IAM permissions policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsIamPolicyDetails {
    /// <p>The number of users, groups, and roles that the policy is attached to.</p>
    pub attachment_count: i32,
    /// <p>When the policy was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub create_date: std::option::Option<std::string::String>,
    /// <p>The identifier of the default version of the policy.</p>
    pub default_version_id: std::option::Option<std::string::String>,
    /// <p>A description of the policy.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Whether the policy can be attached to a user, group, or role.</p>
    pub is_attachable: bool,
    /// <p>The path to the policy.</p>
    pub path: std::option::Option<std::string::String>,
    /// <p>The number of users and roles that use the policy to set the permissions boundary.</p>
    pub permissions_boundary_usage_count: i32,
    /// <p>The unique identifier of the policy.</p>
    pub policy_id: std::option::Option<std::string::String>,
    /// <p>The name of the policy.</p>
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>List of versions of the policy.</p>
    pub policy_version_list: std::option::Option<std::vec::Vec<crate::model::AwsIamPolicyVersion>>,
    /// <p>When the policy was most recently updated.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub update_date: std::option::Option<std::string::String>,
}
impl AwsIamPolicyDetails {
    /// <p>The number of users, groups, and roles that the policy is attached to.</p>
    pub fn attachment_count(&self) -> i32 {
        self.attachment_count
    }
    /// <p>When the policy was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn create_date(&self) -> std::option::Option<&str> {
        self.create_date.as_deref()
    }
    /// <p>The identifier of the default version of the policy.</p>
    pub fn default_version_id(&self) -> std::option::Option<&str> {
        self.default_version_id.as_deref()
    }
    /// <p>A description of the policy.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Whether the policy can be attached to a user, group, or role.</p>
    pub fn is_attachable(&self) -> bool {
        self.is_attachable
    }
    /// <p>The path to the policy.</p>
    pub fn path(&self) -> std::option::Option<&str> {
        self.path.as_deref()
    }
    /// <p>The number of users and roles that use the policy to set the permissions boundary.</p>
    pub fn permissions_boundary_usage_count(&self) -> i32 {
        self.permissions_boundary_usage_count
    }
    /// <p>The unique identifier of the policy.</p>
    pub fn policy_id(&self) -> std::option::Option<&str> {
        self.policy_id.as_deref()
    }
    /// <p>The name of the policy.</p>
    pub fn policy_name(&self) -> std::option::Option<&str> {
        self.policy_name.as_deref()
    }
    /// <p>List of versions of the policy.</p>
    pub fn policy_version_list(&self) -> std::option::Option<&[crate::model::AwsIamPolicyVersion]> {
        self.policy_version_list.as_deref()
    }
    /// <p>When the policy was most recently updated.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn update_date(&self) -> std::option::Option<&str> {
        self.update_date.as_deref()
    }
}
impl std::fmt::Debug for AwsIamPolicyDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsIamPolicyDetails");
        formatter.field("attachment_count", &self.attachment_count);
        formatter.field("create_date", &self.create_date);
        formatter.field("default_version_id", &self.default_version_id);
        formatter.field("description", &self.description);
        formatter.field("is_attachable", &self.is_attachable);
        formatter.field("path", &self.path);
        formatter.field(
            "permissions_boundary_usage_count",
            &self.permissions_boundary_usage_count,
        );
        formatter.field("policy_id", &self.policy_id);
        formatter.field("policy_name", &self.policy_name);
        formatter.field("policy_version_list", &self.policy_version_list);
        formatter.field("update_date", &self.update_date);
        formatter.finish()
    }
}
/// See [`AwsIamPolicyDetails`](crate::model::AwsIamPolicyDetails)
pub mod aws_iam_policy_details {

    /// A builder for [`AwsIamPolicyDetails`](crate::model::AwsIamPolicyDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attachment_count: std::option::Option<i32>,
        pub(crate) create_date: std::option::Option<std::string::String>,
        pub(crate) default_version_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) is_attachable: std::option::Option<bool>,
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) permissions_boundary_usage_count: std::option::Option<i32>,
        pub(crate) policy_id: std::option::Option<std::string::String>,
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) policy_version_list:
            std::option::Option<std::vec::Vec<crate::model::AwsIamPolicyVersion>>,
        pub(crate) update_date: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The number of users, groups, and roles that the policy is attached to.</p>
        pub fn attachment_count(mut self, input: i32) -> Self {
            self.attachment_count = Some(input);
            self
        }
        /// <p>The number of users, groups, and roles that the policy is attached to.</p>
        pub fn set_attachment_count(mut self, input: std::option::Option<i32>) -> Self {
            self.attachment_count = input;
            self
        }
        /// <p>When the policy was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn create_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.create_date = Some(input.into());
            self
        }
        /// <p>When the policy was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_create_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.create_date = input;
            self
        }
        /// <p>The identifier of the default version of the policy.</p>
        pub fn default_version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_version_id = Some(input.into());
            self
        }
        /// <p>The identifier of the default version of the policy.</p>
        pub fn set_default_version_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_version_id = input;
            self
        }
        /// <p>A description of the policy.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the policy.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Whether the policy can be attached to a user, group, or role.</p>
        pub fn is_attachable(mut self, input: bool) -> Self {
            self.is_attachable = Some(input);
            self
        }
        /// <p>Whether the policy can be attached to a user, group, or role.</p>
        pub fn set_is_attachable(mut self, input: std::option::Option<bool>) -> Self {
            self.is_attachable = input;
            self
        }
        /// <p>The path to the policy.</p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.path = Some(input.into());
            self
        }
        /// <p>The path to the policy.</p>
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path = input;
            self
        }
        /// <p>The number of users and roles that use the policy to set the permissions boundary.</p>
        pub fn permissions_boundary_usage_count(mut self, input: i32) -> Self {
            self.permissions_boundary_usage_count = Some(input);
            self
        }
        /// <p>The number of users and roles that use the policy to set the permissions boundary.</p>
        pub fn set_permissions_boundary_usage_count(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.permissions_boundary_usage_count = input;
            self
        }
        /// <p>The unique identifier of the policy.</p>
        pub fn policy_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the policy.</p>
        pub fn set_policy_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_id = input;
            self
        }
        /// <p>The name of the policy.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        /// <p>The name of the policy.</p>
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// Appends an item to `policy_version_list`.
        ///
        /// To override the contents of this collection use [`set_policy_version_list`](Self::set_policy_version_list).
        ///
        /// <p>List of versions of the policy.</p>
        pub fn policy_version_list(mut self, input: crate::model::AwsIamPolicyVersion) -> Self {
            let mut v = self.policy_version_list.unwrap_or_default();
            v.push(input);
            self.policy_version_list = Some(v);
            self
        }
        /// <p>List of versions of the policy.</p>
        pub fn set_policy_version_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsIamPolicyVersion>>,
        ) -> Self {
            self.policy_version_list = input;
            self
        }
        /// <p>When the policy was most recently updated.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn update_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.update_date = Some(input.into());
            self
        }
        /// <p>When the policy was most recently updated.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_update_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.update_date = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsIamPolicyDetails`](crate::model::AwsIamPolicyDetails)
        pub fn build(self) -> crate::model::AwsIamPolicyDetails {
            crate::model::AwsIamPolicyDetails {
                attachment_count: self.attachment_count.unwrap_or_default(),
                create_date: self.create_date,
                default_version_id: self.default_version_id,
                description: self.description,
                is_attachable: self.is_attachable.unwrap_or_default(),
                path: self.path,
                permissions_boundary_usage_count: self
                    .permissions_boundary_usage_count
                    .unwrap_or_default(),
                policy_id: self.policy_id,
                policy_name: self.policy_name,
                policy_version_list: self.policy_version_list,
                update_date: self.update_date,
            }
        }
    }
}
impl AwsIamPolicyDetails {
    /// Creates a new builder-style object to manufacture [`AwsIamPolicyDetails`](crate::model::AwsIamPolicyDetails)
    pub fn builder() -> crate::model::aws_iam_policy_details::Builder {
        crate::model::aws_iam_policy_details::Builder::default()
    }
}

/// <p>A version of an IAM policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsIamPolicyVersion {
    /// <p>The identifier of the policy version.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>Whether the version is the default version.</p>
    pub is_default_version: bool,
    /// <p>Indicates when the version was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub create_date: std::option::Option<std::string::String>,
}
impl AwsIamPolicyVersion {
    /// <p>The identifier of the policy version.</p>
    pub fn version_id(&self) -> std::option::Option<&str> {
        self.version_id.as_deref()
    }
    /// <p>Whether the version is the default version.</p>
    pub fn is_default_version(&self) -> bool {
        self.is_default_version
    }
    /// <p>Indicates when the version was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn create_date(&self) -> std::option::Option<&str> {
        self.create_date.as_deref()
    }
}
impl std::fmt::Debug for AwsIamPolicyVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsIamPolicyVersion");
        formatter.field("version_id", &self.version_id);
        formatter.field("is_default_version", &self.is_default_version);
        formatter.field("create_date", &self.create_date);
        formatter.finish()
    }
}
/// See [`AwsIamPolicyVersion`](crate::model::AwsIamPolicyVersion)
pub mod aws_iam_policy_version {

    /// A builder for [`AwsIamPolicyVersion`](crate::model::AwsIamPolicyVersion)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) is_default_version: std::option::Option<bool>,
        pub(crate) create_date: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the policy version.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        /// <p>The identifier of the policy version.</p>
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>Whether the version is the default version.</p>
        pub fn is_default_version(mut self, input: bool) -> Self {
            self.is_default_version = Some(input);
            self
        }
        /// <p>Whether the version is the default version.</p>
        pub fn set_is_default_version(mut self, input: std::option::Option<bool>) -> Self {
            self.is_default_version = input;
            self
        }
        /// <p>Indicates when the version was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn create_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.create_date = Some(input.into());
            self
        }
        /// <p>Indicates when the version was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_create_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.create_date = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsIamPolicyVersion`](crate::model::AwsIamPolicyVersion)
        pub fn build(self) -> crate::model::AwsIamPolicyVersion {
            crate::model::AwsIamPolicyVersion {
                version_id: self.version_id,
                is_default_version: self.is_default_version.unwrap_or_default(),
                create_date: self.create_date,
            }
        }
    }
}
impl AwsIamPolicyVersion {
    /// Creates a new builder-style object to manufacture [`AwsIamPolicyVersion`](crate::model::AwsIamPolicyVersion)
    pub fn builder() -> crate::model::aws_iam_policy_version::Builder {
        crate::model::aws_iam_policy_version::Builder::default()
    }
}

/// <p>Information about an IAM user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsIamUserDetails {
    /// <p>A list of the managed policies that are attached to the user.</p>
    pub attached_managed_policies:
        std::option::Option<std::vec::Vec<crate::model::AwsIamAttachedManagedPolicy>>,
    /// <p>Indicates when the user was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub create_date: std::option::Option<std::string::String>,
    /// <p>A list of IAM groups that the user belongs to.</p>
    pub group_list: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The path to the user.</p>
    pub path: std::option::Option<std::string::String>,
    /// <p>The permissions boundary for the user.</p>
    pub permissions_boundary: std::option::Option<crate::model::AwsIamPermissionsBoundary>,
    /// <p>The unique identifier for the user.</p>
    pub user_id: std::option::Option<std::string::String>,
    /// <p>The name of the user.</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The list of inline policies that are embedded in the user.</p>
    pub user_policy_list: std::option::Option<std::vec::Vec<crate::model::AwsIamUserPolicy>>,
}
impl AwsIamUserDetails {
    /// <p>A list of the managed policies that are attached to the user.</p>
    pub fn attached_managed_policies(
        &self,
    ) -> std::option::Option<&[crate::model::AwsIamAttachedManagedPolicy]> {
        self.attached_managed_policies.as_deref()
    }
    /// <p>Indicates when the user was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn create_date(&self) -> std::option::Option<&str> {
        self.create_date.as_deref()
    }
    /// <p>A list of IAM groups that the user belongs to.</p>
    pub fn group_list(&self) -> std::option::Option<&[std::string::String]> {
        self.group_list.as_deref()
    }
    /// <p>The path to the user.</p>
    pub fn path(&self) -> std::option::Option<&str> {
        self.path.as_deref()
    }
    /// <p>The permissions boundary for the user.</p>
    pub fn permissions_boundary(
        &self,
    ) -> std::option::Option<&crate::model::AwsIamPermissionsBoundary> {
        self.permissions_boundary.as_ref()
    }
    /// <p>The unique identifier for the user.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
    /// <p>The name of the user.</p>
    pub fn user_name(&self) -> std::option::Option<&str> {
        self.user_name.as_deref()
    }
    /// <p>The list of inline policies that are embedded in the user.</p>
    pub fn user_policy_list(&self) -> std::option::Option<&[crate::model::AwsIamUserPolicy]> {
        self.user_policy_list.as_deref()
    }
}
impl std::fmt::Debug for AwsIamUserDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsIamUserDetails");
        formatter.field("attached_managed_policies", &self.attached_managed_policies);
        formatter.field("create_date", &self.create_date);
        formatter.field("group_list", &self.group_list);
        formatter.field("path", &self.path);
        formatter.field("permissions_boundary", &self.permissions_boundary);
        formatter.field("user_id", &self.user_id);
        formatter.field("user_name", &self.user_name);
        formatter.field("user_policy_list", &self.user_policy_list);
        formatter.finish()
    }
}
/// See [`AwsIamUserDetails`](crate::model::AwsIamUserDetails)
pub mod aws_iam_user_details {

    /// A builder for [`AwsIamUserDetails`](crate::model::AwsIamUserDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attached_managed_policies:
            std::option::Option<std::vec::Vec<crate::model::AwsIamAttachedManagedPolicy>>,
        pub(crate) create_date: std::option::Option<std::string::String>,
        pub(crate) group_list: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) permissions_boundary:
            std::option::Option<crate::model::AwsIamPermissionsBoundary>,
        pub(crate) user_id: std::option::Option<std::string::String>,
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) user_policy_list:
            std::option::Option<std::vec::Vec<crate::model::AwsIamUserPolicy>>,
    }
    impl Builder {
        /// Appends an item to `attached_managed_policies`.
        ///
        /// To override the contents of this collection use [`set_attached_managed_policies`](Self::set_attached_managed_policies).
        ///
        /// <p>A list of the managed policies that are attached to the user.</p>
        pub fn attached_managed_policies(
            mut self,
            input: crate::model::AwsIamAttachedManagedPolicy,
        ) -> Self {
            let mut v = self.attached_managed_policies.unwrap_or_default();
            v.push(input);
            self.attached_managed_policies = Some(v);
            self
        }
        /// <p>A list of the managed policies that are attached to the user.</p>
        pub fn set_attached_managed_policies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsIamAttachedManagedPolicy>>,
        ) -> Self {
            self.attached_managed_policies = input;
            self
        }
        /// <p>Indicates when the user was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn create_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.create_date = Some(input.into());
            self
        }
        /// <p>Indicates when the user was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_create_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.create_date = input;
            self
        }
        /// Appends an item to `group_list`.
        ///
        /// To override the contents of this collection use [`set_group_list`](Self::set_group_list).
        ///
        /// <p>A list of IAM groups that the user belongs to.</p>
        pub fn group_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.group_list.unwrap_or_default();
            v.push(input.into());
            self.group_list = Some(v);
            self
        }
        /// <p>A list of IAM groups that the user belongs to.</p>
        pub fn set_group_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.group_list = input;
            self
        }
        /// <p>The path to the user.</p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.path = Some(input.into());
            self
        }
        /// <p>The path to the user.</p>
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path = input;
            self
        }
        /// <p>The permissions boundary for the user.</p>
        pub fn permissions_boundary(
            mut self,
            input: crate::model::AwsIamPermissionsBoundary,
        ) -> Self {
            self.permissions_boundary = Some(input);
            self
        }
        /// <p>The permissions boundary for the user.</p>
        pub fn set_permissions_boundary(
            mut self,
            input: std::option::Option<crate::model::AwsIamPermissionsBoundary>,
        ) -> Self {
            self.permissions_boundary = input;
            self
        }
        /// <p>The unique identifier for the user.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the user.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// <p>The name of the user.</p>
        pub fn user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_name = Some(input.into());
            self
        }
        /// <p>The name of the user.</p>
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_name = input;
            self
        }
        /// Appends an item to `user_policy_list`.
        ///
        /// To override the contents of this collection use [`set_user_policy_list`](Self::set_user_policy_list).
        ///
        /// <p>The list of inline policies that are embedded in the user.</p>
        pub fn user_policy_list(mut self, input: crate::model::AwsIamUserPolicy) -> Self {
            let mut v = self.user_policy_list.unwrap_or_default();
            v.push(input);
            self.user_policy_list = Some(v);
            self
        }
        /// <p>The list of inline policies that are embedded in the user.</p>
        pub fn set_user_policy_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsIamUserPolicy>>,
        ) -> Self {
            self.user_policy_list = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsIamUserDetails`](crate::model::AwsIamUserDetails)
        pub fn build(self) -> crate::model::AwsIamUserDetails {
            crate::model::AwsIamUserDetails {
                attached_managed_policies: self.attached_managed_policies,
                create_date: self.create_date,
                group_list: self.group_list,
                path: self.path,
                permissions_boundary: self.permissions_boundary,
                user_id: self.user_id,
                user_name: self.user_name,
                user_policy_list: self.user_policy_list,
            }
        }
    }
}
impl AwsIamUserDetails {
    /// Creates a new builder-style object to manufacture [`AwsIamUserDetails`](crate::model::AwsIamUserDetails)
    pub fn builder() -> crate::model::aws_iam_user_details::Builder {
        crate::model::aws_iam_user_details::Builder::default()
    }
}

/// <p>Information about an inline policy that is embedded in the user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsIamUserPolicy {
    /// <p>The name of the policy.</p>
    pub policy_name: std::option::Option<std::string::String>,
}
impl AwsIamUserPolicy {
    /// <p>The name of the policy.</p>
    pub fn policy_name(&self) -> std::option::Option<&str> {
        self.policy_name.as_deref()
    }
}
impl std::fmt::Debug for AwsIamUserPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsIamUserPolicy");
        formatter.field("policy_name", &self.policy_name);
        formatter.finish()
    }
}
/// See [`AwsIamUserPolicy`](crate::model::AwsIamUserPolicy)
pub mod aws_iam_user_policy {

    /// A builder for [`AwsIamUserPolicy`](crate::model::AwsIamUserPolicy)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the policy.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        /// <p>The name of the policy.</p>
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsIamUserPolicy`](crate::model::AwsIamUserPolicy)
        pub fn build(self) -> crate::model::AwsIamUserPolicy {
            crate::model::AwsIamUserPolicy {
                policy_name: self.policy_name,
            }
        }
    }
}
impl AwsIamUserPolicy {
    /// Creates a new builder-style object to manufacture [`AwsIamUserPolicy`](crate::model::AwsIamUserPolicy)
    pub fn builder() -> crate::model::aws_iam_user_policy::Builder {
        crate::model::aws_iam_user_policy::Builder::default()
    }
}

/// <p>IAM access key details related to a finding.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsIamAccessKeyDetails {
    /// <p>The user associated with the IAM access key related to a finding.</p>
    /// <p>The <code>UserName</code> parameter has been replaced with the <code>PrincipalName</code> parameter because access keys can also be assigned to principals that are not IAM users.</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The status of the IAM access key related to a finding.</p>
    pub status: std::option::Option<crate::model::AwsIamAccessKeyStatus>,
    /// <p>Indicates when the IAM access key was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub created_at: std::option::Option<std::string::String>,
    /// <p>The ID of the principal associated with an access key.</p>
    pub principal_id: std::option::Option<std::string::String>,
    /// <p>The type of principal associated with an access key.</p>
    pub principal_type: std::option::Option<std::string::String>,
    /// <p>The name of the principal.</p>
    pub principal_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID of the account for the key.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the access key.</p>
    pub access_key_id: std::option::Option<std::string::String>,
    /// <p>Information about the session that the key was used for.</p>
    pub session_context: std::option::Option<crate::model::AwsIamAccessKeySessionContext>,
}
impl AwsIamAccessKeyDetails {
    /// <p>The user associated with the IAM access key related to a finding.</p>
    /// <p>The <code>UserName</code> parameter has been replaced with the <code>PrincipalName</code> parameter because access keys can also be assigned to principals that are not IAM users.</p>
    pub fn user_name(&self) -> std::option::Option<&str> {
        self.user_name.as_deref()
    }
    /// <p>The status of the IAM access key related to a finding.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::AwsIamAccessKeyStatus> {
        self.status.as_ref()
    }
    /// <p>Indicates when the IAM access key was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn created_at(&self) -> std::option::Option<&str> {
        self.created_at.as_deref()
    }
    /// <p>The ID of the principal associated with an access key.</p>
    pub fn principal_id(&self) -> std::option::Option<&str> {
        self.principal_id.as_deref()
    }
    /// <p>The type of principal associated with an access key.</p>
    pub fn principal_type(&self) -> std::option::Option<&str> {
        self.principal_type.as_deref()
    }
    /// <p>The name of the principal.</p>
    pub fn principal_name(&self) -> std::option::Option<&str> {
        self.principal_name.as_deref()
    }
    /// <p>The Amazon Web Services account ID of the account for the key.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The identifier of the access key.</p>
    pub fn access_key_id(&self) -> std::option::Option<&str> {
        self.access_key_id.as_deref()
    }
    /// <p>Information about the session that the key was used for.</p>
    pub fn session_context(
        &self,
    ) -> std::option::Option<&crate::model::AwsIamAccessKeySessionContext> {
        self.session_context.as_ref()
    }
}
impl std::fmt::Debug for AwsIamAccessKeyDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsIamAccessKeyDetails");
        formatter.field("user_name", &self.user_name);
        formatter.field("status", &self.status);
        formatter.field("created_at", &self.created_at);
        formatter.field("principal_id", &self.principal_id);
        formatter.field("principal_type", &self.principal_type);
        formatter.field("principal_name", &self.principal_name);
        formatter.field("account_id", &self.account_id);
        formatter.field("access_key_id", &self.access_key_id);
        formatter.field("session_context", &self.session_context);
        formatter.finish()
    }
}
/// See [`AwsIamAccessKeyDetails`](crate::model::AwsIamAccessKeyDetails)
pub mod aws_iam_access_key_details {

    /// A builder for [`AwsIamAccessKeyDetails`](crate::model::AwsIamAccessKeyDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::AwsIamAccessKeyStatus>,
        pub(crate) created_at: std::option::Option<std::string::String>,
        pub(crate) principal_id: std::option::Option<std::string::String>,
        pub(crate) principal_type: std::option::Option<std::string::String>,
        pub(crate) principal_name: std::option::Option<std::string::String>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) access_key_id: std::option::Option<std::string::String>,
        pub(crate) session_context:
            std::option::Option<crate::model::AwsIamAccessKeySessionContext>,
    }
    impl Builder {
        /// <p>The user associated with the IAM access key related to a finding.</p>
        /// <p>The <code>UserName</code> parameter has been replaced with the <code>PrincipalName</code> parameter because access keys can also be assigned to principals that are not IAM users.</p>
        pub fn user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_name = Some(input.into());
            self
        }
        /// <p>The user associated with the IAM access key related to a finding.</p>
        /// <p>The <code>UserName</code> parameter has been replaced with the <code>PrincipalName</code> parameter because access keys can also be assigned to principals that are not IAM users.</p>
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_name = input;
            self
        }
        /// <p>The status of the IAM access key related to a finding.</p>
        pub fn status(mut self, input: crate::model::AwsIamAccessKeyStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the IAM access key related to a finding.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AwsIamAccessKeyStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Indicates when the IAM access key was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn created_at(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_at = Some(input.into());
            self
        }
        /// <p>Indicates when the IAM access key was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_created_at(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The ID of the principal associated with an access key.</p>
        pub fn principal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal_id = Some(input.into());
            self
        }
        /// <p>The ID of the principal associated with an access key.</p>
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal_id = input;
            self
        }
        /// <p>The type of principal associated with an access key.</p>
        pub fn principal_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal_type = Some(input.into());
            self
        }
        /// <p>The type of principal associated with an access key.</p>
        pub fn set_principal_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.principal_type = input;
            self
        }
        /// <p>The name of the principal.</p>
        pub fn principal_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal_name = Some(input.into());
            self
        }
        /// <p>The name of the principal.</p>
        pub fn set_principal_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.principal_name = input;
            self
        }
        /// <p>The Amazon Web Services account ID of the account for the key.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID of the account for the key.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The identifier of the access key.</p>
        pub fn access_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.access_key_id = Some(input.into());
            self
        }
        /// <p>The identifier of the access key.</p>
        pub fn set_access_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.access_key_id = input;
            self
        }
        /// <p>Information about the session that the key was used for.</p>
        pub fn session_context(
            mut self,
            input: crate::model::AwsIamAccessKeySessionContext,
        ) -> Self {
            self.session_context = Some(input);
            self
        }
        /// <p>Information about the session that the key was used for.</p>
        pub fn set_session_context(
            mut self,
            input: std::option::Option<crate::model::AwsIamAccessKeySessionContext>,
        ) -> Self {
            self.session_context = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsIamAccessKeyDetails`](crate::model::AwsIamAccessKeyDetails)
        pub fn build(self) -> crate::model::AwsIamAccessKeyDetails {
            crate::model::AwsIamAccessKeyDetails {
                user_name: self.user_name,
                status: self.status,
                created_at: self.created_at,
                principal_id: self.principal_id,
                principal_type: self.principal_type,
                principal_name: self.principal_name,
                account_id: self.account_id,
                access_key_id: self.access_key_id,
                session_context: self.session_context,
            }
        }
    }
}
impl AwsIamAccessKeyDetails {
    /// Creates a new builder-style object to manufacture [`AwsIamAccessKeyDetails`](crate::model::AwsIamAccessKeyDetails)
    pub fn builder() -> crate::model::aws_iam_access_key_details::Builder {
        crate::model::aws_iam_access_key_details::Builder::default()
    }
}

/// <p>Provides information about the session that the key was used for.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsIamAccessKeySessionContext {
    /// <p>Attributes of the session that the key was used for.</p>
    pub attributes: std::option::Option<crate::model::AwsIamAccessKeySessionContextAttributes>,
    /// <p>Information about the entity that created the session.</p>
    pub session_issuer:
        std::option::Option<crate::model::AwsIamAccessKeySessionContextSessionIssuer>,
}
impl AwsIamAccessKeySessionContext {
    /// <p>Attributes of the session that the key was used for.</p>
    pub fn attributes(
        &self,
    ) -> std::option::Option<&crate::model::AwsIamAccessKeySessionContextAttributes> {
        self.attributes.as_ref()
    }
    /// <p>Information about the entity that created the session.</p>
    pub fn session_issuer(
        &self,
    ) -> std::option::Option<&crate::model::AwsIamAccessKeySessionContextSessionIssuer> {
        self.session_issuer.as_ref()
    }
}
impl std::fmt::Debug for AwsIamAccessKeySessionContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsIamAccessKeySessionContext");
        formatter.field("attributes", &self.attributes);
        formatter.field("session_issuer", &self.session_issuer);
        formatter.finish()
    }
}
/// See [`AwsIamAccessKeySessionContext`](crate::model::AwsIamAccessKeySessionContext)
pub mod aws_iam_access_key_session_context {

    /// A builder for [`AwsIamAccessKeySessionContext`](crate::model::AwsIamAccessKeySessionContext)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attributes:
            std::option::Option<crate::model::AwsIamAccessKeySessionContextAttributes>,
        pub(crate) session_issuer:
            std::option::Option<crate::model::AwsIamAccessKeySessionContextSessionIssuer>,
    }
    impl Builder {
        /// <p>Attributes of the session that the key was used for.</p>
        pub fn attributes(
            mut self,
            input: crate::model::AwsIamAccessKeySessionContextAttributes,
        ) -> Self {
            self.attributes = Some(input);
            self
        }
        /// <p>Attributes of the session that the key was used for.</p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<crate::model::AwsIamAccessKeySessionContextAttributes>,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// <p>Information about the entity that created the session.</p>
        pub fn session_issuer(
            mut self,
            input: crate::model::AwsIamAccessKeySessionContextSessionIssuer,
        ) -> Self {
            self.session_issuer = Some(input);
            self
        }
        /// <p>Information about the entity that created the session.</p>
        pub fn set_session_issuer(
            mut self,
            input: std::option::Option<crate::model::AwsIamAccessKeySessionContextSessionIssuer>,
        ) -> Self {
            self.session_issuer = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsIamAccessKeySessionContext`](crate::model::AwsIamAccessKeySessionContext)
        pub fn build(self) -> crate::model::AwsIamAccessKeySessionContext {
            crate::model::AwsIamAccessKeySessionContext {
                attributes: self.attributes,
                session_issuer: self.session_issuer,
            }
        }
    }
}
impl AwsIamAccessKeySessionContext {
    /// Creates a new builder-style object to manufacture [`AwsIamAccessKeySessionContext`](crate::model::AwsIamAccessKeySessionContext)
    pub fn builder() -> crate::model::aws_iam_access_key_session_context::Builder {
        crate::model::aws_iam_access_key_session_context::Builder::default()
    }
}

/// <p>Information about the entity that created the session.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsIamAccessKeySessionContextSessionIssuer {
    /// <p>The type of principal (user, role, or group) that created the session.</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The principal ID of the principal (user, role, or group) that created the session.</p>
    pub principal_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the session.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Web Services account that created the session.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The name of the principal that created the session.</p>
    pub user_name: std::option::Option<std::string::String>,
}
impl AwsIamAccessKeySessionContextSessionIssuer {
    /// <p>The type of principal (user, role, or group) that created the session.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The principal ID of the principal (user, role, or group) that created the session.</p>
    pub fn principal_id(&self) -> std::option::Option<&str> {
        self.principal_id.as_deref()
    }
    /// <p>The ARN of the session.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The identifier of the Amazon Web Services account that created the session.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The name of the principal that created the session.</p>
    pub fn user_name(&self) -> std::option::Option<&str> {
        self.user_name.as_deref()
    }
}
impl std::fmt::Debug for AwsIamAccessKeySessionContextSessionIssuer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsIamAccessKeySessionContextSessionIssuer");
        formatter.field("r#type", &self.r#type);
        formatter.field("principal_id", &self.principal_id);
        formatter.field("arn", &self.arn);
        formatter.field("account_id", &self.account_id);
        formatter.field("user_name", &self.user_name);
        formatter.finish()
    }
}
/// See [`AwsIamAccessKeySessionContextSessionIssuer`](crate::model::AwsIamAccessKeySessionContextSessionIssuer)
pub mod aws_iam_access_key_session_context_session_issuer {

    /// A builder for [`AwsIamAccessKeySessionContextSessionIssuer`](crate::model::AwsIamAccessKeySessionContextSessionIssuer)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) principal_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) user_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of principal (user, role, or group) that created the session.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of principal (user, role, or group) that created the session.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The principal ID of the principal (user, role, or group) that created the session.</p>
        pub fn principal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal_id = Some(input.into());
            self
        }
        /// <p>The principal ID of the principal (user, role, or group) that created the session.</p>
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal_id = input;
            self
        }
        /// <p>The ARN of the session.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the session.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The identifier of the Amazon Web Services account that created the session.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Web Services account that created the session.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The name of the principal that created the session.</p>
        pub fn user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_name = Some(input.into());
            self
        }
        /// <p>The name of the principal that created the session.</p>
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsIamAccessKeySessionContextSessionIssuer`](crate::model::AwsIamAccessKeySessionContextSessionIssuer)
        pub fn build(self) -> crate::model::AwsIamAccessKeySessionContextSessionIssuer {
            crate::model::AwsIamAccessKeySessionContextSessionIssuer {
                r#type: self.r#type,
                principal_id: self.principal_id,
                arn: self.arn,
                account_id: self.account_id,
                user_name: self.user_name,
            }
        }
    }
}
impl AwsIamAccessKeySessionContextSessionIssuer {
    /// Creates a new builder-style object to manufacture [`AwsIamAccessKeySessionContextSessionIssuer`](crate::model::AwsIamAccessKeySessionContextSessionIssuer)
    pub fn builder() -> crate::model::aws_iam_access_key_session_context_session_issuer::Builder {
        crate::model::aws_iam_access_key_session_context_session_issuer::Builder::default()
    }
}

/// <p>Attributes of the session that the key was used for.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsIamAccessKeySessionContextAttributes {
    /// <p>Indicates whether the session used multi-factor authentication (MFA).</p>
    pub mfa_authenticated: bool,
    /// <p>Indicates when the session was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub creation_date: std::option::Option<std::string::String>,
}
impl AwsIamAccessKeySessionContextAttributes {
    /// <p>Indicates whether the session used multi-factor authentication (MFA).</p>
    pub fn mfa_authenticated(&self) -> bool {
        self.mfa_authenticated
    }
    /// <p>Indicates when the session was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn creation_date(&self) -> std::option::Option<&str> {
        self.creation_date.as_deref()
    }
}
impl std::fmt::Debug for AwsIamAccessKeySessionContextAttributes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsIamAccessKeySessionContextAttributes");
        formatter.field("mfa_authenticated", &self.mfa_authenticated);
        formatter.field("creation_date", &self.creation_date);
        formatter.finish()
    }
}
/// See [`AwsIamAccessKeySessionContextAttributes`](crate::model::AwsIamAccessKeySessionContextAttributes)
pub mod aws_iam_access_key_session_context_attributes {

    /// A builder for [`AwsIamAccessKeySessionContextAttributes`](crate::model::AwsIamAccessKeySessionContextAttributes)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mfa_authenticated: std::option::Option<bool>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates whether the session used multi-factor authentication (MFA).</p>
        pub fn mfa_authenticated(mut self, input: bool) -> Self {
            self.mfa_authenticated = Some(input);
            self
        }
        /// <p>Indicates whether the session used multi-factor authentication (MFA).</p>
        pub fn set_mfa_authenticated(mut self, input: std::option::Option<bool>) -> Self {
            self.mfa_authenticated = input;
            self
        }
        /// <p>Indicates when the session was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>Indicates when the session was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsIamAccessKeySessionContextAttributes`](crate::model::AwsIamAccessKeySessionContextAttributes)
        pub fn build(self) -> crate::model::AwsIamAccessKeySessionContextAttributes {
            crate::model::AwsIamAccessKeySessionContextAttributes {
                mfa_authenticated: self.mfa_authenticated.unwrap_or_default(),
                creation_date: self.creation_date,
            }
        }
    }
}
impl AwsIamAccessKeySessionContextAttributes {
    /// Creates a new builder-style object to manufacture [`AwsIamAccessKeySessionContextAttributes`](crate::model::AwsIamAccessKeySessionContextAttributes)
    pub fn builder() -> crate::model::aws_iam_access_key_session_context_attributes::Builder {
        crate::model::aws_iam_access_key_session_context_attributes::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AwsIamAccessKeyStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Inactive,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AwsIamAccessKeyStatus {
    fn from(s: &str) -> Self {
        match s {
            "Active" => AwsIamAccessKeyStatus::Active,
            "Inactive" => AwsIamAccessKeyStatus::Inactive,
            other => AwsIamAccessKeyStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AwsIamAccessKeyStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AwsIamAccessKeyStatus::from(s))
    }
}
impl AwsIamAccessKeyStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AwsIamAccessKeyStatus::Active => "Active",
            AwsIamAccessKeyStatus::Inactive => "Inactive",
            AwsIamAccessKeyStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Active", "Inactive"]
    }
}
impl AsRef<str> for AwsIamAccessKeyStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Details about an Secrets Manager secret.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsSecretsManagerSecretDetails {
    /// <p>Defines the rotation schedule for the secret.</p>
    pub rotation_rules: std::option::Option<crate::model::AwsSecretsManagerSecretRotationRules>,
    /// <p>Whether the rotation occurred within the specified rotation frequency.</p>
    pub rotation_occurred_within_frequency: bool,
    /// <p>The ARN, Key ID, or alias of the KMS key used to encrypt the <code>SecretString</code> or <code>SecretBinary</code> values for versions of this secret.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>Whether rotation is enabled.</p>
    pub rotation_enabled: bool,
    /// <p>The ARN of the Lambda function that rotates the secret.</p>
    pub rotation_lambda_arn: std::option::Option<std::string::String>,
    /// <p>Whether the secret is deleted.</p>
    pub deleted: bool,
    /// <p>The name of the secret.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The user-provided description of the secret.</p>
    pub description: std::option::Option<std::string::String>,
}
impl AwsSecretsManagerSecretDetails {
    /// <p>Defines the rotation schedule for the secret.</p>
    pub fn rotation_rules(
        &self,
    ) -> std::option::Option<&crate::model::AwsSecretsManagerSecretRotationRules> {
        self.rotation_rules.as_ref()
    }
    /// <p>Whether the rotation occurred within the specified rotation frequency.</p>
    pub fn rotation_occurred_within_frequency(&self) -> bool {
        self.rotation_occurred_within_frequency
    }
    /// <p>The ARN, Key ID, or alias of the KMS key used to encrypt the <code>SecretString</code> or <code>SecretBinary</code> values for versions of this secret.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>Whether rotation is enabled.</p>
    pub fn rotation_enabled(&self) -> bool {
        self.rotation_enabled
    }
    /// <p>The ARN of the Lambda function that rotates the secret.</p>
    pub fn rotation_lambda_arn(&self) -> std::option::Option<&str> {
        self.rotation_lambda_arn.as_deref()
    }
    /// <p>Whether the secret is deleted.</p>
    pub fn deleted(&self) -> bool {
        self.deleted
    }
    /// <p>The name of the secret.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The user-provided description of the secret.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
impl std::fmt::Debug for AwsSecretsManagerSecretDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsSecretsManagerSecretDetails");
        formatter.field("rotation_rules", &self.rotation_rules);
        formatter.field(
            "rotation_occurred_within_frequency",
            &self.rotation_occurred_within_frequency,
        );
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("rotation_enabled", &self.rotation_enabled);
        formatter.field("rotation_lambda_arn", &self.rotation_lambda_arn);
        formatter.field("deleted", &self.deleted);
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.finish()
    }
}
/// See [`AwsSecretsManagerSecretDetails`](crate::model::AwsSecretsManagerSecretDetails)
pub mod aws_secrets_manager_secret_details {

    /// A builder for [`AwsSecretsManagerSecretDetails`](crate::model::AwsSecretsManagerSecretDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rotation_rules:
            std::option::Option<crate::model::AwsSecretsManagerSecretRotationRules>,
        pub(crate) rotation_occurred_within_frequency: std::option::Option<bool>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) rotation_enabled: std::option::Option<bool>,
        pub(crate) rotation_lambda_arn: std::option::Option<std::string::String>,
        pub(crate) deleted: std::option::Option<bool>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Defines the rotation schedule for the secret.</p>
        pub fn rotation_rules(
            mut self,
            input: crate::model::AwsSecretsManagerSecretRotationRules,
        ) -> Self {
            self.rotation_rules = Some(input);
            self
        }
        /// <p>Defines the rotation schedule for the secret.</p>
        pub fn set_rotation_rules(
            mut self,
            input: std::option::Option<crate::model::AwsSecretsManagerSecretRotationRules>,
        ) -> Self {
            self.rotation_rules = input;
            self
        }
        /// <p>Whether the rotation occurred within the specified rotation frequency.</p>
        pub fn rotation_occurred_within_frequency(mut self, input: bool) -> Self {
            self.rotation_occurred_within_frequency = Some(input);
            self
        }
        /// <p>Whether the rotation occurred within the specified rotation frequency.</p>
        pub fn set_rotation_occurred_within_frequency(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.rotation_occurred_within_frequency = input;
            self
        }
        /// <p>The ARN, Key ID, or alias of the KMS key used to encrypt the <code>SecretString</code> or <code>SecretBinary</code> values for versions of this secret.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The ARN, Key ID, or alias of the KMS key used to encrypt the <code>SecretString</code> or <code>SecretBinary</code> values for versions of this secret.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>Whether rotation is enabled.</p>
        pub fn rotation_enabled(mut self, input: bool) -> Self {
            self.rotation_enabled = Some(input);
            self
        }
        /// <p>Whether rotation is enabled.</p>
        pub fn set_rotation_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.rotation_enabled = input;
            self
        }
        /// <p>The ARN of the Lambda function that rotates the secret.</p>
        pub fn rotation_lambda_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.rotation_lambda_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the Lambda function that rotates the secret.</p>
        pub fn set_rotation_lambda_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rotation_lambda_arn = input;
            self
        }
        /// <p>Whether the secret is deleted.</p>
        pub fn deleted(mut self, input: bool) -> Self {
            self.deleted = Some(input);
            self
        }
        /// <p>Whether the secret is deleted.</p>
        pub fn set_deleted(mut self, input: std::option::Option<bool>) -> Self {
            self.deleted = input;
            self
        }
        /// <p>The name of the secret.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the secret.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The user-provided description of the secret.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The user-provided description of the secret.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsSecretsManagerSecretDetails`](crate::model::AwsSecretsManagerSecretDetails)
        pub fn build(self) -> crate::model::AwsSecretsManagerSecretDetails {
            crate::model::AwsSecretsManagerSecretDetails {
                rotation_rules: self.rotation_rules,
                rotation_occurred_within_frequency: self
                    .rotation_occurred_within_frequency
                    .unwrap_or_default(),
                kms_key_id: self.kms_key_id,
                rotation_enabled: self.rotation_enabled.unwrap_or_default(),
                rotation_lambda_arn: self.rotation_lambda_arn,
                deleted: self.deleted.unwrap_or_default(),
                name: self.name,
                description: self.description,
            }
        }
    }
}
impl AwsSecretsManagerSecretDetails {
    /// Creates a new builder-style object to manufacture [`AwsSecretsManagerSecretDetails`](crate::model::AwsSecretsManagerSecretDetails)
    pub fn builder() -> crate::model::aws_secrets_manager_secret_details::Builder {
        crate::model::aws_secrets_manager_secret_details::Builder::default()
    }
}

/// <p>Defines the rotation schedule for the secret.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsSecretsManagerSecretRotationRules {
    /// <p>The number of days after the previous rotation to rotate the secret.</p>
    pub automatically_after_days: i32,
}
impl AwsSecretsManagerSecretRotationRules {
    /// <p>The number of days after the previous rotation to rotate the secret.</p>
    pub fn automatically_after_days(&self) -> i32 {
        self.automatically_after_days
    }
}
impl std::fmt::Debug for AwsSecretsManagerSecretRotationRules {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsSecretsManagerSecretRotationRules");
        formatter.field("automatically_after_days", &self.automatically_after_days);
        formatter.finish()
    }
}
/// See [`AwsSecretsManagerSecretRotationRules`](crate::model::AwsSecretsManagerSecretRotationRules)
pub mod aws_secrets_manager_secret_rotation_rules {

    /// A builder for [`AwsSecretsManagerSecretRotationRules`](crate::model::AwsSecretsManagerSecretRotationRules)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) automatically_after_days: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The number of days after the previous rotation to rotate the secret.</p>
        pub fn automatically_after_days(mut self, input: i32) -> Self {
            self.automatically_after_days = Some(input);
            self
        }
        /// <p>The number of days after the previous rotation to rotate the secret.</p>
        pub fn set_automatically_after_days(mut self, input: std::option::Option<i32>) -> Self {
            self.automatically_after_days = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsSecretsManagerSecretRotationRules`](crate::model::AwsSecretsManagerSecretRotationRules)
        pub fn build(self) -> crate::model::AwsSecretsManagerSecretRotationRules {
            crate::model::AwsSecretsManagerSecretRotationRules {
                automatically_after_days: self.automatically_after_days.unwrap_or_default(),
            }
        }
    }
}
impl AwsSecretsManagerSecretRotationRules {
    /// Creates a new builder-style object to manufacture [`AwsSecretsManagerSecretRotationRules`](crate::model::AwsSecretsManagerSecretRotationRules)
    pub fn builder() -> crate::model::aws_secrets_manager_secret_rotation_rules::Builder {
        crate::model::aws_secrets_manager_secret_rotation_rules::Builder::default()
    }
}

/// <p>Details about an Amazon S3 object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3ObjectDetails {
    /// <p>Indicates when the object was last modified.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub last_modified: std::option::Option<std::string::String>,
    /// <p>The opaque identifier assigned by a web server to a specific version of a resource found at a URL.</p>
    pub e_tag: std::option::Option<std::string::String>,
    /// <p>The version of the object.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>A standard MIME type describing the format of the object data.</p>
    pub content_type: std::option::Option<std::string::String>,
    /// <p>If the object is stored using server-side encryption, the value of the server-side encryption algorithm used when storing this object in Amazon S3.</p>
    pub server_side_encryption: std::option::Option<std::string::String>,
    /// <p>The identifier of the KMS symmetric customer managed key that was used for the object.</p>
    pub ssekms_key_id: std::option::Option<std::string::String>,
}
impl AwsS3ObjectDetails {
    /// <p>Indicates when the object was last modified.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn last_modified(&self) -> std::option::Option<&str> {
        self.last_modified.as_deref()
    }
    /// <p>The opaque identifier assigned by a web server to a specific version of a resource found at a URL.</p>
    pub fn e_tag(&self) -> std::option::Option<&str> {
        self.e_tag.as_deref()
    }
    /// <p>The version of the object.</p>
    pub fn version_id(&self) -> std::option::Option<&str> {
        self.version_id.as_deref()
    }
    /// <p>A standard MIME type describing the format of the object data.</p>
    pub fn content_type(&self) -> std::option::Option<&str> {
        self.content_type.as_deref()
    }
    /// <p>If the object is stored using server-side encryption, the value of the server-side encryption algorithm used when storing this object in Amazon S3.</p>
    pub fn server_side_encryption(&self) -> std::option::Option<&str> {
        self.server_side_encryption.as_deref()
    }
    /// <p>The identifier of the KMS symmetric customer managed key that was used for the object.</p>
    pub fn ssekms_key_id(&self) -> std::option::Option<&str> {
        self.ssekms_key_id.as_deref()
    }
}
impl std::fmt::Debug for AwsS3ObjectDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsS3ObjectDetails");
        formatter.field("last_modified", &self.last_modified);
        formatter.field("e_tag", &self.e_tag);
        formatter.field("version_id", &self.version_id);
        formatter.field("content_type", &self.content_type);
        formatter.field("server_side_encryption", &self.server_side_encryption);
        formatter.field("ssekms_key_id", &self.ssekms_key_id);
        formatter.finish()
    }
}
/// See [`AwsS3ObjectDetails`](crate::model::AwsS3ObjectDetails)
pub mod aws_s3_object_details {

    /// A builder for [`AwsS3ObjectDetails`](crate::model::AwsS3ObjectDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) last_modified: std::option::Option<std::string::String>,
        pub(crate) e_tag: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) content_type: std::option::Option<std::string::String>,
        pub(crate) server_side_encryption: std::option::Option<std::string::String>,
        pub(crate) ssekms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates when the object was last modified.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn last_modified(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified = Some(input.into());
            self
        }
        /// <p>Indicates when the object was last modified.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_last_modified(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified = input;
            self
        }
        /// <p>The opaque identifier assigned by a web server to a specific version of a resource found at a URL.</p>
        pub fn e_tag(mut self, input: impl Into<std::string::String>) -> Self {
            self.e_tag = Some(input.into());
            self
        }
        /// <p>The opaque identifier assigned by a web server to a specific version of a resource found at a URL.</p>
        pub fn set_e_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.e_tag = input;
            self
        }
        /// <p>The version of the object.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        /// <p>The version of the object.</p>
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>A standard MIME type describing the format of the object data.</p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_type = Some(input.into());
            self
        }
        /// <p>A standard MIME type describing the format of the object data.</p>
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_type = input;
            self
        }
        /// <p>If the object is stored using server-side encryption, the value of the server-side encryption algorithm used when storing this object in Amazon S3.</p>
        pub fn server_side_encryption(mut self, input: impl Into<std::string::String>) -> Self {
            self.server_side_encryption = Some(input.into());
            self
        }
        /// <p>If the object is stored using server-side encryption, the value of the server-side encryption algorithm used when storing this object in Amazon S3.</p>
        pub fn set_server_side_encryption(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.server_side_encryption = input;
            self
        }
        /// <p>The identifier of the KMS symmetric customer managed key that was used for the object.</p>
        pub fn ssekms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ssekms_key_id = Some(input.into());
            self
        }
        /// <p>The identifier of the KMS symmetric customer managed key that was used for the object.</p>
        pub fn set_ssekms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ssekms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3ObjectDetails`](crate::model::AwsS3ObjectDetails)
        pub fn build(self) -> crate::model::AwsS3ObjectDetails {
            crate::model::AwsS3ObjectDetails {
                last_modified: self.last_modified,
                e_tag: self.e_tag,
                version_id: self.version_id,
                content_type: self.content_type,
                server_side_encryption: self.server_side_encryption,
                ssekms_key_id: self.ssekms_key_id,
            }
        }
    }
}
impl AwsS3ObjectDetails {
    /// Creates a new builder-style object to manufacture [`AwsS3ObjectDetails`](crate::model::AwsS3ObjectDetails)
    pub fn builder() -> crate::model::aws_s3_object_details::Builder {
        crate::model::aws_s3_object_details::Builder::default()
    }
}

/// <p>provides information about the Amazon S3 Public Access Block configuration for accounts.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3AccountPublicAccessBlockDetails {
    /// <p>Indicates whether to reject calls to update an S3 bucket if the calls include a public access control list (ACL).</p>
    pub block_public_acls: bool,
    /// <p>Indicates whether to reject calls to update the access policy for an S3 bucket or access point if the policy allows public access.</p>
    pub block_public_policy: bool,
    /// <p>Indicates whether Amazon S3 ignores public ACLs that are associated with an S3 bucket.</p>
    pub ignore_public_acls: bool,
    /// <p>Indicates whether to restrict access to an access point or S3 bucket that has a public policy to only Amazon Web Services service principals and authorized users within the S3 bucket owner's account.</p>
    pub restrict_public_buckets: bool,
}
impl AwsS3AccountPublicAccessBlockDetails {
    /// <p>Indicates whether to reject calls to update an S3 bucket if the calls include a public access control list (ACL).</p>
    pub fn block_public_acls(&self) -> bool {
        self.block_public_acls
    }
    /// <p>Indicates whether to reject calls to update the access policy for an S3 bucket or access point if the policy allows public access.</p>
    pub fn block_public_policy(&self) -> bool {
        self.block_public_policy
    }
    /// <p>Indicates whether Amazon S3 ignores public ACLs that are associated with an S3 bucket.</p>
    pub fn ignore_public_acls(&self) -> bool {
        self.ignore_public_acls
    }
    /// <p>Indicates whether to restrict access to an access point or S3 bucket that has a public policy to only Amazon Web Services service principals and authorized users within the S3 bucket owner's account.</p>
    pub fn restrict_public_buckets(&self) -> bool {
        self.restrict_public_buckets
    }
}
impl std::fmt::Debug for AwsS3AccountPublicAccessBlockDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsS3AccountPublicAccessBlockDetails");
        formatter.field("block_public_acls", &self.block_public_acls);
        formatter.field("block_public_policy", &self.block_public_policy);
        formatter.field("ignore_public_acls", &self.ignore_public_acls);
        formatter.field("restrict_public_buckets", &self.restrict_public_buckets);
        formatter.finish()
    }
}
/// See [`AwsS3AccountPublicAccessBlockDetails`](crate::model::AwsS3AccountPublicAccessBlockDetails)
pub mod aws_s3_account_public_access_block_details {

    /// A builder for [`AwsS3AccountPublicAccessBlockDetails`](crate::model::AwsS3AccountPublicAccessBlockDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) block_public_acls: std::option::Option<bool>,
        pub(crate) block_public_policy: std::option::Option<bool>,
        pub(crate) ignore_public_acls: std::option::Option<bool>,
        pub(crate) restrict_public_buckets: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Indicates whether to reject calls to update an S3 bucket if the calls include a public access control list (ACL).</p>
        pub fn block_public_acls(mut self, input: bool) -> Self {
            self.block_public_acls = Some(input);
            self
        }
        /// <p>Indicates whether to reject calls to update an S3 bucket if the calls include a public access control list (ACL).</p>
        pub fn set_block_public_acls(mut self, input: std::option::Option<bool>) -> Self {
            self.block_public_acls = input;
            self
        }
        /// <p>Indicates whether to reject calls to update the access policy for an S3 bucket or access point if the policy allows public access.</p>
        pub fn block_public_policy(mut self, input: bool) -> Self {
            self.block_public_policy = Some(input);
            self
        }
        /// <p>Indicates whether to reject calls to update the access policy for an S3 bucket or access point if the policy allows public access.</p>
        pub fn set_block_public_policy(mut self, input: std::option::Option<bool>) -> Self {
            self.block_public_policy = input;
            self
        }
        /// <p>Indicates whether Amazon S3 ignores public ACLs that are associated with an S3 bucket.</p>
        pub fn ignore_public_acls(mut self, input: bool) -> Self {
            self.ignore_public_acls = Some(input);
            self
        }
        /// <p>Indicates whether Amazon S3 ignores public ACLs that are associated with an S3 bucket.</p>
        pub fn set_ignore_public_acls(mut self, input: std::option::Option<bool>) -> Self {
            self.ignore_public_acls = input;
            self
        }
        /// <p>Indicates whether to restrict access to an access point or S3 bucket that has a public policy to only Amazon Web Services service principals and authorized users within the S3 bucket owner's account.</p>
        pub fn restrict_public_buckets(mut self, input: bool) -> Self {
            self.restrict_public_buckets = Some(input);
            self
        }
        /// <p>Indicates whether to restrict access to an access point or S3 bucket that has a public policy to only Amazon Web Services service principals and authorized users within the S3 bucket owner's account.</p>
        pub fn set_restrict_public_buckets(mut self, input: std::option::Option<bool>) -> Self {
            self.restrict_public_buckets = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3AccountPublicAccessBlockDetails`](crate::model::AwsS3AccountPublicAccessBlockDetails)
        pub fn build(self) -> crate::model::AwsS3AccountPublicAccessBlockDetails {
            crate::model::AwsS3AccountPublicAccessBlockDetails {
                block_public_acls: self.block_public_acls.unwrap_or_default(),
                block_public_policy: self.block_public_policy.unwrap_or_default(),
                ignore_public_acls: self.ignore_public_acls.unwrap_or_default(),
                restrict_public_buckets: self.restrict_public_buckets.unwrap_or_default(),
            }
        }
    }
}
impl AwsS3AccountPublicAccessBlockDetails {
    /// Creates a new builder-style object to manufacture [`AwsS3AccountPublicAccessBlockDetails`](crate::model::AwsS3AccountPublicAccessBlockDetails)
    pub fn builder() -> crate::model::aws_s3_account_public_access_block_details::Builder {
        crate::model::aws_s3_account_public_access_block_details::Builder::default()
    }
}

/// <p>The details of an Amazon S3 bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3BucketDetails {
    /// <p>The canonical user ID of the owner of the S3 bucket.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The display name of the owner of the S3 bucket.</p>
    pub owner_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account identifier of the account that owns the S3 bucket.</p>
    pub owner_account_id: std::option::Option<std::string::String>,
    /// <p>Indicates when the S3 bucket was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub created_at: std::option::Option<std::string::String>,
    /// <p>The encryption rules that are applied to the S3 bucket.</p>
    pub server_side_encryption_configuration:
        std::option::Option<crate::model::AwsS3BucketServerSideEncryptionConfiguration>,
    /// <p>The lifecycle configuration for objects in the S3 bucket.</p>
    pub bucket_lifecycle_configuration:
        std::option::Option<crate::model::AwsS3BucketBucketLifecycleConfigurationDetails>,
    /// <p>Provides information about the Amazon S3 Public Access Block configuration for the S3 bucket.</p>
    pub public_access_block_configuration:
        std::option::Option<crate::model::AwsS3AccountPublicAccessBlockDetails>,
    /// <p>The access control list for the S3 bucket.</p>
    pub access_control_list: std::option::Option<std::string::String>,
    /// <p>The logging configuration for the S3 bucket.</p>
    pub bucket_logging_configuration:
        std::option::Option<crate::model::AwsS3BucketLoggingConfiguration>,
    /// <p>The website configuration parameters for the S3 bucket.</p>
    pub bucket_website_configuration:
        std::option::Option<crate::model::AwsS3BucketWebsiteConfiguration>,
    /// <p>The notification configuration for the S3 bucket.</p>
    pub bucket_notification_configuration:
        std::option::Option<crate::model::AwsS3BucketNotificationConfiguration>,
    /// <p>The versioning state of an S3 bucket.</p>
    pub bucket_versioning_configuration:
        std::option::Option<crate::model::AwsS3BucketBucketVersioningConfiguration>,
}
impl AwsS3BucketDetails {
    /// <p>The canonical user ID of the owner of the S3 bucket.</p>
    pub fn owner_id(&self) -> std::option::Option<&str> {
        self.owner_id.as_deref()
    }
    /// <p>The display name of the owner of the S3 bucket.</p>
    pub fn owner_name(&self) -> std::option::Option<&str> {
        self.owner_name.as_deref()
    }
    /// <p>The Amazon Web Services account identifier of the account that owns the S3 bucket.</p>
    pub fn owner_account_id(&self) -> std::option::Option<&str> {
        self.owner_account_id.as_deref()
    }
    /// <p>Indicates when the S3 bucket was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn created_at(&self) -> std::option::Option<&str> {
        self.created_at.as_deref()
    }
    /// <p>The encryption rules that are applied to the S3 bucket.</p>
    pub fn server_side_encryption_configuration(
        &self,
    ) -> std::option::Option<&crate::model::AwsS3BucketServerSideEncryptionConfiguration> {
        self.server_side_encryption_configuration.as_ref()
    }
    /// <p>The lifecycle configuration for objects in the S3 bucket.</p>
    pub fn bucket_lifecycle_configuration(
        &self,
    ) -> std::option::Option<&crate::model::AwsS3BucketBucketLifecycleConfigurationDetails> {
        self.bucket_lifecycle_configuration.as_ref()
    }
    /// <p>Provides information about the Amazon S3 Public Access Block configuration for the S3 bucket.</p>
    pub fn public_access_block_configuration(
        &self,
    ) -> std::option::Option<&crate::model::AwsS3AccountPublicAccessBlockDetails> {
        self.public_access_block_configuration.as_ref()
    }
    /// <p>The access control list for the S3 bucket.</p>
    pub fn access_control_list(&self) -> std::option::Option<&str> {
        self.access_control_list.as_deref()
    }
    /// <p>The logging configuration for the S3 bucket.</p>
    pub fn bucket_logging_configuration(
        &self,
    ) -> std::option::Option<&crate::model::AwsS3BucketLoggingConfiguration> {
        self.bucket_logging_configuration.as_ref()
    }
    /// <p>The website configuration parameters for the S3 bucket.</p>
    pub fn bucket_website_configuration(
        &self,
    ) -> std::option::Option<&crate::model::AwsS3BucketWebsiteConfiguration> {
        self.bucket_website_configuration.as_ref()
    }
    /// <p>The notification configuration for the S3 bucket.</p>
    pub fn bucket_notification_configuration(
        &self,
    ) -> std::option::Option<&crate::model::AwsS3BucketNotificationConfiguration> {
        self.bucket_notification_configuration.as_ref()
    }
    /// <p>The versioning state of an S3 bucket.</p>
    pub fn bucket_versioning_configuration(
        &self,
    ) -> std::option::Option<&crate::model::AwsS3BucketBucketVersioningConfiguration> {
        self.bucket_versioning_configuration.as_ref()
    }
}
impl std::fmt::Debug for AwsS3BucketDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsS3BucketDetails");
        formatter.field("owner_id", &self.owner_id);
        formatter.field("owner_name", &self.owner_name);
        formatter.field("owner_account_id", &self.owner_account_id);
        formatter.field("created_at", &self.created_at);
        formatter.field(
            "server_side_encryption_configuration",
            &self.server_side_encryption_configuration,
        );
        formatter.field(
            "bucket_lifecycle_configuration",
            &self.bucket_lifecycle_configuration,
        );
        formatter.field(
            "public_access_block_configuration",
            &self.public_access_block_configuration,
        );
        formatter.field("access_control_list", &self.access_control_list);
        formatter.field(
            "bucket_logging_configuration",
            &self.bucket_logging_configuration,
        );
        formatter.field(
            "bucket_website_configuration",
            &self.bucket_website_configuration,
        );
        formatter.field(
            "bucket_notification_configuration",
            &self.bucket_notification_configuration,
        );
        formatter.field(
            "bucket_versioning_configuration",
            &self.bucket_versioning_configuration,
        );
        formatter.finish()
    }
}
/// See [`AwsS3BucketDetails`](crate::model::AwsS3BucketDetails)
pub mod aws_s3_bucket_details {

    /// A builder for [`AwsS3BucketDetails`](crate::model::AwsS3BucketDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) owner_name: std::option::Option<std::string::String>,
        pub(crate) owner_account_id: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<std::string::String>,
        pub(crate) server_side_encryption_configuration:
            std::option::Option<crate::model::AwsS3BucketServerSideEncryptionConfiguration>,
        pub(crate) bucket_lifecycle_configuration:
            std::option::Option<crate::model::AwsS3BucketBucketLifecycleConfigurationDetails>,
        pub(crate) public_access_block_configuration:
            std::option::Option<crate::model::AwsS3AccountPublicAccessBlockDetails>,
        pub(crate) access_control_list: std::option::Option<std::string::String>,
        pub(crate) bucket_logging_configuration:
            std::option::Option<crate::model::AwsS3BucketLoggingConfiguration>,
        pub(crate) bucket_website_configuration:
            std::option::Option<crate::model::AwsS3BucketWebsiteConfiguration>,
        pub(crate) bucket_notification_configuration:
            std::option::Option<crate::model::AwsS3BucketNotificationConfiguration>,
        pub(crate) bucket_versioning_configuration:
            std::option::Option<crate::model::AwsS3BucketBucketVersioningConfiguration>,
    }
    impl Builder {
        /// <p>The canonical user ID of the owner of the S3 bucket.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        /// <p>The canonical user ID of the owner of the S3 bucket.</p>
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The display name of the owner of the S3 bucket.</p>
        pub fn owner_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_name = Some(input.into());
            self
        }
        /// <p>The display name of the owner of the S3 bucket.</p>
        pub fn set_owner_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_name = input;
            self
        }
        /// <p>The Amazon Web Services account identifier of the account that owns the S3 bucket.</p>
        pub fn owner_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account identifier of the account that owns the S3 bucket.</p>
        pub fn set_owner_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.owner_account_id = input;
            self
        }
        /// <p>Indicates when the S3 bucket was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn created_at(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_at = Some(input.into());
            self
        }
        /// <p>Indicates when the S3 bucket was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_created_at(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The encryption rules that are applied to the S3 bucket.</p>
        pub fn server_side_encryption_configuration(
            mut self,
            input: crate::model::AwsS3BucketServerSideEncryptionConfiguration,
        ) -> Self {
            self.server_side_encryption_configuration = Some(input);
            self
        }
        /// <p>The encryption rules that are applied to the S3 bucket.</p>
        pub fn set_server_side_encryption_configuration(
            mut self,
            input: std::option::Option<crate::model::AwsS3BucketServerSideEncryptionConfiguration>,
        ) -> Self {
            self.server_side_encryption_configuration = input;
            self
        }
        /// <p>The lifecycle configuration for objects in the S3 bucket.</p>
        pub fn bucket_lifecycle_configuration(
            mut self,
            input: crate::model::AwsS3BucketBucketLifecycleConfigurationDetails,
        ) -> Self {
            self.bucket_lifecycle_configuration = Some(input);
            self
        }
        /// <p>The lifecycle configuration for objects in the S3 bucket.</p>
        pub fn set_bucket_lifecycle_configuration(
            mut self,
            input: std::option::Option<
                crate::model::AwsS3BucketBucketLifecycleConfigurationDetails,
            >,
        ) -> Self {
            self.bucket_lifecycle_configuration = input;
            self
        }
        /// <p>Provides information about the Amazon S3 Public Access Block configuration for the S3 bucket.</p>
        pub fn public_access_block_configuration(
            mut self,
            input: crate::model::AwsS3AccountPublicAccessBlockDetails,
        ) -> Self {
            self.public_access_block_configuration = Some(input);
            self
        }
        /// <p>Provides information about the Amazon S3 Public Access Block configuration for the S3 bucket.</p>
        pub fn set_public_access_block_configuration(
            mut self,
            input: std::option::Option<crate::model::AwsS3AccountPublicAccessBlockDetails>,
        ) -> Self {
            self.public_access_block_configuration = input;
            self
        }
        /// <p>The access control list for the S3 bucket.</p>
        pub fn access_control_list(mut self, input: impl Into<std::string::String>) -> Self {
            self.access_control_list = Some(input.into());
            self
        }
        /// <p>The access control list for the S3 bucket.</p>
        pub fn set_access_control_list(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.access_control_list = input;
            self
        }
        /// <p>The logging configuration for the S3 bucket.</p>
        pub fn bucket_logging_configuration(
            mut self,
            input: crate::model::AwsS3BucketLoggingConfiguration,
        ) -> Self {
            self.bucket_logging_configuration = Some(input);
            self
        }
        /// <p>The logging configuration for the S3 bucket.</p>
        pub fn set_bucket_logging_configuration(
            mut self,
            input: std::option::Option<crate::model::AwsS3BucketLoggingConfiguration>,
        ) -> Self {
            self.bucket_logging_configuration = input;
            self
        }
        /// <p>The website configuration parameters for the S3 bucket.</p>
        pub fn bucket_website_configuration(
            mut self,
            input: crate::model::AwsS3BucketWebsiteConfiguration,
        ) -> Self {
            self.bucket_website_configuration = Some(input);
            self
        }
        /// <p>The website configuration parameters for the S3 bucket.</p>
        pub fn set_bucket_website_configuration(
            mut self,
            input: std::option::Option<crate::model::AwsS3BucketWebsiteConfiguration>,
        ) -> Self {
            self.bucket_website_configuration = input;
            self
        }
        /// <p>The notification configuration for the S3 bucket.</p>
        pub fn bucket_notification_configuration(
            mut self,
            input: crate::model::AwsS3BucketNotificationConfiguration,
        ) -> Self {
            self.bucket_notification_configuration = Some(input);
            self
        }
        /// <p>The notification configuration for the S3 bucket.</p>
        pub fn set_bucket_notification_configuration(
            mut self,
            input: std::option::Option<crate::model::AwsS3BucketNotificationConfiguration>,
        ) -> Self {
            self.bucket_notification_configuration = input;
            self
        }
        /// <p>The versioning state of an S3 bucket.</p>
        pub fn bucket_versioning_configuration(
            mut self,
            input: crate::model::AwsS3BucketBucketVersioningConfiguration,
        ) -> Self {
            self.bucket_versioning_configuration = Some(input);
            self
        }
        /// <p>The versioning state of an S3 bucket.</p>
        pub fn set_bucket_versioning_configuration(
            mut self,
            input: std::option::Option<crate::model::AwsS3BucketBucketVersioningConfiguration>,
        ) -> Self {
            self.bucket_versioning_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3BucketDetails`](crate::model::AwsS3BucketDetails)
        pub fn build(self) -> crate::model::AwsS3BucketDetails {
            crate::model::AwsS3BucketDetails {
                owner_id: self.owner_id,
                owner_name: self.owner_name,
                owner_account_id: self.owner_account_id,
                created_at: self.created_at,
                server_side_encryption_configuration: self.server_side_encryption_configuration,
                bucket_lifecycle_configuration: self.bucket_lifecycle_configuration,
                public_access_block_configuration: self.public_access_block_configuration,
                access_control_list: self.access_control_list,
                bucket_logging_configuration: self.bucket_logging_configuration,
                bucket_website_configuration: self.bucket_website_configuration,
                bucket_notification_configuration: self.bucket_notification_configuration,
                bucket_versioning_configuration: self.bucket_versioning_configuration,
            }
        }
    }
}
impl AwsS3BucketDetails {
    /// Creates a new builder-style object to manufacture [`AwsS3BucketDetails`](crate::model::AwsS3BucketDetails)
    pub fn builder() -> crate::model::aws_s3_bucket_details::Builder {
        crate::model::aws_s3_bucket_details::Builder::default()
    }
}

/// <p>Describes the versioning state of an S3 bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3BucketBucketVersioningConfiguration {
    /// <p>Specifies whether MFA delete is currently enabled in the S3 bucket versioning configuration. If the S3 bucket was never configured with MFA delete, then this attribute is not included.</p>
    pub is_mfa_delete_enabled: bool,
    /// <p>The versioning status of the S3 bucket.</p>
    pub status: std::option::Option<std::string::String>,
}
impl AwsS3BucketBucketVersioningConfiguration {
    /// <p>Specifies whether MFA delete is currently enabled in the S3 bucket versioning configuration. If the S3 bucket was never configured with MFA delete, then this attribute is not included.</p>
    pub fn is_mfa_delete_enabled(&self) -> bool {
        self.is_mfa_delete_enabled
    }
    /// <p>The versioning status of the S3 bucket.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
}
impl std::fmt::Debug for AwsS3BucketBucketVersioningConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsS3BucketBucketVersioningConfiguration");
        formatter.field("is_mfa_delete_enabled", &self.is_mfa_delete_enabled);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`AwsS3BucketBucketVersioningConfiguration`](crate::model::AwsS3BucketBucketVersioningConfiguration)
pub mod aws_s3_bucket_bucket_versioning_configuration {

    /// A builder for [`AwsS3BucketBucketVersioningConfiguration`](crate::model::AwsS3BucketBucketVersioningConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) is_mfa_delete_enabled: std::option::Option<bool>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies whether MFA delete is currently enabled in the S3 bucket versioning configuration. If the S3 bucket was never configured with MFA delete, then this attribute is not included.</p>
        pub fn is_mfa_delete_enabled(mut self, input: bool) -> Self {
            self.is_mfa_delete_enabled = Some(input);
            self
        }
        /// <p>Specifies whether MFA delete is currently enabled in the S3 bucket versioning configuration. If the S3 bucket was never configured with MFA delete, then this attribute is not included.</p>
        pub fn set_is_mfa_delete_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.is_mfa_delete_enabled = input;
            self
        }
        /// <p>The versioning status of the S3 bucket.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The versioning status of the S3 bucket.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3BucketBucketVersioningConfiguration`](crate::model::AwsS3BucketBucketVersioningConfiguration)
        pub fn build(self) -> crate::model::AwsS3BucketBucketVersioningConfiguration {
            crate::model::AwsS3BucketBucketVersioningConfiguration {
                is_mfa_delete_enabled: self.is_mfa_delete_enabled.unwrap_or_default(),
                status: self.status,
            }
        }
    }
}
impl AwsS3BucketBucketVersioningConfiguration {
    /// Creates a new builder-style object to manufacture [`AwsS3BucketBucketVersioningConfiguration`](crate::model::AwsS3BucketBucketVersioningConfiguration)
    pub fn builder() -> crate::model::aws_s3_bucket_bucket_versioning_configuration::Builder {
        crate::model::aws_s3_bucket_bucket_versioning_configuration::Builder::default()
    }
}

/// <p>The notification configuration for the S3 bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3BucketNotificationConfiguration {
    /// <p>Configurations for S3 bucket notifications.</p>
    pub configurations: std::option::Option<
        std::vec::Vec<crate::model::AwsS3BucketNotificationConfigurationDetail>,
    >,
}
impl AwsS3BucketNotificationConfiguration {
    /// <p>Configurations for S3 bucket notifications.</p>
    pub fn configurations(
        &self,
    ) -> std::option::Option<&[crate::model::AwsS3BucketNotificationConfigurationDetail]> {
        self.configurations.as_deref()
    }
}
impl std::fmt::Debug for AwsS3BucketNotificationConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsS3BucketNotificationConfiguration");
        formatter.field("configurations", &self.configurations);
        formatter.finish()
    }
}
/// See [`AwsS3BucketNotificationConfiguration`](crate::model::AwsS3BucketNotificationConfiguration)
pub mod aws_s3_bucket_notification_configuration {

    /// A builder for [`AwsS3BucketNotificationConfiguration`](crate::model::AwsS3BucketNotificationConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configurations: std::option::Option<
            std::vec::Vec<crate::model::AwsS3BucketNotificationConfigurationDetail>,
        >,
    }
    impl Builder {
        /// Appends an item to `configurations`.
        ///
        /// To override the contents of this collection use [`set_configurations`](Self::set_configurations).
        ///
        /// <p>Configurations for S3 bucket notifications.</p>
        pub fn configurations(
            mut self,
            input: crate::model::AwsS3BucketNotificationConfigurationDetail,
        ) -> Self {
            let mut v = self.configurations.unwrap_or_default();
            v.push(input);
            self.configurations = Some(v);
            self
        }
        /// <p>Configurations for S3 bucket notifications.</p>
        pub fn set_configurations(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsS3BucketNotificationConfigurationDetail>,
            >,
        ) -> Self {
            self.configurations = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3BucketNotificationConfiguration`](crate::model::AwsS3BucketNotificationConfiguration)
        pub fn build(self) -> crate::model::AwsS3BucketNotificationConfiguration {
            crate::model::AwsS3BucketNotificationConfiguration {
                configurations: self.configurations,
            }
        }
    }
}
impl AwsS3BucketNotificationConfiguration {
    /// Creates a new builder-style object to manufacture [`AwsS3BucketNotificationConfiguration`](crate::model::AwsS3BucketNotificationConfiguration)
    pub fn builder() -> crate::model::aws_s3_bucket_notification_configuration::Builder {
        crate::model::aws_s3_bucket_notification_configuration::Builder::default()
    }
}

/// <p>Details for an S3 bucket notification configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3BucketNotificationConfigurationDetail {
    /// <p>The list of events that trigger a notification.</p>
    pub events: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The filters that determine which S3 buckets generate notifications.</p>
    pub filter: std::option::Option<crate::model::AwsS3BucketNotificationConfigurationFilter>,
    /// <p>The ARN of the Lambda function, Amazon SQS queue, or Amazon SNS topic that generates the notification.</p>
    pub destination: std::option::Option<std::string::String>,
    /// <p>Indicates the type of notification. Notifications can be generated using Lambda functions, Amazon SQS queues or Amazon SNS topics.</p>
    pub r#type: std::option::Option<std::string::String>,
}
impl AwsS3BucketNotificationConfigurationDetail {
    /// <p>The list of events that trigger a notification.</p>
    pub fn events(&self) -> std::option::Option<&[std::string::String]> {
        self.events.as_deref()
    }
    /// <p>The filters that determine which S3 buckets generate notifications.</p>
    pub fn filter(
        &self,
    ) -> std::option::Option<&crate::model::AwsS3BucketNotificationConfigurationFilter> {
        self.filter.as_ref()
    }
    /// <p>The ARN of the Lambda function, Amazon SQS queue, or Amazon SNS topic that generates the notification.</p>
    pub fn destination(&self) -> std::option::Option<&str> {
        self.destination.as_deref()
    }
    /// <p>Indicates the type of notification. Notifications can be generated using Lambda functions, Amazon SQS queues or Amazon SNS topics.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for AwsS3BucketNotificationConfigurationDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsS3BucketNotificationConfigurationDetail");
        formatter.field("events", &self.events);
        formatter.field("filter", &self.filter);
        formatter.field("destination", &self.destination);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AwsS3BucketNotificationConfigurationDetail`](crate::model::AwsS3BucketNotificationConfigurationDetail)
pub mod aws_s3_bucket_notification_configuration_detail {

    /// A builder for [`AwsS3BucketNotificationConfigurationDetail`](crate::model::AwsS3BucketNotificationConfigurationDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) events: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) filter:
            std::option::Option<crate::model::AwsS3BucketNotificationConfigurationFilter>,
        pub(crate) destination: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `events`.
        ///
        /// To override the contents of this collection use [`set_events`](Self::set_events).
        ///
        /// <p>The list of events that trigger a notification.</p>
        pub fn events(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.events.unwrap_or_default();
            v.push(input.into());
            self.events = Some(v);
            self
        }
        /// <p>The list of events that trigger a notification.</p>
        pub fn set_events(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.events = input;
            self
        }
        /// <p>The filters that determine which S3 buckets generate notifications.</p>
        pub fn filter(
            mut self,
            input: crate::model::AwsS3BucketNotificationConfigurationFilter,
        ) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>The filters that determine which S3 buckets generate notifications.</p>
        pub fn set_filter(
            mut self,
            input: std::option::Option<crate::model::AwsS3BucketNotificationConfigurationFilter>,
        ) -> Self {
            self.filter = input;
            self
        }
        /// <p>The ARN of the Lambda function, Amazon SQS queue, or Amazon SNS topic that generates the notification.</p>
        pub fn destination(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination = Some(input.into());
            self
        }
        /// <p>The ARN of the Lambda function, Amazon SQS queue, or Amazon SNS topic that generates the notification.</p>
        pub fn set_destination(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.destination = input;
            self
        }
        /// <p>Indicates the type of notification. Notifications can be generated using Lambda functions, Amazon SQS queues or Amazon SNS topics.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>Indicates the type of notification. Notifications can be generated using Lambda functions, Amazon SQS queues or Amazon SNS topics.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3BucketNotificationConfigurationDetail`](crate::model::AwsS3BucketNotificationConfigurationDetail)
        pub fn build(self) -> crate::model::AwsS3BucketNotificationConfigurationDetail {
            crate::model::AwsS3BucketNotificationConfigurationDetail {
                events: self.events,
                filter: self.filter,
                destination: self.destination,
                r#type: self.r#type,
            }
        }
    }
}
impl AwsS3BucketNotificationConfigurationDetail {
    /// Creates a new builder-style object to manufacture [`AwsS3BucketNotificationConfigurationDetail`](crate::model::AwsS3BucketNotificationConfigurationDetail)
    pub fn builder() -> crate::model::aws_s3_bucket_notification_configuration_detail::Builder {
        crate::model::aws_s3_bucket_notification_configuration_detail::Builder::default()
    }
}

/// <p>Filtering information for the notifications. The filtering is based on Amazon S3 key names.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3BucketNotificationConfigurationFilter {
    /// <p>Details for an Amazon S3 filter.</p>
    pub s3_key_filter:
        std::option::Option<crate::model::AwsS3BucketNotificationConfigurationS3KeyFilter>,
}
impl AwsS3BucketNotificationConfigurationFilter {
    /// <p>Details for an Amazon S3 filter.</p>
    pub fn s3_key_filter(
        &self,
    ) -> std::option::Option<&crate::model::AwsS3BucketNotificationConfigurationS3KeyFilter> {
        self.s3_key_filter.as_ref()
    }
}
impl std::fmt::Debug for AwsS3BucketNotificationConfigurationFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsS3BucketNotificationConfigurationFilter");
        formatter.field("s3_key_filter", &self.s3_key_filter);
        formatter.finish()
    }
}
/// See [`AwsS3BucketNotificationConfigurationFilter`](crate::model::AwsS3BucketNotificationConfigurationFilter)
pub mod aws_s3_bucket_notification_configuration_filter {

    /// A builder for [`AwsS3BucketNotificationConfigurationFilter`](crate::model::AwsS3BucketNotificationConfigurationFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_key_filter:
            std::option::Option<crate::model::AwsS3BucketNotificationConfigurationS3KeyFilter>,
    }
    impl Builder {
        /// <p>Details for an Amazon S3 filter.</p>
        pub fn s3_key_filter(
            mut self,
            input: crate::model::AwsS3BucketNotificationConfigurationS3KeyFilter,
        ) -> Self {
            self.s3_key_filter = Some(input);
            self
        }
        /// <p>Details for an Amazon S3 filter.</p>
        pub fn set_s3_key_filter(
            mut self,
            input: std::option::Option<
                crate::model::AwsS3BucketNotificationConfigurationS3KeyFilter,
            >,
        ) -> Self {
            self.s3_key_filter = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3BucketNotificationConfigurationFilter`](crate::model::AwsS3BucketNotificationConfigurationFilter)
        pub fn build(self) -> crate::model::AwsS3BucketNotificationConfigurationFilter {
            crate::model::AwsS3BucketNotificationConfigurationFilter {
                s3_key_filter: self.s3_key_filter,
            }
        }
    }
}
impl AwsS3BucketNotificationConfigurationFilter {
    /// Creates a new builder-style object to manufacture [`AwsS3BucketNotificationConfigurationFilter`](crate::model::AwsS3BucketNotificationConfigurationFilter)
    pub fn builder() -> crate::model::aws_s3_bucket_notification_configuration_filter::Builder {
        crate::model::aws_s3_bucket_notification_configuration_filter::Builder::default()
    }
}

/// <p>Details for an Amazon S3 filter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3BucketNotificationConfigurationS3KeyFilter {
    /// <p>The filter rules for the filter.</p>
    pub filter_rules: std::option::Option<
        std::vec::Vec<crate::model::AwsS3BucketNotificationConfigurationS3KeyFilterRule>,
    >,
}
impl AwsS3BucketNotificationConfigurationS3KeyFilter {
    /// <p>The filter rules for the filter.</p>
    pub fn filter_rules(
        &self,
    ) -> std::option::Option<&[crate::model::AwsS3BucketNotificationConfigurationS3KeyFilterRule]>
    {
        self.filter_rules.as_deref()
    }
}
impl std::fmt::Debug for AwsS3BucketNotificationConfigurationS3KeyFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsS3BucketNotificationConfigurationS3KeyFilter");
        formatter.field("filter_rules", &self.filter_rules);
        formatter.finish()
    }
}
/// See [`AwsS3BucketNotificationConfigurationS3KeyFilter`](crate::model::AwsS3BucketNotificationConfigurationS3KeyFilter)
pub mod aws_s3_bucket_notification_configuration_s3_key_filter {

    /// A builder for [`AwsS3BucketNotificationConfigurationS3KeyFilter`](crate::model::AwsS3BucketNotificationConfigurationS3KeyFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter_rules: std::option::Option<
            std::vec::Vec<crate::model::AwsS3BucketNotificationConfigurationS3KeyFilterRule>,
        >,
    }
    impl Builder {
        /// Appends an item to `filter_rules`.
        ///
        /// To override the contents of this collection use [`set_filter_rules`](Self::set_filter_rules).
        ///
        /// <p>The filter rules for the filter.</p>
        pub fn filter_rules(
            mut self,
            input: crate::model::AwsS3BucketNotificationConfigurationS3KeyFilterRule,
        ) -> Self {
            let mut v = self.filter_rules.unwrap_or_default();
            v.push(input);
            self.filter_rules = Some(v);
            self
        }
        /// <p>The filter rules for the filter.</p>
        pub fn set_filter_rules(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsS3BucketNotificationConfigurationS3KeyFilterRule>,
            >,
        ) -> Self {
            self.filter_rules = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3BucketNotificationConfigurationS3KeyFilter`](crate::model::AwsS3BucketNotificationConfigurationS3KeyFilter)
        pub fn build(self) -> crate::model::AwsS3BucketNotificationConfigurationS3KeyFilter {
            crate::model::AwsS3BucketNotificationConfigurationS3KeyFilter {
                filter_rules: self.filter_rules,
            }
        }
    }
}
impl AwsS3BucketNotificationConfigurationS3KeyFilter {
    /// Creates a new builder-style object to manufacture [`AwsS3BucketNotificationConfigurationS3KeyFilter`](crate::model::AwsS3BucketNotificationConfigurationS3KeyFilter)
    pub fn builder() -> crate::model::aws_s3_bucket_notification_configuration_s3_key_filter::Builder
    {
        crate::model::aws_s3_bucket_notification_configuration_s3_key_filter::Builder::default()
    }
}

/// <p>Details for a filter rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3BucketNotificationConfigurationS3KeyFilterRule {
    /// <p>Indicates whether the filter is based on the prefix or suffix of the Amazon S3 key.</p>
    pub name:
        std::option::Option<crate::model::AwsS3BucketNotificationConfigurationS3KeyFilterRuleName>,
    /// <p>The filter value.</p>
    pub value: std::option::Option<std::string::String>,
}
impl AwsS3BucketNotificationConfigurationS3KeyFilterRule {
    /// <p>Indicates whether the filter is based on the prefix or suffix of the Amazon S3 key.</p>
    pub fn name(
        &self,
    ) -> std::option::Option<&crate::model::AwsS3BucketNotificationConfigurationS3KeyFilterRuleName>
    {
        self.name.as_ref()
    }
    /// <p>The filter value.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for AwsS3BucketNotificationConfigurationS3KeyFilterRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsS3BucketNotificationConfigurationS3KeyFilterRule");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`AwsS3BucketNotificationConfigurationS3KeyFilterRule`](crate::model::AwsS3BucketNotificationConfigurationS3KeyFilterRule)
pub mod aws_s3_bucket_notification_configuration_s3_key_filter_rule {

    /// A builder for [`AwsS3BucketNotificationConfigurationS3KeyFilterRule`](crate::model::AwsS3BucketNotificationConfigurationS3KeyFilterRule)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<
            crate::model::AwsS3BucketNotificationConfigurationS3KeyFilterRuleName,
        >,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates whether the filter is based on the prefix or suffix of the Amazon S3 key.</p>
        pub fn name(
            mut self,
            input: crate::model::AwsS3BucketNotificationConfigurationS3KeyFilterRuleName,
        ) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>Indicates whether the filter is based on the prefix or suffix of the Amazon S3 key.</p>
        pub fn set_name(
            mut self,
            input: std::option::Option<
                crate::model::AwsS3BucketNotificationConfigurationS3KeyFilterRuleName,
            >,
        ) -> Self {
            self.name = input;
            self
        }
        /// <p>The filter value.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The filter value.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3BucketNotificationConfigurationS3KeyFilterRule`](crate::model::AwsS3BucketNotificationConfigurationS3KeyFilterRule)
        pub fn build(self) -> crate::model::AwsS3BucketNotificationConfigurationS3KeyFilterRule {
            crate::model::AwsS3BucketNotificationConfigurationS3KeyFilterRule {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl AwsS3BucketNotificationConfigurationS3KeyFilterRule {
    /// Creates a new builder-style object to manufacture [`AwsS3BucketNotificationConfigurationS3KeyFilterRule`](crate::model::AwsS3BucketNotificationConfigurationS3KeyFilterRule)
    pub fn builder(
    ) -> crate::model::aws_s3_bucket_notification_configuration_s3_key_filter_rule::Builder {
        crate::model::aws_s3_bucket_notification_configuration_s3_key_filter_rule::Builder::default(
        )
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AwsS3BucketNotificationConfigurationS3KeyFilterRuleName {
    #[allow(missing_docs)] // documentation missing in model
    Prefix,
    #[allow(missing_docs)] // documentation missing in model
    Suffix,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AwsS3BucketNotificationConfigurationS3KeyFilterRuleName {
    fn from(s: &str) -> Self {
        match s {
            "Prefix" => AwsS3BucketNotificationConfigurationS3KeyFilterRuleName::Prefix,
            "Suffix" => AwsS3BucketNotificationConfigurationS3KeyFilterRuleName::Suffix,
            other => {
                AwsS3BucketNotificationConfigurationS3KeyFilterRuleName::Unknown(other.to_owned())
            }
        }
    }
}
impl std::str::FromStr for AwsS3BucketNotificationConfigurationS3KeyFilterRuleName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AwsS3BucketNotificationConfigurationS3KeyFilterRuleName::from(s))
    }
}
impl AwsS3BucketNotificationConfigurationS3KeyFilterRuleName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AwsS3BucketNotificationConfigurationS3KeyFilterRuleName::Prefix => "Prefix",
            AwsS3BucketNotificationConfigurationS3KeyFilterRuleName::Suffix => "Suffix",
            AwsS3BucketNotificationConfigurationS3KeyFilterRuleName::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Prefix", "Suffix"]
    }
}
impl AsRef<str> for AwsS3BucketNotificationConfigurationS3KeyFilterRuleName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Website parameters for the S3 bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3BucketWebsiteConfiguration {
    /// <p>The name of the error document for the website.</p>
    pub error_document: std::option::Option<std::string::String>,
    /// <p>The name of the index document for the website.</p>
    pub index_document_suffix: std::option::Option<std::string::String>,
    /// <p>The redirect behavior for requests to the website.</p>
    pub redirect_all_requests_to:
        std::option::Option<crate::model::AwsS3BucketWebsiteConfigurationRedirectTo>,
    /// <p>The rules for applying redirects for requests to the website.</p>
    pub routing_rules: std::option::Option<
        std::vec::Vec<crate::model::AwsS3BucketWebsiteConfigurationRoutingRule>,
    >,
}
impl AwsS3BucketWebsiteConfiguration {
    /// <p>The name of the error document for the website.</p>
    pub fn error_document(&self) -> std::option::Option<&str> {
        self.error_document.as_deref()
    }
    /// <p>The name of the index document for the website.</p>
    pub fn index_document_suffix(&self) -> std::option::Option<&str> {
        self.index_document_suffix.as_deref()
    }
    /// <p>The redirect behavior for requests to the website.</p>
    pub fn redirect_all_requests_to(
        &self,
    ) -> std::option::Option<&crate::model::AwsS3BucketWebsiteConfigurationRedirectTo> {
        self.redirect_all_requests_to.as_ref()
    }
    /// <p>The rules for applying redirects for requests to the website.</p>
    pub fn routing_rules(
        &self,
    ) -> std::option::Option<&[crate::model::AwsS3BucketWebsiteConfigurationRoutingRule]> {
        self.routing_rules.as_deref()
    }
}
impl std::fmt::Debug for AwsS3BucketWebsiteConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsS3BucketWebsiteConfiguration");
        formatter.field("error_document", &self.error_document);
        formatter.field("index_document_suffix", &self.index_document_suffix);
        formatter.field("redirect_all_requests_to", &self.redirect_all_requests_to);
        formatter.field("routing_rules", &self.routing_rules);
        formatter.finish()
    }
}
/// See [`AwsS3BucketWebsiteConfiguration`](crate::model::AwsS3BucketWebsiteConfiguration)
pub mod aws_s3_bucket_website_configuration {

    /// A builder for [`AwsS3BucketWebsiteConfiguration`](crate::model::AwsS3BucketWebsiteConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_document: std::option::Option<std::string::String>,
        pub(crate) index_document_suffix: std::option::Option<std::string::String>,
        pub(crate) redirect_all_requests_to:
            std::option::Option<crate::model::AwsS3BucketWebsiteConfigurationRedirectTo>,
        pub(crate) routing_rules: std::option::Option<
            std::vec::Vec<crate::model::AwsS3BucketWebsiteConfigurationRoutingRule>,
        >,
    }
    impl Builder {
        /// <p>The name of the error document for the website.</p>
        pub fn error_document(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_document = Some(input.into());
            self
        }
        /// <p>The name of the error document for the website.</p>
        pub fn set_error_document(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_document = input;
            self
        }
        /// <p>The name of the index document for the website.</p>
        pub fn index_document_suffix(mut self, input: impl Into<std::string::String>) -> Self {
            self.index_document_suffix = Some(input.into());
            self
        }
        /// <p>The name of the index document for the website.</p>
        pub fn set_index_document_suffix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.index_document_suffix = input;
            self
        }
        /// <p>The redirect behavior for requests to the website.</p>
        pub fn redirect_all_requests_to(
            mut self,
            input: crate::model::AwsS3BucketWebsiteConfigurationRedirectTo,
        ) -> Self {
            self.redirect_all_requests_to = Some(input);
            self
        }
        /// <p>The redirect behavior for requests to the website.</p>
        pub fn set_redirect_all_requests_to(
            mut self,
            input: std::option::Option<crate::model::AwsS3BucketWebsiteConfigurationRedirectTo>,
        ) -> Self {
            self.redirect_all_requests_to = input;
            self
        }
        /// Appends an item to `routing_rules`.
        ///
        /// To override the contents of this collection use [`set_routing_rules`](Self::set_routing_rules).
        ///
        /// <p>The rules for applying redirects for requests to the website.</p>
        pub fn routing_rules(
            mut self,
            input: crate::model::AwsS3BucketWebsiteConfigurationRoutingRule,
        ) -> Self {
            let mut v = self.routing_rules.unwrap_or_default();
            v.push(input);
            self.routing_rules = Some(v);
            self
        }
        /// <p>The rules for applying redirects for requests to the website.</p>
        pub fn set_routing_rules(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsS3BucketWebsiteConfigurationRoutingRule>,
            >,
        ) -> Self {
            self.routing_rules = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3BucketWebsiteConfiguration`](crate::model::AwsS3BucketWebsiteConfiguration)
        pub fn build(self) -> crate::model::AwsS3BucketWebsiteConfiguration {
            crate::model::AwsS3BucketWebsiteConfiguration {
                error_document: self.error_document,
                index_document_suffix: self.index_document_suffix,
                redirect_all_requests_to: self.redirect_all_requests_to,
                routing_rules: self.routing_rules,
            }
        }
    }
}
impl AwsS3BucketWebsiteConfiguration {
    /// Creates a new builder-style object to manufacture [`AwsS3BucketWebsiteConfiguration`](crate::model::AwsS3BucketWebsiteConfiguration)
    pub fn builder() -> crate::model::aws_s3_bucket_website_configuration::Builder {
        crate::model::aws_s3_bucket_website_configuration::Builder::default()
    }
}

/// <p>A rule for redirecting requests to the website.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3BucketWebsiteConfigurationRoutingRule {
    /// <p>Provides the condition that must be met in order to apply the routing rule.</p>
    pub condition:
        std::option::Option<crate::model::AwsS3BucketWebsiteConfigurationRoutingRuleCondition>,
    /// <p>Provides the rules to redirect the request if the condition in <code>Condition</code> is met.</p>
    pub redirect:
        std::option::Option<crate::model::AwsS3BucketWebsiteConfigurationRoutingRuleRedirect>,
}
impl AwsS3BucketWebsiteConfigurationRoutingRule {
    /// <p>Provides the condition that must be met in order to apply the routing rule.</p>
    pub fn condition(
        &self,
    ) -> std::option::Option<&crate::model::AwsS3BucketWebsiteConfigurationRoutingRuleCondition>
    {
        self.condition.as_ref()
    }
    /// <p>Provides the rules to redirect the request if the condition in <code>Condition</code> is met.</p>
    pub fn redirect(
        &self,
    ) -> std::option::Option<&crate::model::AwsS3BucketWebsiteConfigurationRoutingRuleRedirect>
    {
        self.redirect.as_ref()
    }
}
impl std::fmt::Debug for AwsS3BucketWebsiteConfigurationRoutingRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsS3BucketWebsiteConfigurationRoutingRule");
        formatter.field("condition", &self.condition);
        formatter.field("redirect", &self.redirect);
        formatter.finish()
    }
}
/// See [`AwsS3BucketWebsiteConfigurationRoutingRule`](crate::model::AwsS3BucketWebsiteConfigurationRoutingRule)
pub mod aws_s3_bucket_website_configuration_routing_rule {

    /// A builder for [`AwsS3BucketWebsiteConfigurationRoutingRule`](crate::model::AwsS3BucketWebsiteConfigurationRoutingRule)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) condition:
            std::option::Option<crate::model::AwsS3BucketWebsiteConfigurationRoutingRuleCondition>,
        pub(crate) redirect:
            std::option::Option<crate::model::AwsS3BucketWebsiteConfigurationRoutingRuleRedirect>,
    }
    impl Builder {
        /// <p>Provides the condition that must be met in order to apply the routing rule.</p>
        pub fn condition(
            mut self,
            input: crate::model::AwsS3BucketWebsiteConfigurationRoutingRuleCondition,
        ) -> Self {
            self.condition = Some(input);
            self
        }
        /// <p>Provides the condition that must be met in order to apply the routing rule.</p>
        pub fn set_condition(
            mut self,
            input: std::option::Option<
                crate::model::AwsS3BucketWebsiteConfigurationRoutingRuleCondition,
            >,
        ) -> Self {
            self.condition = input;
            self
        }
        /// <p>Provides the rules to redirect the request if the condition in <code>Condition</code> is met.</p>
        pub fn redirect(
            mut self,
            input: crate::model::AwsS3BucketWebsiteConfigurationRoutingRuleRedirect,
        ) -> Self {
            self.redirect = Some(input);
            self
        }
        /// <p>Provides the rules to redirect the request if the condition in <code>Condition</code> is met.</p>
        pub fn set_redirect(
            mut self,
            input: std::option::Option<
                crate::model::AwsS3BucketWebsiteConfigurationRoutingRuleRedirect,
            >,
        ) -> Self {
            self.redirect = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3BucketWebsiteConfigurationRoutingRule`](crate::model::AwsS3BucketWebsiteConfigurationRoutingRule)
        pub fn build(self) -> crate::model::AwsS3BucketWebsiteConfigurationRoutingRule {
            crate::model::AwsS3BucketWebsiteConfigurationRoutingRule {
                condition: self.condition,
                redirect: self.redirect,
            }
        }
    }
}
impl AwsS3BucketWebsiteConfigurationRoutingRule {
    /// Creates a new builder-style object to manufacture [`AwsS3BucketWebsiteConfigurationRoutingRule`](crate::model::AwsS3BucketWebsiteConfigurationRoutingRule)
    pub fn builder() -> crate::model::aws_s3_bucket_website_configuration_routing_rule::Builder {
        crate::model::aws_s3_bucket_website_configuration_routing_rule::Builder::default()
    }
}

/// <p>The rules to redirect the request if the condition in <code>Condition</code> is met.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3BucketWebsiteConfigurationRoutingRuleRedirect {
    /// <p>The host name to use in the redirect request.</p>
    pub hostname: std::option::Option<std::string::String>,
    /// <p>The HTTP redirect code to use in the response.</p>
    pub http_redirect_code: std::option::Option<std::string::String>,
    /// <p>The protocol to use to redirect the request. By default, uses the protocol from the original request.</p>
    pub protocol: std::option::Option<std::string::String>,
    /// <p>The object key prefix to use in the redirect request.</p>
    /// <p>Cannot be provided if <code>ReplaceKeyWith</code> is present.</p>
    pub replace_key_prefix_with: std::option::Option<std::string::String>,
    /// <p>The specific object key to use in the redirect request.</p>
    /// <p>Cannot be provided if <code>ReplaceKeyPrefixWith</code> is present.</p>
    pub replace_key_with: std::option::Option<std::string::String>,
}
impl AwsS3BucketWebsiteConfigurationRoutingRuleRedirect {
    /// <p>The host name to use in the redirect request.</p>
    pub fn hostname(&self) -> std::option::Option<&str> {
        self.hostname.as_deref()
    }
    /// <p>The HTTP redirect code to use in the response.</p>
    pub fn http_redirect_code(&self) -> std::option::Option<&str> {
        self.http_redirect_code.as_deref()
    }
    /// <p>The protocol to use to redirect the request. By default, uses the protocol from the original request.</p>
    pub fn protocol(&self) -> std::option::Option<&str> {
        self.protocol.as_deref()
    }
    /// <p>The object key prefix to use in the redirect request.</p>
    /// <p>Cannot be provided if <code>ReplaceKeyWith</code> is present.</p>
    pub fn replace_key_prefix_with(&self) -> std::option::Option<&str> {
        self.replace_key_prefix_with.as_deref()
    }
    /// <p>The specific object key to use in the redirect request.</p>
    /// <p>Cannot be provided if <code>ReplaceKeyPrefixWith</code> is present.</p>
    pub fn replace_key_with(&self) -> std::option::Option<&str> {
        self.replace_key_with.as_deref()
    }
}
impl std::fmt::Debug for AwsS3BucketWebsiteConfigurationRoutingRuleRedirect {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsS3BucketWebsiteConfigurationRoutingRuleRedirect");
        formatter.field("hostname", &self.hostname);
        formatter.field("http_redirect_code", &self.http_redirect_code);
        formatter.field("protocol", &self.protocol);
        formatter.field("replace_key_prefix_with", &self.replace_key_prefix_with);
        formatter.field("replace_key_with", &self.replace_key_with);
        formatter.finish()
    }
}
/// See [`AwsS3BucketWebsiteConfigurationRoutingRuleRedirect`](crate::model::AwsS3BucketWebsiteConfigurationRoutingRuleRedirect)
pub mod aws_s3_bucket_website_configuration_routing_rule_redirect {

    /// A builder for [`AwsS3BucketWebsiteConfigurationRoutingRuleRedirect`](crate::model::AwsS3BucketWebsiteConfigurationRoutingRuleRedirect)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hostname: std::option::Option<std::string::String>,
        pub(crate) http_redirect_code: std::option::Option<std::string::String>,
        pub(crate) protocol: std::option::Option<std::string::String>,
        pub(crate) replace_key_prefix_with: std::option::Option<std::string::String>,
        pub(crate) replace_key_with: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The host name to use in the redirect request.</p>
        pub fn hostname(mut self, input: impl Into<std::string::String>) -> Self {
            self.hostname = Some(input.into());
            self
        }
        /// <p>The host name to use in the redirect request.</p>
        pub fn set_hostname(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hostname = input;
            self
        }
        /// <p>The HTTP redirect code to use in the response.</p>
        pub fn http_redirect_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.http_redirect_code = Some(input.into());
            self
        }
        /// <p>The HTTP redirect code to use in the response.</p>
        pub fn set_http_redirect_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.http_redirect_code = input;
            self
        }
        /// <p>The protocol to use to redirect the request. By default, uses the protocol from the original request.</p>
        pub fn protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.protocol = Some(input.into());
            self
        }
        /// <p>The protocol to use to redirect the request. By default, uses the protocol from the original request.</p>
        pub fn set_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.protocol = input;
            self
        }
        /// <p>The object key prefix to use in the redirect request.</p>
        /// <p>Cannot be provided if <code>ReplaceKeyWith</code> is present.</p>
        pub fn replace_key_prefix_with(mut self, input: impl Into<std::string::String>) -> Self {
            self.replace_key_prefix_with = Some(input.into());
            self
        }
        /// <p>The object key prefix to use in the redirect request.</p>
        /// <p>Cannot be provided if <code>ReplaceKeyWith</code> is present.</p>
        pub fn set_replace_key_prefix_with(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.replace_key_prefix_with = input;
            self
        }
        /// <p>The specific object key to use in the redirect request.</p>
        /// <p>Cannot be provided if <code>ReplaceKeyPrefixWith</code> is present.</p>
        pub fn replace_key_with(mut self, input: impl Into<std::string::String>) -> Self {
            self.replace_key_with = Some(input.into());
            self
        }
        /// <p>The specific object key to use in the redirect request.</p>
        /// <p>Cannot be provided if <code>ReplaceKeyPrefixWith</code> is present.</p>
        pub fn set_replace_key_with(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.replace_key_with = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3BucketWebsiteConfigurationRoutingRuleRedirect`](crate::model::AwsS3BucketWebsiteConfigurationRoutingRuleRedirect)
        pub fn build(self) -> crate::model::AwsS3BucketWebsiteConfigurationRoutingRuleRedirect {
            crate::model::AwsS3BucketWebsiteConfigurationRoutingRuleRedirect {
                hostname: self.hostname,
                http_redirect_code: self.http_redirect_code,
                protocol: self.protocol,
                replace_key_prefix_with: self.replace_key_prefix_with,
                replace_key_with: self.replace_key_with,
            }
        }
    }
}
impl AwsS3BucketWebsiteConfigurationRoutingRuleRedirect {
    /// Creates a new builder-style object to manufacture [`AwsS3BucketWebsiteConfigurationRoutingRuleRedirect`](crate::model::AwsS3BucketWebsiteConfigurationRoutingRuleRedirect)
    pub fn builder(
    ) -> crate::model::aws_s3_bucket_website_configuration_routing_rule_redirect::Builder {
        crate::model::aws_s3_bucket_website_configuration_routing_rule_redirect::Builder::default()
    }
}

/// <p>The condition that must be met in order to apply the routing rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3BucketWebsiteConfigurationRoutingRuleCondition {
    /// <p>Indicates to redirect the request if the HTTP error code matches this value.</p>
    pub http_error_code_returned_equals: std::option::Option<std::string::String>,
    /// <p>Indicates to redirect the request if the key prefix matches this value.</p>
    pub key_prefix_equals: std::option::Option<std::string::String>,
}
impl AwsS3BucketWebsiteConfigurationRoutingRuleCondition {
    /// <p>Indicates to redirect the request if the HTTP error code matches this value.</p>
    pub fn http_error_code_returned_equals(&self) -> std::option::Option<&str> {
        self.http_error_code_returned_equals.as_deref()
    }
    /// <p>Indicates to redirect the request if the key prefix matches this value.</p>
    pub fn key_prefix_equals(&self) -> std::option::Option<&str> {
        self.key_prefix_equals.as_deref()
    }
}
impl std::fmt::Debug for AwsS3BucketWebsiteConfigurationRoutingRuleCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsS3BucketWebsiteConfigurationRoutingRuleCondition");
        formatter.field(
            "http_error_code_returned_equals",
            &self.http_error_code_returned_equals,
        );
        formatter.field("key_prefix_equals", &self.key_prefix_equals);
        formatter.finish()
    }
}
/// See [`AwsS3BucketWebsiteConfigurationRoutingRuleCondition`](crate::model::AwsS3BucketWebsiteConfigurationRoutingRuleCondition)
pub mod aws_s3_bucket_website_configuration_routing_rule_condition {

    /// A builder for [`AwsS3BucketWebsiteConfigurationRoutingRuleCondition`](crate::model::AwsS3BucketWebsiteConfigurationRoutingRuleCondition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) http_error_code_returned_equals: std::option::Option<std::string::String>,
        pub(crate) key_prefix_equals: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates to redirect the request if the HTTP error code matches this value.</p>
        pub fn http_error_code_returned_equals(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.http_error_code_returned_equals = Some(input.into());
            self
        }
        /// <p>Indicates to redirect the request if the HTTP error code matches this value.</p>
        pub fn set_http_error_code_returned_equals(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.http_error_code_returned_equals = input;
            self
        }
        /// <p>Indicates to redirect the request if the key prefix matches this value.</p>
        pub fn key_prefix_equals(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_prefix_equals = Some(input.into());
            self
        }
        /// <p>Indicates to redirect the request if the key prefix matches this value.</p>
        pub fn set_key_prefix_equals(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.key_prefix_equals = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3BucketWebsiteConfigurationRoutingRuleCondition`](crate::model::AwsS3BucketWebsiteConfigurationRoutingRuleCondition)
        pub fn build(self) -> crate::model::AwsS3BucketWebsiteConfigurationRoutingRuleCondition {
            crate::model::AwsS3BucketWebsiteConfigurationRoutingRuleCondition {
                http_error_code_returned_equals: self.http_error_code_returned_equals,
                key_prefix_equals: self.key_prefix_equals,
            }
        }
    }
}
impl AwsS3BucketWebsiteConfigurationRoutingRuleCondition {
    /// Creates a new builder-style object to manufacture [`AwsS3BucketWebsiteConfigurationRoutingRuleCondition`](crate::model::AwsS3BucketWebsiteConfigurationRoutingRuleCondition)
    pub fn builder(
    ) -> crate::model::aws_s3_bucket_website_configuration_routing_rule_condition::Builder {
        crate::model::aws_s3_bucket_website_configuration_routing_rule_condition::Builder::default()
    }
}

/// <p>The redirect behavior for requests to the website.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3BucketWebsiteConfigurationRedirectTo {
    /// <p>The name of the host to redirect requests to.</p>
    pub hostname: std::option::Option<std::string::String>,
    /// <p>The protocol to use when redirecting requests. By default, uses the same protocol as the original request.</p>
    pub protocol: std::option::Option<std::string::String>,
}
impl AwsS3BucketWebsiteConfigurationRedirectTo {
    /// <p>The name of the host to redirect requests to.</p>
    pub fn hostname(&self) -> std::option::Option<&str> {
        self.hostname.as_deref()
    }
    /// <p>The protocol to use when redirecting requests. By default, uses the same protocol as the original request.</p>
    pub fn protocol(&self) -> std::option::Option<&str> {
        self.protocol.as_deref()
    }
}
impl std::fmt::Debug for AwsS3BucketWebsiteConfigurationRedirectTo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsS3BucketWebsiteConfigurationRedirectTo");
        formatter.field("hostname", &self.hostname);
        formatter.field("protocol", &self.protocol);
        formatter.finish()
    }
}
/// See [`AwsS3BucketWebsiteConfigurationRedirectTo`](crate::model::AwsS3BucketWebsiteConfigurationRedirectTo)
pub mod aws_s3_bucket_website_configuration_redirect_to {

    /// A builder for [`AwsS3BucketWebsiteConfigurationRedirectTo`](crate::model::AwsS3BucketWebsiteConfigurationRedirectTo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hostname: std::option::Option<std::string::String>,
        pub(crate) protocol: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the host to redirect requests to.</p>
        pub fn hostname(mut self, input: impl Into<std::string::String>) -> Self {
            self.hostname = Some(input.into());
            self
        }
        /// <p>The name of the host to redirect requests to.</p>
        pub fn set_hostname(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hostname = input;
            self
        }
        /// <p>The protocol to use when redirecting requests. By default, uses the same protocol as the original request.</p>
        pub fn protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.protocol = Some(input.into());
            self
        }
        /// <p>The protocol to use when redirecting requests. By default, uses the same protocol as the original request.</p>
        pub fn set_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.protocol = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3BucketWebsiteConfigurationRedirectTo`](crate::model::AwsS3BucketWebsiteConfigurationRedirectTo)
        pub fn build(self) -> crate::model::AwsS3BucketWebsiteConfigurationRedirectTo {
            crate::model::AwsS3BucketWebsiteConfigurationRedirectTo {
                hostname: self.hostname,
                protocol: self.protocol,
            }
        }
    }
}
impl AwsS3BucketWebsiteConfigurationRedirectTo {
    /// Creates a new builder-style object to manufacture [`AwsS3BucketWebsiteConfigurationRedirectTo`](crate::model::AwsS3BucketWebsiteConfigurationRedirectTo)
    pub fn builder() -> crate::model::aws_s3_bucket_website_configuration_redirect_to::Builder {
        crate::model::aws_s3_bucket_website_configuration_redirect_to::Builder::default()
    }
}

/// <p>Information about logging for the S3 bucket</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3BucketLoggingConfiguration {
    /// <p>The name of the S3 bucket where log files for the S3 bucket are stored.</p>
    pub destination_bucket_name: std::option::Option<std::string::String>,
    /// <p>The prefix added to log files for the S3 bucket.</p>
    pub log_file_prefix: std::option::Option<std::string::String>,
}
impl AwsS3BucketLoggingConfiguration {
    /// <p>The name of the S3 bucket where log files for the S3 bucket are stored.</p>
    pub fn destination_bucket_name(&self) -> std::option::Option<&str> {
        self.destination_bucket_name.as_deref()
    }
    /// <p>The prefix added to log files for the S3 bucket.</p>
    pub fn log_file_prefix(&self) -> std::option::Option<&str> {
        self.log_file_prefix.as_deref()
    }
}
impl std::fmt::Debug for AwsS3BucketLoggingConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsS3BucketLoggingConfiguration");
        formatter.field("destination_bucket_name", &self.destination_bucket_name);
        formatter.field("log_file_prefix", &self.log_file_prefix);
        formatter.finish()
    }
}
/// See [`AwsS3BucketLoggingConfiguration`](crate::model::AwsS3BucketLoggingConfiguration)
pub mod aws_s3_bucket_logging_configuration {

    /// A builder for [`AwsS3BucketLoggingConfiguration`](crate::model::AwsS3BucketLoggingConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_bucket_name: std::option::Option<std::string::String>,
        pub(crate) log_file_prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the S3 bucket where log files for the S3 bucket are stored.</p>
        pub fn destination_bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_bucket_name = Some(input.into());
            self
        }
        /// <p>The name of the S3 bucket where log files for the S3 bucket are stored.</p>
        pub fn set_destination_bucket_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_bucket_name = input;
            self
        }
        /// <p>The prefix added to log files for the S3 bucket.</p>
        pub fn log_file_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_file_prefix = Some(input.into());
            self
        }
        /// <p>The prefix added to log files for the S3 bucket.</p>
        pub fn set_log_file_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_file_prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3BucketLoggingConfiguration`](crate::model::AwsS3BucketLoggingConfiguration)
        pub fn build(self) -> crate::model::AwsS3BucketLoggingConfiguration {
            crate::model::AwsS3BucketLoggingConfiguration {
                destination_bucket_name: self.destination_bucket_name,
                log_file_prefix: self.log_file_prefix,
            }
        }
    }
}
impl AwsS3BucketLoggingConfiguration {
    /// Creates a new builder-style object to manufacture [`AwsS3BucketLoggingConfiguration`](crate::model::AwsS3BucketLoggingConfiguration)
    pub fn builder() -> crate::model::aws_s3_bucket_logging_configuration::Builder {
        crate::model::aws_s3_bucket_logging_configuration::Builder::default()
    }
}

/// <p>The lifecycle configuration for the objects in the S3 bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3BucketBucketLifecycleConfigurationDetails {
    /// <p>The lifecycle rules.</p>
    pub rules: std::option::Option<
        std::vec::Vec<crate::model::AwsS3BucketBucketLifecycleConfigurationRulesDetails>,
    >,
}
impl AwsS3BucketBucketLifecycleConfigurationDetails {
    /// <p>The lifecycle rules.</p>
    pub fn rules(
        &self,
    ) -> std::option::Option<&[crate::model::AwsS3BucketBucketLifecycleConfigurationRulesDetails]>
    {
        self.rules.as_deref()
    }
}
impl std::fmt::Debug for AwsS3BucketBucketLifecycleConfigurationDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsS3BucketBucketLifecycleConfigurationDetails");
        formatter.field("rules", &self.rules);
        formatter.finish()
    }
}
/// See [`AwsS3BucketBucketLifecycleConfigurationDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationDetails)
pub mod aws_s3_bucket_bucket_lifecycle_configuration_details {

    /// A builder for [`AwsS3BucketBucketLifecycleConfigurationDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rules: std::option::Option<
            std::vec::Vec<crate::model::AwsS3BucketBucketLifecycleConfigurationRulesDetails>,
        >,
    }
    impl Builder {
        /// Appends an item to `rules`.
        ///
        /// To override the contents of this collection use [`set_rules`](Self::set_rules).
        ///
        /// <p>The lifecycle rules.</p>
        pub fn rules(
            mut self,
            input: crate::model::AwsS3BucketBucketLifecycleConfigurationRulesDetails,
        ) -> Self {
            let mut v = self.rules.unwrap_or_default();
            v.push(input);
            self.rules = Some(v);
            self
        }
        /// <p>The lifecycle rules.</p>
        pub fn set_rules(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsS3BucketBucketLifecycleConfigurationRulesDetails>,
            >,
        ) -> Self {
            self.rules = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3BucketBucketLifecycleConfigurationDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationDetails)
        pub fn build(self) -> crate::model::AwsS3BucketBucketLifecycleConfigurationDetails {
            crate::model::AwsS3BucketBucketLifecycleConfigurationDetails { rules: self.rules }
        }
    }
}
impl AwsS3BucketBucketLifecycleConfigurationDetails {
    /// Creates a new builder-style object to manufacture [`AwsS3BucketBucketLifecycleConfigurationDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationDetails)
    pub fn builder() -> crate::model::aws_s3_bucket_bucket_lifecycle_configuration_details::Builder
    {
        crate::model::aws_s3_bucket_bucket_lifecycle_configuration_details::Builder::default()
    }
}

/// <p>Configuration for a lifecycle rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3BucketBucketLifecycleConfigurationRulesDetails  {
    /// <p>How Amazon S3 responds when a multipart upload is incomplete. Specifically, provides a number of days before Amazon S3 cancels the entire upload.</p>
    pub abort_incomplete_multipart_upload: std::option::Option<crate::model::AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails>,
    /// <p>The date when objects are moved or deleted.</p> 
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub expiration_date: std::option::Option<std::string::String>,
    /// <p>The length in days of the lifetime for objects that are subject to the rule.</p>
    pub expiration_in_days: i32,
    /// <p>Whether Amazon S3 removes a delete marker that has no noncurrent versions. If set to <code>true</code>, the delete marker is expired. If set to <code>false</code>, the policy takes no action.</p> 
    /// <p>If you provide <code>ExpiredObjectDeleteMarker</code>, you cannot provide <code>ExpirationInDays</code> or <code>ExpirationDate</code>.</p>
    pub expired_object_delete_marker: bool,
    /// <p>Identifies the objects that a rule applies to.</p>
    pub filter: std::option::Option<crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails>,
    /// <p>The unique identifier of the rule.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The number of days that an object is noncurrent before Amazon S3 can perform the associated action.</p>
    pub noncurrent_version_expiration_in_days: i32,
    /// <p>Transition rules that describe when noncurrent objects transition to a specified storage class.</p>
    pub noncurrent_version_transitions: std::option::Option<std::vec::Vec<crate::model::AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails>>,
    /// <p>A prefix that identifies one or more objects that the rule applies to.</p>
    pub prefix: std::option::Option<std::string::String>,
    /// <p>The current status of the rule. Indicates whether the rule is currently being applied.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>Transition rules that indicate when objects transition to a specified storage class.</p>
    pub transitions: std::option::Option<std::vec::Vec<crate::model::AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails>>,
}
impl AwsS3BucketBucketLifecycleConfigurationRulesDetails {
    /// <p>How Amazon S3 responds when a multipart upload is incomplete. Specifically, provides a number of days before Amazon S3 cancels the entire upload.</p>
    pub fn abort_incomplete_multipart_upload(&self) -> std::option::Option<& crate::model::AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails>{
        self.abort_incomplete_multipart_upload.as_ref()
    }
    /// <p>The date when objects are moved or deleted.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn expiration_date(&self) -> std::option::Option<&str> {
        self.expiration_date.as_deref()
    }
    /// <p>The length in days of the lifetime for objects that are subject to the rule.</p>
    pub fn expiration_in_days(&self) -> i32 {
        self.expiration_in_days
    }
    /// <p>Whether Amazon S3 removes a delete marker that has no noncurrent versions. If set to <code>true</code>, the delete marker is expired. If set to <code>false</code>, the policy takes no action.</p>
    /// <p>If you provide <code>ExpiredObjectDeleteMarker</code>, you cannot provide <code>ExpirationInDays</code> or <code>ExpirationDate</code>.</p>
    pub fn expired_object_delete_marker(&self) -> bool {
        self.expired_object_delete_marker
    }
    /// <p>Identifies the objects that a rule applies to.</p>
    pub fn filter(
        &self,
    ) -> std::option::Option<&crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails>
    {
        self.filter.as_ref()
    }
    /// <p>The unique identifier of the rule.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The number of days that an object is noncurrent before Amazon S3 can perform the associated action.</p>
    pub fn noncurrent_version_expiration_in_days(&self) -> i32 {
        self.noncurrent_version_expiration_in_days
    }
    /// <p>Transition rules that describe when noncurrent objects transition to a specified storage class.</p>
    pub fn noncurrent_version_transitions(&self) -> std::option::Option<& [crate::model::AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails]>{
        self.noncurrent_version_transitions.as_deref()
    }
    /// <p>A prefix that identifies one or more objects that the rule applies to.</p>
    pub fn prefix(&self) -> std::option::Option<&str> {
        self.prefix.as_deref()
    }
    /// <p>The current status of the rule. Indicates whether the rule is currently being applied.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>Transition rules that indicate when objects transition to a specified storage class.</p>
    pub fn transitions(
        &self,
    ) -> std::option::Option<
        &[crate::model::AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails],
    > {
        self.transitions.as_deref()
    }
}
impl std::fmt::Debug for AwsS3BucketBucketLifecycleConfigurationRulesDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsS3BucketBucketLifecycleConfigurationRulesDetails");
        formatter.field(
            "abort_incomplete_multipart_upload",
            &self.abort_incomplete_multipart_upload,
        );
        formatter.field("expiration_date", &self.expiration_date);
        formatter.field("expiration_in_days", &self.expiration_in_days);
        formatter.field(
            "expired_object_delete_marker",
            &self.expired_object_delete_marker,
        );
        formatter.field("filter", &self.filter);
        formatter.field("id", &self.id);
        formatter.field(
            "noncurrent_version_expiration_in_days",
            &self.noncurrent_version_expiration_in_days,
        );
        formatter.field(
            "noncurrent_version_transitions",
            &self.noncurrent_version_transitions,
        );
        formatter.field("prefix", &self.prefix);
        formatter.field("status", &self.status);
        formatter.field("transitions", &self.transitions);
        formatter.finish()
    }
}
/// See [`AwsS3BucketBucketLifecycleConfigurationRulesDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesDetails)
pub mod aws_s3_bucket_bucket_lifecycle_configuration_rules_details {

    /// A builder for [`AwsS3BucketBucketLifecycleConfigurationRulesDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) abort_incomplete_multipart_upload: std::option::Option<crate::model::AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails>,
        pub(crate) expiration_date: std::option::Option<std::string::String>,
        pub(crate) expiration_in_days: std::option::Option<i32>,
        pub(crate) expired_object_delete_marker: std::option::Option<bool>,
        pub(crate) filter: std::option::Option<crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) noncurrent_version_expiration_in_days: std::option::Option<i32>,
        pub(crate) noncurrent_version_transitions: std::option::Option<std::vec::Vec<crate::model::AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails>>,
        pub(crate) prefix: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) transitions: std::option::Option<std::vec::Vec<crate::model::AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails>>,
    }
    impl Builder {
        /// <p>How Amazon S3 responds when a multipart upload is incomplete. Specifically, provides a number of days before Amazon S3 cancels the entire upload.</p>
        pub fn abort_incomplete_multipart_upload(
            mut self,
            input: crate::model::AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails,
        ) -> Self {
            self.abort_incomplete_multipart_upload = Some(input);
            self
        }
        /// <p>How Amazon S3 responds when a multipart upload is incomplete. Specifically, provides a number of days before Amazon S3 cancels the entire upload.</p>
        pub fn set_abort_incomplete_multipart_upload(
            mut self,
            input: std::option::Option<crate::model::AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails>,
        ) -> Self {
            self.abort_incomplete_multipart_upload = input;
            self
        }
        /// <p>The date when objects are moved or deleted.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn expiration_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.expiration_date = Some(input.into());
            self
        }
        /// <p>The date when objects are moved or deleted.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_expiration_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expiration_date = input;
            self
        }
        /// <p>The length in days of the lifetime for objects that are subject to the rule.</p>
        pub fn expiration_in_days(mut self, input: i32) -> Self {
            self.expiration_in_days = Some(input);
            self
        }
        /// <p>The length in days of the lifetime for objects that are subject to the rule.</p>
        pub fn set_expiration_in_days(mut self, input: std::option::Option<i32>) -> Self {
            self.expiration_in_days = input;
            self
        }
        /// <p>Whether Amazon S3 removes a delete marker that has no noncurrent versions. If set to <code>true</code>, the delete marker is expired. If set to <code>false</code>, the policy takes no action.</p>
        /// <p>If you provide <code>ExpiredObjectDeleteMarker</code>, you cannot provide <code>ExpirationInDays</code> or <code>ExpirationDate</code>.</p>
        pub fn expired_object_delete_marker(mut self, input: bool) -> Self {
            self.expired_object_delete_marker = Some(input);
            self
        }
        /// <p>Whether Amazon S3 removes a delete marker that has no noncurrent versions. If set to <code>true</code>, the delete marker is expired. If set to <code>false</code>, the policy takes no action.</p>
        /// <p>If you provide <code>ExpiredObjectDeleteMarker</code>, you cannot provide <code>ExpirationInDays</code> or <code>ExpirationDate</code>.</p>
        pub fn set_expired_object_delete_marker(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.expired_object_delete_marker = input;
            self
        }
        /// <p>Identifies the objects that a rule applies to.</p>
        pub fn filter(
            mut self,
            input: crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails,
        ) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>Identifies the objects that a rule applies to.</p>
        pub fn set_filter(
            mut self,
            input: std::option::Option<
                crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails,
            >,
        ) -> Self {
            self.filter = input;
            self
        }
        /// <p>The unique identifier of the rule.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the rule.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The number of days that an object is noncurrent before Amazon S3 can perform the associated action.</p>
        pub fn noncurrent_version_expiration_in_days(mut self, input: i32) -> Self {
            self.noncurrent_version_expiration_in_days = Some(input);
            self
        }
        /// <p>The number of days that an object is noncurrent before Amazon S3 can perform the associated action.</p>
        pub fn set_noncurrent_version_expiration_in_days(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.noncurrent_version_expiration_in_days = input;
            self
        }
        /// Appends an item to `noncurrent_version_transitions`.
        ///
        /// To override the contents of this collection use [`set_noncurrent_version_transitions`](Self::set_noncurrent_version_transitions).
        ///
        /// <p>Transition rules that describe when noncurrent objects transition to a specified storage class.</p>
        pub fn noncurrent_version_transitions(
            mut self,
            input: crate::model::AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails,
        ) -> Self {
            let mut v = self.noncurrent_version_transitions.unwrap_or_default();
            v.push(input);
            self.noncurrent_version_transitions = Some(v);
            self
        }
        /// <p>Transition rules that describe when noncurrent objects transition to a specified storage class.</p>
        pub fn set_noncurrent_version_transitions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails>>,
        ) -> Self {
            self.noncurrent_version_transitions = input;
            self
        }
        /// <p>A prefix that identifies one or more objects that the rule applies to.</p>
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix = Some(input.into());
            self
        }
        /// <p>A prefix that identifies one or more objects that the rule applies to.</p>
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix = input;
            self
        }
        /// <p>The current status of the rule. Indicates whether the rule is currently being applied.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The current status of the rule. Indicates whether the rule is currently being applied.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Appends an item to `transitions`.
        ///
        /// To override the contents of this collection use [`set_transitions`](Self::set_transitions).
        ///
        /// <p>Transition rules that indicate when objects transition to a specified storage class.</p>
        pub fn transitions(
            mut self,
            input: crate::model::AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails,
        ) -> Self {
            let mut v = self.transitions.unwrap_or_default();
            v.push(input);
            self.transitions = Some(v);
            self
        }
        /// <p>Transition rules that indicate when objects transition to a specified storage class.</p>
        pub fn set_transitions(
            mut self,
            input: std::option::Option<
                std::vec::Vec<
                    crate::model::AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails,
                >,
            >,
        ) -> Self {
            self.transitions = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3BucketBucketLifecycleConfigurationRulesDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesDetails)
        pub fn build(self) -> crate::model::AwsS3BucketBucketLifecycleConfigurationRulesDetails {
            crate::model::AwsS3BucketBucketLifecycleConfigurationRulesDetails {
                abort_incomplete_multipart_upload: self.abort_incomplete_multipart_upload,
                expiration_date: self.expiration_date,
                expiration_in_days: self.expiration_in_days.unwrap_or_default(),
                expired_object_delete_marker: self.expired_object_delete_marker.unwrap_or_default(),
                filter: self.filter,
                id: self.id,
                noncurrent_version_expiration_in_days: self
                    .noncurrent_version_expiration_in_days
                    .unwrap_or_default(),
                noncurrent_version_transitions: self.noncurrent_version_transitions,
                prefix: self.prefix,
                status: self.status,
                transitions: self.transitions,
            }
        }
    }
}
impl AwsS3BucketBucketLifecycleConfigurationRulesDetails {
    /// Creates a new builder-style object to manufacture [`AwsS3BucketBucketLifecycleConfigurationRulesDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesDetails)
    pub fn builder(
    ) -> crate::model::aws_s3_bucket_bucket_lifecycle_configuration_rules_details::Builder {
        crate::model::aws_s3_bucket_bucket_lifecycle_configuration_rules_details::Builder::default()
    }
}

/// <p>A rule for when objects transition to specific storage classes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails {
    /// <p>A date on which to transition objects to the specified storage class. If you provide <code>Date</code>, you cannot provide <code>Days</code>.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub date: std::option::Option<std::string::String>,
    /// <p>The number of days after which to transition the object to the specified storage class. If you provide <code>Days</code>, you cannot provide <code>Date</code>.</p>
    pub days: i32,
    /// <p>The storage class to transition the object to.</p>
    pub storage_class: std::option::Option<std::string::String>,
}
impl AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails {
    /// <p>A date on which to transition objects to the specified storage class. If you provide <code>Date</code>, you cannot provide <code>Days</code>.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn date(&self) -> std::option::Option<&str> {
        self.date.as_deref()
    }
    /// <p>The number of days after which to transition the object to the specified storage class. If you provide <code>Days</code>, you cannot provide <code>Date</code>.</p>
    pub fn days(&self) -> i32 {
        self.days
    }
    /// <p>The storage class to transition the object to.</p>
    pub fn storage_class(&self) -> std::option::Option<&str> {
        self.storage_class.as_deref()
    }
}
impl std::fmt::Debug for AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails");
        formatter.field("date", &self.date);
        formatter.field("days", &self.days);
        formatter.field("storage_class", &self.storage_class);
        formatter.finish()
    }
}
/// See [`AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails)
pub mod aws_s3_bucket_bucket_lifecycle_configuration_rules_transitions_details {

    /// A builder for [`AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) date: std::option::Option<std::string::String>,
        pub(crate) days: std::option::Option<i32>,
        pub(crate) storage_class: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A date on which to transition objects to the specified storage class. If you provide <code>Date</code>, you cannot provide <code>Days</code>.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn date(mut self, input: impl Into<std::string::String>) -> Self {
            self.date = Some(input.into());
            self
        }
        /// <p>A date on which to transition objects to the specified storage class. If you provide <code>Date</code>, you cannot provide <code>Days</code>.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.date = input;
            self
        }
        /// <p>The number of days after which to transition the object to the specified storage class. If you provide <code>Days</code>, you cannot provide <code>Date</code>.</p>
        pub fn days(mut self, input: i32) -> Self {
            self.days = Some(input);
            self
        }
        /// <p>The number of days after which to transition the object to the specified storage class. If you provide <code>Days</code>, you cannot provide <code>Date</code>.</p>
        pub fn set_days(mut self, input: std::option::Option<i32>) -> Self {
            self.days = input;
            self
        }
        /// <p>The storage class to transition the object to.</p>
        pub fn storage_class(mut self, input: impl Into<std::string::String>) -> Self {
            self.storage_class = Some(input.into());
            self
        }
        /// <p>The storage class to transition the object to.</p>
        pub fn set_storage_class(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.storage_class = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails {
            crate::model::AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails {
                date: self.date,
                days: self.days.unwrap_or_default(),
                storage_class: self.storage_class,
            }
        }
    }
}
impl AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails {
    /// Creates a new builder-style object to manufacture [`AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails)
    pub fn builder(
    ) -> crate::model::aws_s3_bucket_bucket_lifecycle_configuration_rules_transitions_details::Builder
    {
        crate::model::aws_s3_bucket_bucket_lifecycle_configuration_rules_transitions_details::Builder::default()
    }
}

/// <p>A transition rule that describes when noncurrent objects transition to a specified storage class.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails {
    /// <p>The number of days that an object is noncurrent before Amazon S3 can perform the associated action.</p>
    pub days: i32,
    /// <p>The class of storage to change the object to after the object is noncurrent for the specified number of days.</p>
    pub storage_class: std::option::Option<std::string::String>,
}
impl AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails {
    /// <p>The number of days that an object is noncurrent before Amazon S3 can perform the associated action.</p>
    pub fn days(&self) -> i32 {
        self.days
    }
    /// <p>The class of storage to change the object to after the object is noncurrent for the specified number of days.</p>
    pub fn storage_class(&self) -> std::option::Option<&str> {
        self.storage_class.as_deref()
    }
}
impl std::fmt::Debug
    for AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct(
            "AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails",
        );
        formatter.field("days", &self.days);
        formatter.field("storage_class", &self.storage_class);
        formatter.finish()
    }
}
/// See [`AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails)
pub mod aws_s3_bucket_bucket_lifecycle_configuration_rules_noncurrent_version_transitions_details {

    /// A builder for [`AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) days: std::option::Option<i32>,
        pub(crate) storage_class: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The number of days that an object is noncurrent before Amazon S3 can perform the associated action.</p>
        pub fn days(mut self, input: i32) -> Self {
            self.days = Some(input);
            self
        }
        /// <p>The number of days that an object is noncurrent before Amazon S3 can perform the associated action.</p>
        pub fn set_days(mut self, input: std::option::Option<i32>) -> Self {
            self.days = input;
            self
        }
        /// <p>The class of storage to change the object to after the object is noncurrent for the specified number of days.</p>
        pub fn storage_class(mut self, input: impl Into<std::string::String>) -> Self {
            self.storage_class = Some(input.into());
            self
        }
        /// <p>The class of storage to change the object to after the object is noncurrent for the specified number of days.</p>
        pub fn set_storage_class(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.storage_class = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails)
        pub fn build(self) -> crate::model::AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails{
            crate::model::AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails {
                days: self.days
                    .unwrap_or_default()
                ,
                storage_class: self.storage_class
                ,
            }
        }
    }
}
impl AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails {
    /// Creates a new builder-style object to manufacture [`AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails)
    pub fn builder() -> crate::model::aws_s3_bucket_bucket_lifecycle_configuration_rules_noncurrent_version_transitions_details::Builder{
        crate::model::aws_s3_bucket_bucket_lifecycle_configuration_rules_noncurrent_version_transitions_details::Builder::default()
    }
}

/// <p>Identifies the objects that a rule applies to.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails {
    /// <p>The configuration for the filter.</p>
    pub predicate: std::option::Option<
        crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails,
    >,
}
impl AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails {
    /// <p>The configuration for the filter.</p>
    pub fn predicate(
        &self,
    ) -> std::option::Option<
        &crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails,
    > {
        self.predicate.as_ref()
    }
}
impl std::fmt::Debug for AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails");
        formatter.field("predicate", &self.predicate);
        formatter.finish()
    }
}
/// See [`AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails)
pub mod aws_s3_bucket_bucket_lifecycle_configuration_rules_filter_details {

    /// A builder for [`AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) predicate: std::option::Option<
            crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails,
        >,
    }
    impl Builder {
        /// <p>The configuration for the filter.</p>
        pub fn predicate(
            mut self,
            input: crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails,
        ) -> Self {
            self.predicate = Some(input);
            self
        }
        /// <p>The configuration for the filter.</p>
        pub fn set_predicate(
            mut self,
            input: std::option::Option<
                crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails,
            >,
        ) -> Self {
            self.predicate = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails {
            crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails {
                predicate: self.predicate,
            }
        }
    }
}
impl AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails {
    /// Creates a new builder-style object to manufacture [`AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails)
    pub fn builder(
    ) -> crate::model::aws_s3_bucket_bucket_lifecycle_configuration_rules_filter_details::Builder
    {
        crate::model::aws_s3_bucket_bucket_lifecycle_configuration_rules_filter_details::Builder::default()
    }
}

/// <p>The configuration for the filter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails  {
    /// <p>The values to use for the filter.</p>
    pub operands: std::option::Option<std::vec::Vec<crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails>>,
    /// <p>A prefix filter.</p>
    pub prefix: std::option::Option<std::string::String>,
    /// <p>A tag filter.</p>
    pub tag: std::option::Option<crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails>,
    /// <p>Whether to use <code>AND</code> or <code>OR</code> to join the operands.</p>
    pub r#type: std::option::Option<std::string::String>,
}
impl AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails {
    /// <p>The values to use for the filter.</p>
    pub fn operands(&self) -> std::option::Option<& [crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails]>{
        self.operands.as_deref()
    }
    /// <p>A prefix filter.</p>
    pub fn prefix(&self) -> std::option::Option<&str> {
        self.prefix.as_deref()
    }
    /// <p>A tag filter.</p>
    pub fn tag(
        &self,
    ) -> std::option::Option<
        &crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails,
    > {
        self.tag.as_ref()
    }
    /// <p>Whether to use <code>AND</code> or <code>OR</code> to join the operands.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails");
        formatter.field("operands", &self.operands);
        formatter.field("prefix", &self.prefix);
        formatter.field("tag", &self.tag);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails)
pub mod aws_s3_bucket_bucket_lifecycle_configuration_rules_filter_predicate_details {

    /// A builder for [`AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) operands: std::option::Option<std::vec::Vec<crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails>>,
        pub(crate) prefix: std::option::Option<std::string::String>,
        pub(crate) tag: std::option::Option<crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `operands`.
        ///
        /// To override the contents of this collection use [`set_operands`](Self::set_operands).
        ///
        /// <p>The values to use for the filter.</p>
        pub fn operands(
            mut self,
            input: crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails,
        ) -> Self {
            let mut v = self.operands.unwrap_or_default();
            v.push(input);
            self.operands = Some(v);
            self
        }
        /// <p>The values to use for the filter.</p>
        pub fn set_operands(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails>>,
        ) -> Self {
            self.operands = input;
            self
        }
        /// <p>A prefix filter.</p>
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix = Some(input.into());
            self
        }
        /// <p>A prefix filter.</p>
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix = input;
            self
        }
        /// <p>A tag filter.</p>
        pub fn tag(
            mut self,
            input: crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails,
        ) -> Self {
            self.tag = Some(input);
            self
        }
        /// <p>A tag filter.</p>
        pub fn set_tag(
            mut self,
            input: std::option::Option<
                crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails,
            >,
        ) -> Self {
            self.tag = input;
            self
        }
        /// <p>Whether to use <code>AND</code> or <code>OR</code> to join the operands.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>Whether to use <code>AND</code> or <code>OR</code> to join the operands.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails
        {
            crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails {
                operands: self.operands,
                prefix: self.prefix,
                tag: self.tag,
                r#type: self.r#type,
            }
        }
    }
}
impl AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails {
    /// Creates a new builder-style object to manufacture [`AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails)
    pub fn builder() -> crate::model::aws_s3_bucket_bucket_lifecycle_configuration_rules_filter_predicate_details::Builder{
        crate::model::aws_s3_bucket_bucket_lifecycle_configuration_rules_filter_predicate_details::Builder::default()
    }
}

/// <p>A tag filter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails {
    /// <p>The tag key.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The tag value</p>
    pub value: std::option::Option<std::string::String>,
}
impl AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails {
    /// <p>The tag key.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The tag value</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails)
pub mod aws_s3_bucket_bucket_lifecycle_configuration_rules_filter_predicate_tag_details {

    /// A builder for [`AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The tag key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The tag key.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The tag value</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The tag value</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails
        {
            crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails {
    /// Creates a new builder-style object to manufacture [`AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails)
    pub fn builder() -> crate::model::aws_s3_bucket_bucket_lifecycle_configuration_rules_filter_predicate_tag_details::Builder{
        crate::model::aws_s3_bucket_bucket_lifecycle_configuration_rules_filter_predicate_tag_details::Builder::default()
    }
}

/// <p>A value to use for the filter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails {
    /// <p>Prefix text for matching objects.</p>
    pub prefix: std::option::Option<std::string::String>,
    /// <p>A tag that is assigned to matching objects.</p>
    pub tag: std::option::Option<
        crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails,
    >,
    /// <p>The type of filter value.</p>
    pub r#type: std::option::Option<std::string::String>,
}
impl AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails {
    /// <p>Prefix text for matching objects.</p>
    pub fn prefix(&self) -> std::option::Option<&str> {
        self.prefix.as_deref()
    }
    /// <p>A tag that is assigned to matching objects.</p>
    pub fn tag(&self) -> std::option::Option<& crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails>{
        self.tag.as_ref()
    }
    /// <p>The type of filter value.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug
    for AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct(
            "AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails",
        );
        formatter.field("prefix", &self.prefix);
        formatter.field("tag", &self.tag);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails)
pub mod aws_s3_bucket_bucket_lifecycle_configuration_rules_filter_predicate_operands_details {

    /// A builder for [`AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) prefix: std::option::Option<std::string::String>,
        pub(crate) tag: std::option::Option<crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Prefix text for matching objects.</p>
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix = Some(input.into());
            self
        }
        /// <p>Prefix text for matching objects.</p>
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix = input;
            self
        }
        /// <p>A tag that is assigned to matching objects.</p>
        pub fn tag(
            mut self,
            input: crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails,
        ) -> Self {
            self.tag = Some(input);
            self
        }
        /// <p>A tag that is assigned to matching objects.</p>
        pub fn set_tag(
            mut self,
            input: std::option::Option<crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails>,
        ) -> Self {
            self.tag = input;
            self
        }
        /// <p>The type of filter value.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of filter value.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails
        {
            crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails {
                prefix: self.prefix
                ,
                tag: self.tag
                ,
                r#type: self.r#type
                ,
            }
        }
    }
}
impl AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails {
    /// Creates a new builder-style object to manufacture [`AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails)
    pub fn builder() -> crate::model::aws_s3_bucket_bucket_lifecycle_configuration_rules_filter_predicate_operands_details::Builder{
        crate::model::aws_s3_bucket_bucket_lifecycle_configuration_rules_filter_predicate_operands_details::Builder::default()
    }
}

/// <p>A tag that is assigned to matching objects.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails {
    /// <p>The tag key.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The tag value.</p>
    pub value: std::option::Option<std::string::String>,
}
impl AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails {
    /// <p>The tag key.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The tag value.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug
    for AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct(
            "AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails",
        );
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails)
pub mod aws_s3_bucket_bucket_lifecycle_configuration_rules_filter_predicate_operands_tag_details {

    /// A builder for [`AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The tag key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The tag key.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The tag value.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The tag value.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails)
        pub fn build(self) -> crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails{
            crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails {
                key: self.key
                ,
                value: self.value
                ,
            }
        }
    }
}
impl AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails {
    /// Creates a new builder-style object to manufacture [`AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails)
    pub fn builder() -> crate::model::aws_s3_bucket_bucket_lifecycle_configuration_rules_filter_predicate_operands_tag_details::Builder{
        crate::model::aws_s3_bucket_bucket_lifecycle_configuration_rules_filter_predicate_operands_tag_details::Builder::default()
    }
}

/// <p>Information about what Amazon S3 does when a multipart upload is incomplete.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails {
    /// <p>The number of days after which Amazon S3 cancels an incomplete multipart upload.</p>
    pub days_after_initiation: i32,
}
impl AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails {
    /// <p>The number of days after which Amazon S3 cancels an incomplete multipart upload.</p>
    pub fn days_after_initiation(&self) -> i32 {
        self.days_after_initiation
    }
}
impl std::fmt::Debug
    for AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct(
            "AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails",
        );
        formatter.field("days_after_initiation", &self.days_after_initiation);
        formatter.finish()
    }
}
/// See [`AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails)
pub mod aws_s3_bucket_bucket_lifecycle_configuration_rules_abort_incomplete_multipart_upload_details {

    /// A builder for [`AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) days_after_initiation: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The number of days after which Amazon S3 cancels an incomplete multipart upload.</p>
        pub fn days_after_initiation(mut self, input: i32) -> Self {
            self.days_after_initiation = Some(input);
            self
        }
        /// <p>The number of days after which Amazon S3 cancels an incomplete multipart upload.</p>
        pub fn set_days_after_initiation(mut self, input: std::option::Option<i32>) -> Self {
            self.days_after_initiation = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails)
        pub fn build(self) -> crate::model::AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails{
            crate::model::AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails {
                days_after_initiation: self.days_after_initiation
                    .unwrap_or_default()
                ,
            }
        }
    }
}
impl AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails {
    /// Creates a new builder-style object to manufacture [`AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails`](crate::model::AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails)
    pub fn builder() -> crate::model::aws_s3_bucket_bucket_lifecycle_configuration_rules_abort_incomplete_multipart_upload_details::Builder{
        crate::model::aws_s3_bucket_bucket_lifecycle_configuration_rules_abort_incomplete_multipart_upload_details::Builder::default()
    }
}

/// <p>The encryption configuration for the S3 bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3BucketServerSideEncryptionConfiguration {
    /// <p>The encryption rules that are applied to the S3 bucket.</p>
    pub rules:
        std::option::Option<std::vec::Vec<crate::model::AwsS3BucketServerSideEncryptionRule>>,
}
impl AwsS3BucketServerSideEncryptionConfiguration {
    /// <p>The encryption rules that are applied to the S3 bucket.</p>
    pub fn rules(
        &self,
    ) -> std::option::Option<&[crate::model::AwsS3BucketServerSideEncryptionRule]> {
        self.rules.as_deref()
    }
}
impl std::fmt::Debug for AwsS3BucketServerSideEncryptionConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsS3BucketServerSideEncryptionConfiguration");
        formatter.field("rules", &self.rules);
        formatter.finish()
    }
}
/// See [`AwsS3BucketServerSideEncryptionConfiguration`](crate::model::AwsS3BucketServerSideEncryptionConfiguration)
pub mod aws_s3_bucket_server_side_encryption_configuration {

    /// A builder for [`AwsS3BucketServerSideEncryptionConfiguration`](crate::model::AwsS3BucketServerSideEncryptionConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rules:
            std::option::Option<std::vec::Vec<crate::model::AwsS3BucketServerSideEncryptionRule>>,
    }
    impl Builder {
        /// Appends an item to `rules`.
        ///
        /// To override the contents of this collection use [`set_rules`](Self::set_rules).
        ///
        /// <p>The encryption rules that are applied to the S3 bucket.</p>
        pub fn rules(mut self, input: crate::model::AwsS3BucketServerSideEncryptionRule) -> Self {
            let mut v = self.rules.unwrap_or_default();
            v.push(input);
            self.rules = Some(v);
            self
        }
        /// <p>The encryption rules that are applied to the S3 bucket.</p>
        pub fn set_rules(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsS3BucketServerSideEncryptionRule>,
            >,
        ) -> Self {
            self.rules = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3BucketServerSideEncryptionConfiguration`](crate::model::AwsS3BucketServerSideEncryptionConfiguration)
        pub fn build(self) -> crate::model::AwsS3BucketServerSideEncryptionConfiguration {
            crate::model::AwsS3BucketServerSideEncryptionConfiguration { rules: self.rules }
        }
    }
}
impl AwsS3BucketServerSideEncryptionConfiguration {
    /// Creates a new builder-style object to manufacture [`AwsS3BucketServerSideEncryptionConfiguration`](crate::model::AwsS3BucketServerSideEncryptionConfiguration)
    pub fn builder() -> crate::model::aws_s3_bucket_server_side_encryption_configuration::Builder {
        crate::model::aws_s3_bucket_server_side_encryption_configuration::Builder::default()
    }
}

/// <p>An encryption rule to apply to the S3 bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3BucketServerSideEncryptionRule {
    /// <p>Specifies the default server-side encryption to apply to new objects in the bucket. If a <code>PUT</code> object request doesn't specify any server-side encryption, this default encryption is applied.</p>
    pub apply_server_side_encryption_by_default:
        std::option::Option<crate::model::AwsS3BucketServerSideEncryptionByDefault>,
}
impl AwsS3BucketServerSideEncryptionRule {
    /// <p>Specifies the default server-side encryption to apply to new objects in the bucket. If a <code>PUT</code> object request doesn't specify any server-side encryption, this default encryption is applied.</p>
    pub fn apply_server_side_encryption_by_default(
        &self,
    ) -> std::option::Option<&crate::model::AwsS3BucketServerSideEncryptionByDefault> {
        self.apply_server_side_encryption_by_default.as_ref()
    }
}
impl std::fmt::Debug for AwsS3BucketServerSideEncryptionRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsS3BucketServerSideEncryptionRule");
        formatter.field(
            "apply_server_side_encryption_by_default",
            &self.apply_server_side_encryption_by_default,
        );
        formatter.finish()
    }
}
/// See [`AwsS3BucketServerSideEncryptionRule`](crate::model::AwsS3BucketServerSideEncryptionRule)
pub mod aws_s3_bucket_server_side_encryption_rule {

    /// A builder for [`AwsS3BucketServerSideEncryptionRule`](crate::model::AwsS3BucketServerSideEncryptionRule)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) apply_server_side_encryption_by_default:
            std::option::Option<crate::model::AwsS3BucketServerSideEncryptionByDefault>,
    }
    impl Builder {
        /// <p>Specifies the default server-side encryption to apply to new objects in the bucket. If a <code>PUT</code> object request doesn't specify any server-side encryption, this default encryption is applied.</p>
        pub fn apply_server_side_encryption_by_default(
            mut self,
            input: crate::model::AwsS3BucketServerSideEncryptionByDefault,
        ) -> Self {
            self.apply_server_side_encryption_by_default = Some(input);
            self
        }
        /// <p>Specifies the default server-side encryption to apply to new objects in the bucket. If a <code>PUT</code> object request doesn't specify any server-side encryption, this default encryption is applied.</p>
        pub fn set_apply_server_side_encryption_by_default(
            mut self,
            input: std::option::Option<crate::model::AwsS3BucketServerSideEncryptionByDefault>,
        ) -> Self {
            self.apply_server_side_encryption_by_default = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3BucketServerSideEncryptionRule`](crate::model::AwsS3BucketServerSideEncryptionRule)
        pub fn build(self) -> crate::model::AwsS3BucketServerSideEncryptionRule {
            crate::model::AwsS3BucketServerSideEncryptionRule {
                apply_server_side_encryption_by_default: self
                    .apply_server_side_encryption_by_default,
            }
        }
    }
}
impl AwsS3BucketServerSideEncryptionRule {
    /// Creates a new builder-style object to manufacture [`AwsS3BucketServerSideEncryptionRule`](crate::model::AwsS3BucketServerSideEncryptionRule)
    pub fn builder() -> crate::model::aws_s3_bucket_server_side_encryption_rule::Builder {
        crate::model::aws_s3_bucket_server_side_encryption_rule::Builder::default()
    }
}

/// <p>Specifies the default server-side encryption to apply to new objects in the bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsS3BucketServerSideEncryptionByDefault {
    /// <p>Server-side encryption algorithm to use for the default encryption.</p>
    pub sse_algorithm: std::option::Option<std::string::String>,
    /// <p>KMS key ID to use for the default encryption.</p>
    pub kms_master_key_id: std::option::Option<std::string::String>,
}
impl AwsS3BucketServerSideEncryptionByDefault {
    /// <p>Server-side encryption algorithm to use for the default encryption.</p>
    pub fn sse_algorithm(&self) -> std::option::Option<&str> {
        self.sse_algorithm.as_deref()
    }
    /// <p>KMS key ID to use for the default encryption.</p>
    pub fn kms_master_key_id(&self) -> std::option::Option<&str> {
        self.kms_master_key_id.as_deref()
    }
}
impl std::fmt::Debug for AwsS3BucketServerSideEncryptionByDefault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsS3BucketServerSideEncryptionByDefault");
        formatter.field("sse_algorithm", &self.sse_algorithm);
        formatter.field("kms_master_key_id", &self.kms_master_key_id);
        formatter.finish()
    }
}
/// See [`AwsS3BucketServerSideEncryptionByDefault`](crate::model::AwsS3BucketServerSideEncryptionByDefault)
pub mod aws_s3_bucket_server_side_encryption_by_default {

    /// A builder for [`AwsS3BucketServerSideEncryptionByDefault`](crate::model::AwsS3BucketServerSideEncryptionByDefault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sse_algorithm: std::option::Option<std::string::String>,
        pub(crate) kms_master_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Server-side encryption algorithm to use for the default encryption.</p>
        pub fn sse_algorithm(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_algorithm = Some(input.into());
            self
        }
        /// <p>Server-side encryption algorithm to use for the default encryption.</p>
        pub fn set_sse_algorithm(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_algorithm = input;
            self
        }
        /// <p>KMS key ID to use for the default encryption.</p>
        pub fn kms_master_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_master_key_id = Some(input.into());
            self
        }
        /// <p>KMS key ID to use for the default encryption.</p>
        pub fn set_kms_master_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.kms_master_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsS3BucketServerSideEncryptionByDefault`](crate::model::AwsS3BucketServerSideEncryptionByDefault)
        pub fn build(self) -> crate::model::AwsS3BucketServerSideEncryptionByDefault {
            crate::model::AwsS3BucketServerSideEncryptionByDefault {
                sse_algorithm: self.sse_algorithm,
                kms_master_key_id: self.kms_master_key_id,
            }
        }
    }
}
impl AwsS3BucketServerSideEncryptionByDefault {
    /// Creates a new builder-style object to manufacture [`AwsS3BucketServerSideEncryptionByDefault`](crate::model::AwsS3BucketServerSideEncryptionByDefault)
    pub fn builder() -> crate::model::aws_s3_bucket_server_side_encryption_by_default::Builder {
        crate::model::aws_s3_bucket_server_side_encryption_by_default::Builder::default()
    }
}

/// <p>Information about an Elasticsearch domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElasticsearchDomainDetails {
    /// <p>IAM policy document specifying the access policies for the new Elasticsearch domain.</p>
    pub access_policies: std::option::Option<std::string::String>,
    /// <p>Additional options for the domain endpoint.</p>
    pub domain_endpoint_options:
        std::option::Option<crate::model::AwsElasticsearchDomainDomainEndpointOptions>,
    /// <p>Unique identifier for an Elasticsearch domain.</p>
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>Name of an Elasticsearch domain.</p>
    /// <p>Domain names are unique across all domains owned by the same account within an Amazon Web Services Region.</p>
    /// <p>Domain names must start with a lowercase letter and must be between 3 and 28 characters.</p>
    /// <p>Valid characters are a-z (lowercase only), 0-9, and  (hyphen). </p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>Domain-specific endpoint used to submit index, search, and data upload requests to an Elasticsearch domain.</p>
    /// <p>The endpoint is a service URL. </p>
    pub endpoint: std::option::Option<std::string::String>,
    /// <p>The key-value pair that exists if the Elasticsearch domain uses VPC endpoints.</p>
    pub endpoints:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>OpenSearch version.</p>
    pub elasticsearch_version: std::option::Option<std::string::String>,
    /// <p>Information about an OpenSearch cluster configuration.</p>
    pub elasticsearch_cluster_config:
        std::option::Option<crate::model::AwsElasticsearchDomainElasticsearchClusterConfigDetails>,
    /// <p>Details about the configuration for encryption at rest.</p>
    pub encryption_at_rest_options:
        std::option::Option<crate::model::AwsElasticsearchDomainEncryptionAtRestOptions>,
    /// <p>Configures the CloudWatch Logs to publish for the Elasticsearch domain.</p>
    pub log_publishing_options:
        std::option::Option<crate::model::AwsElasticsearchDomainLogPublishingOptions>,
    /// <p>Details about the configuration for node-to-node encryption.</p>
    pub node_to_node_encryption_options:
        std::option::Option<crate::model::AwsElasticsearchDomainNodeToNodeEncryptionOptions>,
    /// <p>Information about the status of a domain relative to the latest service software.</p>
    pub service_software_options:
        std::option::Option<crate::model::AwsElasticsearchDomainServiceSoftwareOptions>,
    /// <p>Information that OpenSearch derives based on <code>VPCOptions</code> for the domain.</p>
    pub vpc_options: std::option::Option<crate::model::AwsElasticsearchDomainVpcOptions>,
}
impl AwsElasticsearchDomainDetails {
    /// <p>IAM policy document specifying the access policies for the new Elasticsearch domain.</p>
    pub fn access_policies(&self) -> std::option::Option<&str> {
        self.access_policies.as_deref()
    }
    /// <p>Additional options for the domain endpoint.</p>
    pub fn domain_endpoint_options(
        &self,
    ) -> std::option::Option<&crate::model::AwsElasticsearchDomainDomainEndpointOptions> {
        self.domain_endpoint_options.as_ref()
    }
    /// <p>Unique identifier for an Elasticsearch domain.</p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>Name of an Elasticsearch domain.</p>
    /// <p>Domain names are unique across all domains owned by the same account within an Amazon Web Services Region.</p>
    /// <p>Domain names must start with a lowercase letter and must be between 3 and 28 characters.</p>
    /// <p>Valid characters are a-z (lowercase only), 0-9, and  (hyphen). </p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p>Domain-specific endpoint used to submit index, search, and data upload requests to an Elasticsearch domain.</p>
    /// <p>The endpoint is a service URL. </p>
    pub fn endpoint(&self) -> std::option::Option<&str> {
        self.endpoint.as_deref()
    }
    /// <p>The key-value pair that exists if the Elasticsearch domain uses VPC endpoints.</p>
    pub fn endpoints(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.endpoints.as_ref()
    }
    /// <p>OpenSearch version.</p>
    pub fn elasticsearch_version(&self) -> std::option::Option<&str> {
        self.elasticsearch_version.as_deref()
    }
    /// <p>Information about an OpenSearch cluster configuration.</p>
    pub fn elasticsearch_cluster_config(
        &self,
    ) -> std::option::Option<&crate::model::AwsElasticsearchDomainElasticsearchClusterConfigDetails>
    {
        self.elasticsearch_cluster_config.as_ref()
    }
    /// <p>Details about the configuration for encryption at rest.</p>
    pub fn encryption_at_rest_options(
        &self,
    ) -> std::option::Option<&crate::model::AwsElasticsearchDomainEncryptionAtRestOptions> {
        self.encryption_at_rest_options.as_ref()
    }
    /// <p>Configures the CloudWatch Logs to publish for the Elasticsearch domain.</p>
    pub fn log_publishing_options(
        &self,
    ) -> std::option::Option<&crate::model::AwsElasticsearchDomainLogPublishingOptions> {
        self.log_publishing_options.as_ref()
    }
    /// <p>Details about the configuration for node-to-node encryption.</p>
    pub fn node_to_node_encryption_options(
        &self,
    ) -> std::option::Option<&crate::model::AwsElasticsearchDomainNodeToNodeEncryptionOptions> {
        self.node_to_node_encryption_options.as_ref()
    }
    /// <p>Information about the status of a domain relative to the latest service software.</p>
    pub fn service_software_options(
        &self,
    ) -> std::option::Option<&crate::model::AwsElasticsearchDomainServiceSoftwareOptions> {
        self.service_software_options.as_ref()
    }
    /// <p>Information that OpenSearch derives based on <code>VPCOptions</code> for the domain.</p>
    pub fn vpc_options(
        &self,
    ) -> std::option::Option<&crate::model::AwsElasticsearchDomainVpcOptions> {
        self.vpc_options.as_ref()
    }
}
impl std::fmt::Debug for AwsElasticsearchDomainDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElasticsearchDomainDetails");
        formatter.field("access_policies", &self.access_policies);
        formatter.field("domain_endpoint_options", &self.domain_endpoint_options);
        formatter.field("domain_id", &self.domain_id);
        formatter.field("domain_name", &self.domain_name);
        formatter.field("endpoint", &self.endpoint);
        formatter.field("endpoints", &self.endpoints);
        formatter.field("elasticsearch_version", &self.elasticsearch_version);
        formatter.field(
            "elasticsearch_cluster_config",
            &self.elasticsearch_cluster_config,
        );
        formatter.field(
            "encryption_at_rest_options",
            &self.encryption_at_rest_options,
        );
        formatter.field("log_publishing_options", &self.log_publishing_options);
        formatter.field(
            "node_to_node_encryption_options",
            &self.node_to_node_encryption_options,
        );
        formatter.field("service_software_options", &self.service_software_options);
        formatter.field("vpc_options", &self.vpc_options);
        formatter.finish()
    }
}
/// See [`AwsElasticsearchDomainDetails`](crate::model::AwsElasticsearchDomainDetails)
pub mod aws_elasticsearch_domain_details {

    /// A builder for [`AwsElasticsearchDomainDetails`](crate::model::AwsElasticsearchDomainDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) access_policies: std::option::Option<std::string::String>,
        pub(crate) domain_endpoint_options:
            std::option::Option<crate::model::AwsElasticsearchDomainDomainEndpointOptions>,
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) endpoint: std::option::Option<std::string::String>,
        pub(crate) endpoints: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) elasticsearch_version: std::option::Option<std::string::String>,
        pub(crate) elasticsearch_cluster_config: std::option::Option<
            crate::model::AwsElasticsearchDomainElasticsearchClusterConfigDetails,
        >,
        pub(crate) encryption_at_rest_options:
            std::option::Option<crate::model::AwsElasticsearchDomainEncryptionAtRestOptions>,
        pub(crate) log_publishing_options:
            std::option::Option<crate::model::AwsElasticsearchDomainLogPublishingOptions>,
        pub(crate) node_to_node_encryption_options:
            std::option::Option<crate::model::AwsElasticsearchDomainNodeToNodeEncryptionOptions>,
        pub(crate) service_software_options:
            std::option::Option<crate::model::AwsElasticsearchDomainServiceSoftwareOptions>,
        pub(crate) vpc_options: std::option::Option<crate::model::AwsElasticsearchDomainVpcOptions>,
    }
    impl Builder {
        /// <p>IAM policy document specifying the access policies for the new Elasticsearch domain.</p>
        pub fn access_policies(mut self, input: impl Into<std::string::String>) -> Self {
            self.access_policies = Some(input.into());
            self
        }
        /// <p>IAM policy document specifying the access policies for the new Elasticsearch domain.</p>
        pub fn set_access_policies(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.access_policies = input;
            self
        }
        /// <p>Additional options for the domain endpoint.</p>
        pub fn domain_endpoint_options(
            mut self,
            input: crate::model::AwsElasticsearchDomainDomainEndpointOptions,
        ) -> Self {
            self.domain_endpoint_options = Some(input);
            self
        }
        /// <p>Additional options for the domain endpoint.</p>
        pub fn set_domain_endpoint_options(
            mut self,
            input: std::option::Option<crate::model::AwsElasticsearchDomainDomainEndpointOptions>,
        ) -> Self {
            self.domain_endpoint_options = input;
            self
        }
        /// <p>Unique identifier for an Elasticsearch domain.</p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>Unique identifier for an Elasticsearch domain.</p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>Name of an Elasticsearch domain.</p>
        /// <p>Domain names are unique across all domains owned by the same account within an Amazon Web Services Region.</p>
        /// <p>Domain names must start with a lowercase letter and must be between 3 and 28 characters.</p>
        /// <p>Valid characters are a-z (lowercase only), 0-9, and  (hyphen). </p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>Name of an Elasticsearch domain.</p>
        /// <p>Domain names are unique across all domains owned by the same account within an Amazon Web Services Region.</p>
        /// <p>Domain names must start with a lowercase letter and must be between 3 and 28 characters.</p>
        /// <p>Valid characters are a-z (lowercase only), 0-9, and  (hyphen). </p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>Domain-specific endpoint used to submit index, search, and data upload requests to an Elasticsearch domain.</p>
        /// <p>The endpoint is a service URL. </p>
        pub fn endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint = Some(input.into());
            self
        }
        /// <p>Domain-specific endpoint used to submit index, search, and data upload requests to an Elasticsearch domain.</p>
        /// <p>The endpoint is a service URL. </p>
        pub fn set_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint = input;
            self
        }
        /// Adds a key-value pair to `endpoints`.
        ///
        /// To override the contents of this collection use [`set_endpoints`](Self::set_endpoints).
        ///
        /// <p>The key-value pair that exists if the Elasticsearch domain uses VPC endpoints.</p>
        pub fn endpoints(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.endpoints.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.endpoints = Some(hash_map);
            self
        }
        /// <p>The key-value pair that exists if the Elasticsearch domain uses VPC endpoints.</p>
        pub fn set_endpoints(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.endpoints = input;
            self
        }
        /// <p>OpenSearch version.</p>
        pub fn elasticsearch_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.elasticsearch_version = Some(input.into());
            self
        }
        /// <p>OpenSearch version.</p>
        pub fn set_elasticsearch_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.elasticsearch_version = input;
            self
        }
        /// <p>Information about an OpenSearch cluster configuration.</p>
        pub fn elasticsearch_cluster_config(
            mut self,
            input: crate::model::AwsElasticsearchDomainElasticsearchClusterConfigDetails,
        ) -> Self {
            self.elasticsearch_cluster_config = Some(input);
            self
        }
        /// <p>Information about an OpenSearch cluster configuration.</p>
        pub fn set_elasticsearch_cluster_config(
            mut self,
            input: std::option::Option<
                crate::model::AwsElasticsearchDomainElasticsearchClusterConfigDetails,
            >,
        ) -> Self {
            self.elasticsearch_cluster_config = input;
            self
        }
        /// <p>Details about the configuration for encryption at rest.</p>
        pub fn encryption_at_rest_options(
            mut self,
            input: crate::model::AwsElasticsearchDomainEncryptionAtRestOptions,
        ) -> Self {
            self.encryption_at_rest_options = Some(input);
            self
        }
        /// <p>Details about the configuration for encryption at rest.</p>
        pub fn set_encryption_at_rest_options(
            mut self,
            input: std::option::Option<crate::model::AwsElasticsearchDomainEncryptionAtRestOptions>,
        ) -> Self {
            self.encryption_at_rest_options = input;
            self
        }
        /// <p>Configures the CloudWatch Logs to publish for the Elasticsearch domain.</p>
        pub fn log_publishing_options(
            mut self,
            input: crate::model::AwsElasticsearchDomainLogPublishingOptions,
        ) -> Self {
            self.log_publishing_options = Some(input);
            self
        }
        /// <p>Configures the CloudWatch Logs to publish for the Elasticsearch domain.</p>
        pub fn set_log_publishing_options(
            mut self,
            input: std::option::Option<crate::model::AwsElasticsearchDomainLogPublishingOptions>,
        ) -> Self {
            self.log_publishing_options = input;
            self
        }
        /// <p>Details about the configuration for node-to-node encryption.</p>
        pub fn node_to_node_encryption_options(
            mut self,
            input: crate::model::AwsElasticsearchDomainNodeToNodeEncryptionOptions,
        ) -> Self {
            self.node_to_node_encryption_options = Some(input);
            self
        }
        /// <p>Details about the configuration for node-to-node encryption.</p>
        pub fn set_node_to_node_encryption_options(
            mut self,
            input: std::option::Option<
                crate::model::AwsElasticsearchDomainNodeToNodeEncryptionOptions,
            >,
        ) -> Self {
            self.node_to_node_encryption_options = input;
            self
        }
        /// <p>Information about the status of a domain relative to the latest service software.</p>
        pub fn service_software_options(
            mut self,
            input: crate::model::AwsElasticsearchDomainServiceSoftwareOptions,
        ) -> Self {
            self.service_software_options = Some(input);
            self
        }
        /// <p>Information about the status of a domain relative to the latest service software.</p>
        pub fn set_service_software_options(
            mut self,
            input: std::option::Option<crate::model::AwsElasticsearchDomainServiceSoftwareOptions>,
        ) -> Self {
            self.service_software_options = input;
            self
        }
        /// <p>Information that OpenSearch derives based on <code>VPCOptions</code> for the domain.</p>
        pub fn vpc_options(
            mut self,
            input: crate::model::AwsElasticsearchDomainVpcOptions,
        ) -> Self {
            self.vpc_options = Some(input);
            self
        }
        /// <p>Information that OpenSearch derives based on <code>VPCOptions</code> for the domain.</p>
        pub fn set_vpc_options(
            mut self,
            input: std::option::Option<crate::model::AwsElasticsearchDomainVpcOptions>,
        ) -> Self {
            self.vpc_options = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElasticsearchDomainDetails`](crate::model::AwsElasticsearchDomainDetails)
        pub fn build(self) -> crate::model::AwsElasticsearchDomainDetails {
            crate::model::AwsElasticsearchDomainDetails {
                access_policies: self.access_policies,
                domain_endpoint_options: self.domain_endpoint_options,
                domain_id: self.domain_id,
                domain_name: self.domain_name,
                endpoint: self.endpoint,
                endpoints: self.endpoints,
                elasticsearch_version: self.elasticsearch_version,
                elasticsearch_cluster_config: self.elasticsearch_cluster_config,
                encryption_at_rest_options: self.encryption_at_rest_options,
                log_publishing_options: self.log_publishing_options,
                node_to_node_encryption_options: self.node_to_node_encryption_options,
                service_software_options: self.service_software_options,
                vpc_options: self.vpc_options,
            }
        }
    }
}
impl AwsElasticsearchDomainDetails {
    /// Creates a new builder-style object to manufacture [`AwsElasticsearchDomainDetails`](crate::model::AwsElasticsearchDomainDetails)
    pub fn builder() -> crate::model::aws_elasticsearch_domain_details::Builder {
        crate::model::aws_elasticsearch_domain_details::Builder::default()
    }
}

/// <p>Information that OpenSearch derives based on <code>VPCOptions</code> for the domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElasticsearchDomainVpcOptions {
    /// <p>The list of Availability Zones associated with the VPC subnets.</p>
    pub availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The list of security group IDs associated with the VPC endpoints for the domain.</p>
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of subnet IDs associated with the VPC endpoints for the domain.</p>
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>ID for the VPC.</p>
    pub vpc_id: std::option::Option<std::string::String>,
}
impl AwsElasticsearchDomainVpcOptions {
    /// <p>The list of Availability Zones associated with the VPC subnets.</p>
    pub fn availability_zones(&self) -> std::option::Option<&[std::string::String]> {
        self.availability_zones.as_deref()
    }
    /// <p>The list of security group IDs associated with the VPC endpoints for the domain.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
    /// <p>A list of subnet IDs associated with the VPC endpoints for the domain.</p>
    pub fn subnet_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_ids.as_deref()
    }
    /// <p>ID for the VPC.</p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
}
impl std::fmt::Debug for AwsElasticsearchDomainVpcOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElasticsearchDomainVpcOptions");
        formatter.field("availability_zones", &self.availability_zones);
        formatter.field("security_group_ids", &self.security_group_ids);
        formatter.field("subnet_ids", &self.subnet_ids);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.finish()
    }
}
/// See [`AwsElasticsearchDomainVpcOptions`](crate::model::AwsElasticsearchDomainVpcOptions)
pub mod aws_elasticsearch_domain_vpc_options {

    /// A builder for [`AwsElasticsearchDomainVpcOptions`](crate::model::AwsElasticsearchDomainVpcOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `availability_zones`.
        ///
        /// To override the contents of this collection use [`set_availability_zones`](Self::set_availability_zones).
        ///
        /// <p>The list of Availability Zones associated with the VPC subnets.</p>
        pub fn availability_zones(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.availability_zones.unwrap_or_default();
            v.push(input.into());
            self.availability_zones = Some(v);
            self
        }
        /// <p>The list of Availability Zones associated with the VPC subnets.</p>
        pub fn set_availability_zones(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.availability_zones = input;
            self
        }
        /// Appends an item to `security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
        ///
        /// <p>The list of security group IDs associated with the VPC endpoints for the domain.</p>
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        /// <p>The list of security group IDs associated with the VPC endpoints for the domain.</p>
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// Appends an item to `subnet_ids`.
        ///
        /// To override the contents of this collection use [`set_subnet_ids`](Self::set_subnet_ids).
        ///
        /// <p>A list of subnet IDs associated with the VPC endpoints for the domain.</p>
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        /// <p>A list of subnet IDs associated with the VPC endpoints for the domain.</p>
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        /// <p>ID for the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>ID for the VPC.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElasticsearchDomainVpcOptions`](crate::model::AwsElasticsearchDomainVpcOptions)
        pub fn build(self) -> crate::model::AwsElasticsearchDomainVpcOptions {
            crate::model::AwsElasticsearchDomainVpcOptions {
                availability_zones: self.availability_zones,
                security_group_ids: self.security_group_ids,
                subnet_ids: self.subnet_ids,
                vpc_id: self.vpc_id,
            }
        }
    }
}
impl AwsElasticsearchDomainVpcOptions {
    /// Creates a new builder-style object to manufacture [`AwsElasticsearchDomainVpcOptions`](crate::model::AwsElasticsearchDomainVpcOptions)
    pub fn builder() -> crate::model::aws_elasticsearch_domain_vpc_options::Builder {
        crate::model::aws_elasticsearch_domain_vpc_options::Builder::default()
    }
}

/// <p>Information about the state of the domain relative to the latest service software.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElasticsearchDomainServiceSoftwareOptions {
    /// <p>The epoch time when the deployment window closes for required updates. After this time, Amazon OpenSearch Service schedules the software upgrade automatically.</p>
    pub automated_update_date: std::option::Option<std::string::String>,
    /// <p>Whether a request to update the domain can be canceled.</p>
    pub cancellable: bool,
    /// <p>The version of the service software that is currently installed on the domain.</p>
    pub current_version: std::option::Option<std::string::String>,
    /// <p>A more detailed description of the service software status.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The most recent version of the service software.</p>
    pub new_version: std::option::Option<std::string::String>,
    /// <p>Whether a service software update is available for the domain.</p>
    pub update_available: bool,
    /// <p>The status of the service software update.</p>
    pub update_status: std::option::Option<std::string::String>,
}
impl AwsElasticsearchDomainServiceSoftwareOptions {
    /// <p>The epoch time when the deployment window closes for required updates. After this time, Amazon OpenSearch Service schedules the software upgrade automatically.</p>
    pub fn automated_update_date(&self) -> std::option::Option<&str> {
        self.automated_update_date.as_deref()
    }
    /// <p>Whether a request to update the domain can be canceled.</p>
    pub fn cancellable(&self) -> bool {
        self.cancellable
    }
    /// <p>The version of the service software that is currently installed on the domain.</p>
    pub fn current_version(&self) -> std::option::Option<&str> {
        self.current_version.as_deref()
    }
    /// <p>A more detailed description of the service software status.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The most recent version of the service software.</p>
    pub fn new_version(&self) -> std::option::Option<&str> {
        self.new_version.as_deref()
    }
    /// <p>Whether a service software update is available for the domain.</p>
    pub fn update_available(&self) -> bool {
        self.update_available
    }
    /// <p>The status of the service software update.</p>
    pub fn update_status(&self) -> std::option::Option<&str> {
        self.update_status.as_deref()
    }
}
impl std::fmt::Debug for AwsElasticsearchDomainServiceSoftwareOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElasticsearchDomainServiceSoftwareOptions");
        formatter.field("automated_update_date", &self.automated_update_date);
        formatter.field("cancellable", &self.cancellable);
        formatter.field("current_version", &self.current_version);
        formatter.field("description", &self.description);
        formatter.field("new_version", &self.new_version);
        formatter.field("update_available", &self.update_available);
        formatter.field("update_status", &self.update_status);
        formatter.finish()
    }
}
/// See [`AwsElasticsearchDomainServiceSoftwareOptions`](crate::model::AwsElasticsearchDomainServiceSoftwareOptions)
pub mod aws_elasticsearch_domain_service_software_options {

    /// A builder for [`AwsElasticsearchDomainServiceSoftwareOptions`](crate::model::AwsElasticsearchDomainServiceSoftwareOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) automated_update_date: std::option::Option<std::string::String>,
        pub(crate) cancellable: std::option::Option<bool>,
        pub(crate) current_version: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) new_version: std::option::Option<std::string::String>,
        pub(crate) update_available: std::option::Option<bool>,
        pub(crate) update_status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The epoch time when the deployment window closes for required updates. After this time, Amazon OpenSearch Service schedules the software upgrade automatically.</p>
        pub fn automated_update_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.automated_update_date = Some(input.into());
            self
        }
        /// <p>The epoch time when the deployment window closes for required updates. After this time, Amazon OpenSearch Service schedules the software upgrade automatically.</p>
        pub fn set_automated_update_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.automated_update_date = input;
            self
        }
        /// <p>Whether a request to update the domain can be canceled.</p>
        pub fn cancellable(mut self, input: bool) -> Self {
            self.cancellable = Some(input);
            self
        }
        /// <p>Whether a request to update the domain can be canceled.</p>
        pub fn set_cancellable(mut self, input: std::option::Option<bool>) -> Self {
            self.cancellable = input;
            self
        }
        /// <p>The version of the service software that is currently installed on the domain.</p>
        pub fn current_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.current_version = Some(input.into());
            self
        }
        /// <p>The version of the service software that is currently installed on the domain.</p>
        pub fn set_current_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.current_version = input;
            self
        }
        /// <p>A more detailed description of the service software status.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A more detailed description of the service software status.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The most recent version of the service software.</p>
        pub fn new_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.new_version = Some(input.into());
            self
        }
        /// <p>The most recent version of the service software.</p>
        pub fn set_new_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.new_version = input;
            self
        }
        /// <p>Whether a service software update is available for the domain.</p>
        pub fn update_available(mut self, input: bool) -> Self {
            self.update_available = Some(input);
            self
        }
        /// <p>Whether a service software update is available for the domain.</p>
        pub fn set_update_available(mut self, input: std::option::Option<bool>) -> Self {
            self.update_available = input;
            self
        }
        /// <p>The status of the service software update.</p>
        pub fn update_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.update_status = Some(input.into());
            self
        }
        /// <p>The status of the service software update.</p>
        pub fn set_update_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.update_status = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElasticsearchDomainServiceSoftwareOptions`](crate::model::AwsElasticsearchDomainServiceSoftwareOptions)
        pub fn build(self) -> crate::model::AwsElasticsearchDomainServiceSoftwareOptions {
            crate::model::AwsElasticsearchDomainServiceSoftwareOptions {
                automated_update_date: self.automated_update_date,
                cancellable: self.cancellable.unwrap_or_default(),
                current_version: self.current_version,
                description: self.description,
                new_version: self.new_version,
                update_available: self.update_available.unwrap_or_default(),
                update_status: self.update_status,
            }
        }
    }
}
impl AwsElasticsearchDomainServiceSoftwareOptions {
    /// Creates a new builder-style object to manufacture [`AwsElasticsearchDomainServiceSoftwareOptions`](crate::model::AwsElasticsearchDomainServiceSoftwareOptions)
    pub fn builder() -> crate::model::aws_elasticsearch_domain_service_software_options::Builder {
        crate::model::aws_elasticsearch_domain_service_software_options::Builder::default()
    }
}

/// <p>Details about the configuration for node-to-node encryption.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElasticsearchDomainNodeToNodeEncryptionOptions {
    /// <p>Whether node-to-node encryption is enabled.</p>
    pub enabled: bool,
}
impl AwsElasticsearchDomainNodeToNodeEncryptionOptions {
    /// <p>Whether node-to-node encryption is enabled.</p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
}
impl std::fmt::Debug for AwsElasticsearchDomainNodeToNodeEncryptionOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElasticsearchDomainNodeToNodeEncryptionOptions");
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`AwsElasticsearchDomainNodeToNodeEncryptionOptions`](crate::model::AwsElasticsearchDomainNodeToNodeEncryptionOptions)
pub mod aws_elasticsearch_domain_node_to_node_encryption_options {

    /// A builder for [`AwsElasticsearchDomainNodeToNodeEncryptionOptions`](crate::model::AwsElasticsearchDomainNodeToNodeEncryptionOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Whether node-to-node encryption is enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Whether node-to-node encryption is enabled.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElasticsearchDomainNodeToNodeEncryptionOptions`](crate::model::AwsElasticsearchDomainNodeToNodeEncryptionOptions)
        pub fn build(self) -> crate::model::AwsElasticsearchDomainNodeToNodeEncryptionOptions {
            crate::model::AwsElasticsearchDomainNodeToNodeEncryptionOptions {
                enabled: self.enabled.unwrap_or_default(),
            }
        }
    }
}
impl AwsElasticsearchDomainNodeToNodeEncryptionOptions {
    /// Creates a new builder-style object to manufacture [`AwsElasticsearchDomainNodeToNodeEncryptionOptions`](crate::model::AwsElasticsearchDomainNodeToNodeEncryptionOptions)
    pub fn builder(
    ) -> crate::model::aws_elasticsearch_domain_node_to_node_encryption_options::Builder {
        crate::model::aws_elasticsearch_domain_node_to_node_encryption_options::Builder::default()
    }
}

/// <p>configures the CloudWatch Logs to publish for the Elasticsearch domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElasticsearchDomainLogPublishingOptions {
    /// <p>Configures the OpenSearch index logs publishing.</p>
    pub index_slow_logs:
        std::option::Option<crate::model::AwsElasticsearchDomainLogPublishingOptionsLogConfig>,
    /// <p>Configures the OpenSearch search slow log publishing.</p>
    pub search_slow_logs:
        std::option::Option<crate::model::AwsElasticsearchDomainLogPublishingOptionsLogConfig>,
    /// <p>The log configuration.</p>
    pub audit_logs:
        std::option::Option<crate::model::AwsElasticsearchDomainLogPublishingOptionsLogConfig>,
}
impl AwsElasticsearchDomainLogPublishingOptions {
    /// <p>Configures the OpenSearch index logs publishing.</p>
    pub fn index_slow_logs(
        &self,
    ) -> std::option::Option<&crate::model::AwsElasticsearchDomainLogPublishingOptionsLogConfig>
    {
        self.index_slow_logs.as_ref()
    }
    /// <p>Configures the OpenSearch search slow log publishing.</p>
    pub fn search_slow_logs(
        &self,
    ) -> std::option::Option<&crate::model::AwsElasticsearchDomainLogPublishingOptionsLogConfig>
    {
        self.search_slow_logs.as_ref()
    }
    /// <p>The log configuration.</p>
    pub fn audit_logs(
        &self,
    ) -> std::option::Option<&crate::model::AwsElasticsearchDomainLogPublishingOptionsLogConfig>
    {
        self.audit_logs.as_ref()
    }
}
impl std::fmt::Debug for AwsElasticsearchDomainLogPublishingOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElasticsearchDomainLogPublishingOptions");
        formatter.field("index_slow_logs", &self.index_slow_logs);
        formatter.field("search_slow_logs", &self.search_slow_logs);
        formatter.field("audit_logs", &self.audit_logs);
        formatter.finish()
    }
}
/// See [`AwsElasticsearchDomainLogPublishingOptions`](crate::model::AwsElasticsearchDomainLogPublishingOptions)
pub mod aws_elasticsearch_domain_log_publishing_options {

    /// A builder for [`AwsElasticsearchDomainLogPublishingOptions`](crate::model::AwsElasticsearchDomainLogPublishingOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_slow_logs:
            std::option::Option<crate::model::AwsElasticsearchDomainLogPublishingOptionsLogConfig>,
        pub(crate) search_slow_logs:
            std::option::Option<crate::model::AwsElasticsearchDomainLogPublishingOptionsLogConfig>,
        pub(crate) audit_logs:
            std::option::Option<crate::model::AwsElasticsearchDomainLogPublishingOptionsLogConfig>,
    }
    impl Builder {
        /// <p>Configures the OpenSearch index logs publishing.</p>
        pub fn index_slow_logs(
            mut self,
            input: crate::model::AwsElasticsearchDomainLogPublishingOptionsLogConfig,
        ) -> Self {
            self.index_slow_logs = Some(input);
            self
        }
        /// <p>Configures the OpenSearch index logs publishing.</p>
        pub fn set_index_slow_logs(
            mut self,
            input: std::option::Option<
                crate::model::AwsElasticsearchDomainLogPublishingOptionsLogConfig,
            >,
        ) -> Self {
            self.index_slow_logs = input;
            self
        }
        /// <p>Configures the OpenSearch search slow log publishing.</p>
        pub fn search_slow_logs(
            mut self,
            input: crate::model::AwsElasticsearchDomainLogPublishingOptionsLogConfig,
        ) -> Self {
            self.search_slow_logs = Some(input);
            self
        }
        /// <p>Configures the OpenSearch search slow log publishing.</p>
        pub fn set_search_slow_logs(
            mut self,
            input: std::option::Option<
                crate::model::AwsElasticsearchDomainLogPublishingOptionsLogConfig,
            >,
        ) -> Self {
            self.search_slow_logs = input;
            self
        }
        /// <p>The log configuration.</p>
        pub fn audit_logs(
            mut self,
            input: crate::model::AwsElasticsearchDomainLogPublishingOptionsLogConfig,
        ) -> Self {
            self.audit_logs = Some(input);
            self
        }
        /// <p>The log configuration.</p>
        pub fn set_audit_logs(
            mut self,
            input: std::option::Option<
                crate::model::AwsElasticsearchDomainLogPublishingOptionsLogConfig,
            >,
        ) -> Self {
            self.audit_logs = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElasticsearchDomainLogPublishingOptions`](crate::model::AwsElasticsearchDomainLogPublishingOptions)
        pub fn build(self) -> crate::model::AwsElasticsearchDomainLogPublishingOptions {
            crate::model::AwsElasticsearchDomainLogPublishingOptions {
                index_slow_logs: self.index_slow_logs,
                search_slow_logs: self.search_slow_logs,
                audit_logs: self.audit_logs,
            }
        }
    }
}
impl AwsElasticsearchDomainLogPublishingOptions {
    /// Creates a new builder-style object to manufacture [`AwsElasticsearchDomainLogPublishingOptions`](crate::model::AwsElasticsearchDomainLogPublishingOptions)
    pub fn builder() -> crate::model::aws_elasticsearch_domain_log_publishing_options::Builder {
        crate::model::aws_elasticsearch_domain_log_publishing_options::Builder::default()
    }
}

/// <p>The log configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElasticsearchDomainLogPublishingOptionsLogConfig {
    /// <p>The ARN of the CloudWatch Logs group to publish the logs to.</p>
    pub cloud_watch_logs_log_group_arn: std::option::Option<std::string::String>,
    /// <p>Whether the log publishing is enabled.</p>
    pub enabled: bool,
}
impl AwsElasticsearchDomainLogPublishingOptionsLogConfig {
    /// <p>The ARN of the CloudWatch Logs group to publish the logs to.</p>
    pub fn cloud_watch_logs_log_group_arn(&self) -> std::option::Option<&str> {
        self.cloud_watch_logs_log_group_arn.as_deref()
    }
    /// <p>Whether the log publishing is enabled.</p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
}
impl std::fmt::Debug for AwsElasticsearchDomainLogPublishingOptionsLogConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElasticsearchDomainLogPublishingOptionsLogConfig");
        formatter.field(
            "cloud_watch_logs_log_group_arn",
            &self.cloud_watch_logs_log_group_arn,
        );
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`AwsElasticsearchDomainLogPublishingOptionsLogConfig`](crate::model::AwsElasticsearchDomainLogPublishingOptionsLogConfig)
pub mod aws_elasticsearch_domain_log_publishing_options_log_config {

    /// A builder for [`AwsElasticsearchDomainLogPublishingOptionsLogConfig`](crate::model::AwsElasticsearchDomainLogPublishingOptionsLogConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cloud_watch_logs_log_group_arn: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The ARN of the CloudWatch Logs group to publish the logs to.</p>
        pub fn cloud_watch_logs_log_group_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.cloud_watch_logs_log_group_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the CloudWatch Logs group to publish the logs to.</p>
        pub fn set_cloud_watch_logs_log_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cloud_watch_logs_log_group_arn = input;
            self
        }
        /// <p>Whether the log publishing is enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Whether the log publishing is enabled.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElasticsearchDomainLogPublishingOptionsLogConfig`](crate::model::AwsElasticsearchDomainLogPublishingOptionsLogConfig)
        pub fn build(self) -> crate::model::AwsElasticsearchDomainLogPublishingOptionsLogConfig {
            crate::model::AwsElasticsearchDomainLogPublishingOptionsLogConfig {
                cloud_watch_logs_log_group_arn: self.cloud_watch_logs_log_group_arn,
                enabled: self.enabled.unwrap_or_default(),
            }
        }
    }
}
impl AwsElasticsearchDomainLogPublishingOptionsLogConfig {
    /// Creates a new builder-style object to manufacture [`AwsElasticsearchDomainLogPublishingOptionsLogConfig`](crate::model::AwsElasticsearchDomainLogPublishingOptionsLogConfig)
    pub fn builder(
    ) -> crate::model::aws_elasticsearch_domain_log_publishing_options_log_config::Builder {
        crate::model::aws_elasticsearch_domain_log_publishing_options_log_config::Builder::default()
    }
}

/// <p>Details about the configuration for encryption at rest.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElasticsearchDomainEncryptionAtRestOptions {
    /// <p>Whether encryption at rest is enabled.</p>
    pub enabled: bool,
    /// <p>The KMS key ID. Takes the form <code>1a2a3a4-1a2a-3a4a-5a6a-1a2a3a4a5a6a</code>.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl AwsElasticsearchDomainEncryptionAtRestOptions {
    /// <p>Whether encryption at rest is enabled.</p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
    /// <p>The KMS key ID. Takes the form <code>1a2a3a4-1a2a-3a4a-5a6a-1a2a3a4a5a6a</code>.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
}
impl std::fmt::Debug for AwsElasticsearchDomainEncryptionAtRestOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElasticsearchDomainEncryptionAtRestOptions");
        formatter.field("enabled", &self.enabled);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.finish()
    }
}
/// See [`AwsElasticsearchDomainEncryptionAtRestOptions`](crate::model::AwsElasticsearchDomainEncryptionAtRestOptions)
pub mod aws_elasticsearch_domain_encryption_at_rest_options {

    /// A builder for [`AwsElasticsearchDomainEncryptionAtRestOptions`](crate::model::AwsElasticsearchDomainEncryptionAtRestOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Whether encryption at rest is enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Whether encryption at rest is enabled.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The KMS key ID. Takes the form <code>1a2a3a4-1a2a-3a4a-5a6a-1a2a3a4a5a6a</code>.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The KMS key ID. Takes the form <code>1a2a3a4-1a2a-3a4a-5a6a-1a2a3a4a5a6a</code>.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElasticsearchDomainEncryptionAtRestOptions`](crate::model::AwsElasticsearchDomainEncryptionAtRestOptions)
        pub fn build(self) -> crate::model::AwsElasticsearchDomainEncryptionAtRestOptions {
            crate::model::AwsElasticsearchDomainEncryptionAtRestOptions {
                enabled: self.enabled.unwrap_or_default(),
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl AwsElasticsearchDomainEncryptionAtRestOptions {
    /// Creates a new builder-style object to manufacture [`AwsElasticsearchDomainEncryptionAtRestOptions`](crate::model::AwsElasticsearchDomainEncryptionAtRestOptions)
    pub fn builder() -> crate::model::aws_elasticsearch_domain_encryption_at_rest_options::Builder {
        crate::model::aws_elasticsearch_domain_encryption_at_rest_options::Builder::default()
    }
}

/// <p>details about the configuration of an OpenSearch cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElasticsearchDomainElasticsearchClusterConfigDetails {
    /// <p>The number of instances to use for the master node. If this attribute is specified, then <code>DedicatedMasterEnabled</code> must be <code>true</code>.</p>
    pub dedicated_master_count: i32,
    /// <p>Whether to use a dedicated master node for the Elasticsearch domain. A dedicated master node performs cluster management tasks, but doesn't hold data or respond to data upload requests.</p>
    pub dedicated_master_enabled: bool,
    /// <p>The hardware configuration of the computer that hosts the dedicated master node. For example, <code>m3.medium.elasticsearch</code>. If this attribute is specified, then <code>DedicatedMasterEnabled</code> must be <code>true</code>.</p>
    pub dedicated_master_type: std::option::Option<std::string::String>,
    /// <p>The number of data nodes to use in the Elasticsearch domain.</p>
    pub instance_count: i32,
    /// <p>The instance type for your data nodes. For example, <code>m3.medium.elasticsearch</code>.</p>
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>Configuration options for zone awareness. Provided if <code>ZoneAwarenessEnabled</code> is <code>true</code>.</p>
    pub zone_awareness_config: std::option::Option<
        crate::model::AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails,
    >,
    /// <p>Whether to enable zone awareness for the Elasticsearch domain. When zone awareness is enabled, OpenSearch allocates the cluster's nodes and replica index shards across Availability Zones in the same Region. This prevents data loss and minimizes downtime if a node or data center fails.</p>
    pub zone_awareness_enabled: bool,
}
impl AwsElasticsearchDomainElasticsearchClusterConfigDetails {
    /// <p>The number of instances to use for the master node. If this attribute is specified, then <code>DedicatedMasterEnabled</code> must be <code>true</code>.</p>
    pub fn dedicated_master_count(&self) -> i32 {
        self.dedicated_master_count
    }
    /// <p>Whether to use a dedicated master node for the Elasticsearch domain. A dedicated master node performs cluster management tasks, but doesn't hold data or respond to data upload requests.</p>
    pub fn dedicated_master_enabled(&self) -> bool {
        self.dedicated_master_enabled
    }
    /// <p>The hardware configuration of the computer that hosts the dedicated master node. For example, <code>m3.medium.elasticsearch</code>. If this attribute is specified, then <code>DedicatedMasterEnabled</code> must be <code>true</code>.</p>
    pub fn dedicated_master_type(&self) -> std::option::Option<&str> {
        self.dedicated_master_type.as_deref()
    }
    /// <p>The number of data nodes to use in the Elasticsearch domain.</p>
    pub fn instance_count(&self) -> i32 {
        self.instance_count
    }
    /// <p>The instance type for your data nodes. For example, <code>m3.medium.elasticsearch</code>.</p>
    pub fn instance_type(&self) -> std::option::Option<&str> {
        self.instance_type.as_deref()
    }
    /// <p>Configuration options for zone awareness. Provided if <code>ZoneAwarenessEnabled</code> is <code>true</code>.</p>
    pub fn zone_awareness_config(
        &self,
    ) -> std::option::Option<
        &crate::model::AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails,
    > {
        self.zone_awareness_config.as_ref()
    }
    /// <p>Whether to enable zone awareness for the Elasticsearch domain. When zone awareness is enabled, OpenSearch allocates the cluster's nodes and replica index shards across Availability Zones in the same Region. This prevents data loss and minimizes downtime if a node or data center fails.</p>
    pub fn zone_awareness_enabled(&self) -> bool {
        self.zone_awareness_enabled
    }
}
impl std::fmt::Debug for AwsElasticsearchDomainElasticsearchClusterConfigDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsElasticsearchDomainElasticsearchClusterConfigDetails");
        formatter.field("dedicated_master_count", &self.dedicated_master_count);
        formatter.field("dedicated_master_enabled", &self.dedicated_master_enabled);
        formatter.field("dedicated_master_type", &self.dedicated_master_type);
        formatter.field("instance_count", &self.instance_count);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("zone_awareness_config", &self.zone_awareness_config);
        formatter.field("zone_awareness_enabled", &self.zone_awareness_enabled);
        formatter.finish()
    }
}
/// See [`AwsElasticsearchDomainElasticsearchClusterConfigDetails`](crate::model::AwsElasticsearchDomainElasticsearchClusterConfigDetails)
pub mod aws_elasticsearch_domain_elasticsearch_cluster_config_details {

    /// A builder for [`AwsElasticsearchDomainElasticsearchClusterConfigDetails`](crate::model::AwsElasticsearchDomainElasticsearchClusterConfigDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dedicated_master_count: std::option::Option<i32>,
        pub(crate) dedicated_master_enabled: std::option::Option<bool>,
        pub(crate) dedicated_master_type: std::option::Option<std::string::String>,
        pub(crate) instance_count: std::option::Option<i32>,
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) zone_awareness_config: std::option::Option<crate::model::AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails>,
        pub(crate) zone_awareness_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The number of instances to use for the master node. If this attribute is specified, then <code>DedicatedMasterEnabled</code> must be <code>true</code>.</p>
        pub fn dedicated_master_count(mut self, input: i32) -> Self {
            self.dedicated_master_count = Some(input);
            self
        }
        /// <p>The number of instances to use for the master node. If this attribute is specified, then <code>DedicatedMasterEnabled</code> must be <code>true</code>.</p>
        pub fn set_dedicated_master_count(mut self, input: std::option::Option<i32>) -> Self {
            self.dedicated_master_count = input;
            self
        }
        /// <p>Whether to use a dedicated master node for the Elasticsearch domain. A dedicated master node performs cluster management tasks, but doesn't hold data or respond to data upload requests.</p>
        pub fn dedicated_master_enabled(mut self, input: bool) -> Self {
            self.dedicated_master_enabled = Some(input);
            self
        }
        /// <p>Whether to use a dedicated master node for the Elasticsearch domain. A dedicated master node performs cluster management tasks, but doesn't hold data or respond to data upload requests.</p>
        pub fn set_dedicated_master_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.dedicated_master_enabled = input;
            self
        }
        /// <p>The hardware configuration of the computer that hosts the dedicated master node. For example, <code>m3.medium.elasticsearch</code>. If this attribute is specified, then <code>DedicatedMasterEnabled</code> must be <code>true</code>.</p>
        pub fn dedicated_master_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.dedicated_master_type = Some(input.into());
            self
        }
        /// <p>The hardware configuration of the computer that hosts the dedicated master node. For example, <code>m3.medium.elasticsearch</code>. If this attribute is specified, then <code>DedicatedMasterEnabled</code> must be <code>true</code>.</p>
        pub fn set_dedicated_master_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dedicated_master_type = input;
            self
        }
        /// <p>The number of data nodes to use in the Elasticsearch domain.</p>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.instance_count = Some(input);
            self
        }
        /// <p>The number of data nodes to use in the Elasticsearch domain.</p>
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_count = input;
            self
        }
        /// <p>The instance type for your data nodes. For example, <code>m3.medium.elasticsearch</code>.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        /// <p>The instance type for your data nodes. For example, <code>m3.medium.elasticsearch</code>.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>Configuration options for zone awareness. Provided if <code>ZoneAwarenessEnabled</code> is <code>true</code>.</p>
        pub fn zone_awareness_config(
            mut self,
            input: crate::model::AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails,
        ) -> Self {
            self.zone_awareness_config = Some(input);
            self
        }
        /// <p>Configuration options for zone awareness. Provided if <code>ZoneAwarenessEnabled</code> is <code>true</code>.</p>
        pub fn set_zone_awareness_config(
            mut self,
            input: std::option::Option<crate::model::AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails>,
        ) -> Self {
            self.zone_awareness_config = input;
            self
        }
        /// <p>Whether to enable zone awareness for the Elasticsearch domain. When zone awareness is enabled, OpenSearch allocates the cluster's nodes and replica index shards across Availability Zones in the same Region. This prevents data loss and minimizes downtime if a node or data center fails.</p>
        pub fn zone_awareness_enabled(mut self, input: bool) -> Self {
            self.zone_awareness_enabled = Some(input);
            self
        }
        /// <p>Whether to enable zone awareness for the Elasticsearch domain. When zone awareness is enabled, OpenSearch allocates the cluster's nodes and replica index shards across Availability Zones in the same Region. This prevents data loss and minimizes downtime if a node or data center fails.</p>
        pub fn set_zone_awareness_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.zone_awareness_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElasticsearchDomainElasticsearchClusterConfigDetails`](crate::model::AwsElasticsearchDomainElasticsearchClusterConfigDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsElasticsearchDomainElasticsearchClusterConfigDetails {
            crate::model::AwsElasticsearchDomainElasticsearchClusterConfigDetails {
                dedicated_master_count: self.dedicated_master_count.unwrap_or_default(),
                dedicated_master_enabled: self.dedicated_master_enabled.unwrap_or_default(),
                dedicated_master_type: self.dedicated_master_type,
                instance_count: self.instance_count.unwrap_or_default(),
                instance_type: self.instance_type,
                zone_awareness_config: self.zone_awareness_config,
                zone_awareness_enabled: self.zone_awareness_enabled.unwrap_or_default(),
            }
        }
    }
}
impl AwsElasticsearchDomainElasticsearchClusterConfigDetails {
    /// Creates a new builder-style object to manufacture [`AwsElasticsearchDomainElasticsearchClusterConfigDetails`](crate::model::AwsElasticsearchDomainElasticsearchClusterConfigDetails)
    pub fn builder(
    ) -> crate::model::aws_elasticsearch_domain_elasticsearch_cluster_config_details::Builder {
        crate::model::aws_elasticsearch_domain_elasticsearch_cluster_config_details::Builder::default()
    }
}

/// <p>Configuration options for zone awareness.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails {
    /// <p>he number of Availability Zones that the domain uses. Valid values are 2 and 3. The default is 2.</p>
    pub availability_zone_count: i32,
}
impl AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails {
    /// <p>he number of Availability Zones that the domain uses. Valid values are 2 and 3. The default is 2.</p>
    pub fn availability_zone_count(&self) -> i32 {
        self.availability_zone_count
    }
}
impl std::fmt::Debug
    for AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct(
            "AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails",
        );
        formatter.field("availability_zone_count", &self.availability_zone_count);
        formatter.finish()
    }
}
/// See [`AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails`](crate::model::AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails)
pub mod aws_elasticsearch_domain_elasticsearch_cluster_config_zone_awareness_config_details {

    /// A builder for [`AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails`](crate::model::AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_zone_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>he number of Availability Zones that the domain uses. Valid values are 2 and 3. The default is 2.</p>
        pub fn availability_zone_count(mut self, input: i32) -> Self {
            self.availability_zone_count = Some(input);
            self
        }
        /// <p>he number of Availability Zones that the domain uses. Valid values are 2 and 3. The default is 2.</p>
        pub fn set_availability_zone_count(mut self, input: std::option::Option<i32>) -> Self {
            self.availability_zone_count = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails`](crate::model::AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails
        {
            crate::model::AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails {
                availability_zone_count: self.availability_zone_count
                    .unwrap_or_default()
                ,
            }
        }
    }
}
impl AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails {
    /// Creates a new builder-style object to manufacture [`AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails`](crate::model::AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails)
    pub fn builder() -> crate::model::aws_elasticsearch_domain_elasticsearch_cluster_config_zone_awareness_config_details::Builder{
        crate::model::aws_elasticsearch_domain_elasticsearch_cluster_config_zone_awareness_config_details::Builder::default()
    }
}

/// <p>Additional options for the domain endpoint, such as whether to require HTTPS for all traffic.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElasticsearchDomainDomainEndpointOptions {
    /// <p>Whether to require that all traffic to the domain arrive over HTTPS.</p>
    pub enforce_https: bool,
    /// <p>The TLS security policy to apply to the HTTPS endpoint of the OpenSearch domain.</p>
    /// <p>Valid values:</p>
    /// <ul>
    /// <li> <p> <code>Policy-Min-TLS-1-0-2019-07</code>, which supports TLSv1.0 and higher</p> </li>
    /// <li> <p> <code>Policy-Min-TLS-1-2-2019-07</code>, which only supports TLSv1.2</p> </li>
    /// </ul>
    pub tls_security_policy: std::option::Option<std::string::String>,
}
impl AwsElasticsearchDomainDomainEndpointOptions {
    /// <p>Whether to require that all traffic to the domain arrive over HTTPS.</p>
    pub fn enforce_https(&self) -> bool {
        self.enforce_https
    }
    /// <p>The TLS security policy to apply to the HTTPS endpoint of the OpenSearch domain.</p>
    /// <p>Valid values:</p>
    /// <ul>
    /// <li> <p> <code>Policy-Min-TLS-1-0-2019-07</code>, which supports TLSv1.0 and higher</p> </li>
    /// <li> <p> <code>Policy-Min-TLS-1-2-2019-07</code>, which only supports TLSv1.2</p> </li>
    /// </ul>
    pub fn tls_security_policy(&self) -> std::option::Option<&str> {
        self.tls_security_policy.as_deref()
    }
}
impl std::fmt::Debug for AwsElasticsearchDomainDomainEndpointOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElasticsearchDomainDomainEndpointOptions");
        formatter.field("enforce_https", &self.enforce_https);
        formatter.field("tls_security_policy", &self.tls_security_policy);
        formatter.finish()
    }
}
/// See [`AwsElasticsearchDomainDomainEndpointOptions`](crate::model::AwsElasticsearchDomainDomainEndpointOptions)
pub mod aws_elasticsearch_domain_domain_endpoint_options {

    /// A builder for [`AwsElasticsearchDomainDomainEndpointOptions`](crate::model::AwsElasticsearchDomainDomainEndpointOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enforce_https: std::option::Option<bool>,
        pub(crate) tls_security_policy: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Whether to require that all traffic to the domain arrive over HTTPS.</p>
        pub fn enforce_https(mut self, input: bool) -> Self {
            self.enforce_https = Some(input);
            self
        }
        /// <p>Whether to require that all traffic to the domain arrive over HTTPS.</p>
        pub fn set_enforce_https(mut self, input: std::option::Option<bool>) -> Self {
            self.enforce_https = input;
            self
        }
        /// <p>The TLS security policy to apply to the HTTPS endpoint of the OpenSearch domain.</p>
        /// <p>Valid values:</p>
        /// <ul>
        /// <li> <p> <code>Policy-Min-TLS-1-0-2019-07</code>, which supports TLSv1.0 and higher</p> </li>
        /// <li> <p> <code>Policy-Min-TLS-1-2-2019-07</code>, which only supports TLSv1.2</p> </li>
        /// </ul>
        pub fn tls_security_policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.tls_security_policy = Some(input.into());
            self
        }
        /// <p>The TLS security policy to apply to the HTTPS endpoint of the OpenSearch domain.</p>
        /// <p>Valid values:</p>
        /// <ul>
        /// <li> <p> <code>Policy-Min-TLS-1-0-2019-07</code>, which supports TLSv1.0 and higher</p> </li>
        /// <li> <p> <code>Policy-Min-TLS-1-2-2019-07</code>, which only supports TLSv1.2</p> </li>
        /// </ul>
        pub fn set_tls_security_policy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tls_security_policy = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElasticsearchDomainDomainEndpointOptions`](crate::model::AwsElasticsearchDomainDomainEndpointOptions)
        pub fn build(self) -> crate::model::AwsElasticsearchDomainDomainEndpointOptions {
            crate::model::AwsElasticsearchDomainDomainEndpointOptions {
                enforce_https: self.enforce_https.unwrap_or_default(),
                tls_security_policy: self.tls_security_policy,
            }
        }
    }
}
impl AwsElasticsearchDomainDomainEndpointOptions {
    /// Creates a new builder-style object to manufacture [`AwsElasticsearchDomainDomainEndpointOptions`](crate::model::AwsElasticsearchDomainDomainEndpointOptions)
    pub fn builder() -> crate::model::aws_elasticsearch_domain_domain_endpoint_options::Builder {
        crate::model::aws_elasticsearch_domain_domain_endpoint_options::Builder::default()
    }
}

/// <p>Contains details about an Elastic Beanstalk environment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElasticBeanstalkEnvironmentDetails {
    /// <p>The name of the application that is associated with the environment.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>The URL to the CNAME for this environment.</p>
    pub cname: std::option::Option<std::string::String>,
    /// <p>The creation date for this environment.</p>
    pub date_created: std::option::Option<std::string::String>,
    /// <p>The date when this environment was last modified.</p>
    pub date_updated: std::option::Option<std::string::String>,
    /// <p>A description of the environment.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>For load-balanced, autoscaling environments, the URL to the load balancer. For single-instance environments, the IP address of the instance.</p>
    pub endpoint_url: std::option::Option<std::string::String>,
    /// <p>The ARN of the environment.</p>
    pub environment_arn: std::option::Option<std::string::String>,
    /// <p>The identifier of the environment.</p>
    pub environment_id: std::option::Option<std::string::String>,
    /// <p>Links to other environments in the same group.</p>
    pub environment_links: std::option::Option<
        std::vec::Vec<crate::model::AwsElasticBeanstalkEnvironmentEnvironmentLink>,
    >,
    /// <p>The name of the environment.</p>
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The configuration setting for the environment.</p>
    pub option_settings: std::option::Option<
        std::vec::Vec<crate::model::AwsElasticBeanstalkEnvironmentOptionSetting>,
    >,
    /// <p>The ARN of the platform version for the environment.</p>
    pub platform_arn: std::option::Option<std::string::String>,
    /// <p>The name of the solution stack that is deployed with the environment.</p>
    pub solution_stack_name: std::option::Option<std::string::String>,
    /// <p>The current operational status of the environment.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>The tier of the environment.</p>
    pub tier: std::option::Option<crate::model::AwsElasticBeanstalkEnvironmentTier>,
    /// <p>The application version of the environment.</p>
    pub version_label: std::option::Option<std::string::String>,
}
impl AwsElasticBeanstalkEnvironmentDetails {
    /// <p>The name of the application that is associated with the environment.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>The URL to the CNAME for this environment.</p>
    pub fn cname(&self) -> std::option::Option<&str> {
        self.cname.as_deref()
    }
    /// <p>The creation date for this environment.</p>
    pub fn date_created(&self) -> std::option::Option<&str> {
        self.date_created.as_deref()
    }
    /// <p>The date when this environment was last modified.</p>
    pub fn date_updated(&self) -> std::option::Option<&str> {
        self.date_updated.as_deref()
    }
    /// <p>A description of the environment.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>For load-balanced, autoscaling environments, the URL to the load balancer. For single-instance environments, the IP address of the instance.</p>
    pub fn endpoint_url(&self) -> std::option::Option<&str> {
        self.endpoint_url.as_deref()
    }
    /// <p>The ARN of the environment.</p>
    pub fn environment_arn(&self) -> std::option::Option<&str> {
        self.environment_arn.as_deref()
    }
    /// <p>The identifier of the environment.</p>
    pub fn environment_id(&self) -> std::option::Option<&str> {
        self.environment_id.as_deref()
    }
    /// <p>Links to other environments in the same group.</p>
    pub fn environment_links(
        &self,
    ) -> std::option::Option<&[crate::model::AwsElasticBeanstalkEnvironmentEnvironmentLink]> {
        self.environment_links.as_deref()
    }
    /// <p>The name of the environment.</p>
    pub fn environment_name(&self) -> std::option::Option<&str> {
        self.environment_name.as_deref()
    }
    /// <p>The configuration setting for the environment.</p>
    pub fn option_settings(
        &self,
    ) -> std::option::Option<&[crate::model::AwsElasticBeanstalkEnvironmentOptionSetting]> {
        self.option_settings.as_deref()
    }
    /// <p>The ARN of the platform version for the environment.</p>
    pub fn platform_arn(&self) -> std::option::Option<&str> {
        self.platform_arn.as_deref()
    }
    /// <p>The name of the solution stack that is deployed with the environment.</p>
    pub fn solution_stack_name(&self) -> std::option::Option<&str> {
        self.solution_stack_name.as_deref()
    }
    /// <p>The current operational status of the environment.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>The tier of the environment.</p>
    pub fn tier(&self) -> std::option::Option<&crate::model::AwsElasticBeanstalkEnvironmentTier> {
        self.tier.as_ref()
    }
    /// <p>The application version of the environment.</p>
    pub fn version_label(&self) -> std::option::Option<&str> {
        self.version_label.as_deref()
    }
}
impl std::fmt::Debug for AwsElasticBeanstalkEnvironmentDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElasticBeanstalkEnvironmentDetails");
        formatter.field("application_name", &self.application_name);
        formatter.field("cname", &self.cname);
        formatter.field("date_created", &self.date_created);
        formatter.field("date_updated", &self.date_updated);
        formatter.field("description", &self.description);
        formatter.field("endpoint_url", &self.endpoint_url);
        formatter.field("environment_arn", &self.environment_arn);
        formatter.field("environment_id", &self.environment_id);
        formatter.field("environment_links", &self.environment_links);
        formatter.field("environment_name", &self.environment_name);
        formatter.field("option_settings", &self.option_settings);
        formatter.field("platform_arn", &self.platform_arn);
        formatter.field("solution_stack_name", &self.solution_stack_name);
        formatter.field("status", &self.status);
        formatter.field("tier", &self.tier);
        formatter.field("version_label", &self.version_label);
        formatter.finish()
    }
}
/// See [`AwsElasticBeanstalkEnvironmentDetails`](crate::model::AwsElasticBeanstalkEnvironmentDetails)
pub mod aws_elastic_beanstalk_environment_details {

    /// A builder for [`AwsElasticBeanstalkEnvironmentDetails`](crate::model::AwsElasticBeanstalkEnvironmentDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) cname: std::option::Option<std::string::String>,
        pub(crate) date_created: std::option::Option<std::string::String>,
        pub(crate) date_updated: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) endpoint_url: std::option::Option<std::string::String>,
        pub(crate) environment_arn: std::option::Option<std::string::String>,
        pub(crate) environment_id: std::option::Option<std::string::String>,
        pub(crate) environment_links: std::option::Option<
            std::vec::Vec<crate::model::AwsElasticBeanstalkEnvironmentEnvironmentLink>,
        >,
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) option_settings: std::option::Option<
            std::vec::Vec<crate::model::AwsElasticBeanstalkEnvironmentOptionSetting>,
        >,
        pub(crate) platform_arn: std::option::Option<std::string::String>,
        pub(crate) solution_stack_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) tier: std::option::Option<crate::model::AwsElasticBeanstalkEnvironmentTier>,
        pub(crate) version_label: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the application that is associated with the environment.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The name of the application that is associated with the environment.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>The URL to the CNAME for this environment.</p>
        pub fn cname(mut self, input: impl Into<std::string::String>) -> Self {
            self.cname = Some(input.into());
            self
        }
        /// <p>The URL to the CNAME for this environment.</p>
        pub fn set_cname(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cname = input;
            self
        }
        /// <p>The creation date for this environment.</p>
        pub fn date_created(mut self, input: impl Into<std::string::String>) -> Self {
            self.date_created = Some(input.into());
            self
        }
        /// <p>The creation date for this environment.</p>
        pub fn set_date_created(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.date_created = input;
            self
        }
        /// <p>The date when this environment was last modified.</p>
        pub fn date_updated(mut self, input: impl Into<std::string::String>) -> Self {
            self.date_updated = Some(input.into());
            self
        }
        /// <p>The date when this environment was last modified.</p>
        pub fn set_date_updated(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.date_updated = input;
            self
        }
        /// <p>A description of the environment.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the environment.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>For load-balanced, autoscaling environments, the URL to the load balancer. For single-instance environments, the IP address of the instance.</p>
        pub fn endpoint_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_url = Some(input.into());
            self
        }
        /// <p>For load-balanced, autoscaling environments, the URL to the load balancer. For single-instance environments, the IP address of the instance.</p>
        pub fn set_endpoint_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint_url = input;
            self
        }
        /// <p>The ARN of the environment.</p>
        pub fn environment_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the environment.</p>
        pub fn set_environment_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.environment_arn = input;
            self
        }
        /// <p>The identifier of the environment.</p>
        pub fn environment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_id = Some(input.into());
            self
        }
        /// <p>The identifier of the environment.</p>
        pub fn set_environment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.environment_id = input;
            self
        }
        /// Appends an item to `environment_links`.
        ///
        /// To override the contents of this collection use [`set_environment_links`](Self::set_environment_links).
        ///
        /// <p>Links to other environments in the same group.</p>
        pub fn environment_links(
            mut self,
            input: crate::model::AwsElasticBeanstalkEnvironmentEnvironmentLink,
        ) -> Self {
            let mut v = self.environment_links.unwrap_or_default();
            v.push(input);
            self.environment_links = Some(v);
            self
        }
        /// <p>Links to other environments in the same group.</p>
        pub fn set_environment_links(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsElasticBeanstalkEnvironmentEnvironmentLink>,
            >,
        ) -> Self {
            self.environment_links = input;
            self
        }
        /// <p>The name of the environment.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the environment.</p>
        pub fn set_environment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.environment_name = input;
            self
        }
        /// Appends an item to `option_settings`.
        ///
        /// To override the contents of this collection use [`set_option_settings`](Self::set_option_settings).
        ///
        /// <p>The configuration setting for the environment.</p>
        pub fn option_settings(
            mut self,
            input: crate::model::AwsElasticBeanstalkEnvironmentOptionSetting,
        ) -> Self {
            let mut v = self.option_settings.unwrap_or_default();
            v.push(input);
            self.option_settings = Some(v);
            self
        }
        /// <p>The configuration setting for the environment.</p>
        pub fn set_option_settings(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsElasticBeanstalkEnvironmentOptionSetting>,
            >,
        ) -> Self {
            self.option_settings = input;
            self
        }
        /// <p>The ARN of the platform version for the environment.</p>
        pub fn platform_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the platform version for the environment.</p>
        pub fn set_platform_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.platform_arn = input;
            self
        }
        /// <p>The name of the solution stack that is deployed with the environment.</p>
        pub fn solution_stack_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.solution_stack_name = Some(input.into());
            self
        }
        /// <p>The name of the solution stack that is deployed with the environment.</p>
        pub fn set_solution_stack_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.solution_stack_name = input;
            self
        }
        /// <p>The current operational status of the environment.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The current operational status of the environment.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>The tier of the environment.</p>
        pub fn tier(mut self, input: crate::model::AwsElasticBeanstalkEnvironmentTier) -> Self {
            self.tier = Some(input);
            self
        }
        /// <p>The tier of the environment.</p>
        pub fn set_tier(
            mut self,
            input: std::option::Option<crate::model::AwsElasticBeanstalkEnvironmentTier>,
        ) -> Self {
            self.tier = input;
            self
        }
        /// <p>The application version of the environment.</p>
        pub fn version_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_label = Some(input.into());
            self
        }
        /// <p>The application version of the environment.</p>
        pub fn set_version_label(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.version_label = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElasticBeanstalkEnvironmentDetails`](crate::model::AwsElasticBeanstalkEnvironmentDetails)
        pub fn build(self) -> crate::model::AwsElasticBeanstalkEnvironmentDetails {
            crate::model::AwsElasticBeanstalkEnvironmentDetails {
                application_name: self.application_name,
                cname: self.cname,
                date_created: self.date_created,
                date_updated: self.date_updated,
                description: self.description,
                endpoint_url: self.endpoint_url,
                environment_arn: self.environment_arn,
                environment_id: self.environment_id,
                environment_links: self.environment_links,
                environment_name: self.environment_name,
                option_settings: self.option_settings,
                platform_arn: self.platform_arn,
                solution_stack_name: self.solution_stack_name,
                status: self.status,
                tier: self.tier,
                version_label: self.version_label,
            }
        }
    }
}
impl AwsElasticBeanstalkEnvironmentDetails {
    /// Creates a new builder-style object to manufacture [`AwsElasticBeanstalkEnvironmentDetails`](crate::model::AwsElasticBeanstalkEnvironmentDetails)
    pub fn builder() -> crate::model::aws_elastic_beanstalk_environment_details::Builder {
        crate::model::aws_elastic_beanstalk_environment_details::Builder::default()
    }
}

/// <p>Contains information about the tier of the environment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElasticBeanstalkEnvironmentTier {
    /// <p>The name of the environment tier.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of environment tier.</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The version of the environment tier.</p>
    pub version: std::option::Option<std::string::String>,
}
impl AwsElasticBeanstalkEnvironmentTier {
    /// <p>The name of the environment tier.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of environment tier.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The version of the environment tier.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
}
impl std::fmt::Debug for AwsElasticBeanstalkEnvironmentTier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElasticBeanstalkEnvironmentTier");
        formatter.field("name", &self.name);
        formatter.field("r#type", &self.r#type);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`AwsElasticBeanstalkEnvironmentTier`](crate::model::AwsElasticBeanstalkEnvironmentTier)
pub mod aws_elastic_beanstalk_environment_tier {

    /// A builder for [`AwsElasticBeanstalkEnvironmentTier`](crate::model::AwsElasticBeanstalkEnvironmentTier)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the environment tier.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the environment tier.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of environment tier.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of environment tier.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The version of the environment tier.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The version of the environment tier.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElasticBeanstalkEnvironmentTier`](crate::model::AwsElasticBeanstalkEnvironmentTier)
        pub fn build(self) -> crate::model::AwsElasticBeanstalkEnvironmentTier {
            crate::model::AwsElasticBeanstalkEnvironmentTier {
                name: self.name,
                r#type: self.r#type,
                version: self.version,
            }
        }
    }
}
impl AwsElasticBeanstalkEnvironmentTier {
    /// Creates a new builder-style object to manufacture [`AwsElasticBeanstalkEnvironmentTier`](crate::model::AwsElasticBeanstalkEnvironmentTier)
    pub fn builder() -> crate::model::aws_elastic_beanstalk_environment_tier::Builder {
        crate::model::aws_elastic_beanstalk_environment_tier::Builder::default()
    }
}

/// <p>A configuration option setting for the environment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElasticBeanstalkEnvironmentOptionSetting {
    /// <p>The type of resource that the configuration option is associated with.</p>
    pub namespace: std::option::Option<std::string::String>,
    /// <p>The name of the option.</p>
    pub option_name: std::option::Option<std::string::String>,
    /// <p>The name of the resource.</p>
    pub resource_name: std::option::Option<std::string::String>,
    /// <p>The value of the configuration setting.</p>
    pub value: std::option::Option<std::string::String>,
}
impl AwsElasticBeanstalkEnvironmentOptionSetting {
    /// <p>The type of resource that the configuration option is associated with.</p>
    pub fn namespace(&self) -> std::option::Option<&str> {
        self.namespace.as_deref()
    }
    /// <p>The name of the option.</p>
    pub fn option_name(&self) -> std::option::Option<&str> {
        self.option_name.as_deref()
    }
    /// <p>The name of the resource.</p>
    pub fn resource_name(&self) -> std::option::Option<&str> {
        self.resource_name.as_deref()
    }
    /// <p>The value of the configuration setting.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for AwsElasticBeanstalkEnvironmentOptionSetting {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElasticBeanstalkEnvironmentOptionSetting");
        formatter.field("namespace", &self.namespace);
        formatter.field("option_name", &self.option_name);
        formatter.field("resource_name", &self.resource_name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`AwsElasticBeanstalkEnvironmentOptionSetting`](crate::model::AwsElasticBeanstalkEnvironmentOptionSetting)
pub mod aws_elastic_beanstalk_environment_option_setting {

    /// A builder for [`AwsElasticBeanstalkEnvironmentOptionSetting`](crate::model::AwsElasticBeanstalkEnvironmentOptionSetting)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) option_name: std::option::Option<std::string::String>,
        pub(crate) resource_name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of resource that the configuration option is associated with.</p>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>The type of resource that the configuration option is associated with.</p>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// <p>The name of the option.</p>
        pub fn option_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.option_name = Some(input.into());
            self
        }
        /// <p>The name of the option.</p>
        pub fn set_option_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.option_name = input;
            self
        }
        /// <p>The name of the resource.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_name = Some(input.into());
            self
        }
        /// <p>The name of the resource.</p>
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_name = input;
            self
        }
        /// <p>The value of the configuration setting.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the configuration setting.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElasticBeanstalkEnvironmentOptionSetting`](crate::model::AwsElasticBeanstalkEnvironmentOptionSetting)
        pub fn build(self) -> crate::model::AwsElasticBeanstalkEnvironmentOptionSetting {
            crate::model::AwsElasticBeanstalkEnvironmentOptionSetting {
                namespace: self.namespace,
                option_name: self.option_name,
                resource_name: self.resource_name,
                value: self.value,
            }
        }
    }
}
impl AwsElasticBeanstalkEnvironmentOptionSetting {
    /// Creates a new builder-style object to manufacture [`AwsElasticBeanstalkEnvironmentOptionSetting`](crate::model::AwsElasticBeanstalkEnvironmentOptionSetting)
    pub fn builder() -> crate::model::aws_elastic_beanstalk_environment_option_setting::Builder {
        crate::model::aws_elastic_beanstalk_environment_option_setting::Builder::default()
    }
}

/// <p>Contains information about a link to another environment that is in the same group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElasticBeanstalkEnvironmentEnvironmentLink {
    /// <p>The name of the linked environment.</p>
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The name of the environment link.</p>
    pub link_name: std::option::Option<std::string::String>,
}
impl AwsElasticBeanstalkEnvironmentEnvironmentLink {
    /// <p>The name of the linked environment.</p>
    pub fn environment_name(&self) -> std::option::Option<&str> {
        self.environment_name.as_deref()
    }
    /// <p>The name of the environment link.</p>
    pub fn link_name(&self) -> std::option::Option<&str> {
        self.link_name.as_deref()
    }
}
impl std::fmt::Debug for AwsElasticBeanstalkEnvironmentEnvironmentLink {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElasticBeanstalkEnvironmentEnvironmentLink");
        formatter.field("environment_name", &self.environment_name);
        formatter.field("link_name", &self.link_name);
        formatter.finish()
    }
}
/// See [`AwsElasticBeanstalkEnvironmentEnvironmentLink`](crate::model::AwsElasticBeanstalkEnvironmentEnvironmentLink)
pub mod aws_elastic_beanstalk_environment_environment_link {

    /// A builder for [`AwsElasticBeanstalkEnvironmentEnvironmentLink`](crate::model::AwsElasticBeanstalkEnvironmentEnvironmentLink)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) link_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the linked environment.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the linked environment.</p>
        pub fn set_environment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.environment_name = input;
            self
        }
        /// <p>The name of the environment link.</p>
        pub fn link_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_name = Some(input.into());
            self
        }
        /// <p>The name of the environment link.</p>
        pub fn set_link_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElasticBeanstalkEnvironmentEnvironmentLink`](crate::model::AwsElasticBeanstalkEnvironmentEnvironmentLink)
        pub fn build(self) -> crate::model::AwsElasticBeanstalkEnvironmentEnvironmentLink {
            crate::model::AwsElasticBeanstalkEnvironmentEnvironmentLink {
                environment_name: self.environment_name,
                link_name: self.link_name,
            }
        }
    }
}
impl AwsElasticBeanstalkEnvironmentEnvironmentLink {
    /// Creates a new builder-style object to manufacture [`AwsElasticBeanstalkEnvironmentEnvironmentLink`](crate::model::AwsElasticBeanstalkEnvironmentEnvironmentLink)
    pub fn builder() -> crate::model::aws_elastic_beanstalk_environment_environment_link::Builder {
        crate::model::aws_elastic_beanstalk_environment_environment_link::Builder::default()
    }
}

/// <p>Information about a load balancer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElbv2LoadBalancerDetails {
    /// <p>The Availability Zones for the load balancer.</p>
    pub availability_zones: std::option::Option<std::vec::Vec<crate::model::AvailabilityZone>>,
    /// <p>The ID of the Amazon Route 53 hosted zone associated with the load balancer.</p>
    pub canonical_hosted_zone_id: std::option::Option<std::string::String>,
    /// <p>Indicates when the load balancer was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub created_time: std::option::Option<std::string::String>,
    /// <p>The public DNS name of the load balancer.</p>
    pub dns_name: std::option::Option<std::string::String>,
    /// <p>The type of IP addresses used by the subnets for your load balancer. The possible values are <code>ipv4</code> (for IPv4 addresses) and <code>dualstack</code> (for IPv4 and IPv6 addresses).</p>
    pub ip_address_type: std::option::Option<std::string::String>,
    /// <p>The nodes of an Internet-facing load balancer have public IP addresses.</p>
    pub scheme: std::option::Option<std::string::String>,
    /// <p>The IDs of the security groups for the load balancer.</p>
    pub security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The state of the load balancer.</p>
    pub state: std::option::Option<crate::model::LoadBalancerState>,
    /// <p>The type of load balancer.</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The ID of the VPC for the load balancer.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>Attributes of the load balancer.</p>
    pub load_balancer_attributes:
        std::option::Option<std::vec::Vec<crate::model::AwsElbv2LoadBalancerAttribute>>,
}
impl AwsElbv2LoadBalancerDetails {
    /// <p>The Availability Zones for the load balancer.</p>
    pub fn availability_zones(&self) -> std::option::Option<&[crate::model::AvailabilityZone]> {
        self.availability_zones.as_deref()
    }
    /// <p>The ID of the Amazon Route 53 hosted zone associated with the load balancer.</p>
    pub fn canonical_hosted_zone_id(&self) -> std::option::Option<&str> {
        self.canonical_hosted_zone_id.as_deref()
    }
    /// <p>Indicates when the load balancer was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn created_time(&self) -> std::option::Option<&str> {
        self.created_time.as_deref()
    }
    /// <p>The public DNS name of the load balancer.</p>
    pub fn dns_name(&self) -> std::option::Option<&str> {
        self.dns_name.as_deref()
    }
    /// <p>The type of IP addresses used by the subnets for your load balancer. The possible values are <code>ipv4</code> (for IPv4 addresses) and <code>dualstack</code> (for IPv4 and IPv6 addresses).</p>
    pub fn ip_address_type(&self) -> std::option::Option<&str> {
        self.ip_address_type.as_deref()
    }
    /// <p>The nodes of an Internet-facing load balancer have public IP addresses.</p>
    pub fn scheme(&self) -> std::option::Option<&str> {
        self.scheme.as_deref()
    }
    /// <p>The IDs of the security groups for the load balancer.</p>
    pub fn security_groups(&self) -> std::option::Option<&[std::string::String]> {
        self.security_groups.as_deref()
    }
    /// <p>The state of the load balancer.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::LoadBalancerState> {
        self.state.as_ref()
    }
    /// <p>The type of load balancer.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The ID of the VPC for the load balancer.</p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
    /// <p>Attributes of the load balancer.</p>
    pub fn load_balancer_attributes(
        &self,
    ) -> std::option::Option<&[crate::model::AwsElbv2LoadBalancerAttribute]> {
        self.load_balancer_attributes.as_deref()
    }
}
impl std::fmt::Debug for AwsElbv2LoadBalancerDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElbv2LoadBalancerDetails");
        formatter.field("availability_zones", &self.availability_zones);
        formatter.field("canonical_hosted_zone_id", &self.canonical_hosted_zone_id);
        formatter.field("created_time", &self.created_time);
        formatter.field("dns_name", &self.dns_name);
        formatter.field("ip_address_type", &self.ip_address_type);
        formatter.field("scheme", &self.scheme);
        formatter.field("security_groups", &self.security_groups);
        formatter.field("state", &self.state);
        formatter.field("r#type", &self.r#type);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("load_balancer_attributes", &self.load_balancer_attributes);
        formatter.finish()
    }
}
/// See [`AwsElbv2LoadBalancerDetails`](crate::model::AwsElbv2LoadBalancerDetails)
pub mod aws_elbv2_load_balancer_details {

    /// A builder for [`AwsElbv2LoadBalancerDetails`](crate::model::AwsElbv2LoadBalancerDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_zones:
            std::option::Option<std::vec::Vec<crate::model::AvailabilityZone>>,
        pub(crate) canonical_hosted_zone_id: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<std::string::String>,
        pub(crate) dns_name: std::option::Option<std::string::String>,
        pub(crate) ip_address_type: std::option::Option<std::string::String>,
        pub(crate) scheme: std::option::Option<std::string::String>,
        pub(crate) security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) state: std::option::Option<crate::model::LoadBalancerState>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) load_balancer_attributes:
            std::option::Option<std::vec::Vec<crate::model::AwsElbv2LoadBalancerAttribute>>,
    }
    impl Builder {
        /// Appends an item to `availability_zones`.
        ///
        /// To override the contents of this collection use [`set_availability_zones`](Self::set_availability_zones).
        ///
        /// <p>The Availability Zones for the load balancer.</p>
        pub fn availability_zones(mut self, input: crate::model::AvailabilityZone) -> Self {
            let mut v = self.availability_zones.unwrap_or_default();
            v.push(input);
            self.availability_zones = Some(v);
            self
        }
        /// <p>The Availability Zones for the load balancer.</p>
        pub fn set_availability_zones(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AvailabilityZone>>,
        ) -> Self {
            self.availability_zones = input;
            self
        }
        /// <p>The ID of the Amazon Route 53 hosted zone associated with the load balancer.</p>
        pub fn canonical_hosted_zone_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.canonical_hosted_zone_id = Some(input.into());
            self
        }
        /// <p>The ID of the Amazon Route 53 hosted zone associated with the load balancer.</p>
        pub fn set_canonical_hosted_zone_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.canonical_hosted_zone_id = input;
            self
        }
        /// <p>Indicates when the load balancer was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn created_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_time = Some(input.into());
            self
        }
        /// <p>Indicates when the load balancer was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_created_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The public DNS name of the load balancer.</p>
        pub fn dns_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.dns_name = Some(input.into());
            self
        }
        /// <p>The public DNS name of the load balancer.</p>
        pub fn set_dns_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dns_name = input;
            self
        }
        /// <p>The type of IP addresses used by the subnets for your load balancer. The possible values are <code>ipv4</code> (for IPv4 addresses) and <code>dualstack</code> (for IPv4 and IPv6 addresses).</p>
        pub fn ip_address_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.ip_address_type = Some(input.into());
            self
        }
        /// <p>The type of IP addresses used by the subnets for your load balancer. The possible values are <code>ipv4</code> (for IPv4 addresses) and <code>dualstack</code> (for IPv4 and IPv6 addresses).</p>
        pub fn set_ip_address_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ip_address_type = input;
            self
        }
        /// <p>The nodes of an Internet-facing load balancer have public IP addresses.</p>
        pub fn scheme(mut self, input: impl Into<std::string::String>) -> Self {
            self.scheme = Some(input.into());
            self
        }
        /// <p>The nodes of an Internet-facing load balancer have public IP addresses.</p>
        pub fn set_scheme(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.scheme = input;
            self
        }
        /// Appends an item to `security_groups`.
        ///
        /// To override the contents of this collection use [`set_security_groups`](Self::set_security_groups).
        ///
        /// <p>The IDs of the security groups for the load balancer.</p>
        pub fn security_groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_groups.unwrap_or_default();
            v.push(input.into());
            self.security_groups = Some(v);
            self
        }
        /// <p>The IDs of the security groups for the load balancer.</p>
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_groups = input;
            self
        }
        /// <p>The state of the load balancer.</p>
        pub fn state(mut self, input: crate::model::LoadBalancerState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the load balancer.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::LoadBalancerState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The type of load balancer.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of load balancer.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The ID of the VPC for the load balancer.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The ID of the VPC for the load balancer.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Appends an item to `load_balancer_attributes`.
        ///
        /// To override the contents of this collection use [`set_load_balancer_attributes`](Self::set_load_balancer_attributes).
        ///
        /// <p>Attributes of the load balancer.</p>
        pub fn load_balancer_attributes(
            mut self,
            input: crate::model::AwsElbv2LoadBalancerAttribute,
        ) -> Self {
            let mut v = self.load_balancer_attributes.unwrap_or_default();
            v.push(input);
            self.load_balancer_attributes = Some(v);
            self
        }
        /// <p>Attributes of the load balancer.</p>
        pub fn set_load_balancer_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsElbv2LoadBalancerAttribute>>,
        ) -> Self {
            self.load_balancer_attributes = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElbv2LoadBalancerDetails`](crate::model::AwsElbv2LoadBalancerDetails)
        pub fn build(self) -> crate::model::AwsElbv2LoadBalancerDetails {
            crate::model::AwsElbv2LoadBalancerDetails {
                availability_zones: self.availability_zones,
                canonical_hosted_zone_id: self.canonical_hosted_zone_id,
                created_time: self.created_time,
                dns_name: self.dns_name,
                ip_address_type: self.ip_address_type,
                scheme: self.scheme,
                security_groups: self.security_groups,
                state: self.state,
                r#type: self.r#type,
                vpc_id: self.vpc_id,
                load_balancer_attributes: self.load_balancer_attributes,
            }
        }
    }
}
impl AwsElbv2LoadBalancerDetails {
    /// Creates a new builder-style object to manufacture [`AwsElbv2LoadBalancerDetails`](crate::model::AwsElbv2LoadBalancerDetails)
    pub fn builder() -> crate::model::aws_elbv2_load_balancer_details::Builder {
        crate::model::aws_elbv2_load_balancer_details::Builder::default()
    }
}

/// <p>A load balancer attribute.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsElbv2LoadBalancerAttribute {
    /// <p>The name of the load balancer attribute.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The value of the load balancer attribute.</p>
    pub value: std::option::Option<std::string::String>,
}
impl AwsElbv2LoadBalancerAttribute {
    /// <p>The name of the load balancer attribute.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The value of the load balancer attribute.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for AwsElbv2LoadBalancerAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsElbv2LoadBalancerAttribute");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`AwsElbv2LoadBalancerAttribute`](crate::model::AwsElbv2LoadBalancerAttribute)
pub mod aws_elbv2_load_balancer_attribute {

    /// A builder for [`AwsElbv2LoadBalancerAttribute`](crate::model::AwsElbv2LoadBalancerAttribute)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the load balancer attribute.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The name of the load balancer attribute.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value of the load balancer attribute.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the load balancer attribute.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsElbv2LoadBalancerAttribute`](crate::model::AwsElbv2LoadBalancerAttribute)
        pub fn build(self) -> crate::model::AwsElbv2LoadBalancerAttribute {
            crate::model::AwsElbv2LoadBalancerAttribute {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl AwsElbv2LoadBalancerAttribute {
    /// Creates a new builder-style object to manufacture [`AwsElbv2LoadBalancerAttribute`](crate::model::AwsElbv2LoadBalancerAttribute)
    pub fn builder() -> crate::model::aws_elbv2_load_balancer_attribute::Builder {
        crate::model::aws_elbv2_load_balancer_attribute::Builder::default()
    }
}

/// <p>Information about the state of the load balancer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LoadBalancerState {
    /// <p>The state code. The initial state of the load balancer is provisioning.</p>
    /// <p>After the load balancer is fully set up and ready to route traffic, its state is active.</p>
    /// <p>If the load balancer could not be set up, its state is failed. </p>
    pub code: std::option::Option<std::string::String>,
    /// <p>A description of the state.</p>
    pub reason: std::option::Option<std::string::String>,
}
impl LoadBalancerState {
    /// <p>The state code. The initial state of the load balancer is provisioning.</p>
    /// <p>After the load balancer is fully set up and ready to route traffic, its state is active.</p>
    /// <p>If the load balancer could not be set up, its state is failed. </p>
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
    /// <p>A description of the state.</p>
    pub fn reason(&self) -> std::option::Option<&str> {
        self.reason.as_deref()
    }
}
impl std::fmt::Debug for LoadBalancerState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LoadBalancerState");
        formatter.field("code", &self.code);
        formatter.field("reason", &self.reason);
        formatter.finish()
    }
}
/// See [`LoadBalancerState`](crate::model::LoadBalancerState)
pub mod load_balancer_state {

    /// A builder for [`LoadBalancerState`](crate::model::LoadBalancerState)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The state code. The initial state of the load balancer is provisioning.</p>
        /// <p>After the load balancer is fully set up and ready to route traffic, its state is active.</p>
        /// <p>If the load balancer could not be set up, its state is failed. </p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// <p>The state code. The initial state of the load balancer is provisioning.</p>
        /// <p>After the load balancer is fully set up and ready to route traffic, its state is active.</p>
        /// <p>If the load balancer could not be set up, its state is failed. </p>
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A description of the state.</p>
        pub fn reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.reason = Some(input.into());
            self
        }
        /// <p>A description of the state.</p>
        pub fn set_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reason = input;
            self
        }
        /// Consumes the builder and constructs a [`LoadBalancerState`](crate::model::LoadBalancerState)
        pub fn build(self) -> crate::model::LoadBalancerState {
            crate::model::LoadBalancerState {
                code: self.code,
                reason: self.reason,
            }
        }
    }
}
impl LoadBalancerState {
    /// Creates a new builder-style object to manufacture [`LoadBalancerState`](crate::model::LoadBalancerState)
    pub fn builder() -> crate::model::load_balancer_state::Builder {
        crate::model::load_balancer_state::Builder::default()
    }
}

/// <p>Information about an Availability Zone.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AvailabilityZone {
    /// <p>The name of the Availability Zone.</p>
    pub zone_name: std::option::Option<std::string::String>,
    /// <p>The ID of the subnet. You can specify one subnet per Availability Zone.</p>
    pub subnet_id: std::option::Option<std::string::String>,
}
impl AvailabilityZone {
    /// <p>The name of the Availability Zone.</p>
    pub fn zone_name(&self) -> std::option::Option<&str> {
        self.zone_name.as_deref()
    }
    /// <p>The ID of the subnet. You can specify one subnet per Availability Zone.</p>
    pub fn subnet_id(&self) -> std::option::Option<&str> {
        self.subnet_id.as_deref()
    }
}
impl std::fmt::Debug for AvailabilityZone {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AvailabilityZone");
        formatter.field("zone_name", &self.zone_name);
        formatter.field("subnet_id", &self.subnet_id);
        formatter.finish()
    }
}
/// See [`AvailabilityZone`](crate::model::AvailabilityZone)
pub mod availability_zone {

    /// A builder for [`AvailabilityZone`](crate::model::AvailabilityZone)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) zone_name: std::option::Option<std::string::String>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Availability Zone.</p>
        pub fn zone_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.zone_name = Some(input.into());
            self
        }
        /// <p>The name of the Availability Zone.</p>
        pub fn set_zone_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.zone_name = input;
            self
        }
        /// <p>The ID of the subnet. You can specify one subnet per Availability Zone.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        /// <p>The ID of the subnet. You can specify one subnet per Availability Zone.</p>
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AvailabilityZone`](crate::model::AvailabilityZone)
        pub fn build(self) -> crate::model::AvailabilityZone {
            crate::model::AvailabilityZone {
                zone_name: self.zone_name,
                subnet_id: self.subnet_id,
            }
        }
    }
}
impl AvailabilityZone {
    /// Creates a new builder-style object to manufacture [`AvailabilityZone`](crate::model::AvailabilityZone)
    pub fn builder() -> crate::model::availability_zone::Builder {
        crate::model::availability_zone::Builder::default()
    }
}

/// <p>Contains details about an Amazon EC2 network access control list (ACL).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2NetworkAclDetails {
    /// <p>Whether this is the default network ACL for the VPC.</p>
    pub is_default: bool,
    /// <p>The identifier of the network ACL.</p>
    pub network_acl_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Web Services account that owns the network ACL.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the VPC for the network ACL.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>Associations between the network ACL and subnets.</p>
    pub associations: std::option::Option<std::vec::Vec<crate::model::AwsEc2NetworkAclAssociation>>,
    /// <p>The set of rules in the network ACL.</p>
    pub entries: std::option::Option<std::vec::Vec<crate::model::AwsEc2NetworkAclEntry>>,
}
impl AwsEc2NetworkAclDetails {
    /// <p>Whether this is the default network ACL for the VPC.</p>
    pub fn is_default(&self) -> bool {
        self.is_default
    }
    /// <p>The identifier of the network ACL.</p>
    pub fn network_acl_id(&self) -> std::option::Option<&str> {
        self.network_acl_id.as_deref()
    }
    /// <p>The identifier of the Amazon Web Services account that owns the network ACL.</p>
    pub fn owner_id(&self) -> std::option::Option<&str> {
        self.owner_id.as_deref()
    }
    /// <p>The identifier of the VPC for the network ACL.</p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
    /// <p>Associations between the network ACL and subnets.</p>
    pub fn associations(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEc2NetworkAclAssociation]> {
        self.associations.as_deref()
    }
    /// <p>The set of rules in the network ACL.</p>
    pub fn entries(&self) -> std::option::Option<&[crate::model::AwsEc2NetworkAclEntry]> {
        self.entries.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2NetworkAclDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2NetworkAclDetails");
        formatter.field("is_default", &self.is_default);
        formatter.field("network_acl_id", &self.network_acl_id);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("associations", &self.associations);
        formatter.field("entries", &self.entries);
        formatter.finish()
    }
}
/// See [`AwsEc2NetworkAclDetails`](crate::model::AwsEc2NetworkAclDetails)
pub mod aws_ec2_network_acl_details {

    /// A builder for [`AwsEc2NetworkAclDetails`](crate::model::AwsEc2NetworkAclDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) is_default: std::option::Option<bool>,
        pub(crate) network_acl_id: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) associations:
            std::option::Option<std::vec::Vec<crate::model::AwsEc2NetworkAclAssociation>>,
        pub(crate) entries: std::option::Option<std::vec::Vec<crate::model::AwsEc2NetworkAclEntry>>,
    }
    impl Builder {
        /// <p>Whether this is the default network ACL for the VPC.</p>
        pub fn is_default(mut self, input: bool) -> Self {
            self.is_default = Some(input);
            self
        }
        /// <p>Whether this is the default network ACL for the VPC.</p>
        pub fn set_is_default(mut self, input: std::option::Option<bool>) -> Self {
            self.is_default = input;
            self
        }
        /// <p>The identifier of the network ACL.</p>
        pub fn network_acl_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_acl_id = Some(input.into());
            self
        }
        /// <p>The identifier of the network ACL.</p>
        pub fn set_network_acl_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_acl_id = input;
            self
        }
        /// <p>The identifier of the Amazon Web Services account that owns the network ACL.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Web Services account that owns the network ACL.</p>
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The identifier of the VPC for the network ACL.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The identifier of the VPC for the network ACL.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Appends an item to `associations`.
        ///
        /// To override the contents of this collection use [`set_associations`](Self::set_associations).
        ///
        /// <p>Associations between the network ACL and subnets.</p>
        pub fn associations(mut self, input: crate::model::AwsEc2NetworkAclAssociation) -> Self {
            let mut v = self.associations.unwrap_or_default();
            v.push(input);
            self.associations = Some(v);
            self
        }
        /// <p>Associations between the network ACL and subnets.</p>
        pub fn set_associations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsEc2NetworkAclAssociation>>,
        ) -> Self {
            self.associations = input;
            self
        }
        /// Appends an item to `entries`.
        ///
        /// To override the contents of this collection use [`set_entries`](Self::set_entries).
        ///
        /// <p>The set of rules in the network ACL.</p>
        pub fn entries(mut self, input: crate::model::AwsEc2NetworkAclEntry) -> Self {
            let mut v = self.entries.unwrap_or_default();
            v.push(input);
            self.entries = Some(v);
            self
        }
        /// <p>The set of rules in the network ACL.</p>
        pub fn set_entries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsEc2NetworkAclEntry>>,
        ) -> Self {
            self.entries = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2NetworkAclDetails`](crate::model::AwsEc2NetworkAclDetails)
        pub fn build(self) -> crate::model::AwsEc2NetworkAclDetails {
            crate::model::AwsEc2NetworkAclDetails {
                is_default: self.is_default.unwrap_or_default(),
                network_acl_id: self.network_acl_id,
                owner_id: self.owner_id,
                vpc_id: self.vpc_id,
                associations: self.associations,
                entries: self.entries,
            }
        }
    }
}
impl AwsEc2NetworkAclDetails {
    /// Creates a new builder-style object to manufacture [`AwsEc2NetworkAclDetails`](crate::model::AwsEc2NetworkAclDetails)
    pub fn builder() -> crate::model::aws_ec2_network_acl_details::Builder {
        crate::model::aws_ec2_network_acl_details::Builder::default()
    }
}

/// <p>A rule for the network ACL. Each rule allows or denies access based on the IP address, traffic direction, port, and protocol.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2NetworkAclEntry {
    /// <p>The IPV4 network range for which to deny or allow access.</p>
    pub cidr_block: std::option::Option<std::string::String>,
    /// <p>Whether the rule is an egress rule. An egress rule is a rule that applies to traffic that leaves the subnet.</p>
    pub egress: bool,
    /// <p>The Internet Control Message Protocol (ICMP) type and code for which to deny or allow access.</p>
    pub icmp_type_code: std::option::Option<crate::model::IcmpTypeCode>,
    /// <p>The IPV6 network range for which to deny or allow access.</p>
    pub ipv6_cidr_block: std::option::Option<std::string::String>,
    /// <p>For TCP or UDP protocols, the range of ports that the rule applies to.</p>
    pub port_range: std::option::Option<crate::model::PortRangeFromTo>,
    /// <p>The protocol that the rule applies to. To deny or allow access to all protocols, use the value <code>-1</code>.</p>
    pub protocol: std::option::Option<std::string::String>,
    /// <p>Whether the rule is used to allow access or deny access.</p>
    pub rule_action: std::option::Option<std::string::String>,
    /// <p>The rule number. The rules are processed in order by their number.</p>
    pub rule_number: i32,
}
impl AwsEc2NetworkAclEntry {
    /// <p>The IPV4 network range for which to deny or allow access.</p>
    pub fn cidr_block(&self) -> std::option::Option<&str> {
        self.cidr_block.as_deref()
    }
    /// <p>Whether the rule is an egress rule. An egress rule is a rule that applies to traffic that leaves the subnet.</p>
    pub fn egress(&self) -> bool {
        self.egress
    }
    /// <p>The Internet Control Message Protocol (ICMP) type and code for which to deny or allow access.</p>
    pub fn icmp_type_code(&self) -> std::option::Option<&crate::model::IcmpTypeCode> {
        self.icmp_type_code.as_ref()
    }
    /// <p>The IPV6 network range for which to deny or allow access.</p>
    pub fn ipv6_cidr_block(&self) -> std::option::Option<&str> {
        self.ipv6_cidr_block.as_deref()
    }
    /// <p>For TCP or UDP protocols, the range of ports that the rule applies to.</p>
    pub fn port_range(&self) -> std::option::Option<&crate::model::PortRangeFromTo> {
        self.port_range.as_ref()
    }
    /// <p>The protocol that the rule applies to. To deny or allow access to all protocols, use the value <code>-1</code>.</p>
    pub fn protocol(&self) -> std::option::Option<&str> {
        self.protocol.as_deref()
    }
    /// <p>Whether the rule is used to allow access or deny access.</p>
    pub fn rule_action(&self) -> std::option::Option<&str> {
        self.rule_action.as_deref()
    }
    /// <p>The rule number. The rules are processed in order by their number.</p>
    pub fn rule_number(&self) -> i32 {
        self.rule_number
    }
}
impl std::fmt::Debug for AwsEc2NetworkAclEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2NetworkAclEntry");
        formatter.field("cidr_block", &self.cidr_block);
        formatter.field("egress", &self.egress);
        formatter.field("icmp_type_code", &self.icmp_type_code);
        formatter.field("ipv6_cidr_block", &self.ipv6_cidr_block);
        formatter.field("port_range", &self.port_range);
        formatter.field("protocol", &self.protocol);
        formatter.field("rule_action", &self.rule_action);
        formatter.field("rule_number", &self.rule_number);
        formatter.finish()
    }
}
/// See [`AwsEc2NetworkAclEntry`](crate::model::AwsEc2NetworkAclEntry)
pub mod aws_ec2_network_acl_entry {

    /// A builder for [`AwsEc2NetworkAclEntry`](crate::model::AwsEc2NetworkAclEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cidr_block: std::option::Option<std::string::String>,
        pub(crate) egress: std::option::Option<bool>,
        pub(crate) icmp_type_code: std::option::Option<crate::model::IcmpTypeCode>,
        pub(crate) ipv6_cidr_block: std::option::Option<std::string::String>,
        pub(crate) port_range: std::option::Option<crate::model::PortRangeFromTo>,
        pub(crate) protocol: std::option::Option<std::string::String>,
        pub(crate) rule_action: std::option::Option<std::string::String>,
        pub(crate) rule_number: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The IPV4 network range for which to deny or allow access.</p>
        pub fn cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr_block = Some(input.into());
            self
        }
        /// <p>The IPV4 network range for which to deny or allow access.</p>
        pub fn set_cidr_block(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr_block = input;
            self
        }
        /// <p>Whether the rule is an egress rule. An egress rule is a rule that applies to traffic that leaves the subnet.</p>
        pub fn egress(mut self, input: bool) -> Self {
            self.egress = Some(input);
            self
        }
        /// <p>Whether the rule is an egress rule. An egress rule is a rule that applies to traffic that leaves the subnet.</p>
        pub fn set_egress(mut self, input: std::option::Option<bool>) -> Self {
            self.egress = input;
            self
        }
        /// <p>The Internet Control Message Protocol (ICMP) type and code for which to deny or allow access.</p>
        pub fn icmp_type_code(mut self, input: crate::model::IcmpTypeCode) -> Self {
            self.icmp_type_code = Some(input);
            self
        }
        /// <p>The Internet Control Message Protocol (ICMP) type and code for which to deny or allow access.</p>
        pub fn set_icmp_type_code(
            mut self,
            input: std::option::Option<crate::model::IcmpTypeCode>,
        ) -> Self {
            self.icmp_type_code = input;
            self
        }
        /// <p>The IPV6 network range for which to deny or allow access.</p>
        pub fn ipv6_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.ipv6_cidr_block = Some(input.into());
            self
        }
        /// <p>The IPV6 network range for which to deny or allow access.</p>
        pub fn set_ipv6_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ipv6_cidr_block = input;
            self
        }
        /// <p>For TCP or UDP protocols, the range of ports that the rule applies to.</p>
        pub fn port_range(mut self, input: crate::model::PortRangeFromTo) -> Self {
            self.port_range = Some(input);
            self
        }
        /// <p>For TCP or UDP protocols, the range of ports that the rule applies to.</p>
        pub fn set_port_range(
            mut self,
            input: std::option::Option<crate::model::PortRangeFromTo>,
        ) -> Self {
            self.port_range = input;
            self
        }
        /// <p>The protocol that the rule applies to. To deny or allow access to all protocols, use the value <code>-1</code>.</p>
        pub fn protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.protocol = Some(input.into());
            self
        }
        /// <p>The protocol that the rule applies to. To deny or allow access to all protocols, use the value <code>-1</code>.</p>
        pub fn set_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.protocol = input;
            self
        }
        /// <p>Whether the rule is used to allow access or deny access.</p>
        pub fn rule_action(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_action = Some(input.into());
            self
        }
        /// <p>Whether the rule is used to allow access or deny access.</p>
        pub fn set_rule_action(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_action = input;
            self
        }
        /// <p>The rule number. The rules are processed in order by their number.</p>
        pub fn rule_number(mut self, input: i32) -> Self {
            self.rule_number = Some(input);
            self
        }
        /// <p>The rule number. The rules are processed in order by their number.</p>
        pub fn set_rule_number(mut self, input: std::option::Option<i32>) -> Self {
            self.rule_number = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2NetworkAclEntry`](crate::model::AwsEc2NetworkAclEntry)
        pub fn build(self) -> crate::model::AwsEc2NetworkAclEntry {
            crate::model::AwsEc2NetworkAclEntry {
                cidr_block: self.cidr_block,
                egress: self.egress.unwrap_or_default(),
                icmp_type_code: self.icmp_type_code,
                ipv6_cidr_block: self.ipv6_cidr_block,
                port_range: self.port_range,
                protocol: self.protocol,
                rule_action: self.rule_action,
                rule_number: self.rule_number.unwrap_or_default(),
            }
        }
    }
}
impl AwsEc2NetworkAclEntry {
    /// Creates a new builder-style object to manufacture [`AwsEc2NetworkAclEntry`](crate::model::AwsEc2NetworkAclEntry)
    pub fn builder() -> crate::model::aws_ec2_network_acl_entry::Builder {
        crate::model::aws_ec2_network_acl_entry::Builder::default()
    }
}

/// <p>A range of ports.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PortRangeFromTo {
    /// <p>The first port in the port range.</p>
    pub from: i32,
    /// <p>The last port in the port range.</p>
    pub to: i32,
}
impl PortRangeFromTo {
    /// <p>The first port in the port range.</p>
    pub fn from(&self) -> i32 {
        self.from
    }
    /// <p>The last port in the port range.</p>
    pub fn to(&self) -> i32 {
        self.to
    }
}
impl std::fmt::Debug for PortRangeFromTo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PortRangeFromTo");
        formatter.field("from", &self.from);
        formatter.field("to", &self.to);
        formatter.finish()
    }
}
/// See [`PortRangeFromTo`](crate::model::PortRangeFromTo)
pub mod port_range_from_to {

    /// A builder for [`PortRangeFromTo`](crate::model::PortRangeFromTo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) from: std::option::Option<i32>,
        pub(crate) to: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The first port in the port range.</p>
        pub fn from(mut self, input: i32) -> Self {
            self.from = Some(input);
            self
        }
        /// <p>The first port in the port range.</p>
        pub fn set_from(mut self, input: std::option::Option<i32>) -> Self {
            self.from = input;
            self
        }
        /// <p>The last port in the port range.</p>
        pub fn to(mut self, input: i32) -> Self {
            self.to = Some(input);
            self
        }
        /// <p>The last port in the port range.</p>
        pub fn set_to(mut self, input: std::option::Option<i32>) -> Self {
            self.to = input;
            self
        }
        /// Consumes the builder and constructs a [`PortRangeFromTo`](crate::model::PortRangeFromTo)
        pub fn build(self) -> crate::model::PortRangeFromTo {
            crate::model::PortRangeFromTo {
                from: self.from.unwrap_or_default(),
                to: self.to.unwrap_or_default(),
            }
        }
    }
}
impl PortRangeFromTo {
    /// Creates a new builder-style object to manufacture [`PortRangeFromTo`](crate::model::PortRangeFromTo)
    pub fn builder() -> crate::model::port_range_from_to::Builder {
        crate::model::port_range_from_to::Builder::default()
    }
}

/// <p>An Internet Control Message Protocol (ICMP) type and code.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IcmpTypeCode {
    /// <p>The ICMP code for which to deny or allow access. To deny or allow all codes, use the value <code>-1</code>.</p>
    pub code: i32,
    /// <p>The ICMP type for which to deny or allow access. To deny or allow all types, use the value <code>-1</code>.</p>
    pub r#type: i32,
}
impl IcmpTypeCode {
    /// <p>The ICMP code for which to deny or allow access. To deny or allow all codes, use the value <code>-1</code>.</p>
    pub fn code(&self) -> i32 {
        self.code
    }
    /// <p>The ICMP type for which to deny or allow access. To deny or allow all types, use the value <code>-1</code>.</p>
    pub fn r#type(&self) -> i32 {
        self.r#type
    }
}
impl std::fmt::Debug for IcmpTypeCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IcmpTypeCode");
        formatter.field("code", &self.code);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`IcmpTypeCode`](crate::model::IcmpTypeCode)
pub mod icmp_type_code {

    /// A builder for [`IcmpTypeCode`](crate::model::IcmpTypeCode)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<i32>,
        pub(crate) r#type: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ICMP code for which to deny or allow access. To deny or allow all codes, use the value <code>-1</code>.</p>
        pub fn code(mut self, input: i32) -> Self {
            self.code = Some(input);
            self
        }
        /// <p>The ICMP code for which to deny or allow access. To deny or allow all codes, use the value <code>-1</code>.</p>
        pub fn set_code(mut self, input: std::option::Option<i32>) -> Self {
            self.code = input;
            self
        }
        /// <p>The ICMP type for which to deny or allow access. To deny or allow all types, use the value <code>-1</code>.</p>
        pub fn r#type(mut self, input: i32) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The ICMP type for which to deny or allow access. To deny or allow all types, use the value <code>-1</code>.</p>
        pub fn set_type(mut self, input: std::option::Option<i32>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`IcmpTypeCode`](crate::model::IcmpTypeCode)
        pub fn build(self) -> crate::model::IcmpTypeCode {
            crate::model::IcmpTypeCode {
                code: self.code.unwrap_or_default(),
                r#type: self.r#type.unwrap_or_default(),
            }
        }
    }
}
impl IcmpTypeCode {
    /// Creates a new builder-style object to manufacture [`IcmpTypeCode`](crate::model::IcmpTypeCode)
    pub fn builder() -> crate::model::icmp_type_code::Builder {
        crate::model::icmp_type_code::Builder::default()
    }
}

/// <p>An association between the network ACL and a subnet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2NetworkAclAssociation {
    /// <p>The identifier of the association between the network ACL and the subnet.</p>
    pub network_acl_association_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the network ACL.</p>
    pub network_acl_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the subnet that is associated with the network ACL.</p>
    pub subnet_id: std::option::Option<std::string::String>,
}
impl AwsEc2NetworkAclAssociation {
    /// <p>The identifier of the association between the network ACL and the subnet.</p>
    pub fn network_acl_association_id(&self) -> std::option::Option<&str> {
        self.network_acl_association_id.as_deref()
    }
    /// <p>The identifier of the network ACL.</p>
    pub fn network_acl_id(&self) -> std::option::Option<&str> {
        self.network_acl_id.as_deref()
    }
    /// <p>The identifier of the subnet that is associated with the network ACL.</p>
    pub fn subnet_id(&self) -> std::option::Option<&str> {
        self.subnet_id.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2NetworkAclAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2NetworkAclAssociation");
        formatter.field(
            "network_acl_association_id",
            &self.network_acl_association_id,
        );
        formatter.field("network_acl_id", &self.network_acl_id);
        formatter.field("subnet_id", &self.subnet_id);
        formatter.finish()
    }
}
/// See [`AwsEc2NetworkAclAssociation`](crate::model::AwsEc2NetworkAclAssociation)
pub mod aws_ec2_network_acl_association {

    /// A builder for [`AwsEc2NetworkAclAssociation`](crate::model::AwsEc2NetworkAclAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) network_acl_association_id: std::option::Option<std::string::String>,
        pub(crate) network_acl_id: std::option::Option<std::string::String>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the association between the network ACL and the subnet.</p>
        pub fn network_acl_association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_acl_association_id = Some(input.into());
            self
        }
        /// <p>The identifier of the association between the network ACL and the subnet.</p>
        pub fn set_network_acl_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_acl_association_id = input;
            self
        }
        /// <p>The identifier of the network ACL.</p>
        pub fn network_acl_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_acl_id = Some(input.into());
            self
        }
        /// <p>The identifier of the network ACL.</p>
        pub fn set_network_acl_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_acl_id = input;
            self
        }
        /// <p>The identifier of the subnet that is associated with the network ACL.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        /// <p>The identifier of the subnet that is associated with the network ACL.</p>
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2NetworkAclAssociation`](crate::model::AwsEc2NetworkAclAssociation)
        pub fn build(self) -> crate::model::AwsEc2NetworkAclAssociation {
            crate::model::AwsEc2NetworkAclAssociation {
                network_acl_association_id: self.network_acl_association_id,
                network_acl_id: self.network_acl_id,
                subnet_id: self.subnet_id,
            }
        }
    }
}
impl AwsEc2NetworkAclAssociation {
    /// Creates a new builder-style object to manufacture [`AwsEc2NetworkAclAssociation`](crate::model::AwsEc2NetworkAclAssociation)
    pub fn builder() -> crate::model::aws_ec2_network_acl_association::Builder {
        crate::model::aws_ec2_network_acl_association::Builder::default()
    }
}

/// <p>Contains information about a subnet in Amazon EC2.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2SubnetDetails {
    /// <p>Whether to assign an IPV6 address to a network interface that is created in this subnet.</p>
    pub assign_ipv6_address_on_creation: bool,
    /// <p>The Availability Zone for the subnet.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The identifier of the Availability Zone for the subnet.</p>
    pub availability_zone_id: std::option::Option<std::string::String>,
    /// <p>The number of available IPV4 addresses in the subnet. Does not include addresses for stopped instances.</p>
    pub available_ip_address_count: i32,
    /// <p>The IPV4 CIDR block that is assigned to the subnet.</p>
    pub cidr_block: std::option::Option<std::string::String>,
    /// <p>Whether this subnet is the default subnet for the Availability Zone.</p>
    pub default_for_az: bool,
    /// <p>Whether instances in this subnet receive a public IP address.</p>
    pub map_public_ip_on_launch: bool,
    /// <p>The identifier of the Amazon Web Services account that owns the subnet.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The current state of the subnet.</p>
    pub state: std::option::Option<std::string::String>,
    /// <p>The ARN of the subnet.</p>
    pub subnet_arn: std::option::Option<std::string::String>,
    /// <p>The identifier of the subnet.</p>
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the VPC that contains the subnet.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The IPV6 CIDR blocks that are associated with the subnet.</p>
    pub ipv6_cidr_block_association_set:
        std::option::Option<std::vec::Vec<crate::model::Ipv6CidrBlockAssociation>>,
}
impl AwsEc2SubnetDetails {
    /// <p>Whether to assign an IPV6 address to a network interface that is created in this subnet.</p>
    pub fn assign_ipv6_address_on_creation(&self) -> bool {
        self.assign_ipv6_address_on_creation
    }
    /// <p>The Availability Zone for the subnet.</p>
    pub fn availability_zone(&self) -> std::option::Option<&str> {
        self.availability_zone.as_deref()
    }
    /// <p>The identifier of the Availability Zone for the subnet.</p>
    pub fn availability_zone_id(&self) -> std::option::Option<&str> {
        self.availability_zone_id.as_deref()
    }
    /// <p>The number of available IPV4 addresses in the subnet. Does not include addresses for stopped instances.</p>
    pub fn available_ip_address_count(&self) -> i32 {
        self.available_ip_address_count
    }
    /// <p>The IPV4 CIDR block that is assigned to the subnet.</p>
    pub fn cidr_block(&self) -> std::option::Option<&str> {
        self.cidr_block.as_deref()
    }
    /// <p>Whether this subnet is the default subnet for the Availability Zone.</p>
    pub fn default_for_az(&self) -> bool {
        self.default_for_az
    }
    /// <p>Whether instances in this subnet receive a public IP address.</p>
    pub fn map_public_ip_on_launch(&self) -> bool {
        self.map_public_ip_on_launch
    }
    /// <p>The identifier of the Amazon Web Services account that owns the subnet.</p>
    pub fn owner_id(&self) -> std::option::Option<&str> {
        self.owner_id.as_deref()
    }
    /// <p>The current state of the subnet.</p>
    pub fn state(&self) -> std::option::Option<&str> {
        self.state.as_deref()
    }
    /// <p>The ARN of the subnet.</p>
    pub fn subnet_arn(&self) -> std::option::Option<&str> {
        self.subnet_arn.as_deref()
    }
    /// <p>The identifier of the subnet.</p>
    pub fn subnet_id(&self) -> std::option::Option<&str> {
        self.subnet_id.as_deref()
    }
    /// <p>The identifier of the VPC that contains the subnet.</p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
    /// <p>The IPV6 CIDR blocks that are associated with the subnet.</p>
    pub fn ipv6_cidr_block_association_set(
        &self,
    ) -> std::option::Option<&[crate::model::Ipv6CidrBlockAssociation]> {
        self.ipv6_cidr_block_association_set.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2SubnetDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2SubnetDetails");
        formatter.field(
            "assign_ipv6_address_on_creation",
            &self.assign_ipv6_address_on_creation,
        );
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("availability_zone_id", &self.availability_zone_id);
        formatter.field(
            "available_ip_address_count",
            &self.available_ip_address_count,
        );
        formatter.field("cidr_block", &self.cidr_block);
        formatter.field("default_for_az", &self.default_for_az);
        formatter.field("map_public_ip_on_launch", &self.map_public_ip_on_launch);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("state", &self.state);
        formatter.field("subnet_arn", &self.subnet_arn);
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field(
            "ipv6_cidr_block_association_set",
            &self.ipv6_cidr_block_association_set,
        );
        formatter.finish()
    }
}
/// See [`AwsEc2SubnetDetails`](crate::model::AwsEc2SubnetDetails)
pub mod aws_ec2_subnet_details {

    /// A builder for [`AwsEc2SubnetDetails`](crate::model::AwsEc2SubnetDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assign_ipv6_address_on_creation: std::option::Option<bool>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) availability_zone_id: std::option::Option<std::string::String>,
        pub(crate) available_ip_address_count: std::option::Option<i32>,
        pub(crate) cidr_block: std::option::Option<std::string::String>,
        pub(crate) default_for_az: std::option::Option<bool>,
        pub(crate) map_public_ip_on_launch: std::option::Option<bool>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<std::string::String>,
        pub(crate) subnet_arn: std::option::Option<std::string::String>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) ipv6_cidr_block_association_set:
            std::option::Option<std::vec::Vec<crate::model::Ipv6CidrBlockAssociation>>,
    }
    impl Builder {
        /// <p>Whether to assign an IPV6 address to a network interface that is created in this subnet.</p>
        pub fn assign_ipv6_address_on_creation(mut self, input: bool) -> Self {
            self.assign_ipv6_address_on_creation = Some(input);
            self
        }
        /// <p>Whether to assign an IPV6 address to a network interface that is created in this subnet.</p>
        pub fn set_assign_ipv6_address_on_creation(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.assign_ipv6_address_on_creation = input;
            self
        }
        /// <p>The Availability Zone for the subnet.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        /// <p>The Availability Zone for the subnet.</p>
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The identifier of the Availability Zone for the subnet.</p>
        pub fn availability_zone_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Availability Zone for the subnet.</p>
        pub fn set_availability_zone_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone_id = input;
            self
        }
        /// <p>The number of available IPV4 addresses in the subnet. Does not include addresses for stopped instances.</p>
        pub fn available_ip_address_count(mut self, input: i32) -> Self {
            self.available_ip_address_count = Some(input);
            self
        }
        /// <p>The number of available IPV4 addresses in the subnet. Does not include addresses for stopped instances.</p>
        pub fn set_available_ip_address_count(mut self, input: std::option::Option<i32>) -> Self {
            self.available_ip_address_count = input;
            self
        }
        /// <p>The IPV4 CIDR block that is assigned to the subnet.</p>
        pub fn cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr_block = Some(input.into());
            self
        }
        /// <p>The IPV4 CIDR block that is assigned to the subnet.</p>
        pub fn set_cidr_block(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr_block = input;
            self
        }
        /// <p>Whether this subnet is the default subnet for the Availability Zone.</p>
        pub fn default_for_az(mut self, input: bool) -> Self {
            self.default_for_az = Some(input);
            self
        }
        /// <p>Whether this subnet is the default subnet for the Availability Zone.</p>
        pub fn set_default_for_az(mut self, input: std::option::Option<bool>) -> Self {
            self.default_for_az = input;
            self
        }
        /// <p>Whether instances in this subnet receive a public IP address.</p>
        pub fn map_public_ip_on_launch(mut self, input: bool) -> Self {
            self.map_public_ip_on_launch = Some(input);
            self
        }
        /// <p>Whether instances in this subnet receive a public IP address.</p>
        pub fn set_map_public_ip_on_launch(mut self, input: std::option::Option<bool>) -> Self {
            self.map_public_ip_on_launch = input;
            self
        }
        /// <p>The identifier of the Amazon Web Services account that owns the subnet.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Web Services account that owns the subnet.</p>
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The current state of the subnet.</p>
        pub fn state(mut self, input: impl Into<std::string::String>) -> Self {
            self.state = Some(input.into());
            self
        }
        /// <p>The current state of the subnet.</p>
        pub fn set_state(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.state = input;
            self
        }
        /// <p>The ARN of the subnet.</p>
        pub fn subnet_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the subnet.</p>
        pub fn set_subnet_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_arn = input;
            self
        }
        /// <p>The identifier of the subnet.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        /// <p>The identifier of the subnet.</p>
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>The identifier of the VPC that contains the subnet.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The identifier of the VPC that contains the subnet.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Appends an item to `ipv6_cidr_block_association_set`.
        ///
        /// To override the contents of this collection use [`set_ipv6_cidr_block_association_set`](Self::set_ipv6_cidr_block_association_set).
        ///
        /// <p>The IPV6 CIDR blocks that are associated with the subnet.</p>
        pub fn ipv6_cidr_block_association_set(
            mut self,
            input: crate::model::Ipv6CidrBlockAssociation,
        ) -> Self {
            let mut v = self.ipv6_cidr_block_association_set.unwrap_or_default();
            v.push(input);
            self.ipv6_cidr_block_association_set = Some(v);
            self
        }
        /// <p>The IPV6 CIDR blocks that are associated with the subnet.</p>
        pub fn set_ipv6_cidr_block_association_set(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Ipv6CidrBlockAssociation>>,
        ) -> Self {
            self.ipv6_cidr_block_association_set = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2SubnetDetails`](crate::model::AwsEc2SubnetDetails)
        pub fn build(self) -> crate::model::AwsEc2SubnetDetails {
            crate::model::AwsEc2SubnetDetails {
                assign_ipv6_address_on_creation: self
                    .assign_ipv6_address_on_creation
                    .unwrap_or_default(),
                availability_zone: self.availability_zone,
                availability_zone_id: self.availability_zone_id,
                available_ip_address_count: self.available_ip_address_count.unwrap_or_default(),
                cidr_block: self.cidr_block,
                default_for_az: self.default_for_az.unwrap_or_default(),
                map_public_ip_on_launch: self.map_public_ip_on_launch.unwrap_or_default(),
                owner_id: self.owner_id,
                state: self.state,
                subnet_arn: self.subnet_arn,
                subnet_id: self.subnet_id,
                vpc_id: self.vpc_id,
                ipv6_cidr_block_association_set: self.ipv6_cidr_block_association_set,
            }
        }
    }
}
impl AwsEc2SubnetDetails {
    /// Creates a new builder-style object to manufacture [`AwsEc2SubnetDetails`](crate::model::AwsEc2SubnetDetails)
    pub fn builder() -> crate::model::aws_ec2_subnet_details::Builder {
        crate::model::aws_ec2_subnet_details::Builder::default()
    }
}

/// <p>An IPV6 CIDR block association.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Ipv6CidrBlockAssociation {
    /// <p>The association ID for the IPv6 CIDR block.</p>
    pub association_id: std::option::Option<std::string::String>,
    /// <p>The IPv6 CIDR block.</p>
    pub ipv6_cidr_block: std::option::Option<std::string::String>,
    /// <p>Information about the state of the CIDR block.</p>
    pub cidr_block_state: std::option::Option<std::string::String>,
}
impl Ipv6CidrBlockAssociation {
    /// <p>The association ID for the IPv6 CIDR block.</p>
    pub fn association_id(&self) -> std::option::Option<&str> {
        self.association_id.as_deref()
    }
    /// <p>The IPv6 CIDR block.</p>
    pub fn ipv6_cidr_block(&self) -> std::option::Option<&str> {
        self.ipv6_cidr_block.as_deref()
    }
    /// <p>Information about the state of the CIDR block.</p>
    pub fn cidr_block_state(&self) -> std::option::Option<&str> {
        self.cidr_block_state.as_deref()
    }
}
impl std::fmt::Debug for Ipv6CidrBlockAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Ipv6CidrBlockAssociation");
        formatter.field("association_id", &self.association_id);
        formatter.field("ipv6_cidr_block", &self.ipv6_cidr_block);
        formatter.field("cidr_block_state", &self.cidr_block_state);
        formatter.finish()
    }
}
/// See [`Ipv6CidrBlockAssociation`](crate::model::Ipv6CidrBlockAssociation)
pub mod ipv6_cidr_block_association {

    /// A builder for [`Ipv6CidrBlockAssociation`](crate::model::Ipv6CidrBlockAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) ipv6_cidr_block: std::option::Option<std::string::String>,
        pub(crate) cidr_block_state: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The association ID for the IPv6 CIDR block.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        /// <p>The association ID for the IPv6 CIDR block.</p>
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>The IPv6 CIDR block.</p>
        pub fn ipv6_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.ipv6_cidr_block = Some(input.into());
            self
        }
        /// <p>The IPv6 CIDR block.</p>
        pub fn set_ipv6_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ipv6_cidr_block = input;
            self
        }
        /// <p>Information about the state of the CIDR block.</p>
        pub fn cidr_block_state(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr_block_state = Some(input.into());
            self
        }
        /// <p>Information about the state of the CIDR block.</p>
        pub fn set_cidr_block_state(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cidr_block_state = input;
            self
        }
        /// Consumes the builder and constructs a [`Ipv6CidrBlockAssociation`](crate::model::Ipv6CidrBlockAssociation)
        pub fn build(self) -> crate::model::Ipv6CidrBlockAssociation {
            crate::model::Ipv6CidrBlockAssociation {
                association_id: self.association_id,
                ipv6_cidr_block: self.ipv6_cidr_block,
                cidr_block_state: self.cidr_block_state,
            }
        }
    }
}
impl Ipv6CidrBlockAssociation {
    /// Creates a new builder-style object to manufacture [`Ipv6CidrBlockAssociation`](crate::model::Ipv6CidrBlockAssociation)
    pub fn builder() -> crate::model::ipv6_cidr_block_association::Builder {
        crate::model::ipv6_cidr_block_association::Builder::default()
    }
}

/// <p>Information about an Elastic IP address.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2EipDetails {
    /// <p>The identifier of the EC2 instance.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>A public IP address that is associated with the EC2 instance.</p>
    pub public_ip: std::option::Option<std::string::String>,
    /// <p>The identifier that Amazon Web Services assigns to represent the allocation of the Elastic IP address for use with Amazon VPC.</p>
    pub allocation_id: std::option::Option<std::string::String>,
    /// <p>The identifier that represents the association of the Elastic IP address with an EC2 instance.</p>
    pub association_id: std::option::Option<std::string::String>,
    /// <p>The domain in which to allocate the address.</p>
    /// <p>If the address is for use with EC2 instances in a VPC, then <code>Domain</code> is <code>vpc</code>. Otherwise, <code>Domain</code> is <code>standard</code>. </p>
    pub domain: std::option::Option<std::string::String>,
    /// <p>The identifier of an IP address pool. This parameter allows Amazon EC2 to select an IP address from the address pool.</p>
    pub public_ipv4_pool: std::option::Option<std::string::String>,
    /// <p>The name of the location from which the Elastic IP address is advertised.</p>
    pub network_border_group: std::option::Option<std::string::String>,
    /// <p>The identifier of the network interface.</p>
    pub network_interface_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID of the owner of the network interface.</p>
    pub network_interface_owner_id: std::option::Option<std::string::String>,
    /// <p>The private IP address that is associated with the Elastic IP address.</p>
    pub private_ip_address: std::option::Option<std::string::String>,
}
impl AwsEc2EipDetails {
    /// <p>The identifier of the EC2 instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>A public IP address that is associated with the EC2 instance.</p>
    pub fn public_ip(&self) -> std::option::Option<&str> {
        self.public_ip.as_deref()
    }
    /// <p>The identifier that Amazon Web Services assigns to represent the allocation of the Elastic IP address for use with Amazon VPC.</p>
    pub fn allocation_id(&self) -> std::option::Option<&str> {
        self.allocation_id.as_deref()
    }
    /// <p>The identifier that represents the association of the Elastic IP address with an EC2 instance.</p>
    pub fn association_id(&self) -> std::option::Option<&str> {
        self.association_id.as_deref()
    }
    /// <p>The domain in which to allocate the address.</p>
    /// <p>If the address is for use with EC2 instances in a VPC, then <code>Domain</code> is <code>vpc</code>. Otherwise, <code>Domain</code> is <code>standard</code>. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p>The identifier of an IP address pool. This parameter allows Amazon EC2 to select an IP address from the address pool.</p>
    pub fn public_ipv4_pool(&self) -> std::option::Option<&str> {
        self.public_ipv4_pool.as_deref()
    }
    /// <p>The name of the location from which the Elastic IP address is advertised.</p>
    pub fn network_border_group(&self) -> std::option::Option<&str> {
        self.network_border_group.as_deref()
    }
    /// <p>The identifier of the network interface.</p>
    pub fn network_interface_id(&self) -> std::option::Option<&str> {
        self.network_interface_id.as_deref()
    }
    /// <p>The Amazon Web Services account ID of the owner of the network interface.</p>
    pub fn network_interface_owner_id(&self) -> std::option::Option<&str> {
        self.network_interface_owner_id.as_deref()
    }
    /// <p>The private IP address that is associated with the Elastic IP address.</p>
    pub fn private_ip_address(&self) -> std::option::Option<&str> {
        self.private_ip_address.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2EipDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2EipDetails");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("public_ip", &self.public_ip);
        formatter.field("allocation_id", &self.allocation_id);
        formatter.field("association_id", &self.association_id);
        formatter.field("domain", &self.domain);
        formatter.field("public_ipv4_pool", &self.public_ipv4_pool);
        formatter.field("network_border_group", &self.network_border_group);
        formatter.field("network_interface_id", &self.network_interface_id);
        formatter.field(
            "network_interface_owner_id",
            &self.network_interface_owner_id,
        );
        formatter.field("private_ip_address", &self.private_ip_address);
        formatter.finish()
    }
}
/// See [`AwsEc2EipDetails`](crate::model::AwsEc2EipDetails)
pub mod aws_ec2_eip_details {

    /// A builder for [`AwsEc2EipDetails`](crate::model::AwsEc2EipDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) public_ip: std::option::Option<std::string::String>,
        pub(crate) allocation_id: std::option::Option<std::string::String>,
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) public_ipv4_pool: std::option::Option<std::string::String>,
        pub(crate) network_border_group: std::option::Option<std::string::String>,
        pub(crate) network_interface_id: std::option::Option<std::string::String>,
        pub(crate) network_interface_owner_id: std::option::Option<std::string::String>,
        pub(crate) private_ip_address: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the EC2 instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the EC2 instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>A public IP address that is associated with the EC2 instance.</p>
        pub fn public_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.public_ip = Some(input.into());
            self
        }
        /// <p>A public IP address that is associated with the EC2 instance.</p>
        pub fn set_public_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.public_ip = input;
            self
        }
        /// <p>The identifier that Amazon Web Services assigns to represent the allocation of the Elastic IP address for use with Amazon VPC.</p>
        pub fn allocation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.allocation_id = Some(input.into());
            self
        }
        /// <p>The identifier that Amazon Web Services assigns to represent the allocation of the Elastic IP address for use with Amazon VPC.</p>
        pub fn set_allocation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.allocation_id = input;
            self
        }
        /// <p>The identifier that represents the association of the Elastic IP address with an EC2 instance.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        /// <p>The identifier that represents the association of the Elastic IP address with an EC2 instance.</p>
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>The domain in which to allocate the address.</p>
        /// <p>If the address is for use with EC2 instances in a VPC, then <code>Domain</code> is <code>vpc</code>. Otherwise, <code>Domain</code> is <code>standard</code>. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p>The domain in which to allocate the address.</p>
        /// <p>If the address is for use with EC2 instances in a VPC, then <code>Domain</code> is <code>vpc</code>. Otherwise, <code>Domain</code> is <code>standard</code>. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p>The identifier of an IP address pool. This parameter allows Amazon EC2 to select an IP address from the address pool.</p>
        pub fn public_ipv4_pool(mut self, input: impl Into<std::string::String>) -> Self {
            self.public_ipv4_pool = Some(input.into());
            self
        }
        /// <p>The identifier of an IP address pool. This parameter allows Amazon EC2 to select an IP address from the address pool.</p>
        pub fn set_public_ipv4_pool(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.public_ipv4_pool = input;
            self
        }
        /// <p>The name of the location from which the Elastic IP address is advertised.</p>
        pub fn network_border_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_border_group = Some(input.into());
            self
        }
        /// <p>The name of the location from which the Elastic IP address is advertised.</p>
        pub fn set_network_border_group(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_border_group = input;
            self
        }
        /// <p>The identifier of the network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_interface_id = Some(input.into());
            self
        }
        /// <p>The identifier of the network interface.</p>
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_interface_id = input;
            self
        }
        /// <p>The Amazon Web Services account ID of the owner of the network interface.</p>
        pub fn network_interface_owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_interface_owner_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID of the owner of the network interface.</p>
        pub fn set_network_interface_owner_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_interface_owner_id = input;
            self
        }
        /// <p>The private IP address that is associated with the Elastic IP address.</p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_ip_address = Some(input.into());
            self
        }
        /// <p>The private IP address that is associated with the Elastic IP address.</p>
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_ip_address = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2EipDetails`](crate::model::AwsEc2EipDetails)
        pub fn build(self) -> crate::model::AwsEc2EipDetails {
            crate::model::AwsEc2EipDetails {
                instance_id: self.instance_id,
                public_ip: self.public_ip,
                allocation_id: self.allocation_id,
                association_id: self.association_id,
                domain: self.domain,
                public_ipv4_pool: self.public_ipv4_pool,
                network_border_group: self.network_border_group,
                network_interface_id: self.network_interface_id,
                network_interface_owner_id: self.network_interface_owner_id,
                private_ip_address: self.private_ip_address,
            }
        }
    }
}
impl AwsEc2EipDetails {
    /// Creates a new builder-style object to manufacture [`AwsEc2EipDetails`](crate::model::AwsEc2EipDetails)
    pub fn builder() -> crate::model::aws_ec2_eip_details::Builder {
        crate::model::aws_ec2_eip_details::Builder::default()
    }
}

/// <p>Details about an EC2 VPC.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2VpcDetails {
    /// <p>Information about the IPv4 CIDR blocks associated with the VPC.</p>
    pub cidr_block_association_set:
        std::option::Option<std::vec::Vec<crate::model::CidrBlockAssociation>>,
    /// <p>Information about the IPv6 CIDR blocks associated with the VPC.</p>
    pub ipv6_cidr_block_association_set:
        std::option::Option<std::vec::Vec<crate::model::Ipv6CidrBlockAssociation>>,
    /// <p>The identifier of the set of Dynamic Host Configuration Protocol (DHCP) options that are associated with the VPC. If the default options are associated with the VPC, then this is default.</p>
    pub dhcp_options_id: std::option::Option<std::string::String>,
    /// <p>The current state of the VPC.</p>
    pub state: std::option::Option<std::string::String>,
}
impl AwsEc2VpcDetails {
    /// <p>Information about the IPv4 CIDR blocks associated with the VPC.</p>
    pub fn cidr_block_association_set(
        &self,
    ) -> std::option::Option<&[crate::model::CidrBlockAssociation]> {
        self.cidr_block_association_set.as_deref()
    }
    /// <p>Information about the IPv6 CIDR blocks associated with the VPC.</p>
    pub fn ipv6_cidr_block_association_set(
        &self,
    ) -> std::option::Option<&[crate::model::Ipv6CidrBlockAssociation]> {
        self.ipv6_cidr_block_association_set.as_deref()
    }
    /// <p>The identifier of the set of Dynamic Host Configuration Protocol (DHCP) options that are associated with the VPC. If the default options are associated with the VPC, then this is default.</p>
    pub fn dhcp_options_id(&self) -> std::option::Option<&str> {
        self.dhcp_options_id.as_deref()
    }
    /// <p>The current state of the VPC.</p>
    pub fn state(&self) -> std::option::Option<&str> {
        self.state.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2VpcDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2VpcDetails");
        formatter.field(
            "cidr_block_association_set",
            &self.cidr_block_association_set,
        );
        formatter.field(
            "ipv6_cidr_block_association_set",
            &self.ipv6_cidr_block_association_set,
        );
        formatter.field("dhcp_options_id", &self.dhcp_options_id);
        formatter.field("state", &self.state);
        formatter.finish()
    }
}
/// See [`AwsEc2VpcDetails`](crate::model::AwsEc2VpcDetails)
pub mod aws_ec2_vpc_details {

    /// A builder for [`AwsEc2VpcDetails`](crate::model::AwsEc2VpcDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cidr_block_association_set:
            std::option::Option<std::vec::Vec<crate::model::CidrBlockAssociation>>,
        pub(crate) ipv6_cidr_block_association_set:
            std::option::Option<std::vec::Vec<crate::model::Ipv6CidrBlockAssociation>>,
        pub(crate) dhcp_options_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `cidr_block_association_set`.
        ///
        /// To override the contents of this collection use [`set_cidr_block_association_set`](Self::set_cidr_block_association_set).
        ///
        /// <p>Information about the IPv4 CIDR blocks associated with the VPC.</p>
        pub fn cidr_block_association_set(
            mut self,
            input: crate::model::CidrBlockAssociation,
        ) -> Self {
            let mut v = self.cidr_block_association_set.unwrap_or_default();
            v.push(input);
            self.cidr_block_association_set = Some(v);
            self
        }
        /// <p>Information about the IPv4 CIDR blocks associated with the VPC.</p>
        pub fn set_cidr_block_association_set(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CidrBlockAssociation>>,
        ) -> Self {
            self.cidr_block_association_set = input;
            self
        }
        /// Appends an item to `ipv6_cidr_block_association_set`.
        ///
        /// To override the contents of this collection use [`set_ipv6_cidr_block_association_set`](Self::set_ipv6_cidr_block_association_set).
        ///
        /// <p>Information about the IPv6 CIDR blocks associated with the VPC.</p>
        pub fn ipv6_cidr_block_association_set(
            mut self,
            input: crate::model::Ipv6CidrBlockAssociation,
        ) -> Self {
            let mut v = self.ipv6_cidr_block_association_set.unwrap_or_default();
            v.push(input);
            self.ipv6_cidr_block_association_set = Some(v);
            self
        }
        /// <p>Information about the IPv6 CIDR blocks associated with the VPC.</p>
        pub fn set_ipv6_cidr_block_association_set(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Ipv6CidrBlockAssociation>>,
        ) -> Self {
            self.ipv6_cidr_block_association_set = input;
            self
        }
        /// <p>The identifier of the set of Dynamic Host Configuration Protocol (DHCP) options that are associated with the VPC. If the default options are associated with the VPC, then this is default.</p>
        pub fn dhcp_options_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.dhcp_options_id = Some(input.into());
            self
        }
        /// <p>The identifier of the set of Dynamic Host Configuration Protocol (DHCP) options that are associated with the VPC. If the default options are associated with the VPC, then this is default.</p>
        pub fn set_dhcp_options_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dhcp_options_id = input;
            self
        }
        /// <p>The current state of the VPC.</p>
        pub fn state(mut self, input: impl Into<std::string::String>) -> Self {
            self.state = Some(input.into());
            self
        }
        /// <p>The current state of the VPC.</p>
        pub fn set_state(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2VpcDetails`](crate::model::AwsEc2VpcDetails)
        pub fn build(self) -> crate::model::AwsEc2VpcDetails {
            crate::model::AwsEc2VpcDetails {
                cidr_block_association_set: self.cidr_block_association_set,
                ipv6_cidr_block_association_set: self.ipv6_cidr_block_association_set,
                dhcp_options_id: self.dhcp_options_id,
                state: self.state,
            }
        }
    }
}
impl AwsEc2VpcDetails {
    /// Creates a new builder-style object to manufacture [`AwsEc2VpcDetails`](crate::model::AwsEc2VpcDetails)
    pub fn builder() -> crate::model::aws_ec2_vpc_details::Builder {
        crate::model::aws_ec2_vpc_details::Builder::default()
    }
}

/// <p>An IPv4 CIDR block association.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CidrBlockAssociation {
    /// <p>The association ID for the IPv4 CIDR block.</p>
    pub association_id: std::option::Option<std::string::String>,
    /// <p>The IPv4 CIDR block.</p>
    pub cidr_block: std::option::Option<std::string::String>,
    /// <p>Information about the state of the IPv4 CIDR block.</p>
    pub cidr_block_state: std::option::Option<std::string::String>,
}
impl CidrBlockAssociation {
    /// <p>The association ID for the IPv4 CIDR block.</p>
    pub fn association_id(&self) -> std::option::Option<&str> {
        self.association_id.as_deref()
    }
    /// <p>The IPv4 CIDR block.</p>
    pub fn cidr_block(&self) -> std::option::Option<&str> {
        self.cidr_block.as_deref()
    }
    /// <p>Information about the state of the IPv4 CIDR block.</p>
    pub fn cidr_block_state(&self) -> std::option::Option<&str> {
        self.cidr_block_state.as_deref()
    }
}
impl std::fmt::Debug for CidrBlockAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CidrBlockAssociation");
        formatter.field("association_id", &self.association_id);
        formatter.field("cidr_block", &self.cidr_block);
        formatter.field("cidr_block_state", &self.cidr_block_state);
        formatter.finish()
    }
}
/// See [`CidrBlockAssociation`](crate::model::CidrBlockAssociation)
pub mod cidr_block_association {

    /// A builder for [`CidrBlockAssociation`](crate::model::CidrBlockAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) cidr_block: std::option::Option<std::string::String>,
        pub(crate) cidr_block_state: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The association ID for the IPv4 CIDR block.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        /// <p>The association ID for the IPv4 CIDR block.</p>
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>The IPv4 CIDR block.</p>
        pub fn cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr_block = Some(input.into());
            self
        }
        /// <p>The IPv4 CIDR block.</p>
        pub fn set_cidr_block(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr_block = input;
            self
        }
        /// <p>Information about the state of the IPv4 CIDR block.</p>
        pub fn cidr_block_state(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr_block_state = Some(input.into());
            self
        }
        /// <p>Information about the state of the IPv4 CIDR block.</p>
        pub fn set_cidr_block_state(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cidr_block_state = input;
            self
        }
        /// Consumes the builder and constructs a [`CidrBlockAssociation`](crate::model::CidrBlockAssociation)
        pub fn build(self) -> crate::model::CidrBlockAssociation {
            crate::model::CidrBlockAssociation {
                association_id: self.association_id,
                cidr_block: self.cidr_block,
                cidr_block_state: self.cidr_block_state,
            }
        }
    }
}
impl CidrBlockAssociation {
    /// Creates a new builder-style object to manufacture [`CidrBlockAssociation`](crate::model::CidrBlockAssociation)
    pub fn builder() -> crate::model::cidr_block_association::Builder {
        crate::model::cidr_block_association::Builder::default()
    }
}

/// <p>Details about an EC2 volume.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2VolumeDetails {
    /// <p>Indicates when the volume was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub create_time: std::option::Option<std::string::String>,
    /// <p>The device name for the volume that is attached to the instance. </p>
    pub device_name: std::option::Option<std::string::String>,
    /// <p>Specifies whether the volume is encrypted.</p>
    pub encrypted: bool,
    /// <p>The size of the volume, in GiBs.</p>
    pub size: i32,
    /// <p>The snapshot from which the volume was created.</p>
    pub snapshot_id: std::option::Option<std::string::String>,
    /// <p>The volume state.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>The ARN of the KMS key that was used to protect the volume encryption key for the volume.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The volume attachments.</p>
    pub attachments: std::option::Option<std::vec::Vec<crate::model::AwsEc2VolumeAttachment>>,
    /// <p>The ID of the volume. </p>
    pub volume_id: std::option::Option<std::string::String>,
    /// <p>The volume type. </p>
    pub volume_type: std::option::Option<std::string::String>,
    /// <p>Indicates whether the volume was scanned or skipped. </p>
    pub volume_scan_status: std::option::Option<std::string::String>,
}
impl AwsEc2VolumeDetails {
    /// <p>Indicates when the volume was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn create_time(&self) -> std::option::Option<&str> {
        self.create_time.as_deref()
    }
    /// <p>The device name for the volume that is attached to the instance. </p>
    pub fn device_name(&self) -> std::option::Option<&str> {
        self.device_name.as_deref()
    }
    /// <p>Specifies whether the volume is encrypted.</p>
    pub fn encrypted(&self) -> bool {
        self.encrypted
    }
    /// <p>The size of the volume, in GiBs.</p>
    pub fn size(&self) -> i32 {
        self.size
    }
    /// <p>The snapshot from which the volume was created.</p>
    pub fn snapshot_id(&self) -> std::option::Option<&str> {
        self.snapshot_id.as_deref()
    }
    /// <p>The volume state.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>The ARN of the KMS key that was used to protect the volume encryption key for the volume.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>The volume attachments.</p>
    pub fn attachments(&self) -> std::option::Option<&[crate::model::AwsEc2VolumeAttachment]> {
        self.attachments.as_deref()
    }
    /// <p>The ID of the volume. </p>
    pub fn volume_id(&self) -> std::option::Option<&str> {
        self.volume_id.as_deref()
    }
    /// <p>The volume type. </p>
    pub fn volume_type(&self) -> std::option::Option<&str> {
        self.volume_type.as_deref()
    }
    /// <p>Indicates whether the volume was scanned or skipped. </p>
    pub fn volume_scan_status(&self) -> std::option::Option<&str> {
        self.volume_scan_status.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2VolumeDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2VolumeDetails");
        formatter.field("create_time", &self.create_time);
        formatter.field("device_name", &self.device_name);
        formatter.field("encrypted", &self.encrypted);
        formatter.field("size", &self.size);
        formatter.field("snapshot_id", &self.snapshot_id);
        formatter.field("status", &self.status);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("attachments", &self.attachments);
        formatter.field("volume_id", &self.volume_id);
        formatter.field("volume_type", &self.volume_type);
        formatter.field("volume_scan_status", &self.volume_scan_status);
        formatter.finish()
    }
}
/// See [`AwsEc2VolumeDetails`](crate::model::AwsEc2VolumeDetails)
pub mod aws_ec2_volume_details {

    /// A builder for [`AwsEc2VolumeDetails`](crate::model::AwsEc2VolumeDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) create_time: std::option::Option<std::string::String>,
        pub(crate) device_name: std::option::Option<std::string::String>,
        pub(crate) encrypted: std::option::Option<bool>,
        pub(crate) size: std::option::Option<i32>,
        pub(crate) snapshot_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) attachments:
            std::option::Option<std::vec::Vec<crate::model::AwsEc2VolumeAttachment>>,
        pub(crate) volume_id: std::option::Option<std::string::String>,
        pub(crate) volume_type: std::option::Option<std::string::String>,
        pub(crate) volume_scan_status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates when the volume was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn create_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.create_time = Some(input.into());
            self
        }
        /// <p>Indicates when the volume was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_create_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The device name for the volume that is attached to the instance. </p>
        pub fn device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_name = Some(input.into());
            self
        }
        /// <p>The device name for the volume that is attached to the instance. </p>
        pub fn set_device_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_name = input;
            self
        }
        /// <p>Specifies whether the volume is encrypted.</p>
        pub fn encrypted(mut self, input: bool) -> Self {
            self.encrypted = Some(input);
            self
        }
        /// <p>Specifies whether the volume is encrypted.</p>
        pub fn set_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.encrypted = input;
            self
        }
        /// <p>The size of the volume, in GiBs.</p>
        pub fn size(mut self, input: i32) -> Self {
            self.size = Some(input);
            self
        }
        /// <p>The size of the volume, in GiBs.</p>
        pub fn set_size(mut self, input: std::option::Option<i32>) -> Self {
            self.size = input;
            self
        }
        /// <p>The snapshot from which the volume was created.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_id = Some(input.into());
            self
        }
        /// <p>The snapshot from which the volume was created.</p>
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.snapshot_id = input;
            self
        }
        /// <p>The volume state.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The volume state.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>The ARN of the KMS key that was used to protect the volume encryption key for the volume.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The ARN of the KMS key that was used to protect the volume encryption key for the volume.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Appends an item to `attachments`.
        ///
        /// To override the contents of this collection use [`set_attachments`](Self::set_attachments).
        ///
        /// <p>The volume attachments.</p>
        pub fn attachments(mut self, input: crate::model::AwsEc2VolumeAttachment) -> Self {
            let mut v = self.attachments.unwrap_or_default();
            v.push(input);
            self.attachments = Some(v);
            self
        }
        /// <p>The volume attachments.</p>
        pub fn set_attachments(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsEc2VolumeAttachment>>,
        ) -> Self {
            self.attachments = input;
            self
        }
        /// <p>The ID of the volume. </p>
        pub fn volume_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_id = Some(input.into());
            self
        }
        /// <p>The ID of the volume. </p>
        pub fn set_volume_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.volume_id = input;
            self
        }
        /// <p>The volume type. </p>
        pub fn volume_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_type = Some(input.into());
            self
        }
        /// <p>The volume type. </p>
        pub fn set_volume_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.volume_type = input;
            self
        }
        /// <p>Indicates whether the volume was scanned or skipped. </p>
        pub fn volume_scan_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_scan_status = Some(input.into());
            self
        }
        /// <p>Indicates whether the volume was scanned or skipped. </p>
        pub fn set_volume_scan_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.volume_scan_status = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2VolumeDetails`](crate::model::AwsEc2VolumeDetails)
        pub fn build(self) -> crate::model::AwsEc2VolumeDetails {
            crate::model::AwsEc2VolumeDetails {
                create_time: self.create_time,
                device_name: self.device_name,
                encrypted: self.encrypted.unwrap_or_default(),
                size: self.size.unwrap_or_default(),
                snapshot_id: self.snapshot_id,
                status: self.status,
                kms_key_id: self.kms_key_id,
                attachments: self.attachments,
                volume_id: self.volume_id,
                volume_type: self.volume_type,
                volume_scan_status: self.volume_scan_status,
            }
        }
    }
}
impl AwsEc2VolumeDetails {
    /// Creates a new builder-style object to manufacture [`AwsEc2VolumeDetails`](crate::model::AwsEc2VolumeDetails)
    pub fn builder() -> crate::model::aws_ec2_volume_details::Builder {
        crate::model::aws_ec2_volume_details::Builder::default()
    }
}

/// <p>An attachment to an Amazon EC2 volume.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2VolumeAttachment {
    /// <p>The datetime when the attachment initiated.</p>
    pub attach_time: std::option::Option<std::string::String>,
    /// <p>Whether the EBS volume is deleted when the EC2 instance is terminated.</p>
    pub delete_on_termination: bool,
    /// <p>The identifier of the EC2 instance.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The attachment state of the volume.</p>
    pub status: std::option::Option<std::string::String>,
}
impl AwsEc2VolumeAttachment {
    /// <p>The datetime when the attachment initiated.</p>
    pub fn attach_time(&self) -> std::option::Option<&str> {
        self.attach_time.as_deref()
    }
    /// <p>Whether the EBS volume is deleted when the EC2 instance is terminated.</p>
    pub fn delete_on_termination(&self) -> bool {
        self.delete_on_termination
    }
    /// <p>The identifier of the EC2 instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The attachment state of the volume.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2VolumeAttachment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2VolumeAttachment");
        formatter.field("attach_time", &self.attach_time);
        formatter.field("delete_on_termination", &self.delete_on_termination);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`AwsEc2VolumeAttachment`](crate::model::AwsEc2VolumeAttachment)
pub mod aws_ec2_volume_attachment {

    /// A builder for [`AwsEc2VolumeAttachment`](crate::model::AwsEc2VolumeAttachment)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attach_time: std::option::Option<std::string::String>,
        pub(crate) delete_on_termination: std::option::Option<bool>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The datetime when the attachment initiated.</p>
        pub fn attach_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.attach_time = Some(input.into());
            self
        }
        /// <p>The datetime when the attachment initiated.</p>
        pub fn set_attach_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.attach_time = input;
            self
        }
        /// <p>Whether the EBS volume is deleted when the EC2 instance is terminated.</p>
        pub fn delete_on_termination(mut self, input: bool) -> Self {
            self.delete_on_termination = Some(input);
            self
        }
        /// <p>Whether the EBS volume is deleted when the EC2 instance is terminated.</p>
        pub fn set_delete_on_termination(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_on_termination = input;
            self
        }
        /// <p>The identifier of the EC2 instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The identifier of the EC2 instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The attachment state of the volume.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The attachment state of the volume.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2VolumeAttachment`](crate::model::AwsEc2VolumeAttachment)
        pub fn build(self) -> crate::model::AwsEc2VolumeAttachment {
            crate::model::AwsEc2VolumeAttachment {
                attach_time: self.attach_time,
                delete_on_termination: self.delete_on_termination.unwrap_or_default(),
                instance_id: self.instance_id,
                status: self.status,
            }
        }
    }
}
impl AwsEc2VolumeAttachment {
    /// Creates a new builder-style object to manufacture [`AwsEc2VolumeAttachment`](crate::model::AwsEc2VolumeAttachment)
    pub fn builder() -> crate::model::aws_ec2_volume_attachment::Builder {
        crate::model::aws_ec2_volume_attachment::Builder::default()
    }
}

/// <p>Details about an Amazon EC2 security group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2SecurityGroupDetails {
    /// <p>The name of the security group.</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The ID of the security group.</p>
    pub group_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID of the owner of the security group.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>[VPC only] The ID of the VPC for the security group.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The inbound rules associated with the security group.</p>
    pub ip_permissions:
        std::option::Option<std::vec::Vec<crate::model::AwsEc2SecurityGroupIpPermission>>,
    /// <p>[VPC only] The outbound rules associated with the security group.</p>
    pub ip_permissions_egress:
        std::option::Option<std::vec::Vec<crate::model::AwsEc2SecurityGroupIpPermission>>,
}
impl AwsEc2SecurityGroupDetails {
    /// <p>The name of the security group.</p>
    pub fn group_name(&self) -> std::option::Option<&str> {
        self.group_name.as_deref()
    }
    /// <p>The ID of the security group.</p>
    pub fn group_id(&self) -> std::option::Option<&str> {
        self.group_id.as_deref()
    }
    /// <p>The Amazon Web Services account ID of the owner of the security group.</p>
    pub fn owner_id(&self) -> std::option::Option<&str> {
        self.owner_id.as_deref()
    }
    /// <p>[VPC only] The ID of the VPC for the security group.</p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
    /// <p>The inbound rules associated with the security group.</p>
    pub fn ip_permissions(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEc2SecurityGroupIpPermission]> {
        self.ip_permissions.as_deref()
    }
    /// <p>[VPC only] The outbound rules associated with the security group.</p>
    pub fn ip_permissions_egress(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEc2SecurityGroupIpPermission]> {
        self.ip_permissions_egress.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2SecurityGroupDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2SecurityGroupDetails");
        formatter.field("group_name", &self.group_name);
        formatter.field("group_id", &self.group_id);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("ip_permissions", &self.ip_permissions);
        formatter.field("ip_permissions_egress", &self.ip_permissions_egress);
        formatter.finish()
    }
}
/// See [`AwsEc2SecurityGroupDetails`](crate::model::AwsEc2SecurityGroupDetails)
pub mod aws_ec2_security_group_details {

    /// A builder for [`AwsEc2SecurityGroupDetails`](crate::model::AwsEc2SecurityGroupDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) ip_permissions:
            std::option::Option<std::vec::Vec<crate::model::AwsEc2SecurityGroupIpPermission>>,
        pub(crate) ip_permissions_egress:
            std::option::Option<std::vec::Vec<crate::model::AwsEc2SecurityGroupIpPermission>>,
    }
    impl Builder {
        /// <p>The name of the security group.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        /// <p>The name of the security group.</p>
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// <p>The ID of the security group.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// <p>The ID of the security group.</p>
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input;
            self
        }
        /// <p>The Amazon Web Services account ID of the owner of the security group.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID of the owner of the security group.</p>
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>[VPC only] The ID of the VPC for the security group.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>[VPC only] The ID of the VPC for the security group.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Appends an item to `ip_permissions`.
        ///
        /// To override the contents of this collection use [`set_ip_permissions`](Self::set_ip_permissions).
        ///
        /// <p>The inbound rules associated with the security group.</p>
        pub fn ip_permissions(
            mut self,
            input: crate::model::AwsEc2SecurityGroupIpPermission,
        ) -> Self {
            let mut v = self.ip_permissions.unwrap_or_default();
            v.push(input);
            self.ip_permissions = Some(v);
            self
        }
        /// <p>The inbound rules associated with the security group.</p>
        pub fn set_ip_permissions(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEc2SecurityGroupIpPermission>,
            >,
        ) -> Self {
            self.ip_permissions = input;
            self
        }
        /// Appends an item to `ip_permissions_egress`.
        ///
        /// To override the contents of this collection use [`set_ip_permissions_egress`](Self::set_ip_permissions_egress).
        ///
        /// <p>[VPC only] The outbound rules associated with the security group.</p>
        pub fn ip_permissions_egress(
            mut self,
            input: crate::model::AwsEc2SecurityGroupIpPermission,
        ) -> Self {
            let mut v = self.ip_permissions_egress.unwrap_or_default();
            v.push(input);
            self.ip_permissions_egress = Some(v);
            self
        }
        /// <p>[VPC only] The outbound rules associated with the security group.</p>
        pub fn set_ip_permissions_egress(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEc2SecurityGroupIpPermission>,
            >,
        ) -> Self {
            self.ip_permissions_egress = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2SecurityGroupDetails`](crate::model::AwsEc2SecurityGroupDetails)
        pub fn build(self) -> crate::model::AwsEc2SecurityGroupDetails {
            crate::model::AwsEc2SecurityGroupDetails {
                group_name: self.group_name,
                group_id: self.group_id,
                owner_id: self.owner_id,
                vpc_id: self.vpc_id,
                ip_permissions: self.ip_permissions,
                ip_permissions_egress: self.ip_permissions_egress,
            }
        }
    }
}
impl AwsEc2SecurityGroupDetails {
    /// Creates a new builder-style object to manufacture [`AwsEc2SecurityGroupDetails`](crate::model::AwsEc2SecurityGroupDetails)
    pub fn builder() -> crate::model::aws_ec2_security_group_details::Builder {
        crate::model::aws_ec2_security_group_details::Builder::default()
    }
}

/// <p>An IP permission for an EC2 security group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2SecurityGroupIpPermission {
    /// <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>, <code>icmpv6</code>) or number.</p>
    /// <p>[VPC only] Use <code>-1</code> to specify all protocols.</p>
    /// <p>When authorizing security group rules, specifying <code>-1</code> or a protocol number other than <code>tcp</code>, <code>udp</code>, <code>icmp</code>, or <code>icmpv6</code> allows traffic on all ports, regardless of any port range you specify.</p>
    /// <p>For <code>tcp</code>, <code>udp</code>, and <code>icmp</code>, you must specify a port range.</p>
    /// <p>For <code>icmpv6</code>, the port range is optional. If you omit the port range, traffic for all types and codes is allowed. </p>
    pub ip_protocol: std::option::Option<std::string::String>,
    /// <p>The start of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number.</p>
    /// <p>A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes. </p>
    pub from_port: i32,
    /// <p>The end of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code.</p>
    /// <p>A value of <code>-1</code> indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all codes.</p>
    pub to_port: i32,
    /// <p>The security group and Amazon Web Services account ID pairs.</p>
    pub user_id_group_pairs:
        std::option::Option<std::vec::Vec<crate::model::AwsEc2SecurityGroupUserIdGroupPair>>,
    /// <p>The IPv4 ranges.</p>
    pub ip_ranges: std::option::Option<std::vec::Vec<crate::model::AwsEc2SecurityGroupIpRange>>,
    /// <p>The IPv6 ranges.</p>
    pub ipv6_ranges: std::option::Option<std::vec::Vec<crate::model::AwsEc2SecurityGroupIpv6Range>>,
    /// <p>[VPC only] The prefix list IDs for an Amazon Web Services service. With outbound rules, this is the Amazon Web Services service to access through a VPC endpoint from instances associated with the security group.</p>
    pub prefix_list_ids:
        std::option::Option<std::vec::Vec<crate::model::AwsEc2SecurityGroupPrefixListId>>,
}
impl AwsEc2SecurityGroupIpPermission {
    /// <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>, <code>icmpv6</code>) or number.</p>
    /// <p>[VPC only] Use <code>-1</code> to specify all protocols.</p>
    /// <p>When authorizing security group rules, specifying <code>-1</code> or a protocol number other than <code>tcp</code>, <code>udp</code>, <code>icmp</code>, or <code>icmpv6</code> allows traffic on all ports, regardless of any port range you specify.</p>
    /// <p>For <code>tcp</code>, <code>udp</code>, and <code>icmp</code>, you must specify a port range.</p>
    /// <p>For <code>icmpv6</code>, the port range is optional. If you omit the port range, traffic for all types and codes is allowed. </p>
    pub fn ip_protocol(&self) -> std::option::Option<&str> {
        self.ip_protocol.as_deref()
    }
    /// <p>The start of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number.</p>
    /// <p>A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes. </p>
    pub fn from_port(&self) -> i32 {
        self.from_port
    }
    /// <p>The end of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code.</p>
    /// <p>A value of <code>-1</code> indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all codes.</p>
    pub fn to_port(&self) -> i32 {
        self.to_port
    }
    /// <p>The security group and Amazon Web Services account ID pairs.</p>
    pub fn user_id_group_pairs(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEc2SecurityGroupUserIdGroupPair]> {
        self.user_id_group_pairs.as_deref()
    }
    /// <p>The IPv4 ranges.</p>
    pub fn ip_ranges(&self) -> std::option::Option<&[crate::model::AwsEc2SecurityGroupIpRange]> {
        self.ip_ranges.as_deref()
    }
    /// <p>The IPv6 ranges.</p>
    pub fn ipv6_ranges(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEc2SecurityGroupIpv6Range]> {
        self.ipv6_ranges.as_deref()
    }
    /// <p>[VPC only] The prefix list IDs for an Amazon Web Services service. With outbound rules, this is the Amazon Web Services service to access through a VPC endpoint from instances associated with the security group.</p>
    pub fn prefix_list_ids(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEc2SecurityGroupPrefixListId]> {
        self.prefix_list_ids.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2SecurityGroupIpPermission {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2SecurityGroupIpPermission");
        formatter.field("ip_protocol", &self.ip_protocol);
        formatter.field("from_port", &self.from_port);
        formatter.field("to_port", &self.to_port);
        formatter.field("user_id_group_pairs", &self.user_id_group_pairs);
        formatter.field("ip_ranges", &self.ip_ranges);
        formatter.field("ipv6_ranges", &self.ipv6_ranges);
        formatter.field("prefix_list_ids", &self.prefix_list_ids);
        formatter.finish()
    }
}
/// See [`AwsEc2SecurityGroupIpPermission`](crate::model::AwsEc2SecurityGroupIpPermission)
pub mod aws_ec2_security_group_ip_permission {

    /// A builder for [`AwsEc2SecurityGroupIpPermission`](crate::model::AwsEc2SecurityGroupIpPermission)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ip_protocol: std::option::Option<std::string::String>,
        pub(crate) from_port: std::option::Option<i32>,
        pub(crate) to_port: std::option::Option<i32>,
        pub(crate) user_id_group_pairs:
            std::option::Option<std::vec::Vec<crate::model::AwsEc2SecurityGroupUserIdGroupPair>>,
        pub(crate) ip_ranges:
            std::option::Option<std::vec::Vec<crate::model::AwsEc2SecurityGroupIpRange>>,
        pub(crate) ipv6_ranges:
            std::option::Option<std::vec::Vec<crate::model::AwsEc2SecurityGroupIpv6Range>>,
        pub(crate) prefix_list_ids:
            std::option::Option<std::vec::Vec<crate::model::AwsEc2SecurityGroupPrefixListId>>,
    }
    impl Builder {
        /// <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>, <code>icmpv6</code>) or number.</p>
        /// <p>[VPC only] Use <code>-1</code> to specify all protocols.</p>
        /// <p>When authorizing security group rules, specifying <code>-1</code> or a protocol number other than <code>tcp</code>, <code>udp</code>, <code>icmp</code>, or <code>icmpv6</code> allows traffic on all ports, regardless of any port range you specify.</p>
        /// <p>For <code>tcp</code>, <code>udp</code>, and <code>icmp</code>, you must specify a port range.</p>
        /// <p>For <code>icmpv6</code>, the port range is optional. If you omit the port range, traffic for all types and codes is allowed. </p>
        pub fn ip_protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.ip_protocol = Some(input.into());
            self
        }
        /// <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>, <code>icmpv6</code>) or number.</p>
        /// <p>[VPC only] Use <code>-1</code> to specify all protocols.</p>
        /// <p>When authorizing security group rules, specifying <code>-1</code> or a protocol number other than <code>tcp</code>, <code>udp</code>, <code>icmp</code>, or <code>icmpv6</code> allows traffic on all ports, regardless of any port range you specify.</p>
        /// <p>For <code>tcp</code>, <code>udp</code>, and <code>icmp</code>, you must specify a port range.</p>
        /// <p>For <code>icmpv6</code>, the port range is optional. If you omit the port range, traffic for all types and codes is allowed. </p>
        pub fn set_ip_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ip_protocol = input;
            self
        }
        /// <p>The start of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number.</p>
        /// <p>A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes. </p>
        pub fn from_port(mut self, input: i32) -> Self {
            self.from_port = Some(input);
            self
        }
        /// <p>The start of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number.</p>
        /// <p>A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes. </p>
        pub fn set_from_port(mut self, input: std::option::Option<i32>) -> Self {
            self.from_port = input;
            self
        }
        /// <p>The end of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code.</p>
        /// <p>A value of <code>-1</code> indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all codes.</p>
        pub fn to_port(mut self, input: i32) -> Self {
            self.to_port = Some(input);
            self
        }
        /// <p>The end of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code.</p>
        /// <p>A value of <code>-1</code> indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all codes.</p>
        pub fn set_to_port(mut self, input: std::option::Option<i32>) -> Self {
            self.to_port = input;
            self
        }
        /// Appends an item to `user_id_group_pairs`.
        ///
        /// To override the contents of this collection use [`set_user_id_group_pairs`](Self::set_user_id_group_pairs).
        ///
        /// <p>The security group and Amazon Web Services account ID pairs.</p>
        pub fn user_id_group_pairs(
            mut self,
            input: crate::model::AwsEc2SecurityGroupUserIdGroupPair,
        ) -> Self {
            let mut v = self.user_id_group_pairs.unwrap_or_default();
            v.push(input);
            self.user_id_group_pairs = Some(v);
            self
        }
        /// <p>The security group and Amazon Web Services account ID pairs.</p>
        pub fn set_user_id_group_pairs(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEc2SecurityGroupUserIdGroupPair>,
            >,
        ) -> Self {
            self.user_id_group_pairs = input;
            self
        }
        /// Appends an item to `ip_ranges`.
        ///
        /// To override the contents of this collection use [`set_ip_ranges`](Self::set_ip_ranges).
        ///
        /// <p>The IPv4 ranges.</p>
        pub fn ip_ranges(mut self, input: crate::model::AwsEc2SecurityGroupIpRange) -> Self {
            let mut v = self.ip_ranges.unwrap_or_default();
            v.push(input);
            self.ip_ranges = Some(v);
            self
        }
        /// <p>The IPv4 ranges.</p>
        pub fn set_ip_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsEc2SecurityGroupIpRange>>,
        ) -> Self {
            self.ip_ranges = input;
            self
        }
        /// Appends an item to `ipv6_ranges`.
        ///
        /// To override the contents of this collection use [`set_ipv6_ranges`](Self::set_ipv6_ranges).
        ///
        /// <p>The IPv6 ranges.</p>
        pub fn ipv6_ranges(mut self, input: crate::model::AwsEc2SecurityGroupIpv6Range) -> Self {
            let mut v = self.ipv6_ranges.unwrap_or_default();
            v.push(input);
            self.ipv6_ranges = Some(v);
            self
        }
        /// <p>The IPv6 ranges.</p>
        pub fn set_ipv6_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsEc2SecurityGroupIpv6Range>>,
        ) -> Self {
            self.ipv6_ranges = input;
            self
        }
        /// Appends an item to `prefix_list_ids`.
        ///
        /// To override the contents of this collection use [`set_prefix_list_ids`](Self::set_prefix_list_ids).
        ///
        /// <p>[VPC only] The prefix list IDs for an Amazon Web Services service. With outbound rules, this is the Amazon Web Services service to access through a VPC endpoint from instances associated with the security group.</p>
        pub fn prefix_list_ids(
            mut self,
            input: crate::model::AwsEc2SecurityGroupPrefixListId,
        ) -> Self {
            let mut v = self.prefix_list_ids.unwrap_or_default();
            v.push(input);
            self.prefix_list_ids = Some(v);
            self
        }
        /// <p>[VPC only] The prefix list IDs for an Amazon Web Services service. With outbound rules, this is the Amazon Web Services service to access through a VPC endpoint from instances associated with the security group.</p>
        pub fn set_prefix_list_ids(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEc2SecurityGroupPrefixListId>,
            >,
        ) -> Self {
            self.prefix_list_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2SecurityGroupIpPermission`](crate::model::AwsEc2SecurityGroupIpPermission)
        pub fn build(self) -> crate::model::AwsEc2SecurityGroupIpPermission {
            crate::model::AwsEc2SecurityGroupIpPermission {
                ip_protocol: self.ip_protocol,
                from_port: self.from_port.unwrap_or_default(),
                to_port: self.to_port.unwrap_or_default(),
                user_id_group_pairs: self.user_id_group_pairs,
                ip_ranges: self.ip_ranges,
                ipv6_ranges: self.ipv6_ranges,
                prefix_list_ids: self.prefix_list_ids,
            }
        }
    }
}
impl AwsEc2SecurityGroupIpPermission {
    /// Creates a new builder-style object to manufacture [`AwsEc2SecurityGroupIpPermission`](crate::model::AwsEc2SecurityGroupIpPermission)
    pub fn builder() -> crate::model::aws_ec2_security_group_ip_permission::Builder {
        crate::model::aws_ec2_security_group_ip_permission::Builder::default()
    }
}

/// <p>A prefix list ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2SecurityGroupPrefixListId {
    /// <p>The ID of the prefix.</p>
    pub prefix_list_id: std::option::Option<std::string::String>,
}
impl AwsEc2SecurityGroupPrefixListId {
    /// <p>The ID of the prefix.</p>
    pub fn prefix_list_id(&self) -> std::option::Option<&str> {
        self.prefix_list_id.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2SecurityGroupPrefixListId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2SecurityGroupPrefixListId");
        formatter.field("prefix_list_id", &self.prefix_list_id);
        formatter.finish()
    }
}
/// See [`AwsEc2SecurityGroupPrefixListId`](crate::model::AwsEc2SecurityGroupPrefixListId)
pub mod aws_ec2_security_group_prefix_list_id {

    /// A builder for [`AwsEc2SecurityGroupPrefixListId`](crate::model::AwsEc2SecurityGroupPrefixListId)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) prefix_list_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the prefix.</p>
        pub fn prefix_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix_list_id = Some(input.into());
            self
        }
        /// <p>The ID of the prefix.</p>
        pub fn set_prefix_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.prefix_list_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2SecurityGroupPrefixListId`](crate::model::AwsEc2SecurityGroupPrefixListId)
        pub fn build(self) -> crate::model::AwsEc2SecurityGroupPrefixListId {
            crate::model::AwsEc2SecurityGroupPrefixListId {
                prefix_list_id: self.prefix_list_id,
            }
        }
    }
}
impl AwsEc2SecurityGroupPrefixListId {
    /// Creates a new builder-style object to manufacture [`AwsEc2SecurityGroupPrefixListId`](crate::model::AwsEc2SecurityGroupPrefixListId)
    pub fn builder() -> crate::model::aws_ec2_security_group_prefix_list_id::Builder {
        crate::model::aws_ec2_security_group_prefix_list_id::Builder::default()
    }
}

/// <p>A range of IPv6 addresses.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2SecurityGroupIpv6Range {
    /// <p>The IPv6 CIDR range. You can specify either a CIDR range or a source security group, but not both. To specify a single IPv6 address, use the /128 prefix length.</p>
    pub cidr_ipv6: std::option::Option<std::string::String>,
}
impl AwsEc2SecurityGroupIpv6Range {
    /// <p>The IPv6 CIDR range. You can specify either a CIDR range or a source security group, but not both. To specify a single IPv6 address, use the /128 prefix length.</p>
    pub fn cidr_ipv6(&self) -> std::option::Option<&str> {
        self.cidr_ipv6.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2SecurityGroupIpv6Range {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2SecurityGroupIpv6Range");
        formatter.field("cidr_ipv6", &self.cidr_ipv6);
        formatter.finish()
    }
}
/// See [`AwsEc2SecurityGroupIpv6Range`](crate::model::AwsEc2SecurityGroupIpv6Range)
pub mod aws_ec2_security_group_ipv6_range {

    /// A builder for [`AwsEc2SecurityGroupIpv6Range`](crate::model::AwsEc2SecurityGroupIpv6Range)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cidr_ipv6: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IPv6 CIDR range. You can specify either a CIDR range or a source security group, but not both. To specify a single IPv6 address, use the /128 prefix length.</p>
        pub fn cidr_ipv6(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr_ipv6 = Some(input.into());
            self
        }
        /// <p>The IPv6 CIDR range. You can specify either a CIDR range or a source security group, but not both. To specify a single IPv6 address, use the /128 prefix length.</p>
        pub fn set_cidr_ipv6(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr_ipv6 = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2SecurityGroupIpv6Range`](crate::model::AwsEc2SecurityGroupIpv6Range)
        pub fn build(self) -> crate::model::AwsEc2SecurityGroupIpv6Range {
            crate::model::AwsEc2SecurityGroupIpv6Range {
                cidr_ipv6: self.cidr_ipv6,
            }
        }
    }
}
impl AwsEc2SecurityGroupIpv6Range {
    /// Creates a new builder-style object to manufacture [`AwsEc2SecurityGroupIpv6Range`](crate::model::AwsEc2SecurityGroupIpv6Range)
    pub fn builder() -> crate::model::aws_ec2_security_group_ipv6_range::Builder {
        crate::model::aws_ec2_security_group_ipv6_range::Builder::default()
    }
}

/// <p>A range of IPv4 addresses.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2SecurityGroupIpRange {
    /// <p>The IPv4 CIDR range. You can specify either a CIDR range or a source security group, but not both. To specify a single IPv4 address, use the /32 prefix length.</p>
    pub cidr_ip: std::option::Option<std::string::String>,
}
impl AwsEc2SecurityGroupIpRange {
    /// <p>The IPv4 CIDR range. You can specify either a CIDR range or a source security group, but not both. To specify a single IPv4 address, use the /32 prefix length.</p>
    pub fn cidr_ip(&self) -> std::option::Option<&str> {
        self.cidr_ip.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2SecurityGroupIpRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2SecurityGroupIpRange");
        formatter.field("cidr_ip", &self.cidr_ip);
        formatter.finish()
    }
}
/// See [`AwsEc2SecurityGroupIpRange`](crate::model::AwsEc2SecurityGroupIpRange)
pub mod aws_ec2_security_group_ip_range {

    /// A builder for [`AwsEc2SecurityGroupIpRange`](crate::model::AwsEc2SecurityGroupIpRange)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cidr_ip: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IPv4 CIDR range. You can specify either a CIDR range or a source security group, but not both. To specify a single IPv4 address, use the /32 prefix length.</p>
        pub fn cidr_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr_ip = Some(input.into());
            self
        }
        /// <p>The IPv4 CIDR range. You can specify either a CIDR range or a source security group, but not both. To specify a single IPv4 address, use the /32 prefix length.</p>
        pub fn set_cidr_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr_ip = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2SecurityGroupIpRange`](crate::model::AwsEc2SecurityGroupIpRange)
        pub fn build(self) -> crate::model::AwsEc2SecurityGroupIpRange {
            crate::model::AwsEc2SecurityGroupIpRange {
                cidr_ip: self.cidr_ip,
            }
        }
    }
}
impl AwsEc2SecurityGroupIpRange {
    /// Creates a new builder-style object to manufacture [`AwsEc2SecurityGroupIpRange`](crate::model::AwsEc2SecurityGroupIpRange)
    pub fn builder() -> crate::model::aws_ec2_security_group_ip_range::Builder {
        crate::model::aws_ec2_security_group_ip_range::Builder::default()
    }
}

/// <p>A relationship between a security group and a user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2SecurityGroupUserIdGroupPair {
    /// <p>The ID of the security group.</p>
    pub group_id: std::option::Option<std::string::String>,
    /// <p>The name of the security group.</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The status of a VPC peering connection, if applicable.</p>
    pub peering_status: std::option::Option<std::string::String>,
    /// <p>The ID of an Amazon Web Services account.</p>
    /// <p>For a referenced security group in another VPC, the account ID of the referenced security group is returned in the response. If the referenced security group is deleted, this value is not returned.</p>
    /// <p>[EC2-Classic] Required when adding or removing rules that reference a security group in another VPC. </p>
    pub user_id: std::option::Option<std::string::String>,
    /// <p>The ID of the VPC for the referenced security group, if applicable.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The ID of the VPC peering connection, if applicable.</p>
    pub vpc_peering_connection_id: std::option::Option<std::string::String>,
}
impl AwsEc2SecurityGroupUserIdGroupPair {
    /// <p>The ID of the security group.</p>
    pub fn group_id(&self) -> std::option::Option<&str> {
        self.group_id.as_deref()
    }
    /// <p>The name of the security group.</p>
    pub fn group_name(&self) -> std::option::Option<&str> {
        self.group_name.as_deref()
    }
    /// <p>The status of a VPC peering connection, if applicable.</p>
    pub fn peering_status(&self) -> std::option::Option<&str> {
        self.peering_status.as_deref()
    }
    /// <p>The ID of an Amazon Web Services account.</p>
    /// <p>For a referenced security group in another VPC, the account ID of the referenced security group is returned in the response. If the referenced security group is deleted, this value is not returned.</p>
    /// <p>[EC2-Classic] Required when adding or removing rules that reference a security group in another VPC. </p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
    /// <p>The ID of the VPC for the referenced security group, if applicable.</p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
    /// <p>The ID of the VPC peering connection, if applicable.</p>
    pub fn vpc_peering_connection_id(&self) -> std::option::Option<&str> {
        self.vpc_peering_connection_id.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2SecurityGroupUserIdGroupPair {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2SecurityGroupUserIdGroupPair");
        formatter.field("group_id", &self.group_id);
        formatter.field("group_name", &self.group_name);
        formatter.field("peering_status", &self.peering_status);
        formatter.field("user_id", &self.user_id);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("vpc_peering_connection_id", &self.vpc_peering_connection_id);
        formatter.finish()
    }
}
/// See [`AwsEc2SecurityGroupUserIdGroupPair`](crate::model::AwsEc2SecurityGroupUserIdGroupPair)
pub mod aws_ec2_security_group_user_id_group_pair {

    /// A builder for [`AwsEc2SecurityGroupUserIdGroupPair`](crate::model::AwsEc2SecurityGroupUserIdGroupPair)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) peering_status: std::option::Option<std::string::String>,
        pub(crate) user_id: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) vpc_peering_connection_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the security group.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// <p>The ID of the security group.</p>
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input;
            self
        }
        /// <p>The name of the security group.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        /// <p>The name of the security group.</p>
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// <p>The status of a VPC peering connection, if applicable.</p>
        pub fn peering_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.peering_status = Some(input.into());
            self
        }
        /// <p>The status of a VPC peering connection, if applicable.</p>
        pub fn set_peering_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.peering_status = input;
            self
        }
        /// <p>The ID of an Amazon Web Services account.</p>
        /// <p>For a referenced security group in another VPC, the account ID of the referenced security group is returned in the response. If the referenced security group is deleted, this value is not returned.</p>
        /// <p>[EC2-Classic] Required when adding or removing rules that reference a security group in another VPC. </p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The ID of an Amazon Web Services account.</p>
        /// <p>For a referenced security group in another VPC, the account ID of the referenced security group is returned in the response. If the referenced security group is deleted, this value is not returned.</p>
        /// <p>[EC2-Classic] Required when adding or removing rules that reference a security group in another VPC. </p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// <p>The ID of the VPC for the referenced security group, if applicable.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The ID of the VPC for the referenced security group, if applicable.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// <p>The ID of the VPC peering connection, if applicable.</p>
        pub fn vpc_peering_connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_peering_connection_id = Some(input.into());
            self
        }
        /// <p>The ID of the VPC peering connection, if applicable.</p>
        pub fn set_vpc_peering_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_peering_connection_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2SecurityGroupUserIdGroupPair`](crate::model::AwsEc2SecurityGroupUserIdGroupPair)
        pub fn build(self) -> crate::model::AwsEc2SecurityGroupUserIdGroupPair {
            crate::model::AwsEc2SecurityGroupUserIdGroupPair {
                group_id: self.group_id,
                group_name: self.group_name,
                peering_status: self.peering_status,
                user_id: self.user_id,
                vpc_id: self.vpc_id,
                vpc_peering_connection_id: self.vpc_peering_connection_id,
            }
        }
    }
}
impl AwsEc2SecurityGroupUserIdGroupPair {
    /// Creates a new builder-style object to manufacture [`AwsEc2SecurityGroupUserIdGroupPair`](crate::model::AwsEc2SecurityGroupUserIdGroupPair)
    pub fn builder() -> crate::model::aws_ec2_security_group_user_id_group_pair::Builder {
        crate::model::aws_ec2_security_group_user_id_group_pair::Builder::default()
    }
}

/// <p>Details about the network interface</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2NetworkInterfaceDetails {
    /// <p>The network interface attachment.</p>
    pub attachment: std::option::Option<crate::model::AwsEc2NetworkInterfaceAttachment>,
    /// <p>The ID of the network interface.</p>
    pub network_interface_id: std::option::Option<std::string::String>,
    /// <p>Security groups for the network interface.</p>
    pub security_groups:
        std::option::Option<std::vec::Vec<crate::model::AwsEc2NetworkInterfaceSecurityGroup>>,
    /// <p>Indicates whether traffic to or from the instance is validated.</p>
    pub source_dest_check: bool,
    /// <p>The IPv6 addresses associated with the network interface.</p>
    pub ip_v6_addresses:
        std::option::Option<std::vec::Vec<crate::model::AwsEc2NetworkInterfaceIpV6AddressDetail>>,
    /// <p>The private IPv4 addresses associated with the network interface.</p>
    pub private_ip_addresses: std::option::Option<
        std::vec::Vec<crate::model::AwsEc2NetworkInterfacePrivateIpAddressDetail>,
    >,
    /// <p>The public DNS name of the network interface.</p>
    pub public_dns_name: std::option::Option<std::string::String>,
    /// <p>The address of the Elastic IP address bound to the network interface.</p>
    pub public_ip: std::option::Option<std::string::String>,
}
impl AwsEc2NetworkInterfaceDetails {
    /// <p>The network interface attachment.</p>
    pub fn attachment(
        &self,
    ) -> std::option::Option<&crate::model::AwsEc2NetworkInterfaceAttachment> {
        self.attachment.as_ref()
    }
    /// <p>The ID of the network interface.</p>
    pub fn network_interface_id(&self) -> std::option::Option<&str> {
        self.network_interface_id.as_deref()
    }
    /// <p>Security groups for the network interface.</p>
    pub fn security_groups(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEc2NetworkInterfaceSecurityGroup]> {
        self.security_groups.as_deref()
    }
    /// <p>Indicates whether traffic to or from the instance is validated.</p>
    pub fn source_dest_check(&self) -> bool {
        self.source_dest_check
    }
    /// <p>The IPv6 addresses associated with the network interface.</p>
    pub fn ip_v6_addresses(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEc2NetworkInterfaceIpV6AddressDetail]> {
        self.ip_v6_addresses.as_deref()
    }
    /// <p>The private IPv4 addresses associated with the network interface.</p>
    pub fn private_ip_addresses(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEc2NetworkInterfacePrivateIpAddressDetail]> {
        self.private_ip_addresses.as_deref()
    }
    /// <p>The public DNS name of the network interface.</p>
    pub fn public_dns_name(&self) -> std::option::Option<&str> {
        self.public_dns_name.as_deref()
    }
    /// <p>The address of the Elastic IP address bound to the network interface.</p>
    pub fn public_ip(&self) -> std::option::Option<&str> {
        self.public_ip.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2NetworkInterfaceDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2NetworkInterfaceDetails");
        formatter.field("attachment", &self.attachment);
        formatter.field("network_interface_id", &self.network_interface_id);
        formatter.field("security_groups", &self.security_groups);
        formatter.field("source_dest_check", &self.source_dest_check);
        formatter.field("ip_v6_addresses", &self.ip_v6_addresses);
        formatter.field("private_ip_addresses", &self.private_ip_addresses);
        formatter.field("public_dns_name", &self.public_dns_name);
        formatter.field("public_ip", &self.public_ip);
        formatter.finish()
    }
}
/// See [`AwsEc2NetworkInterfaceDetails`](crate::model::AwsEc2NetworkInterfaceDetails)
pub mod aws_ec2_network_interface_details {

    /// A builder for [`AwsEc2NetworkInterfaceDetails`](crate::model::AwsEc2NetworkInterfaceDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attachment: std::option::Option<crate::model::AwsEc2NetworkInterfaceAttachment>,
        pub(crate) network_interface_id: std::option::Option<std::string::String>,
        pub(crate) security_groups:
            std::option::Option<std::vec::Vec<crate::model::AwsEc2NetworkInterfaceSecurityGroup>>,
        pub(crate) source_dest_check: std::option::Option<bool>,
        pub(crate) ip_v6_addresses: std::option::Option<
            std::vec::Vec<crate::model::AwsEc2NetworkInterfaceIpV6AddressDetail>,
        >,
        pub(crate) private_ip_addresses: std::option::Option<
            std::vec::Vec<crate::model::AwsEc2NetworkInterfacePrivateIpAddressDetail>,
        >,
        pub(crate) public_dns_name: std::option::Option<std::string::String>,
        pub(crate) public_ip: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The network interface attachment.</p>
        pub fn attachment(mut self, input: crate::model::AwsEc2NetworkInterfaceAttachment) -> Self {
            self.attachment = Some(input);
            self
        }
        /// <p>The network interface attachment.</p>
        pub fn set_attachment(
            mut self,
            input: std::option::Option<crate::model::AwsEc2NetworkInterfaceAttachment>,
        ) -> Self {
            self.attachment = input;
            self
        }
        /// <p>The ID of the network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_interface_id = Some(input.into());
            self
        }
        /// <p>The ID of the network interface.</p>
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_interface_id = input;
            self
        }
        /// Appends an item to `security_groups`.
        ///
        /// To override the contents of this collection use [`set_security_groups`](Self::set_security_groups).
        ///
        /// <p>Security groups for the network interface.</p>
        pub fn security_groups(
            mut self,
            input: crate::model::AwsEc2NetworkInterfaceSecurityGroup,
        ) -> Self {
            let mut v = self.security_groups.unwrap_or_default();
            v.push(input);
            self.security_groups = Some(v);
            self
        }
        /// <p>Security groups for the network interface.</p>
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEc2NetworkInterfaceSecurityGroup>,
            >,
        ) -> Self {
            self.security_groups = input;
            self
        }
        /// <p>Indicates whether traffic to or from the instance is validated.</p>
        pub fn source_dest_check(mut self, input: bool) -> Self {
            self.source_dest_check = Some(input);
            self
        }
        /// <p>Indicates whether traffic to or from the instance is validated.</p>
        pub fn set_source_dest_check(mut self, input: std::option::Option<bool>) -> Self {
            self.source_dest_check = input;
            self
        }
        /// Appends an item to `ip_v6_addresses`.
        ///
        /// To override the contents of this collection use [`set_ip_v6_addresses`](Self::set_ip_v6_addresses).
        ///
        /// <p>The IPv6 addresses associated with the network interface.</p>
        pub fn ip_v6_addresses(
            mut self,
            input: crate::model::AwsEc2NetworkInterfaceIpV6AddressDetail,
        ) -> Self {
            let mut v = self.ip_v6_addresses.unwrap_or_default();
            v.push(input);
            self.ip_v6_addresses = Some(v);
            self
        }
        /// <p>The IPv6 addresses associated with the network interface.</p>
        pub fn set_ip_v6_addresses(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEc2NetworkInterfaceIpV6AddressDetail>,
            >,
        ) -> Self {
            self.ip_v6_addresses = input;
            self
        }
        /// Appends an item to `private_ip_addresses`.
        ///
        /// To override the contents of this collection use [`set_private_ip_addresses`](Self::set_private_ip_addresses).
        ///
        /// <p>The private IPv4 addresses associated with the network interface.</p>
        pub fn private_ip_addresses(
            mut self,
            input: crate::model::AwsEc2NetworkInterfacePrivateIpAddressDetail,
        ) -> Self {
            let mut v = self.private_ip_addresses.unwrap_or_default();
            v.push(input);
            self.private_ip_addresses = Some(v);
            self
        }
        /// <p>The private IPv4 addresses associated with the network interface.</p>
        pub fn set_private_ip_addresses(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEc2NetworkInterfacePrivateIpAddressDetail>,
            >,
        ) -> Self {
            self.private_ip_addresses = input;
            self
        }
        /// <p>The public DNS name of the network interface.</p>
        pub fn public_dns_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.public_dns_name = Some(input.into());
            self
        }
        /// <p>The public DNS name of the network interface.</p>
        pub fn set_public_dns_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.public_dns_name = input;
            self
        }
        /// <p>The address of the Elastic IP address bound to the network interface.</p>
        pub fn public_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.public_ip = Some(input.into());
            self
        }
        /// <p>The address of the Elastic IP address bound to the network interface.</p>
        pub fn set_public_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.public_ip = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2NetworkInterfaceDetails`](crate::model::AwsEc2NetworkInterfaceDetails)
        pub fn build(self) -> crate::model::AwsEc2NetworkInterfaceDetails {
            crate::model::AwsEc2NetworkInterfaceDetails {
                attachment: self.attachment,
                network_interface_id: self.network_interface_id,
                security_groups: self.security_groups,
                source_dest_check: self.source_dest_check.unwrap_or_default(),
                ip_v6_addresses: self.ip_v6_addresses,
                private_ip_addresses: self.private_ip_addresses,
                public_dns_name: self.public_dns_name,
                public_ip: self.public_ip,
            }
        }
    }
}
impl AwsEc2NetworkInterfaceDetails {
    /// Creates a new builder-style object to manufacture [`AwsEc2NetworkInterfaceDetails`](crate::model::AwsEc2NetworkInterfaceDetails)
    pub fn builder() -> crate::model::aws_ec2_network_interface_details::Builder {
        crate::model::aws_ec2_network_interface_details::Builder::default()
    }
}

/// <p>Provides information about a private IPv4 address that is with the network interface.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2NetworkInterfacePrivateIpAddressDetail {
    /// <p>The IP address.</p>
    pub private_ip_address: std::option::Option<std::string::String>,
    /// <p>The private DNS name for the IP address.</p>
    pub private_dns_name: std::option::Option<std::string::String>,
}
impl AwsEc2NetworkInterfacePrivateIpAddressDetail {
    /// <p>The IP address.</p>
    pub fn private_ip_address(&self) -> std::option::Option<&str> {
        self.private_ip_address.as_deref()
    }
    /// <p>The private DNS name for the IP address.</p>
    pub fn private_dns_name(&self) -> std::option::Option<&str> {
        self.private_dns_name.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2NetworkInterfacePrivateIpAddressDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2NetworkInterfacePrivateIpAddressDetail");
        formatter.field("private_ip_address", &self.private_ip_address);
        formatter.field("private_dns_name", &self.private_dns_name);
        formatter.finish()
    }
}
/// See [`AwsEc2NetworkInterfacePrivateIpAddressDetail`](crate::model::AwsEc2NetworkInterfacePrivateIpAddressDetail)
pub mod aws_ec2_network_interface_private_ip_address_detail {

    /// A builder for [`AwsEc2NetworkInterfacePrivateIpAddressDetail`](crate::model::AwsEc2NetworkInterfacePrivateIpAddressDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) private_ip_address: std::option::Option<std::string::String>,
        pub(crate) private_dns_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IP address.</p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_ip_address = Some(input.into());
            self
        }
        /// <p>The IP address.</p>
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_ip_address = input;
            self
        }
        /// <p>The private DNS name for the IP address.</p>
        pub fn private_dns_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_dns_name = Some(input.into());
            self
        }
        /// <p>The private DNS name for the IP address.</p>
        pub fn set_private_dns_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_dns_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2NetworkInterfacePrivateIpAddressDetail`](crate::model::AwsEc2NetworkInterfacePrivateIpAddressDetail)
        pub fn build(self) -> crate::model::AwsEc2NetworkInterfacePrivateIpAddressDetail {
            crate::model::AwsEc2NetworkInterfacePrivateIpAddressDetail {
                private_ip_address: self.private_ip_address,
                private_dns_name: self.private_dns_name,
            }
        }
    }
}
impl AwsEc2NetworkInterfacePrivateIpAddressDetail {
    /// Creates a new builder-style object to manufacture [`AwsEc2NetworkInterfacePrivateIpAddressDetail`](crate::model::AwsEc2NetworkInterfacePrivateIpAddressDetail)
    pub fn builder() -> crate::model::aws_ec2_network_interface_private_ip_address_detail::Builder {
        crate::model::aws_ec2_network_interface_private_ip_address_detail::Builder::default()
    }
}

/// <p>Provides information about an IPV6 address that is associated with the network interface.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2NetworkInterfaceIpV6AddressDetail {
    /// <p>The IPV6 address.</p>
    pub ip_v6_address: std::option::Option<std::string::String>,
}
impl AwsEc2NetworkInterfaceIpV6AddressDetail {
    /// <p>The IPV6 address.</p>
    pub fn ip_v6_address(&self) -> std::option::Option<&str> {
        self.ip_v6_address.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2NetworkInterfaceIpV6AddressDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2NetworkInterfaceIpV6AddressDetail");
        formatter.field("ip_v6_address", &self.ip_v6_address);
        formatter.finish()
    }
}
/// See [`AwsEc2NetworkInterfaceIpV6AddressDetail`](crate::model::AwsEc2NetworkInterfaceIpV6AddressDetail)
pub mod aws_ec2_network_interface_ip_v6_address_detail {

    /// A builder for [`AwsEc2NetworkInterfaceIpV6AddressDetail`](crate::model::AwsEc2NetworkInterfaceIpV6AddressDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ip_v6_address: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IPV6 address.</p>
        pub fn ip_v6_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.ip_v6_address = Some(input.into());
            self
        }
        /// <p>The IPV6 address.</p>
        pub fn set_ip_v6_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ip_v6_address = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2NetworkInterfaceIpV6AddressDetail`](crate::model::AwsEc2NetworkInterfaceIpV6AddressDetail)
        pub fn build(self) -> crate::model::AwsEc2NetworkInterfaceIpV6AddressDetail {
            crate::model::AwsEc2NetworkInterfaceIpV6AddressDetail {
                ip_v6_address: self.ip_v6_address,
            }
        }
    }
}
impl AwsEc2NetworkInterfaceIpV6AddressDetail {
    /// Creates a new builder-style object to manufacture [`AwsEc2NetworkInterfaceIpV6AddressDetail`](crate::model::AwsEc2NetworkInterfaceIpV6AddressDetail)
    pub fn builder() -> crate::model::aws_ec2_network_interface_ip_v6_address_detail::Builder {
        crate::model::aws_ec2_network_interface_ip_v6_address_detail::Builder::default()
    }
}

/// <p>A security group associated with the network interface.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2NetworkInterfaceSecurityGroup {
    /// <p>The name of the security group.</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The ID of the security group.</p>
    pub group_id: std::option::Option<std::string::String>,
}
impl AwsEc2NetworkInterfaceSecurityGroup {
    /// <p>The name of the security group.</p>
    pub fn group_name(&self) -> std::option::Option<&str> {
        self.group_name.as_deref()
    }
    /// <p>The ID of the security group.</p>
    pub fn group_id(&self) -> std::option::Option<&str> {
        self.group_id.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2NetworkInterfaceSecurityGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2NetworkInterfaceSecurityGroup");
        formatter.field("group_name", &self.group_name);
        formatter.field("group_id", &self.group_id);
        formatter.finish()
    }
}
/// See [`AwsEc2NetworkInterfaceSecurityGroup`](crate::model::AwsEc2NetworkInterfaceSecurityGroup)
pub mod aws_ec2_network_interface_security_group {

    /// A builder for [`AwsEc2NetworkInterfaceSecurityGroup`](crate::model::AwsEc2NetworkInterfaceSecurityGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) group_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the security group.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        /// <p>The name of the security group.</p>
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// <p>The ID of the security group.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// <p>The ID of the security group.</p>
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2NetworkInterfaceSecurityGroup`](crate::model::AwsEc2NetworkInterfaceSecurityGroup)
        pub fn build(self) -> crate::model::AwsEc2NetworkInterfaceSecurityGroup {
            crate::model::AwsEc2NetworkInterfaceSecurityGroup {
                group_name: self.group_name,
                group_id: self.group_id,
            }
        }
    }
}
impl AwsEc2NetworkInterfaceSecurityGroup {
    /// Creates a new builder-style object to manufacture [`AwsEc2NetworkInterfaceSecurityGroup`](crate::model::AwsEc2NetworkInterfaceSecurityGroup)
    pub fn builder() -> crate::model::aws_ec2_network_interface_security_group::Builder {
        crate::model::aws_ec2_network_interface_security_group::Builder::default()
    }
}

/// <p>Information about the network interface attachment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2NetworkInterfaceAttachment {
    /// <p>Indicates when the attachment initiated.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub attach_time: std::option::Option<std::string::String>,
    /// <p>The identifier of the network interface attachment</p>
    pub attachment_id: std::option::Option<std::string::String>,
    /// <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
    pub delete_on_termination: bool,
    /// <p>The device index of the network interface attachment on the instance.</p>
    pub device_index: i32,
    /// <p>The ID of the instance.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID of the owner of the instance.</p>
    pub instance_owner_id: std::option::Option<std::string::String>,
    /// <p>The attachment state.</p>
    /// <p>Valid values: <code>attaching</code> | <code>attached</code> | <code>detaching</code> | <code>detached</code> </p>
    pub status: std::option::Option<std::string::String>,
}
impl AwsEc2NetworkInterfaceAttachment {
    /// <p>Indicates when the attachment initiated.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn attach_time(&self) -> std::option::Option<&str> {
        self.attach_time.as_deref()
    }
    /// <p>The identifier of the network interface attachment</p>
    pub fn attachment_id(&self) -> std::option::Option<&str> {
        self.attachment_id.as_deref()
    }
    /// <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
    pub fn delete_on_termination(&self) -> bool {
        self.delete_on_termination
    }
    /// <p>The device index of the network interface attachment on the instance.</p>
    pub fn device_index(&self) -> i32 {
        self.device_index
    }
    /// <p>The ID of the instance.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The Amazon Web Services account ID of the owner of the instance.</p>
    pub fn instance_owner_id(&self) -> std::option::Option<&str> {
        self.instance_owner_id.as_deref()
    }
    /// <p>The attachment state.</p>
    /// <p>Valid values: <code>attaching</code> | <code>attached</code> | <code>detaching</code> | <code>detached</code> </p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2NetworkInterfaceAttachment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2NetworkInterfaceAttachment");
        formatter.field("attach_time", &self.attach_time);
        formatter.field("attachment_id", &self.attachment_id);
        formatter.field("delete_on_termination", &self.delete_on_termination);
        formatter.field("device_index", &self.device_index);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("instance_owner_id", &self.instance_owner_id);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`AwsEc2NetworkInterfaceAttachment`](crate::model::AwsEc2NetworkInterfaceAttachment)
pub mod aws_ec2_network_interface_attachment {

    /// A builder for [`AwsEc2NetworkInterfaceAttachment`](crate::model::AwsEc2NetworkInterfaceAttachment)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attach_time: std::option::Option<std::string::String>,
        pub(crate) attachment_id: std::option::Option<std::string::String>,
        pub(crate) delete_on_termination: std::option::Option<bool>,
        pub(crate) device_index: std::option::Option<i32>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) instance_owner_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates when the attachment initiated.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn attach_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.attach_time = Some(input.into());
            self
        }
        /// <p>Indicates when the attachment initiated.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_attach_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.attach_time = input;
            self
        }
        /// <p>The identifier of the network interface attachment</p>
        pub fn attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attachment_id = Some(input.into());
            self
        }
        /// <p>The identifier of the network interface attachment</p>
        pub fn set_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attachment_id = input;
            self
        }
        /// <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
        pub fn delete_on_termination(mut self, input: bool) -> Self {
            self.delete_on_termination = Some(input);
            self
        }
        /// <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
        pub fn set_delete_on_termination(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_on_termination = input;
            self
        }
        /// <p>The device index of the network interface attachment on the instance.</p>
        pub fn device_index(mut self, input: i32) -> Self {
            self.device_index = Some(input);
            self
        }
        /// <p>The device index of the network interface attachment on the instance.</p>
        pub fn set_device_index(mut self, input: std::option::Option<i32>) -> Self {
            self.device_index = input;
            self
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The ID of the instance.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The Amazon Web Services account ID of the owner of the instance.</p>
        pub fn instance_owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_owner_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID of the owner of the instance.</p>
        pub fn set_instance_owner_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_owner_id = input;
            self
        }
        /// <p>The attachment state.</p>
        /// <p>Valid values: <code>attaching</code> | <code>attached</code> | <code>detaching</code> | <code>detached</code> </p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The attachment state.</p>
        /// <p>Valid values: <code>attaching</code> | <code>attached</code> | <code>detaching</code> | <code>detached</code> </p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2NetworkInterfaceAttachment`](crate::model::AwsEc2NetworkInterfaceAttachment)
        pub fn build(self) -> crate::model::AwsEc2NetworkInterfaceAttachment {
            crate::model::AwsEc2NetworkInterfaceAttachment {
                attach_time: self.attach_time,
                attachment_id: self.attachment_id,
                delete_on_termination: self.delete_on_termination.unwrap_or_default(),
                device_index: self.device_index.unwrap_or_default(),
                instance_id: self.instance_id,
                instance_owner_id: self.instance_owner_id,
                status: self.status,
            }
        }
    }
}
impl AwsEc2NetworkInterfaceAttachment {
    /// Creates a new builder-style object to manufacture [`AwsEc2NetworkInterfaceAttachment`](crate::model::AwsEc2NetworkInterfaceAttachment)
    pub fn builder() -> crate::model::aws_ec2_network_interface_attachment::Builder {
        crate::model::aws_ec2_network_interface_attachment::Builder::default()
    }
}

/// <p>The details of an Amazon EC2 instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2InstanceDetails {
    /// <p>The instance type of the instance. </p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The Amazon Machine Image (AMI) ID of the instance.</p>
    pub image_id: std::option::Option<std::string::String>,
    /// <p>The IPv4 addresses associated with the instance.</p>
    pub ip_v4_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The IPv6 addresses associated with the instance.</p>
    pub ip_v6_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The key name associated with the instance.</p>
    pub key_name: std::option::Option<std::string::String>,
    /// <p>The IAM profile ARN of the instance.</p>
    pub iam_instance_profile_arn: std::option::Option<std::string::String>,
    /// <p>The identifier of the VPC that the instance was launched in.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the subnet that the instance was launched in.</p>
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>Indicates when the instance was launched.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub launched_at: std::option::Option<std::string::String>,
    /// <p>The identifiers of the network interfaces for the EC2 instance. The details for each network interface are in a corresponding <code>AwsEc2NetworkInterfacesDetails</code> object.</p>
    pub network_interfaces:
        std::option::Option<std::vec::Vec<crate::model::AwsEc2InstanceNetworkInterfacesDetails>>,
    /// <p>The virtualization type of the Amazon Machine Image (AMI) required to launch the instance. </p>
    pub virtualization_type: std::option::Option<std::string::String>,
    /// <p>Details about the metadata options for the Amazon EC2 instance. </p>
    pub metadata_options: std::option::Option<crate::model::AwsEc2InstanceMetadataOptions>,
}
impl AwsEc2InstanceDetails {
    /// <p>The instance type of the instance. </p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The Amazon Machine Image (AMI) ID of the instance.</p>
    pub fn image_id(&self) -> std::option::Option<&str> {
        self.image_id.as_deref()
    }
    /// <p>The IPv4 addresses associated with the instance.</p>
    pub fn ip_v4_addresses(&self) -> std::option::Option<&[std::string::String]> {
        self.ip_v4_addresses.as_deref()
    }
    /// <p>The IPv6 addresses associated with the instance.</p>
    pub fn ip_v6_addresses(&self) -> std::option::Option<&[std::string::String]> {
        self.ip_v6_addresses.as_deref()
    }
    /// <p>The key name associated with the instance.</p>
    pub fn key_name(&self) -> std::option::Option<&str> {
        self.key_name.as_deref()
    }
    /// <p>The IAM profile ARN of the instance.</p>
    pub fn iam_instance_profile_arn(&self) -> std::option::Option<&str> {
        self.iam_instance_profile_arn.as_deref()
    }
    /// <p>The identifier of the VPC that the instance was launched in.</p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
    /// <p>The identifier of the subnet that the instance was launched in.</p>
    pub fn subnet_id(&self) -> std::option::Option<&str> {
        self.subnet_id.as_deref()
    }
    /// <p>Indicates when the instance was launched.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn launched_at(&self) -> std::option::Option<&str> {
        self.launched_at.as_deref()
    }
    /// <p>The identifiers of the network interfaces for the EC2 instance. The details for each network interface are in a corresponding <code>AwsEc2NetworkInterfacesDetails</code> object.</p>
    pub fn network_interfaces(
        &self,
    ) -> std::option::Option<&[crate::model::AwsEc2InstanceNetworkInterfacesDetails]> {
        self.network_interfaces.as_deref()
    }
    /// <p>The virtualization type of the Amazon Machine Image (AMI) required to launch the instance. </p>
    pub fn virtualization_type(&self) -> std::option::Option<&str> {
        self.virtualization_type.as_deref()
    }
    /// <p>Details about the metadata options for the Amazon EC2 instance. </p>
    pub fn metadata_options(
        &self,
    ) -> std::option::Option<&crate::model::AwsEc2InstanceMetadataOptions> {
        self.metadata_options.as_ref()
    }
}
impl std::fmt::Debug for AwsEc2InstanceDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2InstanceDetails");
        formatter.field("r#type", &self.r#type);
        formatter.field("image_id", &self.image_id);
        formatter.field("ip_v4_addresses", &self.ip_v4_addresses);
        formatter.field("ip_v6_addresses", &self.ip_v6_addresses);
        formatter.field("key_name", &self.key_name);
        formatter.field("iam_instance_profile_arn", &self.iam_instance_profile_arn);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("launched_at", &self.launched_at);
        formatter.field("network_interfaces", &self.network_interfaces);
        formatter.field("virtualization_type", &self.virtualization_type);
        formatter.field("metadata_options", &self.metadata_options);
        formatter.finish()
    }
}
/// See [`AwsEc2InstanceDetails`](crate::model::AwsEc2InstanceDetails)
pub mod aws_ec2_instance_details {

    /// A builder for [`AwsEc2InstanceDetails`](crate::model::AwsEc2InstanceDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) image_id: std::option::Option<std::string::String>,
        pub(crate) ip_v4_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) ip_v6_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) key_name: std::option::Option<std::string::String>,
        pub(crate) iam_instance_profile_arn: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) launched_at: std::option::Option<std::string::String>,
        pub(crate) network_interfaces: std::option::Option<
            std::vec::Vec<crate::model::AwsEc2InstanceNetworkInterfacesDetails>,
        >,
        pub(crate) virtualization_type: std::option::Option<std::string::String>,
        pub(crate) metadata_options:
            std::option::Option<crate::model::AwsEc2InstanceMetadataOptions>,
    }
    impl Builder {
        /// <p>The instance type of the instance. </p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The instance type of the instance. </p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The Amazon Machine Image (AMI) ID of the instance.</p>
        pub fn image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_id = Some(input.into());
            self
        }
        /// <p>The Amazon Machine Image (AMI) ID of the instance.</p>
        pub fn set_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_id = input;
            self
        }
        /// Appends an item to `ip_v4_addresses`.
        ///
        /// To override the contents of this collection use [`set_ip_v4_addresses`](Self::set_ip_v4_addresses).
        ///
        /// <p>The IPv4 addresses associated with the instance.</p>
        pub fn ip_v4_addresses(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ip_v4_addresses.unwrap_or_default();
            v.push(input.into());
            self.ip_v4_addresses = Some(v);
            self
        }
        /// <p>The IPv4 addresses associated with the instance.</p>
        pub fn set_ip_v4_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ip_v4_addresses = input;
            self
        }
        /// Appends an item to `ip_v6_addresses`.
        ///
        /// To override the contents of this collection use [`set_ip_v6_addresses`](Self::set_ip_v6_addresses).
        ///
        /// <p>The IPv6 addresses associated with the instance.</p>
        pub fn ip_v6_addresses(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ip_v6_addresses.unwrap_or_default();
            v.push(input.into());
            self.ip_v6_addresses = Some(v);
            self
        }
        /// <p>The IPv6 addresses associated with the instance.</p>
        pub fn set_ip_v6_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ip_v6_addresses = input;
            self
        }
        /// <p>The key name associated with the instance.</p>
        pub fn key_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_name = Some(input.into());
            self
        }
        /// <p>The key name associated with the instance.</p>
        pub fn set_key_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_name = input;
            self
        }
        /// <p>The IAM profile ARN of the instance.</p>
        pub fn iam_instance_profile_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.iam_instance_profile_arn = Some(input.into());
            self
        }
        /// <p>The IAM profile ARN of the instance.</p>
        pub fn set_iam_instance_profile_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.iam_instance_profile_arn = input;
            self
        }
        /// <p>The identifier of the VPC that the instance was launched in.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The identifier of the VPC that the instance was launched in.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// <p>The identifier of the subnet that the instance was launched in.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        /// <p>The identifier of the subnet that the instance was launched in.</p>
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>Indicates when the instance was launched.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn launched_at(mut self, input: impl Into<std::string::String>) -> Self {
            self.launched_at = Some(input.into());
            self
        }
        /// <p>Indicates when the instance was launched.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_launched_at(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.launched_at = input;
            self
        }
        /// Appends an item to `network_interfaces`.
        ///
        /// To override the contents of this collection use [`set_network_interfaces`](Self::set_network_interfaces).
        ///
        /// <p>The identifiers of the network interfaces for the EC2 instance. The details for each network interface are in a corresponding <code>AwsEc2NetworkInterfacesDetails</code> object.</p>
        pub fn network_interfaces(
            mut self,
            input: crate::model::AwsEc2InstanceNetworkInterfacesDetails,
        ) -> Self {
            let mut v = self.network_interfaces.unwrap_or_default();
            v.push(input);
            self.network_interfaces = Some(v);
            self
        }
        /// <p>The identifiers of the network interfaces for the EC2 instance. The details for each network interface are in a corresponding <code>AwsEc2NetworkInterfacesDetails</code> object.</p>
        pub fn set_network_interfaces(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEc2InstanceNetworkInterfacesDetails>,
            >,
        ) -> Self {
            self.network_interfaces = input;
            self
        }
        /// <p>The virtualization type of the Amazon Machine Image (AMI) required to launch the instance. </p>
        pub fn virtualization_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.virtualization_type = Some(input.into());
            self
        }
        /// <p>The virtualization type of the Amazon Machine Image (AMI) required to launch the instance. </p>
        pub fn set_virtualization_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.virtualization_type = input;
            self
        }
        /// <p>Details about the metadata options for the Amazon EC2 instance. </p>
        pub fn metadata_options(
            mut self,
            input: crate::model::AwsEc2InstanceMetadataOptions,
        ) -> Self {
            self.metadata_options = Some(input);
            self
        }
        /// <p>Details about the metadata options for the Amazon EC2 instance. </p>
        pub fn set_metadata_options(
            mut self,
            input: std::option::Option<crate::model::AwsEc2InstanceMetadataOptions>,
        ) -> Self {
            self.metadata_options = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2InstanceDetails`](crate::model::AwsEc2InstanceDetails)
        pub fn build(self) -> crate::model::AwsEc2InstanceDetails {
            crate::model::AwsEc2InstanceDetails {
                r#type: self.r#type,
                image_id: self.image_id,
                ip_v4_addresses: self.ip_v4_addresses,
                ip_v6_addresses: self.ip_v6_addresses,
                key_name: self.key_name,
                iam_instance_profile_arn: self.iam_instance_profile_arn,
                vpc_id: self.vpc_id,
                subnet_id: self.subnet_id,
                launched_at: self.launched_at,
                network_interfaces: self.network_interfaces,
                virtualization_type: self.virtualization_type,
                metadata_options: self.metadata_options,
            }
        }
    }
}
impl AwsEc2InstanceDetails {
    /// Creates a new builder-style object to manufacture [`AwsEc2InstanceDetails`](crate::model::AwsEc2InstanceDetails)
    pub fn builder() -> crate::model::aws_ec2_instance_details::Builder {
        crate::model::aws_ec2_instance_details::Builder::default()
    }
}

/// <p>Metadata options that allow you to configure and secure the Amazon EC2 instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2InstanceMetadataOptions {
    /// <p>Enables or disables the HTTP metadata endpoint on the instance. </p>
    pub http_endpoint: std::option::Option<std::string::String>,
    /// <p>Enables or disables the IPv6 endpoint for the instance metadata service. </p>
    pub http_protocol_ipv6: std::option::Option<std::string::String>,
    /// <p>The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. </p>
    pub http_put_response_hop_limit: i32,
    /// <p>The state of token usage for your instance metadata requests. </p>
    pub http_tokens: std::option::Option<std::string::String>,
    /// <p>Specifies whether to allow access to instance tags from the instance metadata. </p>
    pub instance_metadata_tags: std::option::Option<std::string::String>,
}
impl AwsEc2InstanceMetadataOptions {
    /// <p>Enables or disables the HTTP metadata endpoint on the instance. </p>
    pub fn http_endpoint(&self) -> std::option::Option<&str> {
        self.http_endpoint.as_deref()
    }
    /// <p>Enables or disables the IPv6 endpoint for the instance metadata service. </p>
    pub fn http_protocol_ipv6(&self) -> std::option::Option<&str> {
        self.http_protocol_ipv6.as_deref()
    }
    /// <p>The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. </p>
    pub fn http_put_response_hop_limit(&self) -> i32 {
        self.http_put_response_hop_limit
    }
    /// <p>The state of token usage for your instance metadata requests. </p>
    pub fn http_tokens(&self) -> std::option::Option<&str> {
        self.http_tokens.as_deref()
    }
    /// <p>Specifies whether to allow access to instance tags from the instance metadata. </p>
    pub fn instance_metadata_tags(&self) -> std::option::Option<&str> {
        self.instance_metadata_tags.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2InstanceMetadataOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2InstanceMetadataOptions");
        formatter.field("http_endpoint", &self.http_endpoint);
        formatter.field("http_protocol_ipv6", &self.http_protocol_ipv6);
        formatter.field(
            "http_put_response_hop_limit",
            &self.http_put_response_hop_limit,
        );
        formatter.field("http_tokens", &self.http_tokens);
        formatter.field("instance_metadata_tags", &self.instance_metadata_tags);
        formatter.finish()
    }
}
/// See [`AwsEc2InstanceMetadataOptions`](crate::model::AwsEc2InstanceMetadataOptions)
pub mod aws_ec2_instance_metadata_options {

    /// A builder for [`AwsEc2InstanceMetadataOptions`](crate::model::AwsEc2InstanceMetadataOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) http_endpoint: std::option::Option<std::string::String>,
        pub(crate) http_protocol_ipv6: std::option::Option<std::string::String>,
        pub(crate) http_put_response_hop_limit: std::option::Option<i32>,
        pub(crate) http_tokens: std::option::Option<std::string::String>,
        pub(crate) instance_metadata_tags: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Enables or disables the HTTP metadata endpoint on the instance. </p>
        pub fn http_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.http_endpoint = Some(input.into());
            self
        }
        /// <p>Enables or disables the HTTP metadata endpoint on the instance. </p>
        pub fn set_http_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.http_endpoint = input;
            self
        }
        /// <p>Enables or disables the IPv6 endpoint for the instance metadata service. </p>
        pub fn http_protocol_ipv6(mut self, input: impl Into<std::string::String>) -> Self {
            self.http_protocol_ipv6 = Some(input.into());
            self
        }
        /// <p>Enables or disables the IPv6 endpoint for the instance metadata service. </p>
        pub fn set_http_protocol_ipv6(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.http_protocol_ipv6 = input;
            self
        }
        /// <p>The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. </p>
        pub fn http_put_response_hop_limit(mut self, input: i32) -> Self {
            self.http_put_response_hop_limit = Some(input);
            self
        }
        /// <p>The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. </p>
        pub fn set_http_put_response_hop_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.http_put_response_hop_limit = input;
            self
        }
        /// <p>The state of token usage for your instance metadata requests. </p>
        pub fn http_tokens(mut self, input: impl Into<std::string::String>) -> Self {
            self.http_tokens = Some(input.into());
            self
        }
        /// <p>The state of token usage for your instance metadata requests. </p>
        pub fn set_http_tokens(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.http_tokens = input;
            self
        }
        /// <p>Specifies whether to allow access to instance tags from the instance metadata. </p>
        pub fn instance_metadata_tags(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_metadata_tags = Some(input.into());
            self
        }
        /// <p>Specifies whether to allow access to instance tags from the instance metadata. </p>
        pub fn set_instance_metadata_tags(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_metadata_tags = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2InstanceMetadataOptions`](crate::model::AwsEc2InstanceMetadataOptions)
        pub fn build(self) -> crate::model::AwsEc2InstanceMetadataOptions {
            crate::model::AwsEc2InstanceMetadataOptions {
                http_endpoint: self.http_endpoint,
                http_protocol_ipv6: self.http_protocol_ipv6,
                http_put_response_hop_limit: self.http_put_response_hop_limit.unwrap_or_default(),
                http_tokens: self.http_tokens,
                instance_metadata_tags: self.instance_metadata_tags,
            }
        }
    }
}
impl AwsEc2InstanceMetadataOptions {
    /// Creates a new builder-style object to manufacture [`AwsEc2InstanceMetadataOptions`](crate::model::AwsEc2InstanceMetadataOptions)
    pub fn builder() -> crate::model::aws_ec2_instance_metadata_options::Builder {
        crate::model::aws_ec2_instance_metadata_options::Builder::default()
    }
}

/// <p>Identifies a network interface for the Amazon EC2 instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2InstanceNetworkInterfacesDetails {
    /// <p>The identifier of the network interface. The details are in a corresponding <code>AwsEc2NetworkInterfacesDetails</code> object.</p>
    pub network_interface_id: std::option::Option<std::string::String>,
}
impl AwsEc2InstanceNetworkInterfacesDetails {
    /// <p>The identifier of the network interface. The details are in a corresponding <code>AwsEc2NetworkInterfacesDetails</code> object.</p>
    pub fn network_interface_id(&self) -> std::option::Option<&str> {
        self.network_interface_id.as_deref()
    }
}
impl std::fmt::Debug for AwsEc2InstanceNetworkInterfacesDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2InstanceNetworkInterfacesDetails");
        formatter.field("network_interface_id", &self.network_interface_id);
        formatter.finish()
    }
}
/// See [`AwsEc2InstanceNetworkInterfacesDetails`](crate::model::AwsEc2InstanceNetworkInterfacesDetails)
pub mod aws_ec2_instance_network_interfaces_details {

    /// A builder for [`AwsEc2InstanceNetworkInterfacesDetails`](crate::model::AwsEc2InstanceNetworkInterfacesDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) network_interface_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the network interface. The details are in a corresponding <code>AwsEc2NetworkInterfacesDetails</code> object.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_interface_id = Some(input.into());
            self
        }
        /// <p>The identifier of the network interface. The details are in a corresponding <code>AwsEc2NetworkInterfacesDetails</code> object.</p>
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_interface_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2InstanceNetworkInterfacesDetails`](crate::model::AwsEc2InstanceNetworkInterfacesDetails)
        pub fn build(self) -> crate::model::AwsEc2InstanceNetworkInterfacesDetails {
            crate::model::AwsEc2InstanceNetworkInterfacesDetails {
                network_interface_id: self.network_interface_id,
            }
        }
    }
}
impl AwsEc2InstanceNetworkInterfacesDetails {
    /// Creates a new builder-style object to manufacture [`AwsEc2InstanceNetworkInterfacesDetails`](crate::model::AwsEc2InstanceNetworkInterfacesDetails)
    pub fn builder() -> crate::model::aws_ec2_instance_network_interfaces_details::Builder {
        crate::model::aws_ec2_instance_network_interfaces_details::Builder::default()
    }
}

/// <p>A CloudFront distribution configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCloudFrontDistributionDetails {
    /// <p>Provides information about the cache configuration for the distribution.</p>
    pub cache_behaviors: std::option::Option<crate::model::AwsCloudFrontDistributionCacheBehaviors>,
    /// <p>The default cache behavior for the configuration.</p>
    pub default_cache_behavior:
        std::option::Option<crate::model::AwsCloudFrontDistributionDefaultCacheBehavior>,
    /// <p>The object that CloudFront sends in response to requests from the origin (for example, index.html) when a viewer requests the root URL for the distribution (http://www.example.com) instead of an object in your distribution (http://www.example.com/product-description.html). </p>
    pub default_root_object: std::option::Option<std::string::String>,
    /// <p>The domain name corresponding to the distribution.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The entity tag is a hash of the object.</p>
    pub e_tag: std::option::Option<std::string::String>,
    /// <p>Indicates when that the distribution was last modified.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub last_modified_time: std::option::Option<std::string::String>,
    /// <p>A complex type that controls whether access logs are written for the distribution.</p>
    pub logging: std::option::Option<crate::model::AwsCloudFrontDistributionLogging>,
    /// <p>A complex type that contains information about origins for this distribution.</p>
    pub origins: std::option::Option<crate::model::AwsCloudFrontDistributionOrigins>,
    /// <p>Provides information about the origin groups in the distribution.</p>
    pub origin_groups: std::option::Option<crate::model::AwsCloudFrontDistributionOriginGroups>,
    /// <p>Provides information about the TLS/SSL configuration that the distribution uses to communicate with viewers.</p>
    pub viewer_certificate:
        std::option::Option<crate::model::AwsCloudFrontDistributionViewerCertificate>,
    /// <p>Indicates the current status of the distribution.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>A unique identifier that specifies the WAF web ACL, if any, to associate with this distribution.</p>
    pub web_acl_id: std::option::Option<std::string::String>,
}
impl AwsCloudFrontDistributionDetails {
    /// <p>Provides information about the cache configuration for the distribution.</p>
    pub fn cache_behaviors(
        &self,
    ) -> std::option::Option<&crate::model::AwsCloudFrontDistributionCacheBehaviors> {
        self.cache_behaviors.as_ref()
    }
    /// <p>The default cache behavior for the configuration.</p>
    pub fn default_cache_behavior(
        &self,
    ) -> std::option::Option<&crate::model::AwsCloudFrontDistributionDefaultCacheBehavior> {
        self.default_cache_behavior.as_ref()
    }
    /// <p>The object that CloudFront sends in response to requests from the origin (for example, index.html) when a viewer requests the root URL for the distribution (http://www.example.com) instead of an object in your distribution (http://www.example.com/product-description.html). </p>
    pub fn default_root_object(&self) -> std::option::Option<&str> {
        self.default_root_object.as_deref()
    }
    /// <p>The domain name corresponding to the distribution.</p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p>The entity tag is a hash of the object.</p>
    pub fn e_tag(&self) -> std::option::Option<&str> {
        self.e_tag.as_deref()
    }
    /// <p>Indicates when that the distribution was last modified.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&str> {
        self.last_modified_time.as_deref()
    }
    /// <p>A complex type that controls whether access logs are written for the distribution.</p>
    pub fn logging(&self) -> std::option::Option<&crate::model::AwsCloudFrontDistributionLogging> {
        self.logging.as_ref()
    }
    /// <p>A complex type that contains information about origins for this distribution.</p>
    pub fn origins(&self) -> std::option::Option<&crate::model::AwsCloudFrontDistributionOrigins> {
        self.origins.as_ref()
    }
    /// <p>Provides information about the origin groups in the distribution.</p>
    pub fn origin_groups(
        &self,
    ) -> std::option::Option<&crate::model::AwsCloudFrontDistributionOriginGroups> {
        self.origin_groups.as_ref()
    }
    /// <p>Provides information about the TLS/SSL configuration that the distribution uses to communicate with viewers.</p>
    pub fn viewer_certificate(
        &self,
    ) -> std::option::Option<&crate::model::AwsCloudFrontDistributionViewerCertificate> {
        self.viewer_certificate.as_ref()
    }
    /// <p>Indicates the current status of the distribution.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>A unique identifier that specifies the WAF web ACL, if any, to associate with this distribution.</p>
    pub fn web_acl_id(&self) -> std::option::Option<&str> {
        self.web_acl_id.as_deref()
    }
}
impl std::fmt::Debug for AwsCloudFrontDistributionDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCloudFrontDistributionDetails");
        formatter.field("cache_behaviors", &self.cache_behaviors);
        formatter.field("default_cache_behavior", &self.default_cache_behavior);
        formatter.field("default_root_object", &self.default_root_object);
        formatter.field("domain_name", &self.domain_name);
        formatter.field("e_tag", &self.e_tag);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("logging", &self.logging);
        formatter.field("origins", &self.origins);
        formatter.field("origin_groups", &self.origin_groups);
        formatter.field("viewer_certificate", &self.viewer_certificate);
        formatter.field("status", &self.status);
        formatter.field("web_acl_id", &self.web_acl_id);
        formatter.finish()
    }
}
/// See [`AwsCloudFrontDistributionDetails`](crate::model::AwsCloudFrontDistributionDetails)
pub mod aws_cloud_front_distribution_details {

    /// A builder for [`AwsCloudFrontDistributionDetails`](crate::model::AwsCloudFrontDistributionDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cache_behaviors:
            std::option::Option<crate::model::AwsCloudFrontDistributionCacheBehaviors>,
        pub(crate) default_cache_behavior:
            std::option::Option<crate::model::AwsCloudFrontDistributionDefaultCacheBehavior>,
        pub(crate) default_root_object: std::option::Option<std::string::String>,
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) e_tag: std::option::Option<std::string::String>,
        pub(crate) last_modified_time: std::option::Option<std::string::String>,
        pub(crate) logging: std::option::Option<crate::model::AwsCloudFrontDistributionLogging>,
        pub(crate) origins: std::option::Option<crate::model::AwsCloudFrontDistributionOrigins>,
        pub(crate) origin_groups:
            std::option::Option<crate::model::AwsCloudFrontDistributionOriginGroups>,
        pub(crate) viewer_certificate:
            std::option::Option<crate::model::AwsCloudFrontDistributionViewerCertificate>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) web_acl_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Provides information about the cache configuration for the distribution.</p>
        pub fn cache_behaviors(
            mut self,
            input: crate::model::AwsCloudFrontDistributionCacheBehaviors,
        ) -> Self {
            self.cache_behaviors = Some(input);
            self
        }
        /// <p>Provides information about the cache configuration for the distribution.</p>
        pub fn set_cache_behaviors(
            mut self,
            input: std::option::Option<crate::model::AwsCloudFrontDistributionCacheBehaviors>,
        ) -> Self {
            self.cache_behaviors = input;
            self
        }
        /// <p>The default cache behavior for the configuration.</p>
        pub fn default_cache_behavior(
            mut self,
            input: crate::model::AwsCloudFrontDistributionDefaultCacheBehavior,
        ) -> Self {
            self.default_cache_behavior = Some(input);
            self
        }
        /// <p>The default cache behavior for the configuration.</p>
        pub fn set_default_cache_behavior(
            mut self,
            input: std::option::Option<crate::model::AwsCloudFrontDistributionDefaultCacheBehavior>,
        ) -> Self {
            self.default_cache_behavior = input;
            self
        }
        /// <p>The object that CloudFront sends in response to requests from the origin (for example, index.html) when a viewer requests the root URL for the distribution (http://www.example.com) instead of an object in your distribution (http://www.example.com/product-description.html). </p>
        pub fn default_root_object(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_root_object = Some(input.into());
            self
        }
        /// <p>The object that CloudFront sends in response to requests from the origin (for example, index.html) when a viewer requests the root URL for the distribution (http://www.example.com) instead of an object in your distribution (http://www.example.com/product-description.html). </p>
        pub fn set_default_root_object(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_root_object = input;
            self
        }
        /// <p>The domain name corresponding to the distribution.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>The domain name corresponding to the distribution.</p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>The entity tag is a hash of the object.</p>
        pub fn e_tag(mut self, input: impl Into<std::string::String>) -> Self {
            self.e_tag = Some(input.into());
            self
        }
        /// <p>The entity tag is a hash of the object.</p>
        pub fn set_e_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.e_tag = input;
            self
        }
        /// <p>Indicates when that the distribution was last modified.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn last_modified_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_time = Some(input.into());
            self
        }
        /// <p>Indicates when that the distribution was last modified.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>A complex type that controls whether access logs are written for the distribution.</p>
        pub fn logging(mut self, input: crate::model::AwsCloudFrontDistributionLogging) -> Self {
            self.logging = Some(input);
            self
        }
        /// <p>A complex type that controls whether access logs are written for the distribution.</p>
        pub fn set_logging(
            mut self,
            input: std::option::Option<crate::model::AwsCloudFrontDistributionLogging>,
        ) -> Self {
            self.logging = input;
            self
        }
        /// <p>A complex type that contains information about origins for this distribution.</p>
        pub fn origins(mut self, input: crate::model::AwsCloudFrontDistributionOrigins) -> Self {
            self.origins = Some(input);
            self
        }
        /// <p>A complex type that contains information about origins for this distribution.</p>
        pub fn set_origins(
            mut self,
            input: std::option::Option<crate::model::AwsCloudFrontDistributionOrigins>,
        ) -> Self {
            self.origins = input;
            self
        }
        /// <p>Provides information about the origin groups in the distribution.</p>
        pub fn origin_groups(
            mut self,
            input: crate::model::AwsCloudFrontDistributionOriginGroups,
        ) -> Self {
            self.origin_groups = Some(input);
            self
        }
        /// <p>Provides information about the origin groups in the distribution.</p>
        pub fn set_origin_groups(
            mut self,
            input: std::option::Option<crate::model::AwsCloudFrontDistributionOriginGroups>,
        ) -> Self {
            self.origin_groups = input;
            self
        }
        /// <p>Provides information about the TLS/SSL configuration that the distribution uses to communicate with viewers.</p>
        pub fn viewer_certificate(
            mut self,
            input: crate::model::AwsCloudFrontDistributionViewerCertificate,
        ) -> Self {
            self.viewer_certificate = Some(input);
            self
        }
        /// <p>Provides information about the TLS/SSL configuration that the distribution uses to communicate with viewers.</p>
        pub fn set_viewer_certificate(
            mut self,
            input: std::option::Option<crate::model::AwsCloudFrontDistributionViewerCertificate>,
        ) -> Self {
            self.viewer_certificate = input;
            self
        }
        /// <p>Indicates the current status of the distribution.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>Indicates the current status of the distribution.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>A unique identifier that specifies the WAF web ACL, if any, to associate with this distribution.</p>
        pub fn web_acl_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.web_acl_id = Some(input.into());
            self
        }
        /// <p>A unique identifier that specifies the WAF web ACL, if any, to associate with this distribution.</p>
        pub fn set_web_acl_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.web_acl_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCloudFrontDistributionDetails`](crate::model::AwsCloudFrontDistributionDetails)
        pub fn build(self) -> crate::model::AwsCloudFrontDistributionDetails {
            crate::model::AwsCloudFrontDistributionDetails {
                cache_behaviors: self.cache_behaviors,
                default_cache_behavior: self.default_cache_behavior,
                default_root_object: self.default_root_object,
                domain_name: self.domain_name,
                e_tag: self.e_tag,
                last_modified_time: self.last_modified_time,
                logging: self.logging,
                origins: self.origins,
                origin_groups: self.origin_groups,
                viewer_certificate: self.viewer_certificate,
                status: self.status,
                web_acl_id: self.web_acl_id,
            }
        }
    }
}
impl AwsCloudFrontDistributionDetails {
    /// Creates a new builder-style object to manufacture [`AwsCloudFrontDistributionDetails`](crate::model::AwsCloudFrontDistributionDetails)
    pub fn builder() -> crate::model::aws_cloud_front_distribution_details::Builder {
        crate::model::aws_cloud_front_distribution_details::Builder::default()
    }
}

/// <p>Provides information about the TLS/SSL configuration that the CloudFront distribution uses to communicate with viewers.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCloudFrontDistributionViewerCertificate {
    /// <p>The ARN of the ACM certificate. Used if the certificate is stored in ACM. If you provide an ACM certificate ARN, you must also provide <code>MinimumCertificateVersion</code> and <code>SslSupportMethod</code>.</p>
    pub acm_certificate_arn: std::option::Option<std::string::String>,
    /// <p>The identifier of the certificate. Note that in CloudFront, this attribute is deprecated.</p>
    pub certificate: std::option::Option<std::string::String>,
    /// <p>The source of the certificate identified by <code>Certificate</code>. Note that in CloudFront, this attribute is deprecated.</p>
    pub certificate_source: std::option::Option<std::string::String>,
    /// <p>Whether the distribution uses the CloudFront domain name. If set to <code>false</code>, then you provide either <code>AcmCertificateArn</code> or <code>IamCertificateId</code>.</p>
    pub cloud_front_default_certificate: bool,
    /// <p>The identifier of the IAM certificate. Used if the certificate is stored in IAM. If you provide <code>IamCertificateId</code>, then you also must provide <code>MinimumProtocolVersion</code> and <code>SslSupportMethod</code>.</p>
    pub iam_certificate_id: std::option::Option<std::string::String>,
    /// <p>The security policy that CloudFront uses for HTTPS connections with viewers. If <code>SslSupportMethod</code> is <code>sni-only</code>, then <code>MinimumProtocolVersion</code> must be <code>TLSv1</code> or higher.</p>
    pub minimum_protocol_version: std::option::Option<std::string::String>,
    /// <p>The viewers that the distribution accepts HTTPS connections from.</p>
    pub ssl_support_method: std::option::Option<std::string::String>,
}
impl AwsCloudFrontDistributionViewerCertificate {
    /// <p>The ARN of the ACM certificate. Used if the certificate is stored in ACM. If you provide an ACM certificate ARN, you must also provide <code>MinimumCertificateVersion</code> and <code>SslSupportMethod</code>.</p>
    pub fn acm_certificate_arn(&self) -> std::option::Option<&str> {
        self.acm_certificate_arn.as_deref()
    }
    /// <p>The identifier of the certificate. Note that in CloudFront, this attribute is deprecated.</p>
    pub fn certificate(&self) -> std::option::Option<&str> {
        self.certificate.as_deref()
    }
    /// <p>The source of the certificate identified by <code>Certificate</code>. Note that in CloudFront, this attribute is deprecated.</p>
    pub fn certificate_source(&self) -> std::option::Option<&str> {
        self.certificate_source.as_deref()
    }
    /// <p>Whether the distribution uses the CloudFront domain name. If set to <code>false</code>, then you provide either <code>AcmCertificateArn</code> or <code>IamCertificateId</code>.</p>
    pub fn cloud_front_default_certificate(&self) -> bool {
        self.cloud_front_default_certificate
    }
    /// <p>The identifier of the IAM certificate. Used if the certificate is stored in IAM. If you provide <code>IamCertificateId</code>, then you also must provide <code>MinimumProtocolVersion</code> and <code>SslSupportMethod</code>.</p>
    pub fn iam_certificate_id(&self) -> std::option::Option<&str> {
        self.iam_certificate_id.as_deref()
    }
    /// <p>The security policy that CloudFront uses for HTTPS connections with viewers. If <code>SslSupportMethod</code> is <code>sni-only</code>, then <code>MinimumProtocolVersion</code> must be <code>TLSv1</code> or higher.</p>
    pub fn minimum_protocol_version(&self) -> std::option::Option<&str> {
        self.minimum_protocol_version.as_deref()
    }
    /// <p>The viewers that the distribution accepts HTTPS connections from.</p>
    pub fn ssl_support_method(&self) -> std::option::Option<&str> {
        self.ssl_support_method.as_deref()
    }
}
impl std::fmt::Debug for AwsCloudFrontDistributionViewerCertificate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCloudFrontDistributionViewerCertificate");
        formatter.field("acm_certificate_arn", &self.acm_certificate_arn);
        formatter.field("certificate", &self.certificate);
        formatter.field("certificate_source", &self.certificate_source);
        formatter.field(
            "cloud_front_default_certificate",
            &self.cloud_front_default_certificate,
        );
        formatter.field("iam_certificate_id", &self.iam_certificate_id);
        formatter.field("minimum_protocol_version", &self.minimum_protocol_version);
        formatter.field("ssl_support_method", &self.ssl_support_method);
        formatter.finish()
    }
}
/// See [`AwsCloudFrontDistributionViewerCertificate`](crate::model::AwsCloudFrontDistributionViewerCertificate)
pub mod aws_cloud_front_distribution_viewer_certificate {

    /// A builder for [`AwsCloudFrontDistributionViewerCertificate`](crate::model::AwsCloudFrontDistributionViewerCertificate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) acm_certificate_arn: std::option::Option<std::string::String>,
        pub(crate) certificate: std::option::Option<std::string::String>,
        pub(crate) certificate_source: std::option::Option<std::string::String>,
        pub(crate) cloud_front_default_certificate: std::option::Option<bool>,
        pub(crate) iam_certificate_id: std::option::Option<std::string::String>,
        pub(crate) minimum_protocol_version: std::option::Option<std::string::String>,
        pub(crate) ssl_support_method: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the ACM certificate. Used if the certificate is stored in ACM. If you provide an ACM certificate ARN, you must also provide <code>MinimumCertificateVersion</code> and <code>SslSupportMethod</code>.</p>
        pub fn acm_certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.acm_certificate_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the ACM certificate. Used if the certificate is stored in ACM. If you provide an ACM certificate ARN, you must also provide <code>MinimumCertificateVersion</code> and <code>SslSupportMethod</code>.</p>
        pub fn set_acm_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.acm_certificate_arn = input;
            self
        }
        /// <p>The identifier of the certificate. Note that in CloudFront, this attribute is deprecated.</p>
        pub fn certificate(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate = Some(input.into());
            self
        }
        /// <p>The identifier of the certificate. Note that in CloudFront, this attribute is deprecated.</p>
        pub fn set_certificate(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.certificate = input;
            self
        }
        /// <p>The source of the certificate identified by <code>Certificate</code>. Note that in CloudFront, this attribute is deprecated.</p>
        pub fn certificate_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_source = Some(input.into());
            self
        }
        /// <p>The source of the certificate identified by <code>Certificate</code>. Note that in CloudFront, this attribute is deprecated.</p>
        pub fn set_certificate_source(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_source = input;
            self
        }
        /// <p>Whether the distribution uses the CloudFront domain name. If set to <code>false</code>, then you provide either <code>AcmCertificateArn</code> or <code>IamCertificateId</code>.</p>
        pub fn cloud_front_default_certificate(mut self, input: bool) -> Self {
            self.cloud_front_default_certificate = Some(input);
            self
        }
        /// <p>Whether the distribution uses the CloudFront domain name. If set to <code>false</code>, then you provide either <code>AcmCertificateArn</code> or <code>IamCertificateId</code>.</p>
        pub fn set_cloud_front_default_certificate(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.cloud_front_default_certificate = input;
            self
        }
        /// <p>The identifier of the IAM certificate. Used if the certificate is stored in IAM. If you provide <code>IamCertificateId</code>, then you also must provide <code>MinimumProtocolVersion</code> and <code>SslSupportMethod</code>.</p>
        pub fn iam_certificate_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.iam_certificate_id = Some(input.into());
            self
        }
        /// <p>The identifier of the IAM certificate. Used if the certificate is stored in IAM. If you provide <code>IamCertificateId</code>, then you also must provide <code>MinimumProtocolVersion</code> and <code>SslSupportMethod</code>.</p>
        pub fn set_iam_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.iam_certificate_id = input;
            self
        }
        /// <p>The security policy that CloudFront uses for HTTPS connections with viewers. If <code>SslSupportMethod</code> is <code>sni-only</code>, then <code>MinimumProtocolVersion</code> must be <code>TLSv1</code> or higher.</p>
        pub fn minimum_protocol_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.minimum_protocol_version = Some(input.into());
            self
        }
        /// <p>The security policy that CloudFront uses for HTTPS connections with viewers. If <code>SslSupportMethod</code> is <code>sni-only</code>, then <code>MinimumProtocolVersion</code> must be <code>TLSv1</code> or higher.</p>
        pub fn set_minimum_protocol_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.minimum_protocol_version = input;
            self
        }
        /// <p>The viewers that the distribution accepts HTTPS connections from.</p>
        pub fn ssl_support_method(mut self, input: impl Into<std::string::String>) -> Self {
            self.ssl_support_method = Some(input.into());
            self
        }
        /// <p>The viewers that the distribution accepts HTTPS connections from.</p>
        pub fn set_ssl_support_method(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ssl_support_method = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCloudFrontDistributionViewerCertificate`](crate::model::AwsCloudFrontDistributionViewerCertificate)
        pub fn build(self) -> crate::model::AwsCloudFrontDistributionViewerCertificate {
            crate::model::AwsCloudFrontDistributionViewerCertificate {
                acm_certificate_arn: self.acm_certificate_arn,
                certificate: self.certificate,
                certificate_source: self.certificate_source,
                cloud_front_default_certificate: self
                    .cloud_front_default_certificate
                    .unwrap_or_default(),
                iam_certificate_id: self.iam_certificate_id,
                minimum_protocol_version: self.minimum_protocol_version,
                ssl_support_method: self.ssl_support_method,
            }
        }
    }
}
impl AwsCloudFrontDistributionViewerCertificate {
    /// Creates a new builder-style object to manufacture [`AwsCloudFrontDistributionViewerCertificate`](crate::model::AwsCloudFrontDistributionViewerCertificate)
    pub fn builder() -> crate::model::aws_cloud_front_distribution_viewer_certificate::Builder {
        crate::model::aws_cloud_front_distribution_viewer_certificate::Builder::default()
    }
}

/// <p>Provides information about origin groups that are associated with the CloudFront distribution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCloudFrontDistributionOriginGroups {
    /// <p>The list of origin groups.</p>
    pub items:
        std::option::Option<std::vec::Vec<crate::model::AwsCloudFrontDistributionOriginGroup>>,
}
impl AwsCloudFrontDistributionOriginGroups {
    /// <p>The list of origin groups.</p>
    pub fn items(
        &self,
    ) -> std::option::Option<&[crate::model::AwsCloudFrontDistributionOriginGroup]> {
        self.items.as_deref()
    }
}
impl std::fmt::Debug for AwsCloudFrontDistributionOriginGroups {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCloudFrontDistributionOriginGroups");
        formatter.field("items", &self.items);
        formatter.finish()
    }
}
/// See [`AwsCloudFrontDistributionOriginGroups`](crate::model::AwsCloudFrontDistributionOriginGroups)
pub mod aws_cloud_front_distribution_origin_groups {

    /// A builder for [`AwsCloudFrontDistributionOriginGroups`](crate::model::AwsCloudFrontDistributionOriginGroups)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) items:
            std::option::Option<std::vec::Vec<crate::model::AwsCloudFrontDistributionOriginGroup>>,
    }
    impl Builder {
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>The list of origin groups.</p>
        pub fn items(mut self, input: crate::model::AwsCloudFrontDistributionOriginGroup) -> Self {
            let mut v = self.items.unwrap_or_default();
            v.push(input);
            self.items = Some(v);
            self
        }
        /// <p>The list of origin groups.</p>
        pub fn set_items(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsCloudFrontDistributionOriginGroup>,
            >,
        ) -> Self {
            self.items = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCloudFrontDistributionOriginGroups`](crate::model::AwsCloudFrontDistributionOriginGroups)
        pub fn build(self) -> crate::model::AwsCloudFrontDistributionOriginGroups {
            crate::model::AwsCloudFrontDistributionOriginGroups { items: self.items }
        }
    }
}
impl AwsCloudFrontDistributionOriginGroups {
    /// Creates a new builder-style object to manufacture [`AwsCloudFrontDistributionOriginGroups`](crate::model::AwsCloudFrontDistributionOriginGroups)
    pub fn builder() -> crate::model::aws_cloud_front_distribution_origin_groups::Builder {
        crate::model::aws_cloud_front_distribution_origin_groups::Builder::default()
    }
}

/// <p>Information about an origin group for the CloudFront distribution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCloudFrontDistributionOriginGroup {
    /// <p>Provides the criteria for an origin group to fail over.</p>
    pub failover_criteria:
        std::option::Option<crate::model::AwsCloudFrontDistributionOriginGroupFailover>,
}
impl AwsCloudFrontDistributionOriginGroup {
    /// <p>Provides the criteria for an origin group to fail over.</p>
    pub fn failover_criteria(
        &self,
    ) -> std::option::Option<&crate::model::AwsCloudFrontDistributionOriginGroupFailover> {
        self.failover_criteria.as_ref()
    }
}
impl std::fmt::Debug for AwsCloudFrontDistributionOriginGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCloudFrontDistributionOriginGroup");
        formatter.field("failover_criteria", &self.failover_criteria);
        formatter.finish()
    }
}
/// See [`AwsCloudFrontDistributionOriginGroup`](crate::model::AwsCloudFrontDistributionOriginGroup)
pub mod aws_cloud_front_distribution_origin_group {

    /// A builder for [`AwsCloudFrontDistributionOriginGroup`](crate::model::AwsCloudFrontDistributionOriginGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) failover_criteria:
            std::option::Option<crate::model::AwsCloudFrontDistributionOriginGroupFailover>,
    }
    impl Builder {
        /// <p>Provides the criteria for an origin group to fail over.</p>
        pub fn failover_criteria(
            mut self,
            input: crate::model::AwsCloudFrontDistributionOriginGroupFailover,
        ) -> Self {
            self.failover_criteria = Some(input);
            self
        }
        /// <p>Provides the criteria for an origin group to fail over.</p>
        pub fn set_failover_criteria(
            mut self,
            input: std::option::Option<crate::model::AwsCloudFrontDistributionOriginGroupFailover>,
        ) -> Self {
            self.failover_criteria = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCloudFrontDistributionOriginGroup`](crate::model::AwsCloudFrontDistributionOriginGroup)
        pub fn build(self) -> crate::model::AwsCloudFrontDistributionOriginGroup {
            crate::model::AwsCloudFrontDistributionOriginGroup {
                failover_criteria: self.failover_criteria,
            }
        }
    }
}
impl AwsCloudFrontDistributionOriginGroup {
    /// Creates a new builder-style object to manufacture [`AwsCloudFrontDistributionOriginGroup`](crate::model::AwsCloudFrontDistributionOriginGroup)
    pub fn builder() -> crate::model::aws_cloud_front_distribution_origin_group::Builder {
        crate::model::aws_cloud_front_distribution_origin_group::Builder::default()
    }
}

/// <p>Provides information about when an origin group fails over.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCloudFrontDistributionOriginGroupFailover {
    /// <p>Information about the status codes that cause an origin group to fail over.</p>
    pub status_codes:
        std::option::Option<crate::model::AwsCloudFrontDistributionOriginGroupFailoverStatusCodes>,
}
impl AwsCloudFrontDistributionOriginGroupFailover {
    /// <p>Information about the status codes that cause an origin group to fail over.</p>
    pub fn status_codes(
        &self,
    ) -> std::option::Option<&crate::model::AwsCloudFrontDistributionOriginGroupFailoverStatusCodes>
    {
        self.status_codes.as_ref()
    }
}
impl std::fmt::Debug for AwsCloudFrontDistributionOriginGroupFailover {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCloudFrontDistributionOriginGroupFailover");
        formatter.field("status_codes", &self.status_codes);
        formatter.finish()
    }
}
/// See [`AwsCloudFrontDistributionOriginGroupFailover`](crate::model::AwsCloudFrontDistributionOriginGroupFailover)
pub mod aws_cloud_front_distribution_origin_group_failover {

    /// A builder for [`AwsCloudFrontDistributionOriginGroupFailover`](crate::model::AwsCloudFrontDistributionOriginGroupFailover)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status_codes: std::option::Option<
            crate::model::AwsCloudFrontDistributionOriginGroupFailoverStatusCodes,
        >,
    }
    impl Builder {
        /// <p>Information about the status codes that cause an origin group to fail over.</p>
        pub fn status_codes(
            mut self,
            input: crate::model::AwsCloudFrontDistributionOriginGroupFailoverStatusCodes,
        ) -> Self {
            self.status_codes = Some(input);
            self
        }
        /// <p>Information about the status codes that cause an origin group to fail over.</p>
        pub fn set_status_codes(
            mut self,
            input: std::option::Option<
                crate::model::AwsCloudFrontDistributionOriginGroupFailoverStatusCodes,
            >,
        ) -> Self {
            self.status_codes = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCloudFrontDistributionOriginGroupFailover`](crate::model::AwsCloudFrontDistributionOriginGroupFailover)
        pub fn build(self) -> crate::model::AwsCloudFrontDistributionOriginGroupFailover {
            crate::model::AwsCloudFrontDistributionOriginGroupFailover {
                status_codes: self.status_codes,
            }
        }
    }
}
impl AwsCloudFrontDistributionOriginGroupFailover {
    /// Creates a new builder-style object to manufacture [`AwsCloudFrontDistributionOriginGroupFailover`](crate::model::AwsCloudFrontDistributionOriginGroupFailover)
    pub fn builder() -> crate::model::aws_cloud_front_distribution_origin_group_failover::Builder {
        crate::model::aws_cloud_front_distribution_origin_group_failover::Builder::default()
    }
}

/// <p>The status codes that cause an origin group to fail over.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCloudFrontDistributionOriginGroupFailoverStatusCodes {
    /// <p>The list of status code values that can cause a failover to the next origin.</p>
    pub items: std::option::Option<std::vec::Vec<i32>>,
    /// <p>The number of status codes that can cause a failover.</p>
    pub quantity: i32,
}
impl AwsCloudFrontDistributionOriginGroupFailoverStatusCodes {
    /// <p>The list of status code values that can cause a failover to the next origin.</p>
    pub fn items(&self) -> std::option::Option<&[i32]> {
        self.items.as_deref()
    }
    /// <p>The number of status codes that can cause a failover.</p>
    pub fn quantity(&self) -> i32 {
        self.quantity
    }
}
impl std::fmt::Debug for AwsCloudFrontDistributionOriginGroupFailoverStatusCodes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsCloudFrontDistributionOriginGroupFailoverStatusCodes");
        formatter.field("items", &self.items);
        formatter.field("quantity", &self.quantity);
        formatter.finish()
    }
}
/// See [`AwsCloudFrontDistributionOriginGroupFailoverStatusCodes`](crate::model::AwsCloudFrontDistributionOriginGroupFailoverStatusCodes)
pub mod aws_cloud_front_distribution_origin_group_failover_status_codes {

    /// A builder for [`AwsCloudFrontDistributionOriginGroupFailoverStatusCodes`](crate::model::AwsCloudFrontDistributionOriginGroupFailoverStatusCodes)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) items: std::option::Option<std::vec::Vec<i32>>,
        pub(crate) quantity: std::option::Option<i32>,
    }
    impl Builder {
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>The list of status code values that can cause a failover to the next origin.</p>
        pub fn items(mut self, input: i32) -> Self {
            let mut v = self.items.unwrap_or_default();
            v.push(input);
            self.items = Some(v);
            self
        }
        /// <p>The list of status code values that can cause a failover to the next origin.</p>
        pub fn set_items(mut self, input: std::option::Option<std::vec::Vec<i32>>) -> Self {
            self.items = input;
            self
        }
        /// <p>The number of status codes that can cause a failover.</p>
        pub fn quantity(mut self, input: i32) -> Self {
            self.quantity = Some(input);
            self
        }
        /// <p>The number of status codes that can cause a failover.</p>
        pub fn set_quantity(mut self, input: std::option::Option<i32>) -> Self {
            self.quantity = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCloudFrontDistributionOriginGroupFailoverStatusCodes`](crate::model::AwsCloudFrontDistributionOriginGroupFailoverStatusCodes)
        pub fn build(
            self,
        ) -> crate::model::AwsCloudFrontDistributionOriginGroupFailoverStatusCodes {
            crate::model::AwsCloudFrontDistributionOriginGroupFailoverStatusCodes {
                items: self.items,
                quantity: self.quantity.unwrap_or_default(),
            }
        }
    }
}
impl AwsCloudFrontDistributionOriginGroupFailoverStatusCodes {
    /// Creates a new builder-style object to manufacture [`AwsCloudFrontDistributionOriginGroupFailoverStatusCodes`](crate::model::AwsCloudFrontDistributionOriginGroupFailoverStatusCodes)
    pub fn builder(
    ) -> crate::model::aws_cloud_front_distribution_origin_group_failover_status_codes::Builder
    {
        crate::model::aws_cloud_front_distribution_origin_group_failover_status_codes::Builder::default()
    }
}

/// <p>A complex type that contains information about origins and origin groups for this CloudFront distribution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCloudFrontDistributionOrigins {
    /// <p>A complex type that contains origins or origin groups for this distribution.</p>
    pub items:
        std::option::Option<std::vec::Vec<crate::model::AwsCloudFrontDistributionOriginItem>>,
}
impl AwsCloudFrontDistributionOrigins {
    /// <p>A complex type that contains origins or origin groups for this distribution.</p>
    pub fn items(
        &self,
    ) -> std::option::Option<&[crate::model::AwsCloudFrontDistributionOriginItem]> {
        self.items.as_deref()
    }
}
impl std::fmt::Debug for AwsCloudFrontDistributionOrigins {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCloudFrontDistributionOrigins");
        formatter.field("items", &self.items);
        formatter.finish()
    }
}
/// See [`AwsCloudFrontDistributionOrigins`](crate::model::AwsCloudFrontDistributionOrigins)
pub mod aws_cloud_front_distribution_origins {

    /// A builder for [`AwsCloudFrontDistributionOrigins`](crate::model::AwsCloudFrontDistributionOrigins)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) items:
            std::option::Option<std::vec::Vec<crate::model::AwsCloudFrontDistributionOriginItem>>,
    }
    impl Builder {
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>A complex type that contains origins or origin groups for this distribution.</p>
        pub fn items(mut self, input: crate::model::AwsCloudFrontDistributionOriginItem) -> Self {
            let mut v = self.items.unwrap_or_default();
            v.push(input);
            self.items = Some(v);
            self
        }
        /// <p>A complex type that contains origins or origin groups for this distribution.</p>
        pub fn set_items(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsCloudFrontDistributionOriginItem>,
            >,
        ) -> Self {
            self.items = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCloudFrontDistributionOrigins`](crate::model::AwsCloudFrontDistributionOrigins)
        pub fn build(self) -> crate::model::AwsCloudFrontDistributionOrigins {
            crate::model::AwsCloudFrontDistributionOrigins { items: self.items }
        }
    }
}
impl AwsCloudFrontDistributionOrigins {
    /// Creates a new builder-style object to manufacture [`AwsCloudFrontDistributionOrigins`](crate::model::AwsCloudFrontDistributionOrigins)
    pub fn builder() -> crate::model::aws_cloud_front_distribution_origins::Builder {
        crate::model::aws_cloud_front_distribution_origins::Builder::default()
    }
}

/// <p>A complex type that describes the Amazon S3 bucket, HTTP server (for example, a web server), AWS Elemental MediaStore, or other server from which CloudFront gets your files.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCloudFrontDistributionOriginItem {
    /// <p>Amazon S3 origins: The DNS name of the S3 bucket from which you want CloudFront to get objects for this origin.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the origin or origin group.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>An optional element that causes CloudFront to request your content from a directory in your Amazon S3 bucket or your custom origin.</p>
    pub origin_path: std::option::Option<std::string::String>,
    /// <p>An origin that is an S3 bucket that is not configured with static website hosting.</p>
    pub s3_origin_config:
        std::option::Option<crate::model::AwsCloudFrontDistributionOriginS3OriginConfig>,
    /// <p>An origin that is not an Amazon S3 bucket, with one exception. If the Amazon S3 bucket is configured with static website hosting, use this attribute. If the Amazon S3 bucket is not configured with static website hosting, use the <code>S3OriginConfig</code> type instead. </p>
    pub custom_origin_config:
        std::option::Option<crate::model::AwsCloudFrontDistributionOriginCustomOriginConfig>,
}
impl AwsCloudFrontDistributionOriginItem {
    /// <p>Amazon S3 origins: The DNS name of the S3 bucket from which you want CloudFront to get objects for this origin.</p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p>A unique identifier for the origin or origin group.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>An optional element that causes CloudFront to request your content from a directory in your Amazon S3 bucket or your custom origin.</p>
    pub fn origin_path(&self) -> std::option::Option<&str> {
        self.origin_path.as_deref()
    }
    /// <p>An origin that is an S3 bucket that is not configured with static website hosting.</p>
    pub fn s3_origin_config(
        &self,
    ) -> std::option::Option<&crate::model::AwsCloudFrontDistributionOriginS3OriginConfig> {
        self.s3_origin_config.as_ref()
    }
    /// <p>An origin that is not an Amazon S3 bucket, with one exception. If the Amazon S3 bucket is configured with static website hosting, use this attribute. If the Amazon S3 bucket is not configured with static website hosting, use the <code>S3OriginConfig</code> type instead. </p>
    pub fn custom_origin_config(
        &self,
    ) -> std::option::Option<&crate::model::AwsCloudFrontDistributionOriginCustomOriginConfig> {
        self.custom_origin_config.as_ref()
    }
}
impl std::fmt::Debug for AwsCloudFrontDistributionOriginItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCloudFrontDistributionOriginItem");
        formatter.field("domain_name", &self.domain_name);
        formatter.field("id", &self.id);
        formatter.field("origin_path", &self.origin_path);
        formatter.field("s3_origin_config", &self.s3_origin_config);
        formatter.field("custom_origin_config", &self.custom_origin_config);
        formatter.finish()
    }
}
/// See [`AwsCloudFrontDistributionOriginItem`](crate::model::AwsCloudFrontDistributionOriginItem)
pub mod aws_cloud_front_distribution_origin_item {

    /// A builder for [`AwsCloudFrontDistributionOriginItem`](crate::model::AwsCloudFrontDistributionOriginItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) origin_path: std::option::Option<std::string::String>,
        pub(crate) s3_origin_config:
            std::option::Option<crate::model::AwsCloudFrontDistributionOriginS3OriginConfig>,
        pub(crate) custom_origin_config:
            std::option::Option<crate::model::AwsCloudFrontDistributionOriginCustomOriginConfig>,
    }
    impl Builder {
        /// <p>Amazon S3 origins: The DNS name of the S3 bucket from which you want CloudFront to get objects for this origin.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>Amazon S3 origins: The DNS name of the S3 bucket from which you want CloudFront to get objects for this origin.</p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>A unique identifier for the origin or origin group.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the origin or origin group.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>An optional element that causes CloudFront to request your content from a directory in your Amazon S3 bucket or your custom origin.</p>
        pub fn origin_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.origin_path = Some(input.into());
            self
        }
        /// <p>An optional element that causes CloudFront to request your content from a directory in your Amazon S3 bucket or your custom origin.</p>
        pub fn set_origin_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.origin_path = input;
            self
        }
        /// <p>An origin that is an S3 bucket that is not configured with static website hosting.</p>
        pub fn s3_origin_config(
            mut self,
            input: crate::model::AwsCloudFrontDistributionOriginS3OriginConfig,
        ) -> Self {
            self.s3_origin_config = Some(input);
            self
        }
        /// <p>An origin that is an S3 bucket that is not configured with static website hosting.</p>
        pub fn set_s3_origin_config(
            mut self,
            input: std::option::Option<crate::model::AwsCloudFrontDistributionOriginS3OriginConfig>,
        ) -> Self {
            self.s3_origin_config = input;
            self
        }
        /// <p>An origin that is not an Amazon S3 bucket, with one exception. If the Amazon S3 bucket is configured with static website hosting, use this attribute. If the Amazon S3 bucket is not configured with static website hosting, use the <code>S3OriginConfig</code> type instead. </p>
        pub fn custom_origin_config(
            mut self,
            input: crate::model::AwsCloudFrontDistributionOriginCustomOriginConfig,
        ) -> Self {
            self.custom_origin_config = Some(input);
            self
        }
        /// <p>An origin that is not an Amazon S3 bucket, with one exception. If the Amazon S3 bucket is configured with static website hosting, use this attribute. If the Amazon S3 bucket is not configured with static website hosting, use the <code>S3OriginConfig</code> type instead. </p>
        pub fn set_custom_origin_config(
            mut self,
            input: std::option::Option<
                crate::model::AwsCloudFrontDistributionOriginCustomOriginConfig,
            >,
        ) -> Self {
            self.custom_origin_config = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCloudFrontDistributionOriginItem`](crate::model::AwsCloudFrontDistributionOriginItem)
        pub fn build(self) -> crate::model::AwsCloudFrontDistributionOriginItem {
            crate::model::AwsCloudFrontDistributionOriginItem {
                domain_name: self.domain_name,
                id: self.id,
                origin_path: self.origin_path,
                s3_origin_config: self.s3_origin_config,
                custom_origin_config: self.custom_origin_config,
            }
        }
    }
}
impl AwsCloudFrontDistributionOriginItem {
    /// Creates a new builder-style object to manufacture [`AwsCloudFrontDistributionOriginItem`](crate::model::AwsCloudFrontDistributionOriginItem)
    pub fn builder() -> crate::model::aws_cloud_front_distribution_origin_item::Builder {
        crate::model::aws_cloud_front_distribution_origin_item::Builder::default()
    }
}

/// <p>A custom origin. A custom origin is any origin that is not an Amazon S3 bucket, with one exception. An Amazon S3 bucket that is <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html">configured with static website hosting</a> is a custom origin. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCloudFrontDistributionOriginCustomOriginConfig {
    /// <p>The HTTP port that CloudFront uses to connect to the origin. </p>
    pub http_port: i32,
    /// <p>The HTTPS port that CloudFront uses to connect to the origin. </p>
    pub https_port: i32,
    /// <p>Specifies how long, in seconds, CloudFront persists its connection to the origin. </p>
    pub origin_keepalive_timeout: i32,
    /// <p>Specifies the protocol (HTTP or HTTPS) that CloudFront uses to connect to the origin. </p>
    pub origin_protocol_policy: std::option::Option<std::string::String>,
    /// <p>Specifies how long, in seconds, CloudFront waits for a response from the origin. </p>
    pub origin_read_timeout: i32,
    /// <p>Specifies the minimum SSL/TLS protocol that CloudFront uses when connecting to your origin over HTTPS. </p>
    pub origin_ssl_protocols:
        std::option::Option<crate::model::AwsCloudFrontDistributionOriginSslProtocols>,
}
impl AwsCloudFrontDistributionOriginCustomOriginConfig {
    /// <p>The HTTP port that CloudFront uses to connect to the origin. </p>
    pub fn http_port(&self) -> i32 {
        self.http_port
    }
    /// <p>The HTTPS port that CloudFront uses to connect to the origin. </p>
    pub fn https_port(&self) -> i32 {
        self.https_port
    }
    /// <p>Specifies how long, in seconds, CloudFront persists its connection to the origin. </p>
    pub fn origin_keepalive_timeout(&self) -> i32 {
        self.origin_keepalive_timeout
    }
    /// <p>Specifies the protocol (HTTP or HTTPS) that CloudFront uses to connect to the origin. </p>
    pub fn origin_protocol_policy(&self) -> std::option::Option<&str> {
        self.origin_protocol_policy.as_deref()
    }
    /// <p>Specifies how long, in seconds, CloudFront waits for a response from the origin. </p>
    pub fn origin_read_timeout(&self) -> i32 {
        self.origin_read_timeout
    }
    /// <p>Specifies the minimum SSL/TLS protocol that CloudFront uses when connecting to your origin over HTTPS. </p>
    pub fn origin_ssl_protocols(
        &self,
    ) -> std::option::Option<&crate::model::AwsCloudFrontDistributionOriginSslProtocols> {
        self.origin_ssl_protocols.as_ref()
    }
}
impl std::fmt::Debug for AwsCloudFrontDistributionOriginCustomOriginConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCloudFrontDistributionOriginCustomOriginConfig");
        formatter.field("http_port", &self.http_port);
        formatter.field("https_port", &self.https_port);
        formatter.field("origin_keepalive_timeout", &self.origin_keepalive_timeout);
        formatter.field("origin_protocol_policy", &self.origin_protocol_policy);
        formatter.field("origin_read_timeout", &self.origin_read_timeout);
        formatter.field("origin_ssl_protocols", &self.origin_ssl_protocols);
        formatter.finish()
    }
}
/// See [`AwsCloudFrontDistributionOriginCustomOriginConfig`](crate::model::AwsCloudFrontDistributionOriginCustomOriginConfig)
pub mod aws_cloud_front_distribution_origin_custom_origin_config {

    /// A builder for [`AwsCloudFrontDistributionOriginCustomOriginConfig`](crate::model::AwsCloudFrontDistributionOriginCustomOriginConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) http_port: std::option::Option<i32>,
        pub(crate) https_port: std::option::Option<i32>,
        pub(crate) origin_keepalive_timeout: std::option::Option<i32>,
        pub(crate) origin_protocol_policy: std::option::Option<std::string::String>,
        pub(crate) origin_read_timeout: std::option::Option<i32>,
        pub(crate) origin_ssl_protocols:
            std::option::Option<crate::model::AwsCloudFrontDistributionOriginSslProtocols>,
    }
    impl Builder {
        /// <p>The HTTP port that CloudFront uses to connect to the origin. </p>
        pub fn http_port(mut self, input: i32) -> Self {
            self.http_port = Some(input);
            self
        }
        /// <p>The HTTP port that CloudFront uses to connect to the origin. </p>
        pub fn set_http_port(mut self, input: std::option::Option<i32>) -> Self {
            self.http_port = input;
            self
        }
        /// <p>The HTTPS port that CloudFront uses to connect to the origin. </p>
        pub fn https_port(mut self, input: i32) -> Self {
            self.https_port = Some(input);
            self
        }
        /// <p>The HTTPS port that CloudFront uses to connect to the origin. </p>
        pub fn set_https_port(mut self, input: std::option::Option<i32>) -> Self {
            self.https_port = input;
            self
        }
        /// <p>Specifies how long, in seconds, CloudFront persists its connection to the origin. </p>
        pub fn origin_keepalive_timeout(mut self, input: i32) -> Self {
            self.origin_keepalive_timeout = Some(input);
            self
        }
        /// <p>Specifies how long, in seconds, CloudFront persists its connection to the origin. </p>
        pub fn set_origin_keepalive_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.origin_keepalive_timeout = input;
            self
        }
        /// <p>Specifies the protocol (HTTP or HTTPS) that CloudFront uses to connect to the origin. </p>
        pub fn origin_protocol_policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.origin_protocol_policy = Some(input.into());
            self
        }
        /// <p>Specifies the protocol (HTTP or HTTPS) that CloudFront uses to connect to the origin. </p>
        pub fn set_origin_protocol_policy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.origin_protocol_policy = input;
            self
        }
        /// <p>Specifies how long, in seconds, CloudFront waits for a response from the origin. </p>
        pub fn origin_read_timeout(mut self, input: i32) -> Self {
            self.origin_read_timeout = Some(input);
            self
        }
        /// <p>Specifies how long, in seconds, CloudFront waits for a response from the origin. </p>
        pub fn set_origin_read_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.origin_read_timeout = input;
            self
        }
        /// <p>Specifies the minimum SSL/TLS protocol that CloudFront uses when connecting to your origin over HTTPS. </p>
        pub fn origin_ssl_protocols(
            mut self,
            input: crate::model::AwsCloudFrontDistributionOriginSslProtocols,
        ) -> Self {
            self.origin_ssl_protocols = Some(input);
            self
        }
        /// <p>Specifies the minimum SSL/TLS protocol that CloudFront uses when connecting to your origin over HTTPS. </p>
        pub fn set_origin_ssl_protocols(
            mut self,
            input: std::option::Option<crate::model::AwsCloudFrontDistributionOriginSslProtocols>,
        ) -> Self {
            self.origin_ssl_protocols = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCloudFrontDistributionOriginCustomOriginConfig`](crate::model::AwsCloudFrontDistributionOriginCustomOriginConfig)
        pub fn build(self) -> crate::model::AwsCloudFrontDistributionOriginCustomOriginConfig {
            crate::model::AwsCloudFrontDistributionOriginCustomOriginConfig {
                http_port: self.http_port.unwrap_or_default(),
                https_port: self.https_port.unwrap_or_default(),
                origin_keepalive_timeout: self.origin_keepalive_timeout.unwrap_or_default(),
                origin_protocol_policy: self.origin_protocol_policy,
                origin_read_timeout: self.origin_read_timeout.unwrap_or_default(),
                origin_ssl_protocols: self.origin_ssl_protocols,
            }
        }
    }
}
impl AwsCloudFrontDistributionOriginCustomOriginConfig {
    /// Creates a new builder-style object to manufacture [`AwsCloudFrontDistributionOriginCustomOriginConfig`](crate::model::AwsCloudFrontDistributionOriginCustomOriginConfig)
    pub fn builder(
    ) -> crate::model::aws_cloud_front_distribution_origin_custom_origin_config::Builder {
        crate::model::aws_cloud_front_distribution_origin_custom_origin_config::Builder::default()
    }
}

/// <p>A complex type that contains information about the SSL/TLS protocols that CloudFront can use when establishing an HTTPS connection with your origin. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCloudFrontDistributionOriginSslProtocols {
    /// <p>A list that contains allowed SSL/TLS protocols for this distribution. </p>
    pub items: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The number of SSL/TLS protocols that you want to allow CloudFront to use when establishing an HTTPS connection with this origin. </p>
    pub quantity: i32,
}
impl AwsCloudFrontDistributionOriginSslProtocols {
    /// <p>A list that contains allowed SSL/TLS protocols for this distribution. </p>
    pub fn items(&self) -> std::option::Option<&[std::string::String]> {
        self.items.as_deref()
    }
    /// <p>The number of SSL/TLS protocols that you want to allow CloudFront to use when establishing an HTTPS connection with this origin. </p>
    pub fn quantity(&self) -> i32 {
        self.quantity
    }
}
impl std::fmt::Debug for AwsCloudFrontDistributionOriginSslProtocols {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCloudFrontDistributionOriginSslProtocols");
        formatter.field("items", &self.items);
        formatter.field("quantity", &self.quantity);
        formatter.finish()
    }
}
/// See [`AwsCloudFrontDistributionOriginSslProtocols`](crate::model::AwsCloudFrontDistributionOriginSslProtocols)
pub mod aws_cloud_front_distribution_origin_ssl_protocols {

    /// A builder for [`AwsCloudFrontDistributionOriginSslProtocols`](crate::model::AwsCloudFrontDistributionOriginSslProtocols)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) items: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) quantity: std::option::Option<i32>,
    }
    impl Builder {
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>A list that contains allowed SSL/TLS protocols for this distribution. </p>
        pub fn items(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.items.unwrap_or_default();
            v.push(input.into());
            self.items = Some(v);
            self
        }
        /// <p>A list that contains allowed SSL/TLS protocols for this distribution. </p>
        pub fn set_items(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.items = input;
            self
        }
        /// <p>The number of SSL/TLS protocols that you want to allow CloudFront to use when establishing an HTTPS connection with this origin. </p>
        pub fn quantity(mut self, input: i32) -> Self {
            self.quantity = Some(input);
            self
        }
        /// <p>The number of SSL/TLS protocols that you want to allow CloudFront to use when establishing an HTTPS connection with this origin. </p>
        pub fn set_quantity(mut self, input: std::option::Option<i32>) -> Self {
            self.quantity = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCloudFrontDistributionOriginSslProtocols`](crate::model::AwsCloudFrontDistributionOriginSslProtocols)
        pub fn build(self) -> crate::model::AwsCloudFrontDistributionOriginSslProtocols {
            crate::model::AwsCloudFrontDistributionOriginSslProtocols {
                items: self.items,
                quantity: self.quantity.unwrap_or_default(),
            }
        }
    }
}
impl AwsCloudFrontDistributionOriginSslProtocols {
    /// Creates a new builder-style object to manufacture [`AwsCloudFrontDistributionOriginSslProtocols`](crate::model::AwsCloudFrontDistributionOriginSslProtocols)
    pub fn builder() -> crate::model::aws_cloud_front_distribution_origin_ssl_protocols::Builder {
        crate::model::aws_cloud_front_distribution_origin_ssl_protocols::Builder::default()
    }
}

/// <p>Information about an origin that is an Amazon S3 bucket that is not configured with static website hosting.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCloudFrontDistributionOriginS3OriginConfig {
    /// <p>The CloudFront origin access identity to associate with the origin.</p>
    pub origin_access_identity: std::option::Option<std::string::String>,
}
impl AwsCloudFrontDistributionOriginS3OriginConfig {
    /// <p>The CloudFront origin access identity to associate with the origin.</p>
    pub fn origin_access_identity(&self) -> std::option::Option<&str> {
        self.origin_access_identity.as_deref()
    }
}
impl std::fmt::Debug for AwsCloudFrontDistributionOriginS3OriginConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCloudFrontDistributionOriginS3OriginConfig");
        formatter.field("origin_access_identity", &self.origin_access_identity);
        formatter.finish()
    }
}
/// See [`AwsCloudFrontDistributionOriginS3OriginConfig`](crate::model::AwsCloudFrontDistributionOriginS3OriginConfig)
pub mod aws_cloud_front_distribution_origin_s3_origin_config {

    /// A builder for [`AwsCloudFrontDistributionOriginS3OriginConfig`](crate::model::AwsCloudFrontDistributionOriginS3OriginConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) origin_access_identity: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The CloudFront origin access identity to associate with the origin.</p>
        pub fn origin_access_identity(mut self, input: impl Into<std::string::String>) -> Self {
            self.origin_access_identity = Some(input.into());
            self
        }
        /// <p>The CloudFront origin access identity to associate with the origin.</p>
        pub fn set_origin_access_identity(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.origin_access_identity = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCloudFrontDistributionOriginS3OriginConfig`](crate::model::AwsCloudFrontDistributionOriginS3OriginConfig)
        pub fn build(self) -> crate::model::AwsCloudFrontDistributionOriginS3OriginConfig {
            crate::model::AwsCloudFrontDistributionOriginS3OriginConfig {
                origin_access_identity: self.origin_access_identity,
            }
        }
    }
}
impl AwsCloudFrontDistributionOriginS3OriginConfig {
    /// Creates a new builder-style object to manufacture [`AwsCloudFrontDistributionOriginS3OriginConfig`](crate::model::AwsCloudFrontDistributionOriginS3OriginConfig)
    pub fn builder() -> crate::model::aws_cloud_front_distribution_origin_s3_origin_config::Builder
    {
        crate::model::aws_cloud_front_distribution_origin_s3_origin_config::Builder::default()
    }
}

/// <p>A complex type that controls whether access logs are written for the CloudFront distribution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCloudFrontDistributionLogging {
    /// <p>The S3 bucket to store the access logs in.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>With this field, you can enable or disable the selected distribution.</p>
    pub enabled: bool,
    /// <p>Specifies whether you want CloudFront to include cookies in access logs.</p>
    pub include_cookies: bool,
    /// <p>An optional string that you want CloudFront to use as a prefix to the access log filenames for this distribution.</p>
    pub prefix: std::option::Option<std::string::String>,
}
impl AwsCloudFrontDistributionLogging {
    /// <p>The S3 bucket to store the access logs in.</p>
    pub fn bucket(&self) -> std::option::Option<&str> {
        self.bucket.as_deref()
    }
    /// <p>With this field, you can enable or disable the selected distribution.</p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
    /// <p>Specifies whether you want CloudFront to include cookies in access logs.</p>
    pub fn include_cookies(&self) -> bool {
        self.include_cookies
    }
    /// <p>An optional string that you want CloudFront to use as a prefix to the access log filenames for this distribution.</p>
    pub fn prefix(&self) -> std::option::Option<&str> {
        self.prefix.as_deref()
    }
}
impl std::fmt::Debug for AwsCloudFrontDistributionLogging {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCloudFrontDistributionLogging");
        formatter.field("bucket", &self.bucket);
        formatter.field("enabled", &self.enabled);
        formatter.field("include_cookies", &self.include_cookies);
        formatter.field("prefix", &self.prefix);
        formatter.finish()
    }
}
/// See [`AwsCloudFrontDistributionLogging`](crate::model::AwsCloudFrontDistributionLogging)
pub mod aws_cloud_front_distribution_logging {

    /// A builder for [`AwsCloudFrontDistributionLogging`](crate::model::AwsCloudFrontDistributionLogging)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) include_cookies: std::option::Option<bool>,
        pub(crate) prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The S3 bucket to store the access logs in.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        /// <p>The S3 bucket to store the access logs in.</p>
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>With this field, you can enable or disable the selected distribution.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>With this field, you can enable or disable the selected distribution.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>Specifies whether you want CloudFront to include cookies in access logs.</p>
        pub fn include_cookies(mut self, input: bool) -> Self {
            self.include_cookies = Some(input);
            self
        }
        /// <p>Specifies whether you want CloudFront to include cookies in access logs.</p>
        pub fn set_include_cookies(mut self, input: std::option::Option<bool>) -> Self {
            self.include_cookies = input;
            self
        }
        /// <p>An optional string that you want CloudFront to use as a prefix to the access log filenames for this distribution.</p>
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix = Some(input.into());
            self
        }
        /// <p>An optional string that you want CloudFront to use as a prefix to the access log filenames for this distribution.</p>
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCloudFrontDistributionLogging`](crate::model::AwsCloudFrontDistributionLogging)
        pub fn build(self) -> crate::model::AwsCloudFrontDistributionLogging {
            crate::model::AwsCloudFrontDistributionLogging {
                bucket: self.bucket,
                enabled: self.enabled.unwrap_or_default(),
                include_cookies: self.include_cookies.unwrap_or_default(),
                prefix: self.prefix,
            }
        }
    }
}
impl AwsCloudFrontDistributionLogging {
    /// Creates a new builder-style object to manufacture [`AwsCloudFrontDistributionLogging`](crate::model::AwsCloudFrontDistributionLogging)
    pub fn builder() -> crate::model::aws_cloud_front_distribution_logging::Builder {
        crate::model::aws_cloud_front_distribution_logging::Builder::default()
    }
}

/// <p>Contains information about the default cache configuration for the CloudFront distribution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCloudFrontDistributionDefaultCacheBehavior {
    /// <p>The protocol that viewers can use to access the files in an origin. You can specify the following options:</p>
    /// <ul>
    /// <li> <p> <code>allow-all</code> - Viewers can use HTTP or HTTPS.</p> </li>
    /// <li> <p> <code>redirect-to-https</code> - CloudFront responds to HTTP requests with an HTTP status code of 301 (Moved Permanently) and the HTTPS URL. The viewer then uses the new URL to resubmit.</p> </li>
    /// <li> <p> <code>https-only</code> - CloudFront responds to HTTP request with an HTTP status code of 403 (Forbidden).</p> </li>
    /// </ul>
    pub viewer_protocol_policy: std::option::Option<std::string::String>,
}
impl AwsCloudFrontDistributionDefaultCacheBehavior {
    /// <p>The protocol that viewers can use to access the files in an origin. You can specify the following options:</p>
    /// <ul>
    /// <li> <p> <code>allow-all</code> - Viewers can use HTTP or HTTPS.</p> </li>
    /// <li> <p> <code>redirect-to-https</code> - CloudFront responds to HTTP requests with an HTTP status code of 301 (Moved Permanently) and the HTTPS URL. The viewer then uses the new URL to resubmit.</p> </li>
    /// <li> <p> <code>https-only</code> - CloudFront responds to HTTP request with an HTTP status code of 403 (Forbidden).</p> </li>
    /// </ul>
    pub fn viewer_protocol_policy(&self) -> std::option::Option<&str> {
        self.viewer_protocol_policy.as_deref()
    }
}
impl std::fmt::Debug for AwsCloudFrontDistributionDefaultCacheBehavior {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCloudFrontDistributionDefaultCacheBehavior");
        formatter.field("viewer_protocol_policy", &self.viewer_protocol_policy);
        formatter.finish()
    }
}
/// See [`AwsCloudFrontDistributionDefaultCacheBehavior`](crate::model::AwsCloudFrontDistributionDefaultCacheBehavior)
pub mod aws_cloud_front_distribution_default_cache_behavior {

    /// A builder for [`AwsCloudFrontDistributionDefaultCacheBehavior`](crate::model::AwsCloudFrontDistributionDefaultCacheBehavior)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) viewer_protocol_policy: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The protocol that viewers can use to access the files in an origin. You can specify the following options:</p>
        /// <ul>
        /// <li> <p> <code>allow-all</code> - Viewers can use HTTP or HTTPS.</p> </li>
        /// <li> <p> <code>redirect-to-https</code> - CloudFront responds to HTTP requests with an HTTP status code of 301 (Moved Permanently) and the HTTPS URL. The viewer then uses the new URL to resubmit.</p> </li>
        /// <li> <p> <code>https-only</code> - CloudFront responds to HTTP request with an HTTP status code of 403 (Forbidden).</p> </li>
        /// </ul>
        pub fn viewer_protocol_policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.viewer_protocol_policy = Some(input.into());
            self
        }
        /// <p>The protocol that viewers can use to access the files in an origin. You can specify the following options:</p>
        /// <ul>
        /// <li> <p> <code>allow-all</code> - Viewers can use HTTP or HTTPS.</p> </li>
        /// <li> <p> <code>redirect-to-https</code> - CloudFront responds to HTTP requests with an HTTP status code of 301 (Moved Permanently) and the HTTPS URL. The viewer then uses the new URL to resubmit.</p> </li>
        /// <li> <p> <code>https-only</code> - CloudFront responds to HTTP request with an HTTP status code of 403 (Forbidden).</p> </li>
        /// </ul>
        pub fn set_viewer_protocol_policy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.viewer_protocol_policy = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCloudFrontDistributionDefaultCacheBehavior`](crate::model::AwsCloudFrontDistributionDefaultCacheBehavior)
        pub fn build(self) -> crate::model::AwsCloudFrontDistributionDefaultCacheBehavior {
            crate::model::AwsCloudFrontDistributionDefaultCacheBehavior {
                viewer_protocol_policy: self.viewer_protocol_policy,
            }
        }
    }
}
impl AwsCloudFrontDistributionDefaultCacheBehavior {
    /// Creates a new builder-style object to manufacture [`AwsCloudFrontDistributionDefaultCacheBehavior`](crate::model::AwsCloudFrontDistributionDefaultCacheBehavior)
    pub fn builder() -> crate::model::aws_cloud_front_distribution_default_cache_behavior::Builder {
        crate::model::aws_cloud_front_distribution_default_cache_behavior::Builder::default()
    }
}

/// <p>Provides information about caching for the CloudFront distribution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCloudFrontDistributionCacheBehaviors {
    /// <p>The cache behaviors for the distribution.</p>
    pub items:
        std::option::Option<std::vec::Vec<crate::model::AwsCloudFrontDistributionCacheBehavior>>,
}
impl AwsCloudFrontDistributionCacheBehaviors {
    /// <p>The cache behaviors for the distribution.</p>
    pub fn items(
        &self,
    ) -> std::option::Option<&[crate::model::AwsCloudFrontDistributionCacheBehavior]> {
        self.items.as_deref()
    }
}
impl std::fmt::Debug for AwsCloudFrontDistributionCacheBehaviors {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCloudFrontDistributionCacheBehaviors");
        formatter.field("items", &self.items);
        formatter.finish()
    }
}
/// See [`AwsCloudFrontDistributionCacheBehaviors`](crate::model::AwsCloudFrontDistributionCacheBehaviors)
pub mod aws_cloud_front_distribution_cache_behaviors {

    /// A builder for [`AwsCloudFrontDistributionCacheBehaviors`](crate::model::AwsCloudFrontDistributionCacheBehaviors)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) items: std::option::Option<
            std::vec::Vec<crate::model::AwsCloudFrontDistributionCacheBehavior>,
        >,
    }
    impl Builder {
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>The cache behaviors for the distribution.</p>
        pub fn items(
            mut self,
            input: crate::model::AwsCloudFrontDistributionCacheBehavior,
        ) -> Self {
            let mut v = self.items.unwrap_or_default();
            v.push(input);
            self.items = Some(v);
            self
        }
        /// <p>The cache behaviors for the distribution.</p>
        pub fn set_items(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsCloudFrontDistributionCacheBehavior>,
            >,
        ) -> Self {
            self.items = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCloudFrontDistributionCacheBehaviors`](crate::model::AwsCloudFrontDistributionCacheBehaviors)
        pub fn build(self) -> crate::model::AwsCloudFrontDistributionCacheBehaviors {
            crate::model::AwsCloudFrontDistributionCacheBehaviors { items: self.items }
        }
    }
}
impl AwsCloudFrontDistributionCacheBehaviors {
    /// Creates a new builder-style object to manufacture [`AwsCloudFrontDistributionCacheBehaviors`](crate::model::AwsCloudFrontDistributionCacheBehaviors)
    pub fn builder() -> crate::model::aws_cloud_front_distribution_cache_behaviors::Builder {
        crate::model::aws_cloud_front_distribution_cache_behaviors::Builder::default()
    }
}

/// <p>Information about a cache behavior for the distribution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCloudFrontDistributionCacheBehavior {
    /// <p>The protocol that viewers can use to access the files in an origin. You can specify the following options:</p>
    /// <ul>
    /// <li> <p> <code>allow-all</code> - Viewers can use HTTP or HTTPS.</p> </li>
    /// <li> <p> <code>redirect-to-https</code> - CloudFront responds to HTTP requests with an HTTP status code of 301 (Moved Permanently) and the HTTPS URL. The viewer then uses the new URL to resubmit.</p> </li>
    /// <li> <p> <code>https-only</code> - CloudFront responds to HTTP request with an HTTP status code of 403 (Forbidden).</p> </li>
    /// </ul>
    pub viewer_protocol_policy: std::option::Option<std::string::String>,
}
impl AwsCloudFrontDistributionCacheBehavior {
    /// <p>The protocol that viewers can use to access the files in an origin. You can specify the following options:</p>
    /// <ul>
    /// <li> <p> <code>allow-all</code> - Viewers can use HTTP or HTTPS.</p> </li>
    /// <li> <p> <code>redirect-to-https</code> - CloudFront responds to HTTP requests with an HTTP status code of 301 (Moved Permanently) and the HTTPS URL. The viewer then uses the new URL to resubmit.</p> </li>
    /// <li> <p> <code>https-only</code> - CloudFront responds to HTTP request with an HTTP status code of 403 (Forbidden).</p> </li>
    /// </ul>
    pub fn viewer_protocol_policy(&self) -> std::option::Option<&str> {
        self.viewer_protocol_policy.as_deref()
    }
}
impl std::fmt::Debug for AwsCloudFrontDistributionCacheBehavior {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCloudFrontDistributionCacheBehavior");
        formatter.field("viewer_protocol_policy", &self.viewer_protocol_policy);
        formatter.finish()
    }
}
/// See [`AwsCloudFrontDistributionCacheBehavior`](crate::model::AwsCloudFrontDistributionCacheBehavior)
pub mod aws_cloud_front_distribution_cache_behavior {

    /// A builder for [`AwsCloudFrontDistributionCacheBehavior`](crate::model::AwsCloudFrontDistributionCacheBehavior)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) viewer_protocol_policy: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The protocol that viewers can use to access the files in an origin. You can specify the following options:</p>
        /// <ul>
        /// <li> <p> <code>allow-all</code> - Viewers can use HTTP or HTTPS.</p> </li>
        /// <li> <p> <code>redirect-to-https</code> - CloudFront responds to HTTP requests with an HTTP status code of 301 (Moved Permanently) and the HTTPS URL. The viewer then uses the new URL to resubmit.</p> </li>
        /// <li> <p> <code>https-only</code> - CloudFront responds to HTTP request with an HTTP status code of 403 (Forbidden).</p> </li>
        /// </ul>
        pub fn viewer_protocol_policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.viewer_protocol_policy = Some(input.into());
            self
        }
        /// <p>The protocol that viewers can use to access the files in an origin. You can specify the following options:</p>
        /// <ul>
        /// <li> <p> <code>allow-all</code> - Viewers can use HTTP or HTTPS.</p> </li>
        /// <li> <p> <code>redirect-to-https</code> - CloudFront responds to HTTP requests with an HTTP status code of 301 (Moved Permanently) and the HTTPS URL. The viewer then uses the new URL to resubmit.</p> </li>
        /// <li> <p> <code>https-only</code> - CloudFront responds to HTTP request with an HTTP status code of 403 (Forbidden).</p> </li>
        /// </ul>
        pub fn set_viewer_protocol_policy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.viewer_protocol_policy = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCloudFrontDistributionCacheBehavior`](crate::model::AwsCloudFrontDistributionCacheBehavior)
        pub fn build(self) -> crate::model::AwsCloudFrontDistributionCacheBehavior {
            crate::model::AwsCloudFrontDistributionCacheBehavior {
                viewer_protocol_policy: self.viewer_protocol_policy,
            }
        }
    }
}
impl AwsCloudFrontDistributionCacheBehavior {
    /// Creates a new builder-style object to manufacture [`AwsCloudFrontDistributionCacheBehavior`](crate::model::AwsCloudFrontDistributionCacheBehavior)
    pub fn builder() -> crate::model::aws_cloud_front_distribution_cache_behavior::Builder {
        crate::model::aws_cloud_front_distribution_cache_behavior::Builder::default()
    }
}

/// <p>Information about an CodeBuild project.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCodeBuildProjectDetails {
    /// <p>The KMS key used to encrypt the build output artifacts.</p>
    /// <p>You can specify either the ARN of the KMS key or, if available, the KMS key alias (using the format alias/alias-name). </p>
    pub encryption_key: std::option::Option<std::string::String>,
    /// <p>Information about the build artifacts for the CodeBuild project.</p>
    pub artifacts:
        std::option::Option<std::vec::Vec<crate::model::AwsCodeBuildProjectArtifactsDetails>>,
    /// <p>Information about the build environment for this build project.</p>
    pub environment: std::option::Option<crate::model::AwsCodeBuildProjectEnvironment>,
    /// <p>The name of the build project.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Information about the build input source code for this build project.</p>
    pub source: std::option::Option<crate::model::AwsCodeBuildProjectSource>,
    /// <p>The ARN of the IAM role that enables CodeBuild to interact with dependent Amazon Web Services services on behalf of the Amazon Web Services account.</p>
    pub service_role: std::option::Option<std::string::String>,
    /// <p>Information about logs for the build project.</p>
    pub logs_config: std::option::Option<crate::model::AwsCodeBuildProjectLogsConfigDetails>,
    /// <p>Information about the VPC configuration that CodeBuild accesses.</p>
    pub vpc_config: std::option::Option<crate::model::AwsCodeBuildProjectVpcConfig>,
    /// <p>Information about the secondary artifacts for the CodeBuild project.</p>
    pub secondary_artifacts:
        std::option::Option<std::vec::Vec<crate::model::AwsCodeBuildProjectArtifactsDetails>>,
}
impl AwsCodeBuildProjectDetails {
    /// <p>The KMS key used to encrypt the build output artifacts.</p>
    /// <p>You can specify either the ARN of the KMS key or, if available, the KMS key alias (using the format alias/alias-name). </p>
    pub fn encryption_key(&self) -> std::option::Option<&str> {
        self.encryption_key.as_deref()
    }
    /// <p>Information about the build artifacts for the CodeBuild project.</p>
    pub fn artifacts(
        &self,
    ) -> std::option::Option<&[crate::model::AwsCodeBuildProjectArtifactsDetails]> {
        self.artifacts.as_deref()
    }
    /// <p>Information about the build environment for this build project.</p>
    pub fn environment(
        &self,
    ) -> std::option::Option<&crate::model::AwsCodeBuildProjectEnvironment> {
        self.environment.as_ref()
    }
    /// <p>The name of the build project.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Information about the build input source code for this build project.</p>
    pub fn source(&self) -> std::option::Option<&crate::model::AwsCodeBuildProjectSource> {
        self.source.as_ref()
    }
    /// <p>The ARN of the IAM role that enables CodeBuild to interact with dependent Amazon Web Services services on behalf of the Amazon Web Services account.</p>
    pub fn service_role(&self) -> std::option::Option<&str> {
        self.service_role.as_deref()
    }
    /// <p>Information about logs for the build project.</p>
    pub fn logs_config(
        &self,
    ) -> std::option::Option<&crate::model::AwsCodeBuildProjectLogsConfigDetails> {
        self.logs_config.as_ref()
    }
    /// <p>Information about the VPC configuration that CodeBuild accesses.</p>
    pub fn vpc_config(&self) -> std::option::Option<&crate::model::AwsCodeBuildProjectVpcConfig> {
        self.vpc_config.as_ref()
    }
    /// <p>Information about the secondary artifacts for the CodeBuild project.</p>
    pub fn secondary_artifacts(
        &self,
    ) -> std::option::Option<&[crate::model::AwsCodeBuildProjectArtifactsDetails]> {
        self.secondary_artifacts.as_deref()
    }
}
impl std::fmt::Debug for AwsCodeBuildProjectDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCodeBuildProjectDetails");
        formatter.field("encryption_key", &self.encryption_key);
        formatter.field("artifacts", &self.artifacts);
        formatter.field("environment", &self.environment);
        formatter.field("name", &self.name);
        formatter.field("source", &self.source);
        formatter.field("service_role", &self.service_role);
        formatter.field("logs_config", &self.logs_config);
        formatter.field("vpc_config", &self.vpc_config);
        formatter.field("secondary_artifacts", &self.secondary_artifacts);
        formatter.finish()
    }
}
/// See [`AwsCodeBuildProjectDetails`](crate::model::AwsCodeBuildProjectDetails)
pub mod aws_code_build_project_details {

    /// A builder for [`AwsCodeBuildProjectDetails`](crate::model::AwsCodeBuildProjectDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) encryption_key: std::option::Option<std::string::String>,
        pub(crate) artifacts:
            std::option::Option<std::vec::Vec<crate::model::AwsCodeBuildProjectArtifactsDetails>>,
        pub(crate) environment: std::option::Option<crate::model::AwsCodeBuildProjectEnvironment>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) source: std::option::Option<crate::model::AwsCodeBuildProjectSource>,
        pub(crate) service_role: std::option::Option<std::string::String>,
        pub(crate) logs_config:
            std::option::Option<crate::model::AwsCodeBuildProjectLogsConfigDetails>,
        pub(crate) vpc_config: std::option::Option<crate::model::AwsCodeBuildProjectVpcConfig>,
        pub(crate) secondary_artifacts:
            std::option::Option<std::vec::Vec<crate::model::AwsCodeBuildProjectArtifactsDetails>>,
    }
    impl Builder {
        /// <p>The KMS key used to encrypt the build output artifacts.</p>
        /// <p>You can specify either the ARN of the KMS key or, if available, the KMS key alias (using the format alias/alias-name). </p>
        pub fn encryption_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.encryption_key = Some(input.into());
            self
        }
        /// <p>The KMS key used to encrypt the build output artifacts.</p>
        /// <p>You can specify either the ARN of the KMS key or, if available, the KMS key alias (using the format alias/alias-name). </p>
        pub fn set_encryption_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.encryption_key = input;
            self
        }
        /// Appends an item to `artifacts`.
        ///
        /// To override the contents of this collection use [`set_artifacts`](Self::set_artifacts).
        ///
        /// <p>Information about the build artifacts for the CodeBuild project.</p>
        pub fn artifacts(
            mut self,
            input: crate::model::AwsCodeBuildProjectArtifactsDetails,
        ) -> Self {
            let mut v = self.artifacts.unwrap_or_default();
            v.push(input);
            self.artifacts = Some(v);
            self
        }
        /// <p>Information about the build artifacts for the CodeBuild project.</p>
        pub fn set_artifacts(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsCodeBuildProjectArtifactsDetails>,
            >,
        ) -> Self {
            self.artifacts = input;
            self
        }
        /// <p>Information about the build environment for this build project.</p>
        pub fn environment(mut self, input: crate::model::AwsCodeBuildProjectEnvironment) -> Self {
            self.environment = Some(input);
            self
        }
        /// <p>Information about the build environment for this build project.</p>
        pub fn set_environment(
            mut self,
            input: std::option::Option<crate::model::AwsCodeBuildProjectEnvironment>,
        ) -> Self {
            self.environment = input;
            self
        }
        /// <p>The name of the build project.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the build project.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Information about the build input source code for this build project.</p>
        pub fn source(mut self, input: crate::model::AwsCodeBuildProjectSource) -> Self {
            self.source = Some(input);
            self
        }
        /// <p>Information about the build input source code for this build project.</p>
        pub fn set_source(
            mut self,
            input: std::option::Option<crate::model::AwsCodeBuildProjectSource>,
        ) -> Self {
            self.source = input;
            self
        }
        /// <p>The ARN of the IAM role that enables CodeBuild to interact with dependent Amazon Web Services services on behalf of the Amazon Web Services account.</p>
        pub fn service_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_role = Some(input.into());
            self
        }
        /// <p>The ARN of the IAM role that enables CodeBuild to interact with dependent Amazon Web Services services on behalf of the Amazon Web Services account.</p>
        pub fn set_service_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_role = input;
            self
        }
        /// <p>Information about logs for the build project.</p>
        pub fn logs_config(
            mut self,
            input: crate::model::AwsCodeBuildProjectLogsConfigDetails,
        ) -> Self {
            self.logs_config = Some(input);
            self
        }
        /// <p>Information about logs for the build project.</p>
        pub fn set_logs_config(
            mut self,
            input: std::option::Option<crate::model::AwsCodeBuildProjectLogsConfigDetails>,
        ) -> Self {
            self.logs_config = input;
            self
        }
        /// <p>Information about the VPC configuration that CodeBuild accesses.</p>
        pub fn vpc_config(mut self, input: crate::model::AwsCodeBuildProjectVpcConfig) -> Self {
            self.vpc_config = Some(input);
            self
        }
        /// <p>Information about the VPC configuration that CodeBuild accesses.</p>
        pub fn set_vpc_config(
            mut self,
            input: std::option::Option<crate::model::AwsCodeBuildProjectVpcConfig>,
        ) -> Self {
            self.vpc_config = input;
            self
        }
        /// Appends an item to `secondary_artifacts`.
        ///
        /// To override the contents of this collection use [`set_secondary_artifacts`](Self::set_secondary_artifacts).
        ///
        /// <p>Information about the secondary artifacts for the CodeBuild project.</p>
        pub fn secondary_artifacts(
            mut self,
            input: crate::model::AwsCodeBuildProjectArtifactsDetails,
        ) -> Self {
            let mut v = self.secondary_artifacts.unwrap_or_default();
            v.push(input);
            self.secondary_artifacts = Some(v);
            self
        }
        /// <p>Information about the secondary artifacts for the CodeBuild project.</p>
        pub fn set_secondary_artifacts(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsCodeBuildProjectArtifactsDetails>,
            >,
        ) -> Self {
            self.secondary_artifacts = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCodeBuildProjectDetails`](crate::model::AwsCodeBuildProjectDetails)
        pub fn build(self) -> crate::model::AwsCodeBuildProjectDetails {
            crate::model::AwsCodeBuildProjectDetails {
                encryption_key: self.encryption_key,
                artifacts: self.artifacts,
                environment: self.environment,
                name: self.name,
                source: self.source,
                service_role: self.service_role,
                logs_config: self.logs_config,
                vpc_config: self.vpc_config,
                secondary_artifacts: self.secondary_artifacts,
            }
        }
    }
}
impl AwsCodeBuildProjectDetails {
    /// Creates a new builder-style object to manufacture [`AwsCodeBuildProjectDetails`](crate::model::AwsCodeBuildProjectDetails)
    pub fn builder() -> crate::model::aws_code_build_project_details::Builder {
        crate::model::aws_code_build_project_details::Builder::default()
    }
}

/// <p>Information about the build artifacts for the CodeBuild project.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCodeBuildProjectArtifactsDetails {
    /// <p>An identifier for the artifact definition.</p>
    pub artifact_identifier: std::option::Option<std::string::String>,
    /// <p>Indicates whether to disable encryption on the artifact. Only valid when <code>Type</code> is <code>S3</code>.</p>
    pub encryption_disabled: bool,
    /// <p>Only used when <code>Type</code> is <code>S3</code>. The name of the S3 bucket where the artifact is located.</p>
    pub location: std::option::Option<std::string::String>,
    /// <p>Only used when Type is S3. The name of the artifact. Used with <code>NamepaceType</code> and <code>Path</code> to determine the pattern for storing the artifact.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Only used when <code>Type</code> is <code>S3</code>. The value to use for the namespace. Used with <code>Name</code> and <code>Path</code> to determine the pattern for storing the artifact.</p>
    pub namespace_type: std::option::Option<std::string::String>,
    /// <p>Whether the name specified in the buildspec file overrides the artifact name.</p>
    pub override_artifact_name: bool,
    /// <p>Only used when <code>Type</code> is <code>S3</code>. The type of output artifact to create.</p>
    pub packaging: std::option::Option<std::string::String>,
    /// <p>Only used when <code>Type</code> is <code>S3</code>. The path to the artifact. Used with <code>Name</code> and <code>NamespaceType</code> to determine the pattern for storing the artifact.</p>
    pub path: std::option::Option<std::string::String>,
    /// <p>The type of build artifact.</p>
    pub r#type: std::option::Option<std::string::String>,
}
impl AwsCodeBuildProjectArtifactsDetails {
    /// <p>An identifier for the artifact definition.</p>
    pub fn artifact_identifier(&self) -> std::option::Option<&str> {
        self.artifact_identifier.as_deref()
    }
    /// <p>Indicates whether to disable encryption on the artifact. Only valid when <code>Type</code> is <code>S3</code>.</p>
    pub fn encryption_disabled(&self) -> bool {
        self.encryption_disabled
    }
    /// <p>Only used when <code>Type</code> is <code>S3</code>. The name of the S3 bucket where the artifact is located.</p>
    pub fn location(&self) -> std::option::Option<&str> {
        self.location.as_deref()
    }
    /// <p>Only used when Type is S3. The name of the artifact. Used with <code>NamepaceType</code> and <code>Path</code> to determine the pattern for storing the artifact.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Only used when <code>Type</code> is <code>S3</code>. The value to use for the namespace. Used with <code>Name</code> and <code>Path</code> to determine the pattern for storing the artifact.</p>
    pub fn namespace_type(&self) -> std::option::Option<&str> {
        self.namespace_type.as_deref()
    }
    /// <p>Whether the name specified in the buildspec file overrides the artifact name.</p>
    pub fn override_artifact_name(&self) -> bool {
        self.override_artifact_name
    }
    /// <p>Only used when <code>Type</code> is <code>S3</code>. The type of output artifact to create.</p>
    pub fn packaging(&self) -> std::option::Option<&str> {
        self.packaging.as_deref()
    }
    /// <p>Only used when <code>Type</code> is <code>S3</code>. The path to the artifact. Used with <code>Name</code> and <code>NamespaceType</code> to determine the pattern for storing the artifact.</p>
    pub fn path(&self) -> std::option::Option<&str> {
        self.path.as_deref()
    }
    /// <p>The type of build artifact.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for AwsCodeBuildProjectArtifactsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCodeBuildProjectArtifactsDetails");
        formatter.field("artifact_identifier", &self.artifact_identifier);
        formatter.field("encryption_disabled", &self.encryption_disabled);
        formatter.field("location", &self.location);
        formatter.field("name", &self.name);
        formatter.field("namespace_type", &self.namespace_type);
        formatter.field("override_artifact_name", &self.override_artifact_name);
        formatter.field("packaging", &self.packaging);
        formatter.field("path", &self.path);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AwsCodeBuildProjectArtifactsDetails`](crate::model::AwsCodeBuildProjectArtifactsDetails)
pub mod aws_code_build_project_artifacts_details {

    /// A builder for [`AwsCodeBuildProjectArtifactsDetails`](crate::model::AwsCodeBuildProjectArtifactsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) artifact_identifier: std::option::Option<std::string::String>,
        pub(crate) encryption_disabled: std::option::Option<bool>,
        pub(crate) location: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) namespace_type: std::option::Option<std::string::String>,
        pub(crate) override_artifact_name: std::option::Option<bool>,
        pub(crate) packaging: std::option::Option<std::string::String>,
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An identifier for the artifact definition.</p>
        pub fn artifact_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.artifact_identifier = Some(input.into());
            self
        }
        /// <p>An identifier for the artifact definition.</p>
        pub fn set_artifact_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.artifact_identifier = input;
            self
        }
        /// <p>Indicates whether to disable encryption on the artifact. Only valid when <code>Type</code> is <code>S3</code>.</p>
        pub fn encryption_disabled(mut self, input: bool) -> Self {
            self.encryption_disabled = Some(input);
            self
        }
        /// <p>Indicates whether to disable encryption on the artifact. Only valid when <code>Type</code> is <code>S3</code>.</p>
        pub fn set_encryption_disabled(mut self, input: std::option::Option<bool>) -> Self {
            self.encryption_disabled = input;
            self
        }
        /// <p>Only used when <code>Type</code> is <code>S3</code>. The name of the S3 bucket where the artifact is located.</p>
        pub fn location(mut self, input: impl Into<std::string::String>) -> Self {
            self.location = Some(input.into());
            self
        }
        /// <p>Only used when <code>Type</code> is <code>S3</code>. The name of the S3 bucket where the artifact is located.</p>
        pub fn set_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.location = input;
            self
        }
        /// <p>Only used when Type is S3. The name of the artifact. Used with <code>NamepaceType</code> and <code>Path</code> to determine the pattern for storing the artifact.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Only used when Type is S3. The name of the artifact. Used with <code>NamepaceType</code> and <code>Path</code> to determine the pattern for storing the artifact.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Only used when <code>Type</code> is <code>S3</code>. The value to use for the namespace. Used with <code>Name</code> and <code>Path</code> to determine the pattern for storing the artifact.</p>
        pub fn namespace_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace_type = Some(input.into());
            self
        }
        /// <p>Only used when <code>Type</code> is <code>S3</code>. The value to use for the namespace. Used with <code>Name</code> and <code>Path</code> to determine the pattern for storing the artifact.</p>
        pub fn set_namespace_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.namespace_type = input;
            self
        }
        /// <p>Whether the name specified in the buildspec file overrides the artifact name.</p>
        pub fn override_artifact_name(mut self, input: bool) -> Self {
            self.override_artifact_name = Some(input);
            self
        }
        /// <p>Whether the name specified in the buildspec file overrides the artifact name.</p>
        pub fn set_override_artifact_name(mut self, input: std::option::Option<bool>) -> Self {
            self.override_artifact_name = input;
            self
        }
        /// <p>Only used when <code>Type</code> is <code>S3</code>. The type of output artifact to create.</p>
        pub fn packaging(mut self, input: impl Into<std::string::String>) -> Self {
            self.packaging = Some(input.into());
            self
        }
        /// <p>Only used when <code>Type</code> is <code>S3</code>. The type of output artifact to create.</p>
        pub fn set_packaging(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.packaging = input;
            self
        }
        /// <p>Only used when <code>Type</code> is <code>S3</code>. The path to the artifact. Used with <code>Name</code> and <code>NamespaceType</code> to determine the pattern for storing the artifact.</p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.path = Some(input.into());
            self
        }
        /// <p>Only used when <code>Type</code> is <code>S3</code>. The path to the artifact. Used with <code>Name</code> and <code>NamespaceType</code> to determine the pattern for storing the artifact.</p>
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path = input;
            self
        }
        /// <p>The type of build artifact.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of build artifact.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCodeBuildProjectArtifactsDetails`](crate::model::AwsCodeBuildProjectArtifactsDetails)
        pub fn build(self) -> crate::model::AwsCodeBuildProjectArtifactsDetails {
            crate::model::AwsCodeBuildProjectArtifactsDetails {
                artifact_identifier: self.artifact_identifier,
                encryption_disabled: self.encryption_disabled.unwrap_or_default(),
                location: self.location,
                name: self.name,
                namespace_type: self.namespace_type,
                override_artifact_name: self.override_artifact_name.unwrap_or_default(),
                packaging: self.packaging,
                path: self.path,
                r#type: self.r#type,
            }
        }
    }
}
impl AwsCodeBuildProjectArtifactsDetails {
    /// Creates a new builder-style object to manufacture [`AwsCodeBuildProjectArtifactsDetails`](crate::model::AwsCodeBuildProjectArtifactsDetails)
    pub fn builder() -> crate::model::aws_code_build_project_artifacts_details::Builder {
        crate::model::aws_code_build_project_artifacts_details::Builder::default()
    }
}

/// <p>Information about the VPC configuration that CodeBuild accesses.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCodeBuildProjectVpcConfig {
    /// <p>The ID of the VPC.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>A list of one or more subnet IDs in your VPC.</p>
    pub subnets: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of one or more security group IDs in your VPC.</p>
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AwsCodeBuildProjectVpcConfig {
    /// <p>The ID of the VPC.</p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
    /// <p>A list of one or more subnet IDs in your VPC.</p>
    pub fn subnets(&self) -> std::option::Option<&[std::string::String]> {
        self.subnets.as_deref()
    }
    /// <p>A list of one or more security group IDs in your VPC.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
}
impl std::fmt::Debug for AwsCodeBuildProjectVpcConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCodeBuildProjectVpcConfig");
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("subnets", &self.subnets);
        formatter.field("security_group_ids", &self.security_group_ids);
        formatter.finish()
    }
}
/// See [`AwsCodeBuildProjectVpcConfig`](crate::model::AwsCodeBuildProjectVpcConfig)
pub mod aws_code_build_project_vpc_config {

    /// A builder for [`AwsCodeBuildProjectVpcConfig`](crate::model::AwsCodeBuildProjectVpcConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) subnets: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Appends an item to `subnets`.
        ///
        /// To override the contents of this collection use [`set_subnets`](Self::set_subnets).
        ///
        /// <p>A list of one or more subnet IDs in your VPC.</p>
        pub fn subnets(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnets.unwrap_or_default();
            v.push(input.into());
            self.subnets = Some(v);
            self
        }
        /// <p>A list of one or more subnet IDs in your VPC.</p>
        pub fn set_subnets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnets = input;
            self
        }
        /// Appends an item to `security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
        ///
        /// <p>A list of one or more security group IDs in your VPC.</p>
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        /// <p>A list of one or more security group IDs in your VPC.</p>
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCodeBuildProjectVpcConfig`](crate::model::AwsCodeBuildProjectVpcConfig)
        pub fn build(self) -> crate::model::AwsCodeBuildProjectVpcConfig {
            crate::model::AwsCodeBuildProjectVpcConfig {
                vpc_id: self.vpc_id,
                subnets: self.subnets,
                security_group_ids: self.security_group_ids,
            }
        }
    }
}
impl AwsCodeBuildProjectVpcConfig {
    /// Creates a new builder-style object to manufacture [`AwsCodeBuildProjectVpcConfig`](crate::model::AwsCodeBuildProjectVpcConfig)
    pub fn builder() -> crate::model::aws_code_build_project_vpc_config::Builder {
        crate::model::aws_code_build_project_vpc_config::Builder::default()
    }
}

/// <p>Information about logs for the build project.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCodeBuildProjectLogsConfigDetails {
    /// <p>Information about CloudWatch Logs for the build project.</p>
    pub cloud_watch_logs:
        std::option::Option<crate::model::AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails>,
    /// <p>Information about logs built to an S3 bucket for a build project.</p>
    pub s3_logs: std::option::Option<crate::model::AwsCodeBuildProjectLogsConfigS3LogsDetails>,
}
impl AwsCodeBuildProjectLogsConfigDetails {
    /// <p>Information about CloudWatch Logs for the build project.</p>
    pub fn cloud_watch_logs(
        &self,
    ) -> std::option::Option<&crate::model::AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails>
    {
        self.cloud_watch_logs.as_ref()
    }
    /// <p>Information about logs built to an S3 bucket for a build project.</p>
    pub fn s3_logs(
        &self,
    ) -> std::option::Option<&crate::model::AwsCodeBuildProjectLogsConfigS3LogsDetails> {
        self.s3_logs.as_ref()
    }
}
impl std::fmt::Debug for AwsCodeBuildProjectLogsConfigDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCodeBuildProjectLogsConfigDetails");
        formatter.field("cloud_watch_logs", &self.cloud_watch_logs);
        formatter.field("s3_logs", &self.s3_logs);
        formatter.finish()
    }
}
/// See [`AwsCodeBuildProjectLogsConfigDetails`](crate::model::AwsCodeBuildProjectLogsConfigDetails)
pub mod aws_code_build_project_logs_config_details {

    /// A builder for [`AwsCodeBuildProjectLogsConfigDetails`](crate::model::AwsCodeBuildProjectLogsConfigDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cloud_watch_logs:
            std::option::Option<crate::model::AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails>,
        pub(crate) s3_logs:
            std::option::Option<crate::model::AwsCodeBuildProjectLogsConfigS3LogsDetails>,
    }
    impl Builder {
        /// <p>Information about CloudWatch Logs for the build project.</p>
        pub fn cloud_watch_logs(
            mut self,
            input: crate::model::AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails,
        ) -> Self {
            self.cloud_watch_logs = Some(input);
            self
        }
        /// <p>Information about CloudWatch Logs for the build project.</p>
        pub fn set_cloud_watch_logs(
            mut self,
            input: std::option::Option<
                crate::model::AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails,
            >,
        ) -> Self {
            self.cloud_watch_logs = input;
            self
        }
        /// <p>Information about logs built to an S3 bucket for a build project.</p>
        pub fn s3_logs(
            mut self,
            input: crate::model::AwsCodeBuildProjectLogsConfigS3LogsDetails,
        ) -> Self {
            self.s3_logs = Some(input);
            self
        }
        /// <p>Information about logs built to an S3 bucket for a build project.</p>
        pub fn set_s3_logs(
            mut self,
            input: std::option::Option<crate::model::AwsCodeBuildProjectLogsConfigS3LogsDetails>,
        ) -> Self {
            self.s3_logs = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCodeBuildProjectLogsConfigDetails`](crate::model::AwsCodeBuildProjectLogsConfigDetails)
        pub fn build(self) -> crate::model::AwsCodeBuildProjectLogsConfigDetails {
            crate::model::AwsCodeBuildProjectLogsConfigDetails {
                cloud_watch_logs: self.cloud_watch_logs,
                s3_logs: self.s3_logs,
            }
        }
    }
}
impl AwsCodeBuildProjectLogsConfigDetails {
    /// Creates a new builder-style object to manufacture [`AwsCodeBuildProjectLogsConfigDetails`](crate::model::AwsCodeBuildProjectLogsConfigDetails)
    pub fn builder() -> crate::model::aws_code_build_project_logs_config_details::Builder {
        crate::model::aws_code_build_project_logs_config_details::Builder::default()
    }
}

/// <p>Information about logs built to an S3 bucket for a build project.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCodeBuildProjectLogsConfigS3LogsDetails {
    /// <p>Whether to disable encryption of the S3 build log output.</p>
    pub encryption_disabled: bool,
    /// <p>The ARN of the S3 bucket and the path prefix for S3 logs.</p>
    pub location: std::option::Option<std::string::String>,
    /// <p>The current status of the S3 build logs.</p>
    pub status: std::option::Option<std::string::String>,
}
impl AwsCodeBuildProjectLogsConfigS3LogsDetails {
    /// <p>Whether to disable encryption of the S3 build log output.</p>
    pub fn encryption_disabled(&self) -> bool {
        self.encryption_disabled
    }
    /// <p>The ARN of the S3 bucket and the path prefix for S3 logs.</p>
    pub fn location(&self) -> std::option::Option<&str> {
        self.location.as_deref()
    }
    /// <p>The current status of the S3 build logs.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
}
impl std::fmt::Debug for AwsCodeBuildProjectLogsConfigS3LogsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCodeBuildProjectLogsConfigS3LogsDetails");
        formatter.field("encryption_disabled", &self.encryption_disabled);
        formatter.field("location", &self.location);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`AwsCodeBuildProjectLogsConfigS3LogsDetails`](crate::model::AwsCodeBuildProjectLogsConfigS3LogsDetails)
pub mod aws_code_build_project_logs_config_s3_logs_details {

    /// A builder for [`AwsCodeBuildProjectLogsConfigS3LogsDetails`](crate::model::AwsCodeBuildProjectLogsConfigS3LogsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) encryption_disabled: std::option::Option<bool>,
        pub(crate) location: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Whether to disable encryption of the S3 build log output.</p>
        pub fn encryption_disabled(mut self, input: bool) -> Self {
            self.encryption_disabled = Some(input);
            self
        }
        /// <p>Whether to disable encryption of the S3 build log output.</p>
        pub fn set_encryption_disabled(mut self, input: std::option::Option<bool>) -> Self {
            self.encryption_disabled = input;
            self
        }
        /// <p>The ARN of the S3 bucket and the path prefix for S3 logs.</p>
        pub fn location(mut self, input: impl Into<std::string::String>) -> Self {
            self.location = Some(input.into());
            self
        }
        /// <p>The ARN of the S3 bucket and the path prefix for S3 logs.</p>
        pub fn set_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.location = input;
            self
        }
        /// <p>The current status of the S3 build logs.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The current status of the S3 build logs.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCodeBuildProjectLogsConfigS3LogsDetails`](crate::model::AwsCodeBuildProjectLogsConfigS3LogsDetails)
        pub fn build(self) -> crate::model::AwsCodeBuildProjectLogsConfigS3LogsDetails {
            crate::model::AwsCodeBuildProjectLogsConfigS3LogsDetails {
                encryption_disabled: self.encryption_disabled.unwrap_or_default(),
                location: self.location,
                status: self.status,
            }
        }
    }
}
impl AwsCodeBuildProjectLogsConfigS3LogsDetails {
    /// Creates a new builder-style object to manufacture [`AwsCodeBuildProjectLogsConfigS3LogsDetails`](crate::model::AwsCodeBuildProjectLogsConfigS3LogsDetails)
    pub fn builder() -> crate::model::aws_code_build_project_logs_config_s3_logs_details::Builder {
        crate::model::aws_code_build_project_logs_config_s3_logs_details::Builder::default()
    }
}

/// <p>Information about CloudWatch Logs for the build project.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails {
    /// <p>The group name of the logs in CloudWatch Logs.</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The current status of the logs in CloudWatch Logs for a build project.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>The prefix of the stream name of the CloudWatch Logs.</p>
    pub stream_name: std::option::Option<std::string::String>,
}
impl AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails {
    /// <p>The group name of the logs in CloudWatch Logs.</p>
    pub fn group_name(&self) -> std::option::Option<&str> {
        self.group_name.as_deref()
    }
    /// <p>The current status of the logs in CloudWatch Logs for a build project.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>The prefix of the stream name of the CloudWatch Logs.</p>
    pub fn stream_name(&self) -> std::option::Option<&str> {
        self.stream_name.as_deref()
    }
}
impl std::fmt::Debug for AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails");
        formatter.field("group_name", &self.group_name);
        formatter.field("status", &self.status);
        formatter.field("stream_name", &self.stream_name);
        formatter.finish()
    }
}
/// See [`AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails`](crate::model::AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails)
pub mod aws_code_build_project_logs_config_cloud_watch_logs_details {

    /// A builder for [`AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails`](crate::model::AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) stream_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The group name of the logs in CloudWatch Logs.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        /// <p>The group name of the logs in CloudWatch Logs.</p>
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// <p>The current status of the logs in CloudWatch Logs for a build project.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The current status of the logs in CloudWatch Logs for a build project.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>The prefix of the stream name of the CloudWatch Logs.</p>
        pub fn stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_name = Some(input.into());
            self
        }
        /// <p>The prefix of the stream name of the CloudWatch Logs.</p>
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stream_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails`](crate::model::AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails)
        pub fn build(self) -> crate::model::AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails {
            crate::model::AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails {
                group_name: self.group_name,
                status: self.status,
                stream_name: self.stream_name,
            }
        }
    }
}
impl AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails {
    /// Creates a new builder-style object to manufacture [`AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails`](crate::model::AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails)
    pub fn builder(
    ) -> crate::model::aws_code_build_project_logs_config_cloud_watch_logs_details::Builder {
        crate::model::aws_code_build_project_logs_config_cloud_watch_logs_details::Builder::default(
        )
    }
}

/// <p>Information about the build input source code for this build project.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCodeBuildProjectSource {
    /// <p>The type of repository that contains the source code to be built. Valid values are:</p>
    /// <ul>
    /// <li> <p> <code>BITBUCKET</code> - The source code is in a Bitbucket repository.</p> </li>
    /// <li> <p> <code>CODECOMMIT</code> - The source code is in an CodeCommit repository.</p> </li>
    /// <li> <p> <code>CODEPIPELINE</code> - The source code settings are specified in the source action of a pipeline in CodePipeline.</p> </li>
    /// <li> <p> <code>GITHUB</code> - The source code is in a GitHub repository.</p> </li>
    /// <li> <p> <code>GITHUB_ENTERPRISE</code> - The source code is in a GitHub Enterprise repository.</p> </li>
    /// <li> <p> <code>NO_SOURCE</code> - The project does not have input source code.</p> </li>
    /// <li> <p> <code>S3</code> - The source code is in an S3 input bucket. </p> </li>
    /// </ul>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>Information about the location of the source code to be built.</p>
    /// <p>Valid values include:</p>
    /// <ul>
    /// <li> <p>For source code settings that are specified in the source action of a pipeline in CodePipeline, location should not be specified. If it is specified, CodePipeline ignores it. This is because CodePipeline uses the settings in a pipeline's source action instead of this value.</p> </li>
    /// <li> <p>For source code in an CodeCommit repository, the HTTPS clone URL to the repository that contains the source code and the build spec file (for example, <code>https://git-codecommit.region-ID.amazonaws.com/v1/repos/repo-name</code> ).</p> </li>
    /// <li> <p>For source code in an S3 input bucket, one of the following.</p>
    /// <ul>
    /// <li> <p>The path to the ZIP file that contains the source code (for example, <code>bucket-name/path/to/object-name.zip</code>).</p> </li>
    /// <li> <p> The path to the folder that contains the source code (for example, <code>bucket-name/path/to/source-code/folder/</code>).</p> </li>
    /// </ul> </li>
    /// <li> <p>For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and the build spec file.</p> </li>
    /// <li> <p>For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source and the build spec file. </p> </li>
    /// </ul>
    pub location: std::option::Option<std::string::String>,
    /// <p>Information about the Git clone depth for the build project.</p>
    pub git_clone_depth: i32,
    /// <p>Whether to ignore SSL warnings while connecting to the project source code.</p>
    pub insecure_ssl: bool,
}
impl AwsCodeBuildProjectSource {
    /// <p>The type of repository that contains the source code to be built. Valid values are:</p>
    /// <ul>
    /// <li> <p> <code>BITBUCKET</code> - The source code is in a Bitbucket repository.</p> </li>
    /// <li> <p> <code>CODECOMMIT</code> - The source code is in an CodeCommit repository.</p> </li>
    /// <li> <p> <code>CODEPIPELINE</code> - The source code settings are specified in the source action of a pipeline in CodePipeline.</p> </li>
    /// <li> <p> <code>GITHUB</code> - The source code is in a GitHub repository.</p> </li>
    /// <li> <p> <code>GITHUB_ENTERPRISE</code> - The source code is in a GitHub Enterprise repository.</p> </li>
    /// <li> <p> <code>NO_SOURCE</code> - The project does not have input source code.</p> </li>
    /// <li> <p> <code>S3</code> - The source code is in an S3 input bucket. </p> </li>
    /// </ul>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>Information about the location of the source code to be built.</p>
    /// <p>Valid values include:</p>
    /// <ul>
    /// <li> <p>For source code settings that are specified in the source action of a pipeline in CodePipeline, location should not be specified. If it is specified, CodePipeline ignores it. This is because CodePipeline uses the settings in a pipeline's source action instead of this value.</p> </li>
    /// <li> <p>For source code in an CodeCommit repository, the HTTPS clone URL to the repository that contains the source code and the build spec file (for example, <code>https://git-codecommit.region-ID.amazonaws.com/v1/repos/repo-name</code> ).</p> </li>
    /// <li> <p>For source code in an S3 input bucket, one of the following.</p>
    /// <ul>
    /// <li> <p>The path to the ZIP file that contains the source code (for example, <code>bucket-name/path/to/object-name.zip</code>).</p> </li>
    /// <li> <p> The path to the folder that contains the source code (for example, <code>bucket-name/path/to/source-code/folder/</code>).</p> </li>
    /// </ul> </li>
    /// <li> <p>For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and the build spec file.</p> </li>
    /// <li> <p>For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source and the build spec file. </p> </li>
    /// </ul>
    pub fn location(&self) -> std::option::Option<&str> {
        self.location.as_deref()
    }
    /// <p>Information about the Git clone depth for the build project.</p>
    pub fn git_clone_depth(&self) -> i32 {
        self.git_clone_depth
    }
    /// <p>Whether to ignore SSL warnings while connecting to the project source code.</p>
    pub fn insecure_ssl(&self) -> bool {
        self.insecure_ssl
    }
}
impl std::fmt::Debug for AwsCodeBuildProjectSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCodeBuildProjectSource");
        formatter.field("r#type", &self.r#type);
        formatter.field("location", &self.location);
        formatter.field("git_clone_depth", &self.git_clone_depth);
        formatter.field("insecure_ssl", &self.insecure_ssl);
        formatter.finish()
    }
}
/// See [`AwsCodeBuildProjectSource`](crate::model::AwsCodeBuildProjectSource)
pub mod aws_code_build_project_source {

    /// A builder for [`AwsCodeBuildProjectSource`](crate::model::AwsCodeBuildProjectSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) location: std::option::Option<std::string::String>,
        pub(crate) git_clone_depth: std::option::Option<i32>,
        pub(crate) insecure_ssl: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The type of repository that contains the source code to be built. Valid values are:</p>
        /// <ul>
        /// <li> <p> <code>BITBUCKET</code> - The source code is in a Bitbucket repository.</p> </li>
        /// <li> <p> <code>CODECOMMIT</code> - The source code is in an CodeCommit repository.</p> </li>
        /// <li> <p> <code>CODEPIPELINE</code> - The source code settings are specified in the source action of a pipeline in CodePipeline.</p> </li>
        /// <li> <p> <code>GITHUB</code> - The source code is in a GitHub repository.</p> </li>
        /// <li> <p> <code>GITHUB_ENTERPRISE</code> - The source code is in a GitHub Enterprise repository.</p> </li>
        /// <li> <p> <code>NO_SOURCE</code> - The project does not have input source code.</p> </li>
        /// <li> <p> <code>S3</code> - The source code is in an S3 input bucket. </p> </li>
        /// </ul>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of repository that contains the source code to be built. Valid values are:</p>
        /// <ul>
        /// <li> <p> <code>BITBUCKET</code> - The source code is in a Bitbucket repository.</p> </li>
        /// <li> <p> <code>CODECOMMIT</code> - The source code is in an CodeCommit repository.</p> </li>
        /// <li> <p> <code>CODEPIPELINE</code> - The source code settings are specified in the source action of a pipeline in CodePipeline.</p> </li>
        /// <li> <p> <code>GITHUB</code> - The source code is in a GitHub repository.</p> </li>
        /// <li> <p> <code>GITHUB_ENTERPRISE</code> - The source code is in a GitHub Enterprise repository.</p> </li>
        /// <li> <p> <code>NO_SOURCE</code> - The project does not have input source code.</p> </li>
        /// <li> <p> <code>S3</code> - The source code is in an S3 input bucket. </p> </li>
        /// </ul>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Information about the location of the source code to be built.</p>
        /// <p>Valid values include:</p>
        /// <ul>
        /// <li> <p>For source code settings that are specified in the source action of a pipeline in CodePipeline, location should not be specified. If it is specified, CodePipeline ignores it. This is because CodePipeline uses the settings in a pipeline's source action instead of this value.</p> </li>
        /// <li> <p>For source code in an CodeCommit repository, the HTTPS clone URL to the repository that contains the source code and the build spec file (for example, <code>https://git-codecommit.region-ID.amazonaws.com/v1/repos/repo-name</code> ).</p> </li>
        /// <li> <p>For source code in an S3 input bucket, one of the following.</p>
        /// <ul>
        /// <li> <p>The path to the ZIP file that contains the source code (for example, <code>bucket-name/path/to/object-name.zip</code>).</p> </li>
        /// <li> <p> The path to the folder that contains the source code (for example, <code>bucket-name/path/to/source-code/folder/</code>).</p> </li>
        /// </ul> </li>
        /// <li> <p>For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and the build spec file.</p> </li>
        /// <li> <p>For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source and the build spec file. </p> </li>
        /// </ul>
        pub fn location(mut self, input: impl Into<std::string::String>) -> Self {
            self.location = Some(input.into());
            self
        }
        /// <p>Information about the location of the source code to be built.</p>
        /// <p>Valid values include:</p>
        /// <ul>
        /// <li> <p>For source code settings that are specified in the source action of a pipeline in CodePipeline, location should not be specified. If it is specified, CodePipeline ignores it. This is because CodePipeline uses the settings in a pipeline's source action instead of this value.</p> </li>
        /// <li> <p>For source code in an CodeCommit repository, the HTTPS clone URL to the repository that contains the source code and the build spec file (for example, <code>https://git-codecommit.region-ID.amazonaws.com/v1/repos/repo-name</code> ).</p> </li>
        /// <li> <p>For source code in an S3 input bucket, one of the following.</p>
        /// <ul>
        /// <li> <p>The path to the ZIP file that contains the source code (for example, <code>bucket-name/path/to/object-name.zip</code>).</p> </li>
        /// <li> <p> The path to the folder that contains the source code (for example, <code>bucket-name/path/to/source-code/folder/</code>).</p> </li>
        /// </ul> </li>
        /// <li> <p>For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and the build spec file.</p> </li>
        /// <li> <p>For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source and the build spec file. </p> </li>
        /// </ul>
        pub fn set_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.location = input;
            self
        }
        /// <p>Information about the Git clone depth for the build project.</p>
        pub fn git_clone_depth(mut self, input: i32) -> Self {
            self.git_clone_depth = Some(input);
            self
        }
        /// <p>Information about the Git clone depth for the build project.</p>
        pub fn set_git_clone_depth(mut self, input: std::option::Option<i32>) -> Self {
            self.git_clone_depth = input;
            self
        }
        /// <p>Whether to ignore SSL warnings while connecting to the project source code.</p>
        pub fn insecure_ssl(mut self, input: bool) -> Self {
            self.insecure_ssl = Some(input);
            self
        }
        /// <p>Whether to ignore SSL warnings while connecting to the project source code.</p>
        pub fn set_insecure_ssl(mut self, input: std::option::Option<bool>) -> Self {
            self.insecure_ssl = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCodeBuildProjectSource`](crate::model::AwsCodeBuildProjectSource)
        pub fn build(self) -> crate::model::AwsCodeBuildProjectSource {
            crate::model::AwsCodeBuildProjectSource {
                r#type: self.r#type,
                location: self.location,
                git_clone_depth: self.git_clone_depth.unwrap_or_default(),
                insecure_ssl: self.insecure_ssl.unwrap_or_default(),
            }
        }
    }
}
impl AwsCodeBuildProjectSource {
    /// Creates a new builder-style object to manufacture [`AwsCodeBuildProjectSource`](crate::model::AwsCodeBuildProjectSource)
    pub fn builder() -> crate::model::aws_code_build_project_source::Builder {
        crate::model::aws_code_build_project_source::Builder::default()
    }
}

/// <p>Information about the build environment for this build project.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCodeBuildProjectEnvironment {
    /// <p>The certificate to use with this build project.</p>
    pub certificate: std::option::Option<std::string::String>,
    /// <p>A set of environment variables to make available to builds for the build project.</p>
    pub environment_variables: std::option::Option<
        std::vec::Vec<crate::model::AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails>,
    >,
    /// <p>Whether to allow the Docker daemon to run inside a Docker container. Set to <code>true</code> if the build project is used to build Docker images.</p>
    pub privileged_mode: bool,
    /// <p>The type of credentials CodeBuild uses to pull images in your build.</p>
    /// <p>Valid values:</p>
    /// <ul>
    /// <li> <p> <code>CODEBUILD</code> specifies that CodeBuild uses its own credentials. This requires that you modify your ECR repository policy to trust the CodeBuild service principal.</p> </li>
    /// <li> <p> <code>SERVICE_ROLE</code> specifies that CodeBuild uses your build project's service role.</p> </li>
    /// </ul>
    /// <p>When you use a cross-account or private registry image, you must use <code>SERVICE_ROLE</code> credentials. When you use an CodeBuild curated image, you must use <code>CODEBUILD</code> credentials.</p>
    pub image_pull_credentials_type: std::option::Option<std::string::String>,
    /// <p>The credentials for access to a private registry.</p>
    pub registry_credential:
        std::option::Option<crate::model::AwsCodeBuildProjectEnvironmentRegistryCredential>,
    /// <p>The type of build environment to use for related builds.</p>
    /// <p>The environment type <code>ARM_CONTAINER</code> is available only in Regions US East (N. Virginia), US East (Ohio), US West (Oregon), Europe (Ireland), Asia Pacific (Mumbai), Asia Pacific (Tokyo), Asia Pacific (Sydney), and Europe (Frankfurt).</p>
    /// <p>The environment type <code>LINUX_CONTAINER</code> with compute type build.general1.2xlarge is available only in Regions US East (N. Virginia), US East (N. Virginia), US West (Oregon), Canada (Central), Europe (Ireland), Europe (London), Europe (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney), China (Beijing), and China (Ningxia).</p>
    /// <p>The environment type <code>LINUX_GPU_CONTAINER</code> is available only in Regions US East (N. Virginia), US East (N. Virginia), US West (Oregon), Canada (Central), Europe (Ireland), Europe (London), Europe (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney), China (Beijing), and China (Ningxia).</p>
    /// <p>Valid values: <code>WINDOWS_CONTAINER</code> | <code>LINUX_CONTAINER</code> | <code>LINUX_GPU_CONTAINER</code> | <code>ARM_CONTAINER</code> </p>
    pub r#type: std::option::Option<std::string::String>,
}
impl AwsCodeBuildProjectEnvironment {
    /// <p>The certificate to use with this build project.</p>
    pub fn certificate(&self) -> std::option::Option<&str> {
        self.certificate.as_deref()
    }
    /// <p>A set of environment variables to make available to builds for the build project.</p>
    pub fn environment_variables(
        &self,
    ) -> std::option::Option<
        &[crate::model::AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails],
    > {
        self.environment_variables.as_deref()
    }
    /// <p>Whether to allow the Docker daemon to run inside a Docker container. Set to <code>true</code> if the build project is used to build Docker images.</p>
    pub fn privileged_mode(&self) -> bool {
        self.privileged_mode
    }
    /// <p>The type of credentials CodeBuild uses to pull images in your build.</p>
    /// <p>Valid values:</p>
    /// <ul>
    /// <li> <p> <code>CODEBUILD</code> specifies that CodeBuild uses its own credentials. This requires that you modify your ECR repository policy to trust the CodeBuild service principal.</p> </li>
    /// <li> <p> <code>SERVICE_ROLE</code> specifies that CodeBuild uses your build project's service role.</p> </li>
    /// </ul>
    /// <p>When you use a cross-account or private registry image, you must use <code>SERVICE_ROLE</code> credentials. When you use an CodeBuild curated image, you must use <code>CODEBUILD</code> credentials.</p>
    pub fn image_pull_credentials_type(&self) -> std::option::Option<&str> {
        self.image_pull_credentials_type.as_deref()
    }
    /// <p>The credentials for access to a private registry.</p>
    pub fn registry_credential(
        &self,
    ) -> std::option::Option<&crate::model::AwsCodeBuildProjectEnvironmentRegistryCredential> {
        self.registry_credential.as_ref()
    }
    /// <p>The type of build environment to use for related builds.</p>
    /// <p>The environment type <code>ARM_CONTAINER</code> is available only in Regions US East (N. Virginia), US East (Ohio), US West (Oregon), Europe (Ireland), Asia Pacific (Mumbai), Asia Pacific (Tokyo), Asia Pacific (Sydney), and Europe (Frankfurt).</p>
    /// <p>The environment type <code>LINUX_CONTAINER</code> with compute type build.general1.2xlarge is available only in Regions US East (N. Virginia), US East (N. Virginia), US West (Oregon), Canada (Central), Europe (Ireland), Europe (London), Europe (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney), China (Beijing), and China (Ningxia).</p>
    /// <p>The environment type <code>LINUX_GPU_CONTAINER</code> is available only in Regions US East (N. Virginia), US East (N. Virginia), US West (Oregon), Canada (Central), Europe (Ireland), Europe (London), Europe (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney), China (Beijing), and China (Ningxia).</p>
    /// <p>Valid values: <code>WINDOWS_CONTAINER</code> | <code>LINUX_CONTAINER</code> | <code>LINUX_GPU_CONTAINER</code> | <code>ARM_CONTAINER</code> </p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for AwsCodeBuildProjectEnvironment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCodeBuildProjectEnvironment");
        formatter.field("certificate", &self.certificate);
        formatter.field("environment_variables", &self.environment_variables);
        formatter.field("privileged_mode", &self.privileged_mode);
        formatter.field(
            "image_pull_credentials_type",
            &self.image_pull_credentials_type,
        );
        formatter.field("registry_credential", &self.registry_credential);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AwsCodeBuildProjectEnvironment`](crate::model::AwsCodeBuildProjectEnvironment)
pub mod aws_code_build_project_environment {

    /// A builder for [`AwsCodeBuildProjectEnvironment`](crate::model::AwsCodeBuildProjectEnvironment)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) certificate: std::option::Option<std::string::String>,
        pub(crate) environment_variables: std::option::Option<
            std::vec::Vec<crate::model::AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails>,
        >,
        pub(crate) privileged_mode: std::option::Option<bool>,
        pub(crate) image_pull_credentials_type: std::option::Option<std::string::String>,
        pub(crate) registry_credential:
            std::option::Option<crate::model::AwsCodeBuildProjectEnvironmentRegistryCredential>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The certificate to use with this build project.</p>
        pub fn certificate(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate = Some(input.into());
            self
        }
        /// <p>The certificate to use with this build project.</p>
        pub fn set_certificate(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.certificate = input;
            self
        }
        /// Appends an item to `environment_variables`.
        ///
        /// To override the contents of this collection use [`set_environment_variables`](Self::set_environment_variables).
        ///
        /// <p>A set of environment variables to make available to builds for the build project.</p>
        pub fn environment_variables(
            mut self,
            input: crate::model::AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails,
        ) -> Self {
            let mut v = self.environment_variables.unwrap_or_default();
            v.push(input);
            self.environment_variables = Some(v);
            self
        }
        /// <p>A set of environment variables to make available to builds for the build project.</p>
        pub fn set_environment_variables(
            mut self,
            input: std::option::Option<
                std::vec::Vec<
                    crate::model::AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails,
                >,
            >,
        ) -> Self {
            self.environment_variables = input;
            self
        }
        /// <p>Whether to allow the Docker daemon to run inside a Docker container. Set to <code>true</code> if the build project is used to build Docker images.</p>
        pub fn privileged_mode(mut self, input: bool) -> Self {
            self.privileged_mode = Some(input);
            self
        }
        /// <p>Whether to allow the Docker daemon to run inside a Docker container. Set to <code>true</code> if the build project is used to build Docker images.</p>
        pub fn set_privileged_mode(mut self, input: std::option::Option<bool>) -> Self {
            self.privileged_mode = input;
            self
        }
        /// <p>The type of credentials CodeBuild uses to pull images in your build.</p>
        /// <p>Valid values:</p>
        /// <ul>
        /// <li> <p> <code>CODEBUILD</code> specifies that CodeBuild uses its own credentials. This requires that you modify your ECR repository policy to trust the CodeBuild service principal.</p> </li>
        /// <li> <p> <code>SERVICE_ROLE</code> specifies that CodeBuild uses your build project's service role.</p> </li>
        /// </ul>
        /// <p>When you use a cross-account or private registry image, you must use <code>SERVICE_ROLE</code> credentials. When you use an CodeBuild curated image, you must use <code>CODEBUILD</code> credentials.</p>
        pub fn image_pull_credentials_type(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.image_pull_credentials_type = Some(input.into());
            self
        }
        /// <p>The type of credentials CodeBuild uses to pull images in your build.</p>
        /// <p>Valid values:</p>
        /// <ul>
        /// <li> <p> <code>CODEBUILD</code> specifies that CodeBuild uses its own credentials. This requires that you modify your ECR repository policy to trust the CodeBuild service principal.</p> </li>
        /// <li> <p> <code>SERVICE_ROLE</code> specifies that CodeBuild uses your build project's service role.</p> </li>
        /// </ul>
        /// <p>When you use a cross-account or private registry image, you must use <code>SERVICE_ROLE</code> credentials. When you use an CodeBuild curated image, you must use <code>CODEBUILD</code> credentials.</p>
        pub fn set_image_pull_credentials_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.image_pull_credentials_type = input;
            self
        }
        /// <p>The credentials for access to a private registry.</p>
        pub fn registry_credential(
            mut self,
            input: crate::model::AwsCodeBuildProjectEnvironmentRegistryCredential,
        ) -> Self {
            self.registry_credential = Some(input);
            self
        }
        /// <p>The credentials for access to a private registry.</p>
        pub fn set_registry_credential(
            mut self,
            input: std::option::Option<
                crate::model::AwsCodeBuildProjectEnvironmentRegistryCredential,
            >,
        ) -> Self {
            self.registry_credential = input;
            self
        }
        /// <p>The type of build environment to use for related builds.</p>
        /// <p>The environment type <code>ARM_CONTAINER</code> is available only in Regions US East (N. Virginia), US East (Ohio), US West (Oregon), Europe (Ireland), Asia Pacific (Mumbai), Asia Pacific (Tokyo), Asia Pacific (Sydney), and Europe (Frankfurt).</p>
        /// <p>The environment type <code>LINUX_CONTAINER</code> with compute type build.general1.2xlarge is available only in Regions US East (N. Virginia), US East (N. Virginia), US West (Oregon), Canada (Central), Europe (Ireland), Europe (London), Europe (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney), China (Beijing), and China (Ningxia).</p>
        /// <p>The environment type <code>LINUX_GPU_CONTAINER</code> is available only in Regions US East (N. Virginia), US East (N. Virginia), US West (Oregon), Canada (Central), Europe (Ireland), Europe (London), Europe (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney), China (Beijing), and China (Ningxia).</p>
        /// <p>Valid values: <code>WINDOWS_CONTAINER</code> | <code>LINUX_CONTAINER</code> | <code>LINUX_GPU_CONTAINER</code> | <code>ARM_CONTAINER</code> </p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of build environment to use for related builds.</p>
        /// <p>The environment type <code>ARM_CONTAINER</code> is available only in Regions US East (N. Virginia), US East (Ohio), US West (Oregon), Europe (Ireland), Asia Pacific (Mumbai), Asia Pacific (Tokyo), Asia Pacific (Sydney), and Europe (Frankfurt).</p>
        /// <p>The environment type <code>LINUX_CONTAINER</code> with compute type build.general1.2xlarge is available only in Regions US East (N. Virginia), US East (N. Virginia), US West (Oregon), Canada (Central), Europe (Ireland), Europe (London), Europe (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney), China (Beijing), and China (Ningxia).</p>
        /// <p>The environment type <code>LINUX_GPU_CONTAINER</code> is available only in Regions US East (N. Virginia), US East (N. Virginia), US West (Oregon), Canada (Central), Europe (Ireland), Europe (London), Europe (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney), China (Beijing), and China (Ningxia).</p>
        /// <p>Valid values: <code>WINDOWS_CONTAINER</code> | <code>LINUX_CONTAINER</code> | <code>LINUX_GPU_CONTAINER</code> | <code>ARM_CONTAINER</code> </p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCodeBuildProjectEnvironment`](crate::model::AwsCodeBuildProjectEnvironment)
        pub fn build(self) -> crate::model::AwsCodeBuildProjectEnvironment {
            crate::model::AwsCodeBuildProjectEnvironment {
                certificate: self.certificate,
                environment_variables: self.environment_variables,
                privileged_mode: self.privileged_mode.unwrap_or_default(),
                image_pull_credentials_type: self.image_pull_credentials_type,
                registry_credential: self.registry_credential,
                r#type: self.r#type,
            }
        }
    }
}
impl AwsCodeBuildProjectEnvironment {
    /// Creates a new builder-style object to manufacture [`AwsCodeBuildProjectEnvironment`](crate::model::AwsCodeBuildProjectEnvironment)
    pub fn builder() -> crate::model::aws_code_build_project_environment::Builder {
        crate::model::aws_code_build_project_environment::Builder::default()
    }
}

/// <p>The credentials for access to a private registry.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCodeBuildProjectEnvironmentRegistryCredential {
    /// <p>The ARN or name of credentials created using Secrets Manager.</p> <note>
    /// <p>The credential can use the name of the credentials only if they exist in your current Amazon Web Services Region. </p>
    /// </note>
    pub credential: std::option::Option<std::string::String>,
    /// <p>The service that created the credentials to access a private Docker registry.</p>
    /// <p>The valid value,<code> SECRETS_MANAGER</code>, is for Secrets Manager.</p>
    pub credential_provider: std::option::Option<std::string::String>,
}
impl AwsCodeBuildProjectEnvironmentRegistryCredential {
    /// <p>The ARN or name of credentials created using Secrets Manager.</p> <note>
    /// <p>The credential can use the name of the credentials only if they exist in your current Amazon Web Services Region. </p>
    /// </note>
    pub fn credential(&self) -> std::option::Option<&str> {
        self.credential.as_deref()
    }
    /// <p>The service that created the credentials to access a private Docker registry.</p>
    /// <p>The valid value,<code> SECRETS_MANAGER</code>, is for Secrets Manager.</p>
    pub fn credential_provider(&self) -> std::option::Option<&str> {
        self.credential_provider.as_deref()
    }
}
impl std::fmt::Debug for AwsCodeBuildProjectEnvironmentRegistryCredential {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCodeBuildProjectEnvironmentRegistryCredential");
        formatter.field("credential", &self.credential);
        formatter.field("credential_provider", &self.credential_provider);
        formatter.finish()
    }
}
/// See [`AwsCodeBuildProjectEnvironmentRegistryCredential`](crate::model::AwsCodeBuildProjectEnvironmentRegistryCredential)
pub mod aws_code_build_project_environment_registry_credential {

    /// A builder for [`AwsCodeBuildProjectEnvironmentRegistryCredential`](crate::model::AwsCodeBuildProjectEnvironmentRegistryCredential)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) credential: std::option::Option<std::string::String>,
        pub(crate) credential_provider: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN or name of credentials created using Secrets Manager.</p> <note>
        /// <p>The credential can use the name of the credentials only if they exist in your current Amazon Web Services Region. </p>
        /// </note>
        pub fn credential(mut self, input: impl Into<std::string::String>) -> Self {
            self.credential = Some(input.into());
            self
        }
        /// <p>The ARN or name of credentials created using Secrets Manager.</p> <note>
        /// <p>The credential can use the name of the credentials only if they exist in your current Amazon Web Services Region. </p>
        /// </note>
        pub fn set_credential(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.credential = input;
            self
        }
        /// <p>The service that created the credentials to access a private Docker registry.</p>
        /// <p>The valid value,<code> SECRETS_MANAGER</code>, is for Secrets Manager.</p>
        pub fn credential_provider(mut self, input: impl Into<std::string::String>) -> Self {
            self.credential_provider = Some(input.into());
            self
        }
        /// <p>The service that created the credentials to access a private Docker registry.</p>
        /// <p>The valid value,<code> SECRETS_MANAGER</code>, is for Secrets Manager.</p>
        pub fn set_credential_provider(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.credential_provider = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCodeBuildProjectEnvironmentRegistryCredential`](crate::model::AwsCodeBuildProjectEnvironmentRegistryCredential)
        pub fn build(self) -> crate::model::AwsCodeBuildProjectEnvironmentRegistryCredential {
            crate::model::AwsCodeBuildProjectEnvironmentRegistryCredential {
                credential: self.credential,
                credential_provider: self.credential_provider,
            }
        }
    }
}
impl AwsCodeBuildProjectEnvironmentRegistryCredential {
    /// Creates a new builder-style object to manufacture [`AwsCodeBuildProjectEnvironmentRegistryCredential`](crate::model::AwsCodeBuildProjectEnvironmentRegistryCredential)
    pub fn builder() -> crate::model::aws_code_build_project_environment_registry_credential::Builder
    {
        crate::model::aws_code_build_project_environment_registry_credential::Builder::default()
    }
}

/// <p>Information about an environment variable that is available to builds for the build project.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails {
    /// <p>The name of the environment variable.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of environment variable.</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The value of the environment variable.</p>
    pub value: std::option::Option<std::string::String>,
}
impl AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails {
    /// <p>The name of the environment variable.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of environment variable.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The value of the environment variable.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails");
        formatter.field("name", &self.name);
        formatter.field("r#type", &self.r#type);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails`](crate::model::AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails)
pub mod aws_code_build_project_environment_environment_variables_details {

    /// A builder for [`AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails`](crate::model::AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the environment variable.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the environment variable.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of environment variable.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of environment variable.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The value of the environment variable.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the environment variable.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails`](crate::model::AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails {
            crate::model::AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails {
                name: self.name,
                r#type: self.r#type,
                value: self.value,
            }
        }
    }
}
impl AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails {
    /// Creates a new builder-style object to manufacture [`AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails`](crate::model::AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails)
    pub fn builder(
    ) -> crate::model::aws_code_build_project_environment_environment_variables_details::Builder
    {
        crate::model::aws_code_build_project_environment_environment_variables_details::Builder::default()
    }
}

/// <p>Provides details about an auto scaling group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsAutoScalingAutoScalingGroupDetails {
    /// <p>The name of the launch configuration.</p>
    pub launch_configuration_name: std::option::Option<std::string::String>,
    /// <p>The list of load balancers associated with the group.</p>
    pub load_balancer_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The service to use for the health checks.</p>
    pub health_check_type: std::option::Option<std::string::String>,
    /// <p>The amount of time, in seconds, that Amazon EC2 Auto Scaling waits before it checks the health status of an EC2 instance that has come into service.</p>
    pub health_check_grace_period: i32,
    /// <p>Indicates when the auto scaling group was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub created_time: std::option::Option<std::string::String>,
    /// <p>The mixed instances policy for the automatic scaling group.</p>
    pub mixed_instances_policy: std::option::Option<
        crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails,
    >,
    /// <p>The list of Availability Zones for the automatic scaling group.</p>
    pub availability_zones: std::option::Option<
        std::vec::Vec<crate::model::AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails>,
    >,
    /// <p>The launch template to use.</p>
    pub launch_template: std::option::Option<
        crate::model::AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification,
    >,
    /// <p>Indicates whether capacity rebalancing is enabled. </p>
    pub capacity_rebalance: bool,
}
impl AwsAutoScalingAutoScalingGroupDetails {
    /// <p>The name of the launch configuration.</p>
    pub fn launch_configuration_name(&self) -> std::option::Option<&str> {
        self.launch_configuration_name.as_deref()
    }
    /// <p>The list of load balancers associated with the group.</p>
    pub fn load_balancer_names(&self) -> std::option::Option<&[std::string::String]> {
        self.load_balancer_names.as_deref()
    }
    /// <p>The service to use for the health checks.</p>
    pub fn health_check_type(&self) -> std::option::Option<&str> {
        self.health_check_type.as_deref()
    }
    /// <p>The amount of time, in seconds, that Amazon EC2 Auto Scaling waits before it checks the health status of an EC2 instance that has come into service.</p>
    pub fn health_check_grace_period(&self) -> i32 {
        self.health_check_grace_period
    }
    /// <p>Indicates when the auto scaling group was created.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn created_time(&self) -> std::option::Option<&str> {
        self.created_time.as_deref()
    }
    /// <p>The mixed instances policy for the automatic scaling group.</p>
    pub fn mixed_instances_policy(
        &self,
    ) -> std::option::Option<&crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails>
    {
        self.mixed_instances_policy.as_ref()
    }
    /// <p>The list of Availability Zones for the automatic scaling group.</p>
    pub fn availability_zones(
        &self,
    ) -> std::option::Option<
        &[crate::model::AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails],
    > {
        self.availability_zones.as_deref()
    }
    /// <p>The launch template to use.</p>
    pub fn launch_template(
        &self,
    ) -> std::option::Option<
        &crate::model::AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification,
    > {
        self.launch_template.as_ref()
    }
    /// <p>Indicates whether capacity rebalancing is enabled. </p>
    pub fn capacity_rebalance(&self) -> bool {
        self.capacity_rebalance
    }
}
impl std::fmt::Debug for AwsAutoScalingAutoScalingGroupDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsAutoScalingAutoScalingGroupDetails");
        formatter.field("launch_configuration_name", &self.launch_configuration_name);
        formatter.field("load_balancer_names", &self.load_balancer_names);
        formatter.field("health_check_type", &self.health_check_type);
        formatter.field("health_check_grace_period", &self.health_check_grace_period);
        formatter.field("created_time", &self.created_time);
        formatter.field("mixed_instances_policy", &self.mixed_instances_policy);
        formatter.field("availability_zones", &self.availability_zones);
        formatter.field("launch_template", &self.launch_template);
        formatter.field("capacity_rebalance", &self.capacity_rebalance);
        formatter.finish()
    }
}
/// See [`AwsAutoScalingAutoScalingGroupDetails`](crate::model::AwsAutoScalingAutoScalingGroupDetails)
pub mod aws_auto_scaling_auto_scaling_group_details {

    /// A builder for [`AwsAutoScalingAutoScalingGroupDetails`](crate::model::AwsAutoScalingAutoScalingGroupDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) launch_configuration_name: std::option::Option<std::string::String>,
        pub(crate) load_balancer_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) health_check_type: std::option::Option<std::string::String>,
        pub(crate) health_check_grace_period: std::option::Option<i32>,
        pub(crate) created_time: std::option::Option<std::string::String>,
        pub(crate) mixed_instances_policy: std::option::Option<
            crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails,
        >,
        pub(crate) availability_zones: std::option::Option<
            std::vec::Vec<crate::model::AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails>,
        >,
        pub(crate) launch_template: std::option::Option<
            crate::model::AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification,
        >,
        pub(crate) capacity_rebalance: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the launch configuration.</p>
        pub fn launch_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_configuration_name = Some(input.into());
            self
        }
        /// <p>The name of the launch configuration.</p>
        pub fn set_launch_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_configuration_name = input;
            self
        }
        /// Appends an item to `load_balancer_names`.
        ///
        /// To override the contents of this collection use [`set_load_balancer_names`](Self::set_load_balancer_names).
        ///
        /// <p>The list of load balancers associated with the group.</p>
        pub fn load_balancer_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.load_balancer_names.unwrap_or_default();
            v.push(input.into());
            self.load_balancer_names = Some(v);
            self
        }
        /// <p>The list of load balancers associated with the group.</p>
        pub fn set_load_balancer_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.load_balancer_names = input;
            self
        }
        /// <p>The service to use for the health checks.</p>
        pub fn health_check_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.health_check_type = Some(input.into());
            self
        }
        /// <p>The service to use for the health checks.</p>
        pub fn set_health_check_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.health_check_type = input;
            self
        }
        /// <p>The amount of time, in seconds, that Amazon EC2 Auto Scaling waits before it checks the health status of an EC2 instance that has come into service.</p>
        pub fn health_check_grace_period(mut self, input: i32) -> Self {
            self.health_check_grace_period = Some(input);
            self
        }
        /// <p>The amount of time, in seconds, that Amazon EC2 Auto Scaling waits before it checks the health status of an EC2 instance that has come into service.</p>
        pub fn set_health_check_grace_period(mut self, input: std::option::Option<i32>) -> Self {
            self.health_check_grace_period = input;
            self
        }
        /// <p>Indicates when the auto scaling group was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn created_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_time = Some(input.into());
            self
        }
        /// <p>Indicates when the auto scaling group was created.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_created_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The mixed instances policy for the automatic scaling group.</p>
        pub fn mixed_instances_policy(
            mut self,
            input: crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails,
        ) -> Self {
            self.mixed_instances_policy = Some(input);
            self
        }
        /// <p>The mixed instances policy for the automatic scaling group.</p>
        pub fn set_mixed_instances_policy(
            mut self,
            input: std::option::Option<
                crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails,
            >,
        ) -> Self {
            self.mixed_instances_policy = input;
            self
        }
        /// Appends an item to `availability_zones`.
        ///
        /// To override the contents of this collection use [`set_availability_zones`](Self::set_availability_zones).
        ///
        /// <p>The list of Availability Zones for the automatic scaling group.</p>
        pub fn availability_zones(
            mut self,
            input: crate::model::AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails,
        ) -> Self {
            let mut v = self.availability_zones.unwrap_or_default();
            v.push(input);
            self.availability_zones = Some(v);
            self
        }
        /// <p>The list of Availability Zones for the automatic scaling group.</p>
        pub fn set_availability_zones(
            mut self,
            input: std::option::Option<
                std::vec::Vec<
                    crate::model::AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails,
                >,
            >,
        ) -> Self {
            self.availability_zones = input;
            self
        }
        /// <p>The launch template to use.</p>
        pub fn launch_template(
            mut self,
            input: crate::model::AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification,
        ) -> Self {
            self.launch_template = Some(input);
            self
        }
        /// <p>The launch template to use.</p>
        pub fn set_launch_template(
            mut self,
            input: std::option::Option<crate::model::AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification>,
        ) -> Self {
            self.launch_template = input;
            self
        }
        /// <p>Indicates whether capacity rebalancing is enabled. </p>
        pub fn capacity_rebalance(mut self, input: bool) -> Self {
            self.capacity_rebalance = Some(input);
            self
        }
        /// <p>Indicates whether capacity rebalancing is enabled. </p>
        pub fn set_capacity_rebalance(mut self, input: std::option::Option<bool>) -> Self {
            self.capacity_rebalance = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsAutoScalingAutoScalingGroupDetails`](crate::model::AwsAutoScalingAutoScalingGroupDetails)
        pub fn build(self) -> crate::model::AwsAutoScalingAutoScalingGroupDetails {
            crate::model::AwsAutoScalingAutoScalingGroupDetails {
                launch_configuration_name: self.launch_configuration_name,
                load_balancer_names: self.load_balancer_names,
                health_check_type: self.health_check_type,
                health_check_grace_period: self.health_check_grace_period.unwrap_or_default(),
                created_time: self.created_time,
                mixed_instances_policy: self.mixed_instances_policy,
                availability_zones: self.availability_zones,
                launch_template: self.launch_template,
                capacity_rebalance: self.capacity_rebalance.unwrap_or_default(),
            }
        }
    }
}
impl AwsAutoScalingAutoScalingGroupDetails {
    /// Creates a new builder-style object to manufacture [`AwsAutoScalingAutoScalingGroupDetails`](crate::model::AwsAutoScalingAutoScalingGroupDetails)
    pub fn builder() -> crate::model::aws_auto_scaling_auto_scaling_group_details::Builder {
        crate::model::aws_auto_scaling_auto_scaling_group_details::Builder::default()
    }
}

/// <p>Details about the launch template to use.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification {
    /// <p>The identifier of the launch template. You must specify either <code>LaunchTemplateId</code> or <code>LaunchTemplateName</code>.</p>
    pub launch_template_id: std::option::Option<std::string::String>,
    /// <p>The name of the launch template. You must specify either <code>LaunchTemplateId</code> or <code>LaunchTemplateName</code>.</p>
    pub launch_template_name: std::option::Option<std::string::String>,
    /// <p>Identifies the version of the launch template. You can specify a version identifier, or use the values <code>$Latest</code> or <code>$Default</code>.</p>
    pub version: std::option::Option<std::string::String>,
}
impl AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification {
    /// <p>The identifier of the launch template. You must specify either <code>LaunchTemplateId</code> or <code>LaunchTemplateName</code>.</p>
    pub fn launch_template_id(&self) -> std::option::Option<&str> {
        self.launch_template_id.as_deref()
    }
    /// <p>The name of the launch template. You must specify either <code>LaunchTemplateId</code> or <code>LaunchTemplateName</code>.</p>
    pub fn launch_template_name(&self) -> std::option::Option<&str> {
        self.launch_template_name.as_deref()
    }
    /// <p>Identifies the version of the launch template. You can specify a version identifier, or use the values <code>$Latest</code> or <code>$Default</code>.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
}
impl std::fmt::Debug for AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct(
            "AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification",
        );
        formatter.field("launch_template_id", &self.launch_template_id);
        formatter.field("launch_template_name", &self.launch_template_name);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification`](crate::model::AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification)
pub mod aws_auto_scaling_auto_scaling_group_launch_template_launch_template_specification {

    /// A builder for [`AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification`](crate::model::AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) launch_template_id: std::option::Option<std::string::String>,
        pub(crate) launch_template_name: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the launch template. You must specify either <code>LaunchTemplateId</code> or <code>LaunchTemplateName</code>.</p>
        pub fn launch_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_template_id = Some(input.into());
            self
        }
        /// <p>The identifier of the launch template. You must specify either <code>LaunchTemplateId</code> or <code>LaunchTemplateName</code>.</p>
        pub fn set_launch_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_template_id = input;
            self
        }
        /// <p>The name of the launch template. You must specify either <code>LaunchTemplateId</code> or <code>LaunchTemplateName</code>.</p>
        pub fn launch_template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_template_name = Some(input.into());
            self
        }
        /// <p>The name of the launch template. You must specify either <code>LaunchTemplateId</code> or <code>LaunchTemplateName</code>.</p>
        pub fn set_launch_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_template_name = input;
            self
        }
        /// <p>Identifies the version of the launch template. You can specify a version identifier, or use the values <code>$Latest</code> or <code>$Default</code>.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>Identifies the version of the launch template. You can specify a version identifier, or use the values <code>$Latest</code> or <code>$Default</code>.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification`](crate::model::AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification)
        pub fn build(
            self,
        ) -> crate::model::AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification
        {
            crate::model::AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification {
                launch_template_id: self.launch_template_id,
                launch_template_name: self.launch_template_name,
                version: self.version,
            }
        }
    }
}
impl AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification {
    /// Creates a new builder-style object to manufacture [`AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification`](crate::model::AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification)
    pub fn builder() -> crate::model::aws_auto_scaling_auto_scaling_group_launch_template_launch_template_specification::Builder{
        crate::model::aws_auto_scaling_auto_scaling_group_launch_template_launch_template_specification::Builder::default()
    }
}

/// <p>An Availability Zone for the automatic scaling group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails {
    /// <p>The name of the Availability Zone.</p>
    pub value: std::option::Option<std::string::String>,
}
impl AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails {
    /// <p>The name of the Availability Zone.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails");
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails`](crate::model::AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails)
pub mod aws_auto_scaling_auto_scaling_group_availability_zones_list_details {

    /// A builder for [`AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails`](crate::model::AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Availability Zone.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The name of the Availability Zone.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails`](crate::model::AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails {
            crate::model::AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails {
                value: self.value,
            }
        }
    }
}
impl AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails {
    /// Creates a new builder-style object to manufacture [`AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails`](crate::model::AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails)
    pub fn builder(
    ) -> crate::model::aws_auto_scaling_auto_scaling_group_availability_zones_list_details::Builder
    {
        crate::model::aws_auto_scaling_auto_scaling_group_availability_zones_list_details::Builder::default()
    }
}

/// <p>The mixed instances policy for the automatic scaling group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails  {
    /// <p>The instances distribution. The instances distribution specifies the distribution of On-Demand Instances and Spot Instances, the maximum price to pay for Spot Instances, and how the Auto Scaling group allocates instance types to fulfill On-Demand and Spot capacity.</p>
    pub instances_distribution: std::option::Option<crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails>,
    /// <p>The launch template to use and the instance types (overrides) to use to provision EC2 instances to fulfill On-Demand and Spot capacities.</p>
    pub launch_template: std::option::Option<crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails>,
}
impl AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails {
    /// <p>The instances distribution. The instances distribution specifies the distribution of On-Demand Instances and Spot Instances, the maximum price to pay for Spot Instances, and how the Auto Scaling group allocates instance types to fulfill On-Demand and Spot capacity.</p>
    pub fn instances_distribution(&self) -> std::option::Option<& crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails>{
        self.instances_distribution.as_ref()
    }
    /// <p>The launch template to use and the instance types (overrides) to use to provision EC2 instances to fulfill On-Demand and Spot capacities.</p>
    pub fn launch_template(
        &self,
    ) -> std::option::Option<
        &crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails,
    > {
        self.launch_template.as_ref()
    }
}
impl std::fmt::Debug for AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails");
        formatter.field("instances_distribution", &self.instances_distribution);
        formatter.field("launch_template", &self.launch_template);
        formatter.finish()
    }
}
/// See [`AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails`](crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails)
pub mod aws_auto_scaling_auto_scaling_group_mixed_instances_policy_details {

    /// A builder for [`AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails`](crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instances_distribution: std::option::Option<crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails>,
        pub(crate) launch_template: std::option::Option<crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails>,
    }
    impl Builder {
        /// <p>The instances distribution. The instances distribution specifies the distribution of On-Demand Instances and Spot Instances, the maximum price to pay for Spot Instances, and how the Auto Scaling group allocates instance types to fulfill On-Demand and Spot capacity.</p>
        pub fn instances_distribution(
            mut self,
            input: crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails,
        ) -> Self {
            self.instances_distribution = Some(input);
            self
        }
        /// <p>The instances distribution. The instances distribution specifies the distribution of On-Demand Instances and Spot Instances, the maximum price to pay for Spot Instances, and how the Auto Scaling group allocates instance types to fulfill On-Demand and Spot capacity.</p>
        pub fn set_instances_distribution(
            mut self,
            input: std::option::Option<crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails>,
        ) -> Self {
            self.instances_distribution = input;
            self
        }
        /// <p>The launch template to use and the instance types (overrides) to use to provision EC2 instances to fulfill On-Demand and Spot capacities.</p>
        pub fn launch_template(
            mut self,
            input: crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails,
        ) -> Self {
            self.launch_template = Some(input);
            self
        }
        /// <p>The launch template to use and the instance types (overrides) to use to provision EC2 instances to fulfill On-Demand and Spot capacities.</p>
        pub fn set_launch_template(
            mut self,
            input: std::option::Option<crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails>,
        ) -> Self {
            self.launch_template = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails`](crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails {
            crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails {
                instances_distribution: self.instances_distribution,
                launch_template: self.launch_template,
            }
        }
    }
}
impl AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails {
    /// Creates a new builder-style object to manufacture [`AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails`](crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails)
    pub fn builder(
    ) -> crate::model::aws_auto_scaling_auto_scaling_group_mixed_instances_policy_details::Builder
    {
        crate::model::aws_auto_scaling_auto_scaling_group_mixed_instances_policy_details::Builder::default()
    }
}

/// <p>Describes a launch template and overrides for a mixed instances policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails  {
    /// <p>The launch template to use for a mixed instances policy.</p>
    pub launch_template_specification: std::option::Option<crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification>,
    /// <p>Property values to use to override the values in the launch template.</p>
    pub overrides: std::option::Option<std::vec::Vec<crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails>>,
}
impl AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails {
    /// <p>The launch template to use for a mixed instances policy.</p>
    pub fn launch_template_specification(&self) -> std::option::Option<& crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification>{
        self.launch_template_specification.as_ref()
    }
    /// <p>Property values to use to override the values in the launch template.</p>
    pub fn overrides(&self) -> std::option::Option<& [crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails]>{
        self.overrides.as_deref()
    }
}
impl std::fmt::Debug for AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct(
            "AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails",
        );
        formatter.field(
            "launch_template_specification",
            &self.launch_template_specification,
        );
        formatter.field("overrides", &self.overrides);
        formatter.finish()
    }
}
/// See [`AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails`](crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails)
pub mod aws_auto_scaling_auto_scaling_group_mixed_instances_policy_launch_template_details {

    /// A builder for [`AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails`](crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) launch_template_specification: std::option::Option<crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification>,
        pub(crate) overrides: std::option::Option<std::vec::Vec<crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails>>,
    }
    impl Builder {
        /// <p>The launch template to use for a mixed instances policy.</p>
        pub fn launch_template_specification(
            mut self,
            input: crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification,
        ) -> Self {
            self.launch_template_specification = Some(input);
            self
        }
        /// <p>The launch template to use for a mixed instances policy.</p>
        pub fn set_launch_template_specification(
            mut self,
            input: std::option::Option<crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification>,
        ) -> Self {
            self.launch_template_specification = input;
            self
        }
        /// Appends an item to `overrides`.
        ///
        /// To override the contents of this collection use [`set_overrides`](Self::set_overrides).
        ///
        /// <p>Property values to use to override the values in the launch template.</p>
        pub fn overrides(
            mut self,
            input: crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails,
        ) -> Self {
            let mut v = self.overrides.unwrap_or_default();
            v.push(input);
            self.overrides = Some(v);
            self
        }
        /// <p>Property values to use to override the values in the launch template.</p>
        pub fn set_overrides(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails>>,
        ) -> Self {
            self.overrides = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails`](crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails)
        pub fn build(
            self,
        ) -> crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails
        {
            crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails {
                launch_template_specification: self.launch_template_specification,
                overrides: self.overrides,
            }
        }
    }
}
impl AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails {
    /// Creates a new builder-style object to manufacture [`AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails`](crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails)
    pub fn builder() -> crate::model::aws_auto_scaling_auto_scaling_group_mixed_instances_policy_launch_template_details::Builder{
        crate::model::aws_auto_scaling_auto_scaling_group_mixed_instances_policy_launch_template_details::Builder::default()
    }
}

/// <p>Property values to use to override the values in the launch template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails {
    /// <p>The instance type. For example, <code>m3.xlarge</code>.</p>
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>The number of capacity units provided by the specified instance type in terms of virtual CPUs, memory, storage, throughput, or other relative performance characteristic.</p>
    pub weighted_capacity: std::option::Option<std::string::String>,
}
impl AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails {
    /// <p>The instance type. For example, <code>m3.xlarge</code>.</p>
    pub fn instance_type(&self) -> std::option::Option<&str> {
        self.instance_type.as_deref()
    }
    /// <p>The number of capacity units provided by the specified instance type in terms of virtual CPUs, memory, storage, throughput, or other relative performance characteristic.</p>
    pub fn weighted_capacity(&self) -> std::option::Option<&str> {
        self.weighted_capacity.as_deref()
    }
}
impl std::fmt::Debug
    for AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct(
            "AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails",
        );
        formatter.field("instance_type", &self.instance_type);
        formatter.field("weighted_capacity", &self.weighted_capacity);
        formatter.finish()
    }
}
/// See [`AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails`](crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails)
pub mod aws_auto_scaling_auto_scaling_group_mixed_instances_policy_launch_template_overrides_list_details {

    /// A builder for [`AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails`](crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) weighted_capacity: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The instance type. For example, <code>m3.xlarge</code>.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        /// <p>The instance type. For example, <code>m3.xlarge</code>.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The number of capacity units provided by the specified instance type in terms of virtual CPUs, memory, storage, throughput, or other relative performance characteristic.</p>
        pub fn weighted_capacity(mut self, input: impl Into<std::string::String>) -> Self {
            self.weighted_capacity = Some(input.into());
            self
        }
        /// <p>The number of capacity units provided by the specified instance type in terms of virtual CPUs, memory, storage, throughput, or other relative performance characteristic.</p>
        pub fn set_weighted_capacity(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.weighted_capacity = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails`](crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails)
        pub fn build(self) -> crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails{
            crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails {
                instance_type: self.instance_type
                ,
                weighted_capacity: self.weighted_capacity
                ,
            }
        }
    }
}
impl AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails {
    /// Creates a new builder-style object to manufacture [`AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails`](crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails)
    pub fn builder() -> crate::model::aws_auto_scaling_auto_scaling_group_mixed_instances_policy_launch_template_overrides_list_details::Builder{
        crate::model::aws_auto_scaling_auto_scaling_group_mixed_instances_policy_launch_template_overrides_list_details::Builder::default()
    }
}

/// <p>Details about the launch template to use for a mixed instances policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification
{
    /// <p>The identifier of the launch template. You must specify either <code>LaunchTemplateId</code> or <code>LaunchTemplateName</code>.</p>
    pub launch_template_id: std::option::Option<std::string::String>,
    /// <p>The name of the launch template. You must specify either <code>LaunchTemplateId</code> or <code>LaunchTemplateName</code>.</p>
    pub launch_template_name: std::option::Option<std::string::String>,
    /// <p>Identifies the version of the launch template. You can specify a version identifier, or use the values <code>$Latest</code> or <code>$Default</code>.</p>
    pub version: std::option::Option<std::string::String>,
}
impl AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification {
    /// <p>The identifier of the launch template. You must specify either <code>LaunchTemplateId</code> or <code>LaunchTemplateName</code>.</p>
    pub fn launch_template_id(&self) -> std::option::Option<&str> {
        self.launch_template_id.as_deref()
    }
    /// <p>The name of the launch template. You must specify either <code>LaunchTemplateId</code> or <code>LaunchTemplateName</code>.</p>
    pub fn launch_template_name(&self) -> std::option::Option<&str> {
        self.launch_template_name.as_deref()
    }
    /// <p>Identifies the version of the launch template. You can specify a version identifier, or use the values <code>$Latest</code> or <code>$Default</code>.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
}
impl std::fmt::Debug
    for AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification");
        formatter.field("launch_template_id", &self.launch_template_id);
        formatter.field("launch_template_name", &self.launch_template_name);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification`](crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification)
pub mod aws_auto_scaling_auto_scaling_group_mixed_instances_policy_launch_template_launch_template_specification {

    /// A builder for [`AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification`](crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) launch_template_id: std::option::Option<std::string::String>,
        pub(crate) launch_template_name: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the launch template. You must specify either <code>LaunchTemplateId</code> or <code>LaunchTemplateName</code>.</p>
        pub fn launch_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_template_id = Some(input.into());
            self
        }
        /// <p>The identifier of the launch template. You must specify either <code>LaunchTemplateId</code> or <code>LaunchTemplateName</code>.</p>
        pub fn set_launch_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_template_id = input;
            self
        }
        /// <p>The name of the launch template. You must specify either <code>LaunchTemplateId</code> or <code>LaunchTemplateName</code>.</p>
        pub fn launch_template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_template_name = Some(input.into());
            self
        }
        /// <p>The name of the launch template. You must specify either <code>LaunchTemplateId</code> or <code>LaunchTemplateName</code>.</p>
        pub fn set_launch_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_template_name = input;
            self
        }
        /// <p>Identifies the version of the launch template. You can specify a version identifier, or use the values <code>$Latest</code> or <code>$Default</code>.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>Identifies the version of the launch template. You can specify a version identifier, or use the values <code>$Latest</code> or <code>$Default</code>.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification`](crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification)
        pub fn build(self) -> crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification{
            crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification {
                launch_template_id: self.launch_template_id
                ,
                launch_template_name: self.launch_template_name
                ,
                version: self.version
                ,
            }
        }
    }
}
impl AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification {
    /// Creates a new builder-style object to manufacture [`AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification`](crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification)
    pub fn builder() -> crate::model::aws_auto_scaling_auto_scaling_group_mixed_instances_policy_launch_template_launch_template_specification::Builder{
        crate::model::aws_auto_scaling_auto_scaling_group_mixed_instances_policy_launch_template_launch_template_specification::Builder::default()
    }
}

/// <p>Information about the instances distribution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails {
    /// <p>How to allocate instance types to fulfill On-Demand capacity.</p>
    pub on_demand_allocation_strategy: std::option::Option<std::string::String>,
    /// <p>The minimum amount of the Auto Scaling group's capacity that must be fulfilled by On-Demand Instances.</p>
    pub on_demand_base_capacity: i32,
    /// <p>The percentage of On-Demand Instances and Spot Instances for additional capacity beyond <code>OnDemandBaseCapacity</code>.</p>
    pub on_demand_percentage_above_base_capacity: i32,
    /// <p>How to allocate instances across Spot Instance pools.</p>
    pub spot_allocation_strategy: std::option::Option<std::string::String>,
    /// <p>The number of Spot Instance pools across which to allocate your Spot Instances.</p>
    pub spot_instance_pools: i32,
    /// <p>The maximum price per unit hour that you are willing to pay for a Spot Instance.</p>
    pub spot_max_price: std::option::Option<std::string::String>,
}
impl AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails {
    /// <p>How to allocate instance types to fulfill On-Demand capacity.</p>
    pub fn on_demand_allocation_strategy(&self) -> std::option::Option<&str> {
        self.on_demand_allocation_strategy.as_deref()
    }
    /// <p>The minimum amount of the Auto Scaling group's capacity that must be fulfilled by On-Demand Instances.</p>
    pub fn on_demand_base_capacity(&self) -> i32 {
        self.on_demand_base_capacity
    }
    /// <p>The percentage of On-Demand Instances and Spot Instances for additional capacity beyond <code>OnDemandBaseCapacity</code>.</p>
    pub fn on_demand_percentage_above_base_capacity(&self) -> i32 {
        self.on_demand_percentage_above_base_capacity
    }
    /// <p>How to allocate instances across Spot Instance pools.</p>
    pub fn spot_allocation_strategy(&self) -> std::option::Option<&str> {
        self.spot_allocation_strategy.as_deref()
    }
    /// <p>The number of Spot Instance pools across which to allocate your Spot Instances.</p>
    pub fn spot_instance_pools(&self) -> i32 {
        self.spot_instance_pools
    }
    /// <p>The maximum price per unit hour that you are willing to pay for a Spot Instance.</p>
    pub fn spot_max_price(&self) -> std::option::Option<&str> {
        self.spot_max_price.as_deref()
    }
}
impl std::fmt::Debug
    for AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct(
            "AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails",
        );
        formatter.field(
            "on_demand_allocation_strategy",
            &self.on_demand_allocation_strategy,
        );
        formatter.field("on_demand_base_capacity", &self.on_demand_base_capacity);
        formatter.field(
            "on_demand_percentage_above_base_capacity",
            &self.on_demand_percentage_above_base_capacity,
        );
        formatter.field("spot_allocation_strategy", &self.spot_allocation_strategy);
        formatter.field("spot_instance_pools", &self.spot_instance_pools);
        formatter.field("spot_max_price", &self.spot_max_price);
        formatter.finish()
    }
}
/// See [`AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails`](crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails)
pub mod aws_auto_scaling_auto_scaling_group_mixed_instances_policy_instances_distribution_details {

    /// A builder for [`AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails`](crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) on_demand_allocation_strategy: std::option::Option<std::string::String>,
        pub(crate) on_demand_base_capacity: std::option::Option<i32>,
        pub(crate) on_demand_percentage_above_base_capacity: std::option::Option<i32>,
        pub(crate) spot_allocation_strategy: std::option::Option<std::string::String>,
        pub(crate) spot_instance_pools: std::option::Option<i32>,
        pub(crate) spot_max_price: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>How to allocate instance types to fulfill On-Demand capacity.</p>
        pub fn on_demand_allocation_strategy(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.on_demand_allocation_strategy = Some(input.into());
            self
        }
        /// <p>How to allocate instance types to fulfill On-Demand capacity.</p>
        pub fn set_on_demand_allocation_strategy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.on_demand_allocation_strategy = input;
            self
        }
        /// <p>The minimum amount of the Auto Scaling group's capacity that must be fulfilled by On-Demand Instances.</p>
        pub fn on_demand_base_capacity(mut self, input: i32) -> Self {
            self.on_demand_base_capacity = Some(input);
            self
        }
        /// <p>The minimum amount of the Auto Scaling group's capacity that must be fulfilled by On-Demand Instances.</p>
        pub fn set_on_demand_base_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.on_demand_base_capacity = input;
            self
        }
        /// <p>The percentage of On-Demand Instances and Spot Instances for additional capacity beyond <code>OnDemandBaseCapacity</code>.</p>
        pub fn on_demand_percentage_above_base_capacity(mut self, input: i32) -> Self {
            self.on_demand_percentage_above_base_capacity = Some(input);
            self
        }
        /// <p>The percentage of On-Demand Instances and Spot Instances for additional capacity beyond <code>OnDemandBaseCapacity</code>.</p>
        pub fn set_on_demand_percentage_above_base_capacity(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.on_demand_percentage_above_base_capacity = input;
            self
        }
        /// <p>How to allocate instances across Spot Instance pools.</p>
        pub fn spot_allocation_strategy(mut self, input: impl Into<std::string::String>) -> Self {
            self.spot_allocation_strategy = Some(input.into());
            self
        }
        /// <p>How to allocate instances across Spot Instance pools.</p>
        pub fn set_spot_allocation_strategy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.spot_allocation_strategy = input;
            self
        }
        /// <p>The number of Spot Instance pools across which to allocate your Spot Instances.</p>
        pub fn spot_instance_pools(mut self, input: i32) -> Self {
            self.spot_instance_pools = Some(input);
            self
        }
        /// <p>The number of Spot Instance pools across which to allocate your Spot Instances.</p>
        pub fn set_spot_instance_pools(mut self, input: std::option::Option<i32>) -> Self {
            self.spot_instance_pools = input;
            self
        }
        /// <p>The maximum price per unit hour that you are willing to pay for a Spot Instance.</p>
        pub fn spot_max_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.spot_max_price = Some(input.into());
            self
        }
        /// <p>The maximum price per unit hour that you are willing to pay for a Spot Instance.</p>
        pub fn set_spot_max_price(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.spot_max_price = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails`](crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails)
        pub fn build(self) -> crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails{
            crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails {
                on_demand_allocation_strategy: self.on_demand_allocation_strategy
                ,
                on_demand_base_capacity: self.on_demand_base_capacity
                    .unwrap_or_default()
                ,
                on_demand_percentage_above_base_capacity: self.on_demand_percentage_above_base_capacity
                    .unwrap_or_default()
                ,
                spot_allocation_strategy: self.spot_allocation_strategy
                ,
                spot_instance_pools: self.spot_instance_pools
                    .unwrap_or_default()
                ,
                spot_max_price: self.spot_max_price
                ,
            }
        }
    }
}
impl AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails {
    /// Creates a new builder-style object to manufacture [`AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails`](crate::model::AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails)
    pub fn builder() -> crate::model::aws_auto_scaling_auto_scaling_group_mixed_instances_policy_instances_distribution_details::Builder{
        crate::model::aws_auto_scaling_auto_scaling_group_mixed_instances_policy_instances_distribution_details::Builder::default()
    }
}

/// <p>Provides details about sensitive data that was detected on a resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataClassificationDetails {
    /// <p>The path to the folder or file that contains the sensitive data.</p>
    pub detailed_results_location: std::option::Option<std::string::String>,
    /// <p>The details about the sensitive data that was detected on the resource.</p>
    pub result: std::option::Option<crate::model::ClassificationResult>,
}
impl DataClassificationDetails {
    /// <p>The path to the folder or file that contains the sensitive data.</p>
    pub fn detailed_results_location(&self) -> std::option::Option<&str> {
        self.detailed_results_location.as_deref()
    }
    /// <p>The details about the sensitive data that was detected on the resource.</p>
    pub fn result(&self) -> std::option::Option<&crate::model::ClassificationResult> {
        self.result.as_ref()
    }
}
impl std::fmt::Debug for DataClassificationDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataClassificationDetails");
        formatter.field("detailed_results_location", &self.detailed_results_location);
        formatter.field("result", &self.result);
        formatter.finish()
    }
}
/// See [`DataClassificationDetails`](crate::model::DataClassificationDetails)
pub mod data_classification_details {

    /// A builder for [`DataClassificationDetails`](crate::model::DataClassificationDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) detailed_results_location: std::option::Option<std::string::String>,
        pub(crate) result: std::option::Option<crate::model::ClassificationResult>,
    }
    impl Builder {
        /// <p>The path to the folder or file that contains the sensitive data.</p>
        pub fn detailed_results_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.detailed_results_location = Some(input.into());
            self
        }
        /// <p>The path to the folder or file that contains the sensitive data.</p>
        pub fn set_detailed_results_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.detailed_results_location = input;
            self
        }
        /// <p>The details about the sensitive data that was detected on the resource.</p>
        pub fn result(mut self, input: crate::model::ClassificationResult) -> Self {
            self.result = Some(input);
            self
        }
        /// <p>The details about the sensitive data that was detected on the resource.</p>
        pub fn set_result(
            mut self,
            input: std::option::Option<crate::model::ClassificationResult>,
        ) -> Self {
            self.result = input;
            self
        }
        /// Consumes the builder and constructs a [`DataClassificationDetails`](crate::model::DataClassificationDetails)
        pub fn build(self) -> crate::model::DataClassificationDetails {
            crate::model::DataClassificationDetails {
                detailed_results_location: self.detailed_results_location,
                result: self.result,
            }
        }
    }
}
impl DataClassificationDetails {
    /// Creates a new builder-style object to manufacture [`DataClassificationDetails`](crate::model::DataClassificationDetails)
    pub fn builder() -> crate::model::data_classification_details::Builder {
        crate::model::data_classification_details::Builder::default()
    }
}

/// <p>Details about the sensitive data that was detected on the resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClassificationResult {
    /// <p>The type of content that the finding applies to.</p>
    pub mime_type: std::option::Option<std::string::String>,
    /// <p>The total size in bytes of the affected data.</p>
    pub size_classified: i64,
    /// <p>Indicates whether there are additional occurrences of sensitive data that are not included in the finding. This occurs when the number of occurrences exceeds the maximum that can be included.</p>
    pub additional_occurrences: bool,
    /// <p>The current status of the sensitive data detection.</p>
    pub status: std::option::Option<crate::model::ClassificationStatus>,
    /// <p>Provides details about sensitive data that was identified based on built-in configuration.</p>
    pub sensitive_data: std::option::Option<std::vec::Vec<crate::model::SensitiveDataResult>>,
    /// <p>Provides details about sensitive data that was identified based on customer-defined configuration.</p>
    pub custom_data_identifiers: std::option::Option<crate::model::CustomDataIdentifiersResult>,
}
impl ClassificationResult {
    /// <p>The type of content that the finding applies to.</p>
    pub fn mime_type(&self) -> std::option::Option<&str> {
        self.mime_type.as_deref()
    }
    /// <p>The total size in bytes of the affected data.</p>
    pub fn size_classified(&self) -> i64 {
        self.size_classified
    }
    /// <p>Indicates whether there are additional occurrences of sensitive data that are not included in the finding. This occurs when the number of occurrences exceeds the maximum that can be included.</p>
    pub fn additional_occurrences(&self) -> bool {
        self.additional_occurrences
    }
    /// <p>The current status of the sensitive data detection.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ClassificationStatus> {
        self.status.as_ref()
    }
    /// <p>Provides details about sensitive data that was identified based on built-in configuration.</p>
    pub fn sensitive_data(&self) -> std::option::Option<&[crate::model::SensitiveDataResult]> {
        self.sensitive_data.as_deref()
    }
    /// <p>Provides details about sensitive data that was identified based on customer-defined configuration.</p>
    pub fn custom_data_identifiers(
        &self,
    ) -> std::option::Option<&crate::model::CustomDataIdentifiersResult> {
        self.custom_data_identifiers.as_ref()
    }
}
impl std::fmt::Debug for ClassificationResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClassificationResult");
        formatter.field("mime_type", &self.mime_type);
        formatter.field("size_classified", &self.size_classified);
        formatter.field("additional_occurrences", &self.additional_occurrences);
        formatter.field("status", &self.status);
        formatter.field("sensitive_data", &self.sensitive_data);
        formatter.field("custom_data_identifiers", &self.custom_data_identifiers);
        formatter.finish()
    }
}
/// See [`ClassificationResult`](crate::model::ClassificationResult)
pub mod classification_result {

    /// A builder for [`ClassificationResult`](crate::model::ClassificationResult)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mime_type: std::option::Option<std::string::String>,
        pub(crate) size_classified: std::option::Option<i64>,
        pub(crate) additional_occurrences: std::option::Option<bool>,
        pub(crate) status: std::option::Option<crate::model::ClassificationStatus>,
        pub(crate) sensitive_data:
            std::option::Option<std::vec::Vec<crate::model::SensitiveDataResult>>,
        pub(crate) custom_data_identifiers:
            std::option::Option<crate::model::CustomDataIdentifiersResult>,
    }
    impl Builder {
        /// <p>The type of content that the finding applies to.</p>
        pub fn mime_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.mime_type = Some(input.into());
            self
        }
        /// <p>The type of content that the finding applies to.</p>
        pub fn set_mime_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mime_type = input;
            self
        }
        /// <p>The total size in bytes of the affected data.</p>
        pub fn size_classified(mut self, input: i64) -> Self {
            self.size_classified = Some(input);
            self
        }
        /// <p>The total size in bytes of the affected data.</p>
        pub fn set_size_classified(mut self, input: std::option::Option<i64>) -> Self {
            self.size_classified = input;
            self
        }
        /// <p>Indicates whether there are additional occurrences of sensitive data that are not included in the finding. This occurs when the number of occurrences exceeds the maximum that can be included.</p>
        pub fn additional_occurrences(mut self, input: bool) -> Self {
            self.additional_occurrences = Some(input);
            self
        }
        /// <p>Indicates whether there are additional occurrences of sensitive data that are not included in the finding. This occurs when the number of occurrences exceeds the maximum that can be included.</p>
        pub fn set_additional_occurrences(mut self, input: std::option::Option<bool>) -> Self {
            self.additional_occurrences = input;
            self
        }
        /// <p>The current status of the sensitive data detection.</p>
        pub fn status(mut self, input: crate::model::ClassificationStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the sensitive data detection.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ClassificationStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Appends an item to `sensitive_data`.
        ///
        /// To override the contents of this collection use [`set_sensitive_data`](Self::set_sensitive_data).
        ///
        /// <p>Provides details about sensitive data that was identified based on built-in configuration.</p>
        pub fn sensitive_data(mut self, input: crate::model::SensitiveDataResult) -> Self {
            let mut v = self.sensitive_data.unwrap_or_default();
            v.push(input);
            self.sensitive_data = Some(v);
            self
        }
        /// <p>Provides details about sensitive data that was identified based on built-in configuration.</p>
        pub fn set_sensitive_data(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SensitiveDataResult>>,
        ) -> Self {
            self.sensitive_data = input;
            self
        }
        /// <p>Provides details about sensitive data that was identified based on customer-defined configuration.</p>
        pub fn custom_data_identifiers(
            mut self,
            input: crate::model::CustomDataIdentifiersResult,
        ) -> Self {
            self.custom_data_identifiers = Some(input);
            self
        }
        /// <p>Provides details about sensitive data that was identified based on customer-defined configuration.</p>
        pub fn set_custom_data_identifiers(
            mut self,
            input: std::option::Option<crate::model::CustomDataIdentifiersResult>,
        ) -> Self {
            self.custom_data_identifiers = input;
            self
        }
        /// Consumes the builder and constructs a [`ClassificationResult`](crate::model::ClassificationResult)
        pub fn build(self) -> crate::model::ClassificationResult {
            crate::model::ClassificationResult {
                mime_type: self.mime_type,
                size_classified: self.size_classified.unwrap_or_default(),
                additional_occurrences: self.additional_occurrences.unwrap_or_default(),
                status: self.status,
                sensitive_data: self.sensitive_data,
                custom_data_identifiers: self.custom_data_identifiers,
            }
        }
    }
}
impl ClassificationResult {
    /// Creates a new builder-style object to manufacture [`ClassificationResult`](crate::model::ClassificationResult)
    pub fn builder() -> crate::model::classification_result::Builder {
        crate::model::classification_result::Builder::default()
    }
}

/// <p>Contains an instance of sensitive data that was detected by a customer-defined identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomDataIdentifiersResult {
    /// <p>The list of detected instances of sensitive data.</p>
    pub detections:
        std::option::Option<std::vec::Vec<crate::model::CustomDataIdentifiersDetections>>,
    /// <p>The total number of occurrences of sensitive data.</p>
    pub total_count: i64,
}
impl CustomDataIdentifiersResult {
    /// <p>The list of detected instances of sensitive data.</p>
    pub fn detections(
        &self,
    ) -> std::option::Option<&[crate::model::CustomDataIdentifiersDetections]> {
        self.detections.as_deref()
    }
    /// <p>The total number of occurrences of sensitive data.</p>
    pub fn total_count(&self) -> i64 {
        self.total_count
    }
}
impl std::fmt::Debug for CustomDataIdentifiersResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomDataIdentifiersResult");
        formatter.field("detections", &self.detections);
        formatter.field("total_count", &self.total_count);
        formatter.finish()
    }
}
/// See [`CustomDataIdentifiersResult`](crate::model::CustomDataIdentifiersResult)
pub mod custom_data_identifiers_result {

    /// A builder for [`CustomDataIdentifiersResult`](crate::model::CustomDataIdentifiersResult)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) detections:
            std::option::Option<std::vec::Vec<crate::model::CustomDataIdentifiersDetections>>,
        pub(crate) total_count: std::option::Option<i64>,
    }
    impl Builder {
        /// Appends an item to `detections`.
        ///
        /// To override the contents of this collection use [`set_detections`](Self::set_detections).
        ///
        /// <p>The list of detected instances of sensitive data.</p>
        pub fn detections(mut self, input: crate::model::CustomDataIdentifiersDetections) -> Self {
            let mut v = self.detections.unwrap_or_default();
            v.push(input);
            self.detections = Some(v);
            self
        }
        /// <p>The list of detected instances of sensitive data.</p>
        pub fn set_detections(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::CustomDataIdentifiersDetections>,
            >,
        ) -> Self {
            self.detections = input;
            self
        }
        /// <p>The total number of occurrences of sensitive data.</p>
        pub fn total_count(mut self, input: i64) -> Self {
            self.total_count = Some(input);
            self
        }
        /// <p>The total number of occurrences of sensitive data.</p>
        pub fn set_total_count(mut self, input: std::option::Option<i64>) -> Self {
            self.total_count = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomDataIdentifiersResult`](crate::model::CustomDataIdentifiersResult)
        pub fn build(self) -> crate::model::CustomDataIdentifiersResult {
            crate::model::CustomDataIdentifiersResult {
                detections: self.detections,
                total_count: self.total_count.unwrap_or_default(),
            }
        }
    }
}
impl CustomDataIdentifiersResult {
    /// Creates a new builder-style object to manufacture [`CustomDataIdentifiersResult`](crate::model::CustomDataIdentifiersResult)
    pub fn builder() -> crate::model::custom_data_identifiers_result::Builder {
        crate::model::custom_data_identifiers_result::Builder::default()
    }
}

/// <p>The list of detected instances of sensitive data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomDataIdentifiersDetections {
    /// <p>The total number of occurrences of sensitive data that were detected.</p>
    pub count: i64,
    /// <p>The ARN of the custom identifier that was used to detect the sensitive data.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>he name of the custom identifier that detected the sensitive data.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Details about the sensitive data that was detected.</p>
    pub occurrences: std::option::Option<crate::model::Occurrences>,
}
impl CustomDataIdentifiersDetections {
    /// <p>The total number of occurrences of sensitive data that were detected.</p>
    pub fn count(&self) -> i64 {
        self.count
    }
    /// <p>The ARN of the custom identifier that was used to detect the sensitive data.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>he name of the custom identifier that detected the sensitive data.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Details about the sensitive data that was detected.</p>
    pub fn occurrences(&self) -> std::option::Option<&crate::model::Occurrences> {
        self.occurrences.as_ref()
    }
}
impl std::fmt::Debug for CustomDataIdentifiersDetections {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomDataIdentifiersDetections");
        formatter.field("count", &self.count);
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("occurrences", &self.occurrences);
        formatter.finish()
    }
}
/// See [`CustomDataIdentifiersDetections`](crate::model::CustomDataIdentifiersDetections)
pub mod custom_data_identifiers_detections {

    /// A builder for [`CustomDataIdentifiersDetections`](crate::model::CustomDataIdentifiersDetections)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) count: std::option::Option<i64>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) occurrences: std::option::Option<crate::model::Occurrences>,
    }
    impl Builder {
        /// <p>The total number of occurrences of sensitive data that were detected.</p>
        pub fn count(mut self, input: i64) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>The total number of occurrences of sensitive data that were detected.</p>
        pub fn set_count(mut self, input: std::option::Option<i64>) -> Self {
            self.count = input;
            self
        }
        /// <p>The ARN of the custom identifier that was used to detect the sensitive data.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the custom identifier that was used to detect the sensitive data.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>he name of the custom identifier that detected the sensitive data.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>he name of the custom identifier that detected the sensitive data.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Details about the sensitive data that was detected.</p>
        pub fn occurrences(mut self, input: crate::model::Occurrences) -> Self {
            self.occurrences = Some(input);
            self
        }
        /// <p>Details about the sensitive data that was detected.</p>
        pub fn set_occurrences(
            mut self,
            input: std::option::Option<crate::model::Occurrences>,
        ) -> Self {
            self.occurrences = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomDataIdentifiersDetections`](crate::model::CustomDataIdentifiersDetections)
        pub fn build(self) -> crate::model::CustomDataIdentifiersDetections {
            crate::model::CustomDataIdentifiersDetections {
                count: self.count.unwrap_or_default(),
                arn: self.arn,
                name: self.name,
                occurrences: self.occurrences,
            }
        }
    }
}
impl CustomDataIdentifiersDetections {
    /// Creates a new builder-style object to manufacture [`CustomDataIdentifiersDetections`](crate::model::CustomDataIdentifiersDetections)
    pub fn builder() -> crate::model::custom_data_identifiers_detections::Builder {
        crate::model::custom_data_identifiers_detections::Builder::default()
    }
}

/// <p>The detected occurrences of sensitive data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Occurrences {
    /// <p>Occurrences of sensitive data detected in a non-binary text file or a Microsoft Word file. Non-binary text files include files such as HTML, XML, JSON, and TXT files.</p>
    pub line_ranges: std::option::Option<std::vec::Vec<crate::model::Range>>,
    /// <p>Occurrences of sensitive data detected in a binary text file.</p>
    pub offset_ranges: std::option::Option<std::vec::Vec<crate::model::Range>>,
    /// <p>Occurrences of sensitive data in an Adobe Portable Document Format (PDF) file.</p>
    pub pages: std::option::Option<std::vec::Vec<crate::model::Page>>,
    /// <p>Occurrences of sensitive data in an Apache Avro object container or an Apache Parquet file.</p>
    pub records: std::option::Option<std::vec::Vec<crate::model::Record>>,
    /// <p>Occurrences of sensitive data detected in Microsoft Excel workbooks, comma-separated value (CSV) files, or tab-separated value (TSV) files.</p>
    pub cells: std::option::Option<std::vec::Vec<crate::model::Cell>>,
}
impl Occurrences {
    /// <p>Occurrences of sensitive data detected in a non-binary text file or a Microsoft Word file. Non-binary text files include files such as HTML, XML, JSON, and TXT files.</p>
    pub fn line_ranges(&self) -> std::option::Option<&[crate::model::Range]> {
        self.line_ranges.as_deref()
    }
    /// <p>Occurrences of sensitive data detected in a binary text file.</p>
    pub fn offset_ranges(&self) -> std::option::Option<&[crate::model::Range]> {
        self.offset_ranges.as_deref()
    }
    /// <p>Occurrences of sensitive data in an Adobe Portable Document Format (PDF) file.</p>
    pub fn pages(&self) -> std::option::Option<&[crate::model::Page]> {
        self.pages.as_deref()
    }
    /// <p>Occurrences of sensitive data in an Apache Avro object container or an Apache Parquet file.</p>
    pub fn records(&self) -> std::option::Option<&[crate::model::Record]> {
        self.records.as_deref()
    }
    /// <p>Occurrences of sensitive data detected in Microsoft Excel workbooks, comma-separated value (CSV) files, or tab-separated value (TSV) files.</p>
    pub fn cells(&self) -> std::option::Option<&[crate::model::Cell]> {
        self.cells.as_deref()
    }
}
impl std::fmt::Debug for Occurrences {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Occurrences");
        formatter.field("line_ranges", &self.line_ranges);
        formatter.field("offset_ranges", &self.offset_ranges);
        formatter.field("pages", &self.pages);
        formatter.field("records", &self.records);
        formatter.field("cells", &self.cells);
        formatter.finish()
    }
}
/// See [`Occurrences`](crate::model::Occurrences)
pub mod occurrences {

    /// A builder for [`Occurrences`](crate::model::Occurrences)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) line_ranges: std::option::Option<std::vec::Vec<crate::model::Range>>,
        pub(crate) offset_ranges: std::option::Option<std::vec::Vec<crate::model::Range>>,
        pub(crate) pages: std::option::Option<std::vec::Vec<crate::model::Page>>,
        pub(crate) records: std::option::Option<std::vec::Vec<crate::model::Record>>,
        pub(crate) cells: std::option::Option<std::vec::Vec<crate::model::Cell>>,
    }
    impl Builder {
        /// Appends an item to `line_ranges`.
        ///
        /// To override the contents of this collection use [`set_line_ranges`](Self::set_line_ranges).
        ///
        /// <p>Occurrences of sensitive data detected in a non-binary text file or a Microsoft Word file. Non-binary text files include files such as HTML, XML, JSON, and TXT files.</p>
        pub fn line_ranges(mut self, input: crate::model::Range) -> Self {
            let mut v = self.line_ranges.unwrap_or_default();
            v.push(input);
            self.line_ranges = Some(v);
            self
        }
        /// <p>Occurrences of sensitive data detected in a non-binary text file or a Microsoft Word file. Non-binary text files include files such as HTML, XML, JSON, and TXT files.</p>
        pub fn set_line_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Range>>,
        ) -> Self {
            self.line_ranges = input;
            self
        }
        /// Appends an item to `offset_ranges`.
        ///
        /// To override the contents of this collection use [`set_offset_ranges`](Self::set_offset_ranges).
        ///
        /// <p>Occurrences of sensitive data detected in a binary text file.</p>
        pub fn offset_ranges(mut self, input: crate::model::Range) -> Self {
            let mut v = self.offset_ranges.unwrap_or_default();
            v.push(input);
            self.offset_ranges = Some(v);
            self
        }
        /// <p>Occurrences of sensitive data detected in a binary text file.</p>
        pub fn set_offset_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Range>>,
        ) -> Self {
            self.offset_ranges = input;
            self
        }
        /// Appends an item to `pages`.
        ///
        /// To override the contents of this collection use [`set_pages`](Self::set_pages).
        ///
        /// <p>Occurrences of sensitive data in an Adobe Portable Document Format (PDF) file.</p>
        pub fn pages(mut self, input: crate::model::Page) -> Self {
            let mut v = self.pages.unwrap_or_default();
            v.push(input);
            self.pages = Some(v);
            self
        }
        /// <p>Occurrences of sensitive data in an Adobe Portable Document Format (PDF) file.</p>
        pub fn set_pages(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Page>>,
        ) -> Self {
            self.pages = input;
            self
        }
        /// Appends an item to `records`.
        ///
        /// To override the contents of this collection use [`set_records`](Self::set_records).
        ///
        /// <p>Occurrences of sensitive data in an Apache Avro object container or an Apache Parquet file.</p>
        pub fn records(mut self, input: crate::model::Record) -> Self {
            let mut v = self.records.unwrap_or_default();
            v.push(input);
            self.records = Some(v);
            self
        }
        /// <p>Occurrences of sensitive data in an Apache Avro object container or an Apache Parquet file.</p>
        pub fn set_records(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Record>>,
        ) -> Self {
            self.records = input;
            self
        }
        /// Appends an item to `cells`.
        ///
        /// To override the contents of this collection use [`set_cells`](Self::set_cells).
        ///
        /// <p>Occurrences of sensitive data detected in Microsoft Excel workbooks, comma-separated value (CSV) files, or tab-separated value (TSV) files.</p>
        pub fn cells(mut self, input: crate::model::Cell) -> Self {
            let mut v = self.cells.unwrap_or_default();
            v.push(input);
            self.cells = Some(v);
            self
        }
        /// <p>Occurrences of sensitive data detected in Microsoft Excel workbooks, comma-separated value (CSV) files, or tab-separated value (TSV) files.</p>
        pub fn set_cells(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Cell>>,
        ) -> Self {
            self.cells = input;
            self
        }
        /// Consumes the builder and constructs a [`Occurrences`](crate::model::Occurrences)
        pub fn build(self) -> crate::model::Occurrences {
            crate::model::Occurrences {
                line_ranges: self.line_ranges,
                offset_ranges: self.offset_ranges,
                pages: self.pages,
                records: self.records,
                cells: self.cells,
            }
        }
    }
}
impl Occurrences {
    /// Creates a new builder-style object to manufacture [`Occurrences`](crate::model::Occurrences)
    pub fn builder() -> crate::model::occurrences::Builder {
        crate::model::occurrences::Builder::default()
    }
}

/// <p>An occurrence of sensitive data detected in a Microsoft Excel workbook, comma-separated value (CSV) file, or tab-separated value (TSV) file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Cell {
    /// <p>The column number of the column that contains the data. For a Microsoft Excel workbook, the column number corresponds to the alphabetical column identifiers. For example, a value of 1 for Column corresponds to the A column in the workbook.</p>
    pub column: i64,
    /// <p>The row number of the row that contains the data.</p>
    pub row: i64,
    /// <p>The name of the column that contains the data.</p>
    pub column_name: std::option::Option<std::string::String>,
    /// <p>For a Microsoft Excel workbook, provides the location of the cell, as an absolute cell reference, that contains the data. For example, Sheet2!C5 for cell C5 on Sheet2.</p>
    pub cell_reference: std::option::Option<std::string::String>,
}
impl Cell {
    /// <p>The column number of the column that contains the data. For a Microsoft Excel workbook, the column number corresponds to the alphabetical column identifiers. For example, a value of 1 for Column corresponds to the A column in the workbook.</p>
    pub fn column(&self) -> i64 {
        self.column
    }
    /// <p>The row number of the row that contains the data.</p>
    pub fn row(&self) -> i64 {
        self.row
    }
    /// <p>The name of the column that contains the data.</p>
    pub fn column_name(&self) -> std::option::Option<&str> {
        self.column_name.as_deref()
    }
    /// <p>For a Microsoft Excel workbook, provides the location of the cell, as an absolute cell reference, that contains the data. For example, Sheet2!C5 for cell C5 on Sheet2.</p>
    pub fn cell_reference(&self) -> std::option::Option<&str> {
        self.cell_reference.as_deref()
    }
}
impl std::fmt::Debug for Cell {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Cell");
        formatter.field("column", &self.column);
        formatter.field("row", &self.row);
        formatter.field("column_name", &self.column_name);
        formatter.field("cell_reference", &self.cell_reference);
        formatter.finish()
    }
}
/// See [`Cell`](crate::model::Cell)
pub mod cell {

    /// A builder for [`Cell`](crate::model::Cell)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column: std::option::Option<i64>,
        pub(crate) row: std::option::Option<i64>,
        pub(crate) column_name: std::option::Option<std::string::String>,
        pub(crate) cell_reference: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The column number of the column that contains the data. For a Microsoft Excel workbook, the column number corresponds to the alphabetical column identifiers. For example, a value of 1 for Column corresponds to the A column in the workbook.</p>
        pub fn column(mut self, input: i64) -> Self {
            self.column = Some(input);
            self
        }
        /// <p>The column number of the column that contains the data. For a Microsoft Excel workbook, the column number corresponds to the alphabetical column identifiers. For example, a value of 1 for Column corresponds to the A column in the workbook.</p>
        pub fn set_column(mut self, input: std::option::Option<i64>) -> Self {
            self.column = input;
            self
        }
        /// <p>The row number of the row that contains the data.</p>
        pub fn row(mut self, input: i64) -> Self {
            self.row = Some(input);
            self
        }
        /// <p>The row number of the row that contains the data.</p>
        pub fn set_row(mut self, input: std::option::Option<i64>) -> Self {
            self.row = input;
            self
        }
        /// <p>The name of the column that contains the data.</p>
        pub fn column_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.column_name = Some(input.into());
            self
        }
        /// <p>The name of the column that contains the data.</p>
        pub fn set_column_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.column_name = input;
            self
        }
        /// <p>For a Microsoft Excel workbook, provides the location of the cell, as an absolute cell reference, that contains the data. For example, Sheet2!C5 for cell C5 on Sheet2.</p>
        pub fn cell_reference(mut self, input: impl Into<std::string::String>) -> Self {
            self.cell_reference = Some(input.into());
            self
        }
        /// <p>For a Microsoft Excel workbook, provides the location of the cell, as an absolute cell reference, that contains the data. For example, Sheet2!C5 for cell C5 on Sheet2.</p>
        pub fn set_cell_reference(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cell_reference = input;
            self
        }
        /// Consumes the builder and constructs a [`Cell`](crate::model::Cell)
        pub fn build(self) -> crate::model::Cell {
            crate::model::Cell {
                column: self.column.unwrap_or_default(),
                row: self.row.unwrap_or_default(),
                column_name: self.column_name,
                cell_reference: self.cell_reference,
            }
        }
    }
}
impl Cell {
    /// Creates a new builder-style object to manufacture [`Cell`](crate::model::Cell)
    pub fn builder() -> crate::model::cell::Builder {
        crate::model::cell::Builder::default()
    }
}

/// <p>An occurrence of sensitive data in an Apache Avro object container or an Apache Parquet file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Record {
    /// <p>The path, as a JSONPath expression, to the field in the record that contains the data. If the field name is longer than 20 characters, it is truncated. If the path is longer than 250 characters, it is truncated.</p>
    pub json_path: std::option::Option<std::string::String>,
    /// <p>The record index, starting from 0, for the record that contains the data.</p>
    pub record_index: i64,
}
impl Record {
    /// <p>The path, as a JSONPath expression, to the field in the record that contains the data. If the field name is longer than 20 characters, it is truncated. If the path is longer than 250 characters, it is truncated.</p>
    pub fn json_path(&self) -> std::option::Option<&str> {
        self.json_path.as_deref()
    }
    /// <p>The record index, starting from 0, for the record that contains the data.</p>
    pub fn record_index(&self) -> i64 {
        self.record_index
    }
}
impl std::fmt::Debug for Record {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Record");
        formatter.field("json_path", &self.json_path);
        formatter.field("record_index", &self.record_index);
        formatter.finish()
    }
}
/// See [`Record`](crate::model::Record)
pub mod record {

    /// A builder for [`Record`](crate::model::Record)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) json_path: std::option::Option<std::string::String>,
        pub(crate) record_index: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The path, as a JSONPath expression, to the field in the record that contains the data. If the field name is longer than 20 characters, it is truncated. If the path is longer than 250 characters, it is truncated.</p>
        pub fn json_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.json_path = Some(input.into());
            self
        }
        /// <p>The path, as a JSONPath expression, to the field in the record that contains the data. If the field name is longer than 20 characters, it is truncated. If the path is longer than 250 characters, it is truncated.</p>
        pub fn set_json_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.json_path = input;
            self
        }
        /// <p>The record index, starting from 0, for the record that contains the data.</p>
        pub fn record_index(mut self, input: i64) -> Self {
            self.record_index = Some(input);
            self
        }
        /// <p>The record index, starting from 0, for the record that contains the data.</p>
        pub fn set_record_index(mut self, input: std::option::Option<i64>) -> Self {
            self.record_index = input;
            self
        }
        /// Consumes the builder and constructs a [`Record`](crate::model::Record)
        pub fn build(self) -> crate::model::Record {
            crate::model::Record {
                json_path: self.json_path,
                record_index: self.record_index.unwrap_or_default(),
            }
        }
    }
}
impl Record {
    /// Creates a new builder-style object to manufacture [`Record`](crate::model::Record)
    pub fn builder() -> crate::model::record::Builder {
        crate::model::record::Builder::default()
    }
}

/// <p>An occurrence of sensitive data in an Adobe Portable Document Format (PDF) file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Page {
    /// <p>The page number of the page that contains the sensitive data.</p>
    pub page_number: i64,
    /// <p>An occurrence of sensitive data detected in a non-binary text file or a Microsoft Word file. Non-binary text files include files such as HTML, XML, JSON, and TXT files.</p>
    pub line_range: std::option::Option<crate::model::Range>,
    /// <p>An occurrence of sensitive data detected in a binary text file.</p>
    pub offset_range: std::option::Option<crate::model::Range>,
}
impl Page {
    /// <p>The page number of the page that contains the sensitive data.</p>
    pub fn page_number(&self) -> i64 {
        self.page_number
    }
    /// <p>An occurrence of sensitive data detected in a non-binary text file or a Microsoft Word file. Non-binary text files include files such as HTML, XML, JSON, and TXT files.</p>
    pub fn line_range(&self) -> std::option::Option<&crate::model::Range> {
        self.line_range.as_ref()
    }
    /// <p>An occurrence of sensitive data detected in a binary text file.</p>
    pub fn offset_range(&self) -> std::option::Option<&crate::model::Range> {
        self.offset_range.as_ref()
    }
}
impl std::fmt::Debug for Page {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Page");
        formatter.field("page_number", &self.page_number);
        formatter.field("line_range", &self.line_range);
        formatter.field("offset_range", &self.offset_range);
        formatter.finish()
    }
}
/// See [`Page`](crate::model::Page)
pub mod page {

    /// A builder for [`Page`](crate::model::Page)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page_number: std::option::Option<i64>,
        pub(crate) line_range: std::option::Option<crate::model::Range>,
        pub(crate) offset_range: std::option::Option<crate::model::Range>,
    }
    impl Builder {
        /// <p>The page number of the page that contains the sensitive data.</p>
        pub fn page_number(mut self, input: i64) -> Self {
            self.page_number = Some(input);
            self
        }
        /// <p>The page number of the page that contains the sensitive data.</p>
        pub fn set_page_number(mut self, input: std::option::Option<i64>) -> Self {
            self.page_number = input;
            self
        }
        /// <p>An occurrence of sensitive data detected in a non-binary text file or a Microsoft Word file. Non-binary text files include files such as HTML, XML, JSON, and TXT files.</p>
        pub fn line_range(mut self, input: crate::model::Range) -> Self {
            self.line_range = Some(input);
            self
        }
        /// <p>An occurrence of sensitive data detected in a non-binary text file or a Microsoft Word file. Non-binary text files include files such as HTML, XML, JSON, and TXT files.</p>
        pub fn set_line_range(mut self, input: std::option::Option<crate::model::Range>) -> Self {
            self.line_range = input;
            self
        }
        /// <p>An occurrence of sensitive data detected in a binary text file.</p>
        pub fn offset_range(mut self, input: crate::model::Range) -> Self {
            self.offset_range = Some(input);
            self
        }
        /// <p>An occurrence of sensitive data detected in a binary text file.</p>
        pub fn set_offset_range(mut self, input: std::option::Option<crate::model::Range>) -> Self {
            self.offset_range = input;
            self
        }
        /// Consumes the builder and constructs a [`Page`](crate::model::Page)
        pub fn build(self) -> crate::model::Page {
            crate::model::Page {
                page_number: self.page_number.unwrap_or_default(),
                line_range: self.line_range,
                offset_range: self.offset_range,
            }
        }
    }
}
impl Page {
    /// Creates a new builder-style object to manufacture [`Page`](crate::model::Page)
    pub fn builder() -> crate::model::page::Builder {
        crate::model::page::Builder::default()
    }
}

/// <p>Identifies where the sensitive data begins and ends.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Range {
    /// <p>The number of lines (for a line range) or characters (for an offset range) from the beginning of the file to the end of the sensitive data.</p>
    pub start: i64,
    /// <p>The number of lines (for a line range) or characters (for an offset range) from the beginning of the file to the end of the sensitive data.</p>
    pub end: i64,
    /// <p>In the line where the sensitive data starts, the column within the line where the sensitive data starts.</p>
    pub start_column: i64,
}
impl Range {
    /// <p>The number of lines (for a line range) or characters (for an offset range) from the beginning of the file to the end of the sensitive data.</p>
    pub fn start(&self) -> i64 {
        self.start
    }
    /// <p>The number of lines (for a line range) or characters (for an offset range) from the beginning of the file to the end of the sensitive data.</p>
    pub fn end(&self) -> i64 {
        self.end
    }
    /// <p>In the line where the sensitive data starts, the column within the line where the sensitive data starts.</p>
    pub fn start_column(&self) -> i64 {
        self.start_column
    }
}
impl std::fmt::Debug for Range {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Range");
        formatter.field("start", &self.start);
        formatter.field("end", &self.end);
        formatter.field("start_column", &self.start_column);
        formatter.finish()
    }
}
/// See [`Range`](crate::model::Range)
pub mod range {

    /// A builder for [`Range`](crate::model::Range)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start: std::option::Option<i64>,
        pub(crate) end: std::option::Option<i64>,
        pub(crate) start_column: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The number of lines (for a line range) or characters (for an offset range) from the beginning of the file to the end of the sensitive data.</p>
        pub fn start(mut self, input: i64) -> Self {
            self.start = Some(input);
            self
        }
        /// <p>The number of lines (for a line range) or characters (for an offset range) from the beginning of the file to the end of the sensitive data.</p>
        pub fn set_start(mut self, input: std::option::Option<i64>) -> Self {
            self.start = input;
            self
        }
        /// <p>The number of lines (for a line range) or characters (for an offset range) from the beginning of the file to the end of the sensitive data.</p>
        pub fn end(mut self, input: i64) -> Self {
            self.end = Some(input);
            self
        }
        /// <p>The number of lines (for a line range) or characters (for an offset range) from the beginning of the file to the end of the sensitive data.</p>
        pub fn set_end(mut self, input: std::option::Option<i64>) -> Self {
            self.end = input;
            self
        }
        /// <p>In the line where the sensitive data starts, the column within the line where the sensitive data starts.</p>
        pub fn start_column(mut self, input: i64) -> Self {
            self.start_column = Some(input);
            self
        }
        /// <p>In the line where the sensitive data starts, the column within the line where the sensitive data starts.</p>
        pub fn set_start_column(mut self, input: std::option::Option<i64>) -> Self {
            self.start_column = input;
            self
        }
        /// Consumes the builder and constructs a [`Range`](crate::model::Range)
        pub fn build(self) -> crate::model::Range {
            crate::model::Range {
                start: self.start.unwrap_or_default(),
                end: self.end.unwrap_or_default(),
                start_column: self.start_column.unwrap_or_default(),
            }
        }
    }
}
impl Range {
    /// Creates a new builder-style object to manufacture [`Range`](crate::model::Range)
    pub fn builder() -> crate::model::range::Builder {
        crate::model::range::Builder::default()
    }
}

/// <p>Contains a detected instance of sensitive data that are based on built-in identifiers.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SensitiveDataResult {
    /// <p>The category of sensitive data that was detected. For example, the category can indicate that the sensitive data involved credentials, financial information, or personal information.</p>
    pub category: std::option::Option<std::string::String>,
    /// <p>The list of detected instances of sensitive data.</p>
    pub detections: std::option::Option<std::vec::Vec<crate::model::SensitiveDataDetections>>,
    /// <p>The total number of occurrences of sensitive data.</p>
    pub total_count: i64,
}
impl SensitiveDataResult {
    /// <p>The category of sensitive data that was detected. For example, the category can indicate that the sensitive data involved credentials, financial information, or personal information.</p>
    pub fn category(&self) -> std::option::Option<&str> {
        self.category.as_deref()
    }
    /// <p>The list of detected instances of sensitive data.</p>
    pub fn detections(&self) -> std::option::Option<&[crate::model::SensitiveDataDetections]> {
        self.detections.as_deref()
    }
    /// <p>The total number of occurrences of sensitive data.</p>
    pub fn total_count(&self) -> i64 {
        self.total_count
    }
}
impl std::fmt::Debug for SensitiveDataResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SensitiveDataResult");
        formatter.field("category", &self.category);
        formatter.field("detections", &self.detections);
        formatter.field("total_count", &self.total_count);
        formatter.finish()
    }
}
/// See [`SensitiveDataResult`](crate::model::SensitiveDataResult)
pub mod sensitive_data_result {

    /// A builder for [`SensitiveDataResult`](crate::model::SensitiveDataResult)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) category: std::option::Option<std::string::String>,
        pub(crate) detections:
            std::option::Option<std::vec::Vec<crate::model::SensitiveDataDetections>>,
        pub(crate) total_count: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The category of sensitive data that was detected. For example, the category can indicate that the sensitive data involved credentials, financial information, or personal information.</p>
        pub fn category(mut self, input: impl Into<std::string::String>) -> Self {
            self.category = Some(input.into());
            self
        }
        /// <p>The category of sensitive data that was detected. For example, the category can indicate that the sensitive data involved credentials, financial information, or personal information.</p>
        pub fn set_category(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.category = input;
            self
        }
        /// Appends an item to `detections`.
        ///
        /// To override the contents of this collection use [`set_detections`](Self::set_detections).
        ///
        /// <p>The list of detected instances of sensitive data.</p>
        pub fn detections(mut self, input: crate::model::SensitiveDataDetections) -> Self {
            let mut v = self.detections.unwrap_or_default();
            v.push(input);
            self.detections = Some(v);
            self
        }
        /// <p>The list of detected instances of sensitive data.</p>
        pub fn set_detections(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SensitiveDataDetections>>,
        ) -> Self {
            self.detections = input;
            self
        }
        /// <p>The total number of occurrences of sensitive data.</p>
        pub fn total_count(mut self, input: i64) -> Self {
            self.total_count = Some(input);
            self
        }
        /// <p>The total number of occurrences of sensitive data.</p>
        pub fn set_total_count(mut self, input: std::option::Option<i64>) -> Self {
            self.total_count = input;
            self
        }
        /// Consumes the builder and constructs a [`SensitiveDataResult`](crate::model::SensitiveDataResult)
        pub fn build(self) -> crate::model::SensitiveDataResult {
            crate::model::SensitiveDataResult {
                category: self.category,
                detections: self.detections,
                total_count: self.total_count.unwrap_or_default(),
            }
        }
    }
}
impl SensitiveDataResult {
    /// Creates a new builder-style object to manufacture [`SensitiveDataResult`](crate::model::SensitiveDataResult)
    pub fn builder() -> crate::model::sensitive_data_result::Builder {
        crate::model::sensitive_data_result::Builder::default()
    }
}

/// <p>The list of detected instances of sensitive data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SensitiveDataDetections {
    /// <p>The total number of occurrences of sensitive data that were detected.</p>
    pub count: i64,
    /// <p>The type of sensitive data that was detected. For example, the type might indicate that the data is an email address.</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>Details about the sensitive data that was detected.</p>
    pub occurrences: std::option::Option<crate::model::Occurrences>,
}
impl SensitiveDataDetections {
    /// <p>The total number of occurrences of sensitive data that were detected.</p>
    pub fn count(&self) -> i64 {
        self.count
    }
    /// <p>The type of sensitive data that was detected. For example, the type might indicate that the data is an email address.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>Details about the sensitive data that was detected.</p>
    pub fn occurrences(&self) -> std::option::Option<&crate::model::Occurrences> {
        self.occurrences.as_ref()
    }
}
impl std::fmt::Debug for SensitiveDataDetections {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SensitiveDataDetections");
        formatter.field("count", &self.count);
        formatter.field("r#type", &self.r#type);
        formatter.field("occurrences", &self.occurrences);
        formatter.finish()
    }
}
/// See [`SensitiveDataDetections`](crate::model::SensitiveDataDetections)
pub mod sensitive_data_detections {

    /// A builder for [`SensitiveDataDetections`](crate::model::SensitiveDataDetections)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) count: std::option::Option<i64>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) occurrences: std::option::Option<crate::model::Occurrences>,
    }
    impl Builder {
        /// <p>The total number of occurrences of sensitive data that were detected.</p>
        pub fn count(mut self, input: i64) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>The total number of occurrences of sensitive data that were detected.</p>
        pub fn set_count(mut self, input: std::option::Option<i64>) -> Self {
            self.count = input;
            self
        }
        /// <p>The type of sensitive data that was detected. For example, the type might indicate that the data is an email address.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of sensitive data that was detected. For example, the type might indicate that the data is an email address.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Details about the sensitive data that was detected.</p>
        pub fn occurrences(mut self, input: crate::model::Occurrences) -> Self {
            self.occurrences = Some(input);
            self
        }
        /// <p>Details about the sensitive data that was detected.</p>
        pub fn set_occurrences(
            mut self,
            input: std::option::Option<crate::model::Occurrences>,
        ) -> Self {
            self.occurrences = input;
            self
        }
        /// Consumes the builder and constructs a [`SensitiveDataDetections`](crate::model::SensitiveDataDetections)
        pub fn build(self) -> crate::model::SensitiveDataDetections {
            crate::model::SensitiveDataDetections {
                count: self.count.unwrap_or_default(),
                r#type: self.r#type,
                occurrences: self.occurrences,
            }
        }
    }
}
impl SensitiveDataDetections {
    /// Creates a new builder-style object to manufacture [`SensitiveDataDetections`](crate::model::SensitiveDataDetections)
    pub fn builder() -> crate::model::sensitive_data_detections::Builder {
        crate::model::sensitive_data_detections::Builder::default()
    }
}

/// <p>Provides details about the current status of the sensitive data detection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClassificationStatus {
    /// <p>The code that represents the status of the sensitive data detection.</p>
    pub code: std::option::Option<std::string::String>,
    /// <p>A longer description of the current status of the sensitive data detection.</p>
    pub reason: std::option::Option<std::string::String>,
}
impl ClassificationStatus {
    /// <p>The code that represents the status of the sensitive data detection.</p>
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
    /// <p>A longer description of the current status of the sensitive data detection.</p>
    pub fn reason(&self) -> std::option::Option<&str> {
        self.reason.as_deref()
    }
}
impl std::fmt::Debug for ClassificationStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClassificationStatus");
        formatter.field("code", &self.code);
        formatter.field("reason", &self.reason);
        formatter.finish()
    }
}
/// See [`ClassificationStatus`](crate::model::ClassificationStatus)
pub mod classification_status {

    /// A builder for [`ClassificationStatus`](crate::model::ClassificationStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The code that represents the status of the sensitive data detection.</p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// <p>The code that represents the status of the sensitive data detection.</p>
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A longer description of the current status of the sensitive data detection.</p>
        pub fn reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.reason = Some(input.into());
            self
        }
        /// <p>A longer description of the current status of the sensitive data detection.</p>
        pub fn set_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reason = input;
            self
        }
        /// Consumes the builder and constructs a [`ClassificationStatus`](crate::model::ClassificationStatus)
        pub fn build(self) -> crate::model::ClassificationStatus {
            crate::model::ClassificationStatus {
                code: self.code,
                reason: self.reason,
            }
        }
    }
}
impl ClassificationStatus {
    /// Creates a new builder-style object to manufacture [`ClassificationStatus`](crate::model::ClassificationStatus)
    pub fn builder() -> crate::model::classification_status::Builder {
        crate::model::classification_status::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Partition {
    #[allow(missing_docs)] // documentation missing in model
    Aws,
    #[allow(missing_docs)] // documentation missing in model
    AwsCn,
    #[allow(missing_docs)] // documentation missing in model
    AwsUsGov,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Partition {
    fn from(s: &str) -> Self {
        match s {
            "aws" => Partition::Aws,
            "aws-cn" => Partition::AwsCn,
            "aws-us-gov" => Partition::AwsUsGov,
            other => Partition::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Partition {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Partition::from(s))
    }
}
impl Partition {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Partition::Aws => "aws",
            Partition::AwsCn => "aws-cn",
            Partition::AwsUsGov => "aws-us-gov",
            Partition::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["aws", "aws-cn", "aws-us-gov"]
    }
}
impl AsRef<str> for Partition {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Details about the threat intelligence related to a finding.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ThreatIntelIndicator {
    /// <p>The type of threat intelligence indicator.</p>
    pub r#type: std::option::Option<crate::model::ThreatIntelIndicatorType>,
    /// <p>The value of a threat intelligence indicator.</p>
    pub value: std::option::Option<std::string::String>,
    /// <p>The category of a threat intelligence indicator.</p>
    pub category: std::option::Option<crate::model::ThreatIntelIndicatorCategory>,
    /// <p>Indicates when the most recent instance of a threat intelligence indicator was observed.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub last_observed_at: std::option::Option<std::string::String>,
    /// <p>The source of the threat intelligence indicator.</p>
    pub source: std::option::Option<std::string::String>,
    /// <p>The URL to the page or site where you can get more information about the threat intelligence indicator.</p>
    pub source_url: std::option::Option<std::string::String>,
}
impl ThreatIntelIndicator {
    /// <p>The type of threat intelligence indicator.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ThreatIntelIndicatorType> {
        self.r#type.as_ref()
    }
    /// <p>The value of a threat intelligence indicator.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>The category of a threat intelligence indicator.</p>
    pub fn category(&self) -> std::option::Option<&crate::model::ThreatIntelIndicatorCategory> {
        self.category.as_ref()
    }
    /// <p>Indicates when the most recent instance of a threat intelligence indicator was observed.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn last_observed_at(&self) -> std::option::Option<&str> {
        self.last_observed_at.as_deref()
    }
    /// <p>The source of the threat intelligence indicator.</p>
    pub fn source(&self) -> std::option::Option<&str> {
        self.source.as_deref()
    }
    /// <p>The URL to the page or site where you can get more information about the threat intelligence indicator.</p>
    pub fn source_url(&self) -> std::option::Option<&str> {
        self.source_url.as_deref()
    }
}
impl std::fmt::Debug for ThreatIntelIndicator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ThreatIntelIndicator");
        formatter.field("r#type", &self.r#type);
        formatter.field("value", &self.value);
        formatter.field("category", &self.category);
        formatter.field("last_observed_at", &self.last_observed_at);
        formatter.field("source", &self.source);
        formatter.field("source_url", &self.source_url);
        formatter.finish()
    }
}
/// See [`ThreatIntelIndicator`](crate::model::ThreatIntelIndicator)
pub mod threat_intel_indicator {

    /// A builder for [`ThreatIntelIndicator`](crate::model::ThreatIntelIndicator)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::ThreatIntelIndicatorType>,
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) category: std::option::Option<crate::model::ThreatIntelIndicatorCategory>,
        pub(crate) last_observed_at: std::option::Option<std::string::String>,
        pub(crate) source: std::option::Option<std::string::String>,
        pub(crate) source_url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of threat intelligence indicator.</p>
        pub fn r#type(mut self, input: crate::model::ThreatIntelIndicatorType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of threat intelligence indicator.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ThreatIntelIndicatorType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The value of a threat intelligence indicator.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of a threat intelligence indicator.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>The category of a threat intelligence indicator.</p>
        pub fn category(mut self, input: crate::model::ThreatIntelIndicatorCategory) -> Self {
            self.category = Some(input);
            self
        }
        /// <p>The category of a threat intelligence indicator.</p>
        pub fn set_category(
            mut self,
            input: std::option::Option<crate::model::ThreatIntelIndicatorCategory>,
        ) -> Self {
            self.category = input;
            self
        }
        /// <p>Indicates when the most recent instance of a threat intelligence indicator was observed.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn last_observed_at(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_observed_at = Some(input.into());
            self
        }
        /// <p>Indicates when the most recent instance of a threat intelligence indicator was observed.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_last_observed_at(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_observed_at = input;
            self
        }
        /// <p>The source of the threat intelligence indicator.</p>
        pub fn source(mut self, input: impl Into<std::string::String>) -> Self {
            self.source = Some(input.into());
            self
        }
        /// <p>The source of the threat intelligence indicator.</p>
        pub fn set_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source = input;
            self
        }
        /// <p>The URL to the page or site where you can get more information about the threat intelligence indicator.</p>
        pub fn source_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_url = Some(input.into());
            self
        }
        /// <p>The URL to the page or site where you can get more information about the threat intelligence indicator.</p>
        pub fn set_source_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_url = input;
            self
        }
        /// Consumes the builder and constructs a [`ThreatIntelIndicator`](crate::model::ThreatIntelIndicator)
        pub fn build(self) -> crate::model::ThreatIntelIndicator {
            crate::model::ThreatIntelIndicator {
                r#type: self.r#type,
                value: self.value,
                category: self.category,
                last_observed_at: self.last_observed_at,
                source: self.source,
                source_url: self.source_url,
            }
        }
    }
}
impl ThreatIntelIndicator {
    /// Creates a new builder-style object to manufacture [`ThreatIntelIndicator`](crate::model::ThreatIntelIndicator)
    pub fn builder() -> crate::model::threat_intel_indicator::Builder {
        crate::model::threat_intel_indicator::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ThreatIntelIndicatorCategory {
    #[allow(missing_docs)] // documentation missing in model
    Backdoor,
    #[allow(missing_docs)] // documentation missing in model
    CardStealer,
    #[allow(missing_docs)] // documentation missing in model
    CommandAndControl,
    #[allow(missing_docs)] // documentation missing in model
    DropSite,
    #[allow(missing_docs)] // documentation missing in model
    ExploitSite,
    #[allow(missing_docs)] // documentation missing in model
    Keylogger,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ThreatIntelIndicatorCategory {
    fn from(s: &str) -> Self {
        match s {
            "BACKDOOR" => ThreatIntelIndicatorCategory::Backdoor,
            "CARD_STEALER" => ThreatIntelIndicatorCategory::CardStealer,
            "COMMAND_AND_CONTROL" => ThreatIntelIndicatorCategory::CommandAndControl,
            "DROP_SITE" => ThreatIntelIndicatorCategory::DropSite,
            "EXPLOIT_SITE" => ThreatIntelIndicatorCategory::ExploitSite,
            "KEYLOGGER" => ThreatIntelIndicatorCategory::Keylogger,
            other => ThreatIntelIndicatorCategory::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ThreatIntelIndicatorCategory {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ThreatIntelIndicatorCategory::from(s))
    }
}
impl ThreatIntelIndicatorCategory {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ThreatIntelIndicatorCategory::Backdoor => "BACKDOOR",
            ThreatIntelIndicatorCategory::CardStealer => "CARD_STEALER",
            ThreatIntelIndicatorCategory::CommandAndControl => "COMMAND_AND_CONTROL",
            ThreatIntelIndicatorCategory::DropSite => "DROP_SITE",
            ThreatIntelIndicatorCategory::ExploitSite => "EXPLOIT_SITE",
            ThreatIntelIndicatorCategory::Keylogger => "KEYLOGGER",
            ThreatIntelIndicatorCategory::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "BACKDOOR",
            "CARD_STEALER",
            "COMMAND_AND_CONTROL",
            "DROP_SITE",
            "EXPLOIT_SITE",
            "KEYLOGGER",
        ]
    }
}
impl AsRef<str> for ThreatIntelIndicatorCategory {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ThreatIntelIndicatorType {
    #[allow(missing_docs)] // documentation missing in model
    Domain,
    #[allow(missing_docs)] // documentation missing in model
    EmailAddress,
    #[allow(missing_docs)] // documentation missing in model
    HashMd5,
    #[allow(missing_docs)] // documentation missing in model
    HashSha1,
    #[allow(missing_docs)] // documentation missing in model
    HashSha256,
    #[allow(missing_docs)] // documentation missing in model
    HashSha512,
    #[allow(missing_docs)] // documentation missing in model
    Ipv4Address,
    #[allow(missing_docs)] // documentation missing in model
    Ipv6Address,
    #[allow(missing_docs)] // documentation missing in model
    Mutex,
    #[allow(missing_docs)] // documentation missing in model
    Process,
    #[allow(missing_docs)] // documentation missing in model
    Url,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ThreatIntelIndicatorType {
    fn from(s: &str) -> Self {
        match s {
            "DOMAIN" => ThreatIntelIndicatorType::Domain,
            "EMAIL_ADDRESS" => ThreatIntelIndicatorType::EmailAddress,
            "HASH_MD5" => ThreatIntelIndicatorType::HashMd5,
            "HASH_SHA1" => ThreatIntelIndicatorType::HashSha1,
            "HASH_SHA256" => ThreatIntelIndicatorType::HashSha256,
            "HASH_SHA512" => ThreatIntelIndicatorType::HashSha512,
            "IPV4_ADDRESS" => ThreatIntelIndicatorType::Ipv4Address,
            "IPV6_ADDRESS" => ThreatIntelIndicatorType::Ipv6Address,
            "MUTEX" => ThreatIntelIndicatorType::Mutex,
            "PROCESS" => ThreatIntelIndicatorType::Process,
            "URL" => ThreatIntelIndicatorType::Url,
            other => ThreatIntelIndicatorType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ThreatIntelIndicatorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ThreatIntelIndicatorType::from(s))
    }
}
impl ThreatIntelIndicatorType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ThreatIntelIndicatorType::Domain => "DOMAIN",
            ThreatIntelIndicatorType::EmailAddress => "EMAIL_ADDRESS",
            ThreatIntelIndicatorType::HashMd5 => "HASH_MD5",
            ThreatIntelIndicatorType::HashSha1 => "HASH_SHA1",
            ThreatIntelIndicatorType::HashSha256 => "HASH_SHA256",
            ThreatIntelIndicatorType::HashSha512 => "HASH_SHA512",
            ThreatIntelIndicatorType::Ipv4Address => "IPV4_ADDRESS",
            ThreatIntelIndicatorType::Ipv6Address => "IPV6_ADDRESS",
            ThreatIntelIndicatorType::Mutex => "MUTEX",
            ThreatIntelIndicatorType::Process => "PROCESS",
            ThreatIntelIndicatorType::Url => "URL",
            ThreatIntelIndicatorType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "DOMAIN",
            "EMAIL_ADDRESS",
            "HASH_MD5",
            "HASH_SHA1",
            "HASH_SHA256",
            "HASH_SHA512",
            "IPV4_ADDRESS",
            "IPV6_ADDRESS",
            "MUTEX",
            "PROCESS",
            "URL",
        ]
    }
}
impl AsRef<str> for ThreatIntelIndicatorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information about the threat detected in a security finding and the file paths that were affected by the threat. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Threat {
    /// <p>The name of the threat. </p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The severity of the threat. </p>
    pub severity: std::option::Option<std::string::String>,
    /// <p>This total number of items in which the threat has been detected. </p>
    pub item_count: i32,
    /// <p>Provides information about the file paths that were affected by the threat. </p>
    pub file_paths: std::option::Option<std::vec::Vec<crate::model::FilePaths>>,
}
impl Threat {
    /// <p>The name of the threat. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The severity of the threat. </p>
    pub fn severity(&self) -> std::option::Option<&str> {
        self.severity.as_deref()
    }
    /// <p>This total number of items in which the threat has been detected. </p>
    pub fn item_count(&self) -> i32 {
        self.item_count
    }
    /// <p>Provides information about the file paths that were affected by the threat. </p>
    pub fn file_paths(&self) -> std::option::Option<&[crate::model::FilePaths]> {
        self.file_paths.as_deref()
    }
}
impl std::fmt::Debug for Threat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Threat");
        formatter.field("name", &self.name);
        formatter.field("severity", &self.severity);
        formatter.field("item_count", &self.item_count);
        formatter.field("file_paths", &self.file_paths);
        formatter.finish()
    }
}
/// See [`Threat`](crate::model::Threat)
pub mod threat {

    /// A builder for [`Threat`](crate::model::Threat)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) severity: std::option::Option<std::string::String>,
        pub(crate) item_count: std::option::Option<i32>,
        pub(crate) file_paths: std::option::Option<std::vec::Vec<crate::model::FilePaths>>,
    }
    impl Builder {
        /// <p>The name of the threat. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the threat. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The severity of the threat. </p>
        pub fn severity(mut self, input: impl Into<std::string::String>) -> Self {
            self.severity = Some(input.into());
            self
        }
        /// <p>The severity of the threat. </p>
        pub fn set_severity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.severity = input;
            self
        }
        /// <p>This total number of items in which the threat has been detected. </p>
        pub fn item_count(mut self, input: i32) -> Self {
            self.item_count = Some(input);
            self
        }
        /// <p>This total number of items in which the threat has been detected. </p>
        pub fn set_item_count(mut self, input: std::option::Option<i32>) -> Self {
            self.item_count = input;
            self
        }
        /// Appends an item to `file_paths`.
        ///
        /// To override the contents of this collection use [`set_file_paths`](Self::set_file_paths).
        ///
        /// <p>Provides information about the file paths that were affected by the threat. </p>
        pub fn file_paths(mut self, input: crate::model::FilePaths) -> Self {
            let mut v = self.file_paths.unwrap_or_default();
            v.push(input);
            self.file_paths = Some(v);
            self
        }
        /// <p>Provides information about the file paths that were affected by the threat. </p>
        pub fn set_file_paths(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FilePaths>>,
        ) -> Self {
            self.file_paths = input;
            self
        }
        /// Consumes the builder and constructs a [`Threat`](crate::model::Threat)
        pub fn build(self) -> crate::model::Threat {
            crate::model::Threat {
                name: self.name,
                severity: self.severity,
                item_count: self.item_count.unwrap_or_default(),
                file_paths: self.file_paths,
            }
        }
    }
}
impl Threat {
    /// Creates a new builder-style object to manufacture [`Threat`](crate::model::Threat)
    pub fn builder() -> crate::model::threat::Builder {
        crate::model::threat::Builder::default()
    }
}

/// <p>Provides information about the file paths that were affected by the threat. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FilePaths {
    /// <p>Path to the infected or suspicious file on the resource it was detected on. </p>
    pub file_path: std::option::Option<std::string::String>,
    /// <p>The name of the infected or suspicious file corresponding to the hash. </p>
    pub file_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the resource on which the threat was detected. </p>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The hash value for the infected or suspicious file. </p>
    pub hash: std::option::Option<std::string::String>,
}
impl FilePaths {
    /// <p>Path to the infected or suspicious file on the resource it was detected on. </p>
    pub fn file_path(&self) -> std::option::Option<&str> {
        self.file_path.as_deref()
    }
    /// <p>The name of the infected or suspicious file corresponding to the hash. </p>
    pub fn file_name(&self) -> std::option::Option<&str> {
        self.file_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the resource on which the threat was detected. </p>
    pub fn resource_id(&self) -> std::option::Option<&str> {
        self.resource_id.as_deref()
    }
    /// <p>The hash value for the infected or suspicious file. </p>
    pub fn hash(&self) -> std::option::Option<&str> {
        self.hash.as_deref()
    }
}
impl std::fmt::Debug for FilePaths {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FilePaths");
        formatter.field("file_path", &self.file_path);
        formatter.field("file_name", &self.file_name);
        formatter.field("resource_id", &self.resource_id);
        formatter.field("hash", &self.hash);
        formatter.finish()
    }
}
/// See [`FilePaths`](crate::model::FilePaths)
pub mod file_paths {

    /// A builder for [`FilePaths`](crate::model::FilePaths)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) file_path: std::option::Option<std::string::String>,
        pub(crate) file_name: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) hash: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Path to the infected or suspicious file on the resource it was detected on. </p>
        pub fn file_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_path = Some(input.into());
            self
        }
        /// <p>Path to the infected or suspicious file on the resource it was detected on. </p>
        pub fn set_file_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.file_path = input;
            self
        }
        /// <p>The name of the infected or suspicious file corresponding to the hash. </p>
        pub fn file_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_name = Some(input.into());
            self
        }
        /// <p>The name of the infected or suspicious file corresponding to the hash. </p>
        pub fn set_file_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.file_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource on which the threat was detected. </p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource on which the threat was detected. </p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The hash value for the infected or suspicious file. </p>
        pub fn hash(mut self, input: impl Into<std::string::String>) -> Self {
            self.hash = Some(input.into());
            self
        }
        /// <p>The hash value for the infected or suspicious file. </p>
        pub fn set_hash(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hash = input;
            self
        }
        /// Consumes the builder and constructs a [`FilePaths`](crate::model::FilePaths)
        pub fn build(self) -> crate::model::FilePaths {
            crate::model::FilePaths {
                file_path: self.file_path,
                file_name: self.file_name,
                resource_id: self.resource_id,
                hash: self.hash,
            }
        }
    }
}
impl FilePaths {
    /// Creates a new builder-style object to manufacture [`FilePaths`](crate::model::FilePaths)
    pub fn builder() -> crate::model::file_paths::Builder {
        crate::model::file_paths::Builder::default()
    }
}

/// <p>The details of process-related information about a finding.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessDetails {
    /// <p>The name of the process.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The path to the process executable.</p>
    pub path: std::option::Option<std::string::String>,
    /// <p>The process ID.</p>
    pub pid: i32,
    /// <p>The parent process ID.</p>
    pub parent_pid: i32,
    /// <p>Indicates when the process was launched.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub launched_at: std::option::Option<std::string::String>,
    /// <p>Indicates when the process was terminated.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub terminated_at: std::option::Option<std::string::String>,
}
impl ProcessDetails {
    /// <p>The name of the process.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The path to the process executable.</p>
    pub fn path(&self) -> std::option::Option<&str> {
        self.path.as_deref()
    }
    /// <p>The process ID.</p>
    pub fn pid(&self) -> i32 {
        self.pid
    }
    /// <p>The parent process ID.</p>
    pub fn parent_pid(&self) -> i32 {
        self.parent_pid
    }
    /// <p>Indicates when the process was launched.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn launched_at(&self) -> std::option::Option<&str> {
        self.launched_at.as_deref()
    }
    /// <p>Indicates when the process was terminated.</p>
    /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
    pub fn terminated_at(&self) -> std::option::Option<&str> {
        self.terminated_at.as_deref()
    }
}
impl std::fmt::Debug for ProcessDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessDetails");
        formatter.field("name", &self.name);
        formatter.field("path", &self.path);
        formatter.field("pid", &self.pid);
        formatter.field("parent_pid", &self.parent_pid);
        formatter.field("launched_at", &self.launched_at);
        formatter.field("terminated_at", &self.terminated_at);
        formatter.finish()
    }
}
/// See [`ProcessDetails`](crate::model::ProcessDetails)
pub mod process_details {

    /// A builder for [`ProcessDetails`](crate::model::ProcessDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) pid: std::option::Option<i32>,
        pub(crate) parent_pid: std::option::Option<i32>,
        pub(crate) launched_at: std::option::Option<std::string::String>,
        pub(crate) terminated_at: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the process.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the process.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The path to the process executable.</p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.path = Some(input.into());
            self
        }
        /// <p>The path to the process executable.</p>
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path = input;
            self
        }
        /// <p>The process ID.</p>
        pub fn pid(mut self, input: i32) -> Self {
            self.pid = Some(input);
            self
        }
        /// <p>The process ID.</p>
        pub fn set_pid(mut self, input: std::option::Option<i32>) -> Self {
            self.pid = input;
            self
        }
        /// <p>The parent process ID.</p>
        pub fn parent_pid(mut self, input: i32) -> Self {
            self.parent_pid = Some(input);
            self
        }
        /// <p>The parent process ID.</p>
        pub fn set_parent_pid(mut self, input: std::option::Option<i32>) -> Self {
            self.parent_pid = input;
            self
        }
        /// <p>Indicates when the process was launched.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn launched_at(mut self, input: impl Into<std::string::String>) -> Self {
            self.launched_at = Some(input.into());
            self
        }
        /// <p>Indicates when the process was launched.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_launched_at(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.launched_at = input;
            self
        }
        /// <p>Indicates when the process was terminated.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn terminated_at(mut self, input: impl Into<std::string::String>) -> Self {
            self.terminated_at = Some(input.into());
            self
        }
        /// <p>Indicates when the process was terminated.</p>
        /// <p>Uses the <code>date-time</code> format specified in <a href="https://tools.ietf.org/html/rfc3339#section-5.6">RFC 3339 section 5.6, Internet Date/Time Format</a>. The value cannot contain spaces. For example, <code>2020-03-22T13:22:13.933Z</code>.</p>
        pub fn set_terminated_at(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.terminated_at = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessDetails`](crate::model::ProcessDetails)
        pub fn build(self) -> crate::model::ProcessDetails {
            crate::model::ProcessDetails {
                name: self.name,
                path: self.path,
                pid: self.pid.unwrap_or_default(),
                parent_pid: self.parent_pid.unwrap_or_default(),
                launched_at: self.launched_at,
                terminated_at: self.terminated_at,
            }
        }
    }
}
impl ProcessDetails {
    /// Creates a new builder-style object to manufacture [`ProcessDetails`](crate::model::ProcessDetails)
    pub fn builder() -> crate::model::process_details::Builder {
        crate::model::process_details::Builder::default()
    }
}

/// <p>Information about a network path component.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkPathComponent {
    /// <p>The identifier of a component in the network path.</p>
    pub component_id: std::option::Option<std::string::String>,
    /// <p>The type of component.</p>
    pub component_type: std::option::Option<std::string::String>,
    /// <p>Information about the component that comes after the current component in the network path.</p>
    pub egress: std::option::Option<crate::model::NetworkHeader>,
    /// <p>Information about the component that comes before the current node in the network path.</p>
    pub ingress: std::option::Option<crate::model::NetworkHeader>,
}
impl NetworkPathComponent {
    /// <p>The identifier of a component in the network path.</p>
    pub fn component_id(&self) -> std::option::Option<&str> {
        self.component_id.as_deref()
    }
    /// <p>The type of component.</p>
    pub fn component_type(&self) -> std::option::Option<&str> {
        self.component_type.as_deref()
    }
    /// <p>Information about the component that comes after the current component in the network path.</p>
    pub fn egress(&self) -> std::option::Option<&crate::model::NetworkHeader> {
        self.egress.as_ref()
    }
    /// <p>Information about the component that comes before the current node in the network path.</p>
    pub fn ingress(&self) -> std::option::Option<&crate::model::NetworkHeader> {
        self.ingress.as_ref()
    }
}
impl std::fmt::Debug for NetworkPathComponent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkPathComponent");
        formatter.field("component_id", &self.component_id);
        formatter.field("component_type", &self.component_type);
        formatter.field("egress", &self.egress);
        formatter.field("ingress", &self.ingress);
        formatter.finish()
    }
}
/// See [`NetworkPathComponent`](crate::model::NetworkPathComponent)
pub mod network_path_component {

    /// A builder for [`NetworkPathComponent`](crate::model::NetworkPathComponent)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) component_id: std::option::Option<std::string::String>,
        pub(crate) component_type: std::option::Option<std::string::String>,
        pub(crate) egress: std::option::Option<crate::model::NetworkHeader>,
        pub(crate) ingress: std::option::Option<crate::model::NetworkHeader>,
    }
    impl Builder {
        /// <p>The identifier of a component in the network path.</p>
        pub fn component_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_id = Some(input.into());
            self
        }
        /// <p>The identifier of a component in the network path.</p>
        pub fn set_component_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.component_id = input;
            self
        }
        /// <p>The type of component.</p>
        pub fn component_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_type = Some(input.into());
            self
        }
        /// <p>The type of component.</p>
        pub fn set_component_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.component_type = input;
            self
        }
        /// <p>Information about the component that comes after the current component in the network path.</p>
        pub fn egress(mut self, input: crate::model::NetworkHeader) -> Self {
            self.egress = Some(input);
            self
        }
        /// <p>Information about the component that comes after the current component in the network path.</p>
        pub fn set_egress(
            mut self,
            input: std::option::Option<crate::model::NetworkHeader>,
        ) -> Self {
            self.egress = input;
            self
        }
        /// <p>Information about the component that comes before the current node in the network path.</p>
        pub fn ingress(mut self, input: crate::model::NetworkHeader) -> Self {
            self.ingress = Some(input);
            self
        }
        /// <p>Information about the component that comes before the current node in the network path.</p>
        pub fn set_ingress(
            mut self,
            input: std::option::Option<crate::model::NetworkHeader>,
        ) -> Self {
            self.ingress = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkPathComponent`](crate::model::NetworkPathComponent)
        pub fn build(self) -> crate::model::NetworkPathComponent {
            crate::model::NetworkPathComponent {
                component_id: self.component_id,
                component_type: self.component_type,
                egress: self.egress,
                ingress: self.ingress,
            }
        }
    }
}
impl NetworkPathComponent {
    /// Creates a new builder-style object to manufacture [`NetworkPathComponent`](crate::model::NetworkPathComponent)
    pub fn builder() -> crate::model::network_path_component::Builder {
        crate::model::network_path_component::Builder::default()
    }
}

/// <p>Details about a network path component that occurs before or after the current component.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkHeader {
    /// <p>The protocol used for the component.</p>
    pub protocol: std::option::Option<std::string::String>,
    /// <p>Information about the destination of the component.</p>
    pub destination: std::option::Option<crate::model::NetworkPathComponentDetails>,
    /// <p>Information about the origin of the component.</p>
    pub source: std::option::Option<crate::model::NetworkPathComponentDetails>,
}
impl NetworkHeader {
    /// <p>The protocol used for the component.</p>
    pub fn protocol(&self) -> std::option::Option<&str> {
        self.protocol.as_deref()
    }
    /// <p>Information about the destination of the component.</p>
    pub fn destination(&self) -> std::option::Option<&crate::model::NetworkPathComponentDetails> {
        self.destination.as_ref()
    }
    /// <p>Information about the origin of the component.</p>
    pub fn source(&self) -> std::option::Option<&crate::model::NetworkPathComponentDetails> {
        self.source.as_ref()
    }
}
impl std::fmt::Debug for NetworkHeader {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkHeader");
        formatter.field("protocol", &self.protocol);
        formatter.field("destination", &self.destination);
        formatter.field("source", &self.source);
        formatter.finish()
    }
}
/// See [`NetworkHeader`](crate::model::NetworkHeader)
pub mod network_header {

    /// A builder for [`NetworkHeader`](crate::model::NetworkHeader)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) protocol: std::option::Option<std::string::String>,
        pub(crate) destination: std::option::Option<crate::model::NetworkPathComponentDetails>,
        pub(crate) source: std::option::Option<crate::model::NetworkPathComponentDetails>,
    }
    impl Builder {
        /// <p>The protocol used for the component.</p>
        pub fn protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.protocol = Some(input.into());
            self
        }
        /// <p>The protocol used for the component.</p>
        pub fn set_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.protocol = input;
            self
        }
        /// <p>Information about the destination of the component.</p>
        pub fn destination(mut self, input: crate::model::NetworkPathComponentDetails) -> Self {
            self.destination = Some(input);
            self
        }
        /// <p>Information about the destination of the component.</p>
        pub fn set_destination(
            mut self,
            input: std::option::Option<crate::model::NetworkPathComponentDetails>,
        ) -> Self {
            self.destination = input;
            self
        }
        /// <p>Information about the origin of the component.</p>
        pub fn source(mut self, input: crate::model::NetworkPathComponentDetails) -> Self {
            self.source = Some(input);
            self
        }
        /// <p>Information about the origin of the component.</p>
        pub fn set_source(
            mut self,
            input: std::option::Option<crate::model::NetworkPathComponentDetails>,
        ) -> Self {
            self.source = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkHeader`](crate::model::NetworkHeader)
        pub fn build(self) -> crate::model::NetworkHeader {
            crate::model::NetworkHeader {
                protocol: self.protocol,
                destination: self.destination,
                source: self.source,
            }
        }
    }
}
impl NetworkHeader {
    /// Creates a new builder-style object to manufacture [`NetworkHeader`](crate::model::NetworkHeader)
    pub fn builder() -> crate::model::network_header::Builder {
        crate::model::network_header::Builder::default()
    }
}

/// <p>Information about the destination of the next component in the network path.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkPathComponentDetails {
    /// <p>The IP addresses of the destination.</p>
    pub address: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of port ranges for the destination.</p>
    pub port_ranges: std::option::Option<std::vec::Vec<crate::model::PortRange>>,
}
impl NetworkPathComponentDetails {
    /// <p>The IP addresses of the destination.</p>
    pub fn address(&self) -> std::option::Option<&[std::string::String]> {
        self.address.as_deref()
    }
    /// <p>A list of port ranges for the destination.</p>
    pub fn port_ranges(&self) -> std::option::Option<&[crate::model::PortRange]> {
        self.port_ranges.as_deref()
    }
}
impl std::fmt::Debug for NetworkPathComponentDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkPathComponentDetails");
        formatter.field("address", &self.address);
        formatter.field("port_ranges", &self.port_ranges);
        formatter.finish()
    }
}
/// See [`NetworkPathComponentDetails`](crate::model::NetworkPathComponentDetails)
pub mod network_path_component_details {

    /// A builder for [`NetworkPathComponentDetails`](crate::model::NetworkPathComponentDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) address: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) port_ranges: std::option::Option<std::vec::Vec<crate::model::PortRange>>,
    }
    impl Builder {
        /// Appends an item to `address`.
        ///
        /// To override the contents of this collection use [`set_address`](Self::set_address).
        ///
        /// <p>The IP addresses of the destination.</p>
        pub fn address(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.address.unwrap_or_default();
            v.push(input.into());
            self.address = Some(v);
            self
        }
        /// <p>The IP addresses of the destination.</p>
        pub fn set_address(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.address = input;
            self
        }
        /// Appends an item to `port_ranges`.
        ///
        /// To override the contents of this collection use [`set_port_ranges`](Self::set_port_ranges).
        ///
        /// <p>A list of port ranges for the destination.</p>
        pub fn port_ranges(mut self, input: crate::model::PortRange) -> Self {
            let mut v = self.port_ranges.unwrap_or_default();
            v.push(input);
            self.port_ranges = Some(v);
            self
        }
        /// <p>A list of port ranges for the destination.</p>
        pub fn set_port_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PortRange>>,
        ) -> Self {
            self.port_ranges = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkPathComponentDetails`](crate::model::NetworkPathComponentDetails)
        pub fn build(self) -> crate::model::NetworkPathComponentDetails {
            crate::model::NetworkPathComponentDetails {
                address: self.address,
                port_ranges: self.port_ranges,
            }
        }
    }
}
impl NetworkPathComponentDetails {
    /// Creates a new builder-style object to manufacture [`NetworkPathComponentDetails`](crate::model::NetworkPathComponentDetails)
    pub fn builder() -> crate::model::network_path_component_details::Builder {
        crate::model::network_path_component_details::Builder::default()
    }
}

/// <p>A range of ports.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PortRange {
    /// <p>The first port in the port range.</p>
    pub begin: i32,
    /// <p>The last port in the port range.</p>
    pub end: i32,
}
impl PortRange {
    /// <p>The first port in the port range.</p>
    pub fn begin(&self) -> i32 {
        self.begin
    }
    /// <p>The last port in the port range.</p>
    pub fn end(&self) -> i32 {
        self.end
    }
}
impl std::fmt::Debug for PortRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PortRange");
        formatter.field("begin", &self.begin);
        formatter.field("end", &self.end);
        formatter.finish()
    }
}
/// See [`PortRange`](crate::model::PortRange)
pub mod port_range {

    /// A builder for [`PortRange`](crate::model::PortRange)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) begin: std::option::Option<i32>,
        pub(crate) end: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The first port in the port range.</p>
        pub fn begin(mut self, input: i32) -> Self {
            self.begin = Some(input);
            self
        }
        /// <p>The first port in the port range.</p>
        pub fn set_begin(mut self, input: std::option::Option<i32>) -> Self {
            self.begin = input;
            self
        }
        /// <p>The last port in the port range.</p>
        pub fn end(mut self, input: i32) -> Self {
            self.end = Some(input);
            self
        }
        /// <p>The last port in the port range.</p>
        pub fn set_end(mut self, input: std::option::Option<i32>) -> Self {
            self.end = input;
            self
        }
        /// Consumes the builder and constructs a [`PortRange`](crate::model::PortRange)
        pub fn build(self) -> crate::model::PortRange {
            crate::model::PortRange {
                begin: self.begin.unwrap_or_default(),
                end: self.end.unwrap_or_default(),
            }
        }
    }
}
impl PortRange {
    /// Creates a new builder-style object to manufacture [`PortRange`](crate::model::PortRange)
    pub fn builder() -> crate::model::port_range::Builder {
        crate::model::port_range::Builder::default()
    }
}

/// <p>The details of network-related information about a finding.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Network {
    /// <p>The direction of network traffic associated with a finding.</p>
    pub direction: std::option::Option<crate::model::NetworkDirection>,
    /// <p>The protocol of network-related information about a finding.</p>
    pub protocol: std::option::Option<std::string::String>,
    /// <p>The range of open ports that is present on the network.</p>
    pub open_port_range: std::option::Option<crate::model::PortRange>,
    /// <p>The source IPv4 address of network-related information about a finding.</p>
    pub source_ip_v4: std::option::Option<std::string::String>,
    /// <p>The source IPv6 address of network-related information about a finding.</p>
    pub source_ip_v6: std::option::Option<std::string::String>,
    /// <p>The source port of network-related information about a finding.</p>
    pub source_port: i32,
    /// <p>The source domain of network-related information about a finding.</p>
    pub source_domain: std::option::Option<std::string::String>,
    /// <p>The source media access control (MAC) address of network-related information about a finding.</p>
    pub source_mac: std::option::Option<std::string::String>,
    /// <p>The destination IPv4 address of network-related information about a finding.</p>
    pub destination_ip_v4: std::option::Option<std::string::String>,
    /// <p>The destination IPv6 address of network-related information about a finding.</p>
    pub destination_ip_v6: std::option::Option<std::string::String>,
    /// <p>The destination port of network-related information about a finding.</p>
    pub destination_port: i32,
    /// <p>The destination domain of network-related information about a finding.</p>
    pub destination_domain: std::option::Option<std::string::String>,
}
impl Network {
    /// <p>The direction of network traffic associated with a finding.</p>
    pub fn direction(&self) -> std::option::Option<&crate::model::NetworkDirection> {
        self.direction.as_ref()
    }
    /// <p>The protocol of network-related information about a finding.</p>
    pub fn protocol(&self) -> std::option::Option<&str> {
        self.protocol.as_deref()
    }
    /// <p>The range of open ports that is present on the network.</p>
    pub fn open_port_range(&self) -> std::option::Option<&crate::model::PortRange> {
        self.open_port_range.as_ref()
    }
    /// <p>The source IPv4 address of network-related information about a finding.</p>
    pub fn source_ip_v4(&self) -> std::option::Option<&str> {
        self.source_ip_v4.as_deref()
    }
    /// <p>The source IPv6 address of network-related information about a finding.</p>
    pub fn source_ip_v6(&self) -> std::option::Option<&str> {
        self.source_ip_v6.as_deref()
    }
    /// <p>The source port of network-related information about a finding.</p>
    pub fn source_port(&self) -> i32 {
        self.source_port
    }
    /// <p>The source domain of network-related information about a finding.</p>
    pub fn source_domain(&self) -> std::option::Option<&str> {
        self.source_domain.as_deref()
    }
    /// <p>The source media access control (MAC) address of network-related information about a finding.</p>
    pub fn source_mac(&self) -> std::option::Option<&str> {
        self.source_mac.as_deref()
    }
    /// <p>The destination IPv4 address of network-related information about a finding.</p>
    pub fn destination_ip_v4(&self) -> std::option::Option<&str> {
        self.destination_ip_v4.as_deref()
    }
    /// <p>The destination IPv6 address of network-related information about a finding.</p>
    pub fn destination_ip_v6(&self) -> std::option::Option<&str> {
        self.destination_ip_v6.as_deref()
    }
    /// <p>The destination port of network-related information about a finding.</p>
    pub fn destination_port(&self) -> i32 {
        self.destination_port
    }
    /// <p>The destination domain of network-related information about a finding.</p>
    pub fn destination_domain(&self) -> std::option::Option<&str> {
        self.destination_domain.as_deref()
    }
}
impl std::fmt::Debug for Network {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Network");
        formatter.field("direction", &self.direction);
        formatter.field("protocol", &self.protocol);
        formatter.field("open_port_range", &self.open_port_range);
        formatter.field("source_ip_v4", &self.source_ip_v4);
        formatter.field("source_ip_v6", &self.source_ip_v6);
        formatter.field("source_port", &self.source_port);
        formatter.field("source_domain", &self.source_domain);
        formatter.field("source_mac", &self.source_mac);
        formatter.field("destination_ip_v4", &self.destination_ip_v4);
        formatter.field("destination_ip_v6", &self.destination_ip_v6);
        formatter.field("destination_port", &self.destination_port);
        formatter.field("destination_domain", &self.destination_domain);
        formatter.finish()
    }
}
/// See [`Network`](crate::model::Network)
pub mod network {

    /// A builder for [`Network`](crate::model::Network)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) direction: std::option::Option<crate::model::NetworkDirection>,
        pub(crate) protocol: std::option::Option<std::string::String>,
        pub(crate) open_port_range: std::option::Option<crate::model::PortRange>,
        pub(crate) source_ip_v4: std::option::Option<std::string::String>,
        pub(crate) source_ip_v6: std::option::Option<std::string::String>,
        pub(crate) source_port: std::option::Option<i32>,
        pub(crate) source_domain: std::option::Option<std::string::String>,
        pub(crate) source_mac: std::option::Option<std::string::String>,
        pub(crate) destination_ip_v4: std::option::Option<std::string::String>,
        pub(crate) destination_ip_v6: std::option::Option<std::string::String>,
        pub(crate) destination_port: std::option::Option<i32>,
        pub(crate) destination_domain: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The direction of network traffic associated with a finding.</p>
        pub fn direction(mut self, input: crate::model::NetworkDirection) -> Self {
            self.direction = Some(input);
            self
        }
        /// <p>The direction of network traffic associated with a finding.</p>
        pub fn set_direction(
            mut self,
            input: std::option::Option<crate::model::NetworkDirection>,
        ) -> Self {
            self.direction = input;
            self
        }
        /// <p>The protocol of network-related information about a finding.</p>
        pub fn protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.protocol = Some(input.into());
            self
        }
        /// <p>The protocol of network-related information about a finding.</p>
        pub fn set_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.protocol = input;
            self
        }
        /// <p>The range of open ports that is present on the network.</p>
        pub fn open_port_range(mut self, input: crate::model::PortRange) -> Self {
            self.open_port_range = Some(input);
            self
        }
        /// <p>The range of open ports that is present on the network.</p>
        pub fn set_open_port_range(
            mut self,
            input: std::option::Option<crate::model::PortRange>,
        ) -> Self {
            self.open_port_range = input;
            self
        }
        /// <p>The source IPv4 address of network-related information about a finding.</p>
        pub fn source_ip_v4(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_ip_v4 = Some(input.into());
            self
        }
        /// <p>The source IPv4 address of network-related information about a finding.</p>
        pub fn set_source_ip_v4(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_ip_v4 = input;
            self
        }
        /// <p>The source IPv6 address of network-related information about a finding.</p>
        pub fn source_ip_v6(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_ip_v6 = Some(input.into());
            self
        }
        /// <p>The source IPv6 address of network-related information about a finding.</p>
        pub fn set_source_ip_v6(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_ip_v6 = input;
            self
        }
        /// <p>The source port of network-related information about a finding.</p>
        pub fn source_port(mut self, input: i32) -> Self {
            self.source_port = Some(input);
            self
        }
        /// <p>The source port of network-related information about a finding.</p>
        pub fn set_source_port(mut self, input: std::option::Option<i32>) -> Self {
            self.source_port = input;
            self
        }
        /// <p>The source domain of network-related information about a finding.</p>
        pub fn source_domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_domain = Some(input.into());
            self
        }
        /// <p>The source domain of network-related information about a finding.</p>
        pub fn set_source_domain(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_domain = input;
            self
        }
        /// <p>The source media access control (MAC) address of network-related information about a finding.</p>
        pub fn source_mac(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_mac = Some(input.into());
            self
        }
        /// <p>The source media access control (MAC) address of network-related information about a finding.</p>
        pub fn set_source_mac(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_mac = input;
            self
        }
        /// <p>The destination IPv4 address of network-related information about a finding.</p>
        pub fn destination_ip_v4(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_ip_v4 = Some(input.into());
            self
        }
        /// <p>The destination IPv4 address of network-related information about a finding.</p>
        pub fn set_destination_ip_v4(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_ip_v4 = input;
            self
        }
        /// <p>The destination IPv6 address of network-related information about a finding.</p>
        pub fn destination_ip_v6(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_ip_v6 = Some(input.into());
            self
        }
        /// <p>The destination IPv6 address of network-related information about a finding.</p>
        pub fn set_destination_ip_v6(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_ip_v6 = input;
            self
        }
        /// <p>The destination port of network-related information about a finding.</p>
        pub fn destination_port(mut self, input: i32) -> Self {
            self.destination_port = Some(input);
            self
        }
        /// <p>The destination port of network-related information about a finding.</p>
        pub fn set_destination_port(mut self, input: std::option::Option<i32>) -> Self {
            self.destination_port = input;
            self
        }
        /// <p>The destination domain of network-related information about a finding.</p>
        pub fn destination_domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_domain = Some(input.into());
            self
        }
        /// <p>The destination domain of network-related information about a finding.</p>
        pub fn set_destination_domain(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_domain = input;
            self
        }
        /// Consumes the builder and constructs a [`Network`](crate::model::Network)
        pub fn build(self) -> crate::model::Network {
            crate::model::Network {
                direction: self.direction,
                protocol: self.protocol,
                open_port_range: self.open_port_range,
                source_ip_v4: self.source_ip_v4,
                source_ip_v6: self.source_ip_v6,
                source_port: self.source_port.unwrap_or_default(),
                source_domain: self.source_domain,
                source_mac: self.source_mac,
                destination_ip_v4: self.destination_ip_v4,
                destination_ip_v6: self.destination_ip_v6,
                destination_port: self.destination_port.unwrap_or_default(),
                destination_domain: self.destination_domain,
            }
        }
    }
}
impl Network {
    /// Creates a new builder-style object to manufacture [`Network`](crate::model::Network)
    pub fn builder() -> crate::model::network::Builder {
        crate::model::network::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NetworkDirection {
    #[allow(missing_docs)] // documentation missing in model
    In,
    #[allow(missing_docs)] // documentation missing in model
    Out,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NetworkDirection {
    fn from(s: &str) -> Self {
        match s {
            "IN" => NetworkDirection::In,
            "OUT" => NetworkDirection::Out,
            other => NetworkDirection::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NetworkDirection {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NetworkDirection::from(s))
    }
}
impl NetworkDirection {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NetworkDirection::In => "IN",
            NetworkDirection::Out => "OUT",
            NetworkDirection::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["IN", "OUT"]
    }
}
impl AsRef<str> for NetworkDirection {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A list of malware related to a finding.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Malware {
    /// <p>The name of the malware that was observed.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of the malware that was observed.</p>
    pub r#type: std::option::Option<crate::model::MalwareType>,
    /// <p>The file system path of the malware that was observed.</p>
    pub path: std::option::Option<std::string::String>,
    /// <p>The state of the malware that was observed.</p>
    pub state: std::option::Option<crate::model::MalwareState>,
}
impl Malware {
    /// <p>The name of the malware that was observed.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of the malware that was observed.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::MalwareType> {
        self.r#type.as_ref()
    }
    /// <p>The file system path of the malware that was observed.</p>
    pub fn path(&self) -> std::option::Option<&str> {
        self.path.as_deref()
    }
    /// <p>The state of the malware that was observed.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::MalwareState> {
        self.state.as_ref()
    }
}
impl std::fmt::Debug for Malware {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Malware");
        formatter.field("name", &self.name);
        formatter.field("r#type", &self.r#type);
        formatter.field("path", &self.path);
        formatter.field("state", &self.state);
        formatter.finish()
    }
}
/// See [`Malware`](crate::model::Malware)
pub mod malware {

    /// A builder for [`Malware`](crate::model::Malware)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::MalwareType>,
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::MalwareState>,
    }
    impl Builder {
        /// <p>The name of the malware that was observed.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the malware that was observed.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of the malware that was observed.</p>
        pub fn r#type(mut self, input: crate::model::MalwareType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the malware that was observed.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::MalwareType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The file system path of the malware that was observed.</p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.path = Some(input.into());
            self
        }
        /// <p>The file system path of the malware that was observed.</p>
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path = input;
            self
        }
        /// <p>The state of the malware that was observed.</p>
        pub fn state(mut self, input: crate::model::MalwareState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the malware that was observed.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::MalwareState>) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`Malware`](crate::model::Malware)
        pub fn build(self) -> crate::model::Malware {
            crate::model::Malware {
                name: self.name,
                r#type: self.r#type,
                path: self.path,
                state: self.state,
            }
        }
    }
}
impl Malware {
    /// Creates a new builder-style object to manufacture [`Malware`](crate::model::Malware)
    pub fn builder() -> crate::model::malware::Builder {
        crate::model::malware::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MalwareState {
    #[allow(missing_docs)] // documentation missing in model
    Observed,
    #[allow(missing_docs)] // documentation missing in model
    RemovalFailed,
    #[allow(missing_docs)] // documentation missing in model
    Removed,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MalwareState {
    fn from(s: &str) -> Self {
        match s {
            "OBSERVED" => MalwareState::Observed,
            "REMOVAL_FAILED" => MalwareState::RemovalFailed,
            "REMOVED" => MalwareState::Removed,
            other => MalwareState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MalwareState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MalwareState::from(s))
    }
}
impl MalwareState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MalwareState::Observed => "OBSERVED",
            MalwareState::RemovalFailed => "REMOVAL_FAILED",
            MalwareState::Removed => "REMOVED",
            MalwareState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["OBSERVED", "REMOVAL_FAILED", "REMOVED"]
    }
}
impl AsRef<str> for MalwareState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MalwareType {
    #[allow(missing_docs)] // documentation missing in model
    Adware,
    #[allow(missing_docs)] // documentation missing in model
    BlendedThreat,
    #[allow(missing_docs)] // documentation missing in model
    BotnetAgent,
    #[allow(missing_docs)] // documentation missing in model
    CoinMiner,
    #[allow(missing_docs)] // documentation missing in model
    ExploitKit,
    #[allow(missing_docs)] // documentation missing in model
    Keylogger,
    #[allow(missing_docs)] // documentation missing in model
    Macro,
    #[allow(missing_docs)] // documentation missing in model
    PotentiallyUnwanted,
    #[allow(missing_docs)] // documentation missing in model
    Ransomware,
    #[allow(missing_docs)] // documentation missing in model
    RemoteAccess,
    #[allow(missing_docs)] // documentation missing in model
    Rootkit,
    #[allow(missing_docs)] // documentation missing in model
    Spyware,
    #[allow(missing_docs)] // documentation missing in model
    Trojan,
    #[allow(missing_docs)] // documentation missing in model
    Virus,
    #[allow(missing_docs)] // documentation missing in model
    Worm,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MalwareType {
    fn from(s: &str) -> Self {
        match s {
            "ADWARE" => MalwareType::Adware,
            "BLENDED_THREAT" => MalwareType::BlendedThreat,
            "BOTNET_AGENT" => MalwareType::BotnetAgent,
            "COIN_MINER" => MalwareType::CoinMiner,
            "EXPLOIT_KIT" => MalwareType::ExploitKit,
            "KEYLOGGER" => MalwareType::Keylogger,
            "MACRO" => MalwareType::Macro,
            "POTENTIALLY_UNWANTED" => MalwareType::PotentiallyUnwanted,
            "RANSOMWARE" => MalwareType::Ransomware,
            "REMOTE_ACCESS" => MalwareType::RemoteAccess,
            "ROOTKIT" => MalwareType::Rootkit,
            "SPYWARE" => MalwareType::Spyware,
            "TROJAN" => MalwareType::Trojan,
            "VIRUS" => MalwareType::Virus,
            "WORM" => MalwareType::Worm,
            other => MalwareType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MalwareType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MalwareType::from(s))
    }
}
impl MalwareType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MalwareType::Adware => "ADWARE",
            MalwareType::BlendedThreat => "BLENDED_THREAT",
            MalwareType::BotnetAgent => "BOTNET_AGENT",
            MalwareType::CoinMiner => "COIN_MINER",
            MalwareType::ExploitKit => "EXPLOIT_KIT",
            MalwareType::Keylogger => "KEYLOGGER",
            MalwareType::Macro => "MACRO",
            MalwareType::PotentiallyUnwanted => "POTENTIALLY_UNWANTED",
            MalwareType::Ransomware => "RANSOMWARE",
            MalwareType::RemoteAccess => "REMOTE_ACCESS",
            MalwareType::Rootkit => "ROOTKIT",
            MalwareType::Spyware => "SPYWARE",
            MalwareType::Trojan => "TROJAN",
            MalwareType::Virus => "VIRUS",
            MalwareType::Worm => "WORM",
            MalwareType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ADWARE",
            "BLENDED_THREAT",
            "BOTNET_AGENT",
            "COIN_MINER",
            "EXPLOIT_KIT",
            "KEYLOGGER",
            "MACRO",
            "POTENTIALLY_UNWANTED",
            "RANSOMWARE",
            "REMOTE_ACCESS",
            "ROOTKIT",
            "SPYWARE",
            "TROJAN",
            "VIRUS",
            "WORM",
        ]
    }
}
impl AsRef<str> for MalwareType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Details about the remediation steps for a finding.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Remediation {
    /// <p>A recommendation on the steps to take to remediate the issue identified by a finding.</p>
    pub recommendation: std::option::Option<crate::model::Recommendation>,
}
impl Remediation {
    /// <p>A recommendation on the steps to take to remediate the issue identified by a finding.</p>
    pub fn recommendation(&self) -> std::option::Option<&crate::model::Recommendation> {
        self.recommendation.as_ref()
    }
}
impl std::fmt::Debug for Remediation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Remediation");
        formatter.field("recommendation", &self.recommendation);
        formatter.finish()
    }
}
/// See [`Remediation`](crate::model::Remediation)
pub mod remediation {

    /// A builder for [`Remediation`](crate::model::Remediation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) recommendation: std::option::Option<crate::model::Recommendation>,
    }
    impl Builder {
        /// <p>A recommendation on the steps to take to remediate the issue identified by a finding.</p>
        pub fn recommendation(mut self, input: crate::model::Recommendation) -> Self {
            self.recommendation = Some(input);
            self
        }
        /// <p>A recommendation on the steps to take to remediate the issue identified by a finding.</p>
        pub fn set_recommendation(
            mut self,
            input: std::option::Option<crate::model::Recommendation>,
        ) -> Self {
            self.recommendation = input;
            self
        }
        /// Consumes the builder and constructs a [`Remediation`](crate::model::Remediation)
        pub fn build(self) -> crate::model::Remediation {
            crate::model::Remediation {
                recommendation: self.recommendation,
            }
        }
    }
}
impl Remediation {
    /// Creates a new builder-style object to manufacture [`Remediation`](crate::model::Remediation)
    pub fn builder() -> crate::model::remediation::Builder {
        crate::model::remediation::Builder::default()
    }
}

/// <p>A recommendation on how to remediate the issue identified in a finding.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Recommendation {
    /// <p>Describes the recommended steps to take to remediate an issue identified in a finding.</p>
    pub text: std::option::Option<std::string::String>,
    /// <p>A URL to a page or site that contains information about how to remediate a finding.</p>
    pub url: std::option::Option<std::string::String>,
}
impl Recommendation {
    /// <p>Describes the recommended steps to take to remediate an issue identified in a finding.</p>
    pub fn text(&self) -> std::option::Option<&str> {
        self.text.as_deref()
    }
    /// <p>A URL to a page or site that contains information about how to remediate a finding.</p>
    pub fn url(&self) -> std::option::Option<&str> {
        self.url.as_deref()
    }
}
impl std::fmt::Debug for Recommendation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Recommendation");
        formatter.field("text", &self.text);
        formatter.field("url", &self.url);
        formatter.finish()
    }
}
/// See [`Recommendation`](crate::model::Recommendation)
pub mod recommendation {

    /// A builder for [`Recommendation`](crate::model::Recommendation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) text: std::option::Option<std::string::String>,
        pub(crate) url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Describes the recommended steps to take to remediate an issue identified in a finding.</p>
        pub fn text(mut self, input: impl Into<std::string::String>) -> Self {
            self.text = Some(input.into());
            self
        }
        /// <p>Describes the recommended steps to take to remediate an issue identified in a finding.</p>
        pub fn set_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.text = input;
            self
        }
        /// <p>A URL to a page or site that contains information about how to remediate a finding.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        /// <p>A URL to a page or site that contains information about how to remediate a finding.</p>
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// Consumes the builder and constructs a [`Recommendation`](crate::model::Recommendation)
        pub fn build(self) -> crate::model::Recommendation {
            crate::model::Recommendation {
                text: self.text,
                url: self.url,
            }
        }
    }
}
impl Recommendation {
    /// Creates a new builder-style object to manufacture [`Recommendation`](crate::model::Recommendation)
    pub fn builder() -> crate::model::recommendation::Builder {
        crate::model::recommendation::Builder::default()
    }
}

/// <p>The severity of the finding.</p>
/// <p>The finding provider can provide the initial severity. The finding provider can only update the severity if it has not been updated using <code>BatchUpdateFindings</code>.</p>
/// <p>The finding must have either <code>Label</code> or <code>Normalized</code> populated. If only one of these attributes is populated, then Security Hub automatically populates the other one. If neither attribute is populated, then the finding is invalid. <code>Label</code> is the preferred attribute.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Severity {
    /// <p>Deprecated. This attribute is being deprecated. Instead of providing <code>Product</code>, provide <code>Original</code>.</p>
    /// <p>The native severity as defined by the Amazon Web Services service or integrated partner product that generated the finding.</p>
    pub product: f64,
    /// <p>The severity value of the finding. The allowed values are the following.</p>
    /// <ul>
    /// <li> <p> <code>INFORMATIONAL</code> - No issue was found.</p> </li>
    /// <li> <p> <code>LOW</code> - The issue does not require action on its own.</p> </li>
    /// <li> <p> <code>MEDIUM</code> - The issue must be addressed but not urgently.</p> </li>
    /// <li> <p> <code>HIGH</code> - The issue must be addressed as a priority.</p> </li>
    /// <li> <p> <code>CRITICAL</code> - The issue must be remediated immediately to avoid it escalating.</p> </li>
    /// </ul>
    /// <p>If you provide <code>Normalized</code> and do not provide <code>Label</code>, then <code>Label</code> is set automatically as follows. </p>
    /// <ul>
    /// <li> <p>0 - <code>INFORMATIONAL</code> </p> </li>
    /// <li> <p>139 - <code>LOW</code> </p> </li>
    /// <li> <p>4069 - <code>MEDIUM</code> </p> </li>
    /// <li> <p>7089 - <code>HIGH</code> </p> </li>
    /// <li> <p>90100 - <code>CRITICAL</code> </p> </li>
    /// </ul>
    pub label: std::option::Option<crate::model::SeverityLabel>,
    /// <p>Deprecated. The normalized severity of a finding. This attribute is being deprecated. Instead of providing <code>Normalized</code>, provide <code>Label</code>.</p>
    /// <p>If you provide <code>Label</code> and do not provide <code>Normalized</code>, then <code>Normalized</code> is set automatically as follows.</p>
    /// <ul>
    /// <li> <p> <code>INFORMATIONAL</code> - 0</p> </li>
    /// <li> <p> <code>LOW</code> - 1</p> </li>
    /// <li> <p> <code>MEDIUM</code> - 40</p> </li>
    /// <li> <p> <code>HIGH</code> - 70</p> </li>
    /// <li> <p> <code>CRITICAL</code> - 90</p> </li>
    /// </ul>
    pub normalized: i32,
    /// <p>The native severity from the finding product that generated the finding.</p>
    pub original: std::option::Option<std::string::String>,
}
impl Severity {
    /// <p>Deprecated. This attribute is being deprecated. Instead of providing <code>Product</code>, provide <code>Original</code>.</p>
    /// <p>The native severity as defined by the Amazon Web Services service or integrated partner product that generated the finding.</p>
    pub fn product(&self) -> f64 {
        self.product
    }
    /// <p>The severity value of the finding. The allowed values are the following.</p>
    /// <ul>
    /// <li> <p> <code>INFORMATIONAL</code> - No issue was found.</p> </li>
    /// <li> <p> <code>LOW</code> - The issue does not require action on its own.</p> </li>
    /// <li> <p> <code>MEDIUM</code> - The issue must be addressed but not urgently.</p> </li>
    /// <li> <p> <code>HIGH</code> - The issue must be addressed as a priority.</p> </li>
    /// <li> <p> <code>CRITICAL</code> - The issue must be remediated immediately to avoid it escalating.</p> </li>
    /// </ul>
    /// <p>If you provide <code>Normalized</code> and do not provide <code>Label</code>, then <code>Label</code> is set automatically as follows. </p>
    /// <ul>
    /// <li> <p>0 - <code>INFORMATIONAL</code> </p> </li>
    /// <li> <p>139 - <code>LOW</code> </p> </li>
    /// <li> <p>4069 - <code>MEDIUM</code> </p> </li>
    /// <li> <p>7089 - <code>HIGH</code> </p> </li>
    /// <li> <p>90100 - <code>CRITICAL</code> </p> </li>
    /// </ul>
    pub fn label(&self) -> std::option::Option<&crate::model::SeverityLabel> {
        self.label.as_ref()
    }
    /// <p>Deprecated. The normalized severity of a finding. This attribute is being deprecated. Instead of providing <code>Normalized</code>, provide <code>Label</code>.</p>
    /// <p>If you provide <code>Label</code> and do not provide <code>Normalized</code>, then <code>Normalized</code> is set automatically as follows.</p>
    /// <ul>
    /// <li> <p> <code>INFORMATIONAL</code> - 0</p> </li>
    /// <li> <p> <code>LOW</code> - 1</p> </li>
    /// <li> <p> <code>MEDIUM</code> - 40</p> </li>
    /// <li> <p> <code>HIGH</code> - 70</p> </li>
    /// <li> <p> <code>CRITICAL</code> - 90</p> </li>
    /// </ul>
    pub fn normalized(&self) -> i32 {
        self.normalized
    }
    /// <p>The native severity from the finding product that generated the finding.</p>
    pub fn original(&self) -> std::option::Option<&str> {
        self.original.as_deref()
    }
}
impl std::fmt::Debug for Severity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Severity");
        formatter.field("product", &self.product);
        formatter.field("label", &self.label);
        formatter.field("normalized", &self.normalized);
        formatter.field("original", &self.original);
        formatter.finish()
    }
}
/// See [`Severity`](crate::model::Severity)
pub mod severity {

    /// A builder for [`Severity`](crate::model::Severity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) product: std::option::Option<f64>,
        pub(crate) label: std::option::Option<crate::model::SeverityLabel>,
        pub(crate) normalized: std::option::Option<i32>,
        pub(crate) original: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Deprecated. This attribute is being deprecated. Instead of providing <code>Product</code>, provide <code>Original</code>.</p>
        /// <p>The native severity as defined by the Amazon Web Services service or integrated partner product that generated the finding.</p>
        pub fn product(mut self, input: f64) -> Self {
            self.product = Some(input);
            self
        }
        /// <p>Deprecated. This attribute is being deprecated. Instead of providing <code>Product</code>, provide <code>Original</code>.</p>
        /// <p>The native severity as defined by the Amazon Web Services service or integrated partner product that generated the finding.</p>
        pub fn set_product(mut self, input: std::option::Option<f64>) -> Self {
            self.product = input;
            self
        }
        /// <p>The severity value of the finding. The allowed values are the following.</p>
        /// <ul>
        /// <li> <p> <code>INFORMATIONAL</code> - No issue was found.</p> </li>
        /// <li> <p> <code>LOW</code> - The issue does not require action on its own.</p> </li>
        /// <li> <p> <code>MEDIUM</code> - The issue must be addressed but not urgently.</p> </li>
        /// <li> <p> <code>HIGH</code> - The issue must be addressed as a priority.</p> </li>
        /// <li> <p> <code>CRITICAL</code> - The issue must be remediated immediately to avoid it escalating.</p> </li>
        /// </ul>
        /// <p>If you provide <code>Normalized</code> and do not provide <code>Label</code>, then <code>Label</code> is set automatically as follows. </p>
        /// <ul>
        /// <li> <p>0 - <code>INFORMATIONAL</code> </p> </li>
        /// <li> <p>139 - <code>LOW</code> </p> </li>
        /// <li> <p>4069 - <code>MEDIUM</code> </p> </li>
        /// <li> <p>7089 - <code>HIGH</code> </p> </li>
        /// <li> <p>90100 - <code>CRITICAL</code> </p> </li>
        /// </ul>
        pub fn label(mut self, input: crate::model::SeverityLabel) -> Self {
            self.label = Some(input);
            self
        }
        /// <p>The severity value of the finding. The allowed values are the following.</p>
        /// <ul>
        /// <li> <p> <code>INFORMATIONAL</code> - No issue was found.</p> </li>
        /// <li> <p> <code>LOW</code> - The issue does not require action on its own.</p> </li>
        /// <li> <p> <code>MEDIUM</code> - The issue must be addressed but not urgently.</p> </li>
        /// <li> <p> <code>HIGH</code> - The issue must be addressed as a priority.</p> </li>
        /// <li> <p> <code>CRITICAL</code> - The issue must be remediated immediately to avoid it escalating.</p> </li>
        /// </ul>
        /// <p>If you provide <code>Normalized</code> and do not provide <code>Label</code>, then <code>Label</code> is set automatically as follows. </p>
        /// <ul>
        /// <li> <p>0 - <code>INFORMATIONAL</code> </p> </li>
        /// <li> <p>139 - <code>LOW</code> </p> </li>
        /// <li> <p>4069 - <code>MEDIUM</code> </p> </li>
        /// <li> <p>7089 - <code>HIGH</code> </p> </li>
        /// <li> <p>90100 - <code>CRITICAL</code> </p> </li>
        /// </ul>
        pub fn set_label(
            mut self,
            input: std::option::Option<crate::model::SeverityLabel>,
        ) -> Self {
            self.label = input;
            self
        }
        /// <p>Deprecated. The normalized severity of a finding. This attribute is being deprecated. Instead of providing <code>Normalized</code>, provide <code>Label</code>.</p>
        /// <p>If you provide <code>Label</code> and do not provide <code>Normalized</code>, then <code>Normalized</code> is set automatically as follows.</p>
        /// <ul>
        /// <li> <p> <code>INFORMATIONAL</code> - 0</p> </li>
        /// <li> <p> <code>LOW</code> - 1</p> </li>
        /// <li> <p> <code>MEDIUM</code> - 40</p> </li>
        /// <li> <p> <code>HIGH</code> - 70</p> </li>
        /// <li> <p> <code>CRITICAL</code> - 90</p> </li>
        /// </ul>
        pub fn normalized(mut self, input: i32) -> Self {
            self.normalized = Some(input);
            self
        }
        /// <p>Deprecated. The normalized severity of a finding. This attribute is being deprecated. Instead of providing <code>Normalized</code>, provide <code>Label</code>.</p>
        /// <p>If you provide <code>Label</code> and do not provide <code>Normalized</code>, then <code>Normalized</code> is set automatically as follows.</p>
        /// <ul>
        /// <li> <p> <code>INFORMATIONAL</code> - 0</p> </li>
        /// <li> <p> <code>LOW</code> - 1</p> </li>
        /// <li> <p> <code>MEDIUM</code> - 40</p> </li>
        /// <li> <p> <code>HIGH</code> - 70</p> </li>
        /// <li> <p> <code>CRITICAL</code> - 90</p> </li>
        /// </ul>
        pub fn set_normalized(mut self, input: std::option::Option<i32>) -> Self {
            self.normalized = input;
            self
        }
        /// <p>The native severity from the finding product that generated the finding.</p>
        pub fn original(mut self, input: impl Into<std::string::String>) -> Self {
            self.original = Some(input.into());
            self
        }
        /// <p>The native severity from the finding product that generated the finding.</p>
        pub fn set_original(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.original = input;
            self
        }
        /// Consumes the builder and constructs a [`Severity`](crate::model::Severity)
        pub fn build(self) -> crate::model::Severity {
            crate::model::Severity {
                product: self.product.unwrap_or_default(),
                label: self.label,
                normalized: self.normalized.unwrap_or_default(),
                original: self.original,
            }
        }
    }
}
impl Severity {
    /// Creates a new builder-style object to manufacture [`Severity`](crate::model::Severity)
    pub fn builder() -> crate::model::severity::Builder {
        crate::model::severity::Builder::default()
    }
}

/// <p>A collection of finding attributes used to sort findings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SortCriterion {
    /// <p>The finding attribute used to sort findings.</p>
    pub field: std::option::Option<std::string::String>,
    /// <p>The order used to sort findings.</p>
    pub sort_order: std::option::Option<crate::model::SortOrder>,
}
impl SortCriterion {
    /// <p>The finding attribute used to sort findings.</p>
    pub fn field(&self) -> std::option::Option<&str> {
        self.field.as_deref()
    }
    /// <p>The order used to sort findings.</p>
    pub fn sort_order(&self) -> std::option::Option<&crate::model::SortOrder> {
        self.sort_order.as_ref()
    }
}
impl std::fmt::Debug for SortCriterion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SortCriterion");
        formatter.field("field", &self.field);
        formatter.field("sort_order", &self.sort_order);
        formatter.finish()
    }
}
/// See [`SortCriterion`](crate::model::SortCriterion)
pub mod sort_criterion {

    /// A builder for [`SortCriterion`](crate::model::SortCriterion)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field: std::option::Option<std::string::String>,
        pub(crate) sort_order: std::option::Option<crate::model::SortOrder>,
    }
    impl Builder {
        /// <p>The finding attribute used to sort findings.</p>
        pub fn field(mut self, input: impl Into<std::string::String>) -> Self {
            self.field = Some(input.into());
            self
        }
        /// <p>The finding attribute used to sort findings.</p>
        pub fn set_field(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field = input;
            self
        }
        /// <p>The order used to sort findings.</p>
        pub fn sort_order(mut self, input: crate::model::SortOrder) -> Self {
            self.sort_order = Some(input);
            self
        }
        /// <p>The order used to sort findings.</p>
        pub fn set_sort_order(
            mut self,
            input: std::option::Option<crate::model::SortOrder>,
        ) -> Self {
            self.sort_order = input;
            self
        }
        /// Consumes the builder and constructs a [`SortCriterion`](crate::model::SortCriterion)
        pub fn build(self) -> crate::model::SortCriterion {
            crate::model::SortCriterion {
                field: self.field,
                sort_order: self.sort_order,
            }
        }
    }
}
impl SortCriterion {
    /// Creates a new builder-style object to manufacture [`SortCriterion`](crate::model::SortCriterion)
    pub fn builder() -> crate::model::sort_criterion::Builder {
        crate::model::sort_criterion::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortOrder {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SortOrder {
    fn from(s: &str) -> Self {
        match s {
            "asc" => SortOrder::Ascending,
            "desc" => SortOrder::Descending,
            other => SortOrder::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortOrder::from(s))
    }
}
impl SortOrder {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SortOrder::Ascending => "asc",
            SortOrder::Descending => "desc",
            SortOrder::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["asc", "desc"]
    }
}
impl AsRef<str> for SortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A resource that represents your subscription to a supported standard.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StandardsSubscription {
    /// <p>The ARN of a resource that represents your subscription to a supported standard.</p>
    pub standards_subscription_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of a standard.</p>
    pub standards_arn: std::option::Option<std::string::String>,
    /// <p>A key-value pair of input for the standard.</p>
    pub standards_input:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The status of the standard subscription.</p>
    /// <p>The status values are as follows:</p>
    /// <ul>
    /// <li> <p> <code>PENDING</code> - Standard is in the process of being enabled.</p> </li>
    /// <li> <p> <code>READY</code> - Standard is enabled.</p> </li>
    /// <li> <p> <code>INCOMPLETE</code> - Standard could not be enabled completely. Some controls may not be available.</p> </li>
    /// <li> <p> <code>DELETING</code> - Standard is in the process of being disabled.</p> </li>
    /// <li> <p> <code>FAILED</code> - Standard could not be disabled.</p> </li>
    /// </ul>
    pub standards_status: std::option::Option<crate::model::StandardsStatus>,
    /// <p>The reason for the current status.</p>
    pub standards_status_reason: std::option::Option<crate::model::StandardsStatusReason>,
}
impl StandardsSubscription {
    /// <p>The ARN of a resource that represents your subscription to a supported standard.</p>
    pub fn standards_subscription_arn(&self) -> std::option::Option<&str> {
        self.standards_subscription_arn.as_deref()
    }
    /// <p>The ARN of a standard.</p>
    pub fn standards_arn(&self) -> std::option::Option<&str> {
        self.standards_arn.as_deref()
    }
    /// <p>A key-value pair of input for the standard.</p>
    pub fn standards_input(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.standards_input.as_ref()
    }
    /// <p>The status of the standard subscription.</p>
    /// <p>The status values are as follows:</p>
    /// <ul>
    /// <li> <p> <code>PENDING</code> - Standard is in the process of being enabled.</p> </li>
    /// <li> <p> <code>READY</code> - Standard is enabled.</p> </li>
    /// <li> <p> <code>INCOMPLETE</code> - Standard could not be enabled completely. Some controls may not be available.</p> </li>
    /// <li> <p> <code>DELETING</code> - Standard is in the process of being disabled.</p> </li>
    /// <li> <p> <code>FAILED</code> - Standard could not be disabled.</p> </li>
    /// </ul>
    pub fn standards_status(&self) -> std::option::Option<&crate::model::StandardsStatus> {
        self.standards_status.as_ref()
    }
    /// <p>The reason for the current status.</p>
    pub fn standards_status_reason(
        &self,
    ) -> std::option::Option<&crate::model::StandardsStatusReason> {
        self.standards_status_reason.as_ref()
    }
}
impl std::fmt::Debug for StandardsSubscription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StandardsSubscription");
        formatter.field(
            "standards_subscription_arn",
            &self.standards_subscription_arn,
        );
        formatter.field("standards_arn", &self.standards_arn);
        formatter.field("standards_input", &self.standards_input);
        formatter.field("standards_status", &self.standards_status);
        formatter.field("standards_status_reason", &self.standards_status_reason);
        formatter.finish()
    }
}
/// See [`StandardsSubscription`](crate::model::StandardsSubscription)
pub mod standards_subscription {

    /// A builder for [`StandardsSubscription`](crate::model::StandardsSubscription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) standards_subscription_arn: std::option::Option<std::string::String>,
        pub(crate) standards_arn: std::option::Option<std::string::String>,
        pub(crate) standards_input: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) standards_status: std::option::Option<crate::model::StandardsStatus>,
        pub(crate) standards_status_reason:
            std::option::Option<crate::model::StandardsStatusReason>,
    }
    impl Builder {
        /// <p>The ARN of a resource that represents your subscription to a supported standard.</p>
        pub fn standards_subscription_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.standards_subscription_arn = Some(input.into());
            self
        }
        /// <p>The ARN of a resource that represents your subscription to a supported standard.</p>
        pub fn set_standards_subscription_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.standards_subscription_arn = input;
            self
        }
        /// <p>The ARN of a standard.</p>
        pub fn standards_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.standards_arn = Some(input.into());
            self
        }
        /// <p>The ARN of a standard.</p>
        pub fn set_standards_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.standards_arn = input;
            self
        }
        /// Adds a key-value pair to `standards_input`.
        ///
        /// To override the contents of this collection use [`set_standards_input`](Self::set_standards_input).
        ///
        /// <p>A key-value pair of input for the standard.</p>
        pub fn standards_input(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.standards_input.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.standards_input = Some(hash_map);
            self
        }
        /// <p>A key-value pair of input for the standard.</p>
        pub fn set_standards_input(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.standards_input = input;
            self
        }
        /// <p>The status of the standard subscription.</p>
        /// <p>The status values are as follows:</p>
        /// <ul>
        /// <li> <p> <code>PENDING</code> - Standard is in the process of being enabled.</p> </li>
        /// <li> <p> <code>READY</code> - Standard is enabled.</p> </li>
        /// <li> <p> <code>INCOMPLETE</code> - Standard could not be enabled completely. Some controls may not be available.</p> </li>
        /// <li> <p> <code>DELETING</code> - Standard is in the process of being disabled.</p> </li>
        /// <li> <p> <code>FAILED</code> - Standard could not be disabled.</p> </li>
        /// </ul>
        pub fn standards_status(mut self, input: crate::model::StandardsStatus) -> Self {
            self.standards_status = Some(input);
            self
        }
        /// <p>The status of the standard subscription.</p>
        /// <p>The status values are as follows:</p>
        /// <ul>
        /// <li> <p> <code>PENDING</code> - Standard is in the process of being enabled.</p> </li>
        /// <li> <p> <code>READY</code> - Standard is enabled.</p> </li>
        /// <li> <p> <code>INCOMPLETE</code> - Standard could not be enabled completely. Some controls may not be available.</p> </li>
        /// <li> <p> <code>DELETING</code> - Standard is in the process of being disabled.</p> </li>
        /// <li> <p> <code>FAILED</code> - Standard could not be disabled.</p> </li>
        /// </ul>
        pub fn set_standards_status(
            mut self,
            input: std::option::Option<crate::model::StandardsStatus>,
        ) -> Self {
            self.standards_status = input;
            self
        }
        /// <p>The reason for the current status.</p>
        pub fn standards_status_reason(
            mut self,
            input: crate::model::StandardsStatusReason,
        ) -> Self {
            self.standards_status_reason = Some(input);
            self
        }
        /// <p>The reason for the current status.</p>
        pub fn set_standards_status_reason(
            mut self,
            input: std::option::Option<crate::model::StandardsStatusReason>,
        ) -> Self {
            self.standards_status_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`StandardsSubscription`](crate::model::StandardsSubscription)
        pub fn build(self) -> crate::model::StandardsSubscription {
            crate::model::StandardsSubscription {
                standards_subscription_arn: self.standards_subscription_arn,
                standards_arn: self.standards_arn,
                standards_input: self.standards_input,
                standards_status: self.standards_status,
                standards_status_reason: self.standards_status_reason,
            }
        }
    }
}
impl StandardsSubscription {
    /// Creates a new builder-style object to manufacture [`StandardsSubscription`](crate::model::StandardsSubscription)
    pub fn builder() -> crate::model::standards_subscription::Builder {
        crate::model::standards_subscription::Builder::default()
    }
}

/// <p>The reason for the current status of a standard subscription.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StandardsStatusReason {
    /// <p>The reason code that represents the reason for the current status of a standard subscription.</p>
    pub status_reason_code: std::option::Option<crate::model::StatusReasonCode>,
}
impl StandardsStatusReason {
    /// <p>The reason code that represents the reason for the current status of a standard subscription.</p>
    pub fn status_reason_code(&self) -> std::option::Option<&crate::model::StatusReasonCode> {
        self.status_reason_code.as_ref()
    }
}
impl std::fmt::Debug for StandardsStatusReason {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StandardsStatusReason");
        formatter.field("status_reason_code", &self.status_reason_code);
        formatter.finish()
    }
}
/// See [`StandardsStatusReason`](crate::model::StandardsStatusReason)
pub mod standards_status_reason {

    /// A builder for [`StandardsStatusReason`](crate::model::StandardsStatusReason)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status_reason_code: std::option::Option<crate::model::StatusReasonCode>,
    }
    impl Builder {
        /// <p>The reason code that represents the reason for the current status of a standard subscription.</p>
        pub fn status_reason_code(mut self, input: crate::model::StatusReasonCode) -> Self {
            self.status_reason_code = Some(input);
            self
        }
        /// <p>The reason code that represents the reason for the current status of a standard subscription.</p>
        pub fn set_status_reason_code(
            mut self,
            input: std::option::Option<crate::model::StatusReasonCode>,
        ) -> Self {
            self.status_reason_code = input;
            self
        }
        /// Consumes the builder and constructs a [`StandardsStatusReason`](crate::model::StandardsStatusReason)
        pub fn build(self) -> crate::model::StandardsStatusReason {
            crate::model::StandardsStatusReason {
                status_reason_code: self.status_reason_code,
            }
        }
    }
}
impl StandardsStatusReason {
    /// Creates a new builder-style object to manufacture [`StandardsStatusReason`](crate::model::StandardsStatusReason)
    pub fn builder() -> crate::model::standards_status_reason::Builder {
        crate::model::standards_status_reason::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StatusReasonCode {
    #[allow(missing_docs)] // documentation missing in model
    InternalError,
    #[allow(missing_docs)] // documentation missing in model
    NoAvailableConfigurationRecorder,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StatusReasonCode {
    fn from(s: &str) -> Self {
        match s {
            "INTERNAL_ERROR" => StatusReasonCode::InternalError,
            "NO_AVAILABLE_CONFIGURATION_RECORDER" => {
                StatusReasonCode::NoAvailableConfigurationRecorder
            }
            other => StatusReasonCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StatusReasonCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StatusReasonCode::from(s))
    }
}
impl StatusReasonCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StatusReasonCode::InternalError => "INTERNAL_ERROR",
            StatusReasonCode::NoAvailableConfigurationRecorder => {
                "NO_AVAILABLE_CONFIGURATION_RECORDER"
            }
            StatusReasonCode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["INTERNAL_ERROR", "NO_AVAILABLE_CONFIGURATION_RECORDER"]
    }
}
impl AsRef<str> for StatusReasonCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StandardsStatus {
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Incomplete,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Ready,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StandardsStatus {
    fn from(s: &str) -> Self {
        match s {
            "DELETING" => StandardsStatus::Deleting,
            "FAILED" => StandardsStatus::Failed,
            "INCOMPLETE" => StandardsStatus::Incomplete,
            "PENDING" => StandardsStatus::Pending,
            "READY" => StandardsStatus::Ready,
            other => StandardsStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StandardsStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StandardsStatus::from(s))
    }
}
impl StandardsStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StandardsStatus::Deleting => "DELETING",
            StandardsStatus::Failed => "FAILED",
            StandardsStatus::Incomplete => "INCOMPLETE",
            StandardsStatus::Pending => "PENDING",
            StandardsStatus::Ready => "READY",
            StandardsStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["DELETING", "FAILED", "INCOMPLETE", "PENDING", "READY"]
    }
}
impl AsRef<str> for StandardsStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Details for an individual security standard control.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StandardsControl {
    /// <p>The ARN of the security standard control.</p>
    pub standards_control_arn: std::option::Option<std::string::String>,
    /// <p>The current status of the security standard control. Indicates whether the control is enabled or disabled. Security Hub does not check against disabled controls.</p>
    pub control_status: std::option::Option<crate::model::ControlStatus>,
    /// <p>The reason provided for the most recent change in status for the control.</p>
    pub disabled_reason: std::option::Option<std::string::String>,
    /// <p>The date and time that the status of the security standard control was most recently updated.</p>
    pub control_status_updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The identifier of the security standard control.</p>
    pub control_id: std::option::Option<std::string::String>,
    /// <p>The title of the security standard control.</p>
    pub title: std::option::Option<std::string::String>,
    /// <p>The longer description of the security standard control. Provides information about what the control is checking for.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>A link to remediation information for the control in the Security Hub user documentation.</p>
    pub remediation_url: std::option::Option<std::string::String>,
    /// <p>The severity of findings generated from this security standard control.</p>
    /// <p>The finding severity is based on an assessment of how easy it would be to compromise Amazon Web Services resources if the issue is detected.</p>
    pub severity_rating: std::option::Option<crate::model::SeverityRating>,
    /// <p>The list of requirements that are related to this control.</p>
    pub related_requirements: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl StandardsControl {
    /// <p>The ARN of the security standard control.</p>
    pub fn standards_control_arn(&self) -> std::option::Option<&str> {
        self.standards_control_arn.as_deref()
    }
    /// <p>The current status of the security standard control. Indicates whether the control is enabled or disabled. Security Hub does not check against disabled controls.</p>
    pub fn control_status(&self) -> std::option::Option<&crate::model::ControlStatus> {
        self.control_status.as_ref()
    }
    /// <p>The reason provided for the most recent change in status for the control.</p>
    pub fn disabled_reason(&self) -> std::option::Option<&str> {
        self.disabled_reason.as_deref()
    }
    /// <p>The date and time that the status of the security standard control was most recently updated.</p>
    pub fn control_status_updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.control_status_updated_at.as_ref()
    }
    /// <p>The identifier of the security standard control.</p>
    pub fn control_id(&self) -> std::option::Option<&str> {
        self.control_id.as_deref()
    }
    /// <p>The title of the security standard control.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>The longer description of the security standard control. Provides information about what the control is checking for.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>A link to remediation information for the control in the Security Hub user documentation.</p>
    pub fn remediation_url(&self) -> std::option::Option<&str> {
        self.remediation_url.as_deref()
    }
    /// <p>The severity of findings generated from this security standard control.</p>
    /// <p>The finding severity is based on an assessment of how easy it would be to compromise Amazon Web Services resources if the issue is detected.</p>
    pub fn severity_rating(&self) -> std::option::Option<&crate::model::SeverityRating> {
        self.severity_rating.as_ref()
    }
    /// <p>The list of requirements that are related to this control.</p>
    pub fn related_requirements(&self) -> std::option::Option<&[std::string::String]> {
        self.related_requirements.as_deref()
    }
}
impl std::fmt::Debug for StandardsControl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StandardsControl");
        formatter.field("standards_control_arn", &self.standards_control_arn);
        formatter.field("control_status", &self.control_status);
        formatter.field("disabled_reason", &self.disabled_reason);
        formatter.field("control_status_updated_at", &self.control_status_updated_at);
        formatter.field("control_id", &self.control_id);
        formatter.field("title", &self.title);
        formatter.field("description", &self.description);
        formatter.field("remediation_url", &self.remediation_url);
        formatter.field("severity_rating", &self.severity_rating);
        formatter.field("related_requirements", &self.related_requirements);
        formatter.finish()
    }
}
/// See [`StandardsControl`](crate::model::StandardsControl)
pub mod standards_control {

    /// A builder for [`StandardsControl`](crate::model::StandardsControl)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) standards_control_arn: std::option::Option<std::string::String>,
        pub(crate) control_status: std::option::Option<crate::model::ControlStatus>,
        pub(crate) disabled_reason: std::option::Option<std::string::String>,
        pub(crate) control_status_updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) control_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) remediation_url: std::option::Option<std::string::String>,
        pub(crate) severity_rating: std::option::Option<crate::model::SeverityRating>,
        pub(crate) related_requirements: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The ARN of the security standard control.</p>
        pub fn standards_control_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.standards_control_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the security standard control.</p>
        pub fn set_standards_control_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.standards_control_arn = input;
            self
        }
        /// <p>The current status of the security standard control. Indicates whether the control is enabled or disabled. Security Hub does not check against disabled controls.</p>
        pub fn control_status(mut self, input: crate::model::ControlStatus) -> Self {
            self.control_status = Some(input);
            self
        }
        /// <p>The current status of the security standard control. Indicates whether the control is enabled or disabled. Security Hub does not check against disabled controls.</p>
        pub fn set_control_status(
            mut self,
            input: std::option::Option<crate::model::ControlStatus>,
        ) -> Self {
            self.control_status = input;
            self
        }
        /// <p>The reason provided for the most recent change in status for the control.</p>
        pub fn disabled_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.disabled_reason = Some(input.into());
            self
        }
        /// <p>The reason provided for the most recent change in status for the control.</p>
        pub fn set_disabled_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.disabled_reason = input;
            self
        }
        /// <p>The date and time that the status of the security standard control was most recently updated.</p>
        pub fn control_status_updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.control_status_updated_at = Some(input);
            self
        }
        /// <p>The date and time that the status of the security standard control was most recently updated.</p>
        pub fn set_control_status_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.control_status_updated_at = input;
            self
        }
        /// <p>The identifier of the security standard control.</p>
        pub fn control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_id = Some(input.into());
            self
        }
        /// <p>The identifier of the security standard control.</p>
        pub fn set_control_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.control_id = input;
            self
        }
        /// <p>The title of the security standard control.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title of the security standard control.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The longer description of the security standard control. Provides information about what the control is checking for.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The longer description of the security standard control. Provides information about what the control is checking for.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>A link to remediation information for the control in the Security Hub user documentation.</p>
        pub fn remediation_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.remediation_url = Some(input.into());
            self
        }
        /// <p>A link to remediation information for the control in the Security Hub user documentation.</p>
        pub fn set_remediation_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.remediation_url = input;
            self
        }
        /// <p>The severity of findings generated from this security standard control.</p>
        /// <p>The finding severity is based on an assessment of how easy it would be to compromise Amazon Web Services resources if the issue is detected.</p>
        pub fn severity_rating(mut self, input: crate::model::SeverityRating) -> Self {
            self.severity_rating = Some(input);
            self
        }
        /// <p>The severity of findings generated from this security standard control.</p>
        /// <p>The finding severity is based on an assessment of how easy it would be to compromise Amazon Web Services resources if the issue is detected.</p>
        pub fn set_severity_rating(
            mut self,
            input: std::option::Option<crate::model::SeverityRating>,
        ) -> Self {
            self.severity_rating = input;
            self
        }
        /// Appends an item to `related_requirements`.
        ///
        /// To override the contents of this collection use [`set_related_requirements`](Self::set_related_requirements).
        ///
        /// <p>The list of requirements that are related to this control.</p>
        pub fn related_requirements(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.related_requirements.unwrap_or_default();
            v.push(input.into());
            self.related_requirements = Some(v);
            self
        }
        /// <p>The list of requirements that are related to this control.</p>
        pub fn set_related_requirements(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.related_requirements = input;
            self
        }
        /// Consumes the builder and constructs a [`StandardsControl`](crate::model::StandardsControl)
        pub fn build(self) -> crate::model::StandardsControl {
            crate::model::StandardsControl {
                standards_control_arn: self.standards_control_arn,
                control_status: self.control_status,
                disabled_reason: self.disabled_reason,
                control_status_updated_at: self.control_status_updated_at,
                control_id: self.control_id,
                title: self.title,
                description: self.description,
                remediation_url: self.remediation_url,
                severity_rating: self.severity_rating,
                related_requirements: self.related_requirements,
            }
        }
    }
}
impl StandardsControl {
    /// Creates a new builder-style object to manufacture [`StandardsControl`](crate::model::StandardsControl)
    pub fn builder() -> crate::model::standards_control::Builder {
        crate::model::standards_control::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SeverityRating {
    #[allow(missing_docs)] // documentation missing in model
    Critical,
    #[allow(missing_docs)] // documentation missing in model
    High,
    #[allow(missing_docs)] // documentation missing in model
    Low,
    #[allow(missing_docs)] // documentation missing in model
    Medium,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SeverityRating {
    fn from(s: &str) -> Self {
        match s {
            "CRITICAL" => SeverityRating::Critical,
            "HIGH" => SeverityRating::High,
            "LOW" => SeverityRating::Low,
            "MEDIUM" => SeverityRating::Medium,
            other => SeverityRating::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SeverityRating {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SeverityRating::from(s))
    }
}
impl SeverityRating {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SeverityRating::Critical => "CRITICAL",
            SeverityRating::High => "HIGH",
            SeverityRating::Low => "LOW",
            SeverityRating::Medium => "MEDIUM",
            SeverityRating::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CRITICAL", "HIGH", "LOW", "MEDIUM"]
    }
}
impl AsRef<str> for SeverityRating {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information about a specific standard.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Standard {
    /// <p>The ARN of a standard.</p>
    pub standards_arn: std::option::Option<std::string::String>,
    /// <p>The name of the standard.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A description of the standard.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Whether the standard is enabled by default. When Security Hub is enabled from the console, if a standard is enabled by default, the check box for that standard is selected by default.</p>
    /// <p>When Security Hub is enabled using the <code>EnableSecurityHub</code> API operation, the standard is enabled by default unless <code>EnableDefaultStandards</code> is set to <code>false</code>.</p>
    pub enabled_by_default: bool,
}
impl Standard {
    /// <p>The ARN of a standard.</p>
    pub fn standards_arn(&self) -> std::option::Option<&str> {
        self.standards_arn.as_deref()
    }
    /// <p>The name of the standard.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A description of the standard.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Whether the standard is enabled by default. When Security Hub is enabled from the console, if a standard is enabled by default, the check box for that standard is selected by default.</p>
    /// <p>When Security Hub is enabled using the <code>EnableSecurityHub</code> API operation, the standard is enabled by default unless <code>EnableDefaultStandards</code> is set to <code>false</code>.</p>
    pub fn enabled_by_default(&self) -> bool {
        self.enabled_by_default
    }
}
impl std::fmt::Debug for Standard {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Standard");
        formatter.field("standards_arn", &self.standards_arn);
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("enabled_by_default", &self.enabled_by_default);
        formatter.finish()
    }
}
/// See [`Standard`](crate::model::Standard)
pub mod standard {

    /// A builder for [`Standard`](crate::model::Standard)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) standards_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) enabled_by_default: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The ARN of a standard.</p>
        pub fn standards_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.standards_arn = Some(input.into());
            self
        }
        /// <p>The ARN of a standard.</p>
        pub fn set_standards_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.standards_arn = input;
            self
        }
        /// <p>The name of the standard.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the standard.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A description of the standard.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the standard.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Whether the standard is enabled by default. When Security Hub is enabled from the console, if a standard is enabled by default, the check box for that standard is selected by default.</p>
        /// <p>When Security Hub is enabled using the <code>EnableSecurityHub</code> API operation, the standard is enabled by default unless <code>EnableDefaultStandards</code> is set to <code>false</code>.</p>
        pub fn enabled_by_default(mut self, input: bool) -> Self {
            self.enabled_by_default = Some(input);
            self
        }
        /// <p>Whether the standard is enabled by default. When Security Hub is enabled from the console, if a standard is enabled by default, the check box for that standard is selected by default.</p>
        /// <p>When Security Hub is enabled using the <code>EnableSecurityHub</code> API operation, the standard is enabled by default unless <code>EnableDefaultStandards</code> is set to <code>false</code>.</p>
        pub fn set_enabled_by_default(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled_by_default = input;
            self
        }
        /// Consumes the builder and constructs a [`Standard`](crate::model::Standard)
        pub fn build(self) -> crate::model::Standard {
            crate::model::Standard {
                standards_arn: self.standards_arn,
                name: self.name,
                description: self.description,
                enabled_by_default: self.enabled_by_default.unwrap_or_default(),
            }
        }
    }
}
impl Standard {
    /// Creates a new builder-style object to manufacture [`Standard`](crate::model::Standard)
    pub fn builder() -> crate::model::standard::Builder {
        crate::model::standard::Builder::default()
    }
}

/// <p>Contains details about a product.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Product {
    /// <p>The ARN assigned to the product.</p>
    pub product_arn: std::option::Option<std::string::String>,
    /// <p>The name of the product.</p>
    pub product_name: std::option::Option<std::string::String>,
    /// <p>The name of the company that provides the product.</p>
    pub company_name: std::option::Option<std::string::String>,
    /// <p>A description of the product.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The categories assigned to the product.</p>
    pub categories: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The types of integration that the product supports. Available values are the following.</p>
    /// <ul>
    /// <li> <p> <code>SEND_FINDINGS_TO_SECURITY_HUB</code> - The integration sends findings to Security Hub.</p> </li>
    /// <li> <p> <code>RECEIVE_FINDINGS_FROM_SECURITY_HUB</code> - The integration receives findings from Security Hub.</p> </li>
    /// <li> <p> <code>UPDATE_FINDINGS_IN_SECURITY_HUB</code> - The integration does not send new findings to Security Hub, but does make updates to the findings that it receives from Security Hub.</p> </li>
    /// </ul>
    pub integration_types: std::option::Option<std::vec::Vec<crate::model::IntegrationType>>,
    /// <p>For integrations with Amazon Web Services services, the Amazon Web Services Console URL from which to activate the service.</p>
    /// <p>For integrations with third-party products, the Amazon Web Services Marketplace URL from which to subscribe to or purchase the product.</p>
    pub marketplace_url: std::option::Option<std::string::String>,
    /// <p>The URL to the service or product documentation about the integration with Security Hub, including how to activate the integration.</p>
    pub activation_url: std::option::Option<std::string::String>,
    /// <p>The resource policy associated with the product.</p>
    pub product_subscription_resource_policy: std::option::Option<std::string::String>,
}
impl Product {
    /// <p>The ARN assigned to the product.</p>
    pub fn product_arn(&self) -> std::option::Option<&str> {
        self.product_arn.as_deref()
    }
    /// <p>The name of the product.</p>
    pub fn product_name(&self) -> std::option::Option<&str> {
        self.product_name.as_deref()
    }
    /// <p>The name of the company that provides the product.</p>
    pub fn company_name(&self) -> std::option::Option<&str> {
        self.company_name.as_deref()
    }
    /// <p>A description of the product.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The categories assigned to the product.</p>
    pub fn categories(&self) -> std::option::Option<&[std::string::String]> {
        self.categories.as_deref()
    }
    /// <p>The types of integration that the product supports. Available values are the following.</p>
    /// <ul>
    /// <li> <p> <code>SEND_FINDINGS_TO_SECURITY_HUB</code> - The integration sends findings to Security Hub.</p> </li>
    /// <li> <p> <code>RECEIVE_FINDINGS_FROM_SECURITY_HUB</code> - The integration receives findings from Security Hub.</p> </li>
    /// <li> <p> <code>UPDATE_FINDINGS_IN_SECURITY_HUB</code> - The integration does not send new findings to Security Hub, but does make updates to the findings that it receives from Security Hub.</p> </li>
    /// </ul>
    pub fn integration_types(&self) -> std::option::Option<&[crate::model::IntegrationType]> {
        self.integration_types.as_deref()
    }
    /// <p>For integrations with Amazon Web Services services, the Amazon Web Services Console URL from which to activate the service.</p>
    /// <p>For integrations with third-party products, the Amazon Web Services Marketplace URL from which to subscribe to or purchase the product.</p>
    pub fn marketplace_url(&self) -> std::option::Option<&str> {
        self.marketplace_url.as_deref()
    }
    /// <p>The URL to the service or product documentation about the integration with Security Hub, including how to activate the integration.</p>
    pub fn activation_url(&self) -> std::option::Option<&str> {
        self.activation_url.as_deref()
    }
    /// <p>The resource policy associated with the product.</p>
    pub fn product_subscription_resource_policy(&self) -> std::option::Option<&str> {
        self.product_subscription_resource_policy.as_deref()
    }
}
impl std::fmt::Debug for Product {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Product");
        formatter.field("product_arn", &self.product_arn);
        formatter.field("product_name", &self.product_name);
        formatter.field("company_name", &self.company_name);
        formatter.field("description", &self.description);
        formatter.field("categories", &self.categories);
        formatter.field("integration_types", &self.integration_types);
        formatter.field("marketplace_url", &self.marketplace_url);
        formatter.field("activation_url", &self.activation_url);
        formatter.field(
            "product_subscription_resource_policy",
            &self.product_subscription_resource_policy,
        );
        formatter.finish()
    }
}
/// See [`Product`](crate::model::Product)
pub mod product {

    /// A builder for [`Product`](crate::model::Product)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) product_arn: std::option::Option<std::string::String>,
        pub(crate) product_name: std::option::Option<std::string::String>,
        pub(crate) company_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) categories: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) integration_types:
            std::option::Option<std::vec::Vec<crate::model::IntegrationType>>,
        pub(crate) marketplace_url: std::option::Option<std::string::String>,
        pub(crate) activation_url: std::option::Option<std::string::String>,
        pub(crate) product_subscription_resource_policy: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN assigned to the product.</p>
        pub fn product_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.product_arn = Some(input.into());
            self
        }
        /// <p>The ARN assigned to the product.</p>
        pub fn set_product_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product_arn = input;
            self
        }
        /// <p>The name of the product.</p>
        pub fn product_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.product_name = Some(input.into());
            self
        }
        /// <p>The name of the product.</p>
        pub fn set_product_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product_name = input;
            self
        }
        /// <p>The name of the company that provides the product.</p>
        pub fn company_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.company_name = Some(input.into());
            self
        }
        /// <p>The name of the company that provides the product.</p>
        pub fn set_company_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.company_name = input;
            self
        }
        /// <p>A description of the product.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the product.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `categories`.
        ///
        /// To override the contents of this collection use [`set_categories`](Self::set_categories).
        ///
        /// <p>The categories assigned to the product.</p>
        pub fn categories(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.categories.unwrap_or_default();
            v.push(input.into());
            self.categories = Some(v);
            self
        }
        /// <p>The categories assigned to the product.</p>
        pub fn set_categories(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.categories = input;
            self
        }
        /// Appends an item to `integration_types`.
        ///
        /// To override the contents of this collection use [`set_integration_types`](Self::set_integration_types).
        ///
        /// <p>The types of integration that the product supports. Available values are the following.</p>
        /// <ul>
        /// <li> <p> <code>SEND_FINDINGS_TO_SECURITY_HUB</code> - The integration sends findings to Security Hub.</p> </li>
        /// <li> <p> <code>RECEIVE_FINDINGS_FROM_SECURITY_HUB</code> - The integration receives findings from Security Hub.</p> </li>
        /// <li> <p> <code>UPDATE_FINDINGS_IN_SECURITY_HUB</code> - The integration does not send new findings to Security Hub, but does make updates to the findings that it receives from Security Hub.</p> </li>
        /// </ul>
        pub fn integration_types(mut self, input: crate::model::IntegrationType) -> Self {
            let mut v = self.integration_types.unwrap_or_default();
            v.push(input);
            self.integration_types = Some(v);
            self
        }
        /// <p>The types of integration that the product supports. Available values are the following.</p>
        /// <ul>
        /// <li> <p> <code>SEND_FINDINGS_TO_SECURITY_HUB</code> - The integration sends findings to Security Hub.</p> </li>
        /// <li> <p> <code>RECEIVE_FINDINGS_FROM_SECURITY_HUB</code> - The integration receives findings from Security Hub.</p> </li>
        /// <li> <p> <code>UPDATE_FINDINGS_IN_SECURITY_HUB</code> - The integration does not send new findings to Security Hub, but does make updates to the findings that it receives from Security Hub.</p> </li>
        /// </ul>
        pub fn set_integration_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IntegrationType>>,
        ) -> Self {
            self.integration_types = input;
            self
        }
        /// <p>For integrations with Amazon Web Services services, the Amazon Web Services Console URL from which to activate the service.</p>
        /// <p>For integrations with third-party products, the Amazon Web Services Marketplace URL from which to subscribe to or purchase the product.</p>
        pub fn marketplace_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.marketplace_url = Some(input.into());
            self
        }
        /// <p>For integrations with Amazon Web Services services, the Amazon Web Services Console URL from which to activate the service.</p>
        /// <p>For integrations with third-party products, the Amazon Web Services Marketplace URL from which to subscribe to or purchase the product.</p>
        pub fn set_marketplace_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.marketplace_url = input;
            self
        }
        /// <p>The URL to the service or product documentation about the integration with Security Hub, including how to activate the integration.</p>
        pub fn activation_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.activation_url = Some(input.into());
            self
        }
        /// <p>The URL to the service or product documentation about the integration with Security Hub, including how to activate the integration.</p>
        pub fn set_activation_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.activation_url = input;
            self
        }
        /// <p>The resource policy associated with the product.</p>
        pub fn product_subscription_resource_policy(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.product_subscription_resource_policy = Some(input.into());
            self
        }
        /// <p>The resource policy associated with the product.</p>
        pub fn set_product_subscription_resource_policy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.product_subscription_resource_policy = input;
            self
        }
        /// Consumes the builder and constructs a [`Product`](crate::model::Product)
        pub fn build(self) -> crate::model::Product {
            crate::model::Product {
                product_arn: self.product_arn,
                product_name: self.product_name,
                company_name: self.company_name,
                description: self.description,
                categories: self.categories,
                integration_types: self.integration_types,
                marketplace_url: self.marketplace_url,
                activation_url: self.activation_url,
                product_subscription_resource_policy: self.product_subscription_resource_policy,
            }
        }
    }
}
impl Product {
    /// Creates a new builder-style object to manufacture [`Product`](crate::model::Product)
    pub fn builder() -> crate::model::product::Builder {
        crate::model::product::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum IntegrationType {
    #[allow(missing_docs)] // documentation missing in model
    ReceiveFindingsFromSecurityHub,
    #[allow(missing_docs)] // documentation missing in model
    SendFindingsToSecurityHub,
    #[allow(missing_docs)] // documentation missing in model
    UpdateFindingsInSecurityHub,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for IntegrationType {
    fn from(s: &str) -> Self {
        match s {
            "RECEIVE_FINDINGS_FROM_SECURITY_HUB" => IntegrationType::ReceiveFindingsFromSecurityHub,
            "SEND_FINDINGS_TO_SECURITY_HUB" => IntegrationType::SendFindingsToSecurityHub,
            "UPDATE_FINDINGS_IN_SECURITY_HUB" => IntegrationType::UpdateFindingsInSecurityHub,
            other => IntegrationType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for IntegrationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(IntegrationType::from(s))
    }
}
impl IntegrationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            IntegrationType::ReceiveFindingsFromSecurityHub => "RECEIVE_FINDINGS_FROM_SECURITY_HUB",
            IntegrationType::SendFindingsToSecurityHub => "SEND_FINDINGS_TO_SECURITY_HUB",
            IntegrationType::UpdateFindingsInSecurityHub => "UPDATE_FINDINGS_IN_SECURITY_HUB",
            IntegrationType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "RECEIVE_FINDINGS_FROM_SECURITY_HUB",
            "SEND_FINDINGS_TO_SECURITY_HUB",
            "UPDATE_FINDINGS_IN_SECURITY_HUB",
        ]
    }
}
impl AsRef<str> for IntegrationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An <code>ActionTarget</code> object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ActionTarget {
    /// <p>The ARN for the target action.</p>
    pub action_target_arn: std::option::Option<std::string::String>,
    /// <p>The name of the action target.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the target action.</p>
    pub description: std::option::Option<std::string::String>,
}
impl ActionTarget {
    /// <p>The ARN for the target action.</p>
    pub fn action_target_arn(&self) -> std::option::Option<&str> {
        self.action_target_arn.as_deref()
    }
    /// <p>The name of the action target.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the target action.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
impl std::fmt::Debug for ActionTarget {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ActionTarget");
        formatter.field("action_target_arn", &self.action_target_arn);
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.finish()
    }
}
/// See [`ActionTarget`](crate::model::ActionTarget)
pub mod action_target {

    /// A builder for [`ActionTarget`](crate::model::ActionTarget)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action_target_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN for the target action.</p>
        pub fn action_target_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_target_arn = Some(input.into());
            self
        }
        /// <p>The ARN for the target action.</p>
        pub fn set_action_target_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.action_target_arn = input;
            self
        }
        /// <p>The name of the action target.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the action target.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the target action.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the target action.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`ActionTarget`](crate::model::ActionTarget)
        pub fn build(self) -> crate::model::ActionTarget {
            crate::model::ActionTarget {
                action_target_arn: self.action_target_arn,
                name: self.name,
                description: self.description,
            }
        }
    }
}
impl ActionTarget {
    /// Creates a new builder-style object to manufacture [`ActionTarget`](crate::model::ActionTarget)
    pub fn builder() -> crate::model::action_target::Builder {
        crate::model::action_target::Builder::default()
    }
}

/// <p>The details of an Amazon Web Services account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccountDetails {
    /// <p>The ID of an Amazon Web Services account.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The email of an Amazon Web Services account.</p>
    pub email: std::option::Option<std::string::String>,
}
impl AccountDetails {
    /// <p>The ID of an Amazon Web Services account.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The email of an Amazon Web Services account.</p>
    pub fn email(&self) -> std::option::Option<&str> {
        self.email.as_deref()
    }
}
impl std::fmt::Debug for AccountDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccountDetails");
        formatter.field("account_id", &self.account_id);
        formatter.field("email", &self.email);
        formatter.finish()
    }
}
/// See [`AccountDetails`](crate::model::AccountDetails)
pub mod account_details {

    /// A builder for [`AccountDetails`](crate::model::AccountDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) email: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of an Amazon Web Services account.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The ID of an Amazon Web Services account.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The email of an Amazon Web Services account.</p>
        pub fn email(mut self, input: impl Into<std::string::String>) -> Self {
            self.email = Some(input.into());
            self
        }
        /// <p>The email of an Amazon Web Services account.</p>
        pub fn set_email(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.email = input;
            self
        }
        /// Consumes the builder and constructs a [`AccountDetails`](crate::model::AccountDetails)
        pub fn build(self) -> crate::model::AccountDetails {
            crate::model::AccountDetails {
                account_id: self.account_id,
                email: self.email,
            }
        }
    }
}
impl AccountDetails {
    /// Creates a new builder-style object to manufacture [`AccountDetails`](crate::model::AccountDetails)
    pub fn builder() -> crate::model::account_details::Builder {
        crate::model::account_details::Builder::default()
    }
}

/// <p>A finding from a <code>BatchUpdateFindings</code> request that Security Hub was unable to update.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchUpdateFindingsUnprocessedFinding {
    /// <p>The identifier of the finding that was not updated.</p>
    pub finding_identifier: std::option::Option<crate::model::AwsSecurityFindingIdentifier>,
    /// <p>The code associated with the error.</p>
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The message associated with the error.</p>
    pub error_message: std::option::Option<std::string::String>,
}
impl BatchUpdateFindingsUnprocessedFinding {
    /// <p>The identifier of the finding that was not updated.</p>
    pub fn finding_identifier(
        &self,
    ) -> std::option::Option<&crate::model::AwsSecurityFindingIdentifier> {
        self.finding_identifier.as_ref()
    }
    /// <p>The code associated with the error.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>The message associated with the error.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
impl std::fmt::Debug for BatchUpdateFindingsUnprocessedFinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchUpdateFindingsUnprocessedFinding");
        formatter.field("finding_identifier", &self.finding_identifier);
        formatter.field("error_code", &self.error_code);
        formatter.field("error_message", &self.error_message);
        formatter.finish()
    }
}
/// See [`BatchUpdateFindingsUnprocessedFinding`](crate::model::BatchUpdateFindingsUnprocessedFinding)
pub mod batch_update_findings_unprocessed_finding {

    /// A builder for [`BatchUpdateFindingsUnprocessedFinding`](crate::model::BatchUpdateFindingsUnprocessedFinding)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) finding_identifier:
            std::option::Option<crate::model::AwsSecurityFindingIdentifier>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the finding that was not updated.</p>
        pub fn finding_identifier(
            mut self,
            input: crate::model::AwsSecurityFindingIdentifier,
        ) -> Self {
            self.finding_identifier = Some(input);
            self
        }
        /// <p>The identifier of the finding that was not updated.</p>
        pub fn set_finding_identifier(
            mut self,
            input: std::option::Option<crate::model::AwsSecurityFindingIdentifier>,
        ) -> Self {
            self.finding_identifier = input;
            self
        }
        /// <p>The code associated with the error.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The code associated with the error.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The message associated with the error.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The message associated with the error.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchUpdateFindingsUnprocessedFinding`](crate::model::BatchUpdateFindingsUnprocessedFinding)
        pub fn build(self) -> crate::model::BatchUpdateFindingsUnprocessedFinding {
            crate::model::BatchUpdateFindingsUnprocessedFinding {
                finding_identifier: self.finding_identifier,
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
}
impl BatchUpdateFindingsUnprocessedFinding {
    /// Creates a new builder-style object to manufacture [`BatchUpdateFindingsUnprocessedFinding`](crate::model::BatchUpdateFindingsUnprocessedFinding)
    pub fn builder() -> crate::model::batch_update_findings_unprocessed_finding::Builder {
        crate::model::batch_update_findings_unprocessed_finding::Builder::default()
    }
}

/// <p>Identifies a finding to update using <code>BatchUpdateFindings</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsSecurityFindingIdentifier {
    /// <p>The identifier of the finding that was specified by the finding provider.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The ARN generated by Security Hub that uniquely identifies a product that generates findings. This can be the ARN for a third-party product that is integrated with Security Hub, or the ARN for a custom integration.</p>
    pub product_arn: std::option::Option<std::string::String>,
}
impl AwsSecurityFindingIdentifier {
    /// <p>The identifier of the finding that was specified by the finding provider.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The ARN generated by Security Hub that uniquely identifies a product that generates findings. This can be the ARN for a third-party product that is integrated with Security Hub, or the ARN for a custom integration.</p>
    pub fn product_arn(&self) -> std::option::Option<&str> {
        self.product_arn.as_deref()
    }
}
impl std::fmt::Debug for AwsSecurityFindingIdentifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsSecurityFindingIdentifier");
        formatter.field("id", &self.id);
        formatter.field("product_arn", &self.product_arn);
        formatter.finish()
    }
}
/// See [`AwsSecurityFindingIdentifier`](crate::model::AwsSecurityFindingIdentifier)
pub mod aws_security_finding_identifier {

    /// A builder for [`AwsSecurityFindingIdentifier`](crate::model::AwsSecurityFindingIdentifier)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) product_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the finding that was specified by the finding provider.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the finding that was specified by the finding provider.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The ARN generated by Security Hub that uniquely identifies a product that generates findings. This can be the ARN for a third-party product that is integrated with Security Hub, or the ARN for a custom integration.</p>
        pub fn product_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.product_arn = Some(input.into());
            self
        }
        /// <p>The ARN generated by Security Hub that uniquely identifies a product that generates findings. This can be the ARN for a third-party product that is integrated with Security Hub, or the ARN for a custom integration.</p>
        pub fn set_product_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsSecurityFindingIdentifier`](crate::model::AwsSecurityFindingIdentifier)
        pub fn build(self) -> crate::model::AwsSecurityFindingIdentifier {
            crate::model::AwsSecurityFindingIdentifier {
                id: self.id,
                product_arn: self.product_arn,
            }
        }
    }
}
impl AwsSecurityFindingIdentifier {
    /// Creates a new builder-style object to manufacture [`AwsSecurityFindingIdentifier`](crate::model::AwsSecurityFindingIdentifier)
    pub fn builder() -> crate::model::aws_security_finding_identifier::Builder {
        crate::model::aws_security_finding_identifier::Builder::default()
    }
}

/// <p>Used to update information about the investigation into the finding.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WorkflowUpdate {
    /// <p>The status of the investigation into the finding. The workflow status is specific to an individual finding. It does not affect the generation of new findings. For example, setting the workflow status to <code>SUPPRESSED</code> or <code>RESOLVED</code> does not prevent a new finding for the same issue.</p>
    /// <p>The allowed values are the following.</p>
    /// <ul>
    /// <li> <p> <code>NEW</code> - The initial state of a finding, before it is reviewed.</p> <p>Security Hub also resets <code>WorkFlowStatus</code> from <code>NOTIFIED</code> or <code>RESOLVED</code> to <code>NEW</code> in the following cases:</p>
    /// <ul>
    /// <li> <p>The record state changes from <code>ARCHIVED</code> to <code>ACTIVE</code>.</p> </li>
    /// <li> <p>The compliance status changes from <code>PASSED</code> to either <code>WARNING</code>, <code>FAILED</code>, or <code>NOT_AVAILABLE</code>.</p> </li>
    /// </ul> </li>
    /// <li> <p> <code>NOTIFIED</code> - Indicates that you notified the resource owner about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner.</p> </li>
    /// <li> <p> <code>RESOLVED</code> - The finding was reviewed and remediated and is now considered resolved.</p> </li>
    /// <li> <p> <code>SUPPRESSED</code> - Indicates that you reviewed the finding and do not believe that any action is needed. The finding is no longer updated.</p> </li>
    /// </ul>
    pub status: std::option::Option<crate::model::WorkflowStatus>,
}
impl WorkflowUpdate {
    /// <p>The status of the investigation into the finding. The workflow status is specific to an individual finding. It does not affect the generation of new findings. For example, setting the workflow status to <code>SUPPRESSED</code> or <code>RESOLVED</code> does not prevent a new finding for the same issue.</p>
    /// <p>The allowed values are the following.</p>
    /// <ul>
    /// <li> <p> <code>NEW</code> - The initial state of a finding, before it is reviewed.</p> <p>Security Hub also resets <code>WorkFlowStatus</code> from <code>NOTIFIED</code> or <code>RESOLVED</code> to <code>NEW</code> in the following cases:</p>
    /// <ul>
    /// <li> <p>The record state changes from <code>ARCHIVED</code> to <code>ACTIVE</code>.</p> </li>
    /// <li> <p>The compliance status changes from <code>PASSED</code> to either <code>WARNING</code>, <code>FAILED</code>, or <code>NOT_AVAILABLE</code>.</p> </li>
    /// </ul> </li>
    /// <li> <p> <code>NOTIFIED</code> - Indicates that you notified the resource owner about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner.</p> </li>
    /// <li> <p> <code>RESOLVED</code> - The finding was reviewed and remediated and is now considered resolved.</p> </li>
    /// <li> <p> <code>SUPPRESSED</code> - Indicates that you reviewed the finding and do not believe that any action is needed. The finding is no longer updated.</p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::WorkflowStatus> {
        self.status.as_ref()
    }
}
impl std::fmt::Debug for WorkflowUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WorkflowUpdate");
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`WorkflowUpdate`](crate::model::WorkflowUpdate)
pub mod workflow_update {

    /// A builder for [`WorkflowUpdate`](crate::model::WorkflowUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::WorkflowStatus>,
    }
    impl Builder {
        /// <p>The status of the investigation into the finding. The workflow status is specific to an individual finding. It does not affect the generation of new findings. For example, setting the workflow status to <code>SUPPRESSED</code> or <code>RESOLVED</code> does not prevent a new finding for the same issue.</p>
        /// <p>The allowed values are the following.</p>
        /// <ul>
        /// <li> <p> <code>NEW</code> - The initial state of a finding, before it is reviewed.</p> <p>Security Hub also resets <code>WorkFlowStatus</code> from <code>NOTIFIED</code> or <code>RESOLVED</code> to <code>NEW</code> in the following cases:</p>
        /// <ul>
        /// <li> <p>The record state changes from <code>ARCHIVED</code> to <code>ACTIVE</code>.</p> </li>
        /// <li> <p>The compliance status changes from <code>PASSED</code> to either <code>WARNING</code>, <code>FAILED</code>, or <code>NOT_AVAILABLE</code>.</p> </li>
        /// </ul> </li>
        /// <li> <p> <code>NOTIFIED</code> - Indicates that you notified the resource owner about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner.</p> </li>
        /// <li> <p> <code>RESOLVED</code> - The finding was reviewed and remediated and is now considered resolved.</p> </li>
        /// <li> <p> <code>SUPPRESSED</code> - Indicates that you reviewed the finding and do not believe that any action is needed. The finding is no longer updated.</p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::WorkflowStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the investigation into the finding. The workflow status is specific to an individual finding. It does not affect the generation of new findings. For example, setting the workflow status to <code>SUPPRESSED</code> or <code>RESOLVED</code> does not prevent a new finding for the same issue.</p>
        /// <p>The allowed values are the following.</p>
        /// <ul>
        /// <li> <p> <code>NEW</code> - The initial state of a finding, before it is reviewed.</p> <p>Security Hub also resets <code>WorkFlowStatus</code> from <code>NOTIFIED</code> or <code>RESOLVED</code> to <code>NEW</code> in the following cases:</p>
        /// <ul>
        /// <li> <p>The record state changes from <code>ARCHIVED</code> to <code>ACTIVE</code>.</p> </li>
        /// <li> <p>The compliance status changes from <code>PASSED</code> to either <code>WARNING</code>, <code>FAILED</code>, or <code>NOT_AVAILABLE</code>.</p> </li>
        /// </ul> </li>
        /// <li> <p> <code>NOTIFIED</code> - Indicates that you notified the resource owner about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner.</p> </li>
        /// <li> <p> <code>RESOLVED</code> - The finding was reviewed and remediated and is now considered resolved.</p> </li>
        /// <li> <p> <code>SUPPRESSED</code> - Indicates that you reviewed the finding and do not believe that any action is needed. The finding is no longer updated.</p> </li>
        /// </ul>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::WorkflowStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkflowUpdate`](crate::model::WorkflowUpdate)
        pub fn build(self) -> crate::model::WorkflowUpdate {
            crate::model::WorkflowUpdate {
                status: self.status,
            }
        }
    }
}
impl WorkflowUpdate {
    /// Creates a new builder-style object to manufacture [`WorkflowUpdate`](crate::model::WorkflowUpdate)
    pub fn builder() -> crate::model::workflow_update::Builder {
        crate::model::workflow_update::Builder::default()
    }
}

/// <p>Updates to the severity information for a finding.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SeverityUpdate {
    /// <p>The normalized severity for the finding. This attribute is to be deprecated in favor of <code>Label</code>.</p>
    /// <p>If you provide <code>Normalized</code> and do not provide <code>Label</code>, <code>Label</code> is set automatically as follows.</p>
    /// <ul>
    /// <li> <p>0 - <code>INFORMATIONAL</code> </p> </li>
    /// <li> <p>139 - <code>LOW</code> </p> </li>
    /// <li> <p>4069 - <code>MEDIUM</code> </p> </li>
    /// <li> <p>7089 - <code>HIGH</code> </p> </li>
    /// <li> <p>90100 - <code>CRITICAL</code> </p> </li>
    /// </ul>
    pub normalized: i32,
    /// <p>The native severity as defined by the Amazon Web Services service or integrated partner product that generated the finding.</p>
    pub product: f64,
    /// <p>The severity value of the finding. The allowed values are the following.</p>
    /// <ul>
    /// <li> <p> <code>INFORMATIONAL</code> - No issue was found.</p> </li>
    /// <li> <p> <code>LOW</code> - The issue does not require action on its own.</p> </li>
    /// <li> <p> <code>MEDIUM</code> - The issue must be addressed but not urgently.</p> </li>
    /// <li> <p> <code>HIGH</code> - The issue must be addressed as a priority.</p> </li>
    /// <li> <p> <code>CRITICAL</code> - The issue must be remediated immediately to avoid it escalating.</p> </li>
    /// </ul>
    pub label: std::option::Option<crate::model::SeverityLabel>,
}
impl SeverityUpdate {
    /// <p>The normalized severity for the finding. This attribute is to be deprecated in favor of <code>Label</code>.</p>
    /// <p>If you provide <code>Normalized</code> and do not provide <code>Label</code>, <code>Label</code> is set automatically as follows.</p>
    /// <ul>
    /// <li> <p>0 - <code>INFORMATIONAL</code> </p> </li>
    /// <li> <p>139 - <code>LOW</code> </p> </li>
    /// <li> <p>4069 - <code>MEDIUM</code> </p> </li>
    /// <li> <p>7089 - <code>HIGH</code> </p> </li>
    /// <li> <p>90100 - <code>CRITICAL</code> </p> </li>
    /// </ul>
    pub fn normalized(&self) -> i32 {
        self.normalized
    }
    /// <p>The native severity as defined by the Amazon Web Services service or integrated partner product that generated the finding.</p>
    pub fn product(&self) -> f64 {
        self.product
    }
    /// <p>The severity value of the finding. The allowed values are the following.</p>
    /// <ul>
    /// <li> <p> <code>INFORMATIONAL</code> - No issue was found.</p> </li>
    /// <li> <p> <code>LOW</code> - The issue does not require action on its own.</p> </li>
    /// <li> <p> <code>MEDIUM</code> - The issue must be addressed but not urgently.</p> </li>
    /// <li> <p> <code>HIGH</code> - The issue must be addressed as a priority.</p> </li>
    /// <li> <p> <code>CRITICAL</code> - The issue must be remediated immediately to avoid it escalating.</p> </li>
    /// </ul>
    pub fn label(&self) -> std::option::Option<&crate::model::SeverityLabel> {
        self.label.as_ref()
    }
}
impl std::fmt::Debug for SeverityUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SeverityUpdate");
        formatter.field("normalized", &self.normalized);
        formatter.field("product", &self.product);
        formatter.field("label", &self.label);
        formatter.finish()
    }
}
/// See [`SeverityUpdate`](crate::model::SeverityUpdate)
pub mod severity_update {

    /// A builder for [`SeverityUpdate`](crate::model::SeverityUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) normalized: std::option::Option<i32>,
        pub(crate) product: std::option::Option<f64>,
        pub(crate) label: std::option::Option<crate::model::SeverityLabel>,
    }
    impl Builder {
        /// <p>The normalized severity for the finding. This attribute is to be deprecated in favor of <code>Label</code>.</p>
        /// <p>If you provide <code>Normalized</code> and do not provide <code>Label</code>, <code>Label</code> is set automatically as follows.</p>
        /// <ul>
        /// <li> <p>0 - <code>INFORMATIONAL</code> </p> </li>
        /// <li> <p>139 - <code>LOW</code> </p> </li>
        /// <li> <p>4069 - <code>MEDIUM</code> </p> </li>
        /// <li> <p>7089 - <code>HIGH</code> </p> </li>
        /// <li> <p>90100 - <code>CRITICAL</code> </p> </li>
        /// </ul>
        pub fn normalized(mut self, input: i32) -> Self {
            self.normalized = Some(input);
            self
        }
        /// <p>The normalized severity for the finding. This attribute is to be deprecated in favor of <code>Label</code>.</p>
        /// <p>If you provide <code>Normalized</code> and do not provide <code>Label</code>, <code>Label</code> is set automatically as follows.</p>
        /// <ul>
        /// <li> <p>0 - <code>INFORMATIONAL</code> </p> </li>
        /// <li> <p>139 - <code>LOW</code> </p> </li>
        /// <li> <p>4069 - <code>MEDIUM</code> </p> </li>
        /// <li> <p>7089 - <code>HIGH</code> </p> </li>
        /// <li> <p>90100 - <code>CRITICAL</code> </p> </li>
        /// </ul>
        pub fn set_normalized(mut self, input: std::option::Option<i32>) -> Self {
            self.normalized = input;
            self
        }
        /// <p>The native severity as defined by the Amazon Web Services service or integrated partner product that generated the finding.</p>
        pub fn product(mut self, input: f64) -> Self {
            self.product = Some(input);
            self
        }
        /// <p>The native severity as defined by the Amazon Web Services service or integrated partner product that generated the finding.</p>
        pub fn set_product(mut self, input: std::option::Option<f64>) -> Self {
            self.product = input;
            self
        }
        /// <p>The severity value of the finding. The allowed values are the following.</p>
        /// <ul>
        /// <li> <p> <code>INFORMATIONAL</code> - No issue was found.</p> </li>
        /// <li> <p> <code>LOW</code> - The issue does not require action on its own.</p> </li>
        /// <li> <p> <code>MEDIUM</code> - The issue must be addressed but not urgently.</p> </li>
        /// <li> <p> <code>HIGH</code> - The issue must be addressed as a priority.</p> </li>
        /// <li> <p> <code>CRITICAL</code> - The issue must be remediated immediately to avoid it escalating.</p> </li>
        /// </ul>
        pub fn label(mut self, input: crate::model::SeverityLabel) -> Self {
            self.label = Some(input);
            self
        }
        /// <p>The severity value of the finding. The allowed values are the following.</p>
        /// <ul>
        /// <li> <p> <code>INFORMATIONAL</code> - No issue was found.</p> </li>
        /// <li> <p> <code>LOW</code> - The issue does not require action on its own.</p> </li>
        /// <li> <p> <code>MEDIUM</code> - The issue must be addressed but not urgently.</p> </li>
        /// <li> <p> <code>HIGH</code> - The issue must be addressed as a priority.</p> </li>
        /// <li> <p> <code>CRITICAL</code> - The issue must be remediated immediately to avoid it escalating.</p> </li>
        /// </ul>
        pub fn set_label(
            mut self,
            input: std::option::Option<crate::model::SeverityLabel>,
        ) -> Self {
            self.label = input;
            self
        }
        /// Consumes the builder and constructs a [`SeverityUpdate`](crate::model::SeverityUpdate)
        pub fn build(self) -> crate::model::SeverityUpdate {
            crate::model::SeverityUpdate {
                normalized: self.normalized.unwrap_or_default(),
                product: self.product.unwrap_or_default(),
                label: self.label,
            }
        }
    }
}
impl SeverityUpdate {
    /// Creates a new builder-style object to manufacture [`SeverityUpdate`](crate::model::SeverityUpdate)
    pub fn builder() -> crate::model::severity_update::Builder {
        crate::model::severity_update::Builder::default()
    }
}

/// <p>The list of the findings that cannot be imported. For each finding, the list provides the error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImportFindingsError {
    /// <p>The identifier of the finding that could not be updated.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The code of the error returned by the <code>BatchImportFindings</code> operation.</p>
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The message of the error returned by the <code>BatchImportFindings</code> operation.</p>
    pub error_message: std::option::Option<std::string::String>,
}
impl ImportFindingsError {
    /// <p>The identifier of the finding that could not be updated.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The code of the error returned by the <code>BatchImportFindings</code> operation.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>The message of the error returned by the <code>BatchImportFindings</code> operation.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
impl std::fmt::Debug for ImportFindingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImportFindingsError");
        formatter.field("id", &self.id);
        formatter.field("error_code", &self.error_code);
        formatter.field("error_message", &self.error_message);
        formatter.finish()
    }
}
/// See [`ImportFindingsError`](crate::model::ImportFindingsError)
pub mod import_findings_error {

    /// A builder for [`ImportFindingsError`](crate::model::ImportFindingsError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the finding that could not be updated.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the finding that could not be updated.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The code of the error returned by the <code>BatchImportFindings</code> operation.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The code of the error returned by the <code>BatchImportFindings</code> operation.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The message of the error returned by the <code>BatchImportFindings</code> operation.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The message of the error returned by the <code>BatchImportFindings</code> operation.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`ImportFindingsError`](crate::model::ImportFindingsError)
        pub fn build(self) -> crate::model::ImportFindingsError {
            crate::model::ImportFindingsError {
                id: self.id,
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
}
impl ImportFindingsError {
    /// Creates a new builder-style object to manufacture [`ImportFindingsError`](crate::model::ImportFindingsError)
    pub fn builder() -> crate::model::import_findings_error::Builder {
        crate::model::import_findings_error::Builder::default()
    }
}

/// <p>The standard that you want to enable.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StandardsSubscriptionRequest {
    /// <p>The ARN of the standard that you want to enable. To view the list of available standards and their ARNs, use the <code>DescribeStandards</code> operation.</p>
    pub standards_arn: std::option::Option<std::string::String>,
    /// <p>A key-value pair of input for the standard.</p>
    pub standards_input:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl StandardsSubscriptionRequest {
    /// <p>The ARN of the standard that you want to enable. To view the list of available standards and their ARNs, use the <code>DescribeStandards</code> operation.</p>
    pub fn standards_arn(&self) -> std::option::Option<&str> {
        self.standards_arn.as_deref()
    }
    /// <p>A key-value pair of input for the standard.</p>
    pub fn standards_input(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.standards_input.as_ref()
    }
}
impl std::fmt::Debug for StandardsSubscriptionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StandardsSubscriptionRequest");
        formatter.field("standards_arn", &self.standards_arn);
        formatter.field("standards_input", &self.standards_input);
        formatter.finish()
    }
}
/// See [`StandardsSubscriptionRequest`](crate::model::StandardsSubscriptionRequest)
pub mod standards_subscription_request {

    /// A builder for [`StandardsSubscriptionRequest`](crate::model::StandardsSubscriptionRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) standards_arn: std::option::Option<std::string::String>,
        pub(crate) standards_input: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The ARN of the standard that you want to enable. To view the list of available standards and their ARNs, use the <code>DescribeStandards</code> operation.</p>
        pub fn standards_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.standards_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the standard that you want to enable. To view the list of available standards and their ARNs, use the <code>DescribeStandards</code> operation.</p>
        pub fn set_standards_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.standards_arn = input;
            self
        }
        /// Adds a key-value pair to `standards_input`.
        ///
        /// To override the contents of this collection use [`set_standards_input`](Self::set_standards_input).
        ///
        /// <p>A key-value pair of input for the standard.</p>
        pub fn standards_input(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.standards_input.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.standards_input = Some(hash_map);
            self
        }
        /// <p>A key-value pair of input for the standard.</p>
        pub fn set_standards_input(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.standards_input = input;
            self
        }
        /// Consumes the builder and constructs a [`StandardsSubscriptionRequest`](crate::model::StandardsSubscriptionRequest)
        pub fn build(self) -> crate::model::StandardsSubscriptionRequest {
            crate::model::StandardsSubscriptionRequest {
                standards_arn: self.standards_arn,
                standards_input: self.standards_input,
            }
        }
    }
}
impl StandardsSubscriptionRequest {
    /// Creates a new builder-style object to manufacture [`StandardsSubscriptionRequest`](crate::model::StandardsSubscriptionRequest)
    pub fn builder() -> crate::model::standards_subscription_request::Builder {
        crate::model::standards_subscription_request::Builder::default()
    }
}
