// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AcceptAdministratorInvitationError {
    pub kind: AcceptAdministratorInvitationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AcceptAdministratorInvitationErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AcceptAdministratorInvitationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AcceptAdministratorInvitationErrorKind::InternalException(_inner) => _inner.fmt(f),
            AcceptAdministratorInvitationErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            AcceptAdministratorInvitationErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            AcceptAdministratorInvitationErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            AcceptAdministratorInvitationErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            AcceptAdministratorInvitationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AcceptAdministratorInvitationError {
    fn code(&self) -> Option<&str> {
        AcceptAdministratorInvitationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AcceptAdministratorInvitationError {
    pub fn new(kind: AcceptAdministratorInvitationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AcceptAdministratorInvitationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AcceptAdministratorInvitationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptAdministratorInvitationErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptAdministratorInvitationErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptAdministratorInvitationErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptAdministratorInvitationErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptAdministratorInvitationErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for AcceptAdministratorInvitationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AcceptAdministratorInvitationErrorKind::InternalException(_inner) => Some(_inner),
            AcceptAdministratorInvitationErrorKind::InvalidAccessException(_inner) => Some(_inner),
            AcceptAdministratorInvitationErrorKind::InvalidInputException(_inner) => Some(_inner),
            AcceptAdministratorInvitationErrorKind::LimitExceededException(_inner) => Some(_inner),
            AcceptAdministratorInvitationErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            AcceptAdministratorInvitationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AcceptInvitationError {
    pub kind: AcceptInvitationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AcceptInvitationErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AcceptInvitationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AcceptInvitationErrorKind::InternalException(_inner) => _inner.fmt(f),
            AcceptInvitationErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            AcceptInvitationErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            AcceptInvitationErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            AcceptInvitationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AcceptInvitationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AcceptInvitationError {
    fn code(&self) -> Option<&str> {
        AcceptInvitationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AcceptInvitationError {
    pub fn new(kind: AcceptInvitationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AcceptInvitationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AcceptInvitationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, AcceptInvitationErrorKind::InternalException(_))
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptInvitationErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptInvitationErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptInvitationErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptInvitationErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for AcceptInvitationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AcceptInvitationErrorKind::InternalException(_inner) => Some(_inner),
            AcceptInvitationErrorKind::InvalidAccessException(_inner) => Some(_inner),
            AcceptInvitationErrorKind::InvalidInputException(_inner) => Some(_inner),
            AcceptInvitationErrorKind::LimitExceededException(_inner) => Some(_inner),
            AcceptInvitationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AcceptInvitationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchDisableStandardsError {
    pub kind: BatchDisableStandardsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchDisableStandardsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchDisableStandardsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchDisableStandardsErrorKind::InternalException(_inner) => _inner.fmt(f),
            BatchDisableStandardsErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            BatchDisableStandardsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            BatchDisableStandardsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            BatchDisableStandardsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchDisableStandardsError {
    fn code(&self) -> Option<&str> {
        BatchDisableStandardsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchDisableStandardsError {
    pub fn new(kind: BatchDisableStandardsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchDisableStandardsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchDisableStandardsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDisableStandardsErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDisableStandardsErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDisableStandardsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDisableStandardsErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for BatchDisableStandardsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchDisableStandardsErrorKind::InternalException(_inner) => Some(_inner),
            BatchDisableStandardsErrorKind::InvalidAccessException(_inner) => Some(_inner),
            BatchDisableStandardsErrorKind::InvalidInputException(_inner) => Some(_inner),
            BatchDisableStandardsErrorKind::LimitExceededException(_inner) => Some(_inner),
            BatchDisableStandardsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchEnableStandardsError {
    pub kind: BatchEnableStandardsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchEnableStandardsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchEnableStandardsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchEnableStandardsErrorKind::InternalException(_inner) => _inner.fmt(f),
            BatchEnableStandardsErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            BatchEnableStandardsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            BatchEnableStandardsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            BatchEnableStandardsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchEnableStandardsError {
    fn code(&self) -> Option<&str> {
        BatchEnableStandardsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchEnableStandardsError {
    pub fn new(kind: BatchEnableStandardsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchEnableStandardsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchEnableStandardsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchEnableStandardsErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchEnableStandardsErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchEnableStandardsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchEnableStandardsErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for BatchEnableStandardsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchEnableStandardsErrorKind::InternalException(_inner) => Some(_inner),
            BatchEnableStandardsErrorKind::InvalidAccessException(_inner) => Some(_inner),
            BatchEnableStandardsErrorKind::InvalidInputException(_inner) => Some(_inner),
            BatchEnableStandardsErrorKind::LimitExceededException(_inner) => Some(_inner),
            BatchEnableStandardsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchImportFindingsError {
    pub kind: BatchImportFindingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchImportFindingsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchImportFindingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchImportFindingsErrorKind::InternalException(_inner) => _inner.fmt(f),
            BatchImportFindingsErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            BatchImportFindingsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            BatchImportFindingsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            BatchImportFindingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchImportFindingsError {
    fn code(&self) -> Option<&str> {
        BatchImportFindingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchImportFindingsError {
    pub fn new(kind: BatchImportFindingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchImportFindingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchImportFindingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchImportFindingsErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchImportFindingsErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchImportFindingsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchImportFindingsErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for BatchImportFindingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchImportFindingsErrorKind::InternalException(_inner) => Some(_inner),
            BatchImportFindingsErrorKind::InvalidAccessException(_inner) => Some(_inner),
            BatchImportFindingsErrorKind::InvalidInputException(_inner) => Some(_inner),
            BatchImportFindingsErrorKind::LimitExceededException(_inner) => Some(_inner),
            BatchImportFindingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchUpdateFindingsError {
    pub kind: BatchUpdateFindingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchUpdateFindingsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchUpdateFindingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchUpdateFindingsErrorKind::InternalException(_inner) => _inner.fmt(f),
            BatchUpdateFindingsErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            BatchUpdateFindingsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            BatchUpdateFindingsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            BatchUpdateFindingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchUpdateFindingsError {
    fn code(&self) -> Option<&str> {
        BatchUpdateFindingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchUpdateFindingsError {
    pub fn new(kind: BatchUpdateFindingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchUpdateFindingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchUpdateFindingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdateFindingsErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdateFindingsErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdateFindingsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdateFindingsErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for BatchUpdateFindingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchUpdateFindingsErrorKind::InternalException(_inner) => Some(_inner),
            BatchUpdateFindingsErrorKind::InvalidAccessException(_inner) => Some(_inner),
            BatchUpdateFindingsErrorKind::InvalidInputException(_inner) => Some(_inner),
            BatchUpdateFindingsErrorKind::LimitExceededException(_inner) => Some(_inner),
            BatchUpdateFindingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateActionTargetError {
    pub kind: CreateActionTargetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateActionTargetErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceConflictException(crate::error::ResourceConflictException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateActionTargetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateActionTargetErrorKind::InternalException(_inner) => _inner.fmt(f),
            CreateActionTargetErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            CreateActionTargetErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateActionTargetErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateActionTargetErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            CreateActionTargetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateActionTargetError {
    fn code(&self) -> Option<&str> {
        CreateActionTargetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateActionTargetError {
    pub fn new(kind: CreateActionTargetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateActionTargetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateActionTargetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateActionTargetErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateActionTargetErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateActionTargetErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateActionTargetErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateActionTargetErrorKind::ResourceConflictException(_)
        )
    }
}
impl std::error::Error for CreateActionTargetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateActionTargetErrorKind::InternalException(_inner) => Some(_inner),
            CreateActionTargetErrorKind::InvalidAccessException(_inner) => Some(_inner),
            CreateActionTargetErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateActionTargetErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateActionTargetErrorKind::ResourceConflictException(_inner) => Some(_inner),
            CreateActionTargetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateInsightError {
    pub kind: CreateInsightErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateInsightErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceConflictException(crate::error::ResourceConflictException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateInsightError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateInsightErrorKind::InternalException(_inner) => _inner.fmt(f),
            CreateInsightErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            CreateInsightErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateInsightErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateInsightErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            CreateInsightErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateInsightError {
    fn code(&self) -> Option<&str> {
        CreateInsightError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateInsightError {
    pub fn new(kind: CreateInsightErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateInsightErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateInsightErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, CreateInsightErrorKind::InternalException(_))
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInsightErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, CreateInsightErrorKind::InvalidInputException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInsightErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInsightErrorKind::ResourceConflictException(_)
        )
    }
}
impl std::error::Error for CreateInsightError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateInsightErrorKind::InternalException(_inner) => Some(_inner),
            CreateInsightErrorKind::InvalidAccessException(_inner) => Some(_inner),
            CreateInsightErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateInsightErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateInsightErrorKind::ResourceConflictException(_inner) => Some(_inner),
            CreateInsightErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateMembersError {
    pub kind: CreateMembersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateMembersErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceConflictException(crate::error::ResourceConflictException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateMembersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateMembersErrorKind::InternalException(_inner) => _inner.fmt(f),
            CreateMembersErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            CreateMembersErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateMembersErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateMembersErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            CreateMembersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateMembersError {
    fn code(&self) -> Option<&str> {
        CreateMembersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateMembersError {
    pub fn new(kind: CreateMembersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateMembersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateMembersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, CreateMembersErrorKind::InternalException(_))
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMembersErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, CreateMembersErrorKind::InvalidInputException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMembersErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMembersErrorKind::ResourceConflictException(_)
        )
    }
}
impl std::error::Error for CreateMembersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateMembersErrorKind::InternalException(_inner) => Some(_inner),
            CreateMembersErrorKind::InvalidAccessException(_inner) => Some(_inner),
            CreateMembersErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateMembersErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateMembersErrorKind::ResourceConflictException(_inner) => Some(_inner),
            CreateMembersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeclineInvitationsError {
    pub kind: DeclineInvitationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeclineInvitationsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeclineInvitationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeclineInvitationsErrorKind::InternalException(_inner) => _inner.fmt(f),
            DeclineInvitationsErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            DeclineInvitationsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeclineInvitationsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeclineInvitationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeclineInvitationsError {
    fn code(&self) -> Option<&str> {
        DeclineInvitationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeclineInvitationsError {
    pub fn new(kind: DeclineInvitationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeclineInvitationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeclineInvitationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeclineInvitationsErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeclineInvitationsErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeclineInvitationsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeclineInvitationsErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DeclineInvitationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeclineInvitationsErrorKind::InternalException(_inner) => Some(_inner),
            DeclineInvitationsErrorKind::InvalidAccessException(_inner) => Some(_inner),
            DeclineInvitationsErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeclineInvitationsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeclineInvitationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteActionTargetError {
    pub kind: DeleteActionTargetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteActionTargetErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteActionTargetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteActionTargetErrorKind::InternalException(_inner) => _inner.fmt(f),
            DeleteActionTargetErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            DeleteActionTargetErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteActionTargetErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteActionTargetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteActionTargetError {
    fn code(&self) -> Option<&str> {
        DeleteActionTargetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteActionTargetError {
    pub fn new(kind: DeleteActionTargetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteActionTargetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteActionTargetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteActionTargetErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteActionTargetErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteActionTargetErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteActionTargetErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteActionTargetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteActionTargetErrorKind::InternalException(_inner) => Some(_inner),
            DeleteActionTargetErrorKind::InvalidAccessException(_inner) => Some(_inner),
            DeleteActionTargetErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteActionTargetErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteActionTargetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteInsightError {
    pub kind: DeleteInsightErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteInsightErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteInsightError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteInsightErrorKind::InternalException(_inner) => _inner.fmt(f),
            DeleteInsightErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            DeleteInsightErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteInsightErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteInsightErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteInsightErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteInsightError {
    fn code(&self) -> Option<&str> {
        DeleteInsightError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteInsightError {
    pub fn new(kind: DeleteInsightErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteInsightErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteInsightErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, DeleteInsightErrorKind::InternalException(_))
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInsightErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, DeleteInsightErrorKind::InvalidInputException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInsightErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInsightErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteInsightError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteInsightErrorKind::InternalException(_inner) => Some(_inner),
            DeleteInsightErrorKind::InvalidAccessException(_inner) => Some(_inner),
            DeleteInsightErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteInsightErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteInsightErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteInsightErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteInvitationsError {
    pub kind: DeleteInvitationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteInvitationsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteInvitationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteInvitationsErrorKind::InternalException(_inner) => _inner.fmt(f),
            DeleteInvitationsErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            DeleteInvitationsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteInvitationsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteInvitationsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteInvitationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteInvitationsError {
    fn code(&self) -> Option<&str> {
        DeleteInvitationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteInvitationsError {
    pub fn new(kind: DeleteInvitationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteInvitationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteInvitationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, DeleteInvitationsErrorKind::InternalException(_))
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInvitationsErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInvitationsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInvitationsErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInvitationsErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteInvitationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteInvitationsErrorKind::InternalException(_inner) => Some(_inner),
            DeleteInvitationsErrorKind::InvalidAccessException(_inner) => Some(_inner),
            DeleteInvitationsErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteInvitationsErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteInvitationsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteInvitationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMembersError {
    pub kind: DeleteMembersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMembersErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteMembersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteMembersErrorKind::InternalException(_inner) => _inner.fmt(f),
            DeleteMembersErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            DeleteMembersErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteMembersErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteMembersErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteMembersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteMembersError {
    fn code(&self) -> Option<&str> {
        DeleteMembersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteMembersError {
    pub fn new(kind: DeleteMembersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteMembersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteMembersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, DeleteMembersErrorKind::InternalException(_))
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMembersErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, DeleteMembersErrorKind::InvalidInputException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMembersErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMembersErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteMembersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteMembersErrorKind::InternalException(_inner) => Some(_inner),
            DeleteMembersErrorKind::InvalidAccessException(_inner) => Some(_inner),
            DeleteMembersErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteMembersErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteMembersErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteMembersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeActionTargetsError {
    pub kind: DescribeActionTargetsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeActionTargetsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeActionTargetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeActionTargetsErrorKind::InternalException(_inner) => _inner.fmt(f),
            DescribeActionTargetsErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            DescribeActionTargetsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DescribeActionTargetsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeActionTargetsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeActionTargetsError {
    fn code(&self) -> Option<&str> {
        DescribeActionTargetsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeActionTargetsError {
    pub fn new(kind: DescribeActionTargetsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeActionTargetsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeActionTargetsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeActionTargetsErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeActionTargetsErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeActionTargetsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeActionTargetsErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DescribeActionTargetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeActionTargetsErrorKind::InternalException(_inner) => Some(_inner),
            DescribeActionTargetsErrorKind::InvalidAccessException(_inner) => Some(_inner),
            DescribeActionTargetsErrorKind::InvalidInputException(_inner) => Some(_inner),
            DescribeActionTargetsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeActionTargetsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeHubError {
    pub kind: DescribeHubErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeHubErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeHubError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeHubErrorKind::InternalException(_inner) => _inner.fmt(f),
            DescribeHubErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            DescribeHubErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DescribeHubErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DescribeHubErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeHubErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeHubError {
    fn code(&self) -> Option<&str> {
        DescribeHubError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeHubError {
    pub fn new(kind: DescribeHubErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeHubErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeHubErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, DescribeHubErrorKind::InternalException(_))
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(&self.kind, DescribeHubErrorKind::InvalidAccessException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, DescribeHubErrorKind::InvalidInputException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, DescribeHubErrorKind::LimitExceededException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeHubErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DescribeHubError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeHubErrorKind::InternalException(_inner) => Some(_inner),
            DescribeHubErrorKind::InvalidAccessException(_inner) => Some(_inner),
            DescribeHubErrorKind::InvalidInputException(_inner) => Some(_inner),
            DescribeHubErrorKind::LimitExceededException(_inner) => Some(_inner),
            DescribeHubErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeHubErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeOrganizationConfigurationError {
    pub kind: DescribeOrganizationConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeOrganizationConfigurationErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeOrganizationConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeOrganizationConfigurationErrorKind::InternalException(_inner) => _inner.fmt(f),
            DescribeOrganizationConfigurationErrorKind::InvalidAccessException(_inner) => {
                _inner.fmt(f)
            }
            DescribeOrganizationConfigurationErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            DescribeOrganizationConfigurationErrorKind::LimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            DescribeOrganizationConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeOrganizationConfigurationError {
    fn code(&self) -> Option<&str> {
        DescribeOrganizationConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeOrganizationConfigurationError {
    pub fn new(
        kind: DescribeOrganizationConfigurationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeOrganizationConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeOrganizationConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOrganizationConfigurationErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOrganizationConfigurationErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOrganizationConfigurationErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOrganizationConfigurationErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for DescribeOrganizationConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeOrganizationConfigurationErrorKind::InternalException(_inner) => Some(_inner),
            DescribeOrganizationConfigurationErrorKind::InvalidAccessException(_inner) => {
                Some(_inner)
            }
            DescribeOrganizationConfigurationErrorKind::InvalidInputException(_inner) => {
                Some(_inner)
            }
            DescribeOrganizationConfigurationErrorKind::LimitExceededException(_inner) => {
                Some(_inner)
            }
            DescribeOrganizationConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeProductsError {
    pub kind: DescribeProductsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeProductsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeProductsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeProductsErrorKind::InternalException(_inner) => _inner.fmt(f),
            DescribeProductsErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            DescribeProductsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DescribeProductsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DescribeProductsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeProductsError {
    fn code(&self) -> Option<&str> {
        DescribeProductsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeProductsError {
    pub fn new(kind: DescribeProductsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeProductsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeProductsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, DescribeProductsErrorKind::InternalException(_))
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProductsErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProductsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProductsErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for DescribeProductsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeProductsErrorKind::InternalException(_inner) => Some(_inner),
            DescribeProductsErrorKind::InvalidAccessException(_inner) => Some(_inner),
            DescribeProductsErrorKind::InvalidInputException(_inner) => Some(_inner),
            DescribeProductsErrorKind::LimitExceededException(_inner) => Some(_inner),
            DescribeProductsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeStandardsError {
    pub kind: DescribeStandardsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeStandardsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeStandardsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeStandardsErrorKind::InternalException(_inner) => _inner.fmt(f),
            DescribeStandardsErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            DescribeStandardsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DescribeStandardsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeStandardsError {
    fn code(&self) -> Option<&str> {
        DescribeStandardsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeStandardsError {
    pub fn new(kind: DescribeStandardsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeStandardsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeStandardsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, DescribeStandardsErrorKind::InternalException(_))
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStandardsErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStandardsErrorKind::InvalidInputException(_)
        )
    }
}
impl std::error::Error for DescribeStandardsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeStandardsErrorKind::InternalException(_inner) => Some(_inner),
            DescribeStandardsErrorKind::InvalidAccessException(_inner) => Some(_inner),
            DescribeStandardsErrorKind::InvalidInputException(_inner) => Some(_inner),
            DescribeStandardsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeStandardsControlsError {
    pub kind: DescribeStandardsControlsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeStandardsControlsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeStandardsControlsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeStandardsControlsErrorKind::InternalException(_inner) => _inner.fmt(f),
            DescribeStandardsControlsErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            DescribeStandardsControlsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DescribeStandardsControlsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeStandardsControlsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeStandardsControlsError {
    fn code(&self) -> Option<&str> {
        DescribeStandardsControlsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeStandardsControlsError {
    pub fn new(kind: DescribeStandardsControlsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeStandardsControlsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeStandardsControlsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStandardsControlsErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStandardsControlsErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStandardsControlsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStandardsControlsErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DescribeStandardsControlsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeStandardsControlsErrorKind::InternalException(_inner) => Some(_inner),
            DescribeStandardsControlsErrorKind::InvalidAccessException(_inner) => Some(_inner),
            DescribeStandardsControlsErrorKind::InvalidInputException(_inner) => Some(_inner),
            DescribeStandardsControlsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeStandardsControlsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisableImportFindingsForProductError {
    pub kind: DisableImportFindingsForProductErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisableImportFindingsForProductErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisableImportFindingsForProductError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisableImportFindingsForProductErrorKind::InternalException(_inner) => _inner.fmt(f),
            DisableImportFindingsForProductErrorKind::InvalidAccessException(_inner) => {
                _inner.fmt(f)
            }
            DisableImportFindingsForProductErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            DisableImportFindingsForProductErrorKind::LimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            DisableImportFindingsForProductErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DisableImportFindingsForProductErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisableImportFindingsForProductError {
    fn code(&self) -> Option<&str> {
        DisableImportFindingsForProductError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisableImportFindingsForProductError {
    pub fn new(kind: DisableImportFindingsForProductErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisableImportFindingsForProductErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisableImportFindingsForProductErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableImportFindingsForProductErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableImportFindingsForProductErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableImportFindingsForProductErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableImportFindingsForProductErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableImportFindingsForProductErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DisableImportFindingsForProductError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisableImportFindingsForProductErrorKind::InternalException(_inner) => Some(_inner),
            DisableImportFindingsForProductErrorKind::InvalidAccessException(_inner) => {
                Some(_inner)
            }
            DisableImportFindingsForProductErrorKind::InvalidInputException(_inner) => Some(_inner),
            DisableImportFindingsForProductErrorKind::LimitExceededException(_inner) => {
                Some(_inner)
            }
            DisableImportFindingsForProductErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DisableImportFindingsForProductErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisableOrganizationAdminAccountError {
    pub kind: DisableOrganizationAdminAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisableOrganizationAdminAccountErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisableOrganizationAdminAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisableOrganizationAdminAccountErrorKind::InternalException(_inner) => _inner.fmt(f),
            DisableOrganizationAdminAccountErrorKind::InvalidAccessException(_inner) => {
                _inner.fmt(f)
            }
            DisableOrganizationAdminAccountErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            DisableOrganizationAdminAccountErrorKind::LimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            DisableOrganizationAdminAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisableOrganizationAdminAccountError {
    fn code(&self) -> Option<&str> {
        DisableOrganizationAdminAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisableOrganizationAdminAccountError {
    pub fn new(kind: DisableOrganizationAdminAccountErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisableOrganizationAdminAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisableOrganizationAdminAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableOrganizationAdminAccountErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableOrganizationAdminAccountErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableOrganizationAdminAccountErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableOrganizationAdminAccountErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for DisableOrganizationAdminAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisableOrganizationAdminAccountErrorKind::InternalException(_inner) => Some(_inner),
            DisableOrganizationAdminAccountErrorKind::InvalidAccessException(_inner) => {
                Some(_inner)
            }
            DisableOrganizationAdminAccountErrorKind::InvalidInputException(_inner) => Some(_inner),
            DisableOrganizationAdminAccountErrorKind::LimitExceededException(_inner) => {
                Some(_inner)
            }
            DisableOrganizationAdminAccountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisableSecurityHubError {
    pub kind: DisableSecurityHubErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisableSecurityHubErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisableSecurityHubError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisableSecurityHubErrorKind::InternalException(_inner) => _inner.fmt(f),
            DisableSecurityHubErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            DisableSecurityHubErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DisableSecurityHubErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DisableSecurityHubErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisableSecurityHubError {
    fn code(&self) -> Option<&str> {
        DisableSecurityHubError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisableSecurityHubError {
    pub fn new(kind: DisableSecurityHubErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisableSecurityHubErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisableSecurityHubErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableSecurityHubErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableSecurityHubErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableSecurityHubErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableSecurityHubErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DisableSecurityHubError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisableSecurityHubErrorKind::InternalException(_inner) => Some(_inner),
            DisableSecurityHubErrorKind::InvalidAccessException(_inner) => Some(_inner),
            DisableSecurityHubErrorKind::LimitExceededException(_inner) => Some(_inner),
            DisableSecurityHubErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DisableSecurityHubErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateFromAdministratorAccountError {
    pub kind: DisassociateFromAdministratorAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateFromAdministratorAccountErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateFromAdministratorAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateFromAdministratorAccountErrorKind::InternalException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateFromAdministratorAccountErrorKind::InvalidAccessException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateFromAdministratorAccountErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateFromAdministratorAccountErrorKind::LimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateFromAdministratorAccountErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateFromAdministratorAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateFromAdministratorAccountError {
    fn code(&self) -> Option<&str> {
        DisassociateFromAdministratorAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateFromAdministratorAccountError {
    pub fn new(
        kind: DisassociateFromAdministratorAccountErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateFromAdministratorAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateFromAdministratorAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateFromAdministratorAccountErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateFromAdministratorAccountErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateFromAdministratorAccountErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateFromAdministratorAccountErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateFromAdministratorAccountErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DisassociateFromAdministratorAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateFromAdministratorAccountErrorKind::InternalException(_inner) => {
                Some(_inner)
            }
            DisassociateFromAdministratorAccountErrorKind::InvalidAccessException(_inner) => {
                Some(_inner)
            }
            DisassociateFromAdministratorAccountErrorKind::InvalidInputException(_inner) => {
                Some(_inner)
            }
            DisassociateFromAdministratorAccountErrorKind::LimitExceededException(_inner) => {
                Some(_inner)
            }
            DisassociateFromAdministratorAccountErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DisassociateFromAdministratorAccountErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateFromMasterAccountError {
    pub kind: DisassociateFromMasterAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateFromMasterAccountErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateFromMasterAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateFromMasterAccountErrorKind::InternalException(_inner) => _inner.fmt(f),
            DisassociateFromMasterAccountErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            DisassociateFromMasterAccountErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DisassociateFromMasterAccountErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DisassociateFromMasterAccountErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateFromMasterAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateFromMasterAccountError {
    fn code(&self) -> Option<&str> {
        DisassociateFromMasterAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateFromMasterAccountError {
    pub fn new(kind: DisassociateFromMasterAccountErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateFromMasterAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateFromMasterAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateFromMasterAccountErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateFromMasterAccountErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateFromMasterAccountErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateFromMasterAccountErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateFromMasterAccountErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DisassociateFromMasterAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateFromMasterAccountErrorKind::InternalException(_inner) => Some(_inner),
            DisassociateFromMasterAccountErrorKind::InvalidAccessException(_inner) => Some(_inner),
            DisassociateFromMasterAccountErrorKind::InvalidInputException(_inner) => Some(_inner),
            DisassociateFromMasterAccountErrorKind::LimitExceededException(_inner) => Some(_inner),
            DisassociateFromMasterAccountErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DisassociateFromMasterAccountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateMembersError {
    pub kind: DisassociateMembersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateMembersErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateMembersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateMembersErrorKind::InternalException(_inner) => _inner.fmt(f),
            DisassociateMembersErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            DisassociateMembersErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DisassociateMembersErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DisassociateMembersErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DisassociateMembersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateMembersError {
    fn code(&self) -> Option<&str> {
        DisassociateMembersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateMembersError {
    pub fn new(kind: DisassociateMembersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateMembersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateMembersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateMembersErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateMembersErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateMembersErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateMembersErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateMembersErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DisassociateMembersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateMembersErrorKind::InternalException(_inner) => Some(_inner),
            DisassociateMembersErrorKind::InvalidAccessException(_inner) => Some(_inner),
            DisassociateMembersErrorKind::InvalidInputException(_inner) => Some(_inner),
            DisassociateMembersErrorKind::LimitExceededException(_inner) => Some(_inner),
            DisassociateMembersErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DisassociateMembersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct EnableImportFindingsForProductError {
    pub kind: EnableImportFindingsForProductErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EnableImportFindingsForProductErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceConflictException(crate::error::ResourceConflictException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for EnableImportFindingsForProductError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            EnableImportFindingsForProductErrorKind::InternalException(_inner) => _inner.fmt(f),
            EnableImportFindingsForProductErrorKind::InvalidAccessException(_inner) => {
                _inner.fmt(f)
            }
            EnableImportFindingsForProductErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            EnableImportFindingsForProductErrorKind::LimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            EnableImportFindingsForProductErrorKind::ResourceConflictException(_inner) => {
                _inner.fmt(f)
            }
            EnableImportFindingsForProductErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for EnableImportFindingsForProductError {
    fn code(&self) -> Option<&str> {
        EnableImportFindingsForProductError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl EnableImportFindingsForProductError {
    pub fn new(kind: EnableImportFindingsForProductErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: EnableImportFindingsForProductErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: EnableImportFindingsForProductErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableImportFindingsForProductErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableImportFindingsForProductErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableImportFindingsForProductErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableImportFindingsForProductErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableImportFindingsForProductErrorKind::ResourceConflictException(_)
        )
    }
}
impl std::error::Error for EnableImportFindingsForProductError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            EnableImportFindingsForProductErrorKind::InternalException(_inner) => Some(_inner),
            EnableImportFindingsForProductErrorKind::InvalidAccessException(_inner) => Some(_inner),
            EnableImportFindingsForProductErrorKind::InvalidInputException(_inner) => Some(_inner),
            EnableImportFindingsForProductErrorKind::LimitExceededException(_inner) => Some(_inner),
            EnableImportFindingsForProductErrorKind::ResourceConflictException(_inner) => {
                Some(_inner)
            }
            EnableImportFindingsForProductErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct EnableOrganizationAdminAccountError {
    pub kind: EnableOrganizationAdminAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EnableOrganizationAdminAccountErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for EnableOrganizationAdminAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            EnableOrganizationAdminAccountErrorKind::InternalException(_inner) => _inner.fmt(f),
            EnableOrganizationAdminAccountErrorKind::InvalidAccessException(_inner) => {
                _inner.fmt(f)
            }
            EnableOrganizationAdminAccountErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            EnableOrganizationAdminAccountErrorKind::LimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            EnableOrganizationAdminAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for EnableOrganizationAdminAccountError {
    fn code(&self) -> Option<&str> {
        EnableOrganizationAdminAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl EnableOrganizationAdminAccountError {
    pub fn new(kind: EnableOrganizationAdminAccountErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: EnableOrganizationAdminAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: EnableOrganizationAdminAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableOrganizationAdminAccountErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableOrganizationAdminAccountErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableOrganizationAdminAccountErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableOrganizationAdminAccountErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for EnableOrganizationAdminAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            EnableOrganizationAdminAccountErrorKind::InternalException(_inner) => Some(_inner),
            EnableOrganizationAdminAccountErrorKind::InvalidAccessException(_inner) => Some(_inner),
            EnableOrganizationAdminAccountErrorKind::InvalidInputException(_inner) => Some(_inner),
            EnableOrganizationAdminAccountErrorKind::LimitExceededException(_inner) => Some(_inner),
            EnableOrganizationAdminAccountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct EnableSecurityHubError {
    pub kind: EnableSecurityHubErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EnableSecurityHubErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceConflictException(crate::error::ResourceConflictException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for EnableSecurityHubError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            EnableSecurityHubErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            EnableSecurityHubErrorKind::InternalException(_inner) => _inner.fmt(f),
            EnableSecurityHubErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            EnableSecurityHubErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            EnableSecurityHubErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            EnableSecurityHubErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for EnableSecurityHubError {
    fn code(&self) -> Option<&str> {
        EnableSecurityHubError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl EnableSecurityHubError {
    pub fn new(kind: EnableSecurityHubErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: EnableSecurityHubErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: EnableSecurityHubErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableSecurityHubErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, EnableSecurityHubErrorKind::InternalException(_))
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableSecurityHubErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableSecurityHubErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableSecurityHubErrorKind::ResourceConflictException(_)
        )
    }
}
impl std::error::Error for EnableSecurityHubError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            EnableSecurityHubErrorKind::AccessDeniedException(_inner) => Some(_inner),
            EnableSecurityHubErrorKind::InternalException(_inner) => Some(_inner),
            EnableSecurityHubErrorKind::InvalidAccessException(_inner) => Some(_inner),
            EnableSecurityHubErrorKind::LimitExceededException(_inner) => Some(_inner),
            EnableSecurityHubErrorKind::ResourceConflictException(_inner) => Some(_inner),
            EnableSecurityHubErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAdministratorAccountError {
    pub kind: GetAdministratorAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAdministratorAccountErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAdministratorAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAdministratorAccountErrorKind::InternalException(_inner) => _inner.fmt(f),
            GetAdministratorAccountErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            GetAdministratorAccountErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetAdministratorAccountErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetAdministratorAccountErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetAdministratorAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAdministratorAccountError {
    fn code(&self) -> Option<&str> {
        GetAdministratorAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAdministratorAccountError {
    pub fn new(kind: GetAdministratorAccountErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAdministratorAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAdministratorAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAdministratorAccountErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAdministratorAccountErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAdministratorAccountErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAdministratorAccountErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAdministratorAccountErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for GetAdministratorAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAdministratorAccountErrorKind::InternalException(_inner) => Some(_inner),
            GetAdministratorAccountErrorKind::InvalidAccessException(_inner) => Some(_inner),
            GetAdministratorAccountErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetAdministratorAccountErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetAdministratorAccountErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetAdministratorAccountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEnabledStandardsError {
    pub kind: GetEnabledStandardsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEnabledStandardsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEnabledStandardsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEnabledStandardsErrorKind::InternalException(_inner) => _inner.fmt(f),
            GetEnabledStandardsErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            GetEnabledStandardsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetEnabledStandardsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetEnabledStandardsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetEnabledStandardsError {
    fn code(&self) -> Option<&str> {
        GetEnabledStandardsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetEnabledStandardsError {
    pub fn new(kind: GetEnabledStandardsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEnabledStandardsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEnabledStandardsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEnabledStandardsErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEnabledStandardsErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEnabledStandardsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEnabledStandardsErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for GetEnabledStandardsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEnabledStandardsErrorKind::InternalException(_inner) => Some(_inner),
            GetEnabledStandardsErrorKind::InvalidAccessException(_inner) => Some(_inner),
            GetEnabledStandardsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetEnabledStandardsErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetEnabledStandardsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFindingsError {
    pub kind: GetFindingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFindingsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFindingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFindingsErrorKind::InternalException(_inner) => _inner.fmt(f),
            GetFindingsErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            GetFindingsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetFindingsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetFindingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetFindingsError {
    fn code(&self) -> Option<&str> {
        GetFindingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFindingsError {
    pub fn new(kind: GetFindingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFindingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFindingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, GetFindingsErrorKind::InternalException(_))
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(&self.kind, GetFindingsErrorKind::InvalidAccessException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetFindingsErrorKind::InvalidInputException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, GetFindingsErrorKind::LimitExceededException(_))
    }
}
impl std::error::Error for GetFindingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFindingsErrorKind::InternalException(_inner) => Some(_inner),
            GetFindingsErrorKind::InvalidAccessException(_inner) => Some(_inner),
            GetFindingsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetFindingsErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetFindingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetInsightResultsError {
    pub kind: GetInsightResultsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetInsightResultsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetInsightResultsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetInsightResultsErrorKind::InternalException(_inner) => _inner.fmt(f),
            GetInsightResultsErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            GetInsightResultsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetInsightResultsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetInsightResultsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetInsightResultsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetInsightResultsError {
    fn code(&self) -> Option<&str> {
        GetInsightResultsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetInsightResultsError {
    pub fn new(kind: GetInsightResultsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetInsightResultsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetInsightResultsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, GetInsightResultsErrorKind::InternalException(_))
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInsightResultsErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInsightResultsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInsightResultsErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInsightResultsErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for GetInsightResultsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetInsightResultsErrorKind::InternalException(_inner) => Some(_inner),
            GetInsightResultsErrorKind::InvalidAccessException(_inner) => Some(_inner),
            GetInsightResultsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetInsightResultsErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetInsightResultsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetInsightResultsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetInsightsError {
    pub kind: GetInsightsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetInsightsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetInsightsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetInsightsErrorKind::InternalException(_inner) => _inner.fmt(f),
            GetInsightsErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            GetInsightsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetInsightsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetInsightsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetInsightsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetInsightsError {
    fn code(&self) -> Option<&str> {
        GetInsightsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetInsightsError {
    pub fn new(kind: GetInsightsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetInsightsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetInsightsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, GetInsightsErrorKind::InternalException(_))
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(&self.kind, GetInsightsErrorKind::InvalidAccessException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetInsightsErrorKind::InvalidInputException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, GetInsightsErrorKind::LimitExceededException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInsightsErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for GetInsightsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetInsightsErrorKind::InternalException(_inner) => Some(_inner),
            GetInsightsErrorKind::InvalidAccessException(_inner) => Some(_inner),
            GetInsightsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetInsightsErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetInsightsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetInsightsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetInvitationsCountError {
    pub kind: GetInvitationsCountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetInvitationsCountErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetInvitationsCountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetInvitationsCountErrorKind::InternalException(_inner) => _inner.fmt(f),
            GetInvitationsCountErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            GetInvitationsCountErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetInvitationsCountErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetInvitationsCountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetInvitationsCountError {
    fn code(&self) -> Option<&str> {
        GetInvitationsCountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetInvitationsCountError {
    pub fn new(kind: GetInvitationsCountErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetInvitationsCountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetInvitationsCountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInvitationsCountErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInvitationsCountErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInvitationsCountErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInvitationsCountErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for GetInvitationsCountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetInvitationsCountErrorKind::InternalException(_inner) => Some(_inner),
            GetInvitationsCountErrorKind::InvalidAccessException(_inner) => Some(_inner),
            GetInvitationsCountErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetInvitationsCountErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetInvitationsCountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMasterAccountError {
    pub kind: GetMasterAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMasterAccountErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMasterAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMasterAccountErrorKind::InternalException(_inner) => _inner.fmt(f),
            GetMasterAccountErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            GetMasterAccountErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetMasterAccountErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetMasterAccountErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetMasterAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMasterAccountError {
    fn code(&self) -> Option<&str> {
        GetMasterAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMasterAccountError {
    pub fn new(kind: GetMasterAccountErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMasterAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMasterAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, GetMasterAccountErrorKind::InternalException(_))
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMasterAccountErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMasterAccountErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMasterAccountErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMasterAccountErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for GetMasterAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMasterAccountErrorKind::InternalException(_inner) => Some(_inner),
            GetMasterAccountErrorKind::InvalidAccessException(_inner) => Some(_inner),
            GetMasterAccountErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetMasterAccountErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetMasterAccountErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetMasterAccountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMembersError {
    pub kind: GetMembersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMembersErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMembersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMembersErrorKind::InternalException(_inner) => _inner.fmt(f),
            GetMembersErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            GetMembersErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetMembersErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetMembersErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetMembersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMembersError {
    fn code(&self) -> Option<&str> {
        GetMembersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMembersError {
    pub fn new(kind: GetMembersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMembersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMembersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, GetMembersErrorKind::InternalException(_))
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(&self.kind, GetMembersErrorKind::InvalidAccessException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetMembersErrorKind::InvalidInputException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, GetMembersErrorKind::LimitExceededException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMembersErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for GetMembersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMembersErrorKind::InternalException(_inner) => Some(_inner),
            GetMembersErrorKind::InvalidAccessException(_inner) => Some(_inner),
            GetMembersErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetMembersErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetMembersErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetMembersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct InviteMembersError {
    pub kind: InviteMembersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum InviteMembersErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for InviteMembersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            InviteMembersErrorKind::InternalException(_inner) => _inner.fmt(f),
            InviteMembersErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            InviteMembersErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            InviteMembersErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            InviteMembersErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            InviteMembersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for InviteMembersError {
    fn code(&self) -> Option<&str> {
        InviteMembersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl InviteMembersError {
    pub fn new(kind: InviteMembersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: InviteMembersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: InviteMembersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, InviteMembersErrorKind::InternalException(_))
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            InviteMembersErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, InviteMembersErrorKind::InvalidInputException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            InviteMembersErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            InviteMembersErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for InviteMembersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            InviteMembersErrorKind::InternalException(_inner) => Some(_inner),
            InviteMembersErrorKind::InvalidAccessException(_inner) => Some(_inner),
            InviteMembersErrorKind::InvalidInputException(_inner) => Some(_inner),
            InviteMembersErrorKind::LimitExceededException(_inner) => Some(_inner),
            InviteMembersErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            InviteMembersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListEnabledProductsForImportError {
    pub kind: ListEnabledProductsForImportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListEnabledProductsForImportErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListEnabledProductsForImportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListEnabledProductsForImportErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListEnabledProductsForImportErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            ListEnabledProductsForImportErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListEnabledProductsForImportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListEnabledProductsForImportError {
    fn code(&self) -> Option<&str> {
        ListEnabledProductsForImportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListEnabledProductsForImportError {
    pub fn new(kind: ListEnabledProductsForImportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListEnabledProductsForImportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListEnabledProductsForImportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEnabledProductsForImportErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEnabledProductsForImportErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEnabledProductsForImportErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for ListEnabledProductsForImportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListEnabledProductsForImportErrorKind::InternalException(_inner) => Some(_inner),
            ListEnabledProductsForImportErrorKind::InvalidAccessException(_inner) => Some(_inner),
            ListEnabledProductsForImportErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListEnabledProductsForImportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListInvitationsError {
    pub kind: ListInvitationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListInvitationsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListInvitationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListInvitationsErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListInvitationsErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            ListInvitationsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListInvitationsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListInvitationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListInvitationsError {
    fn code(&self) -> Option<&str> {
        ListInvitationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListInvitationsError {
    pub fn new(kind: ListInvitationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListInvitationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListInvitationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, ListInvitationsErrorKind::InternalException(_))
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInvitationsErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInvitationsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInvitationsErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for ListInvitationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListInvitationsErrorKind::InternalException(_inner) => Some(_inner),
            ListInvitationsErrorKind::InvalidAccessException(_inner) => Some(_inner),
            ListInvitationsErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListInvitationsErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListInvitationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListMembersError {
    pub kind: ListMembersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListMembersErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListMembersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListMembersErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListMembersErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            ListMembersErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListMembersErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListMembersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListMembersError {
    fn code(&self) -> Option<&str> {
        ListMembersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListMembersError {
    pub fn new(kind: ListMembersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListMembersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListMembersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, ListMembersErrorKind::InternalException(_))
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(&self.kind, ListMembersErrorKind::InvalidAccessException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, ListMembersErrorKind::InvalidInputException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, ListMembersErrorKind::LimitExceededException(_))
    }
}
impl std::error::Error for ListMembersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListMembersErrorKind::InternalException(_inner) => Some(_inner),
            ListMembersErrorKind::InvalidAccessException(_inner) => Some(_inner),
            ListMembersErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListMembersErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListMembersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListOrganizationAdminAccountsError {
    pub kind: ListOrganizationAdminAccountsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListOrganizationAdminAccountsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListOrganizationAdminAccountsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListOrganizationAdminAccountsErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListOrganizationAdminAccountsErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            ListOrganizationAdminAccountsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListOrganizationAdminAccountsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListOrganizationAdminAccountsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListOrganizationAdminAccountsError {
    fn code(&self) -> Option<&str> {
        ListOrganizationAdminAccountsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListOrganizationAdminAccountsError {
    pub fn new(kind: ListOrganizationAdminAccountsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListOrganizationAdminAccountsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListOrganizationAdminAccountsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOrganizationAdminAccountsErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOrganizationAdminAccountsErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOrganizationAdminAccountsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOrganizationAdminAccountsErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for ListOrganizationAdminAccountsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListOrganizationAdminAccountsErrorKind::InternalException(_inner) => Some(_inner),
            ListOrganizationAdminAccountsErrorKind::InvalidAccessException(_inner) => Some(_inner),
            ListOrganizationAdminAccountsErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListOrganizationAdminAccountsErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListOrganizationAdminAccountsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::InternalException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InternalException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InvalidInputException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::InternalException(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidInputException(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::InternalException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::InternalException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::InvalidInputException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::InternalException(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidInputException(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateActionTargetError {
    pub kind: UpdateActionTargetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateActionTargetErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateActionTargetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateActionTargetErrorKind::InternalException(_inner) => _inner.fmt(f),
            UpdateActionTargetErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            UpdateActionTargetErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateActionTargetErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateActionTargetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateActionTargetError {
    fn code(&self) -> Option<&str> {
        UpdateActionTargetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateActionTargetError {
    pub fn new(kind: UpdateActionTargetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateActionTargetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateActionTargetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateActionTargetErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateActionTargetErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateActionTargetErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateActionTargetErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for UpdateActionTargetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateActionTargetErrorKind::InternalException(_inner) => Some(_inner),
            UpdateActionTargetErrorKind::InvalidAccessException(_inner) => Some(_inner),
            UpdateActionTargetErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateActionTargetErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateActionTargetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateFindingsError {
    pub kind: UpdateFindingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFindingsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateFindingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateFindingsErrorKind::InternalException(_inner) => _inner.fmt(f),
            UpdateFindingsErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            UpdateFindingsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateFindingsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateFindingsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateFindingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateFindingsError {
    fn code(&self) -> Option<&str> {
        UpdateFindingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateFindingsError {
    pub fn new(kind: UpdateFindingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateFindingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateFindingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, UpdateFindingsErrorKind::InternalException(_))
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFindingsErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFindingsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFindingsErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFindingsErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for UpdateFindingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateFindingsErrorKind::InternalException(_inner) => Some(_inner),
            UpdateFindingsErrorKind::InvalidAccessException(_inner) => Some(_inner),
            UpdateFindingsErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateFindingsErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateFindingsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateFindingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateInsightError {
    pub kind: UpdateInsightErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateInsightErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateInsightError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateInsightErrorKind::InternalException(_inner) => _inner.fmt(f),
            UpdateInsightErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            UpdateInsightErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateInsightErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateInsightErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateInsightErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateInsightError {
    fn code(&self) -> Option<&str> {
        UpdateInsightError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateInsightError {
    pub fn new(kind: UpdateInsightErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateInsightErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateInsightErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, UpdateInsightErrorKind::InternalException(_))
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInsightErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, UpdateInsightErrorKind::InvalidInputException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInsightErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInsightErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for UpdateInsightError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateInsightErrorKind::InternalException(_inner) => Some(_inner),
            UpdateInsightErrorKind::InvalidAccessException(_inner) => Some(_inner),
            UpdateInsightErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateInsightErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateInsightErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateInsightErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateOrganizationConfigurationError {
    pub kind: UpdateOrganizationConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateOrganizationConfigurationErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateOrganizationConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateOrganizationConfigurationErrorKind::InternalException(_inner) => _inner.fmt(f),
            UpdateOrganizationConfigurationErrorKind::InvalidAccessException(_inner) => {
                _inner.fmt(f)
            }
            UpdateOrganizationConfigurationErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            UpdateOrganizationConfigurationErrorKind::LimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            UpdateOrganizationConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateOrganizationConfigurationError {
    fn code(&self) -> Option<&str> {
        UpdateOrganizationConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateOrganizationConfigurationError {
    pub fn new(kind: UpdateOrganizationConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateOrganizationConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateOrganizationConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateOrganizationConfigurationErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateOrganizationConfigurationErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateOrganizationConfigurationErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateOrganizationConfigurationErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for UpdateOrganizationConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateOrganizationConfigurationErrorKind::InternalException(_inner) => Some(_inner),
            UpdateOrganizationConfigurationErrorKind::InvalidAccessException(_inner) => {
                Some(_inner)
            }
            UpdateOrganizationConfigurationErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateOrganizationConfigurationErrorKind::LimitExceededException(_inner) => {
                Some(_inner)
            }
            UpdateOrganizationConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSecurityHubConfigurationError {
    pub kind: UpdateSecurityHubConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSecurityHubConfigurationErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSecurityHubConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSecurityHubConfigurationErrorKind::InternalException(_inner) => _inner.fmt(f),
            UpdateSecurityHubConfigurationErrorKind::InvalidAccessException(_inner) => {
                _inner.fmt(f)
            }
            UpdateSecurityHubConfigurationErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateSecurityHubConfigurationErrorKind::LimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            UpdateSecurityHubConfigurationErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateSecurityHubConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSecurityHubConfigurationError {
    fn code(&self) -> Option<&str> {
        UpdateSecurityHubConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSecurityHubConfigurationError {
    pub fn new(kind: UpdateSecurityHubConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSecurityHubConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSecurityHubConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSecurityHubConfigurationErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSecurityHubConfigurationErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSecurityHubConfigurationErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSecurityHubConfigurationErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSecurityHubConfigurationErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for UpdateSecurityHubConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSecurityHubConfigurationErrorKind::InternalException(_inner) => Some(_inner),
            UpdateSecurityHubConfigurationErrorKind::InvalidAccessException(_inner) => Some(_inner),
            UpdateSecurityHubConfigurationErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateSecurityHubConfigurationErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateSecurityHubConfigurationErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateSecurityHubConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateStandardsControlError {
    pub kind: UpdateStandardsControlErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateStandardsControlErrorKind {
    InternalException(crate::error::InternalException),
    InvalidAccessException(crate::error::InvalidAccessException),
    InvalidInputException(crate::error::InvalidInputException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateStandardsControlError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateStandardsControlErrorKind::InternalException(_inner) => _inner.fmt(f),
            UpdateStandardsControlErrorKind::InvalidAccessException(_inner) => _inner.fmt(f),
            UpdateStandardsControlErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateStandardsControlErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateStandardsControlErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateStandardsControlError {
    fn code(&self) -> Option<&str> {
        UpdateStandardsControlError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateStandardsControlError {
    pub fn new(kind: UpdateStandardsControlErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateStandardsControlErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateStandardsControlErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateStandardsControlErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_access_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateStandardsControlErrorKind::InvalidAccessException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateStandardsControlErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateStandardsControlErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for UpdateStandardsControlError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateStandardsControlErrorKind::InternalException(_inner) => Some(_inner),
            UpdateStandardsControlErrorKind::InvalidAccessException(_inner) => Some(_inner),
            UpdateStandardsControlErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateStandardsControlErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateStandardsControlErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The request was rejected because we can't find the specified resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    pub message: std::option::Option<std::string::String>,
    pub code: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message,
                code: self.code,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>The request was rejected because you supplied an invalid or out-of-range value for an
/// input parameter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidInputException {
    pub message: std::option::Option<std::string::String>,
    pub code: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidInputException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidInputException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.finish()
    }
}
impl InvalidInputException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidInputException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidInputException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidInputException {}
/// See [`InvalidInputException`](crate::error::InvalidInputException)
pub mod invalid_input_exception {
    /// A builder for [`InvalidInputException`](crate::error::InvalidInputException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidInputException`](crate::error::InvalidInputException)
        pub fn build(self) -> crate::error::InvalidInputException {
            crate::error::InvalidInputException {
                message: self.message,
                code: self.code,
            }
        }
    }
}
impl InvalidInputException {
    /// Creates a new builder-style object to manufacture [`InvalidInputException`](crate::error::InvalidInputException)
    pub fn builder() -> crate::error::invalid_input_exception::Builder {
        crate::error::invalid_input_exception::Builder::default()
    }
}

/// <p>There is an issue with the account used to make the request. Either Security Hub is not enabled
/// for the account, or the account does not have permission to perform this action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidAccessException {
    pub message: std::option::Option<std::string::String>,
    pub code: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidAccessException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidAccessException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.finish()
    }
}
impl InvalidAccessException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidAccessException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidAccessException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidAccessException {}
/// See [`InvalidAccessException`](crate::error::InvalidAccessException)
pub mod invalid_access_exception {
    /// A builder for [`InvalidAccessException`](crate::error::InvalidAccessException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidAccessException`](crate::error::InvalidAccessException)
        pub fn build(self) -> crate::error::InvalidAccessException {
            crate::error::InvalidAccessException {
                message: self.message,
                code: self.code,
            }
        }
    }
}
impl InvalidAccessException {
    /// Creates a new builder-style object to manufacture [`InvalidAccessException`](crate::error::InvalidAccessException)
    pub fn builder() -> crate::error::invalid_access_exception::Builder {
        crate::error::invalid_access_exception::Builder::default()
    }
}

/// <p>Internal server error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalException {
    pub message: std::option::Option<std::string::String>,
    pub code: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.finish()
    }
}
impl InternalException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalException {}
/// See [`InternalException`](crate::error::InternalException)
pub mod internal_exception {
    /// A builder for [`InternalException`](crate::error::InternalException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalException`](crate::error::InternalException)
        pub fn build(self) -> crate::error::InternalException {
            crate::error::InternalException {
                message: self.message,
                code: self.code,
            }
        }
    }
}
impl InternalException {
    /// Creates a new builder-style object to manufacture [`InternalException`](crate::error::InternalException)
    pub fn builder() -> crate::error::internal_exception::Builder {
        crate::error::internal_exception::Builder::default()
    }
}

/// <p>The request was rejected because it attempted to create resources beyond the current Amazon Web Services
/// account or throttling limits. The error code describes the limit exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    pub message: std::option::Option<std::string::String>,
    pub code: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.finish()
    }
}
impl LimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
                code: self.code,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>The resource specified in the request conflicts with an existing resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceConflictException {
    pub message: std::option::Option<std::string::String>,
    pub code: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceConflictException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.finish()
    }
}
impl ResourceConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceConflictException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceConflictException {}
/// See [`ResourceConflictException`](crate::error::ResourceConflictException)
pub mod resource_conflict_exception {
    /// A builder for [`ResourceConflictException`](crate::error::ResourceConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceConflictException`](crate::error::ResourceConflictException)
        pub fn build(self) -> crate::error::ResourceConflictException {
            crate::error::ResourceConflictException {
                message: self.message,
                code: self.code,
            }
        }
    }
}
impl ResourceConflictException {
    /// Creates a new builder-style object to manufacture [`ResourceConflictException`](crate::error::ResourceConflictException)
    pub fn builder() -> crate::error::resource_conflict_exception::Builder {
        crate::error::resource_conflict_exception::Builder::default()
    }
}

/// <p>You don't have permission to perform the action specified in the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccessDeniedException {
    pub message: std::option::Option<std::string::String>,
    pub code: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccessDeniedException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.finish()
    }
}
impl AccessDeniedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException)
pub mod access_denied_exception {
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException)
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message,
                code: self.code,
            }
        }
    }
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException)
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}
