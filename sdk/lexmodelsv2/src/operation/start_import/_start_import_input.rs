// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartImportInput  {
    /// <p>The unique identifier for the import. It is included in the response from the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_CreateUploadUrl.html">CreateUploadUrl</a> operation.</p>
    #[doc(hidden)]
    pub import_id: std::option::Option<std::string::String>,
    /// <p>Parameters for creating the bot, bot locale or custom vocabulary.</p>
    #[doc(hidden)]
    pub resource_specification: std::option::Option<crate::types::ImportResourceSpecification>,
    /// <p>The strategy to use when there is a name conflict between the imported resource and an existing resource. When the merge strategy is <code>FailOnConflict</code> existing resources are not overwritten and the import fails.</p>
    #[doc(hidden)]
    pub merge_strategy: std::option::Option<crate::types::MergeStrategy>,
    /// <p>The password used to encrypt the zip archive that contains the resource definition. You should always encrypt the zip archive to protect it during transit between your site and Amazon Lex.</p>
    #[doc(hidden)]
    pub file_password: std::option::Option<std::string::String>,
}
impl StartImportInput {
    /// <p>The unique identifier for the import. It is included in the response from the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_CreateUploadUrl.html">CreateUploadUrl</a> operation.</p>
    pub fn import_id(&self) -> std::option::Option<& str> {
        self.import_id.as_deref()
    }
    /// <p>Parameters for creating the bot, bot locale or custom vocabulary.</p>
    pub fn resource_specification(&self) -> std::option::Option<& crate::types::ImportResourceSpecification> {
        self.resource_specification.as_ref()
    }
    /// <p>The strategy to use when there is a name conflict between the imported resource and an existing resource. When the merge strategy is <code>FailOnConflict</code> existing resources are not overwritten and the import fails.</p>
    pub fn merge_strategy(&self) -> std::option::Option<& crate::types::MergeStrategy> {
        self.merge_strategy.as_ref()
    }
    /// <p>The password used to encrypt the zip archive that contains the resource definition. You should always encrypt the zip archive to protect it during transit between your site and Amazon Lex.</p>
    pub fn file_password(&self) -> std::option::Option<& str> {
        self.file_password.as_deref()
    }
}
impl  std::fmt::Debug for StartImportInput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartImportInput");
        formatter.field("import_id", &self.import_id);
        formatter.field("resource_specification", &self.resource_specification);
        formatter.field("merge_strategy", &self.merge_strategy);
        formatter.field("file_password", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl StartImportInput {
    /// Creates a new builder-style object to manufacture [`StartImportInput`](crate::operation::start_import::StartImportInput).
    pub fn builder() -> crate::operation::start_import::builders::StartImportInputBuilder {
        crate::operation::start_import::builders::StartImportInputBuilder::default()
    }
}

/// A builder for [`StartImportInput`](crate::operation::start_import::StartImportInput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
pub struct StartImportInputBuilder {
    pub(crate) import_id: std::option::Option<std::string::String>,
    pub(crate) resource_specification: std::option::Option<crate::types::ImportResourceSpecification>,
    pub(crate) merge_strategy: std::option::Option<crate::types::MergeStrategy>,
    pub(crate) file_password: std::option::Option<std::string::String>,
}
impl StartImportInputBuilder {
    /// <p>The unique identifier for the import. It is included in the response from the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_CreateUploadUrl.html">CreateUploadUrl</a> operation.</p>
    pub fn import_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.import_id = Some(input.into());
        self
    }
    /// <p>The unique identifier for the import. It is included in the response from the <a href="https://docs.aws.amazon.com/lexv2/latest/dg/API_CreateUploadUrl.html">CreateUploadUrl</a> operation.</p>
    pub fn set_import_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.import_id = input; self
    }
    /// <p>Parameters for creating the bot, bot locale or custom vocabulary.</p>
    pub fn resource_specification(mut self, input: crate::types::ImportResourceSpecification) -> Self {
        self.resource_specification = Some(input);
        self
    }
    /// <p>Parameters for creating the bot, bot locale or custom vocabulary.</p>
    pub fn set_resource_specification(mut self, input: std::option::Option<crate::types::ImportResourceSpecification>) -> Self {
        self.resource_specification = input; self
    }
    /// <p>The strategy to use when there is a name conflict between the imported resource and an existing resource. When the merge strategy is <code>FailOnConflict</code> existing resources are not overwritten and the import fails.</p>
    pub fn merge_strategy(mut self, input: crate::types::MergeStrategy) -> Self {
        self.merge_strategy = Some(input);
        self
    }
    /// <p>The strategy to use when there is a name conflict between the imported resource and an existing resource. When the merge strategy is <code>FailOnConflict</code> existing resources are not overwritten and the import fails.</p>
    pub fn set_merge_strategy(mut self, input: std::option::Option<crate::types::MergeStrategy>) -> Self {
        self.merge_strategy = input; self
    }
    /// <p>The password used to encrypt the zip archive that contains the resource definition. You should always encrypt the zip archive to protect it during transit between your site and Amazon Lex.</p>
    pub fn file_password(mut self, input: impl Into<std::string::String>) -> Self {
        self.file_password = Some(input.into());
        self
    }
    /// <p>The password used to encrypt the zip archive that contains the resource definition. You should always encrypt the zip archive to protect it during transit between your site and Amazon Lex.</p>
    pub fn set_file_password(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.file_password = input; self
    }
    /// Consumes the builder and constructs a [`StartImportInput`](crate::operation::start_import::StartImportInput).
    pub fn build(self) -> Result<crate::operation::start_import::StartImportInput, aws_smithy_http::operation::error::BuildError> {
        Ok(
            crate::operation::start_import::StartImportInput {
                import_id: self.import_id
                ,
                resource_specification: self.resource_specification
                ,
                merge_strategy: self.merge_strategy
                ,
                file_password: self.file_password
                ,
            }
        )
    }
}
impl std::fmt::Debug for StartImportInputBuilder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartImportInputBuilder");
        formatter.field("import_id", &self.import_id);
        formatter.field("resource_specification", &self.resource_specification);
        formatter.field("merge_strategy", &self.merge_strategy);
        formatter.field("file_password", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

