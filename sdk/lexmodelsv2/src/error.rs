// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BuildBotLocaleError {
    pub kind: BuildBotLocaleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BuildBotLocaleErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BuildBotLocaleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BuildBotLocaleErrorKind::ConflictException(_inner) => _inner.fmt(f),
            BuildBotLocaleErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            BuildBotLocaleErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            BuildBotLocaleErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            BuildBotLocaleErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            BuildBotLocaleErrorKind::ValidationException(_inner) => _inner.fmt(f),
            BuildBotLocaleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BuildBotLocaleError {
    fn code(&self) -> Option<&str> {
        BuildBotLocaleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BuildBotLocaleError {
    pub fn new(kind: BuildBotLocaleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BuildBotLocaleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BuildBotLocaleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, BuildBotLocaleErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            BuildBotLocaleErrorKind::InternalServerException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            BuildBotLocaleErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            BuildBotLocaleErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, BuildBotLocaleErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, BuildBotLocaleErrorKind::ValidationException(_))
    }
}
impl std::error::Error for BuildBotLocaleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BuildBotLocaleErrorKind::ConflictException(_inner) => Some(_inner),
            BuildBotLocaleErrorKind::InternalServerException(_inner) => Some(_inner),
            BuildBotLocaleErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            BuildBotLocaleErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            BuildBotLocaleErrorKind::ThrottlingException(_inner) => Some(_inner),
            BuildBotLocaleErrorKind::ValidationException(_inner) => Some(_inner),
            BuildBotLocaleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateBotError {
    pub kind: CreateBotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateBotErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateBotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateBotErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateBotErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateBotErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            CreateBotErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            CreateBotErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateBotErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateBotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateBotError {
    fn code(&self) -> Option<&str> {
        CreateBotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateBotError {
    pub fn new(kind: CreateBotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateBotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateBotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateBotErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, CreateBotErrorKind::InternalServerException(_))
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBotErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBotErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateBotErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateBotErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateBotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateBotErrorKind::ConflictException(_inner) => Some(_inner),
            CreateBotErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateBotErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            CreateBotErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            CreateBotErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateBotErrorKind::ValidationException(_inner) => Some(_inner),
            CreateBotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateBotAliasError {
    pub kind: CreateBotAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateBotAliasErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateBotAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateBotAliasErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateBotAliasErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateBotAliasErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            CreateBotAliasErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            CreateBotAliasErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateBotAliasErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateBotAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateBotAliasError {
    fn code(&self) -> Option<&str> {
        CreateBotAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateBotAliasError {
    pub fn new(kind: CreateBotAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateBotAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateBotAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateBotAliasErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBotAliasErrorKind::InternalServerException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBotAliasErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBotAliasErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateBotAliasErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateBotAliasErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateBotAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateBotAliasErrorKind::ConflictException(_inner) => Some(_inner),
            CreateBotAliasErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateBotAliasErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            CreateBotAliasErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            CreateBotAliasErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateBotAliasErrorKind::ValidationException(_inner) => Some(_inner),
            CreateBotAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateBotLocaleError {
    pub kind: CreateBotLocaleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateBotLocaleErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateBotLocaleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateBotLocaleErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateBotLocaleErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateBotLocaleErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            CreateBotLocaleErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            CreateBotLocaleErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateBotLocaleErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateBotLocaleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateBotLocaleError {
    fn code(&self) -> Option<&str> {
        CreateBotLocaleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateBotLocaleError {
    pub fn new(kind: CreateBotLocaleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateBotLocaleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateBotLocaleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateBotLocaleErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBotLocaleErrorKind::InternalServerException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBotLocaleErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBotLocaleErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateBotLocaleErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateBotLocaleErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateBotLocaleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateBotLocaleErrorKind::ConflictException(_inner) => Some(_inner),
            CreateBotLocaleErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateBotLocaleErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            CreateBotLocaleErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            CreateBotLocaleErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateBotLocaleErrorKind::ValidationException(_inner) => Some(_inner),
            CreateBotLocaleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateBotVersionError {
    pub kind: CreateBotVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateBotVersionErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateBotVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateBotVersionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateBotVersionErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateBotVersionErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            CreateBotVersionErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            CreateBotVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateBotVersionErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateBotVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateBotVersionError {
    fn code(&self) -> Option<&str> {
        CreateBotVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateBotVersionError {
    pub fn new(kind: CreateBotVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateBotVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateBotVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateBotVersionErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBotVersionErrorKind::InternalServerException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBotVersionErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBotVersionErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBotVersionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBotVersionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateBotVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateBotVersionErrorKind::ConflictException(_inner) => Some(_inner),
            CreateBotVersionErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateBotVersionErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            CreateBotVersionErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            CreateBotVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateBotVersionErrorKind::ValidationException(_inner) => Some(_inner),
            CreateBotVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateExportError {
    pub kind: CreateExportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateExportErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateExportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateExportErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateExportErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateExportErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateExportErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            CreateExportErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateExportErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateExportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateExportError {
    fn code(&self) -> Option<&str> {
        CreateExportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateExportError {
    pub fn new(kind: CreateExportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateExportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateExportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateExportErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateExportErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateExportErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateExportErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateExportErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateExportErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateExportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateExportErrorKind::ConflictException(_inner) => Some(_inner),
            CreateExportErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateExportErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateExportErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            CreateExportErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateExportErrorKind::ValidationException(_inner) => Some(_inner),
            CreateExportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateIntentError {
    pub kind: CreateIntentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateIntentErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateIntentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateIntentErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateIntentErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateIntentErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            CreateIntentErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            CreateIntentErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateIntentErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateIntentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateIntentError {
    fn code(&self) -> Option<&str> {
        CreateIntentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateIntentError {
    pub fn new(kind: CreateIntentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateIntentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateIntentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateIntentErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIntentErrorKind::InternalServerException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIntentErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIntentErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateIntentErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateIntentErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateIntentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateIntentErrorKind::ConflictException(_inner) => Some(_inner),
            CreateIntentErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateIntentErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            CreateIntentErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            CreateIntentErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateIntentErrorKind::ValidationException(_inner) => Some(_inner),
            CreateIntentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateResourcePolicyError {
    pub kind: CreateResourcePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateResourcePolicyErrorKind {
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateResourcePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateResourcePolicyErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateResourcePolicyErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            CreateResourcePolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateResourcePolicyErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            CreateResourcePolicyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateResourcePolicyErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateResourcePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateResourcePolicyError {
    fn code(&self) -> Option<&str> {
        CreateResourcePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateResourcePolicyError {
    pub fn new(kind: CreateResourcePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateResourcePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateResourcePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourcePolicyErrorKind::InternalServerException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourcePolicyErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourcePolicyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourcePolicyErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourcePolicyErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourcePolicyErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateResourcePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateResourcePolicyErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateResourcePolicyErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            CreateResourcePolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateResourcePolicyErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            CreateResourcePolicyErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateResourcePolicyErrorKind::ValidationException(_inner) => Some(_inner),
            CreateResourcePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateResourcePolicyStatementError {
    pub kind: CreateResourcePolicyStatementErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateResourcePolicyStatementErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateResourcePolicyStatementError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateResourcePolicyStatementErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateResourcePolicyStatementErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            CreateResourcePolicyStatementErrorKind::PreconditionFailedException(_inner) => {
                _inner.fmt(f)
            }
            CreateResourcePolicyStatementErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            CreateResourcePolicyStatementErrorKind::ServiceQuotaExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateResourcePolicyStatementErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateResourcePolicyStatementErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateResourcePolicyStatementErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateResourcePolicyStatementError {
    fn code(&self) -> Option<&str> {
        CreateResourcePolicyStatementError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateResourcePolicyStatementError {
    pub fn new(kind: CreateResourcePolicyStatementErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateResourcePolicyStatementErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateResourcePolicyStatementErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourcePolicyStatementErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourcePolicyStatementErrorKind::InternalServerException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourcePolicyStatementErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourcePolicyStatementErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourcePolicyStatementErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourcePolicyStatementErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourcePolicyStatementErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateResourcePolicyStatementError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateResourcePolicyStatementErrorKind::ConflictException(_inner) => Some(_inner),
            CreateResourcePolicyStatementErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateResourcePolicyStatementErrorKind::PreconditionFailedException(_inner) => {
                Some(_inner)
            }
            CreateResourcePolicyStatementErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            CreateResourcePolicyStatementErrorKind::ServiceQuotaExceededException(_inner) => {
                Some(_inner)
            }
            CreateResourcePolicyStatementErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateResourcePolicyStatementErrorKind::ValidationException(_inner) => Some(_inner),
            CreateResourcePolicyStatementErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSlotError {
    pub kind: CreateSlotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSlotErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateSlotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSlotErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateSlotErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateSlotErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            CreateSlotErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            CreateSlotErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateSlotErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateSlotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateSlotError {
    fn code(&self) -> Option<&str> {
        CreateSlotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSlotError {
    pub fn new(kind: CreateSlotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateSlotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateSlotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateSlotErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, CreateSlotErrorKind::InternalServerException(_))
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSlotErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSlotErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateSlotErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateSlotErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateSlotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSlotErrorKind::ConflictException(_inner) => Some(_inner),
            CreateSlotErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateSlotErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            CreateSlotErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            CreateSlotErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateSlotErrorKind::ValidationException(_inner) => Some(_inner),
            CreateSlotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSlotTypeError {
    pub kind: CreateSlotTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSlotTypeErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateSlotTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSlotTypeErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateSlotTypeErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateSlotTypeErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            CreateSlotTypeErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            CreateSlotTypeErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateSlotTypeErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateSlotTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateSlotTypeError {
    fn code(&self) -> Option<&str> {
        CreateSlotTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSlotTypeError {
    pub fn new(kind: CreateSlotTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateSlotTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateSlotTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateSlotTypeErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSlotTypeErrorKind::InternalServerException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSlotTypeErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSlotTypeErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateSlotTypeErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateSlotTypeErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateSlotTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSlotTypeErrorKind::ConflictException(_inner) => Some(_inner),
            CreateSlotTypeErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateSlotTypeErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            CreateSlotTypeErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            CreateSlotTypeErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateSlotTypeErrorKind::ValidationException(_inner) => Some(_inner),
            CreateSlotTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateUploadUrlError {
    pub kind: CreateUploadUrlErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUploadUrlErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateUploadUrlError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateUploadUrlErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateUploadUrlErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateUploadUrlErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateUploadUrlErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateUploadUrlErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateUploadUrlErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateUploadUrlError {
    fn code(&self) -> Option<&str> {
        CreateUploadUrlError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateUploadUrlError {
    pub fn new(kind: CreateUploadUrlErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateUploadUrlErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateUploadUrlErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateUploadUrlErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUploadUrlErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUploadUrlErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateUploadUrlErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateUploadUrlErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateUploadUrlError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateUploadUrlErrorKind::ConflictException(_inner) => Some(_inner),
            CreateUploadUrlErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateUploadUrlErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateUploadUrlErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateUploadUrlErrorKind::ValidationException(_inner) => Some(_inner),
            CreateUploadUrlErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteBotError {
    pub kind: DeleteBotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBotErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteBotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteBotErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteBotErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteBotErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            DeleteBotErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            DeleteBotErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteBotErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteBotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteBotError {
    fn code(&self) -> Option<&str> {
        DeleteBotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBotError {
    pub fn new(kind: DeleteBotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteBotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteBotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteBotErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DeleteBotErrorKind::InternalServerException(_))
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBotErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBotErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteBotErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteBotErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteBotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteBotErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteBotErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteBotErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            DeleteBotErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            DeleteBotErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteBotErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteBotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteBotAliasError {
    pub kind: DeleteBotAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBotAliasErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteBotAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteBotAliasErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteBotAliasErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteBotAliasErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            DeleteBotAliasErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            DeleteBotAliasErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteBotAliasErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteBotAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteBotAliasError {
    fn code(&self) -> Option<&str> {
        DeleteBotAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBotAliasError {
    pub fn new(kind: DeleteBotAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteBotAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteBotAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteBotAliasErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBotAliasErrorKind::InternalServerException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBotAliasErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBotAliasErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteBotAliasErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteBotAliasErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteBotAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteBotAliasErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteBotAliasErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteBotAliasErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            DeleteBotAliasErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            DeleteBotAliasErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteBotAliasErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteBotAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteBotLocaleError {
    pub kind: DeleteBotLocaleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBotLocaleErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteBotLocaleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteBotLocaleErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteBotLocaleErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteBotLocaleErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            DeleteBotLocaleErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            DeleteBotLocaleErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteBotLocaleErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteBotLocaleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteBotLocaleError {
    fn code(&self) -> Option<&str> {
        DeleteBotLocaleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBotLocaleError {
    pub fn new(kind: DeleteBotLocaleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteBotLocaleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteBotLocaleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteBotLocaleErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBotLocaleErrorKind::InternalServerException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBotLocaleErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBotLocaleErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteBotLocaleErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteBotLocaleErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteBotLocaleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteBotLocaleErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteBotLocaleErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteBotLocaleErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            DeleteBotLocaleErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            DeleteBotLocaleErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteBotLocaleErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteBotLocaleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteBotVersionError {
    pub kind: DeleteBotVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBotVersionErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteBotVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteBotVersionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteBotVersionErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteBotVersionErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            DeleteBotVersionErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            DeleteBotVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteBotVersionErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteBotVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteBotVersionError {
    fn code(&self) -> Option<&str> {
        DeleteBotVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBotVersionError {
    pub fn new(kind: DeleteBotVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteBotVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteBotVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteBotVersionErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBotVersionErrorKind::InternalServerException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBotVersionErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBotVersionErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBotVersionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBotVersionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteBotVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteBotVersionErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteBotVersionErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteBotVersionErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            DeleteBotVersionErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            DeleteBotVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteBotVersionErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteBotVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteExportError {
    pub kind: DeleteExportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteExportErrorKind {
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteExportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteExportErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteExportErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            DeleteExportErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            DeleteExportErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteExportErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteExportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteExportError {
    fn code(&self) -> Option<&str> {
        DeleteExportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteExportError {
    pub fn new(kind: DeleteExportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteExportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteExportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteExportErrorKind::InternalServerException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteExportErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteExportErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteExportErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteExportErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteExportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteExportErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteExportErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            DeleteExportErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            DeleteExportErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteExportErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteExportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteImportError {
    pub kind: DeleteImportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteImportErrorKind {
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteImportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteImportErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteImportErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            DeleteImportErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            DeleteImportErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteImportErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteImportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteImportError {
    fn code(&self) -> Option<&str> {
        DeleteImportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteImportError {
    pub fn new(kind: DeleteImportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteImportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteImportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteImportErrorKind::InternalServerException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteImportErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteImportErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteImportErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteImportErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteImportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteImportErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteImportErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            DeleteImportErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            DeleteImportErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteImportErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteImportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteIntentError {
    pub kind: DeleteIntentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteIntentErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteIntentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteIntentErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteIntentErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteIntentErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            DeleteIntentErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            DeleteIntentErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteIntentErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteIntentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteIntentError {
    fn code(&self) -> Option<&str> {
        DeleteIntentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteIntentError {
    pub fn new(kind: DeleteIntentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteIntentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteIntentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteIntentErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIntentErrorKind::InternalServerException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIntentErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIntentErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteIntentErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteIntentErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteIntentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteIntentErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteIntentErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteIntentErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            DeleteIntentErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            DeleteIntentErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteIntentErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteIntentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteResourcePolicyError {
    pub kind: DeleteResourcePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteResourcePolicyErrorKind {
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteResourcePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteResourcePolicyErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteResourcePolicyErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            DeleteResourcePolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteResourcePolicyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteResourcePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteResourcePolicyError {
    fn code(&self) -> Option<&str> {
        DeleteResourcePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteResourcePolicyError {
    pub fn new(kind: DeleteResourcePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteResourcePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteResourcePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourcePolicyErrorKind::InternalServerException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourcePolicyErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourcePolicyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourcePolicyErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteResourcePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteResourcePolicyErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteResourcePolicyErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            DeleteResourcePolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteResourcePolicyErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteResourcePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteResourcePolicyStatementError {
    pub kind: DeleteResourcePolicyStatementErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteResourcePolicyStatementErrorKind {
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteResourcePolicyStatementError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteResourcePolicyStatementErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            DeleteResourcePolicyStatementErrorKind::PreconditionFailedException(_inner) => {
                _inner.fmt(f)
            }
            DeleteResourcePolicyStatementErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteResourcePolicyStatementErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteResourcePolicyStatementErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteResourcePolicyStatementError {
    fn code(&self) -> Option<&str> {
        DeleteResourcePolicyStatementError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteResourcePolicyStatementError {
    pub fn new(kind: DeleteResourcePolicyStatementErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteResourcePolicyStatementErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteResourcePolicyStatementErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourcePolicyStatementErrorKind::InternalServerException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourcePolicyStatementErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourcePolicyStatementErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourcePolicyStatementErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteResourcePolicyStatementError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteResourcePolicyStatementErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteResourcePolicyStatementErrorKind::PreconditionFailedException(_inner) => {
                Some(_inner)
            }
            DeleteResourcePolicyStatementErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteResourcePolicyStatementErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteResourcePolicyStatementErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSlotError {
    pub kind: DeleteSlotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSlotErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSlotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSlotErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteSlotErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteSlotErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            DeleteSlotErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            DeleteSlotErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteSlotErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteSlotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSlotError {
    fn code(&self) -> Option<&str> {
        DeleteSlotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSlotError {
    pub fn new(kind: DeleteSlotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSlotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSlotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteSlotErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DeleteSlotErrorKind::InternalServerException(_))
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSlotErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSlotErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteSlotErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteSlotErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteSlotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSlotErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteSlotErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteSlotErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            DeleteSlotErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            DeleteSlotErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteSlotErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteSlotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSlotTypeError {
    pub kind: DeleteSlotTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSlotTypeErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSlotTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSlotTypeErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteSlotTypeErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteSlotTypeErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            DeleteSlotTypeErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            DeleteSlotTypeErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteSlotTypeErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteSlotTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSlotTypeError {
    fn code(&self) -> Option<&str> {
        DeleteSlotTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSlotTypeError {
    pub fn new(kind: DeleteSlotTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSlotTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSlotTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteSlotTypeErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSlotTypeErrorKind::InternalServerException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSlotTypeErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSlotTypeErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteSlotTypeErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteSlotTypeErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteSlotTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSlotTypeErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteSlotTypeErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteSlotTypeErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            DeleteSlotTypeErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            DeleteSlotTypeErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteSlotTypeErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteSlotTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeBotError {
    pub kind: DescribeBotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeBotErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeBotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeBotErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeBotErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeBotErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            DescribeBotErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeBotErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DescribeBotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeBotError {
    fn code(&self) -> Option<&str> {
        DescribeBotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeBotError {
    pub fn new(kind: DescribeBotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeBotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeBotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DescribeBotErrorKind::InternalServerException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBotErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBotErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeBotErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DescribeBotErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DescribeBotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeBotErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeBotErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeBotErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            DescribeBotErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeBotErrorKind::ValidationException(_inner) => Some(_inner),
            DescribeBotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeBotAliasError {
    pub kind: DescribeBotAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeBotAliasErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeBotAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeBotAliasErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeBotAliasErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeBotAliasErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            DescribeBotAliasErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeBotAliasErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DescribeBotAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeBotAliasError {
    fn code(&self) -> Option<&str> {
        DescribeBotAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeBotAliasError {
    pub fn new(kind: DescribeBotAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeBotAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeBotAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBotAliasErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBotAliasErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBotAliasErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBotAliasErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBotAliasErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DescribeBotAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeBotAliasErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeBotAliasErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeBotAliasErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            DescribeBotAliasErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeBotAliasErrorKind::ValidationException(_inner) => Some(_inner),
            DescribeBotAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeBotLocaleError {
    pub kind: DescribeBotLocaleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeBotLocaleErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeBotLocaleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeBotLocaleErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeBotLocaleErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeBotLocaleErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            DescribeBotLocaleErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeBotLocaleErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DescribeBotLocaleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeBotLocaleError {
    fn code(&self) -> Option<&str> {
        DescribeBotLocaleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeBotLocaleError {
    pub fn new(kind: DescribeBotLocaleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeBotLocaleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeBotLocaleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBotLocaleErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBotLocaleErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBotLocaleErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBotLocaleErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBotLocaleErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DescribeBotLocaleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeBotLocaleErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeBotLocaleErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeBotLocaleErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            DescribeBotLocaleErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeBotLocaleErrorKind::ValidationException(_inner) => Some(_inner),
            DescribeBotLocaleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeBotVersionError {
    pub kind: DescribeBotVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeBotVersionErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeBotVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeBotVersionErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeBotVersionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeBotVersionErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            DescribeBotVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeBotVersionErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DescribeBotVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeBotVersionError {
    fn code(&self) -> Option<&str> {
        DescribeBotVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeBotVersionError {
    pub fn new(kind: DescribeBotVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeBotVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeBotVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBotVersionErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBotVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBotVersionErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBotVersionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBotVersionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DescribeBotVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeBotVersionErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeBotVersionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeBotVersionErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            DescribeBotVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeBotVersionErrorKind::ValidationException(_inner) => Some(_inner),
            DescribeBotVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeExportError {
    pub kind: DescribeExportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeExportErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeExportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeExportErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeExportErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeExportErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeExportErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DescribeExportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeExportError {
    fn code(&self) -> Option<&str> {
        DescribeExportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeExportError {
    pub fn new(kind: DescribeExportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeExportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeExportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeExportErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeExportErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeExportErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DescribeExportErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DescribeExportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeExportErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeExportErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeExportErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeExportErrorKind::ValidationException(_inner) => Some(_inner),
            DescribeExportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeImportError {
    pub kind: DescribeImportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeImportErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeImportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeImportErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeImportErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeImportErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeImportErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DescribeImportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeImportError {
    fn code(&self) -> Option<&str> {
        DescribeImportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeImportError {
    pub fn new(kind: DescribeImportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeImportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeImportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeImportErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeImportErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeImportErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DescribeImportErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DescribeImportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeImportErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeImportErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeImportErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeImportErrorKind::ValidationException(_inner) => Some(_inner),
            DescribeImportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeIntentError {
    pub kind: DescribeIntentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeIntentErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeIntentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeIntentErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeIntentErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeIntentErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            DescribeIntentErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeIntentErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DescribeIntentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeIntentError {
    fn code(&self) -> Option<&str> {
        DescribeIntentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeIntentError {
    pub fn new(kind: DescribeIntentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeIntentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeIntentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIntentErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIntentErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIntentErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeIntentErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DescribeIntentErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DescribeIntentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeIntentErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeIntentErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeIntentErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            DescribeIntentErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeIntentErrorKind::ValidationException(_inner) => Some(_inner),
            DescribeIntentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeResourcePolicyError {
    pub kind: DescribeResourcePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeResourcePolicyErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeResourcePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeResourcePolicyErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeResourcePolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeResourcePolicyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeResourcePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeResourcePolicyError {
    fn code(&self) -> Option<&str> {
        DescribeResourcePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeResourcePolicyError {
    pub fn new(kind: DescribeResourcePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeResourcePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeResourcePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeResourcePolicyErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeResourcePolicyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeResourcePolicyErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeResourcePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeResourcePolicyErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeResourcePolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeResourcePolicyErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeResourcePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeSlotError {
    pub kind: DescribeSlotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSlotErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeSlotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeSlotErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeSlotErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeSlotErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            DescribeSlotErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeSlotErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DescribeSlotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeSlotError {
    fn code(&self) -> Option<&str> {
        DescribeSlotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeSlotError {
    pub fn new(kind: DescribeSlotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeSlotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeSlotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSlotErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSlotErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSlotErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeSlotErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DescribeSlotErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DescribeSlotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeSlotErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeSlotErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeSlotErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            DescribeSlotErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeSlotErrorKind::ValidationException(_inner) => Some(_inner),
            DescribeSlotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeSlotTypeError {
    pub kind: DescribeSlotTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSlotTypeErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeSlotTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeSlotTypeErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeSlotTypeErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeSlotTypeErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            DescribeSlotTypeErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeSlotTypeErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DescribeSlotTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeSlotTypeError {
    fn code(&self) -> Option<&str> {
        DescribeSlotTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeSlotTypeError {
    pub fn new(kind: DescribeSlotTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeSlotTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeSlotTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSlotTypeErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSlotTypeErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSlotTypeErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSlotTypeErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSlotTypeErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DescribeSlotTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeSlotTypeErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeSlotTypeErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeSlotTypeErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            DescribeSlotTypeErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeSlotTypeErrorKind::ValidationException(_inner) => Some(_inner),
            DescribeSlotTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListBotAliasesError {
    pub kind: ListBotAliasesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListBotAliasesErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListBotAliasesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListBotAliasesErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListBotAliasesErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            ListBotAliasesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListBotAliasesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListBotAliasesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListBotAliasesError {
    fn code(&self) -> Option<&str> {
        ListBotAliasesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListBotAliasesError {
    pub fn new(kind: ListBotAliasesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListBotAliasesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListBotAliasesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBotAliasesErrorKind::InternalServerException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBotAliasesErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListBotAliasesErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListBotAliasesErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListBotAliasesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListBotAliasesErrorKind::InternalServerException(_inner) => Some(_inner),
            ListBotAliasesErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            ListBotAliasesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListBotAliasesErrorKind::ValidationException(_inner) => Some(_inner),
            ListBotAliasesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListBotLocalesError {
    pub kind: ListBotLocalesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListBotLocalesErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListBotLocalesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListBotLocalesErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListBotLocalesErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            ListBotLocalesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListBotLocalesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListBotLocalesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListBotLocalesError {
    fn code(&self) -> Option<&str> {
        ListBotLocalesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListBotLocalesError {
    pub fn new(kind: ListBotLocalesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListBotLocalesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListBotLocalesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBotLocalesErrorKind::InternalServerException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBotLocalesErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListBotLocalesErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListBotLocalesErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListBotLocalesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListBotLocalesErrorKind::InternalServerException(_inner) => Some(_inner),
            ListBotLocalesErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            ListBotLocalesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListBotLocalesErrorKind::ValidationException(_inner) => Some(_inner),
            ListBotLocalesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListBotsError {
    pub kind: ListBotsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListBotsErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListBotsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListBotsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListBotsErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            ListBotsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListBotsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListBotsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListBotsError {
    fn code(&self) -> Option<&str> {
        ListBotsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListBotsError {
    pub fn new(kind: ListBotsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListBotsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListBotsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListBotsErrorKind::InternalServerException(_))
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBotsErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListBotsErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListBotsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListBotsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListBotsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListBotsErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            ListBotsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListBotsErrorKind::ValidationException(_inner) => Some(_inner),
            ListBotsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListBotVersionsError {
    pub kind: ListBotVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListBotVersionsErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListBotVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListBotVersionsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListBotVersionsErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            ListBotVersionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListBotVersionsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListBotVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListBotVersionsError {
    fn code(&self) -> Option<&str> {
        ListBotVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListBotVersionsError {
    pub fn new(kind: ListBotVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListBotVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListBotVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBotVersionsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBotVersionsErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListBotVersionsErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListBotVersionsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListBotVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListBotVersionsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListBotVersionsErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            ListBotVersionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListBotVersionsErrorKind::ValidationException(_inner) => Some(_inner),
            ListBotVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListBuiltInIntentsError {
    pub kind: ListBuiltInIntentsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListBuiltInIntentsErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListBuiltInIntentsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListBuiltInIntentsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListBuiltInIntentsErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            ListBuiltInIntentsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListBuiltInIntentsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListBuiltInIntentsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListBuiltInIntentsError {
    fn code(&self) -> Option<&str> {
        ListBuiltInIntentsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListBuiltInIntentsError {
    pub fn new(kind: ListBuiltInIntentsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListBuiltInIntentsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListBuiltInIntentsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBuiltInIntentsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBuiltInIntentsErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBuiltInIntentsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBuiltInIntentsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListBuiltInIntentsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListBuiltInIntentsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListBuiltInIntentsErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            ListBuiltInIntentsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListBuiltInIntentsErrorKind::ValidationException(_inner) => Some(_inner),
            ListBuiltInIntentsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListBuiltInSlotTypesError {
    pub kind: ListBuiltInSlotTypesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListBuiltInSlotTypesErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListBuiltInSlotTypesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListBuiltInSlotTypesErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListBuiltInSlotTypesErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            ListBuiltInSlotTypesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListBuiltInSlotTypesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListBuiltInSlotTypesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListBuiltInSlotTypesError {
    fn code(&self) -> Option<&str> {
        ListBuiltInSlotTypesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListBuiltInSlotTypesError {
    pub fn new(kind: ListBuiltInSlotTypesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListBuiltInSlotTypesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListBuiltInSlotTypesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBuiltInSlotTypesErrorKind::InternalServerException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBuiltInSlotTypesErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBuiltInSlotTypesErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBuiltInSlotTypesErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListBuiltInSlotTypesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListBuiltInSlotTypesErrorKind::InternalServerException(_inner) => Some(_inner),
            ListBuiltInSlotTypesErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            ListBuiltInSlotTypesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListBuiltInSlotTypesErrorKind::ValidationException(_inner) => Some(_inner),
            ListBuiltInSlotTypesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListExportsError {
    pub kind: ListExportsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListExportsErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListExportsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListExportsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListExportsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListExportsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListExportsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListExportsError {
    fn code(&self) -> Option<&str> {
        ListExportsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListExportsError {
    pub fn new(kind: ListExportsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListExportsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListExportsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListExportsErrorKind::InternalServerException(_))
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListExportsErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListExportsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListExportsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListExportsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListExportsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListExportsErrorKind::ValidationException(_inner) => Some(_inner),
            ListExportsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListImportsError {
    pub kind: ListImportsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListImportsErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListImportsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListImportsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListImportsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListImportsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListImportsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListImportsError {
    fn code(&self) -> Option<&str> {
        ListImportsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListImportsError {
    pub fn new(kind: ListImportsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListImportsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListImportsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListImportsErrorKind::InternalServerException(_))
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListImportsErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListImportsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListImportsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListImportsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListImportsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListImportsErrorKind::ValidationException(_inner) => Some(_inner),
            ListImportsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListIntentsError {
    pub kind: ListIntentsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListIntentsErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListIntentsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListIntentsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListIntentsErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            ListIntentsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListIntentsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListIntentsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListIntentsError {
    fn code(&self) -> Option<&str> {
        ListIntentsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListIntentsError {
    pub fn new(kind: ListIntentsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListIntentsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListIntentsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListIntentsErrorKind::InternalServerException(_))
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIntentsErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListIntentsErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListIntentsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListIntentsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListIntentsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListIntentsErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            ListIntentsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListIntentsErrorKind::ValidationException(_inner) => Some(_inner),
            ListIntentsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSlotsError {
    pub kind: ListSlotsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSlotsErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSlotsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSlotsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListSlotsErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            ListSlotsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListSlotsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListSlotsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSlotsError {
    fn code(&self) -> Option<&str> {
        ListSlotsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSlotsError {
    pub fn new(kind: ListSlotsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSlotsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSlotsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListSlotsErrorKind::InternalServerException(_))
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSlotsErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListSlotsErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListSlotsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListSlotsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSlotsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListSlotsErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            ListSlotsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListSlotsErrorKind::ValidationException(_inner) => Some(_inner),
            ListSlotsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSlotTypesError {
    pub kind: ListSlotTypesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSlotTypesErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSlotTypesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSlotTypesErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListSlotTypesErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            ListSlotTypesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListSlotTypesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListSlotTypesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSlotTypesError {
    fn code(&self) -> Option<&str> {
        ListSlotTypesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSlotTypesError {
    pub fn new(kind: ListSlotTypesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSlotTypesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSlotTypesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSlotTypesErrorKind::InternalServerException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSlotTypesErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListSlotTypesErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListSlotTypesErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListSlotTypesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSlotTypesErrorKind::InternalServerException(_inner) => Some(_inner),
            ListSlotTypesErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            ListSlotTypesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListSlotTypesErrorKind::ValidationException(_inner) => Some(_inner),
            ListSlotTypesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalServerException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ValidationException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartImportError {
    pub kind: StartImportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartImportErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartImportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartImportErrorKind::ConflictException(_inner) => _inner.fmt(f),
            StartImportErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            StartImportErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StartImportErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            StartImportErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartImportErrorKind::ValidationException(_inner) => _inner.fmt(f),
            StartImportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartImportError {
    fn code(&self) -> Option<&str> {
        StartImportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartImportError {
    pub fn new(kind: StartImportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartImportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartImportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, StartImportErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, StartImportErrorKind::InternalServerException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartImportErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartImportErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, StartImportErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, StartImportErrorKind::ValidationException(_))
    }
}
impl std::error::Error for StartImportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartImportErrorKind::ConflictException(_inner) => Some(_inner),
            StartImportErrorKind::InternalServerException(_inner) => Some(_inner),
            StartImportErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StartImportErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            StartImportErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartImportErrorKind::ValidationException(_inner) => Some(_inner),
            StartImportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InternalServerException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ValidationException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::InternalServerException(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            TagResourceErrorKind::ValidationException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::InternalServerException(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            UntagResourceErrorKind::ValidationException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateBotError {
    pub kind: UpdateBotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateBotErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateBotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateBotErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateBotErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateBotErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            UpdateBotErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            UpdateBotErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateBotErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateBotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateBotError {
    fn code(&self) -> Option<&str> {
        UpdateBotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateBotError {
    pub fn new(kind: UpdateBotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateBotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateBotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateBotErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, UpdateBotErrorKind::InternalServerException(_))
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBotErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBotErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateBotErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateBotErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateBotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateBotErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateBotErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateBotErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            UpdateBotErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            UpdateBotErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateBotErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateBotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateBotAliasError {
    pub kind: UpdateBotAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateBotAliasErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateBotAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateBotAliasErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateBotAliasErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateBotAliasErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            UpdateBotAliasErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            UpdateBotAliasErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateBotAliasErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateBotAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateBotAliasError {
    fn code(&self) -> Option<&str> {
        UpdateBotAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateBotAliasError {
    pub fn new(kind: UpdateBotAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateBotAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateBotAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateBotAliasErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBotAliasErrorKind::InternalServerException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBotAliasErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBotAliasErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateBotAliasErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateBotAliasErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateBotAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateBotAliasErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateBotAliasErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateBotAliasErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            UpdateBotAliasErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            UpdateBotAliasErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateBotAliasErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateBotAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateBotLocaleError {
    pub kind: UpdateBotLocaleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateBotLocaleErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateBotLocaleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateBotLocaleErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateBotLocaleErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateBotLocaleErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            UpdateBotLocaleErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            UpdateBotLocaleErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateBotLocaleErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateBotLocaleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateBotLocaleError {
    fn code(&self) -> Option<&str> {
        UpdateBotLocaleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateBotLocaleError {
    pub fn new(kind: UpdateBotLocaleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateBotLocaleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateBotLocaleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateBotLocaleErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBotLocaleErrorKind::InternalServerException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBotLocaleErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBotLocaleErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateBotLocaleErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateBotLocaleErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateBotLocaleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateBotLocaleErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateBotLocaleErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateBotLocaleErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            UpdateBotLocaleErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            UpdateBotLocaleErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateBotLocaleErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateBotLocaleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateExportError {
    pub kind: UpdateExportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateExportErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateExportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateExportErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateExportErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateExportErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateExportErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            UpdateExportErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateExportErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateExportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateExportError {
    fn code(&self) -> Option<&str> {
        UpdateExportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateExportError {
    pub fn new(kind: UpdateExportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateExportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateExportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateExportErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateExportErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateExportErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateExportErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateExportErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateExportErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateExportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateExportErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateExportErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateExportErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateExportErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            UpdateExportErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateExportErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateExportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateIntentError {
    pub kind: UpdateIntentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateIntentErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateIntentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateIntentErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateIntentErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateIntentErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            UpdateIntentErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            UpdateIntentErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateIntentErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateIntentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateIntentError {
    fn code(&self) -> Option<&str> {
        UpdateIntentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateIntentError {
    pub fn new(kind: UpdateIntentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateIntentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateIntentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateIntentErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIntentErrorKind::InternalServerException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIntentErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIntentErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateIntentErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateIntentErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateIntentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateIntentErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateIntentErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateIntentErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            UpdateIntentErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            UpdateIntentErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateIntentErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateIntentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateResourcePolicyError {
    pub kind: UpdateResourcePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateResourcePolicyErrorKind {
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateResourcePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateResourcePolicyErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateResourcePolicyErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            UpdateResourcePolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateResourcePolicyErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            UpdateResourcePolicyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateResourcePolicyErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateResourcePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateResourcePolicyError {
    fn code(&self) -> Option<&str> {
        UpdateResourcePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateResourcePolicyError {
    pub fn new(kind: UpdateResourcePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateResourcePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateResourcePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResourcePolicyErrorKind::InternalServerException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResourcePolicyErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResourcePolicyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResourcePolicyErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResourcePolicyErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResourcePolicyErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateResourcePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateResourcePolicyErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateResourcePolicyErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            UpdateResourcePolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateResourcePolicyErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            UpdateResourcePolicyErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateResourcePolicyErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateResourcePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSlotError {
    pub kind: UpdateSlotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSlotErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSlotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSlotErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateSlotErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateSlotErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            UpdateSlotErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            UpdateSlotErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateSlotErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateSlotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSlotError {
    fn code(&self) -> Option<&str> {
        UpdateSlotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSlotError {
    pub fn new(kind: UpdateSlotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSlotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSlotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateSlotErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, UpdateSlotErrorKind::InternalServerException(_))
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSlotErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSlotErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateSlotErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateSlotErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateSlotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSlotErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateSlotErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateSlotErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            UpdateSlotErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            UpdateSlotErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateSlotErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateSlotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSlotTypeError {
    pub kind: UpdateSlotTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSlotTypeErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSlotTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSlotTypeErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateSlotTypeErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateSlotTypeErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            UpdateSlotTypeErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            UpdateSlotTypeErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateSlotTypeErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateSlotTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSlotTypeError {
    fn code(&self) -> Option<&str> {
        UpdateSlotTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSlotTypeError {
    pub fn new(kind: UpdateSlotTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSlotTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSlotTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateSlotTypeErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSlotTypeErrorKind::InternalServerException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSlotTypeErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSlotTypeErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateSlotTypeErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateSlotTypeErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateSlotTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSlotTypeErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateSlotTypeErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateSlotTypeErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            UpdateSlotTypeErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            UpdateSlotTypeErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateSlotTypeErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateSlotTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidationException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ValidationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ValidationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ValidationException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ValidationException {}
/// See [`ValidationException`](crate::error::ValidationException)
pub mod validation_exception {
    /// A builder for [`ValidationException`](crate::error::ValidationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationException`](crate::error::ValidationException)
        pub fn build(self) -> crate::error::ValidationException {
            crate::error::ValidationException {
                message: self.message,
            }
        }
    }
}
impl ValidationException {
    /// Creates a new builder-style object to manufacture [`ValidationException`](crate::error::ValidationException)
    pub fn builder() -> crate::error::validation_exception::Builder {
        crate::error::validation_exception::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ThrottlingException {
    pub retry_after_seconds: i32,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ThrottlingException");
        formatter.field("retry_after_seconds", &self.retry_after_seconds);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ThrottlingException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottlingException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ThrottlingException {}
/// See [`ThrottlingException`](crate::error::ThrottlingException)
pub mod throttling_exception {
    /// A builder for [`ThrottlingException`](crate::error::ThrottlingException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) retry_after_seconds: std::option::Option<i32>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn retry_after_seconds(mut self, input: i32) -> Self {
            self.retry_after_seconds = Some(input);
            self
        }
        pub fn set_retry_after_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.retry_after_seconds = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ThrottlingException`](crate::error::ThrottlingException)
        pub fn build(self) -> crate::error::ThrottlingException {
            crate::error::ThrottlingException {
                retry_after_seconds: self.retry_after_seconds.unwrap_or_default(),
                message: self.message,
            }
        }
    }
}
impl ThrottlingException {
    /// Creates a new builder-style object to manufacture [`ThrottlingException`](crate::error::ThrottlingException)
    pub fn builder() -> crate::error::throttling_exception::Builder {
        crate::error::throttling_exception::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceQuotaExceededException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceQuotaExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceQuotaExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceQuotaExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceQuotaExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceQuotaExceededException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceQuotaExceededException {}
/// See [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
pub mod service_quota_exceeded_exception {
    /// A builder for [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
        pub fn build(self) -> crate::error::ServiceQuotaExceededException {
            crate::error::ServiceQuotaExceededException {
                message: self.message,
            }
        }
    }
}
impl ServiceQuotaExceededException {
    /// Creates a new builder-style object to manufacture [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
    pub fn builder() -> crate::error::service_quota_exceeded_exception::Builder {
        crate::error::service_quota_exceeded_exception::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PreconditionFailedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PreconditionFailedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PreconditionFailedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PreconditionFailedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PreconditionFailedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PreconditionFailedException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for PreconditionFailedException {}
/// See [`PreconditionFailedException`](crate::error::PreconditionFailedException)
pub mod precondition_failed_exception {
    /// A builder for [`PreconditionFailedException`](crate::error::PreconditionFailedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PreconditionFailedException`](crate::error::PreconditionFailedException)
        pub fn build(self) -> crate::error::PreconditionFailedException {
            crate::error::PreconditionFailedException {
                message: self.message,
            }
        }
    }
}
impl PreconditionFailedException {
    /// Creates a new builder-style object to manufacture [`PreconditionFailedException`](crate::error::PreconditionFailedException)
    pub fn builder() -> crate::error::precondition_failed_exception::Builder {
        crate::error::precondition_failed_exception::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServerException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServerException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalServerException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerException {}
/// See [`InternalServerException`](crate::error::InternalServerException)
pub mod internal_server_exception {
    /// A builder for [`InternalServerException`](crate::error::InternalServerException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServerException`](crate::error::InternalServerException)
        pub fn build(self) -> crate::error::InternalServerException {
            crate::error::InternalServerException {
                message: self.message,
            }
        }
    }
}
impl InternalServerException {
    /// Creates a new builder-style object to manufacture [`InternalServerException`](crate::error::InternalServerException)
    pub fn builder() -> crate::error::internal_server_exception::Builder {
        crate::error::internal_server_exception::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}
