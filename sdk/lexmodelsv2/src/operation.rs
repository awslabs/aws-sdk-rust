// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Builds a bot, its intents, and its slot types into a specific
/// locale. A bot can be built into multiple locales. At runtime the locale
/// is used to choose a specific build of the bot.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BuildBotLocale {
    _private: (),
}
impl BuildBotLocale {
    /// Creates a new builder-style object to manufacture [`BuildBotLocaleInput`](crate::input::BuildBotLocaleInput)
    pub fn builder() -> crate::input::build_bot_locale_input::Builder {
        crate::input::build_bot_locale_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BuildBotLocale {
    type Output =
        std::result::Result<crate::output::BuildBotLocaleOutput, crate::error::BuildBotLocaleError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 202 {
            crate::operation_deser::parse_build_bot_locale_error(response)
        } else {
            crate::operation_deser::parse_build_bot_locale_response(response)
        }
    }
}

/// <p>Creates an Amazon Lex conversational bot. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateBot {
    _private: (),
}
impl CreateBot {
    /// Creates a new builder-style object to manufacture [`CreateBotInput`](crate::input::CreateBotInput)
    pub fn builder() -> crate::input::create_bot_input::Builder {
        crate::input::create_bot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateBot {
    type Output = std::result::Result<crate::output::CreateBotOutput, crate::error::CreateBotError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 202 {
            crate::operation_deser::parse_create_bot_error(response)
        } else {
            crate::operation_deser::parse_create_bot_response(response)
        }
    }
}

/// <p>Creates an alias for the specified version of a bot. Use an alias to
/// enable you to change the version of a bot without updating applications
/// that use the bot.</p>
/// <p>For example, you can create an alias called "PROD" that your
/// applications use to call the Amazon Lex bot. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateBotAlias {
    _private: (),
}
impl CreateBotAlias {
    /// Creates a new builder-style object to manufacture [`CreateBotAliasInput`](crate::input::CreateBotAliasInput)
    pub fn builder() -> crate::input::create_bot_alias_input::Builder {
        crate::input::create_bot_alias_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateBotAlias {
    type Output =
        std::result::Result<crate::output::CreateBotAliasOutput, crate::error::CreateBotAliasError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 202 {
            crate::operation_deser::parse_create_bot_alias_error(response)
        } else {
            crate::operation_deser::parse_create_bot_alias_response(response)
        }
    }
}

/// <p>Creates a locale in the bot. The locale contains the intents and
/// slot types that the bot uses in conversations with users in the
/// specified language and locale. You must add a locale to a bot before
/// you can add intents and slot types to the bot.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateBotLocale {
    _private: (),
}
impl CreateBotLocale {
    /// Creates a new builder-style object to manufacture [`CreateBotLocaleInput`](crate::input::CreateBotLocaleInput)
    pub fn builder() -> crate::input::create_bot_locale_input::Builder {
        crate::input::create_bot_locale_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateBotLocale {
    type Output = std::result::Result<
        crate::output::CreateBotLocaleOutput,
        crate::error::CreateBotLocaleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 202 {
            crate::operation_deser::parse_create_bot_locale_error(response)
        } else {
            crate::operation_deser::parse_create_bot_locale_response(response)
        }
    }
}

/// <p>Creates a new version of the bot based on the <code>DRAFT</code>
/// version. If the <code>DRAFT</code> version of this resource hasn't
/// changed since you created the last version, Amazon Lex doesn't create a new
/// version, it returns the last created version.</p>
/// <p>When you create the first version of a bot, Amazon Lex sets the version
/// to 1. Subsequent versions increment by 1.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateBotVersion {
    _private: (),
}
impl CreateBotVersion {
    /// Creates a new builder-style object to manufacture [`CreateBotVersionInput`](crate::input::CreateBotVersionInput)
    pub fn builder() -> crate::input::create_bot_version_input::Builder {
        crate::input::create_bot_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateBotVersion {
    type Output = std::result::Result<
        crate::output::CreateBotVersionOutput,
        crate::error::CreateBotVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 202 {
            crate::operation_deser::parse_create_bot_version_error(response)
        } else {
            crate::operation_deser::parse_create_bot_version_response(response)
        }
    }
}

/// <p>Creates a zip archive containing the contents of a bot or a bot
/// locale. The archive contains a directory structure that contains JSON
/// files that define the bot.</p>
/// <p>You can create an archive that contains the complete definition of a
/// bot, or you can specify that the archive contain only the definition of
/// a single bot locale.</p>
/// <p>For more information about exporting bots, and about the structure
/// of the export archive, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/importing-exporting.html"> Importing and
/// exporting bots </a>
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateExport {
    _private: (),
}
impl CreateExport {
    /// Creates a new builder-style object to manufacture [`CreateExportInput`](crate::input::CreateExportInput)
    pub fn builder() -> crate::input::create_export_input::Builder {
        crate::input::create_export_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateExport {
    type Output =
        std::result::Result<crate::output::CreateExportOutput, crate::error::CreateExportError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 202 {
            crate::operation_deser::parse_create_export_error(response)
        } else {
            crate::operation_deser::parse_create_export_response(response)
        }
    }
}

/// <p>Creates an intent.</p>
/// <p>To define the interaction between the user and your bot, you define
/// one or more intents. For example, for a pizza ordering bot you would
/// create an <code>OrderPizza</code> intent.</p>
/// <p>When you create an intent, you must provide a name. You can
/// optionally provide the following:</p>
/// <ul>
/// <li>
/// <p>Sample utterances. For example, "I want to order a pizza" and
/// "Can I order a pizza." You can't provide utterances for built-in
/// intents.</p>
/// </li>
/// <li>
/// <p>Information to be gathered. You specify slots for the
/// information that you bot requests from the user. You can specify
/// standard slot types, such as date and time, or custom slot types
/// for your application.</p>
/// </li>
/// <li>
/// <p>How the intent is fulfilled. You can provide a Lambda function
/// or configure the intent to return the intent information to your
/// client application. If you use a Lambda function, Amazon Lex invokes
/// the function when all of the intent information is
/// available.</p>
/// </li>
/// <li>
/// <p>A confirmation prompt to send to the user to confirm an
/// intent. For example, "Shall I order your pizza?"</p>
/// </li>
/// <li>
/// <p>A conclusion statement to send to the user after the intent is
/// fulfilled. For example, "I ordered your pizza."</p>
/// </li>
/// <li>
/// <p>A follow-up prompt that asks the user for additional activity.
/// For example, "Do you want a drink with your pizza?"</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateIntent {
    _private: (),
}
impl CreateIntent {
    /// Creates a new builder-style object to manufacture [`CreateIntentInput`](crate::input::CreateIntentInput)
    pub fn builder() -> crate::input::create_intent_input::Builder {
        crate::input::create_intent_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateIntent {
    type Output =
        std::result::Result<crate::output::CreateIntentOutput, crate::error::CreateIntentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_intent_error(response)
        } else {
            crate::operation_deser::parse_create_intent_response(response)
        }
    }
}

/// <p>Creates a new resource policy with the specified policy
/// statements.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateResourcePolicy {
    _private: (),
}
impl CreateResourcePolicy {
    /// Creates a new builder-style object to manufacture [`CreateResourcePolicyInput`](crate::input::CreateResourcePolicyInput)
    pub fn builder() -> crate::input::create_resource_policy_input::Builder {
        crate::input::create_resource_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateResourcePolicy {
    type Output = std::result::Result<
        crate::output::CreateResourcePolicyOutput,
        crate::error::CreateResourcePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_resource_policy_error(response)
        } else {
            crate::operation_deser::parse_create_resource_policy_response(response)
        }
    }
}

/// <p>Adds a new resource policy statement to a bot or bot alias. If a
/// resource policy exists, the statement is added to the current resource
/// policy. If a policy doesn't exist, a new policy is created.</p>
/// <p>You can't create a resource policy statement that allows
/// cross-account access.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateResourcePolicyStatement {
    _private: (),
}
impl CreateResourcePolicyStatement {
    /// Creates a new builder-style object to manufacture [`CreateResourcePolicyStatementInput`](crate::input::CreateResourcePolicyStatementInput)
    pub fn builder() -> crate::input::create_resource_policy_statement_input::Builder {
        crate::input::create_resource_policy_statement_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateResourcePolicyStatement {
    type Output = std::result::Result<
        crate::output::CreateResourcePolicyStatementOutput,
        crate::error::CreateResourcePolicyStatementError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_resource_policy_statement_error(response)
        } else {
            crate::operation_deser::parse_create_resource_policy_statement_response(response)
        }
    }
}

/// <p>Creates a slot in an intent. A slot is a variable needed to fulfill
/// an intent. For example, an <code>OrderPizza</code> intent might need
/// slots for size, crust, and number of pizzas. For each slot, you define
/// one or more utterances that Amazon Lex uses to elicit a response from the
/// user. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateSlot {
    _private: (),
}
impl CreateSlot {
    /// Creates a new builder-style object to manufacture [`CreateSlotInput`](crate::input::CreateSlotInput)
    pub fn builder() -> crate::input::create_slot_input::Builder {
        crate::input::create_slot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateSlot {
    type Output =
        std::result::Result<crate::output::CreateSlotOutput, crate::error::CreateSlotError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_slot_error(response)
        } else {
            crate::operation_deser::parse_create_slot_response(response)
        }
    }
}

/// <p>Creates a custom slot type</p>
/// <p> To create a custom slot type, specify a name for the slot type and
/// a set of enumeration values, the values that a slot of this type can
/// assume. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateSlotType {
    _private: (),
}
impl CreateSlotType {
    /// Creates a new builder-style object to manufacture [`CreateSlotTypeInput`](crate::input::CreateSlotTypeInput)
    pub fn builder() -> crate::input::create_slot_type_input::Builder {
        crate::input::create_slot_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateSlotType {
    type Output =
        std::result::Result<crate::output::CreateSlotTypeOutput, crate::error::CreateSlotTypeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_slot_type_error(response)
        } else {
            crate::operation_deser::parse_create_slot_type_response(response)
        }
    }
}

/// <p>Gets a pre-signed S3 write URL that you use to upload the zip
/// archive when importing a bot or a bot locale. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateUploadUrl {
    _private: (),
}
impl CreateUploadUrl {
    /// Creates a new builder-style object to manufacture [`CreateUploadUrlInput`](crate::input::CreateUploadUrlInput)
    pub fn builder() -> crate::input::create_upload_url_input::Builder {
        crate::input::create_upload_url_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateUploadUrl {
    type Output = std::result::Result<
        crate::output::CreateUploadUrlOutput,
        crate::error::CreateUploadUrlError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_upload_url_error(response)
        } else {
            crate::operation_deser::parse_create_upload_url_response(response)
        }
    }
}

/// <p>Deletes all versions of a bot, including the <code>Draft</code>
/// version. To delete a specific version, use the
/// <code>DeleteBotVersion</code> operation.</p>
/// <p>When you delete a bot, all of the resources contained in the bot are
/// also deleted. Deleting a bot removes all locales, intents, slot, and
/// slot types defined for the bot.</p>
/// <p>If a bot has an alias, the <code>DeleteBot</code> operation returns
/// a <code>ResourceInUseException</code> exception. If you want to delete
/// the bot and the alias, set the <code>skipResourceInUseCheck</code>
/// parameter to <code>true</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteBot {
    _private: (),
}
impl DeleteBot {
    /// Creates a new builder-style object to manufacture [`DeleteBotInput`](crate::input::DeleteBotInput)
    pub fn builder() -> crate::input::delete_bot_input::Builder {
        crate::input::delete_bot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteBot {
    type Output = std::result::Result<crate::output::DeleteBotOutput, crate::error::DeleteBotError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 202 {
            crate::operation_deser::parse_delete_bot_error(response)
        } else {
            crate::operation_deser::parse_delete_bot_response(response)
        }
    }
}

/// <p>Deletes the specified bot alias.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteBotAlias {
    _private: (),
}
impl DeleteBotAlias {
    /// Creates a new builder-style object to manufacture [`DeleteBotAliasInput`](crate::input::DeleteBotAliasInput)
    pub fn builder() -> crate::input::delete_bot_alias_input::Builder {
        crate::input::delete_bot_alias_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteBotAlias {
    type Output =
        std::result::Result<crate::output::DeleteBotAliasOutput, crate::error::DeleteBotAliasError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 202 {
            crate::operation_deser::parse_delete_bot_alias_error(response)
        } else {
            crate::operation_deser::parse_delete_bot_alias_response(response)
        }
    }
}

/// <p>Removes a locale from a bot.</p>
/// <p>When you delete a locale, all intents, slots, and slot types defined
/// for the locale are also deleted.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteBotLocale {
    _private: (),
}
impl DeleteBotLocale {
    /// Creates a new builder-style object to manufacture [`DeleteBotLocaleInput`](crate::input::DeleteBotLocaleInput)
    pub fn builder() -> crate::input::delete_bot_locale_input::Builder {
        crate::input::delete_bot_locale_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteBotLocale {
    type Output = std::result::Result<
        crate::output::DeleteBotLocaleOutput,
        crate::error::DeleteBotLocaleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 202 {
            crate::operation_deser::parse_delete_bot_locale_error(response)
        } else {
            crate::operation_deser::parse_delete_bot_locale_response(response)
        }
    }
}

/// <p>Deletes a specific version of a bot. To delete all version of a bot,
/// use the <a>DeleteBot</a> operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteBotVersion {
    _private: (),
}
impl DeleteBotVersion {
    /// Creates a new builder-style object to manufacture [`DeleteBotVersionInput`](crate::input::DeleteBotVersionInput)
    pub fn builder() -> crate::input::delete_bot_version_input::Builder {
        crate::input::delete_bot_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteBotVersion {
    type Output = std::result::Result<
        crate::output::DeleteBotVersionOutput,
        crate::error::DeleteBotVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 202 {
            crate::operation_deser::parse_delete_bot_version_error(response)
        } else {
            crate::operation_deser::parse_delete_bot_version_response(response)
        }
    }
}

/// <p>Removes a previous export and the associated files stored in an S3
/// bucket.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteExport {
    _private: (),
}
impl DeleteExport {
    /// Creates a new builder-style object to manufacture [`DeleteExportInput`](crate::input::DeleteExportInput)
    pub fn builder() -> crate::input::delete_export_input::Builder {
        crate::input::delete_export_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteExport {
    type Output =
        std::result::Result<crate::output::DeleteExportOutput, crate::error::DeleteExportError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 202 {
            crate::operation_deser::parse_delete_export_error(response)
        } else {
            crate::operation_deser::parse_delete_export_response(response)
        }
    }
}

/// <p>Removes a previous import and the associated file stored in an S3
/// bucket.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteImport {
    _private: (),
}
impl DeleteImport {
    /// Creates a new builder-style object to manufacture [`DeleteImportInput`](crate::input::DeleteImportInput)
    pub fn builder() -> crate::input::delete_import_input::Builder {
        crate::input::delete_import_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteImport {
    type Output =
        std::result::Result<crate::output::DeleteImportOutput, crate::error::DeleteImportError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 202 {
            crate::operation_deser::parse_delete_import_error(response)
        } else {
            crate::operation_deser::parse_delete_import_response(response)
        }
    }
}

/// <p>Removes the specified intent.</p>
/// <p>Deleting an intent also deletes the slots associated with the
/// intent.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteIntent {
    _private: (),
}
impl DeleteIntent {
    /// Creates a new builder-style object to manufacture [`DeleteIntentInput`](crate::input::DeleteIntentInput)
    pub fn builder() -> crate::input::delete_intent_input::Builder {
        crate::input::delete_intent_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteIntent {
    type Output =
        std::result::Result<crate::output::DeleteIntentOutput, crate::error::DeleteIntentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_intent_error(response)
        } else {
            crate::operation_deser::parse_delete_intent_response(response)
        }
    }
}

/// <p>Removes an existing policy from a bot or bot alias. If the resource
/// doesn't have a policy attached, Amazon Lex returns an exception.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteResourcePolicy {
    _private: (),
}
impl DeleteResourcePolicy {
    /// Creates a new builder-style object to manufacture [`DeleteResourcePolicyInput`](crate::input::DeleteResourcePolicyInput)
    pub fn builder() -> crate::input::delete_resource_policy_input::Builder {
        crate::input::delete_resource_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteResourcePolicy {
    type Output = std::result::Result<
        crate::output::DeleteResourcePolicyOutput,
        crate::error::DeleteResourcePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_resource_policy_error(response)
        } else {
            crate::operation_deser::parse_delete_resource_policy_response(response)
        }
    }
}

/// <p>Deletes a policy statement from a resource policy. If you delete the
/// last statement from a policy, the policy is deleted. If you specify a
/// statement ID that doesn't exist in the policy, or if the bot or bot
/// alias doesn't have a policy attached, Amazon Lex returns an
/// exception.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteResourcePolicyStatement {
    _private: (),
}
impl DeleteResourcePolicyStatement {
    /// Creates a new builder-style object to manufacture [`DeleteResourcePolicyStatementInput`](crate::input::DeleteResourcePolicyStatementInput)
    pub fn builder() -> crate::input::delete_resource_policy_statement_input::Builder {
        crate::input::delete_resource_policy_statement_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteResourcePolicyStatement {
    type Output = std::result::Result<
        crate::output::DeleteResourcePolicyStatementOutput,
        crate::error::DeleteResourcePolicyStatementError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_resource_policy_statement_error(response)
        } else {
            crate::operation_deser::parse_delete_resource_policy_statement_response(response)
        }
    }
}

/// <p>Deletes the specified slot from an intent.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteSlot {
    _private: (),
}
impl DeleteSlot {
    /// Creates a new builder-style object to manufacture [`DeleteSlotInput`](crate::input::DeleteSlotInput)
    pub fn builder() -> crate::input::delete_slot_input::Builder {
        crate::input::delete_slot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteSlot {
    type Output =
        std::result::Result<crate::output::DeleteSlotOutput, crate::error::DeleteSlotError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_slot_error(response)
        } else {
            crate::operation_deser::parse_delete_slot_response(response)
        }
    }
}

/// <p>Deletes a slot type from a bot locale.</p>
/// <p>If a slot is using the slot type, Amazon Lex throws a
/// <code>ResourceInUseException</code> exception. To avoid the
/// exception, set the <code>skipResourceInUseCheck</code> parameter to
/// <code>true</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteSlotType {
    _private: (),
}
impl DeleteSlotType {
    /// Creates a new builder-style object to manufacture [`DeleteSlotTypeInput`](crate::input::DeleteSlotTypeInput)
    pub fn builder() -> crate::input::delete_slot_type_input::Builder {
        crate::input::delete_slot_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteSlotType {
    type Output =
        std::result::Result<crate::output::DeleteSlotTypeOutput, crate::error::DeleteSlotTypeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_slot_type_error(response)
        } else {
            crate::operation_deser::parse_delete_slot_type_response(response)
        }
    }
}

/// <p>Deletes stored utterances.</p>
/// <p>Amazon Lex stores the utterances that users send to your bot. Utterances
/// are stored for 15 days for use with the  operation, and then stored
/// indefinitely for use in improving the ability of your bot to respond to
/// user input..</p>
/// <p>Use the <code>DeleteUtterances</code> operation to manually delete
/// utterances for a specific session. When you use the
/// <code>DeleteUtterances</code> operation, utterances stored for
/// improving your bot's ability to respond to user input are deleted
/// immediately. Utterances stored for use with the
/// <code>ListAggregatedUtterances</code> operation are deleted after 15
/// days.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteUtterances {
    _private: (),
}
impl DeleteUtterances {
    /// Creates a new builder-style object to manufacture [`DeleteUtterancesInput`](crate::input::DeleteUtterancesInput)
    pub fn builder() -> crate::input::delete_utterances_input::Builder {
        crate::input::delete_utterances_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteUtterances {
    type Output = std::result::Result<
        crate::output::DeleteUtterancesOutput,
        crate::error::DeleteUtterancesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_utterances_error(response)
        } else {
            crate::operation_deser::parse_delete_utterances_response(response)
        }
    }
}

/// <p>Provides metadata information about a bot. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeBot {
    _private: (),
}
impl DescribeBot {
    /// Creates a new builder-style object to manufacture [`DescribeBotInput`](crate::input::DescribeBotInput)
    pub fn builder() -> crate::input::describe_bot_input::Builder {
        crate::input::describe_bot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeBot {
    type Output =
        std::result::Result<crate::output::DescribeBotOutput, crate::error::DescribeBotError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_bot_error(response)
        } else {
            crate::operation_deser::parse_describe_bot_response(response)
        }
    }
}

/// <p>Get information about a specific bot alias.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeBotAlias {
    _private: (),
}
impl DescribeBotAlias {
    /// Creates a new builder-style object to manufacture [`DescribeBotAliasInput`](crate::input::DescribeBotAliasInput)
    pub fn builder() -> crate::input::describe_bot_alias_input::Builder {
        crate::input::describe_bot_alias_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeBotAlias {
    type Output = std::result::Result<
        crate::output::DescribeBotAliasOutput,
        crate::error::DescribeBotAliasError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_bot_alias_error(response)
        } else {
            crate::operation_deser::parse_describe_bot_alias_response(response)
        }
    }
}

/// <p>Describes the settings that a bot has for a specific locale. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeBotLocale {
    _private: (),
}
impl DescribeBotLocale {
    /// Creates a new builder-style object to manufacture [`DescribeBotLocaleInput`](crate::input::DescribeBotLocaleInput)
    pub fn builder() -> crate::input::describe_bot_locale_input::Builder {
        crate::input::describe_bot_locale_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeBotLocale {
    type Output = std::result::Result<
        crate::output::DescribeBotLocaleOutput,
        crate::error::DescribeBotLocaleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_bot_locale_error(response)
        } else {
            crate::operation_deser::parse_describe_bot_locale_response(response)
        }
    }
}

/// <p>Provides metadata about a version of a bot.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeBotVersion {
    _private: (),
}
impl DescribeBotVersion {
    /// Creates a new builder-style object to manufacture [`DescribeBotVersionInput`](crate::input::DescribeBotVersionInput)
    pub fn builder() -> crate::input::describe_bot_version_input::Builder {
        crate::input::describe_bot_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeBotVersion {
    type Output = std::result::Result<
        crate::output::DescribeBotVersionOutput,
        crate::error::DescribeBotVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_bot_version_error(response)
        } else {
            crate::operation_deser::parse_describe_bot_version_response(response)
        }
    }
}

/// <p>Gets information about a specific export.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeExport {
    _private: (),
}
impl DescribeExport {
    /// Creates a new builder-style object to manufacture [`DescribeExportInput`](crate::input::DescribeExportInput)
    pub fn builder() -> crate::input::describe_export_input::Builder {
        crate::input::describe_export_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeExport {
    type Output =
        std::result::Result<crate::output::DescribeExportOutput, crate::error::DescribeExportError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_export_error(response)
        } else {
            crate::operation_deser::parse_describe_export_response(response)
        }
    }
}

/// <p>Gets information about a specific import.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeImport {
    _private: (),
}
impl DescribeImport {
    /// Creates a new builder-style object to manufacture [`DescribeImportInput`](crate::input::DescribeImportInput)
    pub fn builder() -> crate::input::describe_import_input::Builder {
        crate::input::describe_import_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeImport {
    type Output =
        std::result::Result<crate::output::DescribeImportOutput, crate::error::DescribeImportError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_import_error(response)
        } else {
            crate::operation_deser::parse_describe_import_response(response)
        }
    }
}

/// <p>Returns metadata about an intent.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeIntent {
    _private: (),
}
impl DescribeIntent {
    /// Creates a new builder-style object to manufacture [`DescribeIntentInput`](crate::input::DescribeIntentInput)
    pub fn builder() -> crate::input::describe_intent_input::Builder {
        crate::input::describe_intent_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeIntent {
    type Output =
        std::result::Result<crate::output::DescribeIntentOutput, crate::error::DescribeIntentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_intent_error(response)
        } else {
            crate::operation_deser::parse_describe_intent_response(response)
        }
    }
}

/// <p>Gets the resource policy and policy revision for a bot or bot
/// alias.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeResourcePolicy {
    _private: (),
}
impl DescribeResourcePolicy {
    /// Creates a new builder-style object to manufacture [`DescribeResourcePolicyInput`](crate::input::DescribeResourcePolicyInput)
    pub fn builder() -> crate::input::describe_resource_policy_input::Builder {
        crate::input::describe_resource_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeResourcePolicy {
    type Output = std::result::Result<
        crate::output::DescribeResourcePolicyOutput,
        crate::error::DescribeResourcePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_resource_policy_error(response)
        } else {
            crate::operation_deser::parse_describe_resource_policy_response(response)
        }
    }
}

/// <p>Gets metadata information about a slot.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeSlot {
    _private: (),
}
impl DescribeSlot {
    /// Creates a new builder-style object to manufacture [`DescribeSlotInput`](crate::input::DescribeSlotInput)
    pub fn builder() -> crate::input::describe_slot_input::Builder {
        crate::input::describe_slot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeSlot {
    type Output =
        std::result::Result<crate::output::DescribeSlotOutput, crate::error::DescribeSlotError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_slot_error(response)
        } else {
            crate::operation_deser::parse_describe_slot_response(response)
        }
    }
}

/// <p>Gets metadata information about a slot type.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeSlotType {
    _private: (),
}
impl DescribeSlotType {
    /// Creates a new builder-style object to manufacture [`DescribeSlotTypeInput`](crate::input::DescribeSlotTypeInput)
    pub fn builder() -> crate::input::describe_slot_type_input::Builder {
        crate::input::describe_slot_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeSlotType {
    type Output = std::result::Result<
        crate::output::DescribeSlotTypeOutput,
        crate::error::DescribeSlotTypeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_slot_type_error(response)
        } else {
            crate::operation_deser::parse_describe_slot_type_response(response)
        }
    }
}

/// <p>Provides a list of utterances that users have sent to the
/// bot.</p>
/// <p>Utterances are aggregated by the text of the utterance. For example,
/// all instances where customers used the phrase "I want to order pizza"
/// are aggregated into the same line in the response.</p>
/// <p>You can see both detected utterances and missed utterances. A
/// detected utterance is where the bot properly recognized the utterance
/// and activated the associated intent. A missed utterance was not
/// recognized by the bot and didn't activate an intent.</p>
/// <p>Utterances can be aggregated for a bot alias or for a bot version,
/// but not both at the same time.</p>
/// <p>Utterances statistics are not generated under the following
/// conditions:</p>
/// <ul>
/// <li>
/// <p>The <code>childDirected</code> field was set to true when the
/// bot was created.</p>
/// </li>
/// <li>
/// <p>You are using slot obfuscation with one or more slots.</p>
/// </li>
/// <li>
/// <p>You opted out of participating in improving Amazon Lex.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListAggregatedUtterances {
    _private: (),
}
impl ListAggregatedUtterances {
    /// Creates a new builder-style object to manufacture [`ListAggregatedUtterancesInput`](crate::input::ListAggregatedUtterancesInput)
    pub fn builder() -> crate::input::list_aggregated_utterances_input::Builder {
        crate::input::list_aggregated_utterances_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListAggregatedUtterances {
    type Output = std::result::Result<
        crate::output::ListAggregatedUtterancesOutput,
        crate::error::ListAggregatedUtterancesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_aggregated_utterances_error(response)
        } else {
            crate::operation_deser::parse_list_aggregated_utterances_response(response)
        }
    }
}

/// <p>Gets a list of aliases for the specified bot.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListBotAliases {
    _private: (),
}
impl ListBotAliases {
    /// Creates a new builder-style object to manufacture [`ListBotAliasesInput`](crate::input::ListBotAliasesInput)
    pub fn builder() -> crate::input::list_bot_aliases_input::Builder {
        crate::input::list_bot_aliases_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListBotAliases {
    type Output =
        std::result::Result<crate::output::ListBotAliasesOutput, crate::error::ListBotAliasesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_bot_aliases_error(response)
        } else {
            crate::operation_deser::parse_list_bot_aliases_response(response)
        }
    }
}

/// <p>Gets a list of locales for the specified bot.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListBotLocales {
    _private: (),
}
impl ListBotLocales {
    /// Creates a new builder-style object to manufacture [`ListBotLocalesInput`](crate::input::ListBotLocalesInput)
    pub fn builder() -> crate::input::list_bot_locales_input::Builder {
        crate::input::list_bot_locales_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListBotLocales {
    type Output =
        std::result::Result<crate::output::ListBotLocalesOutput, crate::error::ListBotLocalesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_bot_locales_error(response)
        } else {
            crate::operation_deser::parse_list_bot_locales_response(response)
        }
    }
}

/// <p>Gets a list of available bots.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListBots {
    _private: (),
}
impl ListBots {
    /// Creates a new builder-style object to manufacture [`ListBotsInput`](crate::input::ListBotsInput)
    pub fn builder() -> crate::input::list_bots_input::Builder {
        crate::input::list_bots_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListBots {
    type Output = std::result::Result<crate::output::ListBotsOutput, crate::error::ListBotsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_bots_error(response)
        } else {
            crate::operation_deser::parse_list_bots_response(response)
        }
    }
}

/// <p>Gets information about all of the versions of a bot.</p>
/// <p>The <code>ListBotVersions</code> operation returns a summary of each
/// version of a bot. For example, if a bot has three numbered versions,
/// the <code>ListBotVersions</code> operation returns for summaries, one
/// for each numbered version and one for the <code>DRAFT</code>
/// version.</p>
/// <p>The <code>ListBotVersions</code> operation always returns at least
/// one version, the <code>DRAFT</code> version.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListBotVersions {
    _private: (),
}
impl ListBotVersions {
    /// Creates a new builder-style object to manufacture [`ListBotVersionsInput`](crate::input::ListBotVersionsInput)
    pub fn builder() -> crate::input::list_bot_versions_input::Builder {
        crate::input::list_bot_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListBotVersions {
    type Output = std::result::Result<
        crate::output::ListBotVersionsOutput,
        crate::error::ListBotVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_bot_versions_error(response)
        } else {
            crate::operation_deser::parse_list_bot_versions_response(response)
        }
    }
}

/// <p>Gets a list of built-in intents provided by Amazon Lex that you can use
/// in your bot. </p>
/// <p>To use a built-in intent as a the base for your own intent, include
/// the built-in intent signature in the <code>parentIntentSignature</code>
/// parameter when you call the <code>CreateIntent</code> operation. For
/// more information, see <a>CreateIntent</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListBuiltInIntents {
    _private: (),
}
impl ListBuiltInIntents {
    /// Creates a new builder-style object to manufacture [`ListBuiltInIntentsInput`](crate::input::ListBuiltInIntentsInput)
    pub fn builder() -> crate::input::list_built_in_intents_input::Builder {
        crate::input::list_built_in_intents_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListBuiltInIntents {
    type Output = std::result::Result<
        crate::output::ListBuiltInIntentsOutput,
        crate::error::ListBuiltInIntentsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_built_in_intents_error(response)
        } else {
            crate::operation_deser::parse_list_built_in_intents_response(response)
        }
    }
}

/// <p>Gets a list of built-in slot types that meet the specified
/// criteria.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListBuiltInSlotTypes {
    _private: (),
}
impl ListBuiltInSlotTypes {
    /// Creates a new builder-style object to manufacture [`ListBuiltInSlotTypesInput`](crate::input::ListBuiltInSlotTypesInput)
    pub fn builder() -> crate::input::list_built_in_slot_types_input::Builder {
        crate::input::list_built_in_slot_types_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListBuiltInSlotTypes {
    type Output = std::result::Result<
        crate::output::ListBuiltInSlotTypesOutput,
        crate::error::ListBuiltInSlotTypesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_built_in_slot_types_error(response)
        } else {
            crate::operation_deser::parse_list_built_in_slot_types_response(response)
        }
    }
}

/// <p>Lists the exports for a bot or bot locale. Exports are kept in the
/// list for 7 days.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListExports {
    _private: (),
}
impl ListExports {
    /// Creates a new builder-style object to manufacture [`ListExportsInput`](crate::input::ListExportsInput)
    pub fn builder() -> crate::input::list_exports_input::Builder {
        crate::input::list_exports_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListExports {
    type Output =
        std::result::Result<crate::output::ListExportsOutput, crate::error::ListExportsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_exports_error(response)
        } else {
            crate::operation_deser::parse_list_exports_response(response)
        }
    }
}

/// <p>Lists the imports for a bot or bot locale. Imports are kept in the
/// list for 7 days.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListImports {
    _private: (),
}
impl ListImports {
    /// Creates a new builder-style object to manufacture [`ListImportsInput`](crate::input::ListImportsInput)
    pub fn builder() -> crate::input::list_imports_input::Builder {
        crate::input::list_imports_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListImports {
    type Output =
        std::result::Result<crate::output::ListImportsOutput, crate::error::ListImportsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_imports_error(response)
        } else {
            crate::operation_deser::parse_list_imports_response(response)
        }
    }
}

/// <p>Get a list of intents that meet the specified criteria.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListIntents {
    _private: (),
}
impl ListIntents {
    /// Creates a new builder-style object to manufacture [`ListIntentsInput`](crate::input::ListIntentsInput)
    pub fn builder() -> crate::input::list_intents_input::Builder {
        crate::input::list_intents_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListIntents {
    type Output =
        std::result::Result<crate::output::ListIntentsOutput, crate::error::ListIntentsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_intents_error(response)
        } else {
            crate::operation_deser::parse_list_intents_response(response)
        }
    }
}

/// <p>Gets a list of slots that match the specified criteria.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListSlots {
    _private: (),
}
impl ListSlots {
    /// Creates a new builder-style object to manufacture [`ListSlotsInput`](crate::input::ListSlotsInput)
    pub fn builder() -> crate::input::list_slots_input::Builder {
        crate::input::list_slots_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListSlots {
    type Output = std::result::Result<crate::output::ListSlotsOutput, crate::error::ListSlotsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_slots_error(response)
        } else {
            crate::operation_deser::parse_list_slots_response(response)
        }
    }
}

/// <p>Gets a list of slot types that match the specified criteria.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListSlotTypes {
    _private: (),
}
impl ListSlotTypes {
    /// Creates a new builder-style object to manufacture [`ListSlotTypesInput`](crate::input::ListSlotTypesInput)
    pub fn builder() -> crate::input::list_slot_types_input::Builder {
        crate::input::list_slot_types_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListSlotTypes {
    type Output =
        std::result::Result<crate::output::ListSlotTypesOutput, crate::error::ListSlotTypesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_slot_types_error(response)
        } else {
            crate::operation_deser::parse_list_slot_types_response(response)
        }
    }
}

/// <p>Gets a list of tags associated with a resource. Only bots, bot
/// aliases, and bot channels can have tags associated with them.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Starts importing a bot or bot locale from a zip archive that you
/// uploaded to an S3 bucket.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartImport {
    _private: (),
}
impl StartImport {
    /// Creates a new builder-style object to manufacture [`StartImportInput`](crate::input::StartImportInput)
    pub fn builder() -> crate::input::start_import_input::Builder {
        crate::input::start_import_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartImport {
    type Output =
        std::result::Result<crate::output::StartImportOutput, crate::error::StartImportError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 202 {
            crate::operation_deser::parse_start_import_error(response)
        } else {
            crate::operation_deser::parse_start_import_response(response)
        }
    }
}

/// <p>Adds the specified tags to the specified resource. If a tag key
/// already exists, the existing value is replaced with the new
/// value.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Removes tags from a bot, bot alias, or bot channel.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Updates the configuration of an existing bot. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateBot {
    _private: (),
}
impl UpdateBot {
    /// Creates a new builder-style object to manufacture [`UpdateBotInput`](crate::input::UpdateBotInput)
    pub fn builder() -> crate::input::update_bot_input::Builder {
        crate::input::update_bot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateBot {
    type Output = std::result::Result<crate::output::UpdateBotOutput, crate::error::UpdateBotError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 202 {
            crate::operation_deser::parse_update_bot_error(response)
        } else {
            crate::operation_deser::parse_update_bot_response(response)
        }
    }
}

/// <p>Updates the configuration of an existing bot alias.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateBotAlias {
    _private: (),
}
impl UpdateBotAlias {
    /// Creates a new builder-style object to manufacture [`UpdateBotAliasInput`](crate::input::UpdateBotAliasInput)
    pub fn builder() -> crate::input::update_bot_alias_input::Builder {
        crate::input::update_bot_alias_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateBotAlias {
    type Output =
        std::result::Result<crate::output::UpdateBotAliasOutput, crate::error::UpdateBotAliasError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 202 {
            crate::operation_deser::parse_update_bot_alias_error(response)
        } else {
            crate::operation_deser::parse_update_bot_alias_response(response)
        }
    }
}

/// <p>Updates the settings that a bot has for a specific locale.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateBotLocale {
    _private: (),
}
impl UpdateBotLocale {
    /// Creates a new builder-style object to manufacture [`UpdateBotLocaleInput`](crate::input::UpdateBotLocaleInput)
    pub fn builder() -> crate::input::update_bot_locale_input::Builder {
        crate::input::update_bot_locale_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateBotLocale {
    type Output = std::result::Result<
        crate::output::UpdateBotLocaleOutput,
        crate::error::UpdateBotLocaleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 202 {
            crate::operation_deser::parse_update_bot_locale_error(response)
        } else {
            crate::operation_deser::parse_update_bot_locale_response(response)
        }
    }
}

/// <p>Updates the password used to protect an export zip archive.</p>
/// <p>The password is not required. If you don't supply a password, Amazon Lex
/// generates a zip file that is not protected by a password. This is the
/// archive that is available at the pre-signed S3 URL provided by the
/// operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateExport {
    _private: (),
}
impl UpdateExport {
    /// Creates a new builder-style object to manufacture [`UpdateExportInput`](crate::input::UpdateExportInput)
    pub fn builder() -> crate::input::update_export_input::Builder {
        crate::input::update_export_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateExport {
    type Output =
        std::result::Result<crate::output::UpdateExportOutput, crate::error::UpdateExportError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 202 {
            crate::operation_deser::parse_update_export_error(response)
        } else {
            crate::operation_deser::parse_update_export_response(response)
        }
    }
}

/// <p>Updates the settings for an intent.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateIntent {
    _private: (),
}
impl UpdateIntent {
    /// Creates a new builder-style object to manufacture [`UpdateIntentInput`](crate::input::UpdateIntentInput)
    pub fn builder() -> crate::input::update_intent_input::Builder {
        crate::input::update_intent_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateIntent {
    type Output =
        std::result::Result<crate::output::UpdateIntentOutput, crate::error::UpdateIntentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_intent_error(response)
        } else {
            crate::operation_deser::parse_update_intent_response(response)
        }
    }
}

/// <p>Replaces the existing resource policy for a bot or bot alias with a
/// new one. If the policy doesn't exist, Amazon Lex returns an
/// exception.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateResourcePolicy {
    _private: (),
}
impl UpdateResourcePolicy {
    /// Creates a new builder-style object to manufacture [`UpdateResourcePolicyInput`](crate::input::UpdateResourcePolicyInput)
    pub fn builder() -> crate::input::update_resource_policy_input::Builder {
        crate::input::update_resource_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateResourcePolicy {
    type Output = std::result::Result<
        crate::output::UpdateResourcePolicyOutput,
        crate::error::UpdateResourcePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_resource_policy_error(response)
        } else {
            crate::operation_deser::parse_update_resource_policy_response(response)
        }
    }
}

/// <p>Updates the settings for a slot.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateSlot {
    _private: (),
}
impl UpdateSlot {
    /// Creates a new builder-style object to manufacture [`UpdateSlotInput`](crate::input::UpdateSlotInput)
    pub fn builder() -> crate::input::update_slot_input::Builder {
        crate::input::update_slot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateSlot {
    type Output =
        std::result::Result<crate::output::UpdateSlotOutput, crate::error::UpdateSlotError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_slot_error(response)
        } else {
            crate::operation_deser::parse_update_slot_response(response)
        }
    }
}

/// <p>Updates the configuration of an existing slot type.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateSlotType {
    _private: (),
}
impl UpdateSlotType {
    /// Creates a new builder-style object to manufacture [`UpdateSlotTypeInput`](crate::input::UpdateSlotTypeInput)
    pub fn builder() -> crate::input::update_slot_type_input::Builder {
        crate::input::update_slot_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateSlotType {
    type Output =
        std::result::Result<crate::output::UpdateSlotTypeOutput, crate::error::UpdateSlotTypeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 202 {
            crate::operation_deser::parse_update_slot_type_error(response)
        } else {
            crate::operation_deser::parse_update_slot_type_response(response)
        }
    }
}
