// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Provides a list of conditional branches. Branches are evaluated in the order that they are entered in the list. The first branch with a condition that evaluates to true is executed. The last branch in the list is the default branch. The default branch should not have any condition expression. The default branch is executed if no other branch has a matching condition.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ConditionalSpecification {
    /// <p>Determines whether a conditional branch is active. When <code>active</code> is false, the conditions are not evaluated.</p>
    pub active: bool,
    /// <p>A list of conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true.</p>
    pub conditional_branches: ::std::vec::Vec<crate::types::ConditionalBranch>,
    /// <p>The conditional branch that should be followed when the conditions for other branches are not satisfied. A conditional branch is made up of a condition, a response and a next step.</p>
    pub default_branch: ::std::option::Option<crate::types::DefaultConditionalBranch>,
}
impl ConditionalSpecification {
    /// <p>Determines whether a conditional branch is active. When <code>active</code> is false, the conditions are not evaluated.</p>
    pub fn active(&self) -> bool {
        self.active
    }
    /// <p>A list of conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true.</p>
    pub fn conditional_branches(&self) -> &[crate::types::ConditionalBranch] {
        use std::ops::Deref;
        self.conditional_branches.deref()
    }
    /// <p>The conditional branch that should be followed when the conditions for other branches are not satisfied. A conditional branch is made up of a condition, a response and a next step.</p>
    pub fn default_branch(&self) -> ::std::option::Option<&crate::types::DefaultConditionalBranch> {
        self.default_branch.as_ref()
    }
}
impl ConditionalSpecification {
    /// Creates a new builder-style object to manufacture [`ConditionalSpecification`](crate::types::ConditionalSpecification).
    pub fn builder() -> crate::types::builders::ConditionalSpecificationBuilder {
        crate::types::builders::ConditionalSpecificationBuilder::default()
    }
}

/// A builder for [`ConditionalSpecification`](crate::types::ConditionalSpecification).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct ConditionalSpecificationBuilder {
    pub(crate) active: ::std::option::Option<bool>,
    pub(crate) conditional_branches: ::std::option::Option<::std::vec::Vec<crate::types::ConditionalBranch>>,
    pub(crate) default_branch: ::std::option::Option<crate::types::DefaultConditionalBranch>,
}
impl ConditionalSpecificationBuilder {
    /// <p>Determines whether a conditional branch is active. When <code>active</code> is false, the conditions are not evaluated.</p>
    /// This field is required.
    pub fn active(mut self, input: bool) -> Self {
        self.active = ::std::option::Option::Some(input);
        self
    }
    /// <p>Determines whether a conditional branch is active. When <code>active</code> is false, the conditions are not evaluated.</p>
    pub fn set_active(mut self, input: ::std::option::Option<bool>) -> Self {
        self.active = input;
        self
    }
    /// <p>Determines whether a conditional branch is active. When <code>active</code> is false, the conditions are not evaluated.</p>
    pub fn get_active(&self) -> &::std::option::Option<bool> {
        &self.active
    }
    /// Appends an item to `conditional_branches`.
    ///
    /// To override the contents of this collection use [`set_conditional_branches`](Self::set_conditional_branches).
    ///
    /// <p>A list of conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true.</p>
    pub fn conditional_branches(mut self, input: crate::types::ConditionalBranch) -> Self {
        let mut v = self.conditional_branches.unwrap_or_default();
        v.push(input);
        self.conditional_branches = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true.</p>
    pub fn set_conditional_branches(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ConditionalBranch>>) -> Self {
        self.conditional_branches = input;
        self
    }
    /// <p>A list of conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true.</p>
    pub fn get_conditional_branches(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ConditionalBranch>> {
        &self.conditional_branches
    }
    /// <p>The conditional branch that should be followed when the conditions for other branches are not satisfied. A conditional branch is made up of a condition, a response and a next step.</p>
    /// This field is required.
    pub fn default_branch(mut self, input: crate::types::DefaultConditionalBranch) -> Self {
        self.default_branch = ::std::option::Option::Some(input);
        self
    }
    /// <p>The conditional branch that should be followed when the conditions for other branches are not satisfied. A conditional branch is made up of a condition, a response and a next step.</p>
    pub fn set_default_branch(mut self, input: ::std::option::Option<crate::types::DefaultConditionalBranch>) -> Self {
        self.default_branch = input;
        self
    }
    /// <p>The conditional branch that should be followed when the conditions for other branches are not satisfied. A conditional branch is made up of a condition, a response and a next step.</p>
    pub fn get_default_branch(&self) -> &::std::option::Option<crate::types::DefaultConditionalBranch> {
        &self.default_branch
    }
    /// Consumes the builder and constructs a [`ConditionalSpecification`](crate::types::ConditionalSpecification).
    /// This method will fail if any of the following fields are not set:
    /// - [`active`](crate::types::builders::ConditionalSpecificationBuilder::active)
    /// - [`conditional_branches`](crate::types::builders::ConditionalSpecificationBuilder::conditional_branches)
    pub fn build(self) -> ::std::result::Result<crate::types::ConditionalSpecification, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::ConditionalSpecification {
            active: self.active.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "active",
                    "active was not specified but it is required when building ConditionalSpecification",
                )
            })?,
            conditional_branches: self.conditional_branches.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "conditional_branches",
                    "conditional_branches was not specified but it is required when building ConditionalSpecification",
                )
            })?,
            default_branch: self.default_branch,
        })
    }
}
