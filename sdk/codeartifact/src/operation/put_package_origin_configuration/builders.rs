// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::put_package_origin_configuration::_put_package_origin_configuration_output::PutPackageOriginConfigurationOutputBuilder;

pub use crate::operation::put_package_origin_configuration::_put_package_origin_configuration_input::PutPackageOriginConfigurationInputBuilder;

impl PutPackageOriginConfigurationInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::put_package_origin_configuration::PutPackageOriginConfigurationOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::put_package_origin_configuration::PutPackageOriginConfigurationError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.put_package_origin_configuration();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `PutPackageOriginConfiguration`.
///
/// <p>Sets the package origin configuration for a package.</p>
/// <p>The package origin configuration determines how new versions of a package can be added to a repository. You can allow or block direct publishing of new package versions, or ingestion and retaining of new package versions from an external connection or upstream source. For more information about package origin controls and configuration, see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/package-origin-controls.html">Editing package origin controls</a> in the <i>CodeArtifact User Guide</i>.</p>
/// <p><code>PutPackageOriginConfiguration</code> can be called on a package that doesn't yet exist in the repository. When called on a package that does not exist, a package is created in the repository with no versions and the requested restrictions are set on the package. This can be used to preemptively block ingesting or retaining any versions from external connections or upstream repositories, or to block publishing any versions of the package into the repository before connecting any package managers or publishers to the repository.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct PutPackageOriginConfigurationFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::put_package_origin_configuration::builders::PutPackageOriginConfigurationInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::put_package_origin_configuration::PutPackageOriginConfigurationOutput,
        crate::operation::put_package_origin_configuration::PutPackageOriginConfigurationError,
    > for PutPackageOriginConfigurationFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::put_package_origin_configuration::PutPackageOriginConfigurationOutput,
            crate::operation::put_package_origin_configuration::PutPackageOriginConfigurationError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl PutPackageOriginConfigurationFluentBuilder {
    /// Creates a new `PutPackageOriginConfiguration`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the PutPackageOriginConfiguration as a reference.
    pub fn as_input(&self) -> &crate::operation::put_package_origin_configuration::builders::PutPackageOriginConfigurationInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::put_package_origin_configuration::PutPackageOriginConfigurationOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::put_package_origin_configuration::PutPackageOriginConfigurationError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::put_package_origin_configuration::PutPackageOriginConfiguration::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::put_package_origin_configuration::PutPackageOriginConfiguration::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::put_package_origin_configuration::PutPackageOriginConfigurationOutput,
        crate::operation::put_package_origin_configuration::PutPackageOriginConfigurationError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The name of the domain that contains the repository that contains the package.</p>
    pub fn domain(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.domain(input.into());
        self
    }
    /// <p>The name of the domain that contains the repository that contains the package.</p>
    pub fn set_domain(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_domain(input);
        self
    }
    /// <p>The name of the domain that contains the repository that contains the package.</p>
    pub fn get_domain(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_domain()
    }
    /// <p>The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.</p>
    pub fn domain_owner(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.domain_owner(input.into());
        self
    }
    /// <p>The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.</p>
    pub fn set_domain_owner(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_domain_owner(input);
        self
    }
    /// <p>The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.</p>
    pub fn get_domain_owner(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_domain_owner()
    }
    /// <p>The name of the repository that contains the package.</p>
    pub fn repository(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.repository(input.into());
        self
    }
    /// <p>The name of the repository that contains the package.</p>
    pub fn set_repository(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_repository(input);
        self
    }
    /// <p>The name of the repository that contains the package.</p>
    pub fn get_repository(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_repository()
    }
    /// <p>A format that specifies the type of the package to be updated.</p>
    pub fn format(mut self, input: crate::types::PackageFormat) -> Self {
        self.inner = self.inner.format(input);
        self
    }
    /// <p>A format that specifies the type of the package to be updated.</p>
    pub fn set_format(mut self, input: ::std::option::Option<crate::types::PackageFormat>) -> Self {
        self.inner = self.inner.set_format(input);
        self
    }
    /// <p>A format that specifies the type of the package to be updated.</p>
    pub fn get_format(&self) -> &::std::option::Option<crate::types::PackageFormat> {
        self.inner.get_format()
    }
    /// <p>The namespace of the package to be updated. The package component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li>
    /// <p>The namespace of a Maven package is its <code>groupId</code>.</p></li>
    /// <li>
    /// <p>The namespace of an npm package is its <code>scope</code>.</p></li>
    /// <li>
    /// <p>Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace.</p></li>
    /// <li>
    /// <p>The namespace of a generic package is its <code>namespace</code>.</p></li>
    /// </ul>
    pub fn namespace(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.namespace(input.into());
        self
    }
    /// <p>The namespace of the package to be updated. The package component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li>
    /// <p>The namespace of a Maven package is its <code>groupId</code>.</p></li>
    /// <li>
    /// <p>The namespace of an npm package is its <code>scope</code>.</p></li>
    /// <li>
    /// <p>Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace.</p></li>
    /// <li>
    /// <p>The namespace of a generic package is its <code>namespace</code>.</p></li>
    /// </ul>
    pub fn set_namespace(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_namespace(input);
        self
    }
    /// <p>The namespace of the package to be updated. The package component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li>
    /// <p>The namespace of a Maven package is its <code>groupId</code>.</p></li>
    /// <li>
    /// <p>The namespace of an npm package is its <code>scope</code>.</p></li>
    /// <li>
    /// <p>Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace.</p></li>
    /// <li>
    /// <p>The namespace of a generic package is its <code>namespace</code>.</p></li>
    /// </ul>
    pub fn get_namespace(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_namespace()
    }
    /// <p>The name of the package to be updated.</p>
    pub fn package(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.package(input.into());
        self
    }
    /// <p>The name of the package to be updated.</p>
    pub fn set_package(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_package(input);
        self
    }
    /// <p>The name of the package to be updated.</p>
    pub fn get_package(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_package()
    }
    /// <p>A <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageOriginRestrictions.html">PackageOriginRestrictions</a> object that contains information about the <code>upstream</code> and <code>publish</code> package origin restrictions. The <code>upstream</code> restriction determines if new package versions can be ingested or retained from external connections or upstream repositories. The <code>publish</code> restriction determines if new package versions can be published directly to the repository.</p>
    /// <p>You must include both the desired <code>upstream</code> and <code>publish</code> restrictions.</p>
    pub fn restrictions(mut self, input: crate::types::PackageOriginRestrictions) -> Self {
        self.inner = self.inner.restrictions(input);
        self
    }
    /// <p>A <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageOriginRestrictions.html">PackageOriginRestrictions</a> object that contains information about the <code>upstream</code> and <code>publish</code> package origin restrictions. The <code>upstream</code> restriction determines if new package versions can be ingested or retained from external connections or upstream repositories. The <code>publish</code> restriction determines if new package versions can be published directly to the repository.</p>
    /// <p>You must include both the desired <code>upstream</code> and <code>publish</code> restrictions.</p>
    pub fn set_restrictions(mut self, input: ::std::option::Option<crate::types::PackageOriginRestrictions>) -> Self {
        self.inner = self.inner.set_restrictions(input);
        self
    }
    /// <p>A <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageOriginRestrictions.html">PackageOriginRestrictions</a> object that contains information about the <code>upstream</code> and <code>publish</code> package origin restrictions. The <code>upstream</code> restriction determines if new package versions can be ingested or retained from external connections or upstream repositories. The <code>publish</code> restriction determines if new package versions can be published directly to the repository.</p>
    /// <p>You must include both the desired <code>upstream</code> and <code>publish</code> restrictions.</p>
    pub fn get_restrictions(&self) -> &::std::option::Option<crate::types::PackageOriginRestrictions> {
        self.inner.get_restrictions()
    }
}
