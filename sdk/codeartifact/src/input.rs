// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
impl AssociateExternalConnectionInput {
    /// Consumes the builder and constructs an Operation<[`AssociateExternalConnection`](crate::operation::AssociateExternalConnection)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociateExternalConnection,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::AssociateExternalConnectionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/repository/external-connection")
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::AssociateExternalConnectionInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_1 = &_input.domain;
                let inner_1 = inner_1.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_1.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_1));
                if let Some(inner_2) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_2),
                        );
                    }
                }
                let inner_3 = &_input.repository;
                let inner_3 = inner_3.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "repository",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_3.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "repository",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("repository", &aws_smithy_http::query::fmt_string(&inner_3));
                let inner_4 = &_input.external_connection;
                let inner_4 = inner_4.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "external_connection",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_4.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "external_connection",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv(
                    "external-connection",
                    &aws_smithy_http::query::fmt_string(&inner_4),
                );
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AssociateExternalConnectionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateExternalConnection::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociateExternalConnection",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CopyPackageVersionsInput {
    /// Consumes the builder and constructs an Operation<[`CopyPackageVersions`](crate::operation::CopyPackageVersions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CopyPackageVersions,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CopyPackageVersionsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/package/versions/copy").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::CopyPackageVersionsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_5 = &_input.domain;
                let inner_5 = inner_5.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_5.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_5));
                if let Some(inner_6) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_6),
                        );
                    }
                }
                let inner_7 = &_input.source_repository;
                let inner_7 = inner_7.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "source_repository",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_7.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "source_repository",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv(
                    "source-repository",
                    &aws_smithy_http::query::fmt_string(&inner_7),
                );
                let inner_8 = &_input.destination_repository;
                let inner_8 = inner_8.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "destination_repository",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_8.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "destination_repository",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv(
                    "destination-repository",
                    &aws_smithy_http::query::fmt_string(&inner_8),
                );
                let inner_9 = &_input.format;
                let inner_9 = inner_9.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "format",
                        "cannot be empty or unset",
                    )
                })?;
                query.push_kv("format", &aws_smithy_http::query::fmt_string(&inner_9));
                if let Some(inner_10) = &_input.namespace {
                    {
                        query.push_kv("namespace", &aws_smithy_http::query::fmt_string(&inner_10));
                    }
                }
                let inner_11 = &_input.package;
                let inner_11 = inner_11.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "package",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_11.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "package",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("package", &aws_smithy_http::query::fmt_string(&inner_11));
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CopyPackageVersionsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_copy_package_versions(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CopyPackageVersions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CopyPackageVersions",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateDomainInput {
    /// Consumes the builder and constructs an Operation<[`CreateDomain`](crate::operation::CreateDomain)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateDomain,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateDomainInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/domain").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::CreateDomainInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_12 = &_input.domain;
                let inner_12 = inner_12.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_12.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_12));
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateDomainInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_domain(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateDomain::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateDomain",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateRepositoryInput {
    /// Consumes the builder and constructs an Operation<[`CreateRepository`](crate::operation::CreateRepository)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateRepository,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateRepositoryInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/repository").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::CreateRepositoryInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_13 = &_input.domain;
                let inner_13 = inner_13.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_13.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_13));
                if let Some(inner_14) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_14),
                        );
                    }
                }
                let inner_15 = &_input.repository;
                let inner_15 = inner_15.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "repository",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_15.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "repository",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("repository", &aws_smithy_http::query::fmt_string(&inner_15));
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateRepositoryInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_repository(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateRepository::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateRepository",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteDomainInput {
    /// Consumes the builder and constructs an Operation<[`DeleteDomain`](crate::operation::DeleteDomain)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteDomain,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteDomainInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/domain").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DeleteDomainInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_16 = &_input.domain;
                let inner_16 = inner_16.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_16.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_16));
                if let Some(inner_17) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_17),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteDomainInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteDomain::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteDomain",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteDomainPermissionsPolicyInput {
    /// Consumes the builder and constructs an Operation<[`DeleteDomainPermissionsPolicy`](crate::operation::DeleteDomainPermissionsPolicy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteDomainPermissionsPolicy,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteDomainPermissionsPolicyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/domain/permissions/policy").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DeleteDomainPermissionsPolicyInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_18 = &_input.domain;
                let inner_18 = inner_18.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_18.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_18));
                if let Some(inner_19) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_19),
                        );
                    }
                }
                if let Some(inner_20) = &_input.policy_revision {
                    {
                        query.push_kv(
                            "policy-revision",
                            &aws_smithy_http::query::fmt_string(&inner_20),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteDomainPermissionsPolicyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteDomainPermissionsPolicy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteDomainPermissionsPolicy",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeletePackageVersionsInput {
    /// Consumes the builder and constructs an Operation<[`DeletePackageVersions`](crate::operation::DeletePackageVersions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeletePackageVersions,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeletePackageVersionsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/package/versions/delete").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DeletePackageVersionsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_21 = &_input.domain;
                let inner_21 = inner_21.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_21.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_21));
                if let Some(inner_22) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_22),
                        );
                    }
                }
                let inner_23 = &_input.repository;
                let inner_23 = inner_23.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "repository",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_23.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "repository",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("repository", &aws_smithy_http::query::fmt_string(&inner_23));
                let inner_24 = &_input.format;
                let inner_24 = inner_24.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "format",
                        "cannot be empty or unset",
                    )
                })?;
                query.push_kv("format", &aws_smithy_http::query::fmt_string(&inner_24));
                if let Some(inner_25) = &_input.namespace {
                    {
                        query.push_kv("namespace", &aws_smithy_http::query::fmt_string(&inner_25));
                    }
                }
                let inner_26 = &_input.package;
                let inner_26 = inner_26.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "package",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_26.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "package",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("package", &aws_smithy_http::query::fmt_string(&inner_26));
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeletePackageVersionsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_delete_package_versions(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeletePackageVersions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeletePackageVersions",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteRepositoryInput {
    /// Consumes the builder and constructs an Operation<[`DeleteRepository`](crate::operation::DeleteRepository)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteRepository,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteRepositoryInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/repository").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DeleteRepositoryInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_27 = &_input.domain;
                let inner_27 = inner_27.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_27.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_27));
                if let Some(inner_28) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_28),
                        );
                    }
                }
                let inner_29 = &_input.repository;
                let inner_29 = inner_29.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "repository",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_29.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "repository",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("repository", &aws_smithy_http::query::fmt_string(&inner_29));
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteRepositoryInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteRepository::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteRepository",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteRepositoryPermissionsPolicyInput {
    /// Consumes the builder and constructs an Operation<[`DeleteRepositoryPermissionsPolicy`](crate::operation::DeleteRepositoryPermissionsPolicy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteRepositoryPermissionsPolicy,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteRepositoryPermissionsPolicyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/repository/permissions/policies")
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DeleteRepositoryPermissionsPolicyInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_30 = &_input.domain;
                let inner_30 = inner_30.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_30.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_30));
                if let Some(inner_31) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_31),
                        );
                    }
                }
                let inner_32 = &_input.repository;
                let inner_32 = inner_32.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "repository",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_32.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "repository",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("repository", &aws_smithy_http::query::fmt_string(&inner_32));
                if let Some(inner_33) = &_input.policy_revision {
                    {
                        query.push_kv(
                            "policy-revision",
                            &aws_smithy_http::query::fmt_string(&inner_33),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteRepositoryPermissionsPolicyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteRepositoryPermissionsPolicy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteRepositoryPermissionsPolicy",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DescribeDomainInput {
    /// Consumes the builder and constructs an Operation<[`DescribeDomain`](crate::operation::DescribeDomain)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeDomain,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeDomainInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/domain").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DescribeDomainInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_34 = &_input.domain;
                let inner_34 = inner_34.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_34.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_34));
                if let Some(inner_35) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_35),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeDomainInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeDomain::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeDomain",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DescribePackageInput {
    /// Consumes the builder and constructs an Operation<[`DescribePackage`](crate::operation::DescribePackage)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribePackage,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribePackageInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/package").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DescribePackageInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_36 = &_input.domain;
                let inner_36 = inner_36.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_36.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_36));
                if let Some(inner_37) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_37),
                        );
                    }
                }
                let inner_38 = &_input.repository;
                let inner_38 = inner_38.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "repository",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_38.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "repository",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("repository", &aws_smithy_http::query::fmt_string(&inner_38));
                let inner_39 = &_input.format;
                let inner_39 = inner_39.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "format",
                        "cannot be empty or unset",
                    )
                })?;
                query.push_kv("format", &aws_smithy_http::query::fmt_string(&inner_39));
                if let Some(inner_40) = &_input.namespace {
                    {
                        query.push_kv("namespace", &aws_smithy_http::query::fmt_string(&inner_40));
                    }
                }
                let inner_41 = &_input.package;
                let inner_41 = inner_41.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "package",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_41.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "package",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("package", &aws_smithy_http::query::fmt_string(&inner_41));
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribePackageInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribePackage::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribePackage",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DescribePackageVersionInput {
    /// Consumes the builder and constructs an Operation<[`DescribePackageVersion`](crate::operation::DescribePackageVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribePackageVersion,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribePackageVersionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/package/version").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DescribePackageVersionInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_42 = &_input.domain;
                let inner_42 = inner_42.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_42.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_42));
                if let Some(inner_43) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_43),
                        );
                    }
                }
                let inner_44 = &_input.repository;
                let inner_44 = inner_44.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "repository",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_44.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "repository",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("repository", &aws_smithy_http::query::fmt_string(&inner_44));
                let inner_45 = &_input.format;
                let inner_45 = inner_45.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "format",
                        "cannot be empty or unset",
                    )
                })?;
                query.push_kv("format", &aws_smithy_http::query::fmt_string(&inner_45));
                if let Some(inner_46) = &_input.namespace {
                    {
                        query.push_kv("namespace", &aws_smithy_http::query::fmt_string(&inner_46));
                    }
                }
                let inner_47 = &_input.package;
                let inner_47 = inner_47.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "package",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_47.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "package",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("package", &aws_smithy_http::query::fmt_string(&inner_47));
                let inner_48 = &_input.package_version;
                let inner_48 = inner_48.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "package_version",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_48.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "package_version",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("version", &aws_smithy_http::query::fmt_string(&inner_48));
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribePackageVersionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribePackageVersion::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribePackageVersion",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DescribeRepositoryInput {
    /// Consumes the builder and constructs an Operation<[`DescribeRepository`](crate::operation::DescribeRepository)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeRepository,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeRepositoryInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/repository").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DescribeRepositoryInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_49 = &_input.domain;
                let inner_49 = inner_49.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_49.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_49));
                if let Some(inner_50) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_50),
                        );
                    }
                }
                let inner_51 = &_input.repository;
                let inner_51 = inner_51.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "repository",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_51.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "repository",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("repository", &aws_smithy_http::query::fmt_string(&inner_51));
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeRepositoryInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeRepository::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeRepository",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DisassociateExternalConnectionInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateExternalConnection`](crate::operation::DisassociateExternalConnection)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisassociateExternalConnection,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DisassociateExternalConnectionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/repository/external-connection")
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DisassociateExternalConnectionInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_52 = &_input.domain;
                let inner_52 = inner_52.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_52.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_52));
                if let Some(inner_53) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_53),
                        );
                    }
                }
                let inner_54 = &_input.repository;
                let inner_54 = inner_54.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "repository",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_54.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "repository",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("repository", &aws_smithy_http::query::fmt_string(&inner_54));
                let inner_55 = &_input.external_connection;
                let inner_55 = inner_55.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "external_connection",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_55.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "external_connection",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv(
                    "external-connection",
                    &aws_smithy_http::query::fmt_string(&inner_55),
                );
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DisassociateExternalConnectionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociateExternalConnection::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisassociateExternalConnection",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DisposePackageVersionsInput {
    /// Consumes the builder and constructs an Operation<[`DisposePackageVersions`](crate::operation::DisposePackageVersions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisposePackageVersions,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DisposePackageVersionsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/package/versions/dispose").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DisposePackageVersionsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_56 = &_input.domain;
                let inner_56 = inner_56.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_56.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_56));
                if let Some(inner_57) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_57),
                        );
                    }
                }
                let inner_58 = &_input.repository;
                let inner_58 = inner_58.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "repository",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_58.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "repository",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("repository", &aws_smithy_http::query::fmt_string(&inner_58));
                let inner_59 = &_input.format;
                let inner_59 = inner_59.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "format",
                        "cannot be empty or unset",
                    )
                })?;
                query.push_kv("format", &aws_smithy_http::query::fmt_string(&inner_59));
                if let Some(inner_60) = &_input.namespace {
                    {
                        query.push_kv("namespace", &aws_smithy_http::query::fmt_string(&inner_60));
                    }
                }
                let inner_61 = &_input.package;
                let inner_61 = inner_61.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "package",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_61.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "package",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("package", &aws_smithy_http::query::fmt_string(&inner_61));
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DisposePackageVersionsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_dispose_package_versions(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisposePackageVersions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisposePackageVersions",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetAuthorizationTokenInput {
    /// Consumes the builder and constructs an Operation<[`GetAuthorizationToken`](crate::operation::GetAuthorizationToken)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetAuthorizationToken,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetAuthorizationTokenInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/authorization-token").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetAuthorizationTokenInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_62 = &_input.domain;
                let inner_62 = inner_62.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_62.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_62));
                if let Some(inner_63) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_63),
                        );
                    }
                }
                if let Some(inner_64) = &_input.duration_seconds {
                    if *inner_64 != 0 {
                        query.push_kv(
                            "duration",
                            aws_smithy_types::primitive::Encoder::from(*inner_64).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetAuthorizationTokenInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetAuthorizationToken::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetAuthorizationToken",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetDomainPermissionsPolicyInput {
    /// Consumes the builder and constructs an Operation<[`GetDomainPermissionsPolicy`](crate::operation::GetDomainPermissionsPolicy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetDomainPermissionsPolicy,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetDomainPermissionsPolicyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/domain/permissions/policy").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetDomainPermissionsPolicyInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_65 = &_input.domain;
                let inner_65 = inner_65.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_65.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_65));
                if let Some(inner_66) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_66),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetDomainPermissionsPolicyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetDomainPermissionsPolicy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetDomainPermissionsPolicy",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetPackageVersionAssetInput {
    /// Consumes the builder and constructs an Operation<[`GetPackageVersionAsset`](crate::operation::GetPackageVersionAsset)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetPackageVersionAsset,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetPackageVersionAssetInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/package/version/asset").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetPackageVersionAssetInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_67 = &_input.domain;
                let inner_67 = inner_67.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_67.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_67));
                if let Some(inner_68) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_68),
                        );
                    }
                }
                let inner_69 = &_input.repository;
                let inner_69 = inner_69.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "repository",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_69.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "repository",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("repository", &aws_smithy_http::query::fmt_string(&inner_69));
                let inner_70 = &_input.format;
                let inner_70 = inner_70.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "format",
                        "cannot be empty or unset",
                    )
                })?;
                query.push_kv("format", &aws_smithy_http::query::fmt_string(&inner_70));
                if let Some(inner_71) = &_input.namespace {
                    {
                        query.push_kv("namespace", &aws_smithy_http::query::fmt_string(&inner_71));
                    }
                }
                let inner_72 = &_input.package;
                let inner_72 = inner_72.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "package",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_72.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "package",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("package", &aws_smithy_http::query::fmt_string(&inner_72));
                let inner_73 = &_input.package_version;
                let inner_73 = inner_73.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "package_version",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_73.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "package_version",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("version", &aws_smithy_http::query::fmt_string(&inner_73));
                let inner_74 = &_input.asset;
                let inner_74 = inner_74.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "asset",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_74.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "asset",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("asset", &aws_smithy_http::query::fmt_string(&inner_74));
                if let Some(inner_75) = &_input.package_version_revision {
                    {
                        query.push_kv("revision", &aws_smithy_http::query::fmt_string(&inner_75));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetPackageVersionAssetInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetPackageVersionAsset::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetPackageVersionAsset",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetPackageVersionReadmeInput {
    /// Consumes the builder and constructs an Operation<[`GetPackageVersionReadme`](crate::operation::GetPackageVersionReadme)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetPackageVersionReadme,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetPackageVersionReadmeInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/package/version/readme").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetPackageVersionReadmeInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_76 = &_input.domain;
                let inner_76 = inner_76.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_76.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_76));
                if let Some(inner_77) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_77),
                        );
                    }
                }
                let inner_78 = &_input.repository;
                let inner_78 = inner_78.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "repository",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_78.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "repository",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("repository", &aws_smithy_http::query::fmt_string(&inner_78));
                let inner_79 = &_input.format;
                let inner_79 = inner_79.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "format",
                        "cannot be empty or unset",
                    )
                })?;
                query.push_kv("format", &aws_smithy_http::query::fmt_string(&inner_79));
                if let Some(inner_80) = &_input.namespace {
                    {
                        query.push_kv("namespace", &aws_smithy_http::query::fmt_string(&inner_80));
                    }
                }
                let inner_81 = &_input.package;
                let inner_81 = inner_81.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "package",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_81.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "package",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("package", &aws_smithy_http::query::fmt_string(&inner_81));
                let inner_82 = &_input.package_version;
                let inner_82 = inner_82.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "package_version",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_82.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "package_version",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("version", &aws_smithy_http::query::fmt_string(&inner_82));
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetPackageVersionReadmeInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetPackageVersionReadme::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetPackageVersionReadme",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetRepositoryEndpointInput {
    /// Consumes the builder and constructs an Operation<[`GetRepositoryEndpoint`](crate::operation::GetRepositoryEndpoint)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetRepositoryEndpoint,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetRepositoryEndpointInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/repository/endpoint").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetRepositoryEndpointInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_83 = &_input.domain;
                let inner_83 = inner_83.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_83.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_83));
                if let Some(inner_84) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_84),
                        );
                    }
                }
                let inner_85 = &_input.repository;
                let inner_85 = inner_85.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "repository",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_85.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "repository",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("repository", &aws_smithy_http::query::fmt_string(&inner_85));
                let inner_86 = &_input.format;
                let inner_86 = inner_86.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "format",
                        "cannot be empty or unset",
                    )
                })?;
                query.push_kv("format", &aws_smithy_http::query::fmt_string(&inner_86));
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetRepositoryEndpointInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetRepositoryEndpoint::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetRepositoryEndpoint",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetRepositoryPermissionsPolicyInput {
    /// Consumes the builder and constructs an Operation<[`GetRepositoryPermissionsPolicy`](crate::operation::GetRepositoryPermissionsPolicy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetRepositoryPermissionsPolicy,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetRepositoryPermissionsPolicyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/repository/permissions/policy")
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetRepositoryPermissionsPolicyInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_87 = &_input.domain;
                let inner_87 = inner_87.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_87.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_87));
                if let Some(inner_88) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_88),
                        );
                    }
                }
                let inner_89 = &_input.repository;
                let inner_89 = inner_89.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "repository",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_89.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "repository",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("repository", &aws_smithy_http::query::fmt_string(&inner_89));
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetRepositoryPermissionsPolicyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetRepositoryPermissionsPolicy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetRepositoryPermissionsPolicy",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListDomainsInput {
    /// Consumes the builder and constructs an Operation<[`ListDomains`](crate::operation::ListDomains)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListDomains,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListDomainsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/domains").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListDomainsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_domains(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListDomains::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListDomains",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListPackagesInput {
    /// Consumes the builder and constructs an Operation<[`ListPackages`](crate::operation::ListPackages)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListPackages,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListPackagesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/packages").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListPackagesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_90 = &_input.domain;
                let inner_90 = inner_90.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_90.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_90));
                if let Some(inner_91) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_91),
                        );
                    }
                }
                let inner_92 = &_input.repository;
                let inner_92 = inner_92.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "repository",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_92.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "repository",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("repository", &aws_smithy_http::query::fmt_string(&inner_92));
                if let Some(inner_93) = &_input.format {
                    {
                        query.push_kv("format", &aws_smithy_http::query::fmt_string(&inner_93));
                    }
                }
                if let Some(inner_94) = &_input.namespace {
                    {
                        query.push_kv("namespace", &aws_smithy_http::query::fmt_string(&inner_94));
                    }
                }
                if let Some(inner_95) = &_input.package_prefix {
                    {
                        query.push_kv(
                            "package-prefix",
                            &aws_smithy_http::query::fmt_string(&inner_95),
                        );
                    }
                }
                if let Some(inner_96) = &_input.max_results {
                    if *inner_96 != 0 {
                        query.push_kv(
                            "max-results",
                            aws_smithy_types::primitive::Encoder::from(*inner_96).encode(),
                        );
                    }
                }
                if let Some(inner_97) = &_input.next_token {
                    {
                        query.push_kv("next-token", &aws_smithy_http::query::fmt_string(&inner_97));
                    }
                }
                if let Some(inner_98) = &_input.publish {
                    {
                        query.push_kv("publish", &aws_smithy_http::query::fmt_string(&inner_98));
                    }
                }
                if let Some(inner_99) = &_input.upstream {
                    {
                        query.push_kv("upstream", &aws_smithy_http::query::fmt_string(&inner_99));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListPackagesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListPackages::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListPackages",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListPackageVersionAssetsInput {
    /// Consumes the builder and constructs an Operation<[`ListPackageVersionAssets`](crate::operation::ListPackageVersionAssets)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListPackageVersionAssets,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListPackageVersionAssetsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/package/version/assets").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListPackageVersionAssetsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_100 = &_input.domain;
                let inner_100 = inner_100.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_100.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_100));
                if let Some(inner_101) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_101),
                        );
                    }
                }
                let inner_102 = &_input.repository;
                let inner_102 = inner_102.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "repository",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_102.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "repository",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv(
                    "repository",
                    &aws_smithy_http::query::fmt_string(&inner_102),
                );
                let inner_103 = &_input.format;
                let inner_103 = inner_103.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "format",
                        "cannot be empty or unset",
                    )
                })?;
                query.push_kv("format", &aws_smithy_http::query::fmt_string(&inner_103));
                if let Some(inner_104) = &_input.namespace {
                    {
                        query.push_kv("namespace", &aws_smithy_http::query::fmt_string(&inner_104));
                    }
                }
                let inner_105 = &_input.package;
                let inner_105 = inner_105.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "package",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_105.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "package",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("package", &aws_smithy_http::query::fmt_string(&inner_105));
                let inner_106 = &_input.package_version;
                let inner_106 = inner_106.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "package_version",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_106.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "package_version",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("version", &aws_smithy_http::query::fmt_string(&inner_106));
                if let Some(inner_107) = &_input.max_results {
                    if *inner_107 != 0 {
                        query.push_kv(
                            "max-results",
                            aws_smithy_types::primitive::Encoder::from(*inner_107).encode(),
                        );
                    }
                }
                if let Some(inner_108) = &_input.next_token {
                    {
                        query.push_kv(
                            "next-token",
                            &aws_smithy_http::query::fmt_string(&inner_108),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListPackageVersionAssetsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListPackageVersionAssets::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListPackageVersionAssets",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListPackageVersionDependenciesInput {
    /// Consumes the builder and constructs an Operation<[`ListPackageVersionDependencies`](crate::operation::ListPackageVersionDependencies)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListPackageVersionDependencies,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListPackageVersionDependenciesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/package/version/dependencies")
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListPackageVersionDependenciesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_109 = &_input.domain;
                let inner_109 = inner_109.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_109.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_109));
                if let Some(inner_110) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_110),
                        );
                    }
                }
                let inner_111 = &_input.repository;
                let inner_111 = inner_111.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "repository",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_111.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "repository",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv(
                    "repository",
                    &aws_smithy_http::query::fmt_string(&inner_111),
                );
                let inner_112 = &_input.format;
                let inner_112 = inner_112.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "format",
                        "cannot be empty or unset",
                    )
                })?;
                query.push_kv("format", &aws_smithy_http::query::fmt_string(&inner_112));
                if let Some(inner_113) = &_input.namespace {
                    {
                        query.push_kv("namespace", &aws_smithy_http::query::fmt_string(&inner_113));
                    }
                }
                let inner_114 = &_input.package;
                let inner_114 = inner_114.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "package",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_114.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "package",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("package", &aws_smithy_http::query::fmt_string(&inner_114));
                let inner_115 = &_input.package_version;
                let inner_115 = inner_115.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "package_version",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_115.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "package_version",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("version", &aws_smithy_http::query::fmt_string(&inner_115));
                if let Some(inner_116) = &_input.next_token {
                    {
                        query.push_kv(
                            "next-token",
                            &aws_smithy_http::query::fmt_string(&inner_116),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListPackageVersionDependenciesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListPackageVersionDependencies::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListPackageVersionDependencies",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListPackageVersionsInput {
    /// Consumes the builder and constructs an Operation<[`ListPackageVersions`](crate::operation::ListPackageVersions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListPackageVersions,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListPackageVersionsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/package/versions").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListPackageVersionsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_117 = &_input.domain;
                let inner_117 = inner_117.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_117.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_117));
                if let Some(inner_118) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_118),
                        );
                    }
                }
                let inner_119 = &_input.repository;
                let inner_119 = inner_119.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "repository",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_119.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "repository",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv(
                    "repository",
                    &aws_smithy_http::query::fmt_string(&inner_119),
                );
                let inner_120 = &_input.format;
                let inner_120 = inner_120.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "format",
                        "cannot be empty or unset",
                    )
                })?;
                query.push_kv("format", &aws_smithy_http::query::fmt_string(&inner_120));
                if let Some(inner_121) = &_input.namespace {
                    {
                        query.push_kv("namespace", &aws_smithy_http::query::fmt_string(&inner_121));
                    }
                }
                let inner_122 = &_input.package;
                let inner_122 = inner_122.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "package",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_122.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "package",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("package", &aws_smithy_http::query::fmt_string(&inner_122));
                if let Some(inner_123) = &_input.status {
                    {
                        query.push_kv("status", &aws_smithy_http::query::fmt_string(&inner_123));
                    }
                }
                if let Some(inner_124) = &_input.sort_by {
                    {
                        query.push_kv("sortBy", &aws_smithy_http::query::fmt_string(&inner_124));
                    }
                }
                if let Some(inner_125) = &_input.max_results {
                    if *inner_125 != 0 {
                        query.push_kv(
                            "max-results",
                            aws_smithy_types::primitive::Encoder::from(*inner_125).encode(),
                        );
                    }
                }
                if let Some(inner_126) = &_input.next_token {
                    {
                        query.push_kv(
                            "next-token",
                            &aws_smithy_http::query::fmt_string(&inner_126),
                        );
                    }
                }
                if let Some(inner_127) = &_input.origin_type {
                    {
                        query.push_kv(
                            "originType",
                            &aws_smithy_http::query::fmt_string(&inner_127),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListPackageVersionsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListPackageVersions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListPackageVersions",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListRepositoriesInput {
    /// Consumes the builder and constructs an Operation<[`ListRepositories`](crate::operation::ListRepositories)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListRepositories,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListRepositoriesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/repositories").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListRepositoriesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_128) = &_input.repository_prefix {
                    {
                        query.push_kv(
                            "repository-prefix",
                            &aws_smithy_http::query::fmt_string(&inner_128),
                        );
                    }
                }
                if let Some(inner_129) = &_input.max_results {
                    if *inner_129 != 0 {
                        query.push_kv(
                            "max-results",
                            aws_smithy_types::primitive::Encoder::from(*inner_129).encode(),
                        );
                    }
                }
                if let Some(inner_130) = &_input.next_token {
                    {
                        query.push_kv(
                            "next-token",
                            &aws_smithy_http::query::fmt_string(&inner_130),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListRepositoriesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListRepositories::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListRepositories",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListRepositoriesInDomainInput {
    /// Consumes the builder and constructs an Operation<[`ListRepositoriesInDomain`](crate::operation::ListRepositoriesInDomain)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListRepositoriesInDomain,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListRepositoriesInDomainInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/domain/repositories").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListRepositoriesInDomainInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_131 = &_input.domain;
                let inner_131 = inner_131.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_131.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_131));
                if let Some(inner_132) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_132),
                        );
                    }
                }
                if let Some(inner_133) = &_input.administrator_account {
                    {
                        query.push_kv(
                            "administrator-account",
                            &aws_smithy_http::query::fmt_string(&inner_133),
                        );
                    }
                }
                if let Some(inner_134) = &_input.repository_prefix {
                    {
                        query.push_kv(
                            "repository-prefix",
                            &aws_smithy_http::query::fmt_string(&inner_134),
                        );
                    }
                }
                if let Some(inner_135) = &_input.max_results {
                    if *inner_135 != 0 {
                        query.push_kv(
                            "max-results",
                            aws_smithy_types::primitive::Encoder::from(*inner_135).encode(),
                        );
                    }
                }
                if let Some(inner_136) = &_input.next_token {
                    {
                        query.push_kv(
                            "next-token",
                            &aws_smithy_http::query::fmt_string(&inner_136),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListRepositoriesInDomainInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListRepositoriesInDomain::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListRepositoriesInDomain",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListTagsForResource,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListTagsForResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/tags").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListTagsForResourceInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_137 = &_input.resource_arn;
                let inner_137 = inner_137.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "resource_arn",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_137.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "resource_arn",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv(
                    "resourceArn",
                    &aws_smithy_http::query::fmt_string(&inner_137),
                );
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListTagsForResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListTagsForResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListTagsForResource",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl PutDomainPermissionsPolicyInput {
    /// Consumes the builder and constructs an Operation<[`PutDomainPermissionsPolicy`](crate::operation::PutDomainPermissionsPolicy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutDomainPermissionsPolicy,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::PutDomainPermissionsPolicyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/domain/permissions/policy").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::PutDomainPermissionsPolicyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_put_domain_permissions_policy(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutDomainPermissionsPolicy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutDomainPermissionsPolicy",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl PutPackageOriginConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutPackageOriginConfiguration`](crate::operation::PutPackageOriginConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutPackageOriginConfiguration,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::PutPackageOriginConfigurationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/package").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::PutPackageOriginConfigurationInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_138 = &_input.domain;
                let inner_138 = inner_138.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_138.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_138));
                if let Some(inner_139) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_139),
                        );
                    }
                }
                let inner_140 = &_input.repository;
                let inner_140 = inner_140.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "repository",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_140.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "repository",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv(
                    "repository",
                    &aws_smithy_http::query::fmt_string(&inner_140),
                );
                let inner_141 = &_input.format;
                let inner_141 = inner_141.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "format",
                        "cannot be empty or unset",
                    )
                })?;
                query.push_kv("format", &aws_smithy_http::query::fmt_string(&inner_141));
                if let Some(inner_142) = &_input.namespace {
                    {
                        query.push_kv("namespace", &aws_smithy_http::query::fmt_string(&inner_142));
                    }
                }
                let inner_143 = &_input.package;
                let inner_143 = inner_143.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "package",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_143.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "package",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("package", &aws_smithy_http::query::fmt_string(&inner_143));
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::PutPackageOriginConfigurationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_put_package_origin_configuration(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutPackageOriginConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutPackageOriginConfiguration",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl PutRepositoryPermissionsPolicyInput {
    /// Consumes the builder and constructs an Operation<[`PutRepositoryPermissionsPolicy`](crate::operation::PutRepositoryPermissionsPolicy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutRepositoryPermissionsPolicy,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::PutRepositoryPermissionsPolicyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/repository/permissions/policy")
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::PutRepositoryPermissionsPolicyInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_144 = &_input.domain;
                let inner_144 = inner_144.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_144.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_144));
                if let Some(inner_145) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_145),
                        );
                    }
                }
                let inner_146 = &_input.repository;
                let inner_146 = inner_146.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "repository",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_146.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "repository",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv(
                    "repository",
                    &aws_smithy_http::query::fmt_string(&inner_146),
                );
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::PutRepositoryPermissionsPolicyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_put_repository_permissions_policy(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutRepositoryPermissionsPolicy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutRepositoryPermissionsPolicy",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::TagResource,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::TagResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/tag").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::TagResourceInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_147 = &_input.resource_arn;
                let inner_147 = inner_147.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "resource_arn",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_147.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "resource_arn",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv(
                    "resourceArn",
                    &aws_smithy_http::query::fmt_string(&inner_147),
                );
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::TagResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_tag_resource(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::TagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "TagResource",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UntagResource,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UntagResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/untag").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::UntagResourceInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_148 = &_input.resource_arn;
                let inner_148 = inner_148.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "resource_arn",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_148.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "resource_arn",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv(
                    "resourceArn",
                    &aws_smithy_http::query::fmt_string(&inner_148),
                );
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UntagResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_untag_resource(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UntagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UntagResource",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdatePackageVersionsStatusInput {
    /// Consumes the builder and constructs an Operation<[`UpdatePackageVersionsStatus`](crate::operation::UpdatePackageVersionsStatus)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdatePackageVersionsStatus,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdatePackageVersionsStatusInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/package/versions/update_status")
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::UpdatePackageVersionsStatusInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_149 = &_input.domain;
                let inner_149 = inner_149.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_149.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_149));
                if let Some(inner_150) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_150),
                        );
                    }
                }
                let inner_151 = &_input.repository;
                let inner_151 = inner_151.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "repository",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_151.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "repository",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv(
                    "repository",
                    &aws_smithy_http::query::fmt_string(&inner_151),
                );
                let inner_152 = &_input.format;
                let inner_152 = inner_152.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "format",
                        "cannot be empty or unset",
                    )
                })?;
                query.push_kv("format", &aws_smithy_http::query::fmt_string(&inner_152));
                if let Some(inner_153) = &_input.namespace {
                    {
                        query.push_kv("namespace", &aws_smithy_http::query::fmt_string(&inner_153));
                    }
                }
                let inner_154 = &_input.package;
                let inner_154 = inner_154.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "package",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_154.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "package",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("package", &aws_smithy_http::query::fmt_string(&inner_154));
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdatePackageVersionsStatusInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_package_versions_status(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdatePackageVersionsStatus::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdatePackageVersionsStatus",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateRepositoryInput {
    /// Consumes the builder and constructs an Operation<[`UpdateRepository`](crate::operation::UpdateRepository)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateRepository,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateRepositoryInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/repository").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::UpdateRepositoryInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_155 = &_input.domain;
                let inner_155 = inner_155.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_155.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("domain", &aws_smithy_http::query::fmt_string(&inner_155));
                if let Some(inner_156) = &_input.domain_owner {
                    {
                        query.push_kv(
                            "domain-owner",
                            &aws_smithy_http::query::fmt_string(&inner_156),
                        );
                    }
                }
                let inner_157 = &_input.repository;
                let inner_157 = inner_157.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "repository",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_157.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "repository",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv(
                    "repository",
                    &aws_smithy_http::query::fmt_string(&inner_157),
                );
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateRepositoryInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_repository(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateRepository::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateRepository",
            "codeartifact",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateRepositoryInput {
    /// <p> The name of the domain associated with the repository to update. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p> The name of the repository to update. </p>
    #[doc(hidden)]
    pub repository: std::option::Option<std::string::String>,
    /// <p> An updated repository description. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p> A list of upstream repositories to associate with the repository. The order of the upstream repositories in the list determines their priority order when CodeArtifact looks for a requested package version. For more information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html">Working with upstream repositories</a>. </p>
    #[doc(hidden)]
    pub upstreams: std::option::Option<std::vec::Vec<crate::model::UpstreamRepository>>,
}
impl UpdateRepositoryInput {
    /// <p> The name of the domain associated with the repository to update. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p> The name of the repository to update. </p>
    pub fn repository(&self) -> std::option::Option<&str> {
        self.repository.as_deref()
    }
    /// <p> An updated repository description. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p> A list of upstream repositories to associate with the repository. The order of the upstream repositories in the list determines their priority order when CodeArtifact looks for a requested package version. For more information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html">Working with upstream repositories</a>. </p>
    pub fn upstreams(&self) -> std::option::Option<&[crate::model::UpstreamRepository]> {
        self.upstreams.as_deref()
    }
}
impl UpdateRepositoryInput {
    /// Creates a new builder-style object to manufacture [`UpdateRepositoryInput`](crate::input::UpdateRepositoryInput).
    pub fn builder() -> crate::input::update_repository_input::Builder {
        crate::input::update_repository_input::Builder::default()
    }
}

/// See [`UpdateRepositoryInput`](crate::input::UpdateRepositoryInput).
pub mod update_repository_input {

    /// A builder for [`UpdateRepositoryInput`](crate::input::UpdateRepositoryInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) repository: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) upstreams: std::option::Option<std::vec::Vec<crate::model::UpstreamRepository>>,
    }
    impl Builder {
        /// <p> The name of the domain associated with the repository to update. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> The name of the domain associated with the repository to update. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p> The name of the repository to update. </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        /// <p> The name of the repository to update. </p>
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// <p> An updated repository description. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> An updated repository description. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `upstreams`.
        ///
        /// To override the contents of this collection use [`set_upstreams`](Self::set_upstreams).
        ///
        /// <p> A list of upstream repositories to associate with the repository. The order of the upstream repositories in the list determines their priority order when CodeArtifact looks for a requested package version. For more information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html">Working with upstream repositories</a>. </p>
        pub fn upstreams(mut self, input: crate::model::UpstreamRepository) -> Self {
            let mut v = self.upstreams.unwrap_or_default();
            v.push(input);
            self.upstreams = Some(v);
            self
        }
        /// <p> A list of upstream repositories to associate with the repository. The order of the upstream repositories in the list determines their priority order when CodeArtifact looks for a requested package version. For more information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html">Working with upstream repositories</a>. </p>
        pub fn set_upstreams(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UpstreamRepository>>,
        ) -> Self {
            self.upstreams = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateRepositoryInput`](crate::input::UpdateRepositoryInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateRepositoryInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateRepositoryInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                repository: self.repository,
                description: self.description,
                upstreams: self.upstreams,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdatePackageVersionsStatusInput {
    /// <p> The name of the domain that contains the repository that contains the package versions with a status to be updated. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p> The repository that contains the package versions with the status you want to update. </p>
    #[doc(hidden)]
    pub repository: std::option::Option<std::string::String>,
    /// <p> A format that specifies the type of the package with the statuses to update. </p>
    #[doc(hidden)]
    pub format: std::option::Option<crate::model::PackageFormat>,
    /// <p>The namespace of the package version to be updated. The package version component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
    /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
    /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub namespace: std::option::Option<std::string::String>,
    /// <p> The name of the package with the version statuses to update. </p>
    #[doc(hidden)]
    pub package: std::option::Option<std::string::String>,
    /// <p> An array of strings that specify the versions of the package with the statuses to update. </p>
    #[doc(hidden)]
    pub versions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> A map of package versions and package version revisions. The map <code>key</code> is the package version (for example, <code>3.5.2</code>), and the map <code>value</code> is the package version revision. </p>
    #[doc(hidden)]
    pub version_revisions:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p> The package version’s expected status before it is updated. If <code>expectedStatus</code> is provided, the package version's status is updated only if its status at the time <code>UpdatePackageVersionsStatus</code> is called matches <code>expectedStatus</code>. </p>
    #[doc(hidden)]
    pub expected_status: std::option::Option<crate::model::PackageVersionStatus>,
    /// <p> The status you want to change the package version status to. </p>
    #[doc(hidden)]
    pub target_status: std::option::Option<crate::model::PackageVersionStatus>,
}
impl UpdatePackageVersionsStatusInput {
    /// <p> The name of the domain that contains the repository that contains the package versions with a status to be updated. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p> The repository that contains the package versions with the status you want to update. </p>
    pub fn repository(&self) -> std::option::Option<&str> {
        self.repository.as_deref()
    }
    /// <p> A format that specifies the type of the package with the statuses to update. </p>
    pub fn format(&self) -> std::option::Option<&crate::model::PackageFormat> {
        self.format.as_ref()
    }
    /// <p>The namespace of the package version to be updated. The package version component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
    /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
    /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
    /// </ul>
    pub fn namespace(&self) -> std::option::Option<&str> {
        self.namespace.as_deref()
    }
    /// <p> The name of the package with the version statuses to update. </p>
    pub fn package(&self) -> std::option::Option<&str> {
        self.package.as_deref()
    }
    /// <p> An array of strings that specify the versions of the package with the statuses to update. </p>
    pub fn versions(&self) -> std::option::Option<&[std::string::String]> {
        self.versions.as_deref()
    }
    /// <p> A map of package versions and package version revisions. The map <code>key</code> is the package version (for example, <code>3.5.2</code>), and the map <code>value</code> is the package version revision. </p>
    pub fn version_revisions(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.version_revisions.as_ref()
    }
    /// <p> The package version’s expected status before it is updated. If <code>expectedStatus</code> is provided, the package version's status is updated only if its status at the time <code>UpdatePackageVersionsStatus</code> is called matches <code>expectedStatus</code>. </p>
    pub fn expected_status(&self) -> std::option::Option<&crate::model::PackageVersionStatus> {
        self.expected_status.as_ref()
    }
    /// <p> The status you want to change the package version status to. </p>
    pub fn target_status(&self) -> std::option::Option<&crate::model::PackageVersionStatus> {
        self.target_status.as_ref()
    }
}
impl UpdatePackageVersionsStatusInput {
    /// Creates a new builder-style object to manufacture [`UpdatePackageVersionsStatusInput`](crate::input::UpdatePackageVersionsStatusInput).
    pub fn builder() -> crate::input::update_package_versions_status_input::Builder {
        crate::input::update_package_versions_status_input::Builder::default()
    }
}

/// See [`UpdatePackageVersionsStatusInput`](crate::input::UpdatePackageVersionsStatusInput).
pub mod update_package_versions_status_input {

    /// A builder for [`UpdatePackageVersionsStatusInput`](crate::input::UpdatePackageVersionsStatusInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) repository: std::option::Option<std::string::String>,
        pub(crate) format: std::option::Option<crate::model::PackageFormat>,
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) package: std::option::Option<std::string::String>,
        pub(crate) versions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) version_revisions: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) expected_status: std::option::Option<crate::model::PackageVersionStatus>,
        pub(crate) target_status: std::option::Option<crate::model::PackageVersionStatus>,
    }
    impl Builder {
        /// <p> The name of the domain that contains the repository that contains the package versions with a status to be updated. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> The name of the domain that contains the repository that contains the package versions with a status to be updated. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p> The repository that contains the package versions with the status you want to update. </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        /// <p> The repository that contains the package versions with the status you want to update. </p>
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// <p> A format that specifies the type of the package with the statuses to update. </p>
        pub fn format(mut self, input: crate::model::PackageFormat) -> Self {
            self.format = Some(input);
            self
        }
        /// <p> A format that specifies the type of the package with the statuses to update. </p>
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::PackageFormat>,
        ) -> Self {
            self.format = input;
            self
        }
        /// <p>The namespace of the package version to be updated. The package version component that specifies its namespace depends on its type. For example:</p>
        /// <ul>
        /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
        /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
        /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
        /// </ul>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>The namespace of the package version to be updated. The package version component that specifies its namespace depends on its type. For example:</p>
        /// <ul>
        /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
        /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
        /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
        /// </ul>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// <p> The name of the package with the version statuses to update. </p>
        pub fn package(mut self, input: impl Into<std::string::String>) -> Self {
            self.package = Some(input.into());
            self
        }
        /// <p> The name of the package with the version statuses to update. </p>
        pub fn set_package(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.package = input;
            self
        }
        /// Appends an item to `versions`.
        ///
        /// To override the contents of this collection use [`set_versions`](Self::set_versions).
        ///
        /// <p> An array of strings that specify the versions of the package with the statuses to update. </p>
        pub fn versions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.versions.unwrap_or_default();
            v.push(input.into());
            self.versions = Some(v);
            self
        }
        /// <p> An array of strings that specify the versions of the package with the statuses to update. </p>
        pub fn set_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.versions = input;
            self
        }
        /// Adds a key-value pair to `version_revisions`.
        ///
        /// To override the contents of this collection use [`set_version_revisions`](Self::set_version_revisions).
        ///
        /// <p> A map of package versions and package version revisions. The map <code>key</code> is the package version (for example, <code>3.5.2</code>), and the map <code>value</code> is the package version revision. </p>
        pub fn version_revisions(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.version_revisions.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.version_revisions = Some(hash_map);
            self
        }
        /// <p> A map of package versions and package version revisions. The map <code>key</code> is the package version (for example, <code>3.5.2</code>), and the map <code>value</code> is the package version revision. </p>
        pub fn set_version_revisions(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.version_revisions = input;
            self
        }
        /// <p> The package version’s expected status before it is updated. If <code>expectedStatus</code> is provided, the package version's status is updated only if its status at the time <code>UpdatePackageVersionsStatus</code> is called matches <code>expectedStatus</code>. </p>
        pub fn expected_status(mut self, input: crate::model::PackageVersionStatus) -> Self {
            self.expected_status = Some(input);
            self
        }
        /// <p> The package version’s expected status before it is updated. If <code>expectedStatus</code> is provided, the package version's status is updated only if its status at the time <code>UpdatePackageVersionsStatus</code> is called matches <code>expectedStatus</code>. </p>
        pub fn set_expected_status(
            mut self,
            input: std::option::Option<crate::model::PackageVersionStatus>,
        ) -> Self {
            self.expected_status = input;
            self
        }
        /// <p> The status you want to change the package version status to. </p>
        pub fn target_status(mut self, input: crate::model::PackageVersionStatus) -> Self {
            self.target_status = Some(input);
            self
        }
        /// <p> The status you want to change the package version status to. </p>
        pub fn set_target_status(
            mut self,
            input: std::option::Option<crate::model::PackageVersionStatus>,
        ) -> Self {
            self.target_status = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdatePackageVersionsStatusInput`](crate::input::UpdatePackageVersionsStatusInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdatePackageVersionsStatusInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdatePackageVersionsStatusInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                repository: self.repository,
                format: self.format,
                namespace: self.namespace,
                package: self.package,
                versions: self.versions,
                version_revisions: self.version_revisions,
                expected_status: self.expected_status,
                target_status: self.target_status,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UntagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to remove tags from.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The tag key for each tag that you want to remove from the resource.</p>
    #[doc(hidden)]
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UntagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to remove tags from.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The tag key for each tag that you want to remove from the resource.</p>
    pub fn tag_keys(&self) -> std::option::Option<&[std::string::String]> {
        self.tag_keys.as_deref()
    }
}
impl UntagResourceInput {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput).
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput).
pub mod untag_resource_input {

    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource that you want to remove tags from.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource that you want to remove tags from.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tag_keys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        ///
        /// <p>The tag key for each tag that you want to remove from the resource.</p>
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(input.into());
            self.tag_keys = Some(v);
            self
        }
        /// <p>The tag key for each tag that you want to remove from the resource.</p>
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput).
        pub fn build(
            self,
        ) -> Result<crate::input::UntagResourceInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::UntagResourceInput {
                resource_arn: self.resource_arn,
                tag_keys: self.tag_keys,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to add or update tags for.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The tags you want to modify or add to the resource.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl TagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to add or update tags for.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The tags you want to modify or add to the resource.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl TagResourceInput {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput).
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput).
pub mod tag_resource_input {

    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource that you want to add or update tags for.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource that you want to add or update tags for.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags you want to modify or add to the resource.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tags you want to modify or add to the resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput).
        pub fn build(
            self,
        ) -> Result<crate::input::TagResourceInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::TagResourceInput {
                resource_arn: self.resource_arn,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PutRepositoryPermissionsPolicyInput {
    /// <p> The name of the domain containing the repository to set the resource policy on. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p> The name of the repository to set the resource policy on. </p>
    #[doc(hidden)]
    pub repository: std::option::Option<std::string::String>,
    /// <p> Sets the revision of the resource policy that specifies permissions to access the repository. This revision is used for optimistic locking, which prevents others from overwriting your changes to the repository's resource policy. </p>
    #[doc(hidden)]
    pub policy_revision: std::option::Option<std::string::String>,
    /// <p> A valid displayable JSON Aspen policy string to be set as the access control resource policy on the provided repository. </p>
    #[doc(hidden)]
    pub policy_document: std::option::Option<std::string::String>,
}
impl PutRepositoryPermissionsPolicyInput {
    /// <p> The name of the domain containing the repository to set the resource policy on. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p> The name of the repository to set the resource policy on. </p>
    pub fn repository(&self) -> std::option::Option<&str> {
        self.repository.as_deref()
    }
    /// <p> Sets the revision of the resource policy that specifies permissions to access the repository. This revision is used for optimistic locking, which prevents others from overwriting your changes to the repository's resource policy. </p>
    pub fn policy_revision(&self) -> std::option::Option<&str> {
        self.policy_revision.as_deref()
    }
    /// <p> A valid displayable JSON Aspen policy string to be set as the access control resource policy on the provided repository. </p>
    pub fn policy_document(&self) -> std::option::Option<&str> {
        self.policy_document.as_deref()
    }
}
impl PutRepositoryPermissionsPolicyInput {
    /// Creates a new builder-style object to manufacture [`PutRepositoryPermissionsPolicyInput`](crate::input::PutRepositoryPermissionsPolicyInput).
    pub fn builder() -> crate::input::put_repository_permissions_policy_input::Builder {
        crate::input::put_repository_permissions_policy_input::Builder::default()
    }
}

/// See [`PutRepositoryPermissionsPolicyInput`](crate::input::PutRepositoryPermissionsPolicyInput).
pub mod put_repository_permissions_policy_input {

    /// A builder for [`PutRepositoryPermissionsPolicyInput`](crate::input::PutRepositoryPermissionsPolicyInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) repository: std::option::Option<std::string::String>,
        pub(crate) policy_revision: std::option::Option<std::string::String>,
        pub(crate) policy_document: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the domain containing the repository to set the resource policy on. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> The name of the domain containing the repository to set the resource policy on. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p> The name of the repository to set the resource policy on. </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        /// <p> The name of the repository to set the resource policy on. </p>
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// <p> Sets the revision of the resource policy that specifies permissions to access the repository. This revision is used for optimistic locking, which prevents others from overwriting your changes to the repository's resource policy. </p>
        pub fn policy_revision(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_revision = Some(input.into());
            self
        }
        /// <p> Sets the revision of the resource policy that specifies permissions to access the repository. This revision is used for optimistic locking, which prevents others from overwriting your changes to the repository's resource policy. </p>
        pub fn set_policy_revision(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_revision = input;
            self
        }
        /// <p> A valid displayable JSON Aspen policy string to be set as the access control resource policy on the provided repository. </p>
        pub fn policy_document(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_document = Some(input.into());
            self
        }
        /// <p> A valid displayable JSON Aspen policy string to be set as the access control resource policy on the provided repository. </p>
        pub fn set_policy_document(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_document = input;
            self
        }
        /// Consumes the builder and constructs a [`PutRepositoryPermissionsPolicyInput`](crate::input::PutRepositoryPermissionsPolicyInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::PutRepositoryPermissionsPolicyInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::PutRepositoryPermissionsPolicyInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                repository: self.repository,
                policy_revision: self.policy_revision,
                policy_document: self.policy_document,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PutPackageOriginConfigurationInput {
    /// <p>The name of the domain that contains the repository that contains the package.</p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p>The name of the repository that contains the package.</p>
    #[doc(hidden)]
    pub repository: std::option::Option<std::string::String>,
    /// <p>A format that specifies the type of the package to be updated.</p>
    #[doc(hidden)]
    pub format: std::option::Option<crate::model::PackageFormat>,
    /// <p>The namespace of the package to be updated. The package component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li> <p> The namespace of a Maven package is its <code>groupId</code>. </p> </li>
    /// <li> <p> The namespace of an npm package is its <code>scope</code>. </p> </li>
    /// <li> <p> Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace. </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub namespace: std::option::Option<std::string::String>,
    /// <p>The name of the package to be updated.</p>
    #[doc(hidden)]
    pub package: std::option::Option<std::string::String>,
    /// <p>A <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageOriginRestrictions.html">PackageOriginRestrictions</a> object that contains information about the <code>upstream</code> and <code>publish</code> package origin restrictions. The <code>upstream</code> restriction determines if new package versions can be ingested or retained from external connections or upstream repositories. The <code>publish</code> restriction determines if new package versions can be published directly to the repository.</p>
    /// <p>You must include both the desired <code>upstream</code> and <code>publish</code> restrictions.</p>
    #[doc(hidden)]
    pub restrictions: std::option::Option<crate::model::PackageOriginRestrictions>,
}
impl PutPackageOriginConfigurationInput {
    /// <p>The name of the domain that contains the repository that contains the package.</p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p>The name of the repository that contains the package.</p>
    pub fn repository(&self) -> std::option::Option<&str> {
        self.repository.as_deref()
    }
    /// <p>A format that specifies the type of the package to be updated.</p>
    pub fn format(&self) -> std::option::Option<&crate::model::PackageFormat> {
        self.format.as_ref()
    }
    /// <p>The namespace of the package to be updated. The package component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li> <p> The namespace of a Maven package is its <code>groupId</code>. </p> </li>
    /// <li> <p> The namespace of an npm package is its <code>scope</code>. </p> </li>
    /// <li> <p> Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace. </p> </li>
    /// </ul>
    pub fn namespace(&self) -> std::option::Option<&str> {
        self.namespace.as_deref()
    }
    /// <p>The name of the package to be updated.</p>
    pub fn package(&self) -> std::option::Option<&str> {
        self.package.as_deref()
    }
    /// <p>A <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageOriginRestrictions.html">PackageOriginRestrictions</a> object that contains information about the <code>upstream</code> and <code>publish</code> package origin restrictions. The <code>upstream</code> restriction determines if new package versions can be ingested or retained from external connections or upstream repositories. The <code>publish</code> restriction determines if new package versions can be published directly to the repository.</p>
    /// <p>You must include both the desired <code>upstream</code> and <code>publish</code> restrictions.</p>
    pub fn restrictions(&self) -> std::option::Option<&crate::model::PackageOriginRestrictions> {
        self.restrictions.as_ref()
    }
}
impl PutPackageOriginConfigurationInput {
    /// Creates a new builder-style object to manufacture [`PutPackageOriginConfigurationInput`](crate::input::PutPackageOriginConfigurationInput).
    pub fn builder() -> crate::input::put_package_origin_configuration_input::Builder {
        crate::input::put_package_origin_configuration_input::Builder::default()
    }
}

/// See [`PutPackageOriginConfigurationInput`](crate::input::PutPackageOriginConfigurationInput).
pub mod put_package_origin_configuration_input {

    /// A builder for [`PutPackageOriginConfigurationInput`](crate::input::PutPackageOriginConfigurationInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) repository: std::option::Option<std::string::String>,
        pub(crate) format: std::option::Option<crate::model::PackageFormat>,
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) package: std::option::Option<std::string::String>,
        pub(crate) restrictions: std::option::Option<crate::model::PackageOriginRestrictions>,
    }
    impl Builder {
        /// <p>The name of the domain that contains the repository that contains the package.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p>The name of the domain that contains the repository that contains the package.</p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p>The name of the repository that contains the package.</p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        /// <p>The name of the repository that contains the package.</p>
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// <p>A format that specifies the type of the package to be updated.</p>
        pub fn format(mut self, input: crate::model::PackageFormat) -> Self {
            self.format = Some(input);
            self
        }
        /// <p>A format that specifies the type of the package to be updated.</p>
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::PackageFormat>,
        ) -> Self {
            self.format = input;
            self
        }
        /// <p>The namespace of the package to be updated. The package component that specifies its namespace depends on its type. For example:</p>
        /// <ul>
        /// <li> <p> The namespace of a Maven package is its <code>groupId</code>. </p> </li>
        /// <li> <p> The namespace of an npm package is its <code>scope</code>. </p> </li>
        /// <li> <p> Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace. </p> </li>
        /// </ul>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>The namespace of the package to be updated. The package component that specifies its namespace depends on its type. For example:</p>
        /// <ul>
        /// <li> <p> The namespace of a Maven package is its <code>groupId</code>. </p> </li>
        /// <li> <p> The namespace of an npm package is its <code>scope</code>. </p> </li>
        /// <li> <p> Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace. </p> </li>
        /// </ul>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// <p>The name of the package to be updated.</p>
        pub fn package(mut self, input: impl Into<std::string::String>) -> Self {
            self.package = Some(input.into());
            self
        }
        /// <p>The name of the package to be updated.</p>
        pub fn set_package(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.package = input;
            self
        }
        /// <p>A <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageOriginRestrictions.html">PackageOriginRestrictions</a> object that contains information about the <code>upstream</code> and <code>publish</code> package origin restrictions. The <code>upstream</code> restriction determines if new package versions can be ingested or retained from external connections or upstream repositories. The <code>publish</code> restriction determines if new package versions can be published directly to the repository.</p>
        /// <p>You must include both the desired <code>upstream</code> and <code>publish</code> restrictions.</p>
        pub fn restrictions(mut self, input: crate::model::PackageOriginRestrictions) -> Self {
            self.restrictions = Some(input);
            self
        }
        /// <p>A <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageOriginRestrictions.html">PackageOriginRestrictions</a> object that contains information about the <code>upstream</code> and <code>publish</code> package origin restrictions. The <code>upstream</code> restriction determines if new package versions can be ingested or retained from external connections or upstream repositories. The <code>publish</code> restriction determines if new package versions can be published directly to the repository.</p>
        /// <p>You must include both the desired <code>upstream</code> and <code>publish</code> restrictions.</p>
        pub fn set_restrictions(
            mut self,
            input: std::option::Option<crate::model::PackageOriginRestrictions>,
        ) -> Self {
            self.restrictions = input;
            self
        }
        /// Consumes the builder and constructs a [`PutPackageOriginConfigurationInput`](crate::input::PutPackageOriginConfigurationInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::PutPackageOriginConfigurationInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::PutPackageOriginConfigurationInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                repository: self.repository,
                format: self.format,
                namespace: self.namespace,
                package: self.package,
                restrictions: self.restrictions,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PutDomainPermissionsPolicyInput {
    /// <p> The name of the domain on which to set the resource policy. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p> The current revision of the resource policy to be set. This revision is used for optimistic locking, which prevents others from overwriting your changes to the domain's resource policy. </p>
    #[doc(hidden)]
    pub policy_revision: std::option::Option<std::string::String>,
    /// <p> A valid displayable JSON Aspen policy string to be set as the access control resource policy on the provided domain. </p>
    #[doc(hidden)]
    pub policy_document: std::option::Option<std::string::String>,
}
impl PutDomainPermissionsPolicyInput {
    /// <p> The name of the domain on which to set the resource policy. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p> The current revision of the resource policy to be set. This revision is used for optimistic locking, which prevents others from overwriting your changes to the domain's resource policy. </p>
    pub fn policy_revision(&self) -> std::option::Option<&str> {
        self.policy_revision.as_deref()
    }
    /// <p> A valid displayable JSON Aspen policy string to be set as the access control resource policy on the provided domain. </p>
    pub fn policy_document(&self) -> std::option::Option<&str> {
        self.policy_document.as_deref()
    }
}
impl PutDomainPermissionsPolicyInput {
    /// Creates a new builder-style object to manufacture [`PutDomainPermissionsPolicyInput`](crate::input::PutDomainPermissionsPolicyInput).
    pub fn builder() -> crate::input::put_domain_permissions_policy_input::Builder {
        crate::input::put_domain_permissions_policy_input::Builder::default()
    }
}

/// See [`PutDomainPermissionsPolicyInput`](crate::input::PutDomainPermissionsPolicyInput).
pub mod put_domain_permissions_policy_input {

    /// A builder for [`PutDomainPermissionsPolicyInput`](crate::input::PutDomainPermissionsPolicyInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) policy_revision: std::option::Option<std::string::String>,
        pub(crate) policy_document: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the domain on which to set the resource policy. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> The name of the domain on which to set the resource policy. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p> The current revision of the resource policy to be set. This revision is used for optimistic locking, which prevents others from overwriting your changes to the domain's resource policy. </p>
        pub fn policy_revision(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_revision = Some(input.into());
            self
        }
        /// <p> The current revision of the resource policy to be set. This revision is used for optimistic locking, which prevents others from overwriting your changes to the domain's resource policy. </p>
        pub fn set_policy_revision(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_revision = input;
            self
        }
        /// <p> A valid displayable JSON Aspen policy string to be set as the access control resource policy on the provided domain. </p>
        pub fn policy_document(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_document = Some(input.into());
            self
        }
        /// <p> A valid displayable JSON Aspen policy string to be set as the access control resource policy on the provided domain. </p>
        pub fn set_policy_document(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_document = input;
            self
        }
        /// Consumes the builder and constructs a [`PutDomainPermissionsPolicyInput`](crate::input::PutDomainPermissionsPolicyInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::PutDomainPermissionsPolicyInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::PutDomainPermissionsPolicyInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                policy_revision: self.policy_revision,
                policy_document: self.policy_document,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListTagsForResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource to get tags for.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
}
impl ListTagsForResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource to get tags for.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl ListTagsForResourceInput {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
pub mod list_tags_for_resource_input {

    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource to get tags for.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource to get tags for.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListTagsForResourceInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListTagsForResourceInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListRepositoriesInDomainInput {
    /// <p> The name of the domain that contains the returned list of repositories. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p> Filter the list of repositories to only include those that are managed by the Amazon Web Services account ID. </p>
    #[doc(hidden)]
    pub administrator_account: std::option::Option<std::string::String>,
    /// <p> A prefix used to filter returned repositories. Only repositories with names that start with <code>repositoryPrefix</code> are returned. </p>
    #[doc(hidden)]
    pub repository_prefix: std::option::Option<std::string::String>,
    /// <p> The maximum number of results to return per page. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListRepositoriesInDomainInput {
    /// <p> The name of the domain that contains the returned list of repositories. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p> Filter the list of repositories to only include those that are managed by the Amazon Web Services account ID. </p>
    pub fn administrator_account(&self) -> std::option::Option<&str> {
        self.administrator_account.as_deref()
    }
    /// <p> A prefix used to filter returned repositories. Only repositories with names that start with <code>repositoryPrefix</code> are returned. </p>
    pub fn repository_prefix(&self) -> std::option::Option<&str> {
        self.repository_prefix.as_deref()
    }
    /// <p> The maximum number of results to return per page. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl ListRepositoriesInDomainInput {
    /// Creates a new builder-style object to manufacture [`ListRepositoriesInDomainInput`](crate::input::ListRepositoriesInDomainInput).
    pub fn builder() -> crate::input::list_repositories_in_domain_input::Builder {
        crate::input::list_repositories_in_domain_input::Builder::default()
    }
}

/// See [`ListRepositoriesInDomainInput`](crate::input::ListRepositoriesInDomainInput).
pub mod list_repositories_in_domain_input {

    /// A builder for [`ListRepositoriesInDomainInput`](crate::input::ListRepositoriesInDomainInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) administrator_account: std::option::Option<std::string::String>,
        pub(crate) repository_prefix: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the domain that contains the returned list of repositories. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> The name of the domain that contains the returned list of repositories. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p> Filter the list of repositories to only include those that are managed by the Amazon Web Services account ID. </p>
        pub fn administrator_account(mut self, input: impl Into<std::string::String>) -> Self {
            self.administrator_account = Some(input.into());
            self
        }
        /// <p> Filter the list of repositories to only include those that are managed by the Amazon Web Services account ID. </p>
        pub fn set_administrator_account(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.administrator_account = input;
            self
        }
        /// <p> A prefix used to filter returned repositories. Only repositories with names that start with <code>repositoryPrefix</code> are returned. </p>
        pub fn repository_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository_prefix = Some(input.into());
            self
        }
        /// <p> A prefix used to filter returned repositories. Only repositories with names that start with <code>repositoryPrefix</code> are returned. </p>
        pub fn set_repository_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.repository_prefix = input;
            self
        }
        /// <p> The maximum number of results to return per page. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> The maximum number of results to return per page. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListRepositoriesInDomainInput`](crate::input::ListRepositoriesInDomainInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListRepositoriesInDomainInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListRepositoriesInDomainInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                administrator_account: self.administrator_account,
                repository_prefix: self.repository_prefix,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListRepositoriesInput {
    /// <p> A prefix used to filter returned repositories. Only repositories with names that start with <code>repositoryPrefix</code> are returned.</p>
    #[doc(hidden)]
    pub repository_prefix: std::option::Option<std::string::String>,
    /// <p> The maximum number of results to return per page. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListRepositoriesInput {
    /// <p> A prefix used to filter returned repositories. Only repositories with names that start with <code>repositoryPrefix</code> are returned.</p>
    pub fn repository_prefix(&self) -> std::option::Option<&str> {
        self.repository_prefix.as_deref()
    }
    /// <p> The maximum number of results to return per page. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl ListRepositoriesInput {
    /// Creates a new builder-style object to manufacture [`ListRepositoriesInput`](crate::input::ListRepositoriesInput).
    pub fn builder() -> crate::input::list_repositories_input::Builder {
        crate::input::list_repositories_input::Builder::default()
    }
}

/// See [`ListRepositoriesInput`](crate::input::ListRepositoriesInput).
pub mod list_repositories_input {

    /// A builder for [`ListRepositoriesInput`](crate::input::ListRepositoriesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) repository_prefix: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> A prefix used to filter returned repositories. Only repositories with names that start with <code>repositoryPrefix</code> are returned.</p>
        pub fn repository_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository_prefix = Some(input.into());
            self
        }
        /// <p> A prefix used to filter returned repositories. Only repositories with names that start with <code>repositoryPrefix</code> are returned.</p>
        pub fn set_repository_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.repository_prefix = input;
            self
        }
        /// <p> The maximum number of results to return per page. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> The maximum number of results to return per page. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListRepositoriesInput`](crate::input::ListRepositoriesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListRepositoriesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListRepositoriesInput {
                repository_prefix: self.repository_prefix,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListPackageVersionsInput {
    /// <p> The name of the domain that contains the repository that contains the requested package versions. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p> The name of the repository that contains the requested package versions. </p>
    #[doc(hidden)]
    pub repository: std::option::Option<std::string::String>,
    /// <p> The format of the returned package versions. </p>
    #[doc(hidden)]
    pub format: std::option::Option<crate::model::PackageFormat>,
    /// <p>The namespace of the package that contains the requested package versions. The package component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li> <p> The namespace of a Maven package is its <code>groupId</code>. </p> </li>
    /// <li> <p> The namespace of an npm package is its <code>scope</code>. </p> </li>
    /// <li> <p> Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace. </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub namespace: std::option::Option<std::string::String>,
    /// <p> The name of the package for which you want to request package versions. </p>
    #[doc(hidden)]
    pub package: std::option::Option<std::string::String>,
    /// <p> A string that filters the requested package versions by status. </p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::PackageVersionStatus>,
    /// <p> How to sort the requested list of package versions. </p>
    #[doc(hidden)]
    pub sort_by: std::option::Option<crate::model::PackageVersionSortType>,
    /// <p> The maximum number of results to return per page. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The <code>originType</code> used to filter package versions. Only package versions with the provided <code>originType</code> will be returned.</p>
    #[doc(hidden)]
    pub origin_type: std::option::Option<crate::model::PackageVersionOriginType>,
}
impl ListPackageVersionsInput {
    /// <p> The name of the domain that contains the repository that contains the requested package versions. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p> The name of the repository that contains the requested package versions. </p>
    pub fn repository(&self) -> std::option::Option<&str> {
        self.repository.as_deref()
    }
    /// <p> The format of the returned package versions. </p>
    pub fn format(&self) -> std::option::Option<&crate::model::PackageFormat> {
        self.format.as_ref()
    }
    /// <p>The namespace of the package that contains the requested package versions. The package component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li> <p> The namespace of a Maven package is its <code>groupId</code>. </p> </li>
    /// <li> <p> The namespace of an npm package is its <code>scope</code>. </p> </li>
    /// <li> <p> Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace. </p> </li>
    /// </ul>
    pub fn namespace(&self) -> std::option::Option<&str> {
        self.namespace.as_deref()
    }
    /// <p> The name of the package for which you want to request package versions. </p>
    pub fn package(&self) -> std::option::Option<&str> {
        self.package.as_deref()
    }
    /// <p> A string that filters the requested package versions by status. </p>
    pub fn status(&self) -> std::option::Option<&crate::model::PackageVersionStatus> {
        self.status.as_ref()
    }
    /// <p> How to sort the requested list of package versions. </p>
    pub fn sort_by(&self) -> std::option::Option<&crate::model::PackageVersionSortType> {
        self.sort_by.as_ref()
    }
    /// <p> The maximum number of results to return per page. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The <code>originType</code> used to filter package versions. Only package versions with the provided <code>originType</code> will be returned.</p>
    pub fn origin_type(&self) -> std::option::Option<&crate::model::PackageVersionOriginType> {
        self.origin_type.as_ref()
    }
}
impl ListPackageVersionsInput {
    /// Creates a new builder-style object to manufacture [`ListPackageVersionsInput`](crate::input::ListPackageVersionsInput).
    pub fn builder() -> crate::input::list_package_versions_input::Builder {
        crate::input::list_package_versions_input::Builder::default()
    }
}

/// See [`ListPackageVersionsInput`](crate::input::ListPackageVersionsInput).
pub mod list_package_versions_input {

    /// A builder for [`ListPackageVersionsInput`](crate::input::ListPackageVersionsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) repository: std::option::Option<std::string::String>,
        pub(crate) format: std::option::Option<crate::model::PackageFormat>,
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) package: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::PackageVersionStatus>,
        pub(crate) sort_by: std::option::Option<crate::model::PackageVersionSortType>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) origin_type: std::option::Option<crate::model::PackageVersionOriginType>,
    }
    impl Builder {
        /// <p> The name of the domain that contains the repository that contains the requested package versions. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> The name of the domain that contains the repository that contains the requested package versions. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p> The name of the repository that contains the requested package versions. </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        /// <p> The name of the repository that contains the requested package versions. </p>
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// <p> The format of the returned package versions. </p>
        pub fn format(mut self, input: crate::model::PackageFormat) -> Self {
            self.format = Some(input);
            self
        }
        /// <p> The format of the returned package versions. </p>
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::PackageFormat>,
        ) -> Self {
            self.format = input;
            self
        }
        /// <p>The namespace of the package that contains the requested package versions. The package component that specifies its namespace depends on its type. For example:</p>
        /// <ul>
        /// <li> <p> The namespace of a Maven package is its <code>groupId</code>. </p> </li>
        /// <li> <p> The namespace of an npm package is its <code>scope</code>. </p> </li>
        /// <li> <p> Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace. </p> </li>
        /// </ul>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>The namespace of the package that contains the requested package versions. The package component that specifies its namespace depends on its type. For example:</p>
        /// <ul>
        /// <li> <p> The namespace of a Maven package is its <code>groupId</code>. </p> </li>
        /// <li> <p> The namespace of an npm package is its <code>scope</code>. </p> </li>
        /// <li> <p> Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace. </p> </li>
        /// </ul>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// <p> The name of the package for which you want to request package versions. </p>
        pub fn package(mut self, input: impl Into<std::string::String>) -> Self {
            self.package = Some(input.into());
            self
        }
        /// <p> The name of the package for which you want to request package versions. </p>
        pub fn set_package(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.package = input;
            self
        }
        /// <p> A string that filters the requested package versions by status. </p>
        pub fn status(mut self, input: crate::model::PackageVersionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p> A string that filters the requested package versions by status. </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::PackageVersionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p> How to sort the requested list of package versions. </p>
        pub fn sort_by(mut self, input: crate::model::PackageVersionSortType) -> Self {
            self.sort_by = Some(input);
            self
        }
        /// <p> How to sort the requested list of package versions. </p>
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<crate::model::PackageVersionSortType>,
        ) -> Self {
            self.sort_by = input;
            self
        }
        /// <p> The maximum number of results to return per page. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> The maximum number of results to return per page. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The <code>originType</code> used to filter package versions. Only package versions with the provided <code>originType</code> will be returned.</p>
        pub fn origin_type(mut self, input: crate::model::PackageVersionOriginType) -> Self {
            self.origin_type = Some(input);
            self
        }
        /// <p>The <code>originType</code> used to filter package versions. Only package versions with the provided <code>originType</code> will be returned.</p>
        pub fn set_origin_type(
            mut self,
            input: std::option::Option<crate::model::PackageVersionOriginType>,
        ) -> Self {
            self.origin_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPackageVersionsInput`](crate::input::ListPackageVersionsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListPackageVersionsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListPackageVersionsInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                repository: self.repository,
                format: self.format,
                namespace: self.namespace,
                package: self.package,
                status: self.status,
                sort_by: self.sort_by,
                max_results: self.max_results,
                next_token: self.next_token,
                origin_type: self.origin_type,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListPackageVersionDependenciesInput {
    /// <p> The name of the domain that contains the repository that contains the requested package version dependencies. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p> The name of the repository that contains the requested package version. </p>
    #[doc(hidden)]
    pub repository: std::option::Option<std::string::String>,
    /// <p> The format of the package with the requested dependencies. </p>
    #[doc(hidden)]
    pub format: std::option::Option<crate::model::PackageFormat>,
    /// <p>The namespace of the package version with the requested dependencies. The package version component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
    /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
    /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub namespace: std::option::Option<std::string::String>,
    /// <p> The name of the package versions' package. </p>
    #[doc(hidden)]
    pub package: std::option::Option<std::string::String>,
    /// <p> A string that contains the package version (for example, <code>3.5.2</code>). </p>
    #[doc(hidden)]
    pub package_version: std::option::Option<std::string::String>,
    /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListPackageVersionDependenciesInput {
    /// <p> The name of the domain that contains the repository that contains the requested package version dependencies. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p> The name of the repository that contains the requested package version. </p>
    pub fn repository(&self) -> std::option::Option<&str> {
        self.repository.as_deref()
    }
    /// <p> The format of the package with the requested dependencies. </p>
    pub fn format(&self) -> std::option::Option<&crate::model::PackageFormat> {
        self.format.as_ref()
    }
    /// <p>The namespace of the package version with the requested dependencies. The package version component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
    /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
    /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
    /// </ul>
    pub fn namespace(&self) -> std::option::Option<&str> {
        self.namespace.as_deref()
    }
    /// <p> The name of the package versions' package. </p>
    pub fn package(&self) -> std::option::Option<&str> {
        self.package.as_deref()
    }
    /// <p> A string that contains the package version (for example, <code>3.5.2</code>). </p>
    pub fn package_version(&self) -> std::option::Option<&str> {
        self.package_version.as_deref()
    }
    /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl ListPackageVersionDependenciesInput {
    /// Creates a new builder-style object to manufacture [`ListPackageVersionDependenciesInput`](crate::input::ListPackageVersionDependenciesInput).
    pub fn builder() -> crate::input::list_package_version_dependencies_input::Builder {
        crate::input::list_package_version_dependencies_input::Builder::default()
    }
}

/// See [`ListPackageVersionDependenciesInput`](crate::input::ListPackageVersionDependenciesInput).
pub mod list_package_version_dependencies_input {

    /// A builder for [`ListPackageVersionDependenciesInput`](crate::input::ListPackageVersionDependenciesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) repository: std::option::Option<std::string::String>,
        pub(crate) format: std::option::Option<crate::model::PackageFormat>,
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) package: std::option::Option<std::string::String>,
        pub(crate) package_version: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the domain that contains the repository that contains the requested package version dependencies. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> The name of the domain that contains the repository that contains the requested package version dependencies. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p> The name of the repository that contains the requested package version. </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        /// <p> The name of the repository that contains the requested package version. </p>
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// <p> The format of the package with the requested dependencies. </p>
        pub fn format(mut self, input: crate::model::PackageFormat) -> Self {
            self.format = Some(input);
            self
        }
        /// <p> The format of the package with the requested dependencies. </p>
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::PackageFormat>,
        ) -> Self {
            self.format = input;
            self
        }
        /// <p>The namespace of the package version with the requested dependencies. The package version component that specifies its namespace depends on its type. For example:</p>
        /// <ul>
        /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
        /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
        /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
        /// </ul>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>The namespace of the package version with the requested dependencies. The package version component that specifies its namespace depends on its type. For example:</p>
        /// <ul>
        /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
        /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
        /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
        /// </ul>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// <p> The name of the package versions' package. </p>
        pub fn package(mut self, input: impl Into<std::string::String>) -> Self {
            self.package = Some(input.into());
            self
        }
        /// <p> The name of the package versions' package. </p>
        pub fn set_package(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.package = input;
            self
        }
        /// <p> A string that contains the package version (for example, <code>3.5.2</code>). </p>
        pub fn package_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.package_version = Some(input.into());
            self
        }
        /// <p> A string that contains the package version (for example, <code>3.5.2</code>). </p>
        pub fn set_package_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.package_version = input;
            self
        }
        /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPackageVersionDependenciesInput`](crate::input::ListPackageVersionDependenciesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListPackageVersionDependenciesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListPackageVersionDependenciesInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                repository: self.repository,
                format: self.format,
                namespace: self.namespace,
                package: self.package,
                package_version: self.package_version,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListPackageVersionAssetsInput {
    /// <p> The name of the domain that contains the repository associated with the package version assets. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p> The name of the repository that contains the package that contains the requested package version assets. </p>
    #[doc(hidden)]
    pub repository: std::option::Option<std::string::String>,
    /// <p> The format of the package that contains the requested package version assets. </p>
    #[doc(hidden)]
    pub format: std::option::Option<crate::model::PackageFormat>,
    /// <p>The namespace of the package version that contains the requested package version assets. The package version component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
    /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
    /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub namespace: std::option::Option<std::string::String>,
    /// <p> The name of the package that contains the requested package version assets. </p>
    #[doc(hidden)]
    pub package: std::option::Option<std::string::String>,
    /// <p> A string that contains the package version (for example, <code>3.5.2</code>). </p>
    #[doc(hidden)]
    pub package_version: std::option::Option<std::string::String>,
    /// <p> The maximum number of results to return per page. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListPackageVersionAssetsInput {
    /// <p> The name of the domain that contains the repository associated with the package version assets. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p> The name of the repository that contains the package that contains the requested package version assets. </p>
    pub fn repository(&self) -> std::option::Option<&str> {
        self.repository.as_deref()
    }
    /// <p> The format of the package that contains the requested package version assets. </p>
    pub fn format(&self) -> std::option::Option<&crate::model::PackageFormat> {
        self.format.as_ref()
    }
    /// <p>The namespace of the package version that contains the requested package version assets. The package version component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
    /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
    /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
    /// </ul>
    pub fn namespace(&self) -> std::option::Option<&str> {
        self.namespace.as_deref()
    }
    /// <p> The name of the package that contains the requested package version assets. </p>
    pub fn package(&self) -> std::option::Option<&str> {
        self.package.as_deref()
    }
    /// <p> A string that contains the package version (for example, <code>3.5.2</code>). </p>
    pub fn package_version(&self) -> std::option::Option<&str> {
        self.package_version.as_deref()
    }
    /// <p> The maximum number of results to return per page. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl ListPackageVersionAssetsInput {
    /// Creates a new builder-style object to manufacture [`ListPackageVersionAssetsInput`](crate::input::ListPackageVersionAssetsInput).
    pub fn builder() -> crate::input::list_package_version_assets_input::Builder {
        crate::input::list_package_version_assets_input::Builder::default()
    }
}

/// See [`ListPackageVersionAssetsInput`](crate::input::ListPackageVersionAssetsInput).
pub mod list_package_version_assets_input {

    /// A builder for [`ListPackageVersionAssetsInput`](crate::input::ListPackageVersionAssetsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) repository: std::option::Option<std::string::String>,
        pub(crate) format: std::option::Option<crate::model::PackageFormat>,
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) package: std::option::Option<std::string::String>,
        pub(crate) package_version: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the domain that contains the repository associated with the package version assets. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> The name of the domain that contains the repository associated with the package version assets. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p> The name of the repository that contains the package that contains the requested package version assets. </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        /// <p> The name of the repository that contains the package that contains the requested package version assets. </p>
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// <p> The format of the package that contains the requested package version assets. </p>
        pub fn format(mut self, input: crate::model::PackageFormat) -> Self {
            self.format = Some(input);
            self
        }
        /// <p> The format of the package that contains the requested package version assets. </p>
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::PackageFormat>,
        ) -> Self {
            self.format = input;
            self
        }
        /// <p>The namespace of the package version that contains the requested package version assets. The package version component that specifies its namespace depends on its type. For example:</p>
        /// <ul>
        /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
        /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
        /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
        /// </ul>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>The namespace of the package version that contains the requested package version assets. The package version component that specifies its namespace depends on its type. For example:</p>
        /// <ul>
        /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
        /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
        /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
        /// </ul>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// <p> The name of the package that contains the requested package version assets. </p>
        pub fn package(mut self, input: impl Into<std::string::String>) -> Self {
            self.package = Some(input.into());
            self
        }
        /// <p> The name of the package that contains the requested package version assets. </p>
        pub fn set_package(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.package = input;
            self
        }
        /// <p> A string that contains the package version (for example, <code>3.5.2</code>). </p>
        pub fn package_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.package_version = Some(input.into());
            self
        }
        /// <p> A string that contains the package version (for example, <code>3.5.2</code>). </p>
        pub fn set_package_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.package_version = input;
            self
        }
        /// <p> The maximum number of results to return per page. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> The maximum number of results to return per page. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPackageVersionAssetsInput`](crate::input::ListPackageVersionAssetsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListPackageVersionAssetsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListPackageVersionAssetsInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                repository: self.repository,
                format: self.format,
                namespace: self.namespace,
                package: self.package,
                package_version: self.package_version,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListPackagesInput {
    /// <p> The name of the domain that contains the repository that contains the requested packages. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p> The name of the repository that contains the requested packages. </p>
    #[doc(hidden)]
    pub repository: std::option::Option<std::string::String>,
    /// <p>The format used to filter requested packages. Only packages from the provided format will be returned.</p>
    #[doc(hidden)]
    pub format: std::option::Option<crate::model::PackageFormat>,
    /// <p>The namespace prefix used to filter requested packages. Only packages with a namespace that starts with the provided string value are returned. Note that although this option is called <code>--namespace</code> and not <code>--namespace-prefix</code>, it has prefix-matching behavior.</p>
    /// <p>Each package format uses namespace as follows:</p>
    /// <ul>
    /// <li> <p> The namespace of a Maven package is its <code>groupId</code>. </p> </li>
    /// <li> <p> The namespace of an npm package is its <code>scope</code>. </p> </li>
    /// <li> <p> Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace. </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub namespace: std::option::Option<std::string::String>,
    /// <p> A prefix used to filter requested packages. Only packages with names that start with <code>packagePrefix</code> are returned. </p>
    #[doc(hidden)]
    pub package_prefix: std::option::Option<std::string::String>,
    /// <p> The maximum number of results to return per page. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The value of the <code>Publish</code> package origin control restriction used to filter requested packages. Only packages with the provided restriction are returned. For more information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageOriginRestrictions.html">PackageOriginRestrictions</a>.</p>
    #[doc(hidden)]
    pub publish: std::option::Option<crate::model::AllowPublish>,
    /// <p>The value of the <code>Upstream</code> package origin control restriction used to filter requested packages. Only packages with the provided restriction are returned. For more information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageOriginRestrictions.html">PackageOriginRestrictions</a>.</p>
    #[doc(hidden)]
    pub upstream: std::option::Option<crate::model::AllowUpstream>,
}
impl ListPackagesInput {
    /// <p> The name of the domain that contains the repository that contains the requested packages. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p> The name of the repository that contains the requested packages. </p>
    pub fn repository(&self) -> std::option::Option<&str> {
        self.repository.as_deref()
    }
    /// <p>The format used to filter requested packages. Only packages from the provided format will be returned.</p>
    pub fn format(&self) -> std::option::Option<&crate::model::PackageFormat> {
        self.format.as_ref()
    }
    /// <p>The namespace prefix used to filter requested packages. Only packages with a namespace that starts with the provided string value are returned. Note that although this option is called <code>--namespace</code> and not <code>--namespace-prefix</code>, it has prefix-matching behavior.</p>
    /// <p>Each package format uses namespace as follows:</p>
    /// <ul>
    /// <li> <p> The namespace of a Maven package is its <code>groupId</code>. </p> </li>
    /// <li> <p> The namespace of an npm package is its <code>scope</code>. </p> </li>
    /// <li> <p> Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace. </p> </li>
    /// </ul>
    pub fn namespace(&self) -> std::option::Option<&str> {
        self.namespace.as_deref()
    }
    /// <p> A prefix used to filter requested packages. Only packages with names that start with <code>packagePrefix</code> are returned. </p>
    pub fn package_prefix(&self) -> std::option::Option<&str> {
        self.package_prefix.as_deref()
    }
    /// <p> The maximum number of results to return per page. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The value of the <code>Publish</code> package origin control restriction used to filter requested packages. Only packages with the provided restriction are returned. For more information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageOriginRestrictions.html">PackageOriginRestrictions</a>.</p>
    pub fn publish(&self) -> std::option::Option<&crate::model::AllowPublish> {
        self.publish.as_ref()
    }
    /// <p>The value of the <code>Upstream</code> package origin control restriction used to filter requested packages. Only packages with the provided restriction are returned. For more information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageOriginRestrictions.html">PackageOriginRestrictions</a>.</p>
    pub fn upstream(&self) -> std::option::Option<&crate::model::AllowUpstream> {
        self.upstream.as_ref()
    }
}
impl ListPackagesInput {
    /// Creates a new builder-style object to manufacture [`ListPackagesInput`](crate::input::ListPackagesInput).
    pub fn builder() -> crate::input::list_packages_input::Builder {
        crate::input::list_packages_input::Builder::default()
    }
}

/// See [`ListPackagesInput`](crate::input::ListPackagesInput).
pub mod list_packages_input {

    /// A builder for [`ListPackagesInput`](crate::input::ListPackagesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) repository: std::option::Option<std::string::String>,
        pub(crate) format: std::option::Option<crate::model::PackageFormat>,
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) package_prefix: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) publish: std::option::Option<crate::model::AllowPublish>,
        pub(crate) upstream: std::option::Option<crate::model::AllowUpstream>,
    }
    impl Builder {
        /// <p> The name of the domain that contains the repository that contains the requested packages. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> The name of the domain that contains the repository that contains the requested packages. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p> The name of the repository that contains the requested packages. </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        /// <p> The name of the repository that contains the requested packages. </p>
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// <p>The format used to filter requested packages. Only packages from the provided format will be returned.</p>
        pub fn format(mut self, input: crate::model::PackageFormat) -> Self {
            self.format = Some(input);
            self
        }
        /// <p>The format used to filter requested packages. Only packages from the provided format will be returned.</p>
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::PackageFormat>,
        ) -> Self {
            self.format = input;
            self
        }
        /// <p>The namespace prefix used to filter requested packages. Only packages with a namespace that starts with the provided string value are returned. Note that although this option is called <code>--namespace</code> and not <code>--namespace-prefix</code>, it has prefix-matching behavior.</p>
        /// <p>Each package format uses namespace as follows:</p>
        /// <ul>
        /// <li> <p> The namespace of a Maven package is its <code>groupId</code>. </p> </li>
        /// <li> <p> The namespace of an npm package is its <code>scope</code>. </p> </li>
        /// <li> <p> Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace. </p> </li>
        /// </ul>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>The namespace prefix used to filter requested packages. Only packages with a namespace that starts with the provided string value are returned. Note that although this option is called <code>--namespace</code> and not <code>--namespace-prefix</code>, it has prefix-matching behavior.</p>
        /// <p>Each package format uses namespace as follows:</p>
        /// <ul>
        /// <li> <p> The namespace of a Maven package is its <code>groupId</code>. </p> </li>
        /// <li> <p> The namespace of an npm package is its <code>scope</code>. </p> </li>
        /// <li> <p> Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace. </p> </li>
        /// </ul>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// <p> A prefix used to filter requested packages. Only packages with names that start with <code>packagePrefix</code> are returned. </p>
        pub fn package_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.package_prefix = Some(input.into());
            self
        }
        /// <p> A prefix used to filter requested packages. Only packages with names that start with <code>packagePrefix</code> are returned. </p>
        pub fn set_package_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.package_prefix = input;
            self
        }
        /// <p> The maximum number of results to return per page. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> The maximum number of results to return per page. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The value of the <code>Publish</code> package origin control restriction used to filter requested packages. Only packages with the provided restriction are returned. For more information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageOriginRestrictions.html">PackageOriginRestrictions</a>.</p>
        pub fn publish(mut self, input: crate::model::AllowPublish) -> Self {
            self.publish = Some(input);
            self
        }
        /// <p>The value of the <code>Publish</code> package origin control restriction used to filter requested packages. Only packages with the provided restriction are returned. For more information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageOriginRestrictions.html">PackageOriginRestrictions</a>.</p>
        pub fn set_publish(
            mut self,
            input: std::option::Option<crate::model::AllowPublish>,
        ) -> Self {
            self.publish = input;
            self
        }
        /// <p>The value of the <code>Upstream</code> package origin control restriction used to filter requested packages. Only packages with the provided restriction are returned. For more information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageOriginRestrictions.html">PackageOriginRestrictions</a>.</p>
        pub fn upstream(mut self, input: crate::model::AllowUpstream) -> Self {
            self.upstream = Some(input);
            self
        }
        /// <p>The value of the <code>Upstream</code> package origin control restriction used to filter requested packages. Only packages with the provided restriction are returned. For more information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageOriginRestrictions.html">PackageOriginRestrictions</a>.</p>
        pub fn set_upstream(
            mut self,
            input: std::option::Option<crate::model::AllowUpstream>,
        ) -> Self {
            self.upstream = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPackagesInput`](crate::input::ListPackagesInput).
        pub fn build(
            self,
        ) -> Result<crate::input::ListPackagesInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::ListPackagesInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                repository: self.repository,
                format: self.format,
                namespace: self.namespace,
                package_prefix: self.package_prefix,
                max_results: self.max_results,
                next_token: self.next_token,
                publish: self.publish,
                upstream: self.upstream,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListDomainsInput {
    /// <p> The maximum number of results to return per page. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListDomainsInput {
    /// <p> The maximum number of results to return per page. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl ListDomainsInput {
    /// Creates a new builder-style object to manufacture [`ListDomainsInput`](crate::input::ListDomainsInput).
    pub fn builder() -> crate::input::list_domains_input::Builder {
        crate::input::list_domains_input::Builder::default()
    }
}

/// See [`ListDomainsInput`](crate::input::ListDomainsInput).
pub mod list_domains_input {

    /// A builder for [`ListDomainsInput`](crate::input::ListDomainsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The maximum number of results to return per page. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> The maximum number of results to return per page. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListDomainsInput`](crate::input::ListDomainsInput).
        pub fn build(
            self,
        ) -> Result<crate::input::ListDomainsInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::ListDomainsInput {
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetRepositoryPermissionsPolicyInput {
    /// <p> The name of the domain containing the repository whose associated resource policy is to be retrieved. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p> The name of the repository whose associated resource policy is to be retrieved. </p>
    #[doc(hidden)]
    pub repository: std::option::Option<std::string::String>,
}
impl GetRepositoryPermissionsPolicyInput {
    /// <p> The name of the domain containing the repository whose associated resource policy is to be retrieved. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p> The name of the repository whose associated resource policy is to be retrieved. </p>
    pub fn repository(&self) -> std::option::Option<&str> {
        self.repository.as_deref()
    }
}
impl GetRepositoryPermissionsPolicyInput {
    /// Creates a new builder-style object to manufacture [`GetRepositoryPermissionsPolicyInput`](crate::input::GetRepositoryPermissionsPolicyInput).
    pub fn builder() -> crate::input::get_repository_permissions_policy_input::Builder {
        crate::input::get_repository_permissions_policy_input::Builder::default()
    }
}

/// See [`GetRepositoryPermissionsPolicyInput`](crate::input::GetRepositoryPermissionsPolicyInput).
pub mod get_repository_permissions_policy_input {

    /// A builder for [`GetRepositoryPermissionsPolicyInput`](crate::input::GetRepositoryPermissionsPolicyInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) repository: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the domain containing the repository whose associated resource policy is to be retrieved. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> The name of the domain containing the repository whose associated resource policy is to be retrieved. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p> The name of the repository whose associated resource policy is to be retrieved. </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        /// <p> The name of the repository whose associated resource policy is to be retrieved. </p>
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRepositoryPermissionsPolicyInput`](crate::input::GetRepositoryPermissionsPolicyInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetRepositoryPermissionsPolicyInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetRepositoryPermissionsPolicyInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                repository: self.repository,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetRepositoryEndpointInput {
    /// <p> The name of the domain that contains the repository. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain that contains the repository. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p> The name of the repository. </p>
    #[doc(hidden)]
    pub repository: std::option::Option<std::string::String>,
    /// <p> Returns which endpoint of a repository to return. A repository has one endpoint for each package format. </p>
    #[doc(hidden)]
    pub format: std::option::Option<crate::model::PackageFormat>,
}
impl GetRepositoryEndpointInput {
    /// <p> The name of the domain that contains the repository. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain that contains the repository. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p> The name of the repository. </p>
    pub fn repository(&self) -> std::option::Option<&str> {
        self.repository.as_deref()
    }
    /// <p> Returns which endpoint of a repository to return. A repository has one endpoint for each package format. </p>
    pub fn format(&self) -> std::option::Option<&crate::model::PackageFormat> {
        self.format.as_ref()
    }
}
impl GetRepositoryEndpointInput {
    /// Creates a new builder-style object to manufacture [`GetRepositoryEndpointInput`](crate::input::GetRepositoryEndpointInput).
    pub fn builder() -> crate::input::get_repository_endpoint_input::Builder {
        crate::input::get_repository_endpoint_input::Builder::default()
    }
}

/// See [`GetRepositoryEndpointInput`](crate::input::GetRepositoryEndpointInput).
pub mod get_repository_endpoint_input {

    /// A builder for [`GetRepositoryEndpointInput`](crate::input::GetRepositoryEndpointInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) repository: std::option::Option<std::string::String>,
        pub(crate) format: std::option::Option<crate::model::PackageFormat>,
    }
    impl Builder {
        /// <p> The name of the domain that contains the repository. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> The name of the domain that contains the repository. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain that contains the repository. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain that contains the repository. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p> The name of the repository. </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        /// <p> The name of the repository. </p>
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// <p> Returns which endpoint of a repository to return. A repository has one endpoint for each package format. </p>
        pub fn format(mut self, input: crate::model::PackageFormat) -> Self {
            self.format = Some(input);
            self
        }
        /// <p> Returns which endpoint of a repository to return. A repository has one endpoint for each package format. </p>
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::PackageFormat>,
        ) -> Self {
            self.format = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRepositoryEndpointInput`](crate::input::GetRepositoryEndpointInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetRepositoryEndpointInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetRepositoryEndpointInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                repository: self.repository,
                format: self.format,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetPackageVersionReadmeInput {
    /// <p> The name of the domain that contains the repository that contains the package version with the requested readme file. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p> The repository that contains the package with the requested readme file. </p>
    #[doc(hidden)]
    pub repository: std::option::Option<std::string::String>,
    /// <p> A format that specifies the type of the package version with the requested readme file. </p> <note>
    /// <p>Although <code>maven</code> is listed as a valid value, CodeArtifact does not support displaying readme files for Maven packages.</p>
    /// </note>
    #[doc(hidden)]
    pub format: std::option::Option<crate::model::PackageFormat>,
    /// <p>The namespace of the package version with the requested readme file. The package version component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
    /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
    /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub namespace: std::option::Option<std::string::String>,
    /// <p> The name of the package version that contains the requested readme file. </p>
    #[doc(hidden)]
    pub package: std::option::Option<std::string::String>,
    /// <p> A string that contains the package version (for example, <code>3.5.2</code>). </p>
    #[doc(hidden)]
    pub package_version: std::option::Option<std::string::String>,
}
impl GetPackageVersionReadmeInput {
    /// <p> The name of the domain that contains the repository that contains the package version with the requested readme file. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p> The repository that contains the package with the requested readme file. </p>
    pub fn repository(&self) -> std::option::Option<&str> {
        self.repository.as_deref()
    }
    /// <p> A format that specifies the type of the package version with the requested readme file. </p> <note>
    /// <p>Although <code>maven</code> is listed as a valid value, CodeArtifact does not support displaying readme files for Maven packages.</p>
    /// </note>
    pub fn format(&self) -> std::option::Option<&crate::model::PackageFormat> {
        self.format.as_ref()
    }
    /// <p>The namespace of the package version with the requested readme file. The package version component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
    /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
    /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
    /// </ul>
    pub fn namespace(&self) -> std::option::Option<&str> {
        self.namespace.as_deref()
    }
    /// <p> The name of the package version that contains the requested readme file. </p>
    pub fn package(&self) -> std::option::Option<&str> {
        self.package.as_deref()
    }
    /// <p> A string that contains the package version (for example, <code>3.5.2</code>). </p>
    pub fn package_version(&self) -> std::option::Option<&str> {
        self.package_version.as_deref()
    }
}
impl GetPackageVersionReadmeInput {
    /// Creates a new builder-style object to manufacture [`GetPackageVersionReadmeInput`](crate::input::GetPackageVersionReadmeInput).
    pub fn builder() -> crate::input::get_package_version_readme_input::Builder {
        crate::input::get_package_version_readme_input::Builder::default()
    }
}

/// See [`GetPackageVersionReadmeInput`](crate::input::GetPackageVersionReadmeInput).
pub mod get_package_version_readme_input {

    /// A builder for [`GetPackageVersionReadmeInput`](crate::input::GetPackageVersionReadmeInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) repository: std::option::Option<std::string::String>,
        pub(crate) format: std::option::Option<crate::model::PackageFormat>,
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) package: std::option::Option<std::string::String>,
        pub(crate) package_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the domain that contains the repository that contains the package version with the requested readme file. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> The name of the domain that contains the repository that contains the package version with the requested readme file. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p> The repository that contains the package with the requested readme file. </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        /// <p> The repository that contains the package with the requested readme file. </p>
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// <p> A format that specifies the type of the package version with the requested readme file. </p> <note>
        /// <p>Although <code>maven</code> is listed as a valid value, CodeArtifact does not support displaying readme files for Maven packages.</p>
        /// </note>
        pub fn format(mut self, input: crate::model::PackageFormat) -> Self {
            self.format = Some(input);
            self
        }
        /// <p> A format that specifies the type of the package version with the requested readme file. </p> <note>
        /// <p>Although <code>maven</code> is listed as a valid value, CodeArtifact does not support displaying readme files for Maven packages.</p>
        /// </note>
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::PackageFormat>,
        ) -> Self {
            self.format = input;
            self
        }
        /// <p>The namespace of the package version with the requested readme file. The package version component that specifies its namespace depends on its type. For example:</p>
        /// <ul>
        /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
        /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
        /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
        /// </ul>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>The namespace of the package version with the requested readme file. The package version component that specifies its namespace depends on its type. For example:</p>
        /// <ul>
        /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
        /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
        /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
        /// </ul>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// <p> The name of the package version that contains the requested readme file. </p>
        pub fn package(mut self, input: impl Into<std::string::String>) -> Self {
            self.package = Some(input.into());
            self
        }
        /// <p> The name of the package version that contains the requested readme file. </p>
        pub fn set_package(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.package = input;
            self
        }
        /// <p> A string that contains the package version (for example, <code>3.5.2</code>). </p>
        pub fn package_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.package_version = Some(input.into());
            self
        }
        /// <p> A string that contains the package version (for example, <code>3.5.2</code>). </p>
        pub fn set_package_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.package_version = input;
            self
        }
        /// Consumes the builder and constructs a [`GetPackageVersionReadmeInput`](crate::input::GetPackageVersionReadmeInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetPackageVersionReadmeInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetPackageVersionReadmeInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                repository: self.repository,
                format: self.format,
                namespace: self.namespace,
                package: self.package,
                package_version: self.package_version,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetPackageVersionAssetInput {
    /// <p> The name of the domain that contains the repository that contains the package version with the requested asset. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p> The repository that contains the package version with the requested asset. </p>
    #[doc(hidden)]
    pub repository: std::option::Option<std::string::String>,
    /// <p> A format that specifies the type of the package version with the requested asset file. </p>
    #[doc(hidden)]
    pub format: std::option::Option<crate::model::PackageFormat>,
    /// <p>The namespace of the package version with the requested asset file. The package version component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
    /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
    /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub namespace: std::option::Option<std::string::String>,
    /// <p> The name of the package that contains the requested asset. </p>
    #[doc(hidden)]
    pub package: std::option::Option<std::string::String>,
    /// <p> A string that contains the package version (for example, <code>3.5.2</code>). </p>
    #[doc(hidden)]
    pub package_version: std::option::Option<std::string::String>,
    /// <p> The name of the requested asset. </p>
    #[doc(hidden)]
    pub asset: std::option::Option<std::string::String>,
    /// <p> The name of the package version revision that contains the requested asset. </p>
    #[doc(hidden)]
    pub package_version_revision: std::option::Option<std::string::String>,
}
impl GetPackageVersionAssetInput {
    /// <p> The name of the domain that contains the repository that contains the package version with the requested asset. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p> The repository that contains the package version with the requested asset. </p>
    pub fn repository(&self) -> std::option::Option<&str> {
        self.repository.as_deref()
    }
    /// <p> A format that specifies the type of the package version with the requested asset file. </p>
    pub fn format(&self) -> std::option::Option<&crate::model::PackageFormat> {
        self.format.as_ref()
    }
    /// <p>The namespace of the package version with the requested asset file. The package version component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
    /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
    /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
    /// </ul>
    pub fn namespace(&self) -> std::option::Option<&str> {
        self.namespace.as_deref()
    }
    /// <p> The name of the package that contains the requested asset. </p>
    pub fn package(&self) -> std::option::Option<&str> {
        self.package.as_deref()
    }
    /// <p> A string that contains the package version (for example, <code>3.5.2</code>). </p>
    pub fn package_version(&self) -> std::option::Option<&str> {
        self.package_version.as_deref()
    }
    /// <p> The name of the requested asset. </p>
    pub fn asset(&self) -> std::option::Option<&str> {
        self.asset.as_deref()
    }
    /// <p> The name of the package version revision that contains the requested asset. </p>
    pub fn package_version_revision(&self) -> std::option::Option<&str> {
        self.package_version_revision.as_deref()
    }
}
impl GetPackageVersionAssetInput {
    /// Creates a new builder-style object to manufacture [`GetPackageVersionAssetInput`](crate::input::GetPackageVersionAssetInput).
    pub fn builder() -> crate::input::get_package_version_asset_input::Builder {
        crate::input::get_package_version_asset_input::Builder::default()
    }
}

/// See [`GetPackageVersionAssetInput`](crate::input::GetPackageVersionAssetInput).
pub mod get_package_version_asset_input {

    /// A builder for [`GetPackageVersionAssetInput`](crate::input::GetPackageVersionAssetInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) repository: std::option::Option<std::string::String>,
        pub(crate) format: std::option::Option<crate::model::PackageFormat>,
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) package: std::option::Option<std::string::String>,
        pub(crate) package_version: std::option::Option<std::string::String>,
        pub(crate) asset: std::option::Option<std::string::String>,
        pub(crate) package_version_revision: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the domain that contains the repository that contains the package version with the requested asset. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> The name of the domain that contains the repository that contains the package version with the requested asset. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p> The repository that contains the package version with the requested asset. </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        /// <p> The repository that contains the package version with the requested asset. </p>
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// <p> A format that specifies the type of the package version with the requested asset file. </p>
        pub fn format(mut self, input: crate::model::PackageFormat) -> Self {
            self.format = Some(input);
            self
        }
        /// <p> A format that specifies the type of the package version with the requested asset file. </p>
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::PackageFormat>,
        ) -> Self {
            self.format = input;
            self
        }
        /// <p>The namespace of the package version with the requested asset file. The package version component that specifies its namespace depends on its type. For example:</p>
        /// <ul>
        /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
        /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
        /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
        /// </ul>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>The namespace of the package version with the requested asset file. The package version component that specifies its namespace depends on its type. For example:</p>
        /// <ul>
        /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
        /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
        /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
        /// </ul>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// <p> The name of the package that contains the requested asset. </p>
        pub fn package(mut self, input: impl Into<std::string::String>) -> Self {
            self.package = Some(input.into());
            self
        }
        /// <p> The name of the package that contains the requested asset. </p>
        pub fn set_package(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.package = input;
            self
        }
        /// <p> A string that contains the package version (for example, <code>3.5.2</code>). </p>
        pub fn package_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.package_version = Some(input.into());
            self
        }
        /// <p> A string that contains the package version (for example, <code>3.5.2</code>). </p>
        pub fn set_package_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.package_version = input;
            self
        }
        /// <p> The name of the requested asset. </p>
        pub fn asset(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset = Some(input.into());
            self
        }
        /// <p> The name of the requested asset. </p>
        pub fn set_asset(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset = input;
            self
        }
        /// <p> The name of the package version revision that contains the requested asset. </p>
        pub fn package_version_revision(mut self, input: impl Into<std::string::String>) -> Self {
            self.package_version_revision = Some(input.into());
            self
        }
        /// <p> The name of the package version revision that contains the requested asset. </p>
        pub fn set_package_version_revision(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.package_version_revision = input;
            self
        }
        /// Consumes the builder and constructs a [`GetPackageVersionAssetInput`](crate::input::GetPackageVersionAssetInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetPackageVersionAssetInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetPackageVersionAssetInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                repository: self.repository,
                format: self.format,
                namespace: self.namespace,
                package: self.package,
                package_version: self.package_version,
                asset: self.asset,
                package_version_revision: self.package_version_revision,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetDomainPermissionsPolicyInput {
    /// <p> The name of the domain to which the resource policy is attached. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
}
impl GetDomainPermissionsPolicyInput {
    /// <p> The name of the domain to which the resource policy is attached. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
}
impl GetDomainPermissionsPolicyInput {
    /// Creates a new builder-style object to manufacture [`GetDomainPermissionsPolicyInput`](crate::input::GetDomainPermissionsPolicyInput).
    pub fn builder() -> crate::input::get_domain_permissions_policy_input::Builder {
        crate::input::get_domain_permissions_policy_input::Builder::default()
    }
}

/// See [`GetDomainPermissionsPolicyInput`](crate::input::GetDomainPermissionsPolicyInput).
pub mod get_domain_permissions_policy_input {

    /// A builder for [`GetDomainPermissionsPolicyInput`](crate::input::GetDomainPermissionsPolicyInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the domain to which the resource policy is attached. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> The name of the domain to which the resource policy is attached. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetDomainPermissionsPolicyInput`](crate::input::GetDomainPermissionsPolicyInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetDomainPermissionsPolicyInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetDomainPermissionsPolicyInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetAuthorizationTokenInput {
    /// <p> The name of the domain that is in scope for the generated authorization token. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p>The time, in seconds, that the generated authorization token is valid. Valid values are <code>0</code> and any number between <code>900</code> (15 minutes) and <code>43200</code> (12 hours). A value of <code>0</code> will set the expiration of the authorization token to the same expiration of the user's role's temporary credentials.</p>
    #[doc(hidden)]
    pub duration_seconds: std::option::Option<i64>,
}
impl GetAuthorizationTokenInput {
    /// <p> The name of the domain that is in scope for the generated authorization token. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p>The time, in seconds, that the generated authorization token is valid. Valid values are <code>0</code> and any number between <code>900</code> (15 minutes) and <code>43200</code> (12 hours). A value of <code>0</code> will set the expiration of the authorization token to the same expiration of the user's role's temporary credentials.</p>
    pub fn duration_seconds(&self) -> std::option::Option<i64> {
        self.duration_seconds
    }
}
impl GetAuthorizationTokenInput {
    /// Creates a new builder-style object to manufacture [`GetAuthorizationTokenInput`](crate::input::GetAuthorizationTokenInput).
    pub fn builder() -> crate::input::get_authorization_token_input::Builder {
        crate::input::get_authorization_token_input::Builder::default()
    }
}

/// See [`GetAuthorizationTokenInput`](crate::input::GetAuthorizationTokenInput).
pub mod get_authorization_token_input {

    /// A builder for [`GetAuthorizationTokenInput`](crate::input::GetAuthorizationTokenInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) duration_seconds: std::option::Option<i64>,
    }
    impl Builder {
        /// <p> The name of the domain that is in scope for the generated authorization token. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> The name of the domain that is in scope for the generated authorization token. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p>The time, in seconds, that the generated authorization token is valid. Valid values are <code>0</code> and any number between <code>900</code> (15 minutes) and <code>43200</code> (12 hours). A value of <code>0</code> will set the expiration of the authorization token to the same expiration of the user's role's temporary credentials.</p>
        pub fn duration_seconds(mut self, input: i64) -> Self {
            self.duration_seconds = Some(input);
            self
        }
        /// <p>The time, in seconds, that the generated authorization token is valid. Valid values are <code>0</code> and any number between <code>900</code> (15 minutes) and <code>43200</code> (12 hours). A value of <code>0</code> will set the expiration of the authorization token to the same expiration of the user's role's temporary credentials.</p>
        pub fn set_duration_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.duration_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`GetAuthorizationTokenInput`](crate::input::GetAuthorizationTokenInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetAuthorizationTokenInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetAuthorizationTokenInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                duration_seconds: self.duration_seconds,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisposePackageVersionsInput {
    /// <p> The name of the domain that contains the repository you want to dispose. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p> The name of the repository that contains the package versions you want to dispose. </p>
    #[doc(hidden)]
    pub repository: std::option::Option<std::string::String>,
    /// <p> A format that specifies the type of package versions you want to dispose. </p>
    #[doc(hidden)]
    pub format: std::option::Option<crate::model::PackageFormat>,
    /// <p>The namespace of the package versions to be disposed. The package version component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
    /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
    /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub namespace: std::option::Option<std::string::String>,
    /// <p> The name of the package with the versions you want to dispose. </p>
    #[doc(hidden)]
    pub package: std::option::Option<std::string::String>,
    /// <p> The versions of the package you want to dispose. </p>
    #[doc(hidden)]
    pub versions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> The revisions of the package versions you want to dispose. </p>
    #[doc(hidden)]
    pub version_revisions:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p> The expected status of the package version to dispose. </p>
    #[doc(hidden)]
    pub expected_status: std::option::Option<crate::model::PackageVersionStatus>,
}
impl DisposePackageVersionsInput {
    /// <p> The name of the domain that contains the repository you want to dispose. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p> The name of the repository that contains the package versions you want to dispose. </p>
    pub fn repository(&self) -> std::option::Option<&str> {
        self.repository.as_deref()
    }
    /// <p> A format that specifies the type of package versions you want to dispose. </p>
    pub fn format(&self) -> std::option::Option<&crate::model::PackageFormat> {
        self.format.as_ref()
    }
    /// <p>The namespace of the package versions to be disposed. The package version component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
    /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
    /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
    /// </ul>
    pub fn namespace(&self) -> std::option::Option<&str> {
        self.namespace.as_deref()
    }
    /// <p> The name of the package with the versions you want to dispose. </p>
    pub fn package(&self) -> std::option::Option<&str> {
        self.package.as_deref()
    }
    /// <p> The versions of the package you want to dispose. </p>
    pub fn versions(&self) -> std::option::Option<&[std::string::String]> {
        self.versions.as_deref()
    }
    /// <p> The revisions of the package versions you want to dispose. </p>
    pub fn version_revisions(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.version_revisions.as_ref()
    }
    /// <p> The expected status of the package version to dispose. </p>
    pub fn expected_status(&self) -> std::option::Option<&crate::model::PackageVersionStatus> {
        self.expected_status.as_ref()
    }
}
impl DisposePackageVersionsInput {
    /// Creates a new builder-style object to manufacture [`DisposePackageVersionsInput`](crate::input::DisposePackageVersionsInput).
    pub fn builder() -> crate::input::dispose_package_versions_input::Builder {
        crate::input::dispose_package_versions_input::Builder::default()
    }
}

/// See [`DisposePackageVersionsInput`](crate::input::DisposePackageVersionsInput).
pub mod dispose_package_versions_input {

    /// A builder for [`DisposePackageVersionsInput`](crate::input::DisposePackageVersionsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) repository: std::option::Option<std::string::String>,
        pub(crate) format: std::option::Option<crate::model::PackageFormat>,
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) package: std::option::Option<std::string::String>,
        pub(crate) versions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) version_revisions: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) expected_status: std::option::Option<crate::model::PackageVersionStatus>,
    }
    impl Builder {
        /// <p> The name of the domain that contains the repository you want to dispose. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> The name of the domain that contains the repository you want to dispose. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p> The name of the repository that contains the package versions you want to dispose. </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        /// <p> The name of the repository that contains the package versions you want to dispose. </p>
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// <p> A format that specifies the type of package versions you want to dispose. </p>
        pub fn format(mut self, input: crate::model::PackageFormat) -> Self {
            self.format = Some(input);
            self
        }
        /// <p> A format that specifies the type of package versions you want to dispose. </p>
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::PackageFormat>,
        ) -> Self {
            self.format = input;
            self
        }
        /// <p>The namespace of the package versions to be disposed. The package version component that specifies its namespace depends on its type. For example:</p>
        /// <ul>
        /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
        /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
        /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
        /// </ul>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>The namespace of the package versions to be disposed. The package version component that specifies its namespace depends on its type. For example:</p>
        /// <ul>
        /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
        /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
        /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
        /// </ul>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// <p> The name of the package with the versions you want to dispose. </p>
        pub fn package(mut self, input: impl Into<std::string::String>) -> Self {
            self.package = Some(input.into());
            self
        }
        /// <p> The name of the package with the versions you want to dispose. </p>
        pub fn set_package(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.package = input;
            self
        }
        /// Appends an item to `versions`.
        ///
        /// To override the contents of this collection use [`set_versions`](Self::set_versions).
        ///
        /// <p> The versions of the package you want to dispose. </p>
        pub fn versions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.versions.unwrap_or_default();
            v.push(input.into());
            self.versions = Some(v);
            self
        }
        /// <p> The versions of the package you want to dispose. </p>
        pub fn set_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.versions = input;
            self
        }
        /// Adds a key-value pair to `version_revisions`.
        ///
        /// To override the contents of this collection use [`set_version_revisions`](Self::set_version_revisions).
        ///
        /// <p> The revisions of the package versions you want to dispose. </p>
        pub fn version_revisions(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.version_revisions.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.version_revisions = Some(hash_map);
            self
        }
        /// <p> The revisions of the package versions you want to dispose. </p>
        pub fn set_version_revisions(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.version_revisions = input;
            self
        }
        /// <p> The expected status of the package version to dispose. </p>
        pub fn expected_status(mut self, input: crate::model::PackageVersionStatus) -> Self {
            self.expected_status = Some(input);
            self
        }
        /// <p> The expected status of the package version to dispose. </p>
        pub fn set_expected_status(
            mut self,
            input: std::option::Option<crate::model::PackageVersionStatus>,
        ) -> Self {
            self.expected_status = input;
            self
        }
        /// Consumes the builder and constructs a [`DisposePackageVersionsInput`](crate::input::DisposePackageVersionsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DisposePackageVersionsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DisposePackageVersionsInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                repository: self.repository,
                format: self.format,
                namespace: self.namespace,
                package: self.package,
                versions: self.versions,
                version_revisions: self.version_revisions,
                expected_status: self.expected_status,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisassociateExternalConnectionInput {
    /// <p>The name of the domain that contains the repository from which to remove the external repository. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p>The name of the repository from which the external connection will be removed. </p>
    #[doc(hidden)]
    pub repository: std::option::Option<std::string::String>,
    /// <p>The name of the external connection to be removed from the repository. </p>
    #[doc(hidden)]
    pub external_connection: std::option::Option<std::string::String>,
}
impl DisassociateExternalConnectionInput {
    /// <p>The name of the domain that contains the repository from which to remove the external repository. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p>The name of the repository from which the external connection will be removed. </p>
    pub fn repository(&self) -> std::option::Option<&str> {
        self.repository.as_deref()
    }
    /// <p>The name of the external connection to be removed from the repository. </p>
    pub fn external_connection(&self) -> std::option::Option<&str> {
        self.external_connection.as_deref()
    }
}
impl DisassociateExternalConnectionInput {
    /// Creates a new builder-style object to manufacture [`DisassociateExternalConnectionInput`](crate::input::DisassociateExternalConnectionInput).
    pub fn builder() -> crate::input::disassociate_external_connection_input::Builder {
        crate::input::disassociate_external_connection_input::Builder::default()
    }
}

/// See [`DisassociateExternalConnectionInput`](crate::input::DisassociateExternalConnectionInput).
pub mod disassociate_external_connection_input {

    /// A builder for [`DisassociateExternalConnectionInput`](crate::input::DisassociateExternalConnectionInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) repository: std::option::Option<std::string::String>,
        pub(crate) external_connection: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the domain that contains the repository from which to remove the external repository. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p>The name of the domain that contains the repository from which to remove the external repository. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p>The name of the repository from which the external connection will be removed. </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        /// <p>The name of the repository from which the external connection will be removed. </p>
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// <p>The name of the external connection to be removed from the repository. </p>
        pub fn external_connection(mut self, input: impl Into<std::string::String>) -> Self {
            self.external_connection = Some(input.into());
            self
        }
        /// <p>The name of the external connection to be removed from the repository. </p>
        pub fn set_external_connection(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.external_connection = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateExternalConnectionInput`](crate::input::DisassociateExternalConnectionInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DisassociateExternalConnectionInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DisassociateExternalConnectionInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                repository: self.repository,
                external_connection: self.external_connection,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeRepositoryInput {
    /// <p> The name of the domain that contains the repository to describe. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p> A string that specifies the name of the requested repository. </p>
    #[doc(hidden)]
    pub repository: std::option::Option<std::string::String>,
}
impl DescribeRepositoryInput {
    /// <p> The name of the domain that contains the repository to describe. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p> A string that specifies the name of the requested repository. </p>
    pub fn repository(&self) -> std::option::Option<&str> {
        self.repository.as_deref()
    }
}
impl DescribeRepositoryInput {
    /// Creates a new builder-style object to manufacture [`DescribeRepositoryInput`](crate::input::DescribeRepositoryInput).
    pub fn builder() -> crate::input::describe_repository_input::Builder {
        crate::input::describe_repository_input::Builder::default()
    }
}

/// See [`DescribeRepositoryInput`](crate::input::DescribeRepositoryInput).
pub mod describe_repository_input {

    /// A builder for [`DescribeRepositoryInput`](crate::input::DescribeRepositoryInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) repository: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the domain that contains the repository to describe. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> The name of the domain that contains the repository to describe. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p> A string that specifies the name of the requested repository. </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        /// <p> A string that specifies the name of the requested repository. </p>
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeRepositoryInput`](crate::input::DescribeRepositoryInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DescribeRepositoryInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DescribeRepositoryInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                repository: self.repository,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribePackageVersionInput {
    /// <p> The name of the domain that contains the repository that contains the package version. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p> The name of the repository that contains the package version. </p>
    #[doc(hidden)]
    pub repository: std::option::Option<std::string::String>,
    /// <p> A format that specifies the type of the requested package version. </p>
    #[doc(hidden)]
    pub format: std::option::Option<crate::model::PackageFormat>,
    /// <p>The namespace of the requested package version. The package version component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
    /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
    /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub namespace: std::option::Option<std::string::String>,
    /// <p> The name of the requested package version. </p>
    #[doc(hidden)]
    pub package: std::option::Option<std::string::String>,
    /// <p> A string that contains the package version (for example, <code>3.5.2</code>). </p>
    #[doc(hidden)]
    pub package_version: std::option::Option<std::string::String>,
}
impl DescribePackageVersionInput {
    /// <p> The name of the domain that contains the repository that contains the package version. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p> The name of the repository that contains the package version. </p>
    pub fn repository(&self) -> std::option::Option<&str> {
        self.repository.as_deref()
    }
    /// <p> A format that specifies the type of the requested package version. </p>
    pub fn format(&self) -> std::option::Option<&crate::model::PackageFormat> {
        self.format.as_ref()
    }
    /// <p>The namespace of the requested package version. The package version component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
    /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
    /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
    /// </ul>
    pub fn namespace(&self) -> std::option::Option<&str> {
        self.namespace.as_deref()
    }
    /// <p> The name of the requested package version. </p>
    pub fn package(&self) -> std::option::Option<&str> {
        self.package.as_deref()
    }
    /// <p> A string that contains the package version (for example, <code>3.5.2</code>). </p>
    pub fn package_version(&self) -> std::option::Option<&str> {
        self.package_version.as_deref()
    }
}
impl DescribePackageVersionInput {
    /// Creates a new builder-style object to manufacture [`DescribePackageVersionInput`](crate::input::DescribePackageVersionInput).
    pub fn builder() -> crate::input::describe_package_version_input::Builder {
        crate::input::describe_package_version_input::Builder::default()
    }
}

/// See [`DescribePackageVersionInput`](crate::input::DescribePackageVersionInput).
pub mod describe_package_version_input {

    /// A builder for [`DescribePackageVersionInput`](crate::input::DescribePackageVersionInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) repository: std::option::Option<std::string::String>,
        pub(crate) format: std::option::Option<crate::model::PackageFormat>,
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) package: std::option::Option<std::string::String>,
        pub(crate) package_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the domain that contains the repository that contains the package version. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> The name of the domain that contains the repository that contains the package version. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p> The name of the repository that contains the package version. </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        /// <p> The name of the repository that contains the package version. </p>
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// <p> A format that specifies the type of the requested package version. </p>
        pub fn format(mut self, input: crate::model::PackageFormat) -> Self {
            self.format = Some(input);
            self
        }
        /// <p> A format that specifies the type of the requested package version. </p>
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::PackageFormat>,
        ) -> Self {
            self.format = input;
            self
        }
        /// <p>The namespace of the requested package version. The package version component that specifies its namespace depends on its type. For example:</p>
        /// <ul>
        /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
        /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
        /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
        /// </ul>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>The namespace of the requested package version. The package version component that specifies its namespace depends on its type. For example:</p>
        /// <ul>
        /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. </p> </li>
        /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
        /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
        /// </ul>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// <p> The name of the requested package version. </p>
        pub fn package(mut self, input: impl Into<std::string::String>) -> Self {
            self.package = Some(input.into());
            self
        }
        /// <p> The name of the requested package version. </p>
        pub fn set_package(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.package = input;
            self
        }
        /// <p> A string that contains the package version (for example, <code>3.5.2</code>). </p>
        pub fn package_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.package_version = Some(input.into());
            self
        }
        /// <p> A string that contains the package version (for example, <code>3.5.2</code>). </p>
        pub fn set_package_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.package_version = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribePackageVersionInput`](crate::input::DescribePackageVersionInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DescribePackageVersionInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DescribePackageVersionInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                repository: self.repository,
                format: self.format,
                namespace: self.namespace,
                package: self.package,
                package_version: self.package_version,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribePackageInput {
    /// <p>The name of the domain that contains the repository that contains the package.</p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p>The name of the repository that contains the requested package. </p>
    #[doc(hidden)]
    pub repository: std::option::Option<std::string::String>,
    /// <p>A format that specifies the type of the requested package.</p>
    #[doc(hidden)]
    pub format: std::option::Option<crate::model::PackageFormat>,
    /// <p>The namespace of the requested package. The package component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li> <p> The namespace of a Maven package is its <code>groupId</code>. The namespace is required when requesting Maven packages. </p> </li>
    /// <li> <p> The namespace of an npm package is its <code>scope</code>. </p> </li>
    /// <li> <p> Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace. </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub namespace: std::option::Option<std::string::String>,
    /// <p>The name of the requested package.</p>
    #[doc(hidden)]
    pub package: std::option::Option<std::string::String>,
}
impl DescribePackageInput {
    /// <p>The name of the domain that contains the repository that contains the package.</p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p>The name of the repository that contains the requested package. </p>
    pub fn repository(&self) -> std::option::Option<&str> {
        self.repository.as_deref()
    }
    /// <p>A format that specifies the type of the requested package.</p>
    pub fn format(&self) -> std::option::Option<&crate::model::PackageFormat> {
        self.format.as_ref()
    }
    /// <p>The namespace of the requested package. The package component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li> <p> The namespace of a Maven package is its <code>groupId</code>. The namespace is required when requesting Maven packages. </p> </li>
    /// <li> <p> The namespace of an npm package is its <code>scope</code>. </p> </li>
    /// <li> <p> Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace. </p> </li>
    /// </ul>
    pub fn namespace(&self) -> std::option::Option<&str> {
        self.namespace.as_deref()
    }
    /// <p>The name of the requested package.</p>
    pub fn package(&self) -> std::option::Option<&str> {
        self.package.as_deref()
    }
}
impl DescribePackageInput {
    /// Creates a new builder-style object to manufacture [`DescribePackageInput`](crate::input::DescribePackageInput).
    pub fn builder() -> crate::input::describe_package_input::Builder {
        crate::input::describe_package_input::Builder::default()
    }
}

/// See [`DescribePackageInput`](crate::input::DescribePackageInput).
pub mod describe_package_input {

    /// A builder for [`DescribePackageInput`](crate::input::DescribePackageInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) repository: std::option::Option<std::string::String>,
        pub(crate) format: std::option::Option<crate::model::PackageFormat>,
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) package: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the domain that contains the repository that contains the package.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p>The name of the domain that contains the repository that contains the package.</p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p>The name of the repository that contains the requested package. </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        /// <p>The name of the repository that contains the requested package. </p>
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// <p>A format that specifies the type of the requested package.</p>
        pub fn format(mut self, input: crate::model::PackageFormat) -> Self {
            self.format = Some(input);
            self
        }
        /// <p>A format that specifies the type of the requested package.</p>
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::PackageFormat>,
        ) -> Self {
            self.format = input;
            self
        }
        /// <p>The namespace of the requested package. The package component that specifies its namespace depends on its type. For example:</p>
        /// <ul>
        /// <li> <p> The namespace of a Maven package is its <code>groupId</code>. The namespace is required when requesting Maven packages. </p> </li>
        /// <li> <p> The namespace of an npm package is its <code>scope</code>. </p> </li>
        /// <li> <p> Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace. </p> </li>
        /// </ul>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>The namespace of the requested package. The package component that specifies its namespace depends on its type. For example:</p>
        /// <ul>
        /// <li> <p> The namespace of a Maven package is its <code>groupId</code>. The namespace is required when requesting Maven packages. </p> </li>
        /// <li> <p> The namespace of an npm package is its <code>scope</code>. </p> </li>
        /// <li> <p> Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace. </p> </li>
        /// </ul>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// <p>The name of the requested package.</p>
        pub fn package(mut self, input: impl Into<std::string::String>) -> Self {
            self.package = Some(input.into());
            self
        }
        /// <p>The name of the requested package.</p>
        pub fn set_package(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.package = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribePackageInput`](crate::input::DescribePackageInput).
        pub fn build(
            self,
        ) -> Result<crate::input::DescribePackageInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::DescribePackageInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                repository: self.repository,
                format: self.format,
                namespace: self.namespace,
                package: self.package,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeDomainInput {
    /// <p> A string that specifies the name of the requested domain. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
}
impl DescribeDomainInput {
    /// <p> A string that specifies the name of the requested domain. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
}
impl DescribeDomainInput {
    /// Creates a new builder-style object to manufacture [`DescribeDomainInput`](crate::input::DescribeDomainInput).
    pub fn builder() -> crate::input::describe_domain_input::Builder {
        crate::input::describe_domain_input::Builder::default()
    }
}

/// See [`DescribeDomainInput`](crate::input::DescribeDomainInput).
pub mod describe_domain_input {

    /// A builder for [`DescribeDomainInput`](crate::input::DescribeDomainInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> A string that specifies the name of the requested domain. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> A string that specifies the name of the requested domain. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeDomainInput`](crate::input::DescribeDomainInput).
        pub fn build(
            self,
        ) -> Result<crate::input::DescribeDomainInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::DescribeDomainInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteRepositoryPermissionsPolicyInput {
    /// <p> The name of the domain that contains the repository associated with the resource policy to be deleted. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p> The name of the repository that is associated with the resource policy to be deleted </p>
    #[doc(hidden)]
    pub repository: std::option::Option<std::string::String>,
    /// <p> The revision of the repository's resource policy to be deleted. This revision is used for optimistic locking, which prevents others from accidentally overwriting your changes to the repository's resource policy. </p>
    #[doc(hidden)]
    pub policy_revision: std::option::Option<std::string::String>,
}
impl DeleteRepositoryPermissionsPolicyInput {
    /// <p> The name of the domain that contains the repository associated with the resource policy to be deleted. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p> The name of the repository that is associated with the resource policy to be deleted </p>
    pub fn repository(&self) -> std::option::Option<&str> {
        self.repository.as_deref()
    }
    /// <p> The revision of the repository's resource policy to be deleted. This revision is used for optimistic locking, which prevents others from accidentally overwriting your changes to the repository's resource policy. </p>
    pub fn policy_revision(&self) -> std::option::Option<&str> {
        self.policy_revision.as_deref()
    }
}
impl DeleteRepositoryPermissionsPolicyInput {
    /// Creates a new builder-style object to manufacture [`DeleteRepositoryPermissionsPolicyInput`](crate::input::DeleteRepositoryPermissionsPolicyInput).
    pub fn builder() -> crate::input::delete_repository_permissions_policy_input::Builder {
        crate::input::delete_repository_permissions_policy_input::Builder::default()
    }
}

/// See [`DeleteRepositoryPermissionsPolicyInput`](crate::input::DeleteRepositoryPermissionsPolicyInput).
pub mod delete_repository_permissions_policy_input {

    /// A builder for [`DeleteRepositoryPermissionsPolicyInput`](crate::input::DeleteRepositoryPermissionsPolicyInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) repository: std::option::Option<std::string::String>,
        pub(crate) policy_revision: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the domain that contains the repository associated with the resource policy to be deleted. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> The name of the domain that contains the repository associated with the resource policy to be deleted. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p> The name of the repository that is associated with the resource policy to be deleted </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        /// <p> The name of the repository that is associated with the resource policy to be deleted </p>
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// <p> The revision of the repository's resource policy to be deleted. This revision is used for optimistic locking, which prevents others from accidentally overwriting your changes to the repository's resource policy. </p>
        pub fn policy_revision(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_revision = Some(input.into());
            self
        }
        /// <p> The revision of the repository's resource policy to be deleted. This revision is used for optimistic locking, which prevents others from accidentally overwriting your changes to the repository's resource policy. </p>
        pub fn set_policy_revision(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_revision = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteRepositoryPermissionsPolicyInput`](crate::input::DeleteRepositoryPermissionsPolicyInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteRepositoryPermissionsPolicyInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteRepositoryPermissionsPolicyInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                repository: self.repository,
                policy_revision: self.policy_revision,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteRepositoryInput {
    /// <p> The name of the domain that contains the repository to delete. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p> The name of the repository to delete. </p>
    #[doc(hidden)]
    pub repository: std::option::Option<std::string::String>,
}
impl DeleteRepositoryInput {
    /// <p> The name of the domain that contains the repository to delete. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p> The name of the repository to delete. </p>
    pub fn repository(&self) -> std::option::Option<&str> {
        self.repository.as_deref()
    }
}
impl DeleteRepositoryInput {
    /// Creates a new builder-style object to manufacture [`DeleteRepositoryInput`](crate::input::DeleteRepositoryInput).
    pub fn builder() -> crate::input::delete_repository_input::Builder {
        crate::input::delete_repository_input::Builder::default()
    }
}

/// See [`DeleteRepositoryInput`](crate::input::DeleteRepositoryInput).
pub mod delete_repository_input {

    /// A builder for [`DeleteRepositoryInput`](crate::input::DeleteRepositoryInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) repository: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the domain that contains the repository to delete. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> The name of the domain that contains the repository to delete. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p> The name of the repository to delete. </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        /// <p> The name of the repository to delete. </p>
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteRepositoryInput`](crate::input::DeleteRepositoryInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteRepositoryInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteRepositoryInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                repository: self.repository,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeletePackageVersionsInput {
    /// <p> The name of the domain that contains the package to delete. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p> The name of the repository that contains the package versions to delete. </p>
    #[doc(hidden)]
    pub repository: std::option::Option<std::string::String>,
    /// <p> The format of the package versions to delete. </p>
    #[doc(hidden)]
    pub format: std::option::Option<crate::model::PackageFormat>,
    /// <p>The namespace of the package versions to be deleted. The package version component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. The namespace is required when deleting Maven package versions. </p> </li>
    /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
    /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub namespace: std::option::Option<std::string::String>,
    /// <p> The name of the package with the versions to delete. </p>
    #[doc(hidden)]
    pub package: std::option::Option<std::string::String>,
    /// <p> An array of strings that specify the versions of the package to delete. </p>
    #[doc(hidden)]
    pub versions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> The expected status of the package version to delete. </p>
    #[doc(hidden)]
    pub expected_status: std::option::Option<crate::model::PackageVersionStatus>,
}
impl DeletePackageVersionsInput {
    /// <p> The name of the domain that contains the package to delete. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p> The name of the repository that contains the package versions to delete. </p>
    pub fn repository(&self) -> std::option::Option<&str> {
        self.repository.as_deref()
    }
    /// <p> The format of the package versions to delete. </p>
    pub fn format(&self) -> std::option::Option<&crate::model::PackageFormat> {
        self.format.as_ref()
    }
    /// <p>The namespace of the package versions to be deleted. The package version component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. The namespace is required when deleting Maven package versions. </p> </li>
    /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
    /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
    /// </ul>
    pub fn namespace(&self) -> std::option::Option<&str> {
        self.namespace.as_deref()
    }
    /// <p> The name of the package with the versions to delete. </p>
    pub fn package(&self) -> std::option::Option<&str> {
        self.package.as_deref()
    }
    /// <p> An array of strings that specify the versions of the package to delete. </p>
    pub fn versions(&self) -> std::option::Option<&[std::string::String]> {
        self.versions.as_deref()
    }
    /// <p> The expected status of the package version to delete. </p>
    pub fn expected_status(&self) -> std::option::Option<&crate::model::PackageVersionStatus> {
        self.expected_status.as_ref()
    }
}
impl DeletePackageVersionsInput {
    /// Creates a new builder-style object to manufacture [`DeletePackageVersionsInput`](crate::input::DeletePackageVersionsInput).
    pub fn builder() -> crate::input::delete_package_versions_input::Builder {
        crate::input::delete_package_versions_input::Builder::default()
    }
}

/// See [`DeletePackageVersionsInput`](crate::input::DeletePackageVersionsInput).
pub mod delete_package_versions_input {

    /// A builder for [`DeletePackageVersionsInput`](crate::input::DeletePackageVersionsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) repository: std::option::Option<std::string::String>,
        pub(crate) format: std::option::Option<crate::model::PackageFormat>,
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) package: std::option::Option<std::string::String>,
        pub(crate) versions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) expected_status: std::option::Option<crate::model::PackageVersionStatus>,
    }
    impl Builder {
        /// <p> The name of the domain that contains the package to delete. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> The name of the domain that contains the package to delete. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p> The name of the repository that contains the package versions to delete. </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        /// <p> The name of the repository that contains the package versions to delete. </p>
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// <p> The format of the package versions to delete. </p>
        pub fn format(mut self, input: crate::model::PackageFormat) -> Self {
            self.format = Some(input);
            self
        }
        /// <p> The format of the package versions to delete. </p>
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::PackageFormat>,
        ) -> Self {
            self.format = input;
            self
        }
        /// <p>The namespace of the package versions to be deleted. The package version component that specifies its namespace depends on its type. For example:</p>
        /// <ul>
        /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. The namespace is required when deleting Maven package versions. </p> </li>
        /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
        /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
        /// </ul>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>The namespace of the package versions to be deleted. The package version component that specifies its namespace depends on its type. For example:</p>
        /// <ul>
        /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. The namespace is required when deleting Maven package versions. </p> </li>
        /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
        /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
        /// </ul>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// <p> The name of the package with the versions to delete. </p>
        pub fn package(mut self, input: impl Into<std::string::String>) -> Self {
            self.package = Some(input.into());
            self
        }
        /// <p> The name of the package with the versions to delete. </p>
        pub fn set_package(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.package = input;
            self
        }
        /// Appends an item to `versions`.
        ///
        /// To override the contents of this collection use [`set_versions`](Self::set_versions).
        ///
        /// <p> An array of strings that specify the versions of the package to delete. </p>
        pub fn versions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.versions.unwrap_or_default();
            v.push(input.into());
            self.versions = Some(v);
            self
        }
        /// <p> An array of strings that specify the versions of the package to delete. </p>
        pub fn set_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.versions = input;
            self
        }
        /// <p> The expected status of the package version to delete. </p>
        pub fn expected_status(mut self, input: crate::model::PackageVersionStatus) -> Self {
            self.expected_status = Some(input);
            self
        }
        /// <p> The expected status of the package version to delete. </p>
        pub fn set_expected_status(
            mut self,
            input: std::option::Option<crate::model::PackageVersionStatus>,
        ) -> Self {
            self.expected_status = input;
            self
        }
        /// Consumes the builder and constructs a [`DeletePackageVersionsInput`](crate::input::DeletePackageVersionsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeletePackageVersionsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeletePackageVersionsInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                repository: self.repository,
                format: self.format,
                namespace: self.namespace,
                package: self.package,
                versions: self.versions,
                expected_status: self.expected_status,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteDomainPermissionsPolicyInput {
    /// <p> The name of the domain associated with the resource policy to be deleted. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p> The current revision of the resource policy to be deleted. This revision is used for optimistic locking, which prevents others from overwriting your changes to the domain's resource policy. </p>
    #[doc(hidden)]
    pub policy_revision: std::option::Option<std::string::String>,
}
impl DeleteDomainPermissionsPolicyInput {
    /// <p> The name of the domain associated with the resource policy to be deleted. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p> The current revision of the resource policy to be deleted. This revision is used for optimistic locking, which prevents others from overwriting your changes to the domain's resource policy. </p>
    pub fn policy_revision(&self) -> std::option::Option<&str> {
        self.policy_revision.as_deref()
    }
}
impl DeleteDomainPermissionsPolicyInput {
    /// Creates a new builder-style object to manufacture [`DeleteDomainPermissionsPolicyInput`](crate::input::DeleteDomainPermissionsPolicyInput).
    pub fn builder() -> crate::input::delete_domain_permissions_policy_input::Builder {
        crate::input::delete_domain_permissions_policy_input::Builder::default()
    }
}

/// See [`DeleteDomainPermissionsPolicyInput`](crate::input::DeleteDomainPermissionsPolicyInput).
pub mod delete_domain_permissions_policy_input {

    /// A builder for [`DeleteDomainPermissionsPolicyInput`](crate::input::DeleteDomainPermissionsPolicyInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) policy_revision: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the domain associated with the resource policy to be deleted. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> The name of the domain associated with the resource policy to be deleted. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p> The current revision of the resource policy to be deleted. This revision is used for optimistic locking, which prevents others from overwriting your changes to the domain's resource policy. </p>
        pub fn policy_revision(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_revision = Some(input.into());
            self
        }
        /// <p> The current revision of the resource policy to be deleted. This revision is used for optimistic locking, which prevents others from overwriting your changes to the domain's resource policy. </p>
        pub fn set_policy_revision(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_revision = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteDomainPermissionsPolicyInput`](crate::input::DeleteDomainPermissionsPolicyInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteDomainPermissionsPolicyInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteDomainPermissionsPolicyInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                policy_revision: self.policy_revision,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteDomainInput {
    /// <p> The name of the domain to delete. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
}
impl DeleteDomainInput {
    /// <p> The name of the domain to delete. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
}
impl DeleteDomainInput {
    /// Creates a new builder-style object to manufacture [`DeleteDomainInput`](crate::input::DeleteDomainInput).
    pub fn builder() -> crate::input::delete_domain_input::Builder {
        crate::input::delete_domain_input::Builder::default()
    }
}

/// See [`DeleteDomainInput`](crate::input::DeleteDomainInput).
pub mod delete_domain_input {

    /// A builder for [`DeleteDomainInput`](crate::input::DeleteDomainInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the domain to delete. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> The name of the domain to delete. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteDomainInput`](crate::input::DeleteDomainInput).
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteDomainInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::DeleteDomainInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateRepositoryInput {
    /// <p> The name of the domain that contains the created repository. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p> The name of the repository to create. </p>
    #[doc(hidden)]
    pub repository: std::option::Option<std::string::String>,
    /// <p> A description of the created repository. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p> A list of upstream repositories to associate with the repository. The order of the upstream repositories in the list determines their priority order when CodeArtifact looks for a requested package version. For more information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html">Working with upstream repositories</a>. </p>
    #[doc(hidden)]
    pub upstreams: std::option::Option<std::vec::Vec<crate::model::UpstreamRepository>>,
    /// <p>One or more tag key-value pairs for the repository.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateRepositoryInput {
    /// <p> The name of the domain that contains the created repository. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p> The name of the repository to create. </p>
    pub fn repository(&self) -> std::option::Option<&str> {
        self.repository.as_deref()
    }
    /// <p> A description of the created repository. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p> A list of upstream repositories to associate with the repository. The order of the upstream repositories in the list determines their priority order when CodeArtifact looks for a requested package version. For more information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html">Working with upstream repositories</a>. </p>
    pub fn upstreams(&self) -> std::option::Option<&[crate::model::UpstreamRepository]> {
        self.upstreams.as_deref()
    }
    /// <p>One or more tag key-value pairs for the repository.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl CreateRepositoryInput {
    /// Creates a new builder-style object to manufacture [`CreateRepositoryInput`](crate::input::CreateRepositoryInput).
    pub fn builder() -> crate::input::create_repository_input::Builder {
        crate::input::create_repository_input::Builder::default()
    }
}

/// See [`CreateRepositoryInput`](crate::input::CreateRepositoryInput).
pub mod create_repository_input {

    /// A builder for [`CreateRepositoryInput`](crate::input::CreateRepositoryInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) repository: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) upstreams: std::option::Option<std::vec::Vec<crate::model::UpstreamRepository>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p> The name of the domain that contains the created repository. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> The name of the domain that contains the created repository. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p> The name of the repository to create. </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        /// <p> The name of the repository to create. </p>
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// <p> A description of the created repository. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> A description of the created repository. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `upstreams`.
        ///
        /// To override the contents of this collection use [`set_upstreams`](Self::set_upstreams).
        ///
        /// <p> A list of upstream repositories to associate with the repository. The order of the upstream repositories in the list determines their priority order when CodeArtifact looks for a requested package version. For more information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html">Working with upstream repositories</a>. </p>
        pub fn upstreams(mut self, input: crate::model::UpstreamRepository) -> Self {
            let mut v = self.upstreams.unwrap_or_default();
            v.push(input);
            self.upstreams = Some(v);
            self
        }
        /// <p> A list of upstream repositories to associate with the repository. The order of the upstream repositories in the list determines their priority order when CodeArtifact looks for a requested package version. For more information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html">Working with upstream repositories</a>. </p>
        pub fn set_upstreams(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UpstreamRepository>>,
        ) -> Self {
            self.upstreams = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>One or more tag key-value pairs for the repository.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>One or more tag key-value pairs for the repository.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateRepositoryInput`](crate::input::CreateRepositoryInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateRepositoryInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateRepositoryInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                repository: self.repository,
                description: self.description,
                upstreams: self.upstreams,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateDomainInput {
    /// <p> The name of the domain to create. All domain names in an Amazon Web Services Region that are in the same Amazon Web Services account must be unique. The domain name is used as the prefix in DNS hostnames. Do not use sensitive information in a domain name because it is publicly discoverable. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The encryption key for the domain. This is used to encrypt content stored in a domain. An encryption key can be a key ID, a key Amazon Resource Name (ARN), a key alias, or a key alias ARN. To specify an <code>encryptionKey</code>, your IAM role must have <code>kms:DescribeKey</code> and <code>kms:CreateGrant</code> permissions on the encryption key that is used. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestSyntax">DescribeKey</a> in the <i>Key Management Service API Reference</i> and <a href="https://docs.aws.amazon.com/kms/latest/developerguide/kms-api-permissions-reference.html">Key Management Service API Permissions Reference</a> in the <i>Key Management Service Developer Guide</i>. </p> <important>
    /// <p> CodeArtifact supports only symmetric CMKs. Do not associate an asymmetric CMK with your domain. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using symmetric and asymmetric keys</a> in the <i>Key Management Service Developer Guide</i>. </p>
    /// </important>
    #[doc(hidden)]
    pub encryption_key: std::option::Option<std::string::String>,
    /// <p>One or more tag key-value pairs for the domain.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateDomainInput {
    /// <p> The name of the domain to create. All domain names in an Amazon Web Services Region that are in the same Amazon Web Services account must be unique. The domain name is used as the prefix in DNS hostnames. Do not use sensitive information in a domain name because it is publicly discoverable. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The encryption key for the domain. This is used to encrypt content stored in a domain. An encryption key can be a key ID, a key Amazon Resource Name (ARN), a key alias, or a key alias ARN. To specify an <code>encryptionKey</code>, your IAM role must have <code>kms:DescribeKey</code> and <code>kms:CreateGrant</code> permissions on the encryption key that is used. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestSyntax">DescribeKey</a> in the <i>Key Management Service API Reference</i> and <a href="https://docs.aws.amazon.com/kms/latest/developerguide/kms-api-permissions-reference.html">Key Management Service API Permissions Reference</a> in the <i>Key Management Service Developer Guide</i>. </p> <important>
    /// <p> CodeArtifact supports only symmetric CMKs. Do not associate an asymmetric CMK with your domain. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using symmetric and asymmetric keys</a> in the <i>Key Management Service Developer Guide</i>. </p>
    /// </important>
    pub fn encryption_key(&self) -> std::option::Option<&str> {
        self.encryption_key.as_deref()
    }
    /// <p>One or more tag key-value pairs for the domain.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl CreateDomainInput {
    /// Creates a new builder-style object to manufacture [`CreateDomainInput`](crate::input::CreateDomainInput).
    pub fn builder() -> crate::input::create_domain_input::Builder {
        crate::input::create_domain_input::Builder::default()
    }
}

/// See [`CreateDomainInput`](crate::input::CreateDomainInput).
pub mod create_domain_input {

    /// A builder for [`CreateDomainInput`](crate::input::CreateDomainInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) encryption_key: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p> The name of the domain to create. All domain names in an Amazon Web Services Region that are in the same Amazon Web Services account must be unique. The domain name is used as the prefix in DNS hostnames. Do not use sensitive information in a domain name because it is publicly discoverable. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> The name of the domain to create. All domain names in an Amazon Web Services Region that are in the same Amazon Web Services account must be unique. The domain name is used as the prefix in DNS hostnames. Do not use sensitive information in a domain name because it is publicly discoverable. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The encryption key for the domain. This is used to encrypt content stored in a domain. An encryption key can be a key ID, a key Amazon Resource Name (ARN), a key alias, or a key alias ARN. To specify an <code>encryptionKey</code>, your IAM role must have <code>kms:DescribeKey</code> and <code>kms:CreateGrant</code> permissions on the encryption key that is used. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestSyntax">DescribeKey</a> in the <i>Key Management Service API Reference</i> and <a href="https://docs.aws.amazon.com/kms/latest/developerguide/kms-api-permissions-reference.html">Key Management Service API Permissions Reference</a> in the <i>Key Management Service Developer Guide</i>. </p> <important>
        /// <p> CodeArtifact supports only symmetric CMKs. Do not associate an asymmetric CMK with your domain. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using symmetric and asymmetric keys</a> in the <i>Key Management Service Developer Guide</i>. </p>
        /// </important>
        pub fn encryption_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.encryption_key = Some(input.into());
            self
        }
        /// <p> The encryption key for the domain. This is used to encrypt content stored in a domain. An encryption key can be a key ID, a key Amazon Resource Name (ARN), a key alias, or a key alias ARN. To specify an <code>encryptionKey</code>, your IAM role must have <code>kms:DescribeKey</code> and <code>kms:CreateGrant</code> permissions on the encryption key that is used. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestSyntax">DescribeKey</a> in the <i>Key Management Service API Reference</i> and <a href="https://docs.aws.amazon.com/kms/latest/developerguide/kms-api-permissions-reference.html">Key Management Service API Permissions Reference</a> in the <i>Key Management Service Developer Guide</i>. </p> <important>
        /// <p> CodeArtifact supports only symmetric CMKs. Do not associate an asymmetric CMK with your domain. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using symmetric and asymmetric keys</a> in the <i>Key Management Service Developer Guide</i>. </p>
        /// </important>
        pub fn set_encryption_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.encryption_key = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>One or more tag key-value pairs for the domain.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>One or more tag key-value pairs for the domain.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateDomainInput`](crate::input::CreateDomainInput).
        pub fn build(
            self,
        ) -> Result<crate::input::CreateDomainInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::CreateDomainInput {
                domain: self.domain,
                encryption_key: self.encryption_key,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CopyPackageVersionsInput {
    /// <p> The name of the domain that contains the source and destination repositories. </p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p> The name of the repository that contains the package versions to be copied. </p>
    #[doc(hidden)]
    pub source_repository: std::option::Option<std::string::String>,
    /// <p> The name of the repository into which package versions are copied. </p>
    #[doc(hidden)]
    pub destination_repository: std::option::Option<std::string::String>,
    /// <p> The format of the package versions to be copied. </p>
    #[doc(hidden)]
    pub format: std::option::Option<crate::model::PackageFormat>,
    /// <p>The namespace of the package versions to be copied. The package version component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. The namespace is required when copying Maven package versions. </p> </li>
    /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
    /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub namespace: std::option::Option<std::string::String>,
    /// <p> The name of the package that contains the versions to be copied. </p>
    #[doc(hidden)]
    pub package: std::option::Option<std::string::String>,
    /// <p> The versions of the package to be copied. </p> <note>
    /// <p> You must specify <code>versions</code> or <code>versionRevisions</code>. You cannot specify both. </p>
    /// </note>
    #[doc(hidden)]
    pub versions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> A list of key-value pairs. The keys are package versions and the values are package version revisions. A <code>CopyPackageVersion</code> operation succeeds if the specified versions in the source repository match the specified package version revision. </p> <note>
    /// <p> You must specify <code>versions</code> or <code>versionRevisions</code>. You cannot specify both. </p>
    /// </note>
    #[doc(hidden)]
    pub version_revisions:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p> Set to true to overwrite a package version that already exists in the destination repository. If set to false and the package version already exists in the destination repository, the package version is returned in the <code>failedVersions</code> field of the response with an <code>ALREADY_EXISTS</code> error code. </p>
    #[doc(hidden)]
    pub allow_overwrite: std::option::Option<bool>,
    /// <p> Set to true to copy packages from repositories that are upstream from the source repository to the destination repository. The default setting is false. For more information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html">Working with upstream repositories</a>. </p>
    #[doc(hidden)]
    pub include_from_upstream: std::option::Option<bool>,
}
impl CopyPackageVersionsInput {
    /// <p> The name of the domain that contains the source and destination repositories. </p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p> The name of the repository that contains the package versions to be copied. </p>
    pub fn source_repository(&self) -> std::option::Option<&str> {
        self.source_repository.as_deref()
    }
    /// <p> The name of the repository into which package versions are copied. </p>
    pub fn destination_repository(&self) -> std::option::Option<&str> {
        self.destination_repository.as_deref()
    }
    /// <p> The format of the package versions to be copied. </p>
    pub fn format(&self) -> std::option::Option<&crate::model::PackageFormat> {
        self.format.as_ref()
    }
    /// <p>The namespace of the package versions to be copied. The package version component that specifies its namespace depends on its type. For example:</p>
    /// <ul>
    /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. The namespace is required when copying Maven package versions. </p> </li>
    /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
    /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
    /// </ul>
    pub fn namespace(&self) -> std::option::Option<&str> {
        self.namespace.as_deref()
    }
    /// <p> The name of the package that contains the versions to be copied. </p>
    pub fn package(&self) -> std::option::Option<&str> {
        self.package.as_deref()
    }
    /// <p> The versions of the package to be copied. </p> <note>
    /// <p> You must specify <code>versions</code> or <code>versionRevisions</code>. You cannot specify both. </p>
    /// </note>
    pub fn versions(&self) -> std::option::Option<&[std::string::String]> {
        self.versions.as_deref()
    }
    /// <p> A list of key-value pairs. The keys are package versions and the values are package version revisions. A <code>CopyPackageVersion</code> operation succeeds if the specified versions in the source repository match the specified package version revision. </p> <note>
    /// <p> You must specify <code>versions</code> or <code>versionRevisions</code>. You cannot specify both. </p>
    /// </note>
    pub fn version_revisions(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.version_revisions.as_ref()
    }
    /// <p> Set to true to overwrite a package version that already exists in the destination repository. If set to false and the package version already exists in the destination repository, the package version is returned in the <code>failedVersions</code> field of the response with an <code>ALREADY_EXISTS</code> error code. </p>
    pub fn allow_overwrite(&self) -> std::option::Option<bool> {
        self.allow_overwrite
    }
    /// <p> Set to true to copy packages from repositories that are upstream from the source repository to the destination repository. The default setting is false. For more information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html">Working with upstream repositories</a>. </p>
    pub fn include_from_upstream(&self) -> std::option::Option<bool> {
        self.include_from_upstream
    }
}
impl CopyPackageVersionsInput {
    /// Creates a new builder-style object to manufacture [`CopyPackageVersionsInput`](crate::input::CopyPackageVersionsInput).
    pub fn builder() -> crate::input::copy_package_versions_input::Builder {
        crate::input::copy_package_versions_input::Builder::default()
    }
}

/// See [`CopyPackageVersionsInput`](crate::input::CopyPackageVersionsInput).
pub mod copy_package_versions_input {

    /// A builder for [`CopyPackageVersionsInput`](crate::input::CopyPackageVersionsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) source_repository: std::option::Option<std::string::String>,
        pub(crate) destination_repository: std::option::Option<std::string::String>,
        pub(crate) format: std::option::Option<crate::model::PackageFormat>,
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) package: std::option::Option<std::string::String>,
        pub(crate) versions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) version_revisions: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) allow_overwrite: std::option::Option<bool>,
        pub(crate) include_from_upstream: std::option::Option<bool>,
    }
    impl Builder {
        /// <p> The name of the domain that contains the source and destination repositories. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p> The name of the domain that contains the source and destination repositories. </p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p> The name of the repository that contains the package versions to be copied. </p>
        pub fn source_repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_repository = Some(input.into());
            self
        }
        /// <p> The name of the repository that contains the package versions to be copied. </p>
        pub fn set_source_repository(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_repository = input;
            self
        }
        /// <p> The name of the repository into which package versions are copied. </p>
        pub fn destination_repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_repository = Some(input.into());
            self
        }
        /// <p> The name of the repository into which package versions are copied. </p>
        pub fn set_destination_repository(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_repository = input;
            self
        }
        /// <p> The format of the package versions to be copied. </p>
        pub fn format(mut self, input: crate::model::PackageFormat) -> Self {
            self.format = Some(input);
            self
        }
        /// <p> The format of the package versions to be copied. </p>
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::PackageFormat>,
        ) -> Self {
            self.format = input;
            self
        }
        /// <p>The namespace of the package versions to be copied. The package version component that specifies its namespace depends on its type. For example:</p>
        /// <ul>
        /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. The namespace is required when copying Maven package versions. </p> </li>
        /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
        /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
        /// </ul>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>The namespace of the package versions to be copied. The package version component that specifies its namespace depends on its type. For example:</p>
        /// <ul>
        /// <li> <p> The namespace of a Maven package version is its <code>groupId</code>. The namespace is required when copying Maven package versions. </p> </li>
        /// <li> <p> The namespace of an npm package version is its <code>scope</code>. </p> </li>
        /// <li> <p> Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace. </p> </li>
        /// </ul>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// <p> The name of the package that contains the versions to be copied. </p>
        pub fn package(mut self, input: impl Into<std::string::String>) -> Self {
            self.package = Some(input.into());
            self
        }
        /// <p> The name of the package that contains the versions to be copied. </p>
        pub fn set_package(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.package = input;
            self
        }
        /// Appends an item to `versions`.
        ///
        /// To override the contents of this collection use [`set_versions`](Self::set_versions).
        ///
        /// <p> The versions of the package to be copied. </p> <note>
        /// <p> You must specify <code>versions</code> or <code>versionRevisions</code>. You cannot specify both. </p>
        /// </note>
        pub fn versions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.versions.unwrap_or_default();
            v.push(input.into());
            self.versions = Some(v);
            self
        }
        /// <p> The versions of the package to be copied. </p> <note>
        /// <p> You must specify <code>versions</code> or <code>versionRevisions</code>. You cannot specify both. </p>
        /// </note>
        pub fn set_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.versions = input;
            self
        }
        /// Adds a key-value pair to `version_revisions`.
        ///
        /// To override the contents of this collection use [`set_version_revisions`](Self::set_version_revisions).
        ///
        /// <p> A list of key-value pairs. The keys are package versions and the values are package version revisions. A <code>CopyPackageVersion</code> operation succeeds if the specified versions in the source repository match the specified package version revision. </p> <note>
        /// <p> You must specify <code>versions</code> or <code>versionRevisions</code>. You cannot specify both. </p>
        /// </note>
        pub fn version_revisions(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.version_revisions.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.version_revisions = Some(hash_map);
            self
        }
        /// <p> A list of key-value pairs. The keys are package versions and the values are package version revisions. A <code>CopyPackageVersion</code> operation succeeds if the specified versions in the source repository match the specified package version revision. </p> <note>
        /// <p> You must specify <code>versions</code> or <code>versionRevisions</code>. You cannot specify both. </p>
        /// </note>
        pub fn set_version_revisions(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.version_revisions = input;
            self
        }
        /// <p> Set to true to overwrite a package version that already exists in the destination repository. If set to false and the package version already exists in the destination repository, the package version is returned in the <code>failedVersions</code> field of the response with an <code>ALREADY_EXISTS</code> error code. </p>
        pub fn allow_overwrite(mut self, input: bool) -> Self {
            self.allow_overwrite = Some(input);
            self
        }
        /// <p> Set to true to overwrite a package version that already exists in the destination repository. If set to false and the package version already exists in the destination repository, the package version is returned in the <code>failedVersions</code> field of the response with an <code>ALREADY_EXISTS</code> error code. </p>
        pub fn set_allow_overwrite(mut self, input: std::option::Option<bool>) -> Self {
            self.allow_overwrite = input;
            self
        }
        /// <p> Set to true to copy packages from repositories that are upstream from the source repository to the destination repository. The default setting is false. For more information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html">Working with upstream repositories</a>. </p>
        pub fn include_from_upstream(mut self, input: bool) -> Self {
            self.include_from_upstream = Some(input);
            self
        }
        /// <p> Set to true to copy packages from repositories that are upstream from the source repository to the destination repository. The default setting is false. For more information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html">Working with upstream repositories</a>. </p>
        pub fn set_include_from_upstream(mut self, input: std::option::Option<bool>) -> Self {
            self.include_from_upstream = input;
            self
        }
        /// Consumes the builder and constructs a [`CopyPackageVersionsInput`](crate::input::CopyPackageVersionsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CopyPackageVersionsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CopyPackageVersionsInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                source_repository: self.source_repository,
                destination_repository: self.destination_repository,
                format: self.format,
                namespace: self.namespace,
                package: self.package,
                versions: self.versions,
                version_revisions: self.version_revisions,
                allow_overwrite: self.allow_overwrite,
                include_from_upstream: self.include_from_upstream,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateExternalConnectionInput {
    /// <p>The name of the domain that contains the repository.</p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    #[doc(hidden)]
    pub domain_owner: std::option::Option<std::string::String>,
    /// <p> The name of the repository to which the external connection is added. </p>
    #[doc(hidden)]
    pub repository: std::option::Option<std::string::String>,
    /// <p> The name of the external connection to add to the repository. The following values are supported: </p>
    /// <ul>
    /// <li> <p> <code>public:npmjs</code> - for the npm public repository. </p> </li>
    /// <li> <p> <code>public:nuget-org</code> - for the NuGet Gallery. </p> </li>
    /// <li> <p> <code>public:pypi</code> - for the Python Package Index. </p> </li>
    /// <li> <p> <code>public:maven-central</code> - for Maven Central. </p> </li>
    /// <li> <p> <code>public:maven-googleandroid</code> - for the Google Android repository. </p> </li>
    /// <li> <p> <code>public:maven-gradleplugins</code> - for the Gradle plugins repository. </p> </li>
    /// <li> <p> <code>public:maven-commonsware</code> - for the CommonsWare Android repository. </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub external_connection: std::option::Option<std::string::String>,
}
impl AssociateExternalConnectionInput {
    /// <p>The name of the domain that contains the repository.</p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
    pub fn domain_owner(&self) -> std::option::Option<&str> {
        self.domain_owner.as_deref()
    }
    /// <p> The name of the repository to which the external connection is added. </p>
    pub fn repository(&self) -> std::option::Option<&str> {
        self.repository.as_deref()
    }
    /// <p> The name of the external connection to add to the repository. The following values are supported: </p>
    /// <ul>
    /// <li> <p> <code>public:npmjs</code> - for the npm public repository. </p> </li>
    /// <li> <p> <code>public:nuget-org</code> - for the NuGet Gallery. </p> </li>
    /// <li> <p> <code>public:pypi</code> - for the Python Package Index. </p> </li>
    /// <li> <p> <code>public:maven-central</code> - for Maven Central. </p> </li>
    /// <li> <p> <code>public:maven-googleandroid</code> - for the Google Android repository. </p> </li>
    /// <li> <p> <code>public:maven-gradleplugins</code> - for the Gradle plugins repository. </p> </li>
    /// <li> <p> <code>public:maven-commonsware</code> - for the CommonsWare Android repository. </p> </li>
    /// </ul>
    pub fn external_connection(&self) -> std::option::Option<&str> {
        self.external_connection.as_deref()
    }
}
impl AssociateExternalConnectionInput {
    /// Creates a new builder-style object to manufacture [`AssociateExternalConnectionInput`](crate::input::AssociateExternalConnectionInput).
    pub fn builder() -> crate::input::associate_external_connection_input::Builder {
        crate::input::associate_external_connection_input::Builder::default()
    }
}

/// See [`AssociateExternalConnectionInput`](crate::input::AssociateExternalConnectionInput).
pub mod associate_external_connection_input {

    /// A builder for [`AssociateExternalConnectionInput`](crate::input::AssociateExternalConnectionInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) domain_owner: std::option::Option<std::string::String>,
        pub(crate) repository: std::option::Option<std::string::String>,
        pub(crate) external_connection: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the domain that contains the repository.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p>The name of the domain that contains the repository.</p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_owner = Some(input.into());
            self
        }
        /// <p> The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. </p>
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_owner = input;
            self
        }
        /// <p> The name of the repository to which the external connection is added. </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        /// <p> The name of the repository to which the external connection is added. </p>
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// <p> The name of the external connection to add to the repository. The following values are supported: </p>
        /// <ul>
        /// <li> <p> <code>public:npmjs</code> - for the npm public repository. </p> </li>
        /// <li> <p> <code>public:nuget-org</code> - for the NuGet Gallery. </p> </li>
        /// <li> <p> <code>public:pypi</code> - for the Python Package Index. </p> </li>
        /// <li> <p> <code>public:maven-central</code> - for Maven Central. </p> </li>
        /// <li> <p> <code>public:maven-googleandroid</code> - for the Google Android repository. </p> </li>
        /// <li> <p> <code>public:maven-gradleplugins</code> - for the Gradle plugins repository. </p> </li>
        /// <li> <p> <code>public:maven-commonsware</code> - for the CommonsWare Android repository. </p> </li>
        /// </ul>
        pub fn external_connection(mut self, input: impl Into<std::string::String>) -> Self {
            self.external_connection = Some(input.into());
            self
        }
        /// <p> The name of the external connection to add to the repository. The following values are supported: </p>
        /// <ul>
        /// <li> <p> <code>public:npmjs</code> - for the npm public repository. </p> </li>
        /// <li> <p> <code>public:nuget-org</code> - for the NuGet Gallery. </p> </li>
        /// <li> <p> <code>public:pypi</code> - for the Python Package Index. </p> </li>
        /// <li> <p> <code>public:maven-central</code> - for Maven Central. </p> </li>
        /// <li> <p> <code>public:maven-googleandroid</code> - for the Google Android repository. </p> </li>
        /// <li> <p> <code>public:maven-gradleplugins</code> - for the Gradle plugins repository. </p> </li>
        /// <li> <p> <code>public:maven-commonsware</code> - for the CommonsWare Android repository. </p> </li>
        /// </ul>
        pub fn set_external_connection(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.external_connection = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateExternalConnectionInput`](crate::input::AssociateExternalConnectionInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::AssociateExternalConnectionInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::AssociateExternalConnectionInput {
                domain: self.domain,
                domain_owner: self.domain_owner,
                repository: self.repository,
                external_connection: self.external_connection,
            })
        }
    }
}
