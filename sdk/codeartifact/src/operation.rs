// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Adds an existing external connection to a repository. One external connection is allowed
/// per repository.</p>
/// <note>
/// <p>A repository can have one or more upstream repositories, or an external connection.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AssociateExternalConnection {
    _private: (),
}
impl AssociateExternalConnection {
    /// Creates a new builder-style object to manufacture [`AssociateExternalConnectionInput`](crate::input::AssociateExternalConnectionInput)
    pub fn builder() -> crate::input::associate_external_connection_input::Builder {
        crate::input::associate_external_connection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AssociateExternalConnection {
    type Output = std::result::Result<
        crate::output::AssociateExternalConnectionOutput,
        crate::error::AssociateExternalConnectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_associate_external_connection_error(response)
        } else {
            crate::operation_deser::parse_associate_external_connection_response(response)
        }
    }
}

/// <p>
/// Copies package versions from one repository to another repository in the same domain.
/// </p>
/// <note>
/// <p>
/// You must specify <code>versions</code> or <code>versionRevisions</code>. You cannot specify both.
/// </p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CopyPackageVersions {
    _private: (),
}
impl CopyPackageVersions {
    /// Creates a new builder-style object to manufacture [`CopyPackageVersionsInput`](crate::input::CopyPackageVersionsInput)
    pub fn builder() -> crate::input::copy_package_versions_input::Builder {
        crate::input::copy_package_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CopyPackageVersions {
    type Output = std::result::Result<
        crate::output::CopyPackageVersionsOutput,
        crate::error::CopyPackageVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_copy_package_versions_error(response)
        } else {
            crate::operation_deser::parse_copy_package_versions_response(response)
        }
    }
}

/// <p>
/// Creates a domain. CodeArtifact <i>domains</i> make it easier to manage multiple repositories across an
/// organization. You can use a domain to apply permissions across many
/// repositories owned by different AWS accounts. An asset is stored only once
/// in a domain, even if it's in multiple repositories.
/// </p>
/// <p>Although you can have multiple domains, we recommend a single production domain that contains all
/// published artifacts so that your development teams can find and share packages. You can use a second
/// pre-production domain to test changes to the production domain configuration.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDomain {
    _private: (),
}
impl CreateDomain {
    /// Creates a new builder-style object to manufacture [`CreateDomainInput`](crate::input::CreateDomainInput)
    pub fn builder() -> crate::input::create_domain_input::Builder {
        crate::input::create_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDomain {
    type Output =
        std::result::Result<crate::output::CreateDomainOutput, crate::error::CreateDomainError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_domain_error(response)
        } else {
            crate::operation_deser::parse_create_domain_response(response)
        }
    }
}

/// <p>
/// Creates a repository.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateRepository {
    _private: (),
}
impl CreateRepository {
    /// Creates a new builder-style object to manufacture [`CreateRepositoryInput`](crate::input::CreateRepositoryInput)
    pub fn builder() -> crate::input::create_repository_input::Builder {
        crate::input::create_repository_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateRepository {
    type Output = std::result::Result<
        crate::output::CreateRepositoryOutput,
        crate::error::CreateRepositoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_repository_error(response)
        } else {
            crate::operation_deser::parse_create_repository_response(response)
        }
    }
}

/// <p>
/// Deletes a domain. You cannot delete a domain that contains repositories. If you want to delete a domain
/// with repositories, first delete its repositories.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDomain {
    _private: (),
}
impl DeleteDomain {
    /// Creates a new builder-style object to manufacture [`DeleteDomainInput`](crate::input::DeleteDomainInput)
    pub fn builder() -> crate::input::delete_domain_input::Builder {
        crate::input::delete_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDomain {
    type Output =
        std::result::Result<crate::output::DeleteDomainOutput, crate::error::DeleteDomainError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_domain_error(response)
        } else {
            crate::operation_deser::parse_delete_domain_response(response)
        }
    }
}

/// <p>
/// Deletes the resource policy set on a domain.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDomainPermissionsPolicy {
    _private: (),
}
impl DeleteDomainPermissionsPolicy {
    /// Creates a new builder-style object to manufacture [`DeleteDomainPermissionsPolicyInput`](crate::input::DeleteDomainPermissionsPolicyInput)
    pub fn builder() -> crate::input::delete_domain_permissions_policy_input::Builder {
        crate::input::delete_domain_permissions_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDomainPermissionsPolicy {
    type Output = std::result::Result<
        crate::output::DeleteDomainPermissionsPolicyOutput,
        crate::error::DeleteDomainPermissionsPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_domain_permissions_policy_error(response)
        } else {
            crate::operation_deser::parse_delete_domain_permissions_policy_response(response)
        }
    }
}

/// <p> Deletes one or more versions of a package. A deleted package version cannot be restored
/// in your repository. If you want to remove a package version from your repository and be able
/// to restore it later, set its status to <code>Archived</code>. Archived packages cannot be
/// downloaded from a repository and don't show up with list package APIs (for example,
/// <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_ListPackageVersions.html">ListackageVersions</a>), but you can restore them using <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_UpdatePackageVersionsStatus.html">UpdatePackageVersionsStatus</a>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeletePackageVersions {
    _private: (),
}
impl DeletePackageVersions {
    /// Creates a new builder-style object to manufacture [`DeletePackageVersionsInput`](crate::input::DeletePackageVersionsInput)
    pub fn builder() -> crate::input::delete_package_versions_input::Builder {
        crate::input::delete_package_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeletePackageVersions {
    type Output = std::result::Result<
        crate::output::DeletePackageVersionsOutput,
        crate::error::DeletePackageVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_package_versions_error(response)
        } else {
            crate::operation_deser::parse_delete_package_versions_response(response)
        }
    }
}

/// <p>
/// Deletes a repository.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteRepository {
    _private: (),
}
impl DeleteRepository {
    /// Creates a new builder-style object to manufacture [`DeleteRepositoryInput`](crate::input::DeleteRepositoryInput)
    pub fn builder() -> crate::input::delete_repository_input::Builder {
        crate::input::delete_repository_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteRepository {
    type Output = std::result::Result<
        crate::output::DeleteRepositoryOutput,
        crate::error::DeleteRepositoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_repository_error(response)
        } else {
            crate::operation_deser::parse_delete_repository_response(response)
        }
    }
}

/// <p>
/// Deletes the resource policy that is set on a repository. After a resource policy is deleted, the
/// permissions allowed and denied by the deleted policy are removed. The effect of deleting a resource policy might not be immediate.
/// </p>
/// <important>
/// <p>
/// Use <code>DeleteRepositoryPermissionsPolicy</code> with caution. After a policy is deleted, AWS users, roles, and accounts lose permissions to perform
/// the repository actions granted by the deleted policy.
/// </p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteRepositoryPermissionsPolicy {
    _private: (),
}
impl DeleteRepositoryPermissionsPolicy {
    /// Creates a new builder-style object to manufacture [`DeleteRepositoryPermissionsPolicyInput`](crate::input::DeleteRepositoryPermissionsPolicyInput)
    pub fn builder() -> crate::input::delete_repository_permissions_policy_input::Builder {
        crate::input::delete_repository_permissions_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteRepositoryPermissionsPolicy {
    type Output = std::result::Result<
        crate::output::DeleteRepositoryPermissionsPolicyOutput,
        crate::error::DeleteRepositoryPermissionsPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_repository_permissions_policy_error(response)
        } else {
            crate::operation_deser::parse_delete_repository_permissions_policy_response(response)
        }
    }
}

/// <p>
/// Returns a
/// <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_DomainDescription.html">DomainDescription</a>
/// object that contains information about the requested domain.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDomain {
    _private: (),
}
impl DescribeDomain {
    /// Creates a new builder-style object to manufacture [`DescribeDomainInput`](crate::input::DescribeDomainInput)
    pub fn builder() -> crate::input::describe_domain_input::Builder {
        crate::input::describe_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDomain {
    type Output =
        std::result::Result<crate::output::DescribeDomainOutput, crate::error::DescribeDomainError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_domain_error(response)
        } else {
            crate::operation_deser::parse_describe_domain_response(response)
        }
    }
}

/// <p>
/// Returns a
/// <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageVersionDescription.html">PackageVersionDescription</a>
/// object that contains information about the requested package version.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribePackageVersion {
    _private: (),
}
impl DescribePackageVersion {
    /// Creates a new builder-style object to manufacture [`DescribePackageVersionInput`](crate::input::DescribePackageVersionInput)
    pub fn builder() -> crate::input::describe_package_version_input::Builder {
        crate::input::describe_package_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribePackageVersion {
    type Output = std::result::Result<
        crate::output::DescribePackageVersionOutput,
        crate::error::DescribePackageVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_package_version_error(response)
        } else {
            crate::operation_deser::parse_describe_package_version_response(response)
        }
    }
}

/// <p>
/// Returns a <code>RepositoryDescription</code> object that contains detailed information
/// about the requested repository.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeRepository {
    _private: (),
}
impl DescribeRepository {
    /// Creates a new builder-style object to manufacture [`DescribeRepositoryInput`](crate::input::DescribeRepositoryInput)
    pub fn builder() -> crate::input::describe_repository_input::Builder {
        crate::input::describe_repository_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeRepository {
    type Output = std::result::Result<
        crate::output::DescribeRepositoryOutput,
        crate::error::DescribeRepositoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_repository_error(response)
        } else {
            crate::operation_deser::parse_describe_repository_response(response)
        }
    }
}

/// <p>
/// Removes an existing external connection from a repository.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisassociateExternalConnection {
    _private: (),
}
impl DisassociateExternalConnection {
    /// Creates a new builder-style object to manufacture [`DisassociateExternalConnectionInput`](crate::input::DisassociateExternalConnectionInput)
    pub fn builder() -> crate::input::disassociate_external_connection_input::Builder {
        crate::input::disassociate_external_connection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisassociateExternalConnection {
    type Output = std::result::Result<
        crate::output::DisassociateExternalConnectionOutput,
        crate::error::DisassociateExternalConnectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_disassociate_external_connection_error(response)
        } else {
            crate::operation_deser::parse_disassociate_external_connection_response(response)
        }
    }
}

/// <p>
/// Deletes the assets in package versions and sets the package versions' status to <code>Disposed</code>.
/// A disposed package version cannot be restored in your repository because its assets are deleted.
/// </p>
/// <p>
/// To view all disposed package versions in a repository, use <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_ListPackageVersions.html">ListPackageVersions</a> and set the
/// <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_ListPackageVersions.html#API_ListPackageVersions_RequestSyntax">status</a> parameter
/// to <code>Disposed</code>.
/// </p>
/// <p>
/// To view information about a disposed package version, use <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_DescribePackageVersion.html">DescribePackageVersion</a>.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisposePackageVersions {
    _private: (),
}
impl DisposePackageVersions {
    /// Creates a new builder-style object to manufacture [`DisposePackageVersionsInput`](crate::input::DisposePackageVersionsInput)
    pub fn builder() -> crate::input::dispose_package_versions_input::Builder {
        crate::input::dispose_package_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisposePackageVersions {
    type Output = std::result::Result<
        crate::output::DisposePackageVersionsOutput,
        crate::error::DisposePackageVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_dispose_package_versions_error(response)
        } else {
            crate::operation_deser::parse_dispose_package_versions_response(response)
        }
    }
}

/// <p>
/// Generates a temporary authorization token for accessing repositories in the domain.
/// This API requires the <code>codeartifact:GetAuthorizationToken</code> and <code>sts:GetServiceBearerToken</code> permissions.
/// For more information about authorization tokens, see
/// <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/tokens-authentication.html">AWS CodeArtifact authentication and tokens</a>.
/// </p>
/// <note>
/// <p>CodeArtifact authorization tokens are valid for a period of 12 hours when created with the <code>login</code> command.
/// You can call <code>login</code> periodically to refresh the token. When
/// you create an authorization token with the <code>GetAuthorizationToken</code> API, you can set a custom authorization period,
/// up to a maximum of 12 hours, with the <code>durationSeconds</code> parameter.</p>
/// <p>The authorization period begins after <code>login</code>
/// or <code>GetAuthorizationToken</code> is called. If <code>login</code> or <code>GetAuthorizationToken</code> is called while
/// assuming a role, the token lifetime is independent of the maximum session duration
/// of the role. For example, if you call <code>sts assume-role</code> and specify a session duration of 15 minutes, then
/// generate a CodeArtifact authorization token, the token will be valid for the full authorization period
/// even though this is longer than the 15-minute session duration.</p>
/// <p>See
/// <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html">Using IAM Roles</a>
/// for more information on controlling session duration. </p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetAuthorizationToken {
    _private: (),
}
impl GetAuthorizationToken {
    /// Creates a new builder-style object to manufacture [`GetAuthorizationTokenInput`](crate::input::GetAuthorizationTokenInput)
    pub fn builder() -> crate::input::get_authorization_token_input::Builder {
        crate::input::get_authorization_token_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetAuthorizationToken {
    type Output = std::result::Result<
        crate::output::GetAuthorizationTokenOutput,
        crate::error::GetAuthorizationTokenError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_authorization_token_error(response)
        } else {
            crate::operation_deser::parse_get_authorization_token_response(response)
        }
    }
}

/// <p>
/// Returns the resource policy attached to the specified domain.
/// </p>
/// <note>
/// <p>
/// The policy is a resource-based policy, not an identity-based policy. For more information, see
/// <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_identity-vs-resource.html">Identity-based policies
/// and resource-based policies </a> in the <i>AWS Identity and Access Management User Guide</i>.
/// </p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDomainPermissionsPolicy {
    _private: (),
}
impl GetDomainPermissionsPolicy {
    /// Creates a new builder-style object to manufacture [`GetDomainPermissionsPolicyInput`](crate::input::GetDomainPermissionsPolicyInput)
    pub fn builder() -> crate::input::get_domain_permissions_policy_input::Builder {
        crate::input::get_domain_permissions_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDomainPermissionsPolicy {
    type Output = std::result::Result<
        crate::output::GetDomainPermissionsPolicyOutput,
        crate::error::GetDomainPermissionsPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_domain_permissions_policy_error(response)
        } else {
            crate::operation_deser::parse_get_domain_permissions_policy_response(response)
        }
    }
}

/// <p>
/// Returns an asset (or file) that is in a package. For example, for a Maven package version, use
/// <code>GetPackageVersionAsset</code> to download a <code>JAR</code> file, a <code>POM</code> file,
/// or any other assets in the package version.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetPackageVersionAsset {
    _private: (),
}
impl GetPackageVersionAsset {
    /// Creates a new builder-style object to manufacture [`GetPackageVersionAssetInput`](crate::input::GetPackageVersionAssetInput)
    pub fn builder() -> crate::input::get_package_version_asset_input::Builder {
        crate::input::get_package_version_asset_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseHttpResponse<smithy_http::body::SdkBody>
    for GetPackageVersionAsset
{
    type Output = std::result::Result<
        crate::output::GetPackageVersionAssetOutput,
        crate::error::GetPackageVersionAssetError,
    >;
    fn parse_unloaded(
        &self,
        response: &mut http::Response<smithy_http::body::SdkBody>,
    ) -> Option<Self::Output> {
        // This is an error, defer to the non-streaming parser
        if !response.status().is_success() && response.status().as_u16() != 200 {
            return None;
        }
        Some(crate::operation_deser::parse_get_package_version_asset(
            response,
        ))
    }
    fn parse_loaded(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        // if streaming, we only hit this case if its an error
        crate::operation_deser::parse_get_package_version_asset_error(response)
    }
}

/// <p>
/// Gets the readme file or descriptive text for a package version. For packages that do not contain a readme file, CodeArtifact
/// extracts a description from a metadata file. For example, from the <code><description></code> element in the
/// <code>pom.xml</code> file of a Maven package.
/// </p>
/// <p>
/// The returned text might contain formatting. For example, it might contain formatting for Markdown or reStructuredText.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetPackageVersionReadme {
    _private: (),
}
impl GetPackageVersionReadme {
    /// Creates a new builder-style object to manufacture [`GetPackageVersionReadmeInput`](crate::input::GetPackageVersionReadmeInput)
    pub fn builder() -> crate::input::get_package_version_readme_input::Builder {
        crate::input::get_package_version_readme_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetPackageVersionReadme {
    type Output = std::result::Result<
        crate::output::GetPackageVersionReadmeOutput,
        crate::error::GetPackageVersionReadmeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_package_version_readme_error(response)
        } else {
            crate::operation_deser::parse_get_package_version_readme_response(response)
        }
    }
}

/// <p>
/// Returns the endpoint of a repository for a specific package format. A repository has one endpoint for each
/// package format:
/// </p>
/// <ul>
/// <li>
/// <p>
/// <code>npm</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>pypi</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>maven</code>
/// </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRepositoryEndpoint {
    _private: (),
}
impl GetRepositoryEndpoint {
    /// Creates a new builder-style object to manufacture [`GetRepositoryEndpointInput`](crate::input::GetRepositoryEndpointInput)
    pub fn builder() -> crate::input::get_repository_endpoint_input::Builder {
        crate::input::get_repository_endpoint_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRepositoryEndpoint {
    type Output = std::result::Result<
        crate::output::GetRepositoryEndpointOutput,
        crate::error::GetRepositoryEndpointError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_repository_endpoint_error(response)
        } else {
            crate::operation_deser::parse_get_repository_endpoint_response(response)
        }
    }
}

/// <p>
/// Returns the resource policy that is set on a repository.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRepositoryPermissionsPolicy {
    _private: (),
}
impl GetRepositoryPermissionsPolicy {
    /// Creates a new builder-style object to manufacture [`GetRepositoryPermissionsPolicyInput`](crate::input::GetRepositoryPermissionsPolicyInput)
    pub fn builder() -> crate::input::get_repository_permissions_policy_input::Builder {
        crate::input::get_repository_permissions_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRepositoryPermissionsPolicy {
    type Output = std::result::Result<
        crate::output::GetRepositoryPermissionsPolicyOutput,
        crate::error::GetRepositoryPermissionsPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_repository_permissions_policy_error(response)
        } else {
            crate::operation_deser::parse_get_repository_permissions_policy_response(response)
        }
    }
}

/// <p> Returns a list of <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageVersionDescription.html">DomainSummary</a> objects for all domains owned by the AWS account that makes
/// this call. Each returned <code>DomainSummary</code> object contains information about a
/// domain. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDomains {
    _private: (),
}
impl ListDomains {
    /// Creates a new builder-style object to manufacture [`ListDomainsInput`](crate::input::ListDomainsInput)
    pub fn builder() -> crate::input::list_domains_input::Builder {
        crate::input::list_domains_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDomains {
    type Output =
        std::result::Result<crate::output::ListDomainsOutput, crate::error::ListDomainsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_domains_error(response)
        } else {
            crate::operation_deser::parse_list_domains_response(response)
        }
    }
}

/// <p>
/// Returns a list of
/// <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageSummary.html">PackageSummary</a>
/// objects for packages in a repository that match the request parameters.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListPackages {
    _private: (),
}
impl ListPackages {
    /// Creates a new builder-style object to manufacture [`ListPackagesInput`](crate::input::ListPackagesInput)
    pub fn builder() -> crate::input::list_packages_input::Builder {
        crate::input::list_packages_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListPackages {
    type Output =
        std::result::Result<crate::output::ListPackagesOutput, crate::error::ListPackagesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_packages_error(response)
        } else {
            crate::operation_deser::parse_list_packages_response(response)
        }
    }
}

/// <p>
/// Returns a list of
/// <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_AssetSummary.html">AssetSummary</a>
/// objects for assets in a package version.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListPackageVersionAssets {
    _private: (),
}
impl ListPackageVersionAssets {
    /// Creates a new builder-style object to manufacture [`ListPackageVersionAssetsInput`](crate::input::ListPackageVersionAssetsInput)
    pub fn builder() -> crate::input::list_package_version_assets_input::Builder {
        crate::input::list_package_version_assets_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListPackageVersionAssets {
    type Output = std::result::Result<
        crate::output::ListPackageVersionAssetsOutput,
        crate::error::ListPackageVersionAssetsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_package_version_assets_error(response)
        } else {
            crate::operation_deser::parse_list_package_version_assets_response(response)
        }
    }
}

/// <p>
/// Returns the direct dependencies for a package version. The dependencies are returned as
/// <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageDependency.html">PackageDependency</a>
/// objects. CodeArtifact extracts the dependencies for a package version from the metadata file for the package
/// format (for example, the <code>package.json</code> file for npm packages and the <code>pom.xml</code> file
/// for Maven). Any package version dependencies that are not listed in the configuration file are not returned.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListPackageVersionDependencies {
    _private: (),
}
impl ListPackageVersionDependencies {
    /// Creates a new builder-style object to manufacture [`ListPackageVersionDependenciesInput`](crate::input::ListPackageVersionDependenciesInput)
    pub fn builder() -> crate::input::list_package_version_dependencies_input::Builder {
        crate::input::list_package_version_dependencies_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListPackageVersionDependencies {
    type Output = std::result::Result<
        crate::output::ListPackageVersionDependenciesOutput,
        crate::error::ListPackageVersionDependenciesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_package_version_dependencies_error(response)
        } else {
            crate::operation_deser::parse_list_package_version_dependencies_response(response)
        }
    }
}

/// <p>
/// Returns a list of
/// <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageVersionSummary.html">PackageVersionSummary</a>
/// objects for package versions in a repository that match the request parameters.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListPackageVersions {
    _private: (),
}
impl ListPackageVersions {
    /// Creates a new builder-style object to manufacture [`ListPackageVersionsInput`](crate::input::ListPackageVersionsInput)
    pub fn builder() -> crate::input::list_package_versions_input::Builder {
        crate::input::list_package_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListPackageVersions {
    type Output = std::result::Result<
        crate::output::ListPackageVersionsOutput,
        crate::error::ListPackageVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_package_versions_error(response)
        } else {
            crate::operation_deser::parse_list_package_versions_response(response)
        }
    }
}

/// <p>
/// Returns a list of
/// <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_RepositorySummary.html">RepositorySummary</a>
/// objects. Each <code>RepositorySummary</code> contains information about a repository in the specified AWS account and that matches the input
/// parameters.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListRepositories {
    _private: (),
}
impl ListRepositories {
    /// Creates a new builder-style object to manufacture [`ListRepositoriesInput`](crate::input::ListRepositoriesInput)
    pub fn builder() -> crate::input::list_repositories_input::Builder {
        crate::input::list_repositories_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListRepositories {
    type Output = std::result::Result<
        crate::output::ListRepositoriesOutput,
        crate::error::ListRepositoriesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_repositories_error(response)
        } else {
            crate::operation_deser::parse_list_repositories_response(response)
        }
    }
}

/// <p>
/// Returns a list of
/// <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_RepositorySummary.html">RepositorySummary</a>
/// objects. Each <code>RepositorySummary</code> contains information about a repository in the specified domain and that matches the input
/// parameters.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListRepositoriesInDomain {
    _private: (),
}
impl ListRepositoriesInDomain {
    /// Creates a new builder-style object to manufacture [`ListRepositoriesInDomainInput`](crate::input::ListRepositoriesInDomainInput)
    pub fn builder() -> crate::input::list_repositories_in_domain_input::Builder {
        crate::input::list_repositories_in_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListRepositoriesInDomain {
    type Output = std::result::Result<
        crate::output::ListRepositoriesInDomainOutput,
        crate::error::ListRepositoriesInDomainError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_repositories_in_domain_error(response)
        } else {
            crate::operation_deser::parse_list_repositories_in_domain_response(response)
        }
    }
}

/// <p>Gets information about AWS tags for a specified Amazon Resource Name (ARN) in AWS CodeArtifact.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>
/// Sets a resource policy on a domain that specifies permissions to access it.
/// </p>
/// <p>
/// When you call <code>PutDomainPermissionsPolicy</code>, the resource policy on the domain is ignored when evaluting permissions.
/// This ensures that the owner of a domain cannot lock themselves out of the domain, which would prevent them from being
/// able to update the resource policy.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutDomainPermissionsPolicy {
    _private: (),
}
impl PutDomainPermissionsPolicy {
    /// Creates a new builder-style object to manufacture [`PutDomainPermissionsPolicyInput`](crate::input::PutDomainPermissionsPolicyInput)
    pub fn builder() -> crate::input::put_domain_permissions_policy_input::Builder {
        crate::input::put_domain_permissions_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutDomainPermissionsPolicy {
    type Output = std::result::Result<
        crate::output::PutDomainPermissionsPolicyOutput,
        crate::error::PutDomainPermissionsPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_domain_permissions_policy_error(response)
        } else {
            crate::operation_deser::parse_put_domain_permissions_policy_response(response)
        }
    }
}

/// <p>
/// Sets the resource policy on a repository that specifies permissions to access it.
/// </p>
/// <p>
/// When you call <code>PutRepositoryPermissionsPolicy</code>, the resource policy on the repository is ignored when evaluting permissions.
/// This ensures that the owner of a repository cannot lock themselves out of the repository, which would prevent them from being
/// able to update the resource policy.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutRepositoryPermissionsPolicy {
    _private: (),
}
impl PutRepositoryPermissionsPolicy {
    /// Creates a new builder-style object to manufacture [`PutRepositoryPermissionsPolicyInput`](crate::input::PutRepositoryPermissionsPolicyInput)
    pub fn builder() -> crate::input::put_repository_permissions_policy_input::Builder {
        crate::input::put_repository_permissions_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutRepositoryPermissionsPolicy {
    type Output = std::result::Result<
        crate::output::PutRepositoryPermissionsPolicyOutput,
        crate::error::PutRepositoryPermissionsPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_repository_permissions_policy_error(response)
        } else {
            crate::operation_deser::parse_put_repository_permissions_policy_response(response)
        }
    }
}

/// <p>Adds or updates tags for a resource in AWS CodeArtifact.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Removes tags from a resource in AWS CodeArtifact.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>
/// Updates the status of one or more versions of a package.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdatePackageVersionsStatus {
    _private: (),
}
impl UpdatePackageVersionsStatus {
    /// Creates a new builder-style object to manufacture [`UpdatePackageVersionsStatusInput`](crate::input::UpdatePackageVersionsStatusInput)
    pub fn builder() -> crate::input::update_package_versions_status_input::Builder {
        crate::input::update_package_versions_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdatePackageVersionsStatus {
    type Output = std::result::Result<
        crate::output::UpdatePackageVersionsStatusOutput,
        crate::error::UpdatePackageVersionsStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_package_versions_status_error(response)
        } else {
            crate::operation_deser::parse_update_package_versions_status_response(response)
        }
    }
}

/// <p>
/// Update the properties of a repository.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateRepository {
    _private: (),
}
impl UpdateRepository {
    /// Creates a new builder-style object to manufacture [`UpdateRepositoryInput`](crate::input::UpdateRepositoryInput)
    pub fn builder() -> crate::input::update_repository_input::Builder {
        crate::input::update_repository_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateRepository {
    type Output = std::result::Result<
        crate::output::UpdateRepositoryOutput,
        crate::error::UpdateRepositoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_repository_error(response)
        } else {
            crate::operation_deser::parse_update_repository_response(response)
        }
    }
}
