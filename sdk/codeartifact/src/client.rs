// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn associate_external_connection(&self) -> fluent_builders::AssociateExternalConnection<C> {
        fluent_builders::AssociateExternalConnection::new(self.handle.clone())
    }
    pub fn copy_package_versions(&self) -> fluent_builders::CopyPackageVersions<C> {
        fluent_builders::CopyPackageVersions::new(self.handle.clone())
    }
    pub fn create_domain(&self) -> fluent_builders::CreateDomain<C> {
        fluent_builders::CreateDomain::new(self.handle.clone())
    }
    pub fn create_repository(&self) -> fluent_builders::CreateRepository<C> {
        fluent_builders::CreateRepository::new(self.handle.clone())
    }
    pub fn delete_domain(&self) -> fluent_builders::DeleteDomain<C> {
        fluent_builders::DeleteDomain::new(self.handle.clone())
    }
    pub fn delete_domain_permissions_policy(
        &self,
    ) -> fluent_builders::DeleteDomainPermissionsPolicy<C> {
        fluent_builders::DeleteDomainPermissionsPolicy::new(self.handle.clone())
    }
    pub fn delete_package_versions(&self) -> fluent_builders::DeletePackageVersions<C> {
        fluent_builders::DeletePackageVersions::new(self.handle.clone())
    }
    pub fn delete_repository(&self) -> fluent_builders::DeleteRepository<C> {
        fluent_builders::DeleteRepository::new(self.handle.clone())
    }
    pub fn delete_repository_permissions_policy(
        &self,
    ) -> fluent_builders::DeleteRepositoryPermissionsPolicy<C> {
        fluent_builders::DeleteRepositoryPermissionsPolicy::new(self.handle.clone())
    }
    pub fn describe_domain(&self) -> fluent_builders::DescribeDomain<C> {
        fluent_builders::DescribeDomain::new(self.handle.clone())
    }
    pub fn describe_package_version(&self) -> fluent_builders::DescribePackageVersion<C> {
        fluent_builders::DescribePackageVersion::new(self.handle.clone())
    }
    pub fn describe_repository(&self) -> fluent_builders::DescribeRepository<C> {
        fluent_builders::DescribeRepository::new(self.handle.clone())
    }
    pub fn disassociate_external_connection(
        &self,
    ) -> fluent_builders::DisassociateExternalConnection<C> {
        fluent_builders::DisassociateExternalConnection::new(self.handle.clone())
    }
    pub fn dispose_package_versions(&self) -> fluent_builders::DisposePackageVersions<C> {
        fluent_builders::DisposePackageVersions::new(self.handle.clone())
    }
    pub fn get_authorization_token(&self) -> fluent_builders::GetAuthorizationToken<C> {
        fluent_builders::GetAuthorizationToken::new(self.handle.clone())
    }
    pub fn get_domain_permissions_policy(&self) -> fluent_builders::GetDomainPermissionsPolicy<C> {
        fluent_builders::GetDomainPermissionsPolicy::new(self.handle.clone())
    }
    pub fn get_package_version_asset(&self) -> fluent_builders::GetPackageVersionAsset<C> {
        fluent_builders::GetPackageVersionAsset::new(self.handle.clone())
    }
    pub fn get_package_version_readme(&self) -> fluent_builders::GetPackageVersionReadme<C> {
        fluent_builders::GetPackageVersionReadme::new(self.handle.clone())
    }
    pub fn get_repository_endpoint(&self) -> fluent_builders::GetRepositoryEndpoint<C> {
        fluent_builders::GetRepositoryEndpoint::new(self.handle.clone())
    }
    pub fn get_repository_permissions_policy(
        &self,
    ) -> fluent_builders::GetRepositoryPermissionsPolicy<C> {
        fluent_builders::GetRepositoryPermissionsPolicy::new(self.handle.clone())
    }
    pub fn list_domains(&self) -> fluent_builders::ListDomains<C> {
        fluent_builders::ListDomains::new(self.handle.clone())
    }
    pub fn list_packages(&self) -> fluent_builders::ListPackages<C> {
        fluent_builders::ListPackages::new(self.handle.clone())
    }
    pub fn list_package_version_assets(&self) -> fluent_builders::ListPackageVersionAssets<C> {
        fluent_builders::ListPackageVersionAssets::new(self.handle.clone())
    }
    pub fn list_package_version_dependencies(
        &self,
    ) -> fluent_builders::ListPackageVersionDependencies<C> {
        fluent_builders::ListPackageVersionDependencies::new(self.handle.clone())
    }
    pub fn list_package_versions(&self) -> fluent_builders::ListPackageVersions<C> {
        fluent_builders::ListPackageVersions::new(self.handle.clone())
    }
    pub fn list_repositories(&self) -> fluent_builders::ListRepositories<C> {
        fluent_builders::ListRepositories::new(self.handle.clone())
    }
    pub fn list_repositories_in_domain(&self) -> fluent_builders::ListRepositoriesInDomain<C> {
        fluent_builders::ListRepositoriesInDomain::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn put_domain_permissions_policy(&self) -> fluent_builders::PutDomainPermissionsPolicy<C> {
        fluent_builders::PutDomainPermissionsPolicy::new(self.handle.clone())
    }
    pub fn put_repository_permissions_policy(
        &self,
    ) -> fluent_builders::PutRepositoryPermissionsPolicy<C> {
        fluent_builders::PutRepositoryPermissionsPolicy::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_package_versions_status(
        &self,
    ) -> fluent_builders::UpdatePackageVersionsStatus<C> {
        fluent_builders::UpdatePackageVersionsStatus::new(self.handle.clone())
    }
    pub fn update_repository(&self) -> fluent_builders::UpdateRepository<C> {
        fluent_builders::UpdateRepository::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AssociateExternalConnection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_external_connection_input::Builder,
    }
    impl<C> AssociateExternalConnection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateExternalConnectionOutput,
            smithy_http::result::SdkError<crate::error::AssociateExternalConnectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that contains the repository.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
        /// <p>
        /// The name of the repository to which the external connection is added.
        /// </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository(input);
            self
        }
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_repository(input);
            self
        }
        /// <p>
        /// The name of the external connection to add to the repository. The following values are supported:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>public:npmjs</code> - for the npm public repository.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>public:pypi</code> - for the Python Package Index.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>public:maven-central</code> - for Maven Central.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>public:maven-googleandroid</code> - for the Google Android repository.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>public:maven-gradleplugins</code> - for the Gradle plugins repository.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>public:maven-commonsware</code> - for the CommonsWare Android repository.
        /// </p>
        /// </li>
        /// </ul>
        pub fn external_connection(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.external_connection(input);
            self
        }
        pub fn set_external_connection(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_external_connection(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CopyPackageVersions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::copy_package_versions_input::Builder,
    }
    impl<C> CopyPackageVersions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CopyPackageVersionsOutput,
            smithy_http::result::SdkError<crate::error::CopyPackageVersionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the domain that contains the source and destination repositories.
        /// </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
        /// <p>
        /// The name of the repository that contains the package versions to copy.
        /// </p>
        pub fn source_repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_repository(input);
            self
        }
        pub fn set_source_repository(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_repository(input);
            self
        }
        /// <p>
        /// The name of the repository into which package versions are copied.
        /// </p>
        pub fn destination_repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_repository(input);
            self
        }
        pub fn set_destination_repository(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_repository(input);
            self
        }
        /// <p>
        /// The format of the package that is copied. The valid package types are:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>npm</code>: A Node Package Manager (npm) package.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>pypi</code>: A Python Package Index (PyPI) package.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>maven</code>: A Maven package that contains compiled code in a distributable format, such as a JAR file.
        /// </p>
        /// </li>
        /// </ul>
        pub fn format(mut self, input: crate::model::PackageFormat) -> Self {
            self.inner = self.inner.format(input);
            self
        }
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::PackageFormat>,
        ) -> Self {
            self.inner = self.inner.set_format(input);
            self
        }
        /// <p>
        /// The namespace of the package. The package component that specifies its
        /// namespace depends on its type. For example:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// The namespace of a Maven package is its <code>groupId</code>.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// The namespace of an npm package is its <code>scope</code>.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// A Python package does not contain a corresponding component, so
        /// Python packages do not have a namespace.
        /// </p>
        /// </li>
        /// </ul>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace(input);
            self
        }
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace(input);
            self
        }
        /// <p>
        /// The name of the package that is copied.
        /// </p>
        pub fn package(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.package(input);
            self
        }
        pub fn set_package(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_package(input);
            self
        }
        /// <p>
        /// The versions of the package to copy.
        /// </p>
        /// <note>
        /// <p>
        /// You must specify <code>versions</code> or <code>versionRevisions</code>. You cannot specify both.
        /// </p>
        /// </note>
        pub fn versions(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.versions(inp);
            self
        }
        pub fn set_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_versions(input);
            self
        }
        /// <p>
        /// A list of key-value pairs. The keys are package versions and the values are package version revisions. A <code>CopyPackageVersion</code> operation
        /// succeeds if the specified versions in the source repository match the specified package version revision.
        /// </p>
        /// <note>
        /// <p>
        /// You must specify <code>versions</code> or <code>versionRevisions</code>. You cannot specify both.
        /// </p>
        /// </note>
        pub fn version_revisions(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.version_revisions(k, v);
            self
        }
        pub fn set_version_revisions(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_version_revisions(input);
            self
        }
        /// <p>
        /// Set to true to overwrite a package version that already exists in the destination repository.
        /// If set to false and the package version already exists in the destination repository,
        /// the package version is returned in the <code>failedVersions</code> field of the response with
        /// an <code>ALREADY_EXISTS</code> error code.
        /// </p>
        pub fn allow_overwrite(mut self, input: bool) -> Self {
            self.inner = self.inner.allow_overwrite(input);
            self
        }
        pub fn set_allow_overwrite(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_allow_overwrite(input);
            self
        }
        /// <p> Set to true to copy packages from repositories that are upstream from the source
        /// repository to the destination repository. The default setting is false. For more information,
        /// see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html">Working with
        /// upstream repositories</a>. </p>
        pub fn include_from_upstream(mut self, input: bool) -> Self {
            self.inner = self.inner.include_from_upstream(input);
            self
        }
        pub fn set_include_from_upstream(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_from_upstream(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDomain<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_domain_input::Builder,
    }
    impl<C> CreateDomain<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDomainOutput,
            smithy_http::result::SdkError<crate::error::CreateDomainError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The name of the domain to create. All domain names in an AWS Region that are in the
        /// same AWS account must be unique. The domain name is used as the prefix in DNS hostnames. Do
        /// not use sensitive information in a domain name because it is publicly discoverable. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p> The encryption key for the domain. This is used to encrypt content stored in a domain.
        /// An encryption key can be a key ID, a key Amazon Resource Name (ARN), a key alias, or a key
        /// alias ARN. To specify an <code>encryptionKey</code>, your IAM role must have
        /// <code>kms:DescribeKey</code> and <code>kms:CreateGrant</code> permissions on the encryption
        /// key that is used. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestSyntax">DescribeKey</a> in the <i>AWS Key Management Service API Reference</i>
        /// and <a href="https://docs.aws.amazon.com/kms/latest/developerguide/kms-api-permissions-reference.html">AWS KMS API Permissions
        /// Reference</a> in the <i>AWS Key Management Service Developer Guide</i>. </p>
        /// <important>
        /// <p> CodeArtifact supports only symmetric CMKs. Do not associate an asymmetric CMK with your
        /// domain. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using symmetric and asymmetric
        /// keys</a> in the <i>AWS Key Management Service Developer Guide</i>. </p>
        /// </important>
        pub fn encryption_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.encryption_key(input);
            self
        }
        pub fn set_encryption_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_encryption_key(input);
            self
        }
        /// <p>One or more tag key-value pairs for the domain.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateRepository<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_repository_input::Builder,
    }
    impl<C> CreateRepository<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateRepositoryOutput,
            smithy_http::result::SdkError<crate::error::CreateRepositoryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the domain that contains the created repository.
        /// </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
        /// <p> The name of the repository to create. </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository(input);
            self
        }
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_repository(input);
            self
        }
        /// <p>
        /// A description of the created repository.
        /// </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p> A list of upstream repositories to associate with the repository. The order of the upstream repositories
        /// in the list determines their priority order when AWS CodeArtifact looks for a requested package version. For more
        /// information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html">Working with upstream repositories</a>. </p>
        pub fn upstreams(mut self, inp: impl Into<crate::model::UpstreamRepository>) -> Self {
            self.inner = self.inner.upstreams(inp);
            self
        }
        pub fn set_upstreams(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UpstreamRepository>>,
        ) -> Self {
            self.inner = self.inner.set_upstreams(input);
            self
        }
        /// <p>One or more tag key-value pairs for the repository.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDomain<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_domain_input::Builder,
    }
    impl<C> DeleteDomain<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDomainOutput,
            smithy_http::result::SdkError<crate::error::DeleteDomainError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the domain to delete.
        /// </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDomainPermissionsPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_domain_permissions_policy_input::Builder,
    }
    impl<C> DeleteDomainPermissionsPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDomainPermissionsPolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteDomainPermissionsPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the domain associated with the resource policy to be deleted.
        /// </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
        /// <p>
        /// The current revision of the resource policy to be deleted. This revision is used for optimistic locking, which
        /// prevents others from overwriting your changes to the domain's resource policy.
        /// </p>
        pub fn policy_revision(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_revision(input);
            self
        }
        pub fn set_policy_revision(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_revision(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeletePackageVersions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_package_versions_input::Builder,
    }
    impl<C> DeletePackageVersions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeletePackageVersionsOutput,
            smithy_http::result::SdkError<crate::error::DeletePackageVersionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the domain that contains the package to delete.
        /// </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
        /// <p>
        /// The name of the repository that contains the package versions to delete.
        /// </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository(input);
            self
        }
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_repository(input);
            self
        }
        /// <p>
        /// The format of the package versions to delete. The valid values are:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>npm</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>pypi</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>maven</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn format(mut self, input: crate::model::PackageFormat) -> Self {
            self.inner = self.inner.format(input);
            self
        }
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::PackageFormat>,
        ) -> Self {
            self.inner = self.inner.set_format(input);
            self
        }
        /// <p>
        /// The namespace of the package. The package component that specifies its
        /// namespace depends on its type. For example:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// The namespace of a Maven package is its <code>groupId</code>.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// The namespace of an npm package is its <code>scope</code>.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// A Python package does not contain a corresponding component, so
        /// Python packages do not have a namespace.
        /// </p>
        /// </li>
        /// </ul>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace(input);
            self
        }
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace(input);
            self
        }
        /// <p>
        /// The name of the package with the versions to delete.
        /// </p>
        pub fn package(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.package(input);
            self
        }
        pub fn set_package(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_package(input);
            self
        }
        /// <p>
        /// An array of strings that specify the versions of the package to delete.
        /// </p>
        pub fn versions(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.versions(inp);
            self
        }
        pub fn set_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_versions(input);
            self
        }
        /// <p>
        /// The expected status of the package version to delete. Valid values are:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Published</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Unfinished</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Unlisted</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Archived</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Disposed</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn expected_status(mut self, input: crate::model::PackageVersionStatus) -> Self {
            self.inner = self.inner.expected_status(input);
            self
        }
        pub fn set_expected_status(
            mut self,
            input: std::option::Option<crate::model::PackageVersionStatus>,
        ) -> Self {
            self.inner = self.inner.set_expected_status(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRepository<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_repository_input::Builder,
    }
    impl<C> DeleteRepository<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteRepositoryOutput,
            smithy_http::result::SdkError<crate::error::DeleteRepositoryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the domain that contains the repository to delete.
        /// </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
        /// <p> The name of the repository to delete. </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository(input);
            self
        }
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_repository(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRepositoryPermissionsPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_repository_permissions_policy_input::Builder,
    }
    impl<C> DeleteRepositoryPermissionsPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteRepositoryPermissionsPolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteRepositoryPermissionsPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the domain that contains the repository associated with the resource policy to be deleted.
        /// </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
        /// <p>
        /// The name of the repository that is associated with the resource policy to be deleted
        /// </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository(input);
            self
        }
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_repository(input);
            self
        }
        /// <p>
        /// The revision of the repository's resource policy to be deleted. This revision is used for optimistic locking, which
        /// prevents others from accidentally overwriting your changes to the repository's resource policy.
        /// </p>
        pub fn policy_revision(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_revision(input);
            self
        }
        pub fn set_policy_revision(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_revision(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeDomain<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_domain_input::Builder,
    }
    impl<C> DescribeDomain<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeDomainOutput,
            smithy_http::result::SdkError<crate::error::DescribeDomainError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// A string that specifies the name of the requested domain.
        /// </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribePackageVersion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_package_version_input::Builder,
    }
    impl<C> DescribePackageVersion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribePackageVersionOutput,
            smithy_http::result::SdkError<crate::error::DescribePackageVersionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the domain that contains the repository that contains the package version.
        /// </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
        /// <p> The name of the repository that contains the package version. </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository(input);
            self
        }
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_repository(input);
            self
        }
        /// <p>
        /// A format that specifies the type of the requested package version. The valid values are:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>npm</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>pypi</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>maven</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn format(mut self, input: crate::model::PackageFormat) -> Self {
            self.inner = self.inner.format(input);
            self
        }
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::PackageFormat>,
        ) -> Self {
            self.inner = self.inner.set_format(input);
            self
        }
        /// <p>
        /// The namespace of the package. The package component that specifies its
        /// namespace depends on its type. For example:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// The namespace of a Maven package is its <code>groupId</code>.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// The namespace of an npm package is its <code>scope</code>.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// A Python package does not contain a corresponding component, so
        /// Python packages do not have a namespace.
        /// </p>
        /// </li>
        /// </ul>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace(input);
            self
        }
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace(input);
            self
        }
        /// <p> The name of the requested package version. </p>
        pub fn package(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.package(input);
            self
        }
        pub fn set_package(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_package(input);
            self
        }
        /// <p>
        /// A string that contains the package version (for example, <code>3.5.2</code>).
        /// </p>
        pub fn package_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.package_version(input);
            self
        }
        pub fn set_package_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_package_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeRepository<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_repository_input::Builder,
    }
    impl<C> DescribeRepository<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeRepositoryOutput,
            smithy_http::result::SdkError<crate::error::DescribeRepositoryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the domain that contains the repository to describe.
        /// </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
        /// <p>
        /// A string that specifies the name of the requested repository.
        /// </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository(input);
            self
        }
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_repository(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateExternalConnection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disassociate_external_connection_input::Builder,
    }
    impl<C> DisassociateExternalConnection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateExternalConnectionOutput,
            smithy_http::result::SdkError<crate::error::DisassociateExternalConnectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that contains the repository from which to remove the external
        /// repository. </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
        /// <p>The name of the repository from which the external connection will be removed. </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository(input);
            self
        }
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_repository(input);
            self
        }
        /// <p>The name of the external connection to be removed from the repository. </p>
        pub fn external_connection(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.external_connection(input);
            self
        }
        pub fn set_external_connection(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_external_connection(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisposePackageVersions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::dispose_package_versions_input::Builder,
    }
    impl<C> DisposePackageVersions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisposePackageVersionsOutput,
            smithy_http::result::SdkError<crate::error::DisposePackageVersionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the domain that contains the repository you want to dispose.
        /// </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
        /// <p>
        /// The name of the repository that contains the package versions you want to dispose.
        /// </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository(input);
            self
        }
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_repository(input);
            self
        }
        /// <p>
        /// A format that specifies the type of package versions you want to dispose. The valid values are:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>npm</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>pypi</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>maven</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn format(mut self, input: crate::model::PackageFormat) -> Self {
            self.inner = self.inner.format(input);
            self
        }
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::PackageFormat>,
        ) -> Self {
            self.inner = self.inner.set_format(input);
            self
        }
        /// <p>
        /// The namespace of the package. The package component that specifies its
        /// namespace depends on its type. For example:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// The namespace of a Maven package is its <code>groupId</code>.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// The namespace of an npm package is its <code>scope</code>.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// A Python package does not contain a corresponding component, so
        /// Python packages do not have a namespace.
        /// </p>
        /// </li>
        /// </ul>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace(input);
            self
        }
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace(input);
            self
        }
        /// <p>
        /// The name of the package with the versions you want to dispose.
        /// </p>
        pub fn package(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.package(input);
            self
        }
        pub fn set_package(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_package(input);
            self
        }
        /// <p>
        /// The versions of the package you want to dispose.
        /// </p>
        pub fn versions(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.versions(inp);
            self
        }
        pub fn set_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_versions(input);
            self
        }
        /// <p>
        /// The revisions of the package versions you want to dispose.
        /// </p>
        pub fn version_revisions(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.version_revisions(k, v);
            self
        }
        pub fn set_version_revisions(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_version_revisions(input);
            self
        }
        /// <p>
        /// The expected status of the package version to dispose. Valid values are:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Published</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Unfinished</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Unlisted</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Archived</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Disposed</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn expected_status(mut self, input: crate::model::PackageVersionStatus) -> Self {
            self.inner = self.inner.expected_status(input);
            self
        }
        pub fn set_expected_status(
            mut self,
            input: std::option::Option<crate::model::PackageVersionStatus>,
        ) -> Self {
            self.inner = self.inner.set_expected_status(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAuthorizationToken<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_authorization_token_input::Builder,
    }
    impl<C> GetAuthorizationToken<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetAuthorizationTokenOutput,
            smithy_http::result::SdkError<crate::error::GetAuthorizationTokenError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the domain that is in scope for the generated authorization token.
        /// </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
        /// <p>The time, in seconds, that the generated authorization token is valid. Valid values are
        /// <code>0</code> and any number between <code>900</code> (15 minutes) and <code>43200</code> (12 hours).
        /// A value of <code>0</code> will set the expiration of the authorization token to the same expiration of
        /// the user's role's temporary credentials.</p>
        pub fn duration_seconds(mut self, input: i64) -> Self {
            self.inner = self.inner.duration_seconds(input);
            self
        }
        pub fn set_duration_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_duration_seconds(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDomainPermissionsPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_domain_permissions_policy_input::Builder,
    }
    impl<C> GetDomainPermissionsPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDomainPermissionsPolicyOutput,
            smithy_http::result::SdkError<crate::error::GetDomainPermissionsPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the domain to which the resource policy is attached.
        /// </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPackageVersionAsset<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_package_version_asset_input::Builder,
    }
    impl<C> GetPackageVersionAsset<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPackageVersionAssetOutput,
            smithy_http::result::SdkError<crate::error::GetPackageVersionAssetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the domain that contains the repository that contains the package version with the requested asset.
        /// </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
        /// <p>
        /// The repository that contains the package version with the requested asset.
        /// </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository(input);
            self
        }
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_repository(input);
            self
        }
        /// <p>
        /// A format that specifies the type of the package version with the requested asset file. The valid values are:
        /// </p>    
        /// <ul>
        /// <li>
        /// <p>
        /// <code>npm</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>pypi</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>maven</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn format(mut self, input: crate::model::PackageFormat) -> Self {
            self.inner = self.inner.format(input);
            self
        }
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::PackageFormat>,
        ) -> Self {
            self.inner = self.inner.set_format(input);
            self
        }
        /// <p>
        /// The namespace of the package. The package component that specifies its
        /// namespace depends on its type. For example:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// The namespace of a Maven package is its <code>groupId</code>.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// The namespace of an npm package is its <code>scope</code>.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// A Python package does not contain a corresponding component, so
        /// Python packages do not have a namespace.
        /// </p>
        /// </li>
        /// </ul>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace(input);
            self
        }
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace(input);
            self
        }
        /// <p>
        /// The name of the package that contains the requested asset.
        /// </p>
        pub fn package(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.package(input);
            self
        }
        pub fn set_package(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_package(input);
            self
        }
        /// <p>
        /// A string that contains the package version (for example, <code>3.5.2</code>).
        /// </p>
        pub fn package_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.package_version(input);
            self
        }
        pub fn set_package_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_package_version(input);
            self
        }
        /// <p>
        /// The name of the requested asset.
        /// </p>
        pub fn asset(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.asset(input);
            self
        }
        pub fn set_asset(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_asset(input);
            self
        }
        /// <p>
        /// The name of the package version revision that contains the requested asset.
        /// </p>
        pub fn package_version_revision(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.package_version_revision(input);
            self
        }
        pub fn set_package_version_revision(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_package_version_revision(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPackageVersionReadme<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_package_version_readme_input::Builder,
    }
    impl<C> GetPackageVersionReadme<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPackageVersionReadmeOutput,
            smithy_http::result::SdkError<crate::error::GetPackageVersionReadmeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the domain that contains the repository that contains the package version with the requested readme file.
        /// </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
        /// <p>
        /// The repository that contains the package with the requested readme file.
        /// </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository(input);
            self
        }
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_repository(input);
            self
        }
        /// <p>
        /// A format that specifies the type of the package version with the requested readme file. The valid values are:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>npm</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>pypi</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>maven</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn format(mut self, input: crate::model::PackageFormat) -> Self {
            self.inner = self.inner.format(input);
            self
        }
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::PackageFormat>,
        ) -> Self {
            self.inner = self.inner.set_format(input);
            self
        }
        /// <p>
        /// The namespace of the package. The package component that specifies its
        /// namespace depends on its type. For example:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// The namespace of a Maven package is its <code>groupId</code>.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// The namespace of an npm package is its <code>scope</code>.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// A Python package does not contain a corresponding component, so
        /// Python packages do not have a namespace.
        /// </p>
        /// </li>
        /// </ul>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace(input);
            self
        }
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace(input);
            self
        }
        /// <p>
        /// The name of the package version that contains the requested readme file.
        /// </p>
        pub fn package(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.package(input);
            self
        }
        pub fn set_package(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_package(input);
            self
        }
        /// <p>
        /// A string that contains the package version (for example, <code>3.5.2</code>).
        /// </p>
        pub fn package_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.package_version(input);
            self
        }
        pub fn set_package_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_package_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRepositoryEndpoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_repository_endpoint_input::Builder,
    }
    impl<C> GetRepositoryEndpoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRepositoryEndpointOutput,
            smithy_http::result::SdkError<crate::error::GetRepositoryEndpointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the domain that contains the repository.
        /// </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain that contains the repository. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
        /// <p>
        /// The name of the repository.
        /// </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository(input);
            self
        }
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_repository(input);
            self
        }
        /// <p>
        /// Returns which endpoint of a repository to return. A repository has one endpoint for each
        /// package format:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>npm</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>pypi</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>maven</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn format(mut self, input: crate::model::PackageFormat) -> Self {
            self.inner = self.inner.format(input);
            self
        }
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::PackageFormat>,
        ) -> Self {
            self.inner = self.inner.set_format(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRepositoryPermissionsPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_repository_permissions_policy_input::Builder,
    }
    impl<C> GetRepositoryPermissionsPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRepositoryPermissionsPolicyOutput,
            smithy_http::result::SdkError<crate::error::GetRepositoryPermissionsPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the domain containing the repository whose associated resource policy is to be retrieved.
        /// </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
        /// <p>
        /// The name of the repository whose associated resource policy is to be retrieved.
        /// </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository(input);
            self
        }
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_repository(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDomains<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_domains_input::Builder,
    }
    impl<C> ListDomains<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDomainsOutput,
            smithy_http::result::SdkError<crate::error::ListDomainsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The maximum number of results to return per page.
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPackages<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_packages_input::Builder,
    }
    impl<C> ListPackages<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListPackagesOutput,
            smithy_http::result::SdkError<crate::error::ListPackagesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the domain that contains the repository that contains the requested list of packages.
        /// </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
        /// <p>
        /// The name of the repository from which packages are to be listed.
        /// </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository(input);
            self
        }
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_repository(input);
            self
        }
        /// <p>
        /// The format of the packages. The valid package types are:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>npm</code>: A Node Package Manager (npm) package.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>pypi</code>: A Python Package Index (PyPI) package.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>maven</code>: A Maven package that contains compiled code in a distributable format, such as a JAR file.
        /// </p>
        /// </li>
        /// </ul>
        pub fn format(mut self, input: crate::model::PackageFormat) -> Self {
            self.inner = self.inner.format(input);
            self
        }
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::PackageFormat>,
        ) -> Self {
            self.inner = self.inner.set_format(input);
            self
        }
        /// <p>
        /// The namespace of the package. The package component that specifies its
        /// namespace depends on its type. For example:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// The namespace of a Maven package is its <code>groupId</code>.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// The namespace of an npm package is its <code>scope</code>.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// A Python package does not contain a corresponding component, so
        /// Python packages do not have a namespace.
        /// </p>
        /// </li>
        /// </ul>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace(input);
            self
        }
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace(input);
            self
        }
        /// <p>
        /// A prefix used to filter returned packages. Only packages with names that start with
        /// <code>packagePrefix</code> are returned.
        /// </p>
        pub fn package_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.package_prefix(input);
            self
        }
        pub fn set_package_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_package_prefix(input);
            self
        }
        /// <p>
        /// The maximum number of results to return per page.
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPackageVersionAssets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_package_version_assets_input::Builder,
    }
    impl<C> ListPackageVersionAssets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListPackageVersionAssetsOutput,
            smithy_http::result::SdkError<crate::error::ListPackageVersionAssetsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the domain that contains the repository associated with the package version assets.
        /// </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
        /// <p>
        /// The name of the repository that contains the package that contains the returned package version assets.
        /// </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository(input);
            self
        }
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_repository(input);
            self
        }
        /// <p>
        /// The format of the package that contains the returned package version assets. The valid package types are:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>npm</code>: A Node Package Manager (npm) package.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>pypi</code>: A Python Package Index (PyPI) package.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>maven</code>: A Maven package that contains compiled code in a distributable format, such as a JAR file.
        /// </p>
        /// </li>
        /// </ul>
        pub fn format(mut self, input: crate::model::PackageFormat) -> Self {
            self.inner = self.inner.format(input);
            self
        }
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::PackageFormat>,
        ) -> Self {
            self.inner = self.inner.set_format(input);
            self
        }
        /// <p>
        /// The namespace of the package. The package component that specifies its
        /// namespace depends on its type. For example:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// The namespace of a Maven package is its <code>groupId</code>.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// The namespace of an npm package is its <code>scope</code>.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// A Python package does not contain a corresponding component, so
        /// Python packages do not have a namespace.
        /// </p>
        /// </li>
        /// </ul>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace(input);
            self
        }
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace(input);
            self
        }
        /// <p>
        /// The name of the package that contains the returned package version assets.
        /// </p>
        pub fn package(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.package(input);
            self
        }
        pub fn set_package(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_package(input);
            self
        }
        /// <p>
        /// A string that contains the package version (for example, <code>3.5.2</code>).
        /// </p>
        pub fn package_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.package_version(input);
            self
        }
        pub fn set_package_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_package_version(input);
            self
        }
        /// <p>
        /// The maximum number of results to return per page.
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPackageVersionDependencies<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_package_version_dependencies_input::Builder,
    }
    impl<C> ListPackageVersionDependencies<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListPackageVersionDependenciesOutput,
            smithy_http::result::SdkError<crate::error::ListPackageVersionDependenciesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the domain that contains the repository that contains the requested package version dependencies.
        /// </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
        /// <p>
        /// The name of the repository that contains the requested package version.
        /// </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository(input);
            self
        }
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_repository(input);
            self
        }
        /// <p>
        /// The format of the package with the requested dependencies. The valid package types are:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>npm</code>: A Node Package Manager (npm) package.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>pypi</code>: A Python Package Index (PyPI) package.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>maven</code>: A Maven package that contains compiled code in a distributable format, such as a JAR file.
        /// </p>
        /// </li>
        /// </ul>
        pub fn format(mut self, input: crate::model::PackageFormat) -> Self {
            self.inner = self.inner.format(input);
            self
        }
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::PackageFormat>,
        ) -> Self {
            self.inner = self.inner.set_format(input);
            self
        }
        /// <p>
        /// The namespace of the package. The package component that specifies its
        /// namespace depends on its type. For example:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// The namespace of a Maven package is its <code>groupId</code>.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// The namespace of an npm package is its <code>scope</code>.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// A Python package does not contain a corresponding component, so
        /// Python packages do not have a namespace.
        /// </p>
        /// </li>
        /// </ul>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace(input);
            self
        }
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace(input);
            self
        }
        /// <p>
        /// The name of the package versions' package.
        /// </p>
        pub fn package(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.package(input);
            self
        }
        pub fn set_package(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_package(input);
            self
        }
        /// <p>
        /// A string that contains the package version (for example, <code>3.5.2</code>).
        /// </p>
        pub fn package_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.package_version(input);
            self
        }
        pub fn set_package_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_package_version(input);
            self
        }
        /// <p>
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPackageVersions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_package_versions_input::Builder,
    }
    impl<C> ListPackageVersions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListPackageVersionsOutput,
            smithy_http::result::SdkError<crate::error::ListPackageVersionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the domain that contains the repository that contains the returned package versions.
        /// </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
        /// <p>
        /// The name of the repository that contains the package.
        /// </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository(input);
            self
        }
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_repository(input);
            self
        }
        /// <p>
        /// The format of the returned packages. The valid package types are:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>npm</code>: A Node Package Manager (npm) package.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>pypi</code>: A Python Package Index (PyPI) package.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>maven</code>: A Maven package that contains compiled code in a distributable format, such as a JAR file.
        /// </p>
        /// </li>
        /// </ul>
        pub fn format(mut self, input: crate::model::PackageFormat) -> Self {
            self.inner = self.inner.format(input);
            self
        }
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::PackageFormat>,
        ) -> Self {
            self.inner = self.inner.set_format(input);
            self
        }
        /// <p>
        /// The namespace of the package. The package component that specifies its
        /// namespace depends on its type. For example:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// The namespace of a Maven package is its <code>groupId</code>.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// The namespace of an npm package is its <code>scope</code>.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// A Python package does not contain a corresponding component, so
        /// Python packages do not have a namespace.
        /// </p>
        /// </li>
        /// </ul>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace(input);
            self
        }
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace(input);
            self
        }
        /// <p>
        /// The name of the package for which you want to return a list of package versions.
        /// </p>
        pub fn package(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.package(input);
            self
        }
        pub fn set_package(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_package(input);
            self
        }
        /// <p>
        /// A string that specifies the status of the package versions to include in the returned list. It can be one of the following:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Published</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Unfinished</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Unlisted</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Archived</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Disposed</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::PackageVersionStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::PackageVersionStatus>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
        /// <p>
        /// How to sort the returned list of package versions.
        /// </p>
        pub fn sort_by(mut self, input: crate::model::PackageVersionSortType) -> Self {
            self.inner = self.inner.sort_by(input);
            self
        }
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<crate::model::PackageVersionSortType>,
        ) -> Self {
            self.inner = self.inner.set_sort_by(input);
            self
        }
        /// <p>
        /// The maximum number of results to return per page.
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListRepositories<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_repositories_input::Builder,
    }
    impl<C> ListRepositories<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListRepositoriesOutput,
            smithy_http::result::SdkError<crate::error::ListRepositoriesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> A prefix used to filter returned repositories. Only repositories with names that start
        /// with <code>repositoryPrefix</code> are returned.</p>
        pub fn repository_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_prefix(input);
            self
        }
        pub fn set_repository_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_prefix(input);
            self
        }
        /// <p>
        /// The maximum number of results to return per page.
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListRepositoriesInDomain<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_repositories_in_domain_input::Builder,
    }
    impl<C> ListRepositoriesInDomain<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListRepositoriesInDomainOutput,
            smithy_http::result::SdkError<crate::error::ListRepositoriesInDomainError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the domain that contains the returned list of repositories.
        /// </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
        /// <p>
        /// Filter the list of repositories to only include those that are managed by the AWS account ID.
        /// </p>
        pub fn administrator_account(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.administrator_account(input);
            self
        }
        pub fn set_administrator_account(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_administrator_account(input);
            self
        }
        /// <p>
        /// A prefix used to filter returned repositories. Only repositories with names that start with
        /// <code>repositoryPrefix</code> are returned.
        /// </p>
        pub fn repository_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_prefix(input);
            self
        }
        pub fn set_repository_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_prefix(input);
            self
        }
        /// <p>
        /// The maximum number of results to return per page.
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource to get tags for.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutDomainPermissionsPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_domain_permissions_policy_input::Builder,
    }
    impl<C> PutDomainPermissionsPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutDomainPermissionsPolicyOutput,
            smithy_http::result::SdkError<crate::error::PutDomainPermissionsPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the domain on which to set the resource policy.
        /// </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
        /// <p>
        /// The current revision of the resource policy to be set. This revision is used for optimistic locking, which
        /// prevents others from overwriting your changes to the domain's resource policy.
        /// </p>
        pub fn policy_revision(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_revision(input);
            self
        }
        pub fn set_policy_revision(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_revision(input);
            self
        }
        /// <p> A valid displayable JSON Aspen policy string to be set as the access control resource
        /// policy on the provided domain. </p>
        pub fn policy_document(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_document(input);
            self
        }
        pub fn set_policy_document(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_document(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutRepositoryPermissionsPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_repository_permissions_policy_input::Builder,
    }
    impl<C> PutRepositoryPermissionsPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutRepositoryPermissionsPolicyOutput,
            smithy_http::result::SdkError<crate::error::PutRepositoryPermissionsPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the domain containing the repository to set the resource policy on.
        /// </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
        /// <p> The name of the repository to set the resource policy on. </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository(input);
            self
        }
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_repository(input);
            self
        }
        /// <p>
        /// Sets the revision of the resource policy that specifies permissions to access the repository.
        /// This revision is used for optimistic locking, which prevents others from overwriting your
        /// changes to the repository's resource policy.
        /// </p>
        pub fn policy_revision(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_revision(input);
            self
        }
        pub fn set_policy_revision(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_revision(input);
            self
        }
        /// <p> A valid displayable JSON Aspen policy string to be set as the access control resource
        /// policy on the provided repository. </p>
        pub fn policy_document(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_document(input);
            self
        }
        pub fn set_policy_document(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_document(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource that you want to add or update tags for.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The tags you want to modify or add to the resource.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource that you want to remove tags from.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The tag key for each tag that you want to remove from the resource.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdatePackageVersionsStatus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_package_versions_status_input::Builder,
    }
    impl<C> UpdatePackageVersionsStatus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdatePackageVersionsStatusOutput,
            smithy_http::result::SdkError<crate::error::UpdatePackageVersionsStatusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the domain that contains the repository that contains the package versions with a status to be updated.
        /// </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
        /// <p>
        /// The repository that contains the package versions with the status you want to update.
        /// </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository(input);
            self
        }
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_repository(input);
            self
        }
        /// <p>
        /// A format that specifies the type of the package with the statuses to update. The valid values are:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>npm</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>pypi</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>maven</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn format(mut self, input: crate::model::PackageFormat) -> Self {
            self.inner = self.inner.format(input);
            self
        }
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::PackageFormat>,
        ) -> Self {
            self.inner = self.inner.set_format(input);
            self
        }
        /// <p>
        /// The namespace of the package. The package component that specifies its
        /// namespace depends on its type. For example:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// The namespace of a Maven package is its <code>groupId</code>.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// The namespace of an npm package is its <code>scope</code>.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// A Python package does not contain a corresponding component, so
        /// Python packages do not have a namespace.
        /// </p>
        /// </li>
        /// </ul>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace(input);
            self
        }
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace(input);
            self
        }
        /// <p>
        /// The name of the package with the version statuses to update.
        /// </p>
        pub fn package(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.package(input);
            self
        }
        pub fn set_package(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_package(input);
            self
        }
        /// <p>
        /// An array of strings that specify the versions of the package with the statuses to update.
        /// </p>
        pub fn versions(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.versions(inp);
            self
        }
        pub fn set_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_versions(input);
            self
        }
        /// <p> A map of package versions and package version revisions. The map <code>key</code> is the
        /// package version (for example, <code>3.5.2</code>), and the map <code>value</code> is the
        /// package version revision. </p>
        pub fn version_revisions(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.version_revisions(k, v);
            self
        }
        pub fn set_version_revisions(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_version_revisions(input);
            self
        }
        /// <p> The package versions expected status before it is updated. If
        /// <code>expectedStatus</code> is provided, the package version's status is updated only if its
        /// status at the time <code>UpdatePackageVersionsStatus</code> is called matches
        /// <code>expectedStatus</code>. </p>
        pub fn expected_status(mut self, input: crate::model::PackageVersionStatus) -> Self {
            self.inner = self.inner.expected_status(input);
            self
        }
        pub fn set_expected_status(
            mut self,
            input: std::option::Option<crate::model::PackageVersionStatus>,
        ) -> Self {
            self.inner = self.inner.set_expected_status(input);
            self
        }
        /// <p>
        /// The status you want to change the package version status to.
        /// </p>
        pub fn target_status(mut self, input: crate::model::PackageVersionStatus) -> Self {
            self.inner = self.inner.target_status(input);
            self
        }
        pub fn set_target_status(
            mut self,
            input: std::option::Option<crate::model::PackageVersionStatus>,
        ) -> Self {
            self.inner = self.inner.set_target_status(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateRepository<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_repository_input::Builder,
    }
    impl<C> UpdateRepository<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateRepositoryOutput,
            smithy_http::result::SdkError<crate::error::UpdateRepositoryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the domain associated with the repository to update.
        /// </p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>
        /// The 12-digit account number of the AWS account that owns the domain. It does not include
        /// dashes or spaces.
        /// </p>
        pub fn domain_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_owner(input);
            self
        }
        pub fn set_domain_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_owner(input);
            self
        }
        /// <p>
        /// The name of the repository to update.
        /// </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository(input);
            self
        }
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_repository(input);
            self
        }
        /// <p>
        /// An updated repository description.
        /// </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p> A list of upstream repositories to associate with the repository. The order of the upstream repositories
        /// in the list determines their priority order when AWS CodeArtifact looks for a requested package version. For more
        /// information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html">Working with upstream repositories</a>. </p>
        pub fn upstreams(mut self, inp: impl Into<crate::model::UpstreamRepository>) -> Self {
            self.inner = self.inner.upstreams(inp);
            self
        }
        pub fn set_upstreams(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UpstreamRepository>>,
        ) -> Self {
            self.inner = self.inner.set_upstreams(input);
            self
        }
    }
}
