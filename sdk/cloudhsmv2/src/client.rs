// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn copy_backup_to_region(&self) -> fluent_builders::CopyBackupToRegion<C> {
        fluent_builders::CopyBackupToRegion::new(self.handle.clone())
    }
    pub fn create_cluster(&self) -> fluent_builders::CreateCluster<C> {
        fluent_builders::CreateCluster::new(self.handle.clone())
    }
    pub fn create_hsm(&self) -> fluent_builders::CreateHsm<C> {
        fluent_builders::CreateHsm::new(self.handle.clone())
    }
    pub fn delete_backup(&self) -> fluent_builders::DeleteBackup<C> {
        fluent_builders::DeleteBackup::new(self.handle.clone())
    }
    pub fn delete_cluster(&self) -> fluent_builders::DeleteCluster<C> {
        fluent_builders::DeleteCluster::new(self.handle.clone())
    }
    pub fn delete_hsm(&self) -> fluent_builders::DeleteHsm<C> {
        fluent_builders::DeleteHsm::new(self.handle.clone())
    }
    pub fn describe_backups(&self) -> fluent_builders::DescribeBackups<C> {
        fluent_builders::DescribeBackups::new(self.handle.clone())
    }
    pub fn describe_clusters(&self) -> fluent_builders::DescribeClusters<C> {
        fluent_builders::DescribeClusters::new(self.handle.clone())
    }
    pub fn initialize_cluster(&self) -> fluent_builders::InitializeCluster<C> {
        fluent_builders::InitializeCluster::new(self.handle.clone())
    }
    pub fn list_tags(&self) -> fluent_builders::ListTags<C> {
        fluent_builders::ListTags::new(self.handle.clone())
    }
    pub fn modify_backup_attributes(&self) -> fluent_builders::ModifyBackupAttributes<C> {
        fluent_builders::ModifyBackupAttributes::new(self.handle.clone())
    }
    pub fn modify_cluster(&self) -> fluent_builders::ModifyCluster<C> {
        fluent_builders::ModifyCluster::new(self.handle.clone())
    }
    pub fn restore_backup(&self) -> fluent_builders::RestoreBackup<C> {
        fluent_builders::RestoreBackup::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CopyBackupToRegion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::copy_backup_to_region_input::Builder,
    }
    impl<C> CopyBackupToRegion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CopyBackupToRegionOutput,
            smithy_http::result::SdkError<crate::error::CopyBackupToRegionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The AWS region that will contain your copied CloudHSM cluster backup.</p>
        pub fn destination_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_region(input);
            self
        }
        pub fn set_destination_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_region(input);
            self
        }
        /// <p>The ID of the backup that will be copied to the destination region. </p>
        pub fn backup_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_id(input);
            self
        }
        pub fn set_backup_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_backup_id(input);
            self
        }
        /// <p>Tags to apply to the destination backup during creation. If you specify tags, only these tags will be applied to the destination backup. If you do not specify tags, the service copies tags from the source backup to the destination backup.</p>
        pub fn tag_list(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tag_list(inp);
            self
        }
        pub fn set_tag_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tag_list(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateCluster<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_cluster_input::Builder,
    }
    impl<C> CreateCluster<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateClusterOutput,
            smithy_http::result::SdkError<crate::error::CreateClusterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A policy that defines how the service retains backups.</p>
        pub fn backup_retention_policy(
            mut self,
            input: crate::model::BackupRetentionPolicy,
        ) -> Self {
            self.inner = self.inner.backup_retention_policy(input);
            self
        }
        pub fn set_backup_retention_policy(
            mut self,
            input: std::option::Option<crate::model::BackupRetentionPolicy>,
        ) -> Self {
            self.inner = self.inner.set_backup_retention_policy(input);
            self
        }
        /// <p>The type of HSM to use in the cluster. Currently the only allowed value is
        /// <code>hsm1.medium</code>.</p>
        pub fn hsm_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hsm_type(input);
            self
        }
        pub fn set_hsm_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_hsm_type(input);
            self
        }
        /// <p>The identifier (ID) of the cluster backup to restore. Use this value to restore the
        /// cluster from a backup instead of creating a new cluster. To find the backup ID, use <a>DescribeBackups</a>.</p>
        pub fn source_backup_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_backup_id(input);
            self
        }
        pub fn set_source_backup_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_backup_id(input);
            self
        }
        /// <p>The identifiers (IDs) of the subnets where you are creating the cluster. You must
        /// specify at least one subnet. If you specify multiple subnets, they must meet the following
        /// criteria:</p>
        /// <ul>
        /// <li>
        /// <p>All subnets must be in the same virtual private cloud (VPC).</p>
        /// </li>
        /// <li>
        /// <p>You can specify only one subnet per Availability Zone.</p>
        /// </li>
        /// </ul>
        pub fn subnet_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_ids(inp);
            self
        }
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subnet_ids(input);
            self
        }
        /// <p>Tags to apply to the CloudHSM cluster during creation.</p>
        pub fn tag_list(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tag_list(inp);
            self
        }
        pub fn set_tag_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tag_list(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateHsm<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_hsm_input::Builder,
    }
    impl<C> CreateHsm<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateHsmOutput,
            smithy_http::result::SdkError<crate::error::CreateHsmError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier (ID) of the HSM's cluster. To find the cluster ID, use <a>DescribeClusters</a>.</p>
        pub fn cluster_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_id(input);
            self
        }
        pub fn set_cluster_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_id(input);
            self
        }
        /// <p>The Availability Zone where you are creating the HSM. To find the cluster's
        /// Availability Zones, use <a>DescribeClusters</a>.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zone(input);
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_availability_zone(input);
            self
        }
        /// <p>The HSM's IP address. If you specify an IP address, use an available address from the
        /// subnet that maps to the Availability Zone where you are creating the HSM. If you don't specify
        /// an IP address, one is chosen for you from that subnet.</p>
        pub fn ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ip_address(input);
            self
        }
        pub fn set_ip_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ip_address(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBackup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_backup_input::Builder,
    }
    impl<C> DeleteBackup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteBackupOutput,
            smithy_http::result::SdkError<crate::error::DeleteBackupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the backup to be deleted. To find the ID of a backup, use the <a>DescribeBackups</a> operation.</p>
        pub fn backup_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_id(input);
            self
        }
        pub fn set_backup_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_backup_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteCluster<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_cluster_input::Builder,
    }
    impl<C> DeleteCluster<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteClusterOutput,
            smithy_http::result::SdkError<crate::error::DeleteClusterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier (ID) of the cluster that you are deleting. To find the cluster ID, use
        /// <a>DescribeClusters</a>.</p>
        pub fn cluster_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_id(input);
            self
        }
        pub fn set_cluster_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteHsm<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_hsm_input::Builder,
    }
    impl<C> DeleteHsm<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteHsmOutput,
            smithy_http::result::SdkError<crate::error::DeleteHsmError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier (ID) of the cluster that contains the HSM that you are
        /// deleting.</p>
        pub fn cluster_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_id(input);
            self
        }
        pub fn set_cluster_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_id(input);
            self
        }
        /// <p>The identifier (ID) of the HSM that you are deleting.</p>
        pub fn hsm_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hsm_id(input);
            self
        }
        pub fn set_hsm_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_hsm_id(input);
            self
        }
        /// <p>The identifier (ID) of the elastic network interface (ENI) of the HSM that you are
        /// deleting.</p>
        pub fn eni_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.eni_id(input);
            self
        }
        pub fn set_eni_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_eni_id(input);
            self
        }
        /// <p>The IP address of the elastic network interface (ENI) of the HSM that you are
        /// deleting.</p>
        pub fn eni_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.eni_ip(input);
            self
        }
        pub fn set_eni_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_eni_ip(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeBackups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_backups_input::Builder,
    }
    impl<C> DescribeBackups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeBackupsOutput,
            smithy_http::result::SdkError<crate::error::DescribeBackupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The <code>NextToken</code> value that you received in the previous response. Use this
        /// value to get more backups.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of backups to return in the response. When there are more backups
        /// than the number you specify, the response contains a <code>NextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>One or more filters to limit the items returned in the response.</p>
        /// <p>Use the <code>backupIds</code> filter to return only the specified backups. Specify
        /// backups by their backup identifier (ID).</p>
        /// <p>Use the <code>sourceBackupIds</code> filter to return only the backups created from a
        /// source backup. The <code>sourceBackupID</code> of a source backup is returned by the <a>CopyBackupToRegion</a> operation.</p>
        /// <p>Use the <code>clusterIds</code> filter to return only the backups for the specified
        /// clusters. Specify clusters by their cluster identifier (ID).</p>
        /// <p>Use the <code>states</code> filter to return only backups that match the specified
        /// state.</p>
        /// <p>Use the <code>neverExpires</code> filter to return backups filtered by the value in the
        /// <code>neverExpires</code> parameter. <code>True</code> returns all backups exempt from the
        /// backup retention policy. <code>False</code> returns all backups with a backup retention policy
        /// defined at the cluster.</p>
        pub fn filters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.filters(k, v);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Designates whether or not to sort the return backups by ascending chronological order
        /// of generation.</p>
        pub fn sort_ascending(mut self, input: bool) -> Self {
            self.inner = self.inner.sort_ascending(input);
            self
        }
        pub fn set_sort_ascending(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_sort_ascending(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeClusters<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_clusters_input::Builder,
    }
    impl<C> DescribeClusters<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeClustersOutput,
            smithy_http::result::SdkError<crate::error::DescribeClustersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more filters to limit the items returned in the response.</p>
        /// <p>Use the <code>clusterIds</code> filter to return only the specified clusters. Specify
        /// clusters by their cluster identifier (ID).</p>
        /// <p>Use the <code>vpcIds</code> filter to return only the clusters in the specified virtual
        /// private clouds (VPCs). Specify VPCs by their VPC identifier (ID).</p>
        /// <p>Use the <code>states</code> filter to return only clusters that match the specified
        /// state.</p>
        pub fn filters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.filters(k, v);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The <code>NextToken</code> value that you received in the previous response. Use this
        /// value to get more clusters.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of clusters to return in the response. When there are more clusters
        /// than the number you specify, the response contains a <code>NextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct InitializeCluster<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::initialize_cluster_input::Builder,
    }
    impl<C> InitializeCluster<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::InitializeClusterOutput,
            smithy_http::result::SdkError<crate::error::InitializeClusterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier (ID) of the cluster that you are claiming. To find the cluster ID, use
        /// <a>DescribeClusters</a>.</p>
        pub fn cluster_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_id(input);
            self
        }
        pub fn set_cluster_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_id(input);
            self
        }
        /// <p>The cluster certificate issued (signed) by your issuing certificate authority (CA). The
        /// certificate must be in PEM format and can contain a maximum of 5000 characters.</p>
        pub fn signed_cert(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.signed_cert(input);
            self
        }
        pub fn set_signed_cert(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_signed_cert(input);
            self
        }
        /// <p>The issuing certificate of the issuing certificate authority (CA) that issued (signed)
        /// the cluster certificate. You must use a self-signed certificate. The certificate used to sign the HSM CSR must be directly available, and thus must be the
        /// root certificate. The certificate must be in PEM format and can contain a
        /// maximum of 5000 characters.</p>
        pub fn trust_anchor(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.trust_anchor(input);
            self
        }
        pub fn set_trust_anchor(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_trust_anchor(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTags<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_input::Builder,
    }
    impl<C> ListTags<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsOutput,
            smithy_http::result::SdkError<crate::error::ListTagsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The cluster identifier (ID) for the cluster whose tags you are getting. To find the
        /// cluster ID, use <a>DescribeClusters</a>.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(input);
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(input);
            self
        }
        /// <p>The <code>NextToken</code> value that you received in the previous response. Use this
        /// value to get more tags.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of tags to return in the response. When there are more tags than the
        /// number you specify, the response contains a <code>NextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyBackupAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_backup_attributes_input::Builder,
    }
    impl<C> ModifyBackupAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyBackupAttributesOutput,
            smithy_http::result::SdkError<crate::error::ModifyBackupAttributesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier (ID) of the backup to modify. To find the ID of a backup, use the <a>DescribeBackups</a> operation.</p>
        pub fn backup_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_id(input);
            self
        }
        pub fn set_backup_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_backup_id(input);
            self
        }
        /// <p>Specifies whether the service should exempt a backup from the retention policy for the cluster. <code>True</code> exempts
        /// a backup from the retention policy. <code>False</code> means the service applies the backup retention policy defined at the cluster.</p>
        pub fn never_expires(mut self, input: bool) -> Self {
            self.inner = self.inner.never_expires(input);
            self
        }
        pub fn set_never_expires(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_never_expires(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyCluster<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_cluster_input::Builder,
    }
    impl<C> ModifyCluster<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyClusterOutput,
            smithy_http::result::SdkError<crate::error::ModifyClusterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A policy that defines how the service retains backups.</p>
        pub fn backup_retention_policy(
            mut self,
            input: crate::model::BackupRetentionPolicy,
        ) -> Self {
            self.inner = self.inner.backup_retention_policy(input);
            self
        }
        pub fn set_backup_retention_policy(
            mut self,
            input: std::option::Option<crate::model::BackupRetentionPolicy>,
        ) -> Self {
            self.inner = self.inner.set_backup_retention_policy(input);
            self
        }
        /// <p>The identifier (ID) of the cluster that you want to modify. To find the cluster ID, use
        /// <a>DescribeClusters</a>.</p>
        pub fn cluster_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_id(input);
            self
        }
        pub fn set_cluster_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RestoreBackup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::restore_backup_input::Builder,
    }
    impl<C> RestoreBackup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RestoreBackupOutput,
            smithy_http::result::SdkError<crate::error::RestoreBackupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the backup to be restored. To find the ID of a backup, use the <a>DescribeBackups</a> operation.</p>
        pub fn backup_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_id(input);
            self
        }
        pub fn set_backup_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_backup_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The cluster identifier (ID) for the cluster that you are tagging. To find the cluster
        /// ID, use <a>DescribeClusters</a>.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(input);
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(input);
            self
        }
        /// <p>A list of one or more tags.</p>
        pub fn tag_list(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tag_list(inp);
            self
        }
        pub fn set_tag_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tag_list(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The cluster identifier (ID) for the cluster whose tags you are removing. To find the
        /// cluster ID, use <a>DescribeClusters</a>.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(input);
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(input);
            self
        }
        /// <p>A list of one or more tag keys for the tags that you are removing. Specify only the tag
        /// keys, not the tag values.</p>
        pub fn tag_key_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_key_list(inp);
            self
        }
        pub fn set_tag_key_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_key_list(input);
            self
        }
    }
}
