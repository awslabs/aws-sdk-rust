// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Information about the source of the data included in the resource data sync.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceDataSyncSource {
    /// <p>The type of data source for the resource data sync. <code>SourceType</code> is either
    /// <code>AwsOrganizations</code> (if an organization is present in AWS Organizations) or
    /// <code>SingleAccountMultiRegions</code>.</p>
    #[serde(rename = "SourceType")]
    #[serde(default)]
    pub source_type: std::option::Option<std::string::String>,
    /// <p>Information about the AwsOrganizationsSource resource data sync source. A sync source of
    /// this type can synchronize data from AWS Organizations.</p>
    #[serde(rename = "AwsOrganizationsSource")]
    #[serde(default)]
    pub aws_organizations_source:
        std::option::Option<crate::model::ResourceDataSyncAwsOrganizationsSource>,
    /// <p>The <code>SyncSource</code> AWS Regions included in the resource data sync.</p>
    #[serde(rename = "SourceRegions")]
    #[serde(default)]
    pub source_regions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Whether to automatically synchronize and aggregate data from new AWS Regions when those
    /// Regions come online.</p>
    #[serde(rename = "IncludeFutureRegions")]
    #[serde(default)]
    pub include_future_regions: bool,
    /// <p>When you create a resource data sync, if you choose one of the AWS Organizations options, then Systems Manager
    /// automatically enables all OpsData sources in the selected AWS Regions for all AWS accounts in
    /// your organization (or in the selected organization units). For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/Explorer-resouce-data-sync-multiple-accounts-and-regions.html">About multiple account and Region resource data syncs</a> in the
    /// <i>AWS Systems Manager User Guide</i>.</p>
    #[serde(rename = "EnableAllOpsDataSources")]
    #[serde(default)]
    pub enable_all_ops_data_sources: bool,
}
impl std::fmt::Debug for ResourceDataSyncSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceDataSyncSource");
        formatter.field("source_type", &self.source_type);
        formatter.field("aws_organizations_source", &self.aws_organizations_source);
        formatter.field("source_regions", &self.source_regions);
        formatter.field("include_future_regions", &self.include_future_regions);
        formatter.field(
            "enable_all_ops_data_sources",
            &self.enable_all_ops_data_sources,
        );
        formatter.finish()
    }
}
/// See [`ResourceDataSyncSource`](crate::model::ResourceDataSyncSource)
pub mod resource_data_sync_source {
    /// A builder for [`ResourceDataSyncSource`](crate::model::ResourceDataSyncSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_type: std::option::Option<std::string::String>,
        pub(crate) aws_organizations_source:
            std::option::Option<crate::model::ResourceDataSyncAwsOrganizationsSource>,
        pub(crate) source_regions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) include_future_regions: std::option::Option<bool>,
        pub(crate) enable_all_ops_data_sources: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The type of data source for the resource data sync. <code>SourceType</code> is either
        /// <code>AwsOrganizations</code> (if an organization is present in AWS Organizations) or
        /// <code>SingleAccountMultiRegions</code>.</p>
        pub fn source_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_type = Some(input.into());
            self
        }
        pub fn set_source_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_type = input;
            self
        }
        /// <p>Information about the AwsOrganizationsSource resource data sync source. A sync source of
        /// this type can synchronize data from AWS Organizations.</p>
        pub fn aws_organizations_source(
            mut self,
            input: crate::model::ResourceDataSyncAwsOrganizationsSource,
        ) -> Self {
            self.aws_organizations_source = Some(input);
            self
        }
        pub fn set_aws_organizations_source(
            mut self,
            input: std::option::Option<crate::model::ResourceDataSyncAwsOrganizationsSource>,
        ) -> Self {
            self.aws_organizations_source = input;
            self
        }
        pub fn source_regions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.source_regions.unwrap_or_default();
            v.push(input.into());
            self.source_regions = Some(v);
            self
        }
        pub fn set_source_regions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.source_regions = input;
            self
        }
        /// <p>Whether to automatically synchronize and aggregate data from new AWS Regions when those
        /// Regions come online.</p>
        pub fn include_future_regions(mut self, input: bool) -> Self {
            self.include_future_regions = Some(input);
            self
        }
        pub fn set_include_future_regions(mut self, input: std::option::Option<bool>) -> Self {
            self.include_future_regions = input;
            self
        }
        /// <p>When you create a resource data sync, if you choose one of the AWS Organizations options, then Systems Manager
        /// automatically enables all OpsData sources in the selected AWS Regions for all AWS accounts in
        /// your organization (or in the selected organization units). For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/Explorer-resouce-data-sync-multiple-accounts-and-regions.html">About multiple account and Region resource data syncs</a> in the
        /// <i>AWS Systems Manager User Guide</i>.</p>
        pub fn enable_all_ops_data_sources(mut self, input: bool) -> Self {
            self.enable_all_ops_data_sources = Some(input);
            self
        }
        pub fn set_enable_all_ops_data_sources(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_all_ops_data_sources = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceDataSyncSource`](crate::model::ResourceDataSyncSource)
        pub fn build(self) -> crate::model::ResourceDataSyncSource {
            crate::model::ResourceDataSyncSource {
                source_type: self.source_type,
                aws_organizations_source: self.aws_organizations_source,
                source_regions: self.source_regions,
                include_future_regions: self.include_future_regions.unwrap_or_default(),
                enable_all_ops_data_sources: self.enable_all_ops_data_sources.unwrap_or_default(),
            }
        }
    }
}
impl ResourceDataSyncSource {
    /// Creates a new builder-style object to manufacture [`ResourceDataSyncSource`](crate::model::ResourceDataSyncSource)
    pub fn builder() -> crate::model::resource_data_sync_source::Builder {
        crate::model::resource_data_sync_source::Builder::default()
    }
}

/// <p>Information about the AwsOrganizationsSource resource data sync source. A sync source of
/// this type can synchronize data from AWS Organizations or, if an AWS Organization is not present, from
/// multiple AWS Regions.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceDataSyncAwsOrganizationsSource {
    /// <p>If an AWS Organization is present, this is either <code>OrganizationalUnits</code> or
    /// <code>EntireOrganization</code>. For <code>OrganizationalUnits</code>, the data is aggregated
    /// from a set of organization units. For <code>EntireOrganization</code>, the data is aggregated
    /// from the entire AWS Organization. </p>
    #[serde(rename = "OrganizationSourceType")]
    #[serde(default)]
    pub organization_source_type: std::option::Option<std::string::String>,
    /// <p>The AWS Organizations organization units included in the sync.</p>
    #[serde(rename = "OrganizationalUnits")]
    #[serde(default)]
    pub organizational_units:
        std::option::Option<std::vec::Vec<crate::model::ResourceDataSyncOrganizationalUnit>>,
}
impl std::fmt::Debug for ResourceDataSyncAwsOrganizationsSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceDataSyncAwsOrganizationsSource");
        formatter.field("organization_source_type", &self.organization_source_type);
        formatter.field("organizational_units", &self.organizational_units);
        formatter.finish()
    }
}
/// See [`ResourceDataSyncAwsOrganizationsSource`](crate::model::ResourceDataSyncAwsOrganizationsSource)
pub mod resource_data_sync_aws_organizations_source {
    /// A builder for [`ResourceDataSyncAwsOrganizationsSource`](crate::model::ResourceDataSyncAwsOrganizationsSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) organization_source_type: std::option::Option<std::string::String>,
        pub(crate) organizational_units:
            std::option::Option<std::vec::Vec<crate::model::ResourceDataSyncOrganizationalUnit>>,
    }
    impl Builder {
        /// <p>If an AWS Organization is present, this is either <code>OrganizationalUnits</code> or
        /// <code>EntireOrganization</code>. For <code>OrganizationalUnits</code>, the data is aggregated
        /// from a set of organization units. For <code>EntireOrganization</code>, the data is aggregated
        /// from the entire AWS Organization. </p>
        pub fn organization_source_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.organization_source_type = Some(input.into());
            self
        }
        pub fn set_organization_source_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.organization_source_type = input;
            self
        }
        pub fn organizational_units(
            mut self,
            input: impl Into<crate::model::ResourceDataSyncOrganizationalUnit>,
        ) -> Self {
            let mut v = self.organizational_units.unwrap_or_default();
            v.push(input.into());
            self.organizational_units = Some(v);
            self
        }
        pub fn set_organizational_units(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ResourceDataSyncOrganizationalUnit>,
            >,
        ) -> Self {
            self.organizational_units = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceDataSyncAwsOrganizationsSource`](crate::model::ResourceDataSyncAwsOrganizationsSource)
        pub fn build(self) -> crate::model::ResourceDataSyncAwsOrganizationsSource {
            crate::model::ResourceDataSyncAwsOrganizationsSource {
                organization_source_type: self.organization_source_type,
                organizational_units: self.organizational_units,
            }
        }
    }
}
impl ResourceDataSyncAwsOrganizationsSource {
    /// Creates a new builder-style object to manufacture [`ResourceDataSyncAwsOrganizationsSource`](crate::model::ResourceDataSyncAwsOrganizationsSource)
    pub fn builder() -> crate::model::resource_data_sync_aws_organizations_source::Builder {
        crate::model::resource_data_sync_aws_organizations_source::Builder::default()
    }
}

/// <p>The AWS Organizations organizational unit data source for the sync.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceDataSyncOrganizationalUnit {
    /// <p>The AWS Organization unit ID data source for the sync.</p>
    #[serde(rename = "OrganizationalUnitId")]
    #[serde(default)]
    pub organizational_unit_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceDataSyncOrganizationalUnit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceDataSyncOrganizationalUnit");
        formatter.field("organizational_unit_id", &self.organizational_unit_id);
        formatter.finish()
    }
}
/// See [`ResourceDataSyncOrganizationalUnit`](crate::model::ResourceDataSyncOrganizationalUnit)
pub mod resource_data_sync_organizational_unit {
    /// A builder for [`ResourceDataSyncOrganizationalUnit`](crate::model::ResourceDataSyncOrganizationalUnit)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) organizational_unit_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The AWS Organization unit ID data source for the sync.</p>
        pub fn organizational_unit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.organizational_unit_id = Some(input.into());
            self
        }
        pub fn set_organizational_unit_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.organizational_unit_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceDataSyncOrganizationalUnit`](crate::model::ResourceDataSyncOrganizationalUnit)
        pub fn build(self) -> crate::model::ResourceDataSyncOrganizationalUnit {
            crate::model::ResourceDataSyncOrganizationalUnit {
                organizational_unit_id: self.organizational_unit_id,
            }
        }
    }
}
impl ResourceDataSyncOrganizationalUnit {
    /// Creates a new builder-style object to manufacture [`ResourceDataSyncOrganizationalUnit`](crate::model::ResourceDataSyncOrganizationalUnit)
    pub fn builder() -> crate::model::resource_data_sync_organizational_unit::Builder {
        crate::model::resource_data_sync_organizational_unit::Builder::default()
    }
}

/// <p>Information about the patches to use to update the instances, including target operating
/// systems and source repository. Applies to Linux instances only.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PatchSource {
    /// <p>The name specified to identify the patch source.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The specific operating system versions a patch repository applies to, such as "Ubuntu16.04",
    /// "AmazonLinux2016.09", "RedhatEnterpriseLinux7.2" or "Suse12.7". For lists of supported product
    /// values, see <a>PatchFilter</a>.</p>
    #[serde(rename = "Products")]
    #[serde(default)]
    pub products: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The value of the yum repo configuration. For example:</p>
    /// <p>
    /// <code>[main]</code>
    /// </p>
    /// <p>
    /// <code>name=MyCustomRepository</code>
    /// </p>
    /// <p>
    /// <code>baseurl=https://my-custom-repository</code>
    /// </p>
    /// <p>
    /// <code>enabled=1</code>
    /// </p>
    /// <note>
    /// <p>For information about other options available for your yum repository configuration, see
    /// <a href="https://man7.org/linux/man-pages/man5/dnf.conf.5.html">dnf.conf(5)</a>.</p>
    /// </note>
    #[serde(rename = "Configuration")]
    #[serde(default)]
    pub configuration: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PatchSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PatchSource");
        formatter.field("name", &self.name);
        formatter.field("products", &self.products);
        formatter.field("configuration", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`PatchSource`](crate::model::PatchSource)
pub mod patch_source {
    /// A builder for [`PatchSource`](crate::model::PatchSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) products: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) configuration: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name specified to identify the patch source.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        pub fn products(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.products.unwrap_or_default();
            v.push(input.into());
            self.products = Some(v);
            self
        }
        pub fn set_products(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.products = input;
            self
        }
        /// <p>The value of the yum repo configuration. For example:</p>
        /// <p>
        /// <code>[main]</code>
        /// </p>
        /// <p>
        /// <code>name=MyCustomRepository</code>
        /// </p>
        /// <p>
        /// <code>baseurl=https://my-custom-repository</code>
        /// </p>
        /// <p>
        /// <code>enabled=1</code>
        /// </p>
        /// <note>
        /// <p>For information about other options available for your yum repository configuration, see
        /// <a href="https://man7.org/linux/man-pages/man5/dnf.conf.5.html">dnf.conf(5)</a>.</p>
        /// </note>
        pub fn configuration(mut self, input: impl Into<std::string::String>) -> Self {
            self.configuration = Some(input.into());
            self
        }
        pub fn set_configuration(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PatchSource`](crate::model::PatchSource)
        pub fn build(self) -> crate::model::PatchSource {
            crate::model::PatchSource {
                name: self.name,
                products: self.products,
                configuration: self.configuration,
            }
        }
    }
}
impl PatchSource {
    /// Creates a new builder-style object to manufacture [`PatchSource`](crate::model::PatchSource)
    pub fn builder() -> crate::model::patch_source::Builder {
        crate::model::patch_source::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PatchAction {
    AllowAsDependency,
    Block,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PatchAction {
    fn from(s: &str) -> Self {
        match s {
            "ALLOW_AS_DEPENDENCY" => PatchAction::AllowAsDependency,
            "BLOCK" => PatchAction::Block,
            other => PatchAction::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PatchAction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(PatchAction::from(s))
    }
}
impl PatchAction {
    pub fn as_str(&self) -> &str {
        match self {
            PatchAction::AllowAsDependency => "ALLOW_AS_DEPENDENCY",
            PatchAction::Block => "BLOCK",
            PatchAction::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for PatchAction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for PatchAction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PatchComplianceLevel {
    Critical,
    High,
    Informational,
    Low,
    Medium,
    Unspecified,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PatchComplianceLevel {
    fn from(s: &str) -> Self {
        match s {
            "CRITICAL" => PatchComplianceLevel::Critical,
            "HIGH" => PatchComplianceLevel::High,
            "INFORMATIONAL" => PatchComplianceLevel::Informational,
            "LOW" => PatchComplianceLevel::Low,
            "MEDIUM" => PatchComplianceLevel::Medium,
            "UNSPECIFIED" => PatchComplianceLevel::Unspecified,
            other => PatchComplianceLevel::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PatchComplianceLevel {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(PatchComplianceLevel::from(s))
    }
}
impl PatchComplianceLevel {
    pub fn as_str(&self) -> &str {
        match self {
            PatchComplianceLevel::Critical => "CRITICAL",
            PatchComplianceLevel::High => "HIGH",
            PatchComplianceLevel::Informational => "INFORMATIONAL",
            PatchComplianceLevel::Low => "LOW",
            PatchComplianceLevel::Medium => "MEDIUM",
            PatchComplianceLevel::Unspecified => "UNSPECIFIED",
            PatchComplianceLevel::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for PatchComplianceLevel {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for PatchComplianceLevel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>A set of rules defining the approval rules for a patch baseline.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PatchRuleGroup {
    /// <p>The rules that make up the rule group.</p>
    #[serde(rename = "PatchRules")]
    #[serde(default)]
    pub patch_rules: std::option::Option<std::vec::Vec<crate::model::PatchRule>>,
}
impl std::fmt::Debug for PatchRuleGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PatchRuleGroup");
        formatter.field("patch_rules", &self.patch_rules);
        formatter.finish()
    }
}
/// See [`PatchRuleGroup`](crate::model::PatchRuleGroup)
pub mod patch_rule_group {
    /// A builder for [`PatchRuleGroup`](crate::model::PatchRuleGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) patch_rules: std::option::Option<std::vec::Vec<crate::model::PatchRule>>,
    }
    impl Builder {
        pub fn patch_rules(mut self, input: impl Into<crate::model::PatchRule>) -> Self {
            let mut v = self.patch_rules.unwrap_or_default();
            v.push(input.into());
            self.patch_rules = Some(v);
            self
        }
        pub fn set_patch_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PatchRule>>,
        ) -> Self {
            self.patch_rules = input;
            self
        }
        /// Consumes the builder and constructs a [`PatchRuleGroup`](crate::model::PatchRuleGroup)
        pub fn build(self) -> crate::model::PatchRuleGroup {
            crate::model::PatchRuleGroup {
                patch_rules: self.patch_rules,
            }
        }
    }
}
impl PatchRuleGroup {
    /// Creates a new builder-style object to manufacture [`PatchRuleGroup`](crate::model::PatchRuleGroup)
    pub fn builder() -> crate::model::patch_rule_group::Builder {
        crate::model::patch_rule_group::Builder::default()
    }
}

/// <p>Defines an approval rule for a patch baseline.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PatchRule {
    /// <p>The patch filter group that defines the criteria for the rule.</p>
    #[serde(rename = "PatchFilterGroup")]
    #[serde(default)]
    pub patch_filter_group: std::option::Option<crate::model::PatchFilterGroup>,
    /// <p>A compliance severity level for all approved patches in a patch baseline.</p>
    #[serde(rename = "ComplianceLevel")]
    #[serde(default)]
    pub compliance_level: std::option::Option<crate::model::PatchComplianceLevel>,
    /// <p>The number of days after the release date of each patch matched by the rule that the patch
    /// is marked as approved in the patch baseline. For example, a value of <code>7</code> means that
    /// patches are approved seven days after they are released. Not supported on Debian Server or Ubuntu
    /// Server.</p>
    #[serde(rename = "ApproveAfterDays")]
    #[serde(default)]
    pub approve_after_days: std::option::Option<i32>,
    /// <p>The cutoff date for auto approval of released patches. Any patches released on or before
    /// this date are installed automatically. Not supported on Debian Server or Ubuntu Server.</p>
    /// <p>Enter dates in the format <code>YYYY-MM-DD</code>. For example,
    /// <code>2020-12-31</code>.</p>
    #[serde(rename = "ApproveUntilDate")]
    #[serde(default)]
    pub approve_until_date: std::option::Option<std::string::String>,
    /// <p>For instances identified by the approval rule filters, enables a patch baseline to apply
    /// non-security updates available in the specified repository. The default value is 'false'. Applies
    /// to Linux instances only.</p>
    #[serde(rename = "EnableNonSecurity")]
    #[serde(default)]
    pub enable_non_security: std::option::Option<bool>,
}
impl std::fmt::Debug for PatchRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PatchRule");
        formatter.field("patch_filter_group", &self.patch_filter_group);
        formatter.field("compliance_level", &self.compliance_level);
        formatter.field("approve_after_days", &self.approve_after_days);
        formatter.field("approve_until_date", &self.approve_until_date);
        formatter.field("enable_non_security", &self.enable_non_security);
        formatter.finish()
    }
}
/// See [`PatchRule`](crate::model::PatchRule)
pub mod patch_rule {
    /// A builder for [`PatchRule`](crate::model::PatchRule)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) patch_filter_group: std::option::Option<crate::model::PatchFilterGroup>,
        pub(crate) compliance_level: std::option::Option<crate::model::PatchComplianceLevel>,
        pub(crate) approve_after_days: std::option::Option<i32>,
        pub(crate) approve_until_date: std::option::Option<std::string::String>,
        pub(crate) enable_non_security: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The patch filter group that defines the criteria for the rule.</p>
        pub fn patch_filter_group(mut self, input: crate::model::PatchFilterGroup) -> Self {
            self.patch_filter_group = Some(input);
            self
        }
        pub fn set_patch_filter_group(
            mut self,
            input: std::option::Option<crate::model::PatchFilterGroup>,
        ) -> Self {
            self.patch_filter_group = input;
            self
        }
        /// <p>A compliance severity level for all approved patches in a patch baseline.</p>
        pub fn compliance_level(mut self, input: crate::model::PatchComplianceLevel) -> Self {
            self.compliance_level = Some(input);
            self
        }
        pub fn set_compliance_level(
            mut self,
            input: std::option::Option<crate::model::PatchComplianceLevel>,
        ) -> Self {
            self.compliance_level = input;
            self
        }
        /// <p>The number of days after the release date of each patch matched by the rule that the patch
        /// is marked as approved in the patch baseline. For example, a value of <code>7</code> means that
        /// patches are approved seven days after they are released. Not supported on Debian Server or Ubuntu
        /// Server.</p>
        pub fn approve_after_days(mut self, input: i32) -> Self {
            self.approve_after_days = Some(input);
            self
        }
        pub fn set_approve_after_days(mut self, input: std::option::Option<i32>) -> Self {
            self.approve_after_days = input;
            self
        }
        /// <p>The cutoff date for auto approval of released patches. Any patches released on or before
        /// this date are installed automatically. Not supported on Debian Server or Ubuntu Server.</p>
        /// <p>Enter dates in the format <code>YYYY-MM-DD</code>. For example,
        /// <code>2020-12-31</code>.</p>
        pub fn approve_until_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.approve_until_date = Some(input.into());
            self
        }
        pub fn set_approve_until_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.approve_until_date = input;
            self
        }
        /// <p>For instances identified by the approval rule filters, enables a patch baseline to apply
        /// non-security updates available in the specified repository. The default value is 'false'. Applies
        /// to Linux instances only.</p>
        pub fn enable_non_security(mut self, input: bool) -> Self {
            self.enable_non_security = Some(input);
            self
        }
        pub fn set_enable_non_security(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_non_security = input;
            self
        }
        /// Consumes the builder and constructs a [`PatchRule`](crate::model::PatchRule)
        pub fn build(self) -> crate::model::PatchRule {
            crate::model::PatchRule {
                patch_filter_group: self.patch_filter_group,
                compliance_level: self.compliance_level,
                approve_after_days: self.approve_after_days,
                approve_until_date: self.approve_until_date,
                enable_non_security: self.enable_non_security,
            }
        }
    }
}
impl PatchRule {
    /// Creates a new builder-style object to manufacture [`PatchRule`](crate::model::PatchRule)
    pub fn builder() -> crate::model::patch_rule::Builder {
        crate::model::patch_rule::Builder::default()
    }
}

/// <p>A set of patch filters, typically used for approval rules.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PatchFilterGroup {
    /// <p>The set of patch filters that make up the group.</p>
    #[serde(rename = "PatchFilters")]
    #[serde(default)]
    pub patch_filters: std::option::Option<std::vec::Vec<crate::model::PatchFilter>>,
}
impl std::fmt::Debug for PatchFilterGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PatchFilterGroup");
        formatter.field("patch_filters", &self.patch_filters);
        formatter.finish()
    }
}
/// See [`PatchFilterGroup`](crate::model::PatchFilterGroup)
pub mod patch_filter_group {
    /// A builder for [`PatchFilterGroup`](crate::model::PatchFilterGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) patch_filters: std::option::Option<std::vec::Vec<crate::model::PatchFilter>>,
    }
    impl Builder {
        pub fn patch_filters(mut self, input: impl Into<crate::model::PatchFilter>) -> Self {
            let mut v = self.patch_filters.unwrap_or_default();
            v.push(input.into());
            self.patch_filters = Some(v);
            self
        }
        pub fn set_patch_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PatchFilter>>,
        ) -> Self {
            self.patch_filters = input;
            self
        }
        /// Consumes the builder and constructs a [`PatchFilterGroup`](crate::model::PatchFilterGroup)
        pub fn build(self) -> crate::model::PatchFilterGroup {
            crate::model::PatchFilterGroup {
                patch_filters: self.patch_filters,
            }
        }
    }
}
impl PatchFilterGroup {
    /// Creates a new builder-style object to manufacture [`PatchFilterGroup`](crate::model::PatchFilterGroup)
    pub fn builder() -> crate::model::patch_filter_group::Builder {
        crate::model::patch_filter_group::Builder::default()
    }
}

/// <p> Defines which patches should be included in a patch baseline.</p>
/// <p>A patch filter consists of a key and a set of values. The filter key is a patch property.
/// For example, the available filter keys for WINDOWS are PATCH_SET, PRODUCT, PRODUCT_FAMILY,
/// CLASSIFICATION, and MSRC_SEVERITY. The filter values define a matching criterion for the patch
/// property indicated by the key. For example, if the filter key is PRODUCT and the filter values
/// are ["Office 2013", "Office 2016"], then the filter accepts all patches where product name is
/// either "Office 2013" or "Office 2016". The filter values can be exact values for the patch
/// property given as a key, or a wildcard (*), which matches all values.</p>
/// <p>You can view lists of valid values for the patch properties by running the
/// <code>DescribePatchProperties</code> command. For information about which patch properties can
/// be used with each major operating system, see <a>DescribePatchProperties</a>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PatchFilter {
    /// <p>The key for the filter.</p>
    /// <p>Run the <a>DescribePatchProperties</a> command to view lists of valid keys for
    /// each operating system type.</p>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<crate::model::PatchFilterKey>,
    /// <p>The value for the filter key.</p>
    /// <p>Run the <a>DescribePatchProperties</a> command to view lists of valid values for
    /// each key based on operating system type.</p>
    #[serde(rename = "Values")]
    #[serde(default)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for PatchFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PatchFilter");
        formatter.field("key", &self.key);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`PatchFilter`](crate::model::PatchFilter)
pub mod patch_filter {
    /// A builder for [`PatchFilter`](crate::model::PatchFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<crate::model::PatchFilterKey>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The key for the filter.</p>
        /// <p>Run the <a>DescribePatchProperties</a> command to view lists of valid keys for
        /// each operating system type.</p>
        pub fn key(mut self, input: crate::model::PatchFilterKey) -> Self {
            self.key = Some(input);
            self
        }
        pub fn set_key(mut self, input: std::option::Option<crate::model::PatchFilterKey>) -> Self {
            self.key = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`PatchFilter`](crate::model::PatchFilter)
        pub fn build(self) -> crate::model::PatchFilter {
            crate::model::PatchFilter {
                key: self.key,
                values: self.values,
            }
        }
    }
}
impl PatchFilter {
    /// Creates a new builder-style object to manufacture [`PatchFilter`](crate::model::PatchFilter)
    pub fn builder() -> crate::model::patch_filter::Builder {
        crate::model::patch_filter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PatchFilterKey {
    AdvisoryId,
    Arch,
    BugzillaId,
    Classification,
    CveId,
    Epoch,
    MsrcSeverity,
    Name,
    PatchId,
    PatchSet,
    Priority,
    Product,
    ProductFamily,
    Release,
    Repository,
    Section,
    Security,
    Severity,
    Version,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PatchFilterKey {
    fn from(s: &str) -> Self {
        match s {
            "ADVISORY_ID" => PatchFilterKey::AdvisoryId,
            "ARCH" => PatchFilterKey::Arch,
            "BUGZILLA_ID" => PatchFilterKey::BugzillaId,
            "CLASSIFICATION" => PatchFilterKey::Classification,
            "CVE_ID" => PatchFilterKey::CveId,
            "EPOCH" => PatchFilterKey::Epoch,
            "MSRC_SEVERITY" => PatchFilterKey::MsrcSeverity,
            "NAME" => PatchFilterKey::Name,
            "PATCH_ID" => PatchFilterKey::PatchId,
            "PATCH_SET" => PatchFilterKey::PatchSet,
            "PRIORITY" => PatchFilterKey::Priority,
            "PRODUCT" => PatchFilterKey::Product,
            "PRODUCT_FAMILY" => PatchFilterKey::ProductFamily,
            "RELEASE" => PatchFilterKey::Release,
            "REPOSITORY" => PatchFilterKey::Repository,
            "SECTION" => PatchFilterKey::Section,
            "SECURITY" => PatchFilterKey::Security,
            "SEVERITY" => PatchFilterKey::Severity,
            "VERSION" => PatchFilterKey::Version,
            other => PatchFilterKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PatchFilterKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(PatchFilterKey::from(s))
    }
}
impl PatchFilterKey {
    pub fn as_str(&self) -> &str {
        match self {
            PatchFilterKey::AdvisoryId => "ADVISORY_ID",
            PatchFilterKey::Arch => "ARCH",
            PatchFilterKey::BugzillaId => "BUGZILLA_ID",
            PatchFilterKey::Classification => "CLASSIFICATION",
            PatchFilterKey::CveId => "CVE_ID",
            PatchFilterKey::Epoch => "EPOCH",
            PatchFilterKey::MsrcSeverity => "MSRC_SEVERITY",
            PatchFilterKey::Name => "NAME",
            PatchFilterKey::PatchId => "PATCH_ID",
            PatchFilterKey::PatchSet => "PATCH_SET",
            PatchFilterKey::Priority => "PRIORITY",
            PatchFilterKey::Product => "PRODUCT",
            PatchFilterKey::ProductFamily => "PRODUCT_FAMILY",
            PatchFilterKey::Release => "RELEASE",
            PatchFilterKey::Repository => "REPOSITORY",
            PatchFilterKey::Section => "SECTION",
            PatchFilterKey::Security => "SECURITY",
            PatchFilterKey::Severity => "SEVERITY",
            PatchFilterKey::Version => "VERSION",
            PatchFilterKey::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for PatchFilterKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for PatchFilterKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OperatingSystem {
    AmazonLinux,
    AmazonLinux2,
    CentOs,
    Debian,
    MacOs,
    OracleLinux,
    RedhatEnterpriseLinux,
    Suse,
    Ubuntu,
    Windows,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OperatingSystem {
    fn from(s: &str) -> Self {
        match s {
            "AMAZON_LINUX" => OperatingSystem::AmazonLinux,
            "AMAZON_LINUX_2" => OperatingSystem::AmazonLinux2,
            "CENTOS" => OperatingSystem::CentOs,
            "DEBIAN" => OperatingSystem::Debian,
            "MACOS" => OperatingSystem::MacOs,
            "ORACLE_LINUX" => OperatingSystem::OracleLinux,
            "REDHAT_ENTERPRISE_LINUX" => OperatingSystem::RedhatEnterpriseLinux,
            "SUSE" => OperatingSystem::Suse,
            "UBUNTU" => OperatingSystem::Ubuntu,
            "WINDOWS" => OperatingSystem::Windows,
            other => OperatingSystem::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OperatingSystem {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(OperatingSystem::from(s))
    }
}
impl OperatingSystem {
    pub fn as_str(&self) -> &str {
        match self {
            OperatingSystem::AmazonLinux => "AMAZON_LINUX",
            OperatingSystem::AmazonLinux2 => "AMAZON_LINUX_2",
            OperatingSystem::CentOs => "CENTOS",
            OperatingSystem::Debian => "DEBIAN",
            OperatingSystem::MacOs => "MACOS",
            OperatingSystem::OracleLinux => "ORACLE_LINUX",
            OperatingSystem::RedhatEnterpriseLinux => "REDHAT_ENTERPRISE_LINUX",
            OperatingSystem::Suse => "SUSE",
            OperatingSystem::Ubuntu => "UBUNTU",
            OperatingSystem::Windows => "WINDOWS",
            OperatingSystem::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for OperatingSystem {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for OperatingSystem {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Metadata to assign to an Application Manager application.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MetadataValue {
    /// <p>Metadata value to assign to an Application Manager application.</p>
    #[serde(rename = "Value")]
    #[serde(default)]
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MetadataValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MetadataValue");
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`MetadataValue`](crate::model::MetadataValue)
pub mod metadata_value {
    /// A builder for [`MetadataValue`](crate::model::MetadataValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Metadata value to assign to an Application Manager application.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`MetadataValue`](crate::model::MetadataValue)
        pub fn build(self) -> crate::model::MetadataValue {
            crate::model::MetadataValue { value: self.value }
        }
    }
}
impl MetadataValue {
    /// Creates a new builder-style object to manufacture [`MetadataValue`](crate::model::MetadataValue)
    pub fn builder() -> crate::model::metadata_value::Builder {
        crate::model::metadata_value::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OpsItemStatus {
    Approved,
    Cancelled,
    Cancelling,
    ChangeCalendarOverrideApproved,
    ChangeCalendarOverrideRejected,
    CompletedWithFailure,
    CompletedWithSuccess,
    Failed,
    InProgress,
    Open,
    Pending,
    PendingApproval,
    PendingChangeCalendarOverride,
    Rejected,
    Resolved,
    RunbookInProgress,
    Scheduled,
    TimedOut,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OpsItemStatus {
    fn from(s: &str) -> Self {
        match s {
            "Approved" => OpsItemStatus::Approved,
            "Cancelled" => OpsItemStatus::Cancelled,
            "Cancelling" => OpsItemStatus::Cancelling,
            "ChangeCalendarOverrideApproved" => OpsItemStatus::ChangeCalendarOverrideApproved,
            "ChangeCalendarOverrideRejected" => OpsItemStatus::ChangeCalendarOverrideRejected,
            "CompletedWithFailure" => OpsItemStatus::CompletedWithFailure,
            "CompletedWithSuccess" => OpsItemStatus::CompletedWithSuccess,
            "Failed" => OpsItemStatus::Failed,
            "InProgress" => OpsItemStatus::InProgress,
            "Open" => OpsItemStatus::Open,
            "Pending" => OpsItemStatus::Pending,
            "PendingApproval" => OpsItemStatus::PendingApproval,
            "PendingChangeCalendarOverride" => OpsItemStatus::PendingChangeCalendarOverride,
            "Rejected" => OpsItemStatus::Rejected,
            "Resolved" => OpsItemStatus::Resolved,
            "RunbookInProgress" => OpsItemStatus::RunbookInProgress,
            "Scheduled" => OpsItemStatus::Scheduled,
            "TimedOut" => OpsItemStatus::TimedOut,
            other => OpsItemStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OpsItemStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(OpsItemStatus::from(s))
    }
}
impl OpsItemStatus {
    pub fn as_str(&self) -> &str {
        match self {
            OpsItemStatus::Approved => "Approved",
            OpsItemStatus::Cancelled => "Cancelled",
            OpsItemStatus::Cancelling => "Cancelling",
            OpsItemStatus::ChangeCalendarOverrideApproved => "ChangeCalendarOverrideApproved",
            OpsItemStatus::ChangeCalendarOverrideRejected => "ChangeCalendarOverrideRejected",
            OpsItemStatus::CompletedWithFailure => "CompletedWithFailure",
            OpsItemStatus::CompletedWithSuccess => "CompletedWithSuccess",
            OpsItemStatus::Failed => "Failed",
            OpsItemStatus::InProgress => "InProgress",
            OpsItemStatus::Open => "Open",
            OpsItemStatus::Pending => "Pending",
            OpsItemStatus::PendingApproval => "PendingApproval",
            OpsItemStatus::PendingChangeCalendarOverride => "PendingChangeCalendarOverride",
            OpsItemStatus::Rejected => "Rejected",
            OpsItemStatus::Resolved => "Resolved",
            OpsItemStatus::RunbookInProgress => "RunbookInProgress",
            OpsItemStatus::Scheduled => "Scheduled",
            OpsItemStatus::TimedOut => "TimedOut",
            OpsItemStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for OpsItemStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for OpsItemStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>An OpsItems that shares something in common with the current OpsItem. For example, related
/// OpsItems can include OpsItems with similar error messages, impacted resources, or statuses for
/// the impacted resource.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct RelatedOpsItem {
    /// <p>The ID of an OpsItem related to the current OpsItem.</p>
    #[serde(rename = "OpsItemId")]
    #[serde(default)]
    pub ops_item_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RelatedOpsItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RelatedOpsItem");
        formatter.field("ops_item_id", &self.ops_item_id);
        formatter.finish()
    }
}
/// See [`RelatedOpsItem`](crate::model::RelatedOpsItem)
pub mod related_ops_item {
    /// A builder for [`RelatedOpsItem`](crate::model::RelatedOpsItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ops_item_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of an OpsItem related to the current OpsItem.</p>
        pub fn ops_item_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ops_item_id = Some(input.into());
            self
        }
        pub fn set_ops_item_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ops_item_id = input;
            self
        }
        /// Consumes the builder and constructs a [`RelatedOpsItem`](crate::model::RelatedOpsItem)
        pub fn build(self) -> crate::model::RelatedOpsItem {
            crate::model::RelatedOpsItem {
                ops_item_id: self.ops_item_id,
            }
        }
    }
}
impl RelatedOpsItem {
    /// Creates a new builder-style object to manufacture [`RelatedOpsItem`](crate::model::RelatedOpsItem)
    pub fn builder() -> crate::model::related_ops_item::Builder {
        crate::model::related_ops_item::Builder::default()
    }
}

/// <p>A notification about the OpsItem.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsItemNotification {
    /// <p>The Amazon Resource Name (ARN) of an SNS topic where notifications are sent when this
    /// OpsItem is edited or changed.</p>
    #[serde(rename = "Arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OpsItemNotification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsItemNotification");
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}
/// See [`OpsItemNotification`](crate::model::OpsItemNotification)
pub mod ops_item_notification {
    /// A builder for [`OpsItemNotification`](crate::model::OpsItemNotification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of an SNS topic where notifications are sent when this
        /// OpsItem is edited or changed.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsItemNotification`](crate::model::OpsItemNotification)
        pub fn build(self) -> crate::model::OpsItemNotification {
            crate::model::OpsItemNotification { arn: self.arn }
        }
    }
}
impl OpsItemNotification {
    /// Creates a new builder-style object to manufacture [`OpsItemNotification`](crate::model::OpsItemNotification)
    pub fn builder() -> crate::model::ops_item_notification::Builder {
        crate::model::ops_item_notification::Builder::default()
    }
}

/// <p>An object that defines the value of the key and its type in the OperationalData map.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsItemDataValue {
    /// <p>The value of the OperationalData key.</p>
    #[serde(rename = "Value")]
    #[serde(default)]
    pub value: std::option::Option<std::string::String>,
    /// <p>The type of key-value pair. Valid types include <code>SearchableString</code> and
    /// <code>String</code>.</p>
    #[serde(rename = "Type")]
    #[serde(default)]
    pub r#type: std::option::Option<crate::model::OpsItemDataType>,
}
impl std::fmt::Debug for OpsItemDataValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsItemDataValue");
        formatter.field("value", &self.value);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`OpsItemDataValue`](crate::model::OpsItemDataValue)
pub mod ops_item_data_value {
    /// A builder for [`OpsItemDataValue`](crate::model::OpsItemDataValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::OpsItemDataType>,
    }
    impl Builder {
        /// <p>The value of the OperationalData key.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>The type of key-value pair. Valid types include <code>SearchableString</code> and
        /// <code>String</code>.</p>
        pub fn r#type(mut self, input: crate::model::OpsItemDataType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::OpsItemDataType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsItemDataValue`](crate::model::OpsItemDataValue)
        pub fn build(self) -> crate::model::OpsItemDataValue {
            crate::model::OpsItemDataValue {
                value: self.value,
                r#type: self.r#type,
            }
        }
    }
}
impl OpsItemDataValue {
    /// Creates a new builder-style object to manufacture [`OpsItemDataValue`](crate::model::OpsItemDataValue)
    pub fn builder() -> crate::model::ops_item_data_value::Builder {
        crate::model::ops_item_data_value::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OpsItemDataType {
    SearchableString,
    String,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OpsItemDataType {
    fn from(s: &str) -> Self {
        match s {
            "SearchableString" => OpsItemDataType::SearchableString,
            "String" => OpsItemDataType::String,
            other => OpsItemDataType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OpsItemDataType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(OpsItemDataType::from(s))
    }
}
impl OpsItemDataType {
    pub fn as_str(&self) -> &str {
        match self {
            OpsItemDataType::SearchableString => "SearchableString",
            OpsItemDataType::String => "String",
            OpsItemDataType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for OpsItemDataType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for OpsItemDataType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Information about an S3 bucket to write instance-level logs to.</p>
/// <note>
/// <p>
/// <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the
/// <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure.
/// For information about how Systems Manager handles these options for the supported maintenance
/// window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
/// </note>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct LoggingInfo {
    /// <p>The name of an S3 bucket where execution logs are stored .</p>
    #[serde(rename = "S3BucketName")]
    #[serde(default)]
    pub s3_bucket_name: std::option::Option<std::string::String>,
    /// <p>(Optional) The S3 bucket subfolder. </p>
    #[serde(rename = "S3KeyPrefix")]
    #[serde(default)]
    pub s3_key_prefix: std::option::Option<std::string::String>,
    /// <p>The Region where the S3 bucket is located.</p>
    #[serde(rename = "S3Region")]
    #[serde(default)]
    pub s3_region: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LoggingInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LoggingInfo");
        formatter.field("s3_bucket_name", &self.s3_bucket_name);
        formatter.field("s3_key_prefix", &self.s3_key_prefix);
        formatter.field("s3_region", &self.s3_region);
        formatter.finish()
    }
}
/// See [`LoggingInfo`](crate::model::LoggingInfo)
pub mod logging_info {
    /// A builder for [`LoggingInfo`](crate::model::LoggingInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_bucket_name: std::option::Option<std::string::String>,
        pub(crate) s3_key_prefix: std::option::Option<std::string::String>,
        pub(crate) s3_region: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of an S3 bucket where execution logs are stored .</p>
        pub fn s3_bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket_name = Some(input.into());
            self
        }
        pub fn set_s3_bucket_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_bucket_name = input;
            self
        }
        /// <p>(Optional) The S3 bucket subfolder. </p>
        pub fn s3_key_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_key_prefix = Some(input.into());
            self
        }
        pub fn set_s3_key_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_key_prefix = input;
            self
        }
        /// <p>The Region where the S3 bucket is located.</p>
        pub fn s3_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_region = Some(input.into());
            self
        }
        pub fn set_s3_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_region = input;
            self
        }
        /// Consumes the builder and constructs a [`LoggingInfo`](crate::model::LoggingInfo)
        pub fn build(self) -> crate::model::LoggingInfo {
            crate::model::LoggingInfo {
                s3_bucket_name: self.s3_bucket_name,
                s3_key_prefix: self.s3_key_prefix,
                s3_region: self.s3_region,
            }
        }
    }
}
impl LoggingInfo {
    /// Creates a new builder-style object to manufacture [`LoggingInfo`](crate::model::LoggingInfo)
    pub fn builder() -> crate::model::logging_info::Builder {
        crate::model::logging_info::Builder::default()
    }
}

/// <p>The parameters for task execution.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MaintenanceWindowTaskInvocationParameters {
    /// <p>The parameters for a RUN_COMMAND task type.</p>
    #[serde(rename = "RunCommand")]
    #[serde(default)]
    pub run_command: std::option::Option<crate::model::MaintenanceWindowRunCommandParameters>,
    /// <p>The parameters for an AUTOMATION task type.</p>
    #[serde(rename = "Automation")]
    #[serde(default)]
    pub automation: std::option::Option<crate::model::MaintenanceWindowAutomationParameters>,
    /// <p>The parameters for a STEP_FUNCTIONS task type.</p>
    #[serde(rename = "StepFunctions")]
    #[serde(default)]
    pub step_functions: std::option::Option<crate::model::MaintenanceWindowStepFunctionsParameters>,
    /// <p>The parameters for a LAMBDA task type.</p>
    #[serde(rename = "Lambda")]
    #[serde(default)]
    pub lambda: std::option::Option<crate::model::MaintenanceWindowLambdaParameters>,
}
impl std::fmt::Debug for MaintenanceWindowTaskInvocationParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaintenanceWindowTaskInvocationParameters");
        formatter.field("run_command", &self.run_command);
        formatter.field("automation", &self.automation);
        formatter.field("step_functions", &self.step_functions);
        formatter.field("lambda", &self.lambda);
        formatter.finish()
    }
}
/// See [`MaintenanceWindowTaskInvocationParameters`](crate::model::MaintenanceWindowTaskInvocationParameters)
pub mod maintenance_window_task_invocation_parameters {
    /// A builder for [`MaintenanceWindowTaskInvocationParameters`](crate::model::MaintenanceWindowTaskInvocationParameters)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) run_command:
            std::option::Option<crate::model::MaintenanceWindowRunCommandParameters>,
        pub(crate) automation:
            std::option::Option<crate::model::MaintenanceWindowAutomationParameters>,
        pub(crate) step_functions:
            std::option::Option<crate::model::MaintenanceWindowStepFunctionsParameters>,
        pub(crate) lambda: std::option::Option<crate::model::MaintenanceWindowLambdaParameters>,
    }
    impl Builder {
        /// <p>The parameters for a RUN_COMMAND task type.</p>
        pub fn run_command(
            mut self,
            input: crate::model::MaintenanceWindowRunCommandParameters,
        ) -> Self {
            self.run_command = Some(input);
            self
        }
        pub fn set_run_command(
            mut self,
            input: std::option::Option<crate::model::MaintenanceWindowRunCommandParameters>,
        ) -> Self {
            self.run_command = input;
            self
        }
        /// <p>The parameters for an AUTOMATION task type.</p>
        pub fn automation(
            mut self,
            input: crate::model::MaintenanceWindowAutomationParameters,
        ) -> Self {
            self.automation = Some(input);
            self
        }
        pub fn set_automation(
            mut self,
            input: std::option::Option<crate::model::MaintenanceWindowAutomationParameters>,
        ) -> Self {
            self.automation = input;
            self
        }
        /// <p>The parameters for a STEP_FUNCTIONS task type.</p>
        pub fn step_functions(
            mut self,
            input: crate::model::MaintenanceWindowStepFunctionsParameters,
        ) -> Self {
            self.step_functions = Some(input);
            self
        }
        pub fn set_step_functions(
            mut self,
            input: std::option::Option<crate::model::MaintenanceWindowStepFunctionsParameters>,
        ) -> Self {
            self.step_functions = input;
            self
        }
        /// <p>The parameters for a LAMBDA task type.</p>
        pub fn lambda(mut self, input: crate::model::MaintenanceWindowLambdaParameters) -> Self {
            self.lambda = Some(input);
            self
        }
        pub fn set_lambda(
            mut self,
            input: std::option::Option<crate::model::MaintenanceWindowLambdaParameters>,
        ) -> Self {
            self.lambda = input;
            self
        }
        /// Consumes the builder and constructs a [`MaintenanceWindowTaskInvocationParameters`](crate::model::MaintenanceWindowTaskInvocationParameters)
        pub fn build(self) -> crate::model::MaintenanceWindowTaskInvocationParameters {
            crate::model::MaintenanceWindowTaskInvocationParameters {
                run_command: self.run_command,
                automation: self.automation,
                step_functions: self.step_functions,
                lambda: self.lambda,
            }
        }
    }
}
impl MaintenanceWindowTaskInvocationParameters {
    /// Creates a new builder-style object to manufacture [`MaintenanceWindowTaskInvocationParameters`](crate::model::MaintenanceWindowTaskInvocationParameters)
    pub fn builder() -> crate::model::maintenance_window_task_invocation_parameters::Builder {
        crate::model::maintenance_window_task_invocation_parameters::Builder::default()
    }
}

/// <p>The parameters for a LAMBDA task type.</p>
/// <p>For information about specifying and updating task parameters, see <a>RegisterTaskWithMaintenanceWindow</a> and <a>UpdateMaintenanceWindowTask</a>.</p>
/// <note>
/// <p>
/// <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the
/// <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure.
/// For information about how Systems Manager handles these options for the supported maintenance
/// window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
/// <p>
/// <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs,
/// instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information
/// about how Systems Manager handles these options for the supported maintenance window task
/// types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
/// <p>For Lambda tasks, Systems Manager ignores any values specified for TaskParameters and
/// LoggingInfo.</p>
/// </note>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MaintenanceWindowLambdaParameters {
    /// <p>Pass client-specific information to the Lambda function that you are invoking. You can then
    /// process the client information in your Lambda function as you choose through the context
    /// variable.</p>
    #[serde(rename = "ClientContext")]
    #[serde(default)]
    pub client_context: std::option::Option<std::string::String>,
    /// <p>(Optional) Specify a Lambda function version or alias name. If you specify a function
    /// version, the action uses the qualified function ARN to invoke a specific Lambda function. If you
    /// specify an alias name, the action uses the alias ARN to invoke the Lambda function version to
    /// which the alias points.</p>
    #[serde(rename = "Qualifier")]
    #[serde(default)]
    pub qualifier: std::option::Option<std::string::String>,
    /// <p>JSON to provide to your Lambda function as input.</p>
    #[serde(rename = "Payload")]
    #[serde(deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesblob_deser")]
    #[serde(default)]
    pub payload: std::option::Option<smithy_types::Blob>,
}
impl std::fmt::Debug for MaintenanceWindowLambdaParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaintenanceWindowLambdaParameters");
        formatter.field("client_context", &self.client_context);
        formatter.field("qualifier", &self.qualifier);
        formatter.field("payload", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`MaintenanceWindowLambdaParameters`](crate::model::MaintenanceWindowLambdaParameters)
pub mod maintenance_window_lambda_parameters {
    /// A builder for [`MaintenanceWindowLambdaParameters`](crate::model::MaintenanceWindowLambdaParameters)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_context: std::option::Option<std::string::String>,
        pub(crate) qualifier: std::option::Option<std::string::String>,
        pub(crate) payload: std::option::Option<smithy_types::Blob>,
    }
    impl Builder {
        /// <p>Pass client-specific information to the Lambda function that you are invoking. You can then
        /// process the client information in your Lambda function as you choose through the context
        /// variable.</p>
        pub fn client_context(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_context = Some(input.into());
            self
        }
        pub fn set_client_context(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_context = input;
            self
        }
        /// <p>(Optional) Specify a Lambda function version or alias name. If you specify a function
        /// version, the action uses the qualified function ARN to invoke a specific Lambda function. If you
        /// specify an alias name, the action uses the alias ARN to invoke the Lambda function version to
        /// which the alias points.</p>
        pub fn qualifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.qualifier = Some(input.into());
            self
        }
        pub fn set_qualifier(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.qualifier = input;
            self
        }
        /// <p>JSON to provide to your Lambda function as input.</p>
        pub fn payload(mut self, input: smithy_types::Blob) -> Self {
            self.payload = Some(input);
            self
        }
        pub fn set_payload(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.payload = input;
            self
        }
        /// Consumes the builder and constructs a [`MaintenanceWindowLambdaParameters`](crate::model::MaintenanceWindowLambdaParameters)
        pub fn build(self) -> crate::model::MaintenanceWindowLambdaParameters {
            crate::model::MaintenanceWindowLambdaParameters {
                client_context: self.client_context,
                qualifier: self.qualifier,
                payload: self.payload,
            }
        }
    }
}
impl MaintenanceWindowLambdaParameters {
    /// Creates a new builder-style object to manufacture [`MaintenanceWindowLambdaParameters`](crate::model::MaintenanceWindowLambdaParameters)
    pub fn builder() -> crate::model::maintenance_window_lambda_parameters::Builder {
        crate::model::maintenance_window_lambda_parameters::Builder::default()
    }
}

/// <p>The parameters for a STEP_FUNCTIONS task.</p>
/// <p>For information about specifying and updating task parameters, see <a>RegisterTaskWithMaintenanceWindow</a> and <a>UpdateMaintenanceWindowTask</a>.</p>
/// <note>
/// <p>
/// <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the
/// <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure.
/// For information about how Systems Manager handles these options for the supported maintenance
/// window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
/// <p>
/// <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs,
/// instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information
/// about how Systems Manager handles these options for the supported maintenance window task
/// types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
/// <p>For Step Functions tasks, Systems Manager ignores any values specified for
/// <code>TaskParameters</code> and <code>LoggingInfo</code>.</p>
/// </note>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MaintenanceWindowStepFunctionsParameters {
    /// <p>The inputs for the STEP_FUNCTIONS task.</p>
    #[serde(rename = "Input")]
    #[serde(default)]
    pub input: std::option::Option<std::string::String>,
    /// <p>The name of the STEP_FUNCTIONS task.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaintenanceWindowStepFunctionsParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaintenanceWindowStepFunctionsParameters");
        formatter.field("input", &"*** Sensitive Data Redacted ***");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`MaintenanceWindowStepFunctionsParameters`](crate::model::MaintenanceWindowStepFunctionsParameters)
pub mod maintenance_window_step_functions_parameters {
    /// A builder for [`MaintenanceWindowStepFunctionsParameters`](crate::model::MaintenanceWindowStepFunctionsParameters)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) input: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The inputs for the STEP_FUNCTIONS task.</p>
        pub fn input(mut self, input: impl Into<std::string::String>) -> Self {
            self.input = Some(input.into());
            self
        }
        pub fn set_input(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.input = input;
            self
        }
        /// <p>The name of the STEP_FUNCTIONS task.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`MaintenanceWindowStepFunctionsParameters`](crate::model::MaintenanceWindowStepFunctionsParameters)
        pub fn build(self) -> crate::model::MaintenanceWindowStepFunctionsParameters {
            crate::model::MaintenanceWindowStepFunctionsParameters {
                input: self.input,
                name: self.name,
            }
        }
    }
}
impl MaintenanceWindowStepFunctionsParameters {
    /// Creates a new builder-style object to manufacture [`MaintenanceWindowStepFunctionsParameters`](crate::model::MaintenanceWindowStepFunctionsParameters)
    pub fn builder() -> crate::model::maintenance_window_step_functions_parameters::Builder {
        crate::model::maintenance_window_step_functions_parameters::Builder::default()
    }
}

/// <p>The parameters for an AUTOMATION task type.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MaintenanceWindowAutomationParameters {
    /// <p>The version of an Automation document to use during task execution.</p>
    #[serde(rename = "DocumentVersion")]
    #[serde(default)]
    pub document_version: std::option::Option<std::string::String>,
    /// <p>The parameters for the AUTOMATION task.</p>
    /// <p>For information about specifying and updating task parameters, see <a>RegisterTaskWithMaintenanceWindow</a> and <a>UpdateMaintenanceWindowTask</a>.</p>
    /// <note>
    /// <p>
    /// <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the
    /// <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure.
    /// For information about how Systems Manager handles these options for the supported maintenance
    /// window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
    /// <p>
    /// <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs,
    /// instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information
    /// about how Systems Manager handles these options for the supported maintenance window task
    /// types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
    /// <p>For AUTOMATION task types, Systems Manager ignores any values specified for these parameters.</p>
    /// </note>
    #[serde(rename = "Parameters")]
    #[serde(default)]
    pub parameters: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
}
impl std::fmt::Debug for MaintenanceWindowAutomationParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaintenanceWindowAutomationParameters");
        formatter.field("document_version", &self.document_version);
        formatter.field("parameters", &self.parameters);
        formatter.finish()
    }
}
/// See [`MaintenanceWindowAutomationParameters`](crate::model::MaintenanceWindowAutomationParameters)
pub mod maintenance_window_automation_parameters {
    /// A builder for [`MaintenanceWindowAutomationParameters`](crate::model::MaintenanceWindowAutomationParameters)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_version: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
    }
    impl Builder {
        /// <p>The version of an Automation document to use during task execution.</p>
        pub fn document_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_version = Some(input.into());
            self
        }
        pub fn set_document_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_version = input;
            self
        }
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`MaintenanceWindowAutomationParameters`](crate::model::MaintenanceWindowAutomationParameters)
        pub fn build(self) -> crate::model::MaintenanceWindowAutomationParameters {
            crate::model::MaintenanceWindowAutomationParameters {
                document_version: self.document_version,
                parameters: self.parameters,
            }
        }
    }
}
impl MaintenanceWindowAutomationParameters {
    /// Creates a new builder-style object to manufacture [`MaintenanceWindowAutomationParameters`](crate::model::MaintenanceWindowAutomationParameters)
    pub fn builder() -> crate::model::maintenance_window_automation_parameters::Builder {
        crate::model::maintenance_window_automation_parameters::Builder::default()
    }
}

/// <p>The parameters for a RUN_COMMAND task type.</p>
/// <p>For information about specifying and updating task parameters, see <a>RegisterTaskWithMaintenanceWindow</a> and <a>UpdateMaintenanceWindowTask</a>.</p>
/// <note>
/// <p>
/// <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the
/// <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure.
/// For information about how Systems Manager handles these options for the supported maintenance
/// window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
/// <p>
/// <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs,
/// instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information
/// about how Systems Manager handles these options for the supported maintenance window task
/// types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
/// <p>For Run Command tasks, Systems Manager uses specified values for <code>TaskParameters</code> and
/// <code>LoggingInfo</code> only if no values are specified for
/// <code>TaskInvocationParameters</code>. </p>
/// </note>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MaintenanceWindowRunCommandParameters {
    /// <p>Information about the commands to run.</p>
    #[serde(rename = "Comment")]
    #[serde(default)]
    pub comment: std::option::Option<std::string::String>,
    /// <p>Configuration options for sending command output to CloudWatch Logs.</p>
    #[serde(rename = "CloudWatchOutputConfig")]
    #[serde(default)]
    pub cloud_watch_output_config: std::option::Option<crate::model::CloudWatchOutputConfig>,
    /// <p>The SHA-256 or SHA-1 hash created by the system when the document was created. SHA-1 hashes
    /// have been deprecated.</p>
    #[serde(rename = "DocumentHash")]
    #[serde(default)]
    pub document_hash: std::option::Option<std::string::String>,
    /// <p>SHA-256 or SHA-1. SHA-1 hashes have been deprecated.</p>
    #[serde(rename = "DocumentHashType")]
    #[serde(default)]
    pub document_hash_type: std::option::Option<crate::model::DocumentHashType>,
    /// <p>The SSM document version to use in the request. You can specify $DEFAULT, $LATEST, or a
    /// specific version number. If you run commands by using the AWS CLI, then you must escape the first
    /// two options by using a backslash. If you specify a version number, then you don't need to use the
    /// backslash. For example:</p>
    /// <p>--document-version "\$DEFAULT"</p>
    /// <p>--document-version "\$LATEST"</p>
    /// <p>--document-version "3"</p>
    #[serde(rename = "DocumentVersion")]
    #[serde(default)]
    pub document_version: std::option::Option<std::string::String>,
    /// <p>Configurations for sending notifications about command status changes on a per-instance
    /// basis.</p>
    #[serde(rename = "NotificationConfig")]
    #[serde(default)]
    pub notification_config: std::option::Option<crate::model::NotificationConfig>,
    /// <p>The name of the S3 bucket.</p>
    #[serde(rename = "OutputS3BucketName")]
    #[serde(default)]
    pub output_s3_bucket_name: std::option::Option<std::string::String>,
    /// <p>The S3 bucket subfolder.</p>
    #[serde(rename = "OutputS3KeyPrefix")]
    #[serde(default)]
    pub output_s3_key_prefix: std::option::Option<std::string::String>,
    /// <p>The parameters for the RUN_COMMAND task execution.</p>
    #[serde(rename = "Parameters")]
    #[serde(default)]
    pub parameters: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The ARN of the IAM service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for
    /// maintenance window Run Command tasks.</p>
    #[serde(rename = "ServiceRoleArn")]
    #[serde(default)]
    pub service_role_arn: std::option::Option<std::string::String>,
    /// <p>If this time is reached and the command has not already started running, it doesn't
    /// run.</p>
    #[serde(rename = "TimeoutSeconds")]
    #[serde(default)]
    pub timeout_seconds: std::option::Option<i32>,
}
impl std::fmt::Debug for MaintenanceWindowRunCommandParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaintenanceWindowRunCommandParameters");
        formatter.field("comment", &self.comment);
        formatter.field("cloud_watch_output_config", &self.cloud_watch_output_config);
        formatter.field("document_hash", &self.document_hash);
        formatter.field("document_hash_type", &self.document_hash_type);
        formatter.field("document_version", &self.document_version);
        formatter.field("notification_config", &self.notification_config);
        formatter.field("output_s3_bucket_name", &self.output_s3_bucket_name);
        formatter.field("output_s3_key_prefix", &self.output_s3_key_prefix);
        formatter.field("parameters", &self.parameters);
        formatter.field("service_role_arn", &self.service_role_arn);
        formatter.field("timeout_seconds", &self.timeout_seconds);
        formatter.finish()
    }
}
/// See [`MaintenanceWindowRunCommandParameters`](crate::model::MaintenanceWindowRunCommandParameters)
pub mod maintenance_window_run_command_parameters {
    /// A builder for [`MaintenanceWindowRunCommandParameters`](crate::model::MaintenanceWindowRunCommandParameters)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) comment: std::option::Option<std::string::String>,
        pub(crate) cloud_watch_output_config:
            std::option::Option<crate::model::CloudWatchOutputConfig>,
        pub(crate) document_hash: std::option::Option<std::string::String>,
        pub(crate) document_hash_type: std::option::Option<crate::model::DocumentHashType>,
        pub(crate) document_version: std::option::Option<std::string::String>,
        pub(crate) notification_config: std::option::Option<crate::model::NotificationConfig>,
        pub(crate) output_s3_bucket_name: std::option::Option<std::string::String>,
        pub(crate) output_s3_key_prefix: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) service_role_arn: std::option::Option<std::string::String>,
        pub(crate) timeout_seconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Information about the commands to run.</p>
        pub fn comment(mut self, input: impl Into<std::string::String>) -> Self {
            self.comment = Some(input.into());
            self
        }
        pub fn set_comment(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.comment = input;
            self
        }
        /// <p>Configuration options for sending command output to CloudWatch Logs.</p>
        pub fn cloud_watch_output_config(
            mut self,
            input: crate::model::CloudWatchOutputConfig,
        ) -> Self {
            self.cloud_watch_output_config = Some(input);
            self
        }
        pub fn set_cloud_watch_output_config(
            mut self,
            input: std::option::Option<crate::model::CloudWatchOutputConfig>,
        ) -> Self {
            self.cloud_watch_output_config = input;
            self
        }
        /// <p>The SHA-256 or SHA-1 hash created by the system when the document was created. SHA-1 hashes
        /// have been deprecated.</p>
        pub fn document_hash(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_hash = Some(input.into());
            self
        }
        pub fn set_document_hash(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_hash = input;
            self
        }
        /// <p>SHA-256 or SHA-1. SHA-1 hashes have been deprecated.</p>
        pub fn document_hash_type(mut self, input: crate::model::DocumentHashType) -> Self {
            self.document_hash_type = Some(input);
            self
        }
        pub fn set_document_hash_type(
            mut self,
            input: std::option::Option<crate::model::DocumentHashType>,
        ) -> Self {
            self.document_hash_type = input;
            self
        }
        /// <p>The SSM document version to use in the request. You can specify $DEFAULT, $LATEST, or a
        /// specific version number. If you run commands by using the AWS CLI, then you must escape the first
        /// two options by using a backslash. If you specify a version number, then you don't need to use the
        /// backslash. For example:</p>
        /// <p>--document-version "\$DEFAULT"</p>
        /// <p>--document-version "\$LATEST"</p>
        /// <p>--document-version "3"</p>
        pub fn document_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_version = Some(input.into());
            self
        }
        pub fn set_document_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_version = input;
            self
        }
        /// <p>Configurations for sending notifications about command status changes on a per-instance
        /// basis.</p>
        pub fn notification_config(mut self, input: crate::model::NotificationConfig) -> Self {
            self.notification_config = Some(input);
            self
        }
        pub fn set_notification_config(
            mut self,
            input: std::option::Option<crate::model::NotificationConfig>,
        ) -> Self {
            self.notification_config = input;
            self
        }
        /// <p>The name of the S3 bucket.</p>
        pub fn output_s3_bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_s3_bucket_name = Some(input.into());
            self
        }
        pub fn set_output_s3_bucket_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_s3_bucket_name = input;
            self
        }
        /// <p>The S3 bucket subfolder.</p>
        pub fn output_s3_key_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_s3_key_prefix = Some(input.into());
            self
        }
        pub fn set_output_s3_key_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_s3_key_prefix = input;
            self
        }
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// <p>The ARN of the IAM service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for
        /// maintenance window Run Command tasks.</p>
        pub fn service_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_role_arn = Some(input.into());
            self
        }
        pub fn set_service_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.service_role_arn = input;
            self
        }
        /// <p>If this time is reached and the command has not already started running, it doesn't
        /// run.</p>
        pub fn timeout_seconds(mut self, input: i32) -> Self {
            self.timeout_seconds = Some(input);
            self
        }
        pub fn set_timeout_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.timeout_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`MaintenanceWindowRunCommandParameters`](crate::model::MaintenanceWindowRunCommandParameters)
        pub fn build(self) -> crate::model::MaintenanceWindowRunCommandParameters {
            crate::model::MaintenanceWindowRunCommandParameters {
                comment: self.comment,
                cloud_watch_output_config: self.cloud_watch_output_config,
                document_hash: self.document_hash,
                document_hash_type: self.document_hash_type,
                document_version: self.document_version,
                notification_config: self.notification_config,
                output_s3_bucket_name: self.output_s3_bucket_name,
                output_s3_key_prefix: self.output_s3_key_prefix,
                parameters: self.parameters,
                service_role_arn: self.service_role_arn,
                timeout_seconds: self.timeout_seconds,
            }
        }
    }
}
impl MaintenanceWindowRunCommandParameters {
    /// Creates a new builder-style object to manufacture [`MaintenanceWindowRunCommandParameters`](crate::model::MaintenanceWindowRunCommandParameters)
    pub fn builder() -> crate::model::maintenance_window_run_command_parameters::Builder {
        crate::model::maintenance_window_run_command_parameters::Builder::default()
    }
}

/// <p>Configurations for sending notifications.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct NotificationConfig {
    /// <p>An Amazon Resource Name (ARN) for an Amazon Simple Notification Service (Amazon SNS) topic. Run Command pushes
    /// notifications about command status changes to this topic.</p>
    #[serde(rename = "NotificationArn")]
    #[serde(default)]
    pub notification_arn: std::option::Option<std::string::String>,
    /// <p>The different events for which you can receive notifications. These events include the
    /// following: All (events), InProgress, Success, TimedOut, Cancelled, Failed. To learn more about
    /// these events, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/monitoring-sns-notifications.html">Monitoring Systems
    /// Manager status changes using Amazon SNS notifications</a> in the
    /// <i>AWS Systems Manager User Guide</i>.</p>
    #[serde(rename = "NotificationEvents")]
    #[serde(default)]
    pub notification_events: std::option::Option<std::vec::Vec<crate::model::NotificationEvent>>,
    /// <p>Command: Receive notification when the status of a command changes. Invocation: For commands
    /// sent to multiple instances, receive notification on a per-instance basis when the status of a
    /// command changes. </p>
    #[serde(rename = "NotificationType")]
    #[serde(default)]
    pub notification_type: std::option::Option<crate::model::NotificationType>,
}
impl std::fmt::Debug for NotificationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotificationConfig");
        formatter.field("notification_arn", &self.notification_arn);
        formatter.field("notification_events", &self.notification_events);
        formatter.field("notification_type", &self.notification_type);
        formatter.finish()
    }
}
/// See [`NotificationConfig`](crate::model::NotificationConfig)
pub mod notification_config {
    /// A builder for [`NotificationConfig`](crate::model::NotificationConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) notification_arn: std::option::Option<std::string::String>,
        pub(crate) notification_events:
            std::option::Option<std::vec::Vec<crate::model::NotificationEvent>>,
        pub(crate) notification_type: std::option::Option<crate::model::NotificationType>,
    }
    impl Builder {
        /// <p>An Amazon Resource Name (ARN) for an Amazon Simple Notification Service (Amazon SNS) topic. Run Command pushes
        /// notifications about command status changes to this topic.</p>
        pub fn notification_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.notification_arn = Some(input.into());
            self
        }
        pub fn set_notification_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.notification_arn = input;
            self
        }
        pub fn notification_events(
            mut self,
            input: impl Into<crate::model::NotificationEvent>,
        ) -> Self {
            let mut v = self.notification_events.unwrap_or_default();
            v.push(input.into());
            self.notification_events = Some(v);
            self
        }
        pub fn set_notification_events(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NotificationEvent>>,
        ) -> Self {
            self.notification_events = input;
            self
        }
        /// <p>Command: Receive notification when the status of a command changes. Invocation: For commands
        /// sent to multiple instances, receive notification on a per-instance basis when the status of a
        /// command changes. </p>
        pub fn notification_type(mut self, input: crate::model::NotificationType) -> Self {
            self.notification_type = Some(input);
            self
        }
        pub fn set_notification_type(
            mut self,
            input: std::option::Option<crate::model::NotificationType>,
        ) -> Self {
            self.notification_type = input;
            self
        }
        /// Consumes the builder and constructs a [`NotificationConfig`](crate::model::NotificationConfig)
        pub fn build(self) -> crate::model::NotificationConfig {
            crate::model::NotificationConfig {
                notification_arn: self.notification_arn,
                notification_events: self.notification_events,
                notification_type: self.notification_type,
            }
        }
    }
}
impl NotificationConfig {
    /// Creates a new builder-style object to manufacture [`NotificationConfig`](crate::model::NotificationConfig)
    pub fn builder() -> crate::model::notification_config::Builder {
        crate::model::notification_config::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NotificationType {
    Command,
    Invocation,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NotificationType {
    fn from(s: &str) -> Self {
        match s {
            "Command" => NotificationType::Command,
            "Invocation" => NotificationType::Invocation,
            other => NotificationType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NotificationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(NotificationType::from(s))
    }
}
impl NotificationType {
    pub fn as_str(&self) -> &str {
        match self {
            NotificationType::Command => "Command",
            NotificationType::Invocation => "Invocation",
            NotificationType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for NotificationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for NotificationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NotificationEvent {
    All,
    Cancelled,
    Failed,
    InProgress,
    Success,
    TimedOut,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NotificationEvent {
    fn from(s: &str) -> Self {
        match s {
            "All" => NotificationEvent::All,
            "Cancelled" => NotificationEvent::Cancelled,
            "Failed" => NotificationEvent::Failed,
            "InProgress" => NotificationEvent::InProgress,
            "Success" => NotificationEvent::Success,
            "TimedOut" => NotificationEvent::TimedOut,
            other => NotificationEvent::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NotificationEvent {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(NotificationEvent::from(s))
    }
}
impl NotificationEvent {
    pub fn as_str(&self) -> &str {
        match self {
            NotificationEvent::All => "All",
            NotificationEvent::Cancelled => "Cancelled",
            NotificationEvent::Failed => "Failed",
            NotificationEvent::InProgress => "InProgress",
            NotificationEvent::Success => "Success",
            NotificationEvent::TimedOut => "TimedOut",
            NotificationEvent::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for NotificationEvent {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for NotificationEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DocumentHashType {
    Sha1,
    Sha256,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DocumentHashType {
    fn from(s: &str) -> Self {
        match s {
            "Sha1" => DocumentHashType::Sha1,
            "Sha256" => DocumentHashType::Sha256,
            other => DocumentHashType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DocumentHashType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(DocumentHashType::from(s))
    }
}
impl DocumentHashType {
    pub fn as_str(&self) -> &str {
        match self {
            DocumentHashType::Sha1 => "Sha1",
            DocumentHashType::Sha256 => "Sha256",
            DocumentHashType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for DocumentHashType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for DocumentHashType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Configuration options for sending command output to CloudWatch Logs.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CloudWatchOutputConfig {
    /// <p>The name of the CloudWatch log group where you want to send command output. If you don't
    /// specify a group name, Systems Manager automatically creates a log group for you. The log group uses the
    /// following naming format: aws/ssm/<i>SystemsManagerDocumentName</i>.</p>
    #[serde(rename = "CloudWatchLogGroupName")]
    #[serde(default)]
    pub cloud_watch_log_group_name: std::option::Option<std::string::String>,
    /// <p>Enables Systems Manager to send command output to CloudWatch Logs.</p>
    #[serde(rename = "CloudWatchOutputEnabled")]
    #[serde(default)]
    pub cloud_watch_output_enabled: bool,
}
impl std::fmt::Debug for CloudWatchOutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CloudWatchOutputConfig");
        formatter.field(
            "cloud_watch_log_group_name",
            &self.cloud_watch_log_group_name,
        );
        formatter.field(
            "cloud_watch_output_enabled",
            &self.cloud_watch_output_enabled,
        );
        formatter.finish()
    }
}
/// See [`CloudWatchOutputConfig`](crate::model::CloudWatchOutputConfig)
pub mod cloud_watch_output_config {
    /// A builder for [`CloudWatchOutputConfig`](crate::model::CloudWatchOutputConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cloud_watch_log_group_name: std::option::Option<std::string::String>,
        pub(crate) cloud_watch_output_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the CloudWatch log group where you want to send command output. If you don't
        /// specify a group name, Systems Manager automatically creates a log group for you. The log group uses the
        /// following naming format: aws/ssm/<i>SystemsManagerDocumentName</i>.</p>
        pub fn cloud_watch_log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.cloud_watch_log_group_name = Some(input.into());
            self
        }
        pub fn set_cloud_watch_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cloud_watch_log_group_name = input;
            self
        }
        /// <p>Enables Systems Manager to send command output to CloudWatch Logs.</p>
        pub fn cloud_watch_output_enabled(mut self, input: bool) -> Self {
            self.cloud_watch_output_enabled = Some(input);
            self
        }
        pub fn set_cloud_watch_output_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.cloud_watch_output_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`CloudWatchOutputConfig`](crate::model::CloudWatchOutputConfig)
        pub fn build(self) -> crate::model::CloudWatchOutputConfig {
            crate::model::CloudWatchOutputConfig {
                cloud_watch_log_group_name: self.cloud_watch_log_group_name,
                cloud_watch_output_enabled: self.cloud_watch_output_enabled.unwrap_or_default(),
            }
        }
    }
}
impl CloudWatchOutputConfig {
    /// Creates a new builder-style object to manufacture [`CloudWatchOutputConfig`](crate::model::CloudWatchOutputConfig)
    pub fn builder() -> crate::model::cloud_watch_output_config::Builder {
        crate::model::cloud_watch_output_config::Builder::default()
    }
}

/// <p>Defines the values for a task parameter.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MaintenanceWindowTaskParameterValueExpression {
    /// <p>This field contains an array of 0 or more strings, each 1 to 255 characters in
    /// length.</p>
    #[serde(rename = "Values")]
    #[serde(default)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for MaintenanceWindowTaskParameterValueExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaintenanceWindowTaskParameterValueExpression");
        formatter.field("values", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`MaintenanceWindowTaskParameterValueExpression`](crate::model::MaintenanceWindowTaskParameterValueExpression)
pub mod maintenance_window_task_parameter_value_expression {
    /// A builder for [`MaintenanceWindowTaskParameterValueExpression`](crate::model::MaintenanceWindowTaskParameterValueExpression)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`MaintenanceWindowTaskParameterValueExpression`](crate::model::MaintenanceWindowTaskParameterValueExpression)
        pub fn build(self) -> crate::model::MaintenanceWindowTaskParameterValueExpression {
            crate::model::MaintenanceWindowTaskParameterValueExpression {
                values: self.values,
            }
        }
    }
}
impl MaintenanceWindowTaskParameterValueExpression {
    /// Creates a new builder-style object to manufacture [`MaintenanceWindowTaskParameterValueExpression`](crate::model::MaintenanceWindowTaskParameterValueExpression)
    pub fn builder() -> crate::model::maintenance_window_task_parameter_value_expression::Builder {
        crate::model::maintenance_window_task_parameter_value_expression::Builder::default()
    }
}

/// <p>An array of search criteria that targets instances using a Key,Value combination that you
/// specify.</p>
/// <note>
/// <p> One or more targets must be specified for maintenance window Run Command-type tasks.
/// Depending on the task, targets are optional for other maintenance window task types (Automation,
/// AWS Lambda, and AWS Step Functions). For more information about running tasks that do not
/// specify targets, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html">Registering
/// maintenance window tasks without targets</a> in the
/// <i>AWS Systems Manager User Guide</i>.</p>
/// </note>
/// <p>Supported formats include the following.</p>
/// <ul>
/// <li>
/// <p>
/// <code>Key=InstanceIds,Values=<i>instance-id-1</i>,<i>instance-id-2</i>,<i>instance-id-3</i>
/// </code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>Key=tag:<i>my-tag-key</i>,Values=<i>my-tag-value-1</i>,<i>my-tag-value-2</i>
/// </code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>Key=tag-key,Values=<i>my-tag-key-1</i>,<i>my-tag-key-2</i>
/// </code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <b>Run Command and Maintenance window targets only</b>:
/// <code>Key=resource-groups:Name,Values=<i>resource-group-name</i>
/// </code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <b>Maintenance window targets only</b>:
/// <code>Key=resource-groups:ResourceTypeFilters,Values=<i>resource-type-1</i>,<i>resource-type-2</i>
/// </code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <b>Automation targets only</b>:
/// <code>Key=ResourceGroup;Values=<i>resource-group-name</i>
/// </code>
/// </p>
/// </li>
/// </ul>
/// <p>For example:</p>
/// <ul>
/// <li>
/// <p>
/// <code>Key=InstanceIds,Values=i-02573cafcfEXAMPLE,i-0471e04240EXAMPLE,i-07782c72faEXAMPLE</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>Key=tag:CostCenter,Values=CostCenter1,CostCenter2,CostCenter3</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>Key=tag-key,Values=Name,Instance-Type,CostCenter</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <b>Run Command and Maintenance window targets only</b>:
/// <code>Key=resource-groups:Name,Values=ProductionResourceGroup</code>
/// </p>
/// <p>This example demonstrates how to target all resources in the resource group <b>ProductionResourceGroup</b> in your maintenance window.</p>
/// </li>
/// <li>
/// <p>
/// <b>Maintenance window targets only</b>:
/// <code>Key=resource-groups:ResourceTypeFilters,Values=<i>AWS::EC2::INSTANCE</i>,<i>AWS::EC2::VPC</i>
/// </code>
/// </p>
/// <p>This example demonstrates how to target only EC2 instances and VPCs in your maintenance
/// window.</p>
/// </li>
/// <li>
/// <p>
/// <b>Automation targets only</b>:
/// <code>Key=ResourceGroup,Values=MyResourceGroup</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <b>State Manager association targets only</b>:
/// <code>Key=InstanceIds,Values=<i>*</i>
/// </code>
/// </p>
/// <p>This example demonstrates how to target all managed instances in the AWS Region where the
/// association was created.</p>
/// </li>
/// </ul>
/// <p>For more information about how to send commands that target instances using
/// <code>Key,Value</code> parameters, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html#send-commands-targeting">Targeting multiple instances</a> in the <i>AWS Systems Manager User Guide</i>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct Target {
    /// <p>User-defined criteria for sending commands that target instances that meet the
    /// criteria.</p>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<std::string::String>,
    /// <p>User-defined criteria that maps to <code>Key</code>. For example, if you specified
    /// <code>tag:ServerRole</code>, you could specify <code>value:WebServer</code> to run a command on
    /// instances that include EC2 tags of <code>ServerRole,WebServer</code>. </p>
    /// <p>Depending on the type of <code>Target</code>, the maximum number of values for a
    /// <code>Key</code> might be lower than the global maximum of 50.</p>
    #[serde(rename = "Values")]
    #[serde(default)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for Target {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Target");
        formatter.field("key", &self.key);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`Target`](crate::model::Target)
pub mod target {
    /// A builder for [`Target`](crate::model::Target)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>User-defined criteria for sending commands that target instances that meet the
        /// criteria.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`Target`](crate::model::Target)
        pub fn build(self) -> crate::model::Target {
            crate::model::Target {
                key: self.key,
                values: self.values,
            }
        }
    }
}
impl Target {
    /// Creates a new builder-style object to manufacture [`Target`](crate::model::Target)
    pub fn builder() -> crate::model::target::Builder {
        crate::model::target::Builder::default()
    }
}

/// <p>Information about a document approval review.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DocumentReviews {
    /// <p>The action to take on a document approval review request.</p>
    #[serde(rename = "Action")]
    #[serde(default)]
    pub action: std::option::Option<crate::model::DocumentReviewAction>,
    /// <p>A comment entered by a user in your organization about the document review request.</p>
    #[serde(rename = "Comment")]
    #[serde(default)]
    pub comment: std::option::Option<std::vec::Vec<crate::model::DocumentReviewCommentSource>>,
}
impl std::fmt::Debug for DocumentReviews {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DocumentReviews");
        formatter.field("action", &self.action);
        formatter.field("comment", &self.comment);
        formatter.finish()
    }
}
/// See [`DocumentReviews`](crate::model::DocumentReviews)
pub mod document_reviews {
    /// A builder for [`DocumentReviews`](crate::model::DocumentReviews)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action: std::option::Option<crate::model::DocumentReviewAction>,
        pub(crate) comment:
            std::option::Option<std::vec::Vec<crate::model::DocumentReviewCommentSource>>,
    }
    impl Builder {
        /// <p>The action to take on a document approval review request.</p>
        pub fn action(mut self, input: crate::model::DocumentReviewAction) -> Self {
            self.action = Some(input);
            self
        }
        pub fn set_action(
            mut self,
            input: std::option::Option<crate::model::DocumentReviewAction>,
        ) -> Self {
            self.action = input;
            self
        }
        pub fn comment(
            mut self,
            input: impl Into<crate::model::DocumentReviewCommentSource>,
        ) -> Self {
            let mut v = self.comment.unwrap_or_default();
            v.push(input.into());
            self.comment = Some(v);
            self
        }
        pub fn set_comment(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DocumentReviewCommentSource>>,
        ) -> Self {
            self.comment = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentReviews`](crate::model::DocumentReviews)
        pub fn build(self) -> crate::model::DocumentReviews {
            crate::model::DocumentReviews {
                action: self.action,
                comment: self.comment,
            }
        }
    }
}
impl DocumentReviews {
    /// Creates a new builder-style object to manufacture [`DocumentReviews`](crate::model::DocumentReviews)
    pub fn builder() -> crate::model::document_reviews::Builder {
        crate::model::document_reviews::Builder::default()
    }
}

/// <p>Information about comments added to a document review request.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DocumentReviewCommentSource {
    /// <p>The type of information added to a review request. Currently, only the value
    /// <code>Comment</code> is supported.</p>
    #[serde(rename = "Type")]
    #[serde(default)]
    pub r#type: std::option::Option<crate::model::DocumentReviewCommentType>,
    /// <p>The content of a comment entered by a user who requests a review of a new document version,
    /// or who reviews the new version.</p>
    #[serde(rename = "Content")]
    #[serde(default)]
    pub content: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DocumentReviewCommentSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DocumentReviewCommentSource");
        formatter.field("r#type", &self.r#type);
        formatter.field("content", &self.content);
        formatter.finish()
    }
}
/// See [`DocumentReviewCommentSource`](crate::model::DocumentReviewCommentSource)
pub mod document_review_comment_source {
    /// A builder for [`DocumentReviewCommentSource`](crate::model::DocumentReviewCommentSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::DocumentReviewCommentType>,
        pub(crate) content: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of information added to a review request. Currently, only the value
        /// <code>Comment</code> is supported.</p>
        pub fn r#type(mut self, input: crate::model::DocumentReviewCommentType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::DocumentReviewCommentType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The content of a comment entered by a user who requests a review of a new document version,
        /// or who reviews the new version.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentReviewCommentSource`](crate::model::DocumentReviewCommentSource)
        pub fn build(self) -> crate::model::DocumentReviewCommentSource {
            crate::model::DocumentReviewCommentSource {
                r#type: self.r#type,
                content: self.content,
            }
        }
    }
}
impl DocumentReviewCommentSource {
    /// Creates a new builder-style object to manufacture [`DocumentReviewCommentSource`](crate::model::DocumentReviewCommentSource)
    pub fn builder() -> crate::model::document_review_comment_source::Builder {
        crate::model::document_review_comment_source::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DocumentReviewCommentType {
    Comment,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DocumentReviewCommentType {
    fn from(s: &str) -> Self {
        match s {
            "Comment" => DocumentReviewCommentType::Comment,
            other => DocumentReviewCommentType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DocumentReviewCommentType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(DocumentReviewCommentType::from(s))
    }
}
impl DocumentReviewCommentType {
    pub fn as_str(&self) -> &str {
        match self {
            DocumentReviewCommentType::Comment => "Comment",
            DocumentReviewCommentType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for DocumentReviewCommentType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for DocumentReviewCommentType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DocumentReviewAction {
    Approve,
    Reject,
    SendForReview,
    UpdateReview,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DocumentReviewAction {
    fn from(s: &str) -> Self {
        match s {
            "Approve" => DocumentReviewAction::Approve,
            "Reject" => DocumentReviewAction::Reject,
            "SendForReview" => DocumentReviewAction::SendForReview,
            "UpdateReview" => DocumentReviewAction::UpdateReview,
            other => DocumentReviewAction::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DocumentReviewAction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(DocumentReviewAction::from(s))
    }
}
impl DocumentReviewAction {
    pub fn as_str(&self) -> &str {
        match self {
            DocumentReviewAction::Approve => "Approve",
            DocumentReviewAction::Reject => "Reject",
            DocumentReviewAction::SendForReview => "SendForReview",
            DocumentReviewAction::UpdateReview => "UpdateReview",
            DocumentReviewAction::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for DocumentReviewAction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for DocumentReviewAction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>A default version of a document.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DocumentDefaultVersionDescription {
    /// <p>The name of the document.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The default version of the document.</p>
    #[serde(rename = "DefaultVersion")]
    #[serde(default)]
    pub default_version: std::option::Option<std::string::String>,
    /// <p>The default version of the artifact associated with the document.</p>
    #[serde(rename = "DefaultVersionName")]
    #[serde(default)]
    pub default_version_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DocumentDefaultVersionDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DocumentDefaultVersionDescription");
        formatter.field("name", &self.name);
        formatter.field("default_version", &self.default_version);
        formatter.field("default_version_name", &self.default_version_name);
        formatter.finish()
    }
}
/// See [`DocumentDefaultVersionDescription`](crate::model::DocumentDefaultVersionDescription)
pub mod document_default_version_description {
    /// A builder for [`DocumentDefaultVersionDescription`](crate::model::DocumentDefaultVersionDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) default_version: std::option::Option<std::string::String>,
        pub(crate) default_version_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the document.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The default version of the document.</p>
        pub fn default_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_version = Some(input.into());
            self
        }
        pub fn set_default_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_version = input;
            self
        }
        /// <p>The default version of the artifact associated with the document.</p>
        pub fn default_version_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_version_name = Some(input.into());
            self
        }
        pub fn set_default_version_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_version_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentDefaultVersionDescription`](crate::model::DocumentDefaultVersionDescription)
        pub fn build(self) -> crate::model::DocumentDefaultVersionDescription {
            crate::model::DocumentDefaultVersionDescription {
                name: self.name,
                default_version: self.default_version,
                default_version_name: self.default_version_name,
            }
        }
    }
}
impl DocumentDefaultVersionDescription {
    /// Creates a new builder-style object to manufacture [`DocumentDefaultVersionDescription`](crate::model::DocumentDefaultVersionDescription)
    pub fn builder() -> crate::model::document_default_version_description::Builder {
        crate::model::document_default_version_description::Builder::default()
    }
}

/// <p>Describes a Systems Manager document. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DocumentDescription {
    /// <p>The SHA1 hash of the document, which you can use for verification.</p>
    #[serde(rename = "Sha1")]
    #[serde(default)]
    pub sha1: std::option::Option<std::string::String>,
    /// <p>The Sha256 or Sha1 hash created by the system when the document was created. </p>
    /// <note>
    /// <p>Sha1 hashes have been deprecated.</p>
    /// </note>
    #[serde(rename = "Hash")]
    #[serde(default)]
    pub hash: std::option::Option<std::string::String>,
    /// <p>The hash type of the document. Valid values include <code>Sha256</code> or
    /// <code>Sha1</code>.</p>
    /// <note>
    /// <p>Sha1 hashes have been deprecated.</p>
    /// </note>
    #[serde(rename = "HashType")]
    #[serde(default)]
    pub hash_type: std::option::Option<crate::model::DocumentHashType>,
    /// <p>The name of the Systems Manager document.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The friendly name of the Systems Manager document. This value can differ for each version of the
    /// document. If you want to update this value, see <a>UpdateDocument</a>.</p>
    #[serde(rename = "DisplayName")]
    #[serde(default)]
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The version of the artifact associated with the document.</p>
    #[serde(rename = "VersionName")]
    #[serde(default)]
    pub version_name: std::option::Option<std::string::String>,
    /// <p>The AWS user account that created the document.</p>
    #[serde(rename = "Owner")]
    #[serde(default)]
    pub owner: std::option::Option<std::string::String>,
    /// <p>The date when the document was created.</p>
    #[serde(rename = "CreatedDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub created_date: std::option::Option<smithy_types::Instant>,
    /// <p>The status of the Systems Manager document.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::DocumentStatus>,
    /// <p>A message returned by AWS Systems Manager that explains the <code>Status</code> value. For example, a
    /// <code>Failed</code> status might be explained by the <code>StatusInformation</code> message,
    /// "The specified S3 bucket does not exist. Verify that the URL of the S3 bucket is correct."</p>
    #[serde(rename = "StatusInformation")]
    #[serde(default)]
    pub status_information: std::option::Option<std::string::String>,
    /// <p>The document version.</p>
    #[serde(rename = "DocumentVersion")]
    #[serde(default)]
    pub document_version: std::option::Option<std::string::String>,
    /// <p>A description of the document. </p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>A description of the parameters for a document.</p>
    #[serde(rename = "Parameters")]
    #[serde(default)]
    pub parameters: std::option::Option<std::vec::Vec<crate::model::DocumentParameter>>,
    /// <p>The list of OS platforms compatible with this Systems Manager document. </p>
    #[serde(rename = "PlatformTypes")]
    #[serde(default)]
    pub platform_types: std::option::Option<std::vec::Vec<crate::model::PlatformType>>,
    /// <p>The type of document.</p>
    #[serde(rename = "DocumentType")]
    #[serde(default)]
    pub document_type: std::option::Option<crate::model::DocumentType>,
    /// <p>The schema version.</p>
    #[serde(rename = "SchemaVersion")]
    #[serde(default)]
    pub schema_version: std::option::Option<std::string::String>,
    /// <p>The latest version of the document.</p>
    #[serde(rename = "LatestVersion")]
    #[serde(default)]
    pub latest_version: std::option::Option<std::string::String>,
    /// <p>The default version.</p>
    #[serde(rename = "DefaultVersion")]
    #[serde(default)]
    pub default_version: std::option::Option<std::string::String>,
    /// <p>The document format, either JSON or YAML.</p>
    #[serde(rename = "DocumentFormat")]
    #[serde(default)]
    pub document_format: std::option::Option<crate::model::DocumentFormat>,
    /// <p>The target type which defines the kinds of resources the document can run on. For example,
    /// /AWS::EC2::Instance. For a list of valid resource types, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">AWS resource and property types
    /// reference</a> in the <i>AWS CloudFormation User Guide</i>. </p>
    #[serde(rename = "TargetType")]
    #[serde(default)]
    pub target_type: std::option::Option<std::string::String>,
    /// <p>The tags, or metadata, that have been applied to the document.</p>
    #[serde(rename = "Tags")]
    #[serde(default)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Details about the document attachments, including names, locations, sizes, and so on.</p>
    #[serde(rename = "AttachmentsInformation")]
    #[serde(default)]
    pub attachments_information:
        std::option::Option<std::vec::Vec<crate::model::AttachmentInformation>>,
    /// <p>A list of SSM documents required by a document. For example, an
    /// <code>ApplicationConfiguration</code> document requires an
    /// <code>ApplicationConfigurationSchema</code> document.</p>
    #[serde(rename = "Requires")]
    #[serde(default)]
    pub requires: std::option::Option<std::vec::Vec<crate::model::DocumentRequires>>,
    /// <p>The user in your organization who created the document.</p>
    #[serde(rename = "Author")]
    #[serde(default)]
    pub author: std::option::Option<std::string::String>,
    /// <p>Details about the review of a document.</p>
    #[serde(rename = "ReviewInformation")]
    #[serde(default)]
    pub review_information: std::option::Option<std::vec::Vec<crate::model::ReviewInformation>>,
    /// <p>The version of the document currently approved for use in the organization.</p>
    #[serde(rename = "ApprovedVersion")]
    #[serde(default)]
    pub approved_version: std::option::Option<std::string::String>,
    /// <p>The version of the document that is currently under review.</p>
    #[serde(rename = "PendingReviewVersion")]
    #[serde(default)]
    pub pending_review_version: std::option::Option<std::string::String>,
    /// <p>The current status of the review.</p>
    #[serde(rename = "ReviewStatus")]
    #[serde(default)]
    pub review_status: std::option::Option<crate::model::ReviewStatus>,
}
impl std::fmt::Debug for DocumentDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DocumentDescription");
        formatter.field("sha1", &self.sha1);
        formatter.field("hash", &self.hash);
        formatter.field("hash_type", &self.hash_type);
        formatter.field("name", &self.name);
        formatter.field("display_name", &self.display_name);
        formatter.field("version_name", &self.version_name);
        formatter.field("owner", &self.owner);
        formatter.field("created_date", &self.created_date);
        formatter.field("status", &self.status);
        formatter.field("status_information", &self.status_information);
        formatter.field("document_version", &self.document_version);
        formatter.field("description", &self.description);
        formatter.field("parameters", &self.parameters);
        formatter.field("platform_types", &self.platform_types);
        formatter.field("document_type", &self.document_type);
        formatter.field("schema_version", &self.schema_version);
        formatter.field("latest_version", &self.latest_version);
        formatter.field("default_version", &self.default_version);
        formatter.field("document_format", &self.document_format);
        formatter.field("target_type", &self.target_type);
        formatter.field("tags", &self.tags);
        formatter.field("attachments_information", &self.attachments_information);
        formatter.field("requires", &self.requires);
        formatter.field("author", &self.author);
        formatter.field("review_information", &self.review_information);
        formatter.field("approved_version", &self.approved_version);
        formatter.field("pending_review_version", &self.pending_review_version);
        formatter.field("review_status", &self.review_status);
        formatter.finish()
    }
}
/// See [`DocumentDescription`](crate::model::DocumentDescription)
pub mod document_description {
    /// A builder for [`DocumentDescription`](crate::model::DocumentDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sha1: std::option::Option<std::string::String>,
        pub(crate) hash: std::option::Option<std::string::String>,
        pub(crate) hash_type: std::option::Option<crate::model::DocumentHashType>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) version_name: std::option::Option<std::string::String>,
        pub(crate) owner: std::option::Option<std::string::String>,
        pub(crate) created_date: std::option::Option<smithy_types::Instant>,
        pub(crate) status: std::option::Option<crate::model::DocumentStatus>,
        pub(crate) status_information: std::option::Option<std::string::String>,
        pub(crate) document_version: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<std::vec::Vec<crate::model::DocumentParameter>>,
        pub(crate) platform_types: std::option::Option<std::vec::Vec<crate::model::PlatformType>>,
        pub(crate) document_type: std::option::Option<crate::model::DocumentType>,
        pub(crate) schema_version: std::option::Option<std::string::String>,
        pub(crate) latest_version: std::option::Option<std::string::String>,
        pub(crate) default_version: std::option::Option<std::string::String>,
        pub(crate) document_format: std::option::Option<crate::model::DocumentFormat>,
        pub(crate) target_type: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) attachments_information:
            std::option::Option<std::vec::Vec<crate::model::AttachmentInformation>>,
        pub(crate) requires: std::option::Option<std::vec::Vec<crate::model::DocumentRequires>>,
        pub(crate) author: std::option::Option<std::string::String>,
        pub(crate) review_information:
            std::option::Option<std::vec::Vec<crate::model::ReviewInformation>>,
        pub(crate) approved_version: std::option::Option<std::string::String>,
        pub(crate) pending_review_version: std::option::Option<std::string::String>,
        pub(crate) review_status: std::option::Option<crate::model::ReviewStatus>,
    }
    impl Builder {
        /// <p>The SHA1 hash of the document, which you can use for verification.</p>
        pub fn sha1(mut self, input: impl Into<std::string::String>) -> Self {
            self.sha1 = Some(input.into());
            self
        }
        pub fn set_sha1(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sha1 = input;
            self
        }
        /// <p>The Sha256 or Sha1 hash created by the system when the document was created. </p>
        /// <note>
        /// <p>Sha1 hashes have been deprecated.</p>
        /// </note>
        pub fn hash(mut self, input: impl Into<std::string::String>) -> Self {
            self.hash = Some(input.into());
            self
        }
        pub fn set_hash(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hash = input;
            self
        }
        /// <p>The hash type of the document. Valid values include <code>Sha256</code> or
        /// <code>Sha1</code>.</p>
        /// <note>
        /// <p>Sha1 hashes have been deprecated.</p>
        /// </note>
        pub fn hash_type(mut self, input: crate::model::DocumentHashType) -> Self {
            self.hash_type = Some(input);
            self
        }
        pub fn set_hash_type(
            mut self,
            input: std::option::Option<crate::model::DocumentHashType>,
        ) -> Self {
            self.hash_type = input;
            self
        }
        /// <p>The name of the Systems Manager document.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The friendly name of the Systems Manager document. This value can differ for each version of the
        /// document. If you want to update this value, see <a>UpdateDocument</a>.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>The version of the artifact associated with the document.</p>
        pub fn version_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_name = Some(input.into());
            self
        }
        pub fn set_version_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_name = input;
            self
        }
        /// <p>The AWS user account that created the document.</p>
        pub fn owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner = Some(input.into());
            self
        }
        pub fn set_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner = input;
            self
        }
        /// <p>The date when the document was created.</p>
        pub fn created_date(mut self, input: smithy_types::Instant) -> Self {
            self.created_date = Some(input);
            self
        }
        pub fn set_created_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.created_date = input;
            self
        }
        /// <p>The status of the Systems Manager document.</p>
        pub fn status(mut self, input: crate::model::DocumentStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::DocumentStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>A message returned by AWS Systems Manager that explains the <code>Status</code> value. For example, a
        /// <code>Failed</code> status might be explained by the <code>StatusInformation</code> message,
        /// "The specified S3 bucket does not exist. Verify that the URL of the S3 bucket is correct."</p>
        pub fn status_information(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_information = Some(input.into());
            self
        }
        pub fn set_status_information(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_information = input;
            self
        }
        /// <p>The document version.</p>
        pub fn document_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_version = Some(input.into());
            self
        }
        pub fn set_document_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_version = input;
            self
        }
        /// <p>A description of the document. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        pub fn parameters(mut self, input: impl Into<crate::model::DocumentParameter>) -> Self {
            let mut v = self.parameters.unwrap_or_default();
            v.push(input.into());
            self.parameters = Some(v);
            self
        }
        pub fn set_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DocumentParameter>>,
        ) -> Self {
            self.parameters = input;
            self
        }
        pub fn platform_types(mut self, input: impl Into<crate::model::PlatformType>) -> Self {
            let mut v = self.platform_types.unwrap_or_default();
            v.push(input.into());
            self.platform_types = Some(v);
            self
        }
        pub fn set_platform_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PlatformType>>,
        ) -> Self {
            self.platform_types = input;
            self
        }
        /// <p>The type of document.</p>
        pub fn document_type(mut self, input: crate::model::DocumentType) -> Self {
            self.document_type = Some(input);
            self
        }
        pub fn set_document_type(
            mut self,
            input: std::option::Option<crate::model::DocumentType>,
        ) -> Self {
            self.document_type = input;
            self
        }
        /// <p>The schema version.</p>
        pub fn schema_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.schema_version = Some(input.into());
            self
        }
        pub fn set_schema_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.schema_version = input;
            self
        }
        /// <p>The latest version of the document.</p>
        pub fn latest_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.latest_version = Some(input.into());
            self
        }
        pub fn set_latest_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.latest_version = input;
            self
        }
        /// <p>The default version.</p>
        pub fn default_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_version = Some(input.into());
            self
        }
        pub fn set_default_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_version = input;
            self
        }
        /// <p>The document format, either JSON or YAML.</p>
        pub fn document_format(mut self, input: crate::model::DocumentFormat) -> Self {
            self.document_format = Some(input);
            self
        }
        pub fn set_document_format(
            mut self,
            input: std::option::Option<crate::model::DocumentFormat>,
        ) -> Self {
            self.document_format = input;
            self
        }
        /// <p>The target type which defines the kinds of resources the document can run on. For example,
        /// /AWS::EC2::Instance. For a list of valid resource types, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">AWS resource and property types
        /// reference</a> in the <i>AWS CloudFormation User Guide</i>. </p>
        pub fn target_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_type = Some(input.into());
            self
        }
        pub fn set_target_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_type = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        pub fn attachments_information(
            mut self,
            input: impl Into<crate::model::AttachmentInformation>,
        ) -> Self {
            let mut v = self.attachments_information.unwrap_or_default();
            v.push(input.into());
            self.attachments_information = Some(v);
            self
        }
        pub fn set_attachments_information(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AttachmentInformation>>,
        ) -> Self {
            self.attachments_information = input;
            self
        }
        pub fn requires(mut self, input: impl Into<crate::model::DocumentRequires>) -> Self {
            let mut v = self.requires.unwrap_or_default();
            v.push(input.into());
            self.requires = Some(v);
            self
        }
        pub fn set_requires(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DocumentRequires>>,
        ) -> Self {
            self.requires = input;
            self
        }
        /// <p>The user in your organization who created the document.</p>
        pub fn author(mut self, input: impl Into<std::string::String>) -> Self {
            self.author = Some(input.into());
            self
        }
        pub fn set_author(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.author = input;
            self
        }
        pub fn review_information(
            mut self,
            input: impl Into<crate::model::ReviewInformation>,
        ) -> Self {
            let mut v = self.review_information.unwrap_or_default();
            v.push(input.into());
            self.review_information = Some(v);
            self
        }
        pub fn set_review_information(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReviewInformation>>,
        ) -> Self {
            self.review_information = input;
            self
        }
        /// <p>The version of the document currently approved for use in the organization.</p>
        pub fn approved_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.approved_version = Some(input.into());
            self
        }
        pub fn set_approved_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.approved_version = input;
            self
        }
        /// <p>The version of the document that is currently under review.</p>
        pub fn pending_review_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.pending_review_version = Some(input.into());
            self
        }
        pub fn set_pending_review_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pending_review_version = input;
            self
        }
        /// <p>The current status of the review.</p>
        pub fn review_status(mut self, input: crate::model::ReviewStatus) -> Self {
            self.review_status = Some(input);
            self
        }
        pub fn set_review_status(
            mut self,
            input: std::option::Option<crate::model::ReviewStatus>,
        ) -> Self {
            self.review_status = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentDescription`](crate::model::DocumentDescription)
        pub fn build(self) -> crate::model::DocumentDescription {
            crate::model::DocumentDescription {
                sha1: self.sha1,
                hash: self.hash,
                hash_type: self.hash_type,
                name: self.name,
                display_name: self.display_name,
                version_name: self.version_name,
                owner: self.owner,
                created_date: self.created_date,
                status: self.status,
                status_information: self.status_information,
                document_version: self.document_version,
                description: self.description,
                parameters: self.parameters,
                platform_types: self.platform_types,
                document_type: self.document_type,
                schema_version: self.schema_version,
                latest_version: self.latest_version,
                default_version: self.default_version,
                document_format: self.document_format,
                target_type: self.target_type,
                tags: self.tags,
                attachments_information: self.attachments_information,
                requires: self.requires,
                author: self.author,
                review_information: self.review_information,
                approved_version: self.approved_version,
                pending_review_version: self.pending_review_version,
                review_status: self.review_status,
            }
        }
    }
}
impl DocumentDescription {
    /// Creates a new builder-style object to manufacture [`DocumentDescription`](crate::model::DocumentDescription)
    pub fn builder() -> crate::model::document_description::Builder {
        crate::model::document_description::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReviewStatus {
    Approved,
    NotReviewed,
    Pending,
    Rejected,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ReviewStatus {
    fn from(s: &str) -> Self {
        match s {
            "APPROVED" => ReviewStatus::Approved,
            "NOT_REVIEWED" => ReviewStatus::NotReviewed,
            "PENDING" => ReviewStatus::Pending,
            "REJECTED" => ReviewStatus::Rejected,
            other => ReviewStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ReviewStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ReviewStatus::from(s))
    }
}
impl ReviewStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ReviewStatus::Approved => "APPROVED",
            ReviewStatus::NotReviewed => "NOT_REVIEWED",
            ReviewStatus::Pending => "PENDING",
            ReviewStatus::Rejected => "REJECTED",
            ReviewStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ReviewStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ReviewStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Information about the result of a document review request.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ReviewInformation {
    /// <p>The time that the reviewer took action on the document review request.</p>
    #[serde(rename = "ReviewedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub reviewed_time: std::option::Option<smithy_types::Instant>,
    /// <p>The current status of the document review request.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::ReviewStatus>,
    /// <p>The reviewer assigned to take action on the document review request.</p>
    #[serde(rename = "Reviewer")]
    #[serde(default)]
    pub reviewer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReviewInformation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReviewInformation");
        formatter.field("reviewed_time", &self.reviewed_time);
        formatter.field("status", &self.status);
        formatter.field("reviewer", &self.reviewer);
        formatter.finish()
    }
}
/// See [`ReviewInformation`](crate::model::ReviewInformation)
pub mod review_information {
    /// A builder for [`ReviewInformation`](crate::model::ReviewInformation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reviewed_time: std::option::Option<smithy_types::Instant>,
        pub(crate) status: std::option::Option<crate::model::ReviewStatus>,
        pub(crate) reviewer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The time that the reviewer took action on the document review request.</p>
        pub fn reviewed_time(mut self, input: smithy_types::Instant) -> Self {
            self.reviewed_time = Some(input);
            self
        }
        pub fn set_reviewed_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.reviewed_time = input;
            self
        }
        /// <p>The current status of the document review request.</p>
        pub fn status(mut self, input: crate::model::ReviewStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ReviewStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The reviewer assigned to take action on the document review request.</p>
        pub fn reviewer(mut self, input: impl Into<std::string::String>) -> Self {
            self.reviewer = Some(input.into());
            self
        }
        pub fn set_reviewer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reviewer = input;
            self
        }
        /// Consumes the builder and constructs a [`ReviewInformation`](crate::model::ReviewInformation)
        pub fn build(self) -> crate::model::ReviewInformation {
            crate::model::ReviewInformation {
                reviewed_time: self.reviewed_time,
                status: self.status,
                reviewer: self.reviewer,
            }
        }
    }
}
impl ReviewInformation {
    /// Creates a new builder-style object to manufacture [`ReviewInformation`](crate::model::ReviewInformation)
    pub fn builder() -> crate::model::review_information::Builder {
        crate::model::review_information::Builder::default()
    }
}

/// <p>An SSM document required by the current document.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DocumentRequires {
    /// <p>The name of the required SSM document. The name can be an Amazon Resource Name (ARN).</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The document version required by the current document.</p>
    #[serde(rename = "Version")]
    #[serde(default)]
    pub version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DocumentRequires {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DocumentRequires");
        formatter.field("name", &self.name);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`DocumentRequires`](crate::model::DocumentRequires)
pub mod document_requires {
    /// A builder for [`DocumentRequires`](crate::model::DocumentRequires)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the required SSM document. The name can be an Amazon Resource Name (ARN).</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The document version required by the current document.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentRequires`](crate::model::DocumentRequires)
        pub fn build(self) -> crate::model::DocumentRequires {
            crate::model::DocumentRequires {
                name: self.name,
                version: self.version,
            }
        }
    }
}
impl DocumentRequires {
    /// Creates a new builder-style object to manufacture [`DocumentRequires`](crate::model::DocumentRequires)
    pub fn builder() -> crate::model::document_requires::Builder {
        crate::model::document_requires::Builder::default()
    }
}

/// <p>An attribute of an attachment, such as the attachment name.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AttachmentInformation {
    /// <p>The name of the attachment.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AttachmentInformation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttachmentInformation");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`AttachmentInformation`](crate::model::AttachmentInformation)
pub mod attachment_information {
    /// A builder for [`AttachmentInformation`](crate::model::AttachmentInformation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the attachment.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`AttachmentInformation`](crate::model::AttachmentInformation)
        pub fn build(self) -> crate::model::AttachmentInformation {
            crate::model::AttachmentInformation { name: self.name }
        }
    }
}
impl AttachmentInformation {
    /// Creates a new builder-style object to manufacture [`AttachmentInformation`](crate::model::AttachmentInformation)
    pub fn builder() -> crate::model::attachment_information::Builder {
        crate::model::attachment_information::Builder::default()
    }
}

/// <p>Metadata that you assign to your AWS resources. Tags enable you to categorize your resources
/// in different ways, for example, by purpose, owner, or environment. In Systems Manager, you can apply tags
/// to documents, managed instances, maintenance windows, Parameter Store parameters, and patch
/// baselines.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct Tag {
    /// <p>The name of the tag.</p>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The value of the tag.</p>
    #[serde(rename = "Value")]
    #[serde(default)]
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Tag");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Tag`](crate::model::Tag)
pub mod tag {
    /// A builder for [`Tag`](crate::model::Tag)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the tag.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value of the tag.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag)
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag)
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DocumentFormat {
    Json,
    Text,
    Yaml,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DocumentFormat {
    fn from(s: &str) -> Self {
        match s {
            "JSON" => DocumentFormat::Json,
            "TEXT" => DocumentFormat::Text,
            "YAML" => DocumentFormat::Yaml,
            other => DocumentFormat::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DocumentFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(DocumentFormat::from(s))
    }
}
impl DocumentFormat {
    pub fn as_str(&self) -> &str {
        match self {
            DocumentFormat::Json => "JSON",
            DocumentFormat::Text => "TEXT",
            DocumentFormat::Yaml => "YAML",
            DocumentFormat::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for DocumentFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for DocumentFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DocumentType {
    ApplicationConfiguration,
    ApplicationConfigurationSchema,
    Automation,
    ChangeTemplate,
    ChangeCalendar,
    Command,
    DeploymentStrategy,
    Package,
    Policy,
    ProblemAnalysis,
    ProblemAnalysisTemplate,
    Session,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DocumentType {
    fn from(s: &str) -> Self {
        match s {
            "ApplicationConfiguration" => DocumentType::ApplicationConfiguration,
            "ApplicationConfigurationSchema" => DocumentType::ApplicationConfigurationSchema,
            "Automation" => DocumentType::Automation,
            "Automation.ChangeTemplate" => DocumentType::ChangeTemplate,
            "ChangeCalendar" => DocumentType::ChangeCalendar,
            "Command" => DocumentType::Command,
            "DeploymentStrategy" => DocumentType::DeploymentStrategy,
            "Package" => DocumentType::Package,
            "Policy" => DocumentType::Policy,
            "ProblemAnalysis" => DocumentType::ProblemAnalysis,
            "ProblemAnalysisTemplate" => DocumentType::ProblemAnalysisTemplate,
            "Session" => DocumentType::Session,
            other => DocumentType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DocumentType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(DocumentType::from(s))
    }
}
impl DocumentType {
    pub fn as_str(&self) -> &str {
        match self {
            DocumentType::ApplicationConfiguration => "ApplicationConfiguration",
            DocumentType::ApplicationConfigurationSchema => "ApplicationConfigurationSchema",
            DocumentType::Automation => "Automation",
            DocumentType::ChangeTemplate => "Automation.ChangeTemplate",
            DocumentType::ChangeCalendar => "ChangeCalendar",
            DocumentType::Command => "Command",
            DocumentType::DeploymentStrategy => "DeploymentStrategy",
            DocumentType::Package => "Package",
            DocumentType::Policy => "Policy",
            DocumentType::ProblemAnalysis => "ProblemAnalysis",
            DocumentType::ProblemAnalysisTemplate => "ProblemAnalysisTemplate",
            DocumentType::Session => "Session",
            DocumentType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for DocumentType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for DocumentType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PlatformType {
    Linux,
    Windows,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PlatformType {
    fn from(s: &str) -> Self {
        match s {
            "Linux" => PlatformType::Linux,
            "Windows" => PlatformType::Windows,
            other => PlatformType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PlatformType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(PlatformType::from(s))
    }
}
impl PlatformType {
    pub fn as_str(&self) -> &str {
        match self {
            PlatformType::Linux => "Linux",
            PlatformType::Windows => "Windows",
            PlatformType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for PlatformType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for PlatformType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Parameters specified in a System Manager document that run on the server when the command is
/// run. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DocumentParameter {
    /// <p>The name of the parameter.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of parameter. The type can be either String or StringList.</p>
    #[serde(rename = "Type")]
    #[serde(default)]
    pub r#type: std::option::Option<crate::model::DocumentParameterType>,
    /// <p>A description of what the parameter does, how to use it, the default value, and whether or
    /// not the parameter is optional.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>If specified, the default values for the parameters. Parameters without a default value are
    /// required. Parameters with a default value are optional.</p>
    #[serde(rename = "DefaultValue")]
    #[serde(default)]
    pub default_value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DocumentParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DocumentParameter");
        formatter.field("name", &self.name);
        formatter.field("r#type", &self.r#type);
        formatter.field("description", &self.description);
        formatter.field("default_value", &self.default_value);
        formatter.finish()
    }
}
/// See [`DocumentParameter`](crate::model::DocumentParameter)
pub mod document_parameter {
    /// A builder for [`DocumentParameter`](crate::model::DocumentParameter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::DocumentParameterType>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) default_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the parameter.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of parameter. The type can be either String or StringList.</p>
        pub fn r#type(mut self, input: crate::model::DocumentParameterType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::DocumentParameterType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>A description of what the parameter does, how to use it, the default value, and whether or
        /// not the parameter is optional.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>If specified, the default values for the parameters. Parameters without a default value are
        /// required. Parameters with a default value are optional.</p>
        pub fn default_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_value = Some(input.into());
            self
        }
        pub fn set_default_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_value = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentParameter`](crate::model::DocumentParameter)
        pub fn build(self) -> crate::model::DocumentParameter {
            crate::model::DocumentParameter {
                name: self.name,
                r#type: self.r#type,
                description: self.description,
                default_value: self.default_value,
            }
        }
    }
}
impl DocumentParameter {
    /// Creates a new builder-style object to manufacture [`DocumentParameter`](crate::model::DocumentParameter)
    pub fn builder() -> crate::model::document_parameter::Builder {
        crate::model::document_parameter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DocumentParameterType {
    String,
    StringList,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DocumentParameterType {
    fn from(s: &str) -> Self {
        match s {
            "String" => DocumentParameterType::String,
            "StringList" => DocumentParameterType::StringList,
            other => DocumentParameterType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DocumentParameterType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(DocumentParameterType::from(s))
    }
}
impl DocumentParameterType {
    pub fn as_str(&self) -> &str {
        match self {
            DocumentParameterType::String => "String",
            DocumentParameterType::StringList => "StringList",
            DocumentParameterType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for DocumentParameterType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for DocumentParameterType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>The status of a document.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DocumentStatus {
    Active,
    Creating,
    Deleting,
    Failed,
    Updating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DocumentStatus {
    fn from(s: &str) -> Self {
        match s {
            "Active" => DocumentStatus::Active,
            "Creating" => DocumentStatus::Creating,
            "Deleting" => DocumentStatus::Deleting,
            "Failed" => DocumentStatus::Failed,
            "Updating" => DocumentStatus::Updating,
            other => DocumentStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DocumentStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(DocumentStatus::from(s))
    }
}
impl DocumentStatus {
    pub fn as_str(&self) -> &str {
        match self {
            DocumentStatus::Active => "Active",
            DocumentStatus::Creating => "Creating",
            DocumentStatus::Deleting => "Deleting",
            DocumentStatus::Failed => "Failed",
            DocumentStatus::Updating => "Updating",
            DocumentStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for DocumentStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for DocumentStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Identifying information about a document attachment, including the file name and a key-value
/// pair that identifies the location of an attachment to a document.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AttachmentsSource {
    /// <p>The key of a key-value pair that identifies the location of an attachment to a
    /// document.</p>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<crate::model::AttachmentsSourceKey>,
    /// <p>The value of a key-value pair that identifies the location of an attachment to a document.
    /// The format for <b>Value</b> depends on the type of key you
    /// specify.</p>
    /// <ul>
    /// <li>
    /// <p>For the key <i>SourceUrl</i>, the value is an S3 bucket location. For
    /// example:</p>
    /// <p>
    /// <code>"Values": [ "s3://doc-example-bucket/my-folder" ]</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>For the key <i>S3FileUrl</i>, the value is a file in an S3 bucket. For
    /// example:</p>
    /// <p>
    /// <code>"Values": [ "s3://doc-example-bucket/my-folder/my-file.py" ]</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>For the key <i>AttachmentReference</i>, the value is constructed from the
    /// name of another SSM document in your account, a version number of that document, and a file
    /// attached to that document version that you want to reuse. For example:</p>
    /// <p>
    /// <code>"Values": [ "MyOtherDocument/3/my-other-file.py" ]</code>
    /// </p>
    /// <p>However, if the SSM document is shared with you from another account, the full SSM
    /// document ARN must be specified instead of the document name only. For example:</p>
    /// <p>
    /// <code>"Values": [
    /// "arn:aws:ssm:us-east-2:111122223333:document/OtherAccountDocument/3/their-file.py"
    /// ]</code>
    /// </p>
    /// </li>
    /// </ul>
    #[serde(rename = "Values")]
    #[serde(default)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name of the document attachment file.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AttachmentsSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttachmentsSource");
        formatter.field("key", &self.key);
        formatter.field("values", &self.values);
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`AttachmentsSource`](crate::model::AttachmentsSource)
pub mod attachments_source {
    /// A builder for [`AttachmentsSource`](crate::model::AttachmentsSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<crate::model::AttachmentsSourceKey>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The key of a key-value pair that identifies the location of an attachment to a
        /// document.</p>
        pub fn key(mut self, input: crate::model::AttachmentsSourceKey) -> Self {
            self.key = Some(input);
            self
        }
        pub fn set_key(
            mut self,
            input: std::option::Option<crate::model::AttachmentsSourceKey>,
        ) -> Self {
            self.key = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// <p>The name of the document attachment file.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`AttachmentsSource`](crate::model::AttachmentsSource)
        pub fn build(self) -> crate::model::AttachmentsSource {
            crate::model::AttachmentsSource {
                key: self.key,
                values: self.values,
                name: self.name,
            }
        }
    }
}
impl AttachmentsSource {
    /// Creates a new builder-style object to manufacture [`AttachmentsSource`](crate::model::AttachmentsSource)
    pub fn builder() -> crate::model::attachments_source::Builder {
        crate::model::attachments_source::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AttachmentsSourceKey {
    AttachmentReference,
    S3FileUrl,
    SourceUrl,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AttachmentsSourceKey {
    fn from(s: &str) -> Self {
        match s {
            "AttachmentReference" => AttachmentsSourceKey::AttachmentReference,
            "S3FileUrl" => AttachmentsSourceKey::S3FileUrl,
            "SourceUrl" => AttachmentsSourceKey::SourceUrl,
            other => AttachmentsSourceKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AttachmentsSourceKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(AttachmentsSourceKey::from(s))
    }
}
impl AttachmentsSourceKey {
    pub fn as_str(&self) -> &str {
        match self {
            AttachmentsSourceKey::AttachmentReference => "AttachmentReference",
            AttachmentsSourceKey::S3FileUrl => "S3FileUrl",
            AttachmentsSourceKey::SourceUrl => "SourceUrl",
            AttachmentsSourceKey::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for AttachmentsSourceKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for AttachmentsSourceKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Describes the parameters for a document.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociationDescription {
    /// <p>The name of the Systems Manager document.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The ID of the instance.</p>
    #[serde(rename = "InstanceId")]
    #[serde(default)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The association version.</p>
    #[serde(rename = "AssociationVersion")]
    #[serde(default)]
    pub association_version: std::option::Option<std::string::String>,
    /// <p>The date when the association was made.</p>
    #[serde(rename = "Date")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub date: std::option::Option<smithy_types::Instant>,
    /// <p>The date when the association was last updated.</p>
    #[serde(rename = "LastUpdateAssociationDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_update_association_date: std::option::Option<smithy_types::Instant>,
    /// <p>The association status.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::AssociationStatus>,
    /// <p>Information about the association.</p>
    #[serde(rename = "Overview")]
    #[serde(default)]
    pub overview: std::option::Option<crate::model::AssociationOverview>,
    /// <p>The document version.</p>
    #[serde(rename = "DocumentVersion")]
    #[serde(default)]
    pub document_version: std::option::Option<std::string::String>,
    /// <p>Specify the target for the association. This target is required for associations that use an
    /// Automation document and target resources by using rate controls.</p>
    #[serde(rename = "AutomationTargetParameterName")]
    #[serde(default)]
    pub automation_target_parameter_name: std::option::Option<std::string::String>,
    /// <p>A description of the parameters for a document. </p>
    #[serde(rename = "Parameters")]
    #[serde(default)]
    pub parameters: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The association ID.</p>
    #[serde(rename = "AssociationId")]
    #[serde(default)]
    pub association_id: std::option::Option<std::string::String>,
    /// <p>The instances targeted by the request. </p>
    #[serde(rename = "Targets")]
    #[serde(default)]
    pub targets: std::option::Option<std::vec::Vec<crate::model::Target>>,
    /// <p>A cron expression that specifies a schedule when the association runs.</p>
    #[serde(rename = "ScheduleExpression")]
    #[serde(default)]
    pub schedule_expression: std::option::Option<std::string::String>,
    /// <p>An S3 bucket where you want to store the output details of the request.</p>
    #[serde(rename = "OutputLocation")]
    #[serde(default)]
    pub output_location: std::option::Option<crate::model::InstanceAssociationOutputLocation>,
    /// <p>The date on which the association was last run.</p>
    #[serde(rename = "LastExecutionDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_execution_date: std::option::Option<smithy_types::Instant>,
    /// <p>The last date on which the association was successfully run.</p>
    #[serde(rename = "LastSuccessfulExecutionDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_successful_execution_date: std::option::Option<smithy_types::Instant>,
    /// <p>The association name.</p>
    #[serde(rename = "AssociationName")]
    #[serde(default)]
    pub association_name: std::option::Option<std::string::String>,
    /// <p>The number of errors that are allowed before the system stops sending requests to run the
    /// association on additional targets. You can specify either an absolute number of errors, for
    /// example 10, or a percentage of the target set, for example 10%. If you specify 3, for example,
    /// the system stops sending requests when the fourth error is received. If you specify 0, then the
    /// system stops sending requests after the first error is returned. If you run an association on 50
    /// instances and set MaxError to 10%, then the system stops sending the request when the sixth error
    /// is received.</p>
    /// <p>Executions that are already running an association when MaxErrors is reached are allowed to
    /// complete, but some of these executions may fail as well. If you need to ensure that there won't
    /// be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one
    /// at a time.</p>
    #[serde(rename = "MaxErrors")]
    #[serde(default)]
    pub max_errors: std::option::Option<std::string::String>,
    /// <p>The maximum number of targets allowed to run the association at the same time. You can
    /// specify a number, for example 10, or a percentage of the target set, for example 10%. The default
    /// value is 100%, which means all targets run the association at the same time.</p>
    /// <p>If a new instance starts and attempts to run an association while Systems Manager is running
    /// MaxConcurrency associations, the association is allowed to run. During the next association
    /// interval, the new instance will process its association within the limit specified for
    /// MaxConcurrency.</p>
    #[serde(rename = "MaxConcurrency")]
    #[serde(default)]
    pub max_concurrency: std::option::Option<std::string::String>,
    /// <p>The severity level that is assigned to the association.</p>
    #[serde(rename = "ComplianceSeverity")]
    #[serde(default)]
    pub compliance_severity: std::option::Option<crate::model::AssociationComplianceSeverity>,
    /// <p>The mode for generating association compliance. You can specify <code>AUTO</code> or
    /// <code>MANUAL</code>. In <code>AUTO</code> mode, the system uses the status of the association
    /// execution to determine the compliance status. If the association execution runs successfully,
    /// then the association is <code>COMPLIANT</code>. If the association execution doesn't run
    /// successfully, the association is <code>NON-COMPLIANT</code>.</p>
    /// <p>In <code>MANUAL</code> mode, you must specify the <code>AssociationId</code> as a parameter
    /// for the <a>PutComplianceItems</a> API action. In this case, compliance data is not
    /// managed by State Manager. It is managed by your direct call to the <a>PutComplianceItems</a> API action.</p>
    /// <p>By default, all associations use <code>AUTO</code> mode.</p>
    #[serde(rename = "SyncCompliance")]
    #[serde(default)]
    pub sync_compliance: std::option::Option<crate::model::AssociationSyncCompliance>,
    /// <p>By default, when you create a new associations, the system runs it immediately after it is
    /// created and then according to the schedule you specified. Specify this option if you don't want
    /// an association to run immediately after you create it. This parameter is not supported for rate
    /// expressions.</p>
    #[serde(rename = "ApplyOnlyAtCronInterval")]
    #[serde(default)]
    pub apply_only_at_cron_interval: bool,
    /// <p>The names or Amazon Resource Names (ARNs) of the Systems Manager Change Calendar type
    /// documents your associations are gated under. The associations only run when that Change
    /// Calendar is open. For more information, see
    /// <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar">AWS Systems Manager Change Calendar</a>.</p>
    #[serde(rename = "CalendarNames")]
    #[serde(default)]
    pub calendar_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The combination of AWS Regions and AWS accounts where you want to run the
    /// association.</p>
    #[serde(rename = "TargetLocations")]
    #[serde(default)]
    pub target_locations: std::option::Option<std::vec::Vec<crate::model::TargetLocation>>,
}
impl std::fmt::Debug for AssociationDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociationDescription");
        formatter.field("name", &self.name);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("association_version", &self.association_version);
        formatter.field("date", &self.date);
        formatter.field(
            "last_update_association_date",
            &self.last_update_association_date,
        );
        formatter.field("status", &self.status);
        formatter.field("overview", &self.overview);
        formatter.field("document_version", &self.document_version);
        formatter.field(
            "automation_target_parameter_name",
            &self.automation_target_parameter_name,
        );
        formatter.field("parameters", &self.parameters);
        formatter.field("association_id", &self.association_id);
        formatter.field("targets", &self.targets);
        formatter.field("schedule_expression", &self.schedule_expression);
        formatter.field("output_location", &self.output_location);
        formatter.field("last_execution_date", &self.last_execution_date);
        formatter.field(
            "last_successful_execution_date",
            &self.last_successful_execution_date,
        );
        formatter.field("association_name", &self.association_name);
        formatter.field("max_errors", &self.max_errors);
        formatter.field("max_concurrency", &self.max_concurrency);
        formatter.field("compliance_severity", &self.compliance_severity);
        formatter.field("sync_compliance", &self.sync_compliance);
        formatter.field(
            "apply_only_at_cron_interval",
            &self.apply_only_at_cron_interval,
        );
        formatter.field("calendar_names", &self.calendar_names);
        formatter.field("target_locations", &self.target_locations);
        formatter.finish()
    }
}
/// See [`AssociationDescription`](crate::model::AssociationDescription)
pub mod association_description {
    /// A builder for [`AssociationDescription`](crate::model::AssociationDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) association_version: std::option::Option<std::string::String>,
        pub(crate) date: std::option::Option<smithy_types::Instant>,
        pub(crate) last_update_association_date: std::option::Option<smithy_types::Instant>,
        pub(crate) status: std::option::Option<crate::model::AssociationStatus>,
        pub(crate) overview: std::option::Option<crate::model::AssociationOverview>,
        pub(crate) document_version: std::option::Option<std::string::String>,
        pub(crate) automation_target_parameter_name: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) targets: std::option::Option<std::vec::Vec<crate::model::Target>>,
        pub(crate) schedule_expression: std::option::Option<std::string::String>,
        pub(crate) output_location:
            std::option::Option<crate::model::InstanceAssociationOutputLocation>,
        pub(crate) last_execution_date: std::option::Option<smithy_types::Instant>,
        pub(crate) last_successful_execution_date: std::option::Option<smithy_types::Instant>,
        pub(crate) association_name: std::option::Option<std::string::String>,
        pub(crate) max_errors: std::option::Option<std::string::String>,
        pub(crate) max_concurrency: std::option::Option<std::string::String>,
        pub(crate) compliance_severity:
            std::option::Option<crate::model::AssociationComplianceSeverity>,
        pub(crate) sync_compliance: std::option::Option<crate::model::AssociationSyncCompliance>,
        pub(crate) apply_only_at_cron_interval: std::option::Option<bool>,
        pub(crate) calendar_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) target_locations:
            std::option::Option<std::vec::Vec<crate::model::TargetLocation>>,
    }
    impl Builder {
        /// <p>The name of the Systems Manager document.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The association version.</p>
        pub fn association_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_version = Some(input.into());
            self
        }
        pub fn set_association_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_version = input;
            self
        }
        /// <p>The date when the association was made.</p>
        pub fn date(mut self, input: smithy_types::Instant) -> Self {
            self.date = Some(input);
            self
        }
        pub fn set_date(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.date = input;
            self
        }
        /// <p>The date when the association was last updated.</p>
        pub fn last_update_association_date(mut self, input: smithy_types::Instant) -> Self {
            self.last_update_association_date = Some(input);
            self
        }
        pub fn set_last_update_association_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_update_association_date = input;
            self
        }
        /// <p>The association status.</p>
        pub fn status(mut self, input: crate::model::AssociationStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AssociationStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Information about the association.</p>
        pub fn overview(mut self, input: crate::model::AssociationOverview) -> Self {
            self.overview = Some(input);
            self
        }
        pub fn set_overview(
            mut self,
            input: std::option::Option<crate::model::AssociationOverview>,
        ) -> Self {
            self.overview = input;
            self
        }
        /// <p>The document version.</p>
        pub fn document_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_version = Some(input.into());
            self
        }
        pub fn set_document_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_version = input;
            self
        }
        /// <p>Specify the target for the association. This target is required for associations that use an
        /// Automation document and target resources by using rate controls.</p>
        pub fn automation_target_parameter_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.automation_target_parameter_name = Some(input.into());
            self
        }
        pub fn set_automation_target_parameter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.automation_target_parameter_name = input;
            self
        }
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// <p>The association ID.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        pub fn targets(mut self, input: impl Into<crate::model::Target>) -> Self {
            let mut v = self.targets.unwrap_or_default();
            v.push(input.into());
            self.targets = Some(v);
            self
        }
        pub fn set_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Target>>,
        ) -> Self {
            self.targets = input;
            self
        }
        /// <p>A cron expression that specifies a schedule when the association runs.</p>
        pub fn schedule_expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.schedule_expression = Some(input.into());
            self
        }
        pub fn set_schedule_expression(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.schedule_expression = input;
            self
        }
        /// <p>An S3 bucket where you want to store the output details of the request.</p>
        pub fn output_location(
            mut self,
            input: crate::model::InstanceAssociationOutputLocation,
        ) -> Self {
            self.output_location = Some(input);
            self
        }
        pub fn set_output_location(
            mut self,
            input: std::option::Option<crate::model::InstanceAssociationOutputLocation>,
        ) -> Self {
            self.output_location = input;
            self
        }
        /// <p>The date on which the association was last run.</p>
        pub fn last_execution_date(mut self, input: smithy_types::Instant) -> Self {
            self.last_execution_date = Some(input);
            self
        }
        pub fn set_last_execution_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_execution_date = input;
            self
        }
        /// <p>The last date on which the association was successfully run.</p>
        pub fn last_successful_execution_date(mut self, input: smithy_types::Instant) -> Self {
            self.last_successful_execution_date = Some(input);
            self
        }
        pub fn set_last_successful_execution_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_successful_execution_date = input;
            self
        }
        /// <p>The association name.</p>
        pub fn association_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_name = Some(input.into());
            self
        }
        pub fn set_association_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_name = input;
            self
        }
        /// <p>The number of errors that are allowed before the system stops sending requests to run the
        /// association on additional targets. You can specify either an absolute number of errors, for
        /// example 10, or a percentage of the target set, for example 10%. If you specify 3, for example,
        /// the system stops sending requests when the fourth error is received. If you specify 0, then the
        /// system stops sending requests after the first error is returned. If you run an association on 50
        /// instances and set MaxError to 10%, then the system stops sending the request when the sixth error
        /// is received.</p>
        /// <p>Executions that are already running an association when MaxErrors is reached are allowed to
        /// complete, but some of these executions may fail as well. If you need to ensure that there won't
        /// be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one
        /// at a time.</p>
        pub fn max_errors(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_errors = Some(input.into());
            self
        }
        pub fn set_max_errors(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_errors = input;
            self
        }
        /// <p>The maximum number of targets allowed to run the association at the same time. You can
        /// specify a number, for example 10, or a percentage of the target set, for example 10%. The default
        /// value is 100%, which means all targets run the association at the same time.</p>
        /// <p>If a new instance starts and attempts to run an association while Systems Manager is running
        /// MaxConcurrency associations, the association is allowed to run. During the next association
        /// interval, the new instance will process its association within the limit specified for
        /// MaxConcurrency.</p>
        pub fn max_concurrency(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_concurrency = Some(input.into());
            self
        }
        pub fn set_max_concurrency(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.max_concurrency = input;
            self
        }
        /// <p>The severity level that is assigned to the association.</p>
        pub fn compliance_severity(
            mut self,
            input: crate::model::AssociationComplianceSeverity,
        ) -> Self {
            self.compliance_severity = Some(input);
            self
        }
        pub fn set_compliance_severity(
            mut self,
            input: std::option::Option<crate::model::AssociationComplianceSeverity>,
        ) -> Self {
            self.compliance_severity = input;
            self
        }
        /// <p>The mode for generating association compliance. You can specify <code>AUTO</code> or
        /// <code>MANUAL</code>. In <code>AUTO</code> mode, the system uses the status of the association
        /// execution to determine the compliance status. If the association execution runs successfully,
        /// then the association is <code>COMPLIANT</code>. If the association execution doesn't run
        /// successfully, the association is <code>NON-COMPLIANT</code>.</p>
        /// <p>In <code>MANUAL</code> mode, you must specify the <code>AssociationId</code> as a parameter
        /// for the <a>PutComplianceItems</a> API action. In this case, compliance data is not
        /// managed by State Manager. It is managed by your direct call to the <a>PutComplianceItems</a> API action.</p>
        /// <p>By default, all associations use <code>AUTO</code> mode.</p>
        pub fn sync_compliance(mut self, input: crate::model::AssociationSyncCompliance) -> Self {
            self.sync_compliance = Some(input);
            self
        }
        pub fn set_sync_compliance(
            mut self,
            input: std::option::Option<crate::model::AssociationSyncCompliance>,
        ) -> Self {
            self.sync_compliance = input;
            self
        }
        /// <p>By default, when you create a new associations, the system runs it immediately after it is
        /// created and then according to the schedule you specified. Specify this option if you don't want
        /// an association to run immediately after you create it. This parameter is not supported for rate
        /// expressions.</p>
        pub fn apply_only_at_cron_interval(mut self, input: bool) -> Self {
            self.apply_only_at_cron_interval = Some(input);
            self
        }
        pub fn set_apply_only_at_cron_interval(mut self, input: std::option::Option<bool>) -> Self {
            self.apply_only_at_cron_interval = input;
            self
        }
        pub fn calendar_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.calendar_names.unwrap_or_default();
            v.push(input.into());
            self.calendar_names = Some(v);
            self
        }
        pub fn set_calendar_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.calendar_names = input;
            self
        }
        pub fn target_locations(mut self, input: impl Into<crate::model::TargetLocation>) -> Self {
            let mut v = self.target_locations.unwrap_or_default();
            v.push(input.into());
            self.target_locations = Some(v);
            self
        }
        pub fn set_target_locations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TargetLocation>>,
        ) -> Self {
            self.target_locations = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociationDescription`](crate::model::AssociationDescription)
        pub fn build(self) -> crate::model::AssociationDescription {
            crate::model::AssociationDescription {
                name: self.name,
                instance_id: self.instance_id,
                association_version: self.association_version,
                date: self.date,
                last_update_association_date: self.last_update_association_date,
                status: self.status,
                overview: self.overview,
                document_version: self.document_version,
                automation_target_parameter_name: self.automation_target_parameter_name,
                parameters: self.parameters,
                association_id: self.association_id,
                targets: self.targets,
                schedule_expression: self.schedule_expression,
                output_location: self.output_location,
                last_execution_date: self.last_execution_date,
                last_successful_execution_date: self.last_successful_execution_date,
                association_name: self.association_name,
                max_errors: self.max_errors,
                max_concurrency: self.max_concurrency,
                compliance_severity: self.compliance_severity,
                sync_compliance: self.sync_compliance,
                apply_only_at_cron_interval: self.apply_only_at_cron_interval.unwrap_or_default(),
                calendar_names: self.calendar_names,
                target_locations: self.target_locations,
            }
        }
    }
}
impl AssociationDescription {
    /// Creates a new builder-style object to manufacture [`AssociationDescription`](crate::model::AssociationDescription)
    pub fn builder() -> crate::model::association_description::Builder {
        crate::model::association_description::Builder::default()
    }
}

/// <p>The combination of AWS Regions and accounts targeted by the current Automation
/// execution.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TargetLocation {
    /// <p>The AWS accounts targeted by the current Automation execution.</p>
    #[serde(rename = "Accounts")]
    #[serde(default)]
    pub accounts: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The AWS Regions targeted by the current Automation execution.</p>
    #[serde(rename = "Regions")]
    #[serde(default)]
    pub regions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The maximum number of AWS accounts and AWS regions allowed to run the Automation
    /// concurrently.</p>
    #[serde(rename = "TargetLocationMaxConcurrency")]
    #[serde(default)]
    pub target_location_max_concurrency: std::option::Option<std::string::String>,
    /// <p>The maximum number of errors allowed before the system stops queueing additional Automation
    /// executions for the currently running Automation.</p>
    #[serde(rename = "TargetLocationMaxErrors")]
    #[serde(default)]
    pub target_location_max_errors: std::option::Option<std::string::String>,
    /// <p>The Automation execution role used by the currently running Automation. If not specified,
    /// the default value is <code>AWS-SystemsManager-AutomationExecutionRole</code>.</p>
    #[serde(rename = "ExecutionRoleName")]
    #[serde(default)]
    pub execution_role_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TargetLocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TargetLocation");
        formatter.field("accounts", &self.accounts);
        formatter.field("regions", &self.regions);
        formatter.field(
            "target_location_max_concurrency",
            &self.target_location_max_concurrency,
        );
        formatter.field(
            "target_location_max_errors",
            &self.target_location_max_errors,
        );
        formatter.field("execution_role_name", &self.execution_role_name);
        formatter.finish()
    }
}
/// See [`TargetLocation`](crate::model::TargetLocation)
pub mod target_location {
    /// A builder for [`TargetLocation`](crate::model::TargetLocation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) accounts: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) regions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) target_location_max_concurrency: std::option::Option<std::string::String>,
        pub(crate) target_location_max_errors: std::option::Option<std::string::String>,
        pub(crate) execution_role_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn accounts(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.accounts.unwrap_or_default();
            v.push(input.into());
            self.accounts = Some(v);
            self
        }
        pub fn set_accounts(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.accounts = input;
            self
        }
        pub fn regions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.regions.unwrap_or_default();
            v.push(input.into());
            self.regions = Some(v);
            self
        }
        pub fn set_regions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.regions = input;
            self
        }
        /// <p>The maximum number of AWS accounts and AWS regions allowed to run the Automation
        /// concurrently.</p>
        pub fn target_location_max_concurrency(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.target_location_max_concurrency = Some(input.into());
            self
        }
        pub fn set_target_location_max_concurrency(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_location_max_concurrency = input;
            self
        }
        /// <p>The maximum number of errors allowed before the system stops queueing additional Automation
        /// executions for the currently running Automation.</p>
        pub fn target_location_max_errors(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_location_max_errors = Some(input.into());
            self
        }
        pub fn set_target_location_max_errors(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_location_max_errors = input;
            self
        }
        /// <p>The Automation execution role used by the currently running Automation. If not specified,
        /// the default value is <code>AWS-SystemsManager-AutomationExecutionRole</code>.</p>
        pub fn execution_role_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.execution_role_name = Some(input.into());
            self
        }
        pub fn set_execution_role_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.execution_role_name = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetLocation`](crate::model::TargetLocation)
        pub fn build(self) -> crate::model::TargetLocation {
            crate::model::TargetLocation {
                accounts: self.accounts,
                regions: self.regions,
                target_location_max_concurrency: self.target_location_max_concurrency,
                target_location_max_errors: self.target_location_max_errors,
                execution_role_name: self.execution_role_name,
            }
        }
    }
}
impl TargetLocation {
    /// Creates a new builder-style object to manufacture [`TargetLocation`](crate::model::TargetLocation)
    pub fn builder() -> crate::model::target_location::Builder {
        crate::model::target_location::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssociationSyncCompliance {
    Auto,
    Manual,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AssociationSyncCompliance {
    fn from(s: &str) -> Self {
        match s {
            "AUTO" => AssociationSyncCompliance::Auto,
            "MANUAL" => AssociationSyncCompliance::Manual,
            other => AssociationSyncCompliance::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AssociationSyncCompliance {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(AssociationSyncCompliance::from(s))
    }
}
impl AssociationSyncCompliance {
    pub fn as_str(&self) -> &str {
        match self {
            AssociationSyncCompliance::Auto => "AUTO",
            AssociationSyncCompliance::Manual => "MANUAL",
            AssociationSyncCompliance::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for AssociationSyncCompliance {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for AssociationSyncCompliance {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssociationComplianceSeverity {
    Critical,
    High,
    Low,
    Medium,
    Unspecified,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AssociationComplianceSeverity {
    fn from(s: &str) -> Self {
        match s {
            "CRITICAL" => AssociationComplianceSeverity::Critical,
            "HIGH" => AssociationComplianceSeverity::High,
            "LOW" => AssociationComplianceSeverity::Low,
            "MEDIUM" => AssociationComplianceSeverity::Medium,
            "UNSPECIFIED" => AssociationComplianceSeverity::Unspecified,
            other => AssociationComplianceSeverity::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AssociationComplianceSeverity {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(AssociationComplianceSeverity::from(s))
    }
}
impl AssociationComplianceSeverity {
    pub fn as_str(&self) -> &str {
        match self {
            AssociationComplianceSeverity::Critical => "CRITICAL",
            AssociationComplianceSeverity::High => "HIGH",
            AssociationComplianceSeverity::Low => "LOW",
            AssociationComplianceSeverity::Medium => "MEDIUM",
            AssociationComplianceSeverity::Unspecified => "UNSPECIFIED",
            AssociationComplianceSeverity::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for AssociationComplianceSeverity {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for AssociationComplianceSeverity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>An S3 bucket where you want to store the results of this request.</p>
/// <p>For the minimal permissions required to enable Amazon S3 output for an association, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-state-assoc.html">Creating
/// associations</a> in the <i>Systems Manager User Guide</i>. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceAssociationOutputLocation {
    /// <p>An S3 bucket where you want to store the results of this request.</p>
    #[serde(rename = "S3Location")]
    #[serde(default)]
    pub s3_location: std::option::Option<crate::model::S3OutputLocation>,
}
impl std::fmt::Debug for InstanceAssociationOutputLocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceAssociationOutputLocation");
        formatter.field("s3_location", &self.s3_location);
        formatter.finish()
    }
}
/// See [`InstanceAssociationOutputLocation`](crate::model::InstanceAssociationOutputLocation)
pub mod instance_association_output_location {
    /// A builder for [`InstanceAssociationOutputLocation`](crate::model::InstanceAssociationOutputLocation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_location: std::option::Option<crate::model::S3OutputLocation>,
    }
    impl Builder {
        /// <p>An S3 bucket where you want to store the results of this request.</p>
        pub fn s3_location(mut self, input: crate::model::S3OutputLocation) -> Self {
            self.s3_location = Some(input);
            self
        }
        pub fn set_s3_location(
            mut self,
            input: std::option::Option<crate::model::S3OutputLocation>,
        ) -> Self {
            self.s3_location = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceAssociationOutputLocation`](crate::model::InstanceAssociationOutputLocation)
        pub fn build(self) -> crate::model::InstanceAssociationOutputLocation {
            crate::model::InstanceAssociationOutputLocation {
                s3_location: self.s3_location,
            }
        }
    }
}
impl InstanceAssociationOutputLocation {
    /// Creates a new builder-style object to manufacture [`InstanceAssociationOutputLocation`](crate::model::InstanceAssociationOutputLocation)
    pub fn builder() -> crate::model::instance_association_output_location::Builder {
        crate::model::instance_association_output_location::Builder::default()
    }
}

/// <p>An S3 bucket where you want to store the results of this request.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct S3OutputLocation {
    /// <p>(Deprecated) You can no longer specify this parameter. The system ignores it. Instead, Systems Manager
    /// automatically determines the Region of the S3 bucket.</p>
    #[serde(rename = "OutputS3Region")]
    #[serde(default)]
    pub output_s3_region: std::option::Option<std::string::String>,
    /// <p>The name of the S3 bucket.</p>
    #[serde(rename = "OutputS3BucketName")]
    #[serde(default)]
    pub output_s3_bucket_name: std::option::Option<std::string::String>,
    /// <p>The S3 bucket subfolder.</p>
    #[serde(rename = "OutputS3KeyPrefix")]
    #[serde(default)]
    pub output_s3_key_prefix: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for S3OutputLocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3OutputLocation");
        formatter.field("output_s3_region", &self.output_s3_region);
        formatter.field("output_s3_bucket_name", &self.output_s3_bucket_name);
        formatter.field("output_s3_key_prefix", &self.output_s3_key_prefix);
        formatter.finish()
    }
}
/// See [`S3OutputLocation`](crate::model::S3OutputLocation)
pub mod s3_output_location {
    /// A builder for [`S3OutputLocation`](crate::model::S3OutputLocation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) output_s3_region: std::option::Option<std::string::String>,
        pub(crate) output_s3_bucket_name: std::option::Option<std::string::String>,
        pub(crate) output_s3_key_prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>(Deprecated) You can no longer specify this parameter. The system ignores it. Instead, Systems Manager
        /// automatically determines the Region of the S3 bucket.</p>
        pub fn output_s3_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_s3_region = Some(input.into());
            self
        }
        pub fn set_output_s3_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_s3_region = input;
            self
        }
        /// <p>The name of the S3 bucket.</p>
        pub fn output_s3_bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_s3_bucket_name = Some(input.into());
            self
        }
        pub fn set_output_s3_bucket_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_s3_bucket_name = input;
            self
        }
        /// <p>The S3 bucket subfolder.</p>
        pub fn output_s3_key_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_s3_key_prefix = Some(input.into());
            self
        }
        pub fn set_output_s3_key_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_s3_key_prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`S3OutputLocation`](crate::model::S3OutputLocation)
        pub fn build(self) -> crate::model::S3OutputLocation {
            crate::model::S3OutputLocation {
                output_s3_region: self.output_s3_region,
                output_s3_bucket_name: self.output_s3_bucket_name,
                output_s3_key_prefix: self.output_s3_key_prefix,
            }
        }
    }
}
impl S3OutputLocation {
    /// Creates a new builder-style object to manufacture [`S3OutputLocation`](crate::model::S3OutputLocation)
    pub fn builder() -> crate::model::s3_output_location::Builder {
        crate::model::s3_output_location::Builder::default()
    }
}

/// <p>Information about the association.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociationOverview {
    /// <p>The status of the association. Status can be: Pending, Success, or Failed.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<std::string::String>,
    /// <p>A detailed status of the association.</p>
    #[serde(rename = "DetailedStatus")]
    #[serde(default)]
    pub detailed_status: std::option::Option<std::string::String>,
    /// <p>Returns the number of targets for the association status. For example, if you created an
    /// association with two instances, and one of them was successful, this would return the count of
    /// instances by status.</p>
    #[serde(rename = "AssociationStatusAggregatedCount")]
    #[serde(default)]
    pub association_status_aggregated_count:
        std::option::Option<std::collections::HashMap<std::string::String, i32>>,
}
impl std::fmt::Debug for AssociationOverview {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociationOverview");
        formatter.field("status", &self.status);
        formatter.field("detailed_status", &self.detailed_status);
        formatter.field(
            "association_status_aggregated_count",
            &self.association_status_aggregated_count,
        );
        formatter.finish()
    }
}
/// See [`AssociationOverview`](crate::model::AssociationOverview)
pub mod association_overview {
    /// A builder for [`AssociationOverview`](crate::model::AssociationOverview)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) detailed_status: std::option::Option<std::string::String>,
        pub(crate) association_status_aggregated_count:
            std::option::Option<std::collections::HashMap<std::string::String, i32>>,
    }
    impl Builder {
        /// <p>The status of the association. Status can be: Pending, Success, or Failed.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>A detailed status of the association.</p>
        pub fn detailed_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.detailed_status = Some(input.into());
            self
        }
        pub fn set_detailed_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.detailed_status = input;
            self
        }
        pub fn association_status_aggregated_count(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<i32>,
        ) -> Self {
            let mut hash_map = self.association_status_aggregated_count.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.association_status_aggregated_count = Some(hash_map);
            self
        }
        pub fn set_association_status_aggregated_count(
            mut self,
            input: std::option::Option<std::collections::HashMap<std::string::String, i32>>,
        ) -> Self {
            self.association_status_aggregated_count = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociationOverview`](crate::model::AssociationOverview)
        pub fn build(self) -> crate::model::AssociationOverview {
            crate::model::AssociationOverview {
                status: self.status,
                detailed_status: self.detailed_status,
                association_status_aggregated_count: self.association_status_aggregated_count,
            }
        }
    }
}
impl AssociationOverview {
    /// Creates a new builder-style object to manufacture [`AssociationOverview`](crate::model::AssociationOverview)
    pub fn builder() -> crate::model::association_overview::Builder {
        crate::model::association_overview::Builder::default()
    }
}

/// <p>Describes an association status.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociationStatus {
    /// <p>The date when the status changed.</p>
    #[serde(rename = "Date")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub date: std::option::Option<smithy_types::Instant>,
    /// <p>The status.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<crate::model::AssociationStatusName>,
    /// <p>The reason for the status.</p>
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
    /// <p>A user-defined string.</p>
    #[serde(rename = "AdditionalInfo")]
    #[serde(default)]
    pub additional_info: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AssociationStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociationStatus");
        formatter.field("date", &self.date);
        formatter.field("name", &self.name);
        formatter.field("message", &self.message);
        formatter.field("additional_info", &self.additional_info);
        formatter.finish()
    }
}
/// See [`AssociationStatus`](crate::model::AssociationStatus)
pub mod association_status {
    /// A builder for [`AssociationStatus`](crate::model::AssociationStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) date: std::option::Option<smithy_types::Instant>,
        pub(crate) name: std::option::Option<crate::model::AssociationStatusName>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) additional_info: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The date when the status changed.</p>
        pub fn date(mut self, input: smithy_types::Instant) -> Self {
            self.date = Some(input);
            self
        }
        pub fn set_date(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.date = input;
            self
        }
        /// <p>The status.</p>
        pub fn name(mut self, input: crate::model::AssociationStatusName) -> Self {
            self.name = Some(input);
            self
        }
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::AssociationStatusName>,
        ) -> Self {
            self.name = input;
            self
        }
        /// <p>The reason for the status.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>A user-defined string.</p>
        pub fn additional_info(mut self, input: impl Into<std::string::String>) -> Self {
            self.additional_info = Some(input.into());
            self
        }
        pub fn set_additional_info(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.additional_info = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociationStatus`](crate::model::AssociationStatus)
        pub fn build(self) -> crate::model::AssociationStatus {
            crate::model::AssociationStatus {
                date: self.date,
                name: self.name,
                message: self.message,
                additional_info: self.additional_info,
            }
        }
    }
}
impl AssociationStatus {
    /// Creates a new builder-style object to manufacture [`AssociationStatus`](crate::model::AssociationStatus)
    pub fn builder() -> crate::model::association_status::Builder {
        crate::model::association_status::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssociationStatusName {
    Failed,
    Pending,
    Success,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AssociationStatusName {
    fn from(s: &str) -> Self {
        match s {
            "Failed" => AssociationStatusName::Failed,
            "Pending" => AssociationStatusName::Pending,
            "Success" => AssociationStatusName::Success,
            other => AssociationStatusName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AssociationStatusName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(AssociationStatusName::from(s))
    }
}
impl AssociationStatusName {
    pub fn as_str(&self) -> &str {
        match self {
            AssociationStatusName::Failed => "Failed",
            AssociationStatusName::Pending => "Pending",
            AssociationStatusName::Success => "Success",
            AssociationStatusName::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for AssociationStatusName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for AssociationStatusName {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StopType {
    Cancel,
    Complete,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StopType {
    fn from(s: &str) -> Self {
        match s {
            "Cancel" => StopType::Cancel,
            "Complete" => StopType::Complete,
            other => StopType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StopType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(StopType::from(s))
    }
}
impl StopType {
    pub fn as_str(&self) -> &str {
        match self {
            StopType::Cancel => "Cancel",
            StopType::Complete => "Complete",
            StopType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for StopType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for StopType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Information about an Automation runbook (Automation document) used in a runbook workflow in
/// Change Manager.</p>
/// <note>
/// <p>The Automation runbooks specified for the runbook workflow can't run until all required
/// approvals for the change request have been received.</p>
/// </note>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct Runbook {
    /// <p>The name of the Automation runbook (Automation document) used in a runbook workflow.</p>
    #[serde(rename = "DocumentName")]
    #[serde(default)]
    pub document_name: std::option::Option<std::string::String>,
    /// <p>The version of the Automation runbook (Automation document) used in a
    /// runbook workflow.</p>
    #[serde(rename = "DocumentVersion")]
    #[serde(default)]
    pub document_version: std::option::Option<std::string::String>,
    /// <p>The key-value map of execution parameters, which were supplied when calling
    /// <code>StartChangeRequestExecution</code>.</p>
    #[serde(rename = "Parameters")]
    #[serde(default)]
    pub parameters: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The name of the parameter used as the target resource for the rate-controlled
    /// runbook workflow. Required if you specify <code>Targets</code>. </p>
    #[serde(rename = "TargetParameterName")]
    #[serde(default)]
    pub target_parameter_name: std::option::Option<std::string::String>,
    /// <p>A key-value mapping to target resources that the Runbook operation performs tasks on.
    /// Required if you specify <code>TargetParameterName</code>.</p>
    #[serde(rename = "Targets")]
    #[serde(default)]
    pub targets: std::option::Option<std::vec::Vec<crate::model::Target>>,
    /// <p>The <code>MaxConcurrency</code> value specified by the user when the operation started,
    /// indicating the maximum number of resources that the runbook operation can run on at the same
    /// time.</p>
    #[serde(rename = "MaxConcurrency")]
    #[serde(default)]
    pub max_concurrency: std::option::Option<std::string::String>,
    /// <p>The <code>MaxErrors</code> value specified by the user when the execution started,
    /// indicating the maximum number of errors that can occur during the operation before the updates
    /// are stopped or rolled back.</p>
    #[serde(rename = "MaxErrors")]
    #[serde(default)]
    pub max_errors: std::option::Option<std::string::String>,
    /// <p>Information about the AWS Regions and accounts targeted by the current Runbook
    /// operation.</p>
    #[serde(rename = "TargetLocations")]
    #[serde(default)]
    pub target_locations: std::option::Option<std::vec::Vec<crate::model::TargetLocation>>,
}
impl std::fmt::Debug for Runbook {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Runbook");
        formatter.field("document_name", &self.document_name);
        formatter.field("document_version", &self.document_version);
        formatter.field("parameters", &self.parameters);
        formatter.field("target_parameter_name", &self.target_parameter_name);
        formatter.field("targets", &self.targets);
        formatter.field("max_concurrency", &self.max_concurrency);
        formatter.field("max_errors", &self.max_errors);
        formatter.field("target_locations", &self.target_locations);
        formatter.finish()
    }
}
/// See [`Runbook`](crate::model::Runbook)
pub mod runbook {
    /// A builder for [`Runbook`](crate::model::Runbook)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_name: std::option::Option<std::string::String>,
        pub(crate) document_version: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) target_parameter_name: std::option::Option<std::string::String>,
        pub(crate) targets: std::option::Option<std::vec::Vec<crate::model::Target>>,
        pub(crate) max_concurrency: std::option::Option<std::string::String>,
        pub(crate) max_errors: std::option::Option<std::string::String>,
        pub(crate) target_locations:
            std::option::Option<std::vec::Vec<crate::model::TargetLocation>>,
    }
    impl Builder {
        /// <p>The name of the Automation runbook (Automation document) used in a runbook workflow.</p>
        pub fn document_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_name = Some(input.into());
            self
        }
        pub fn set_document_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_name = input;
            self
        }
        /// <p>The version of the Automation runbook (Automation document) used in a
        /// runbook workflow.</p>
        pub fn document_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_version = Some(input.into());
            self
        }
        pub fn set_document_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_version = input;
            self
        }
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// <p>The name of the parameter used as the target resource for the rate-controlled
        /// runbook workflow. Required if you specify <code>Targets</code>. </p>
        pub fn target_parameter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_parameter_name = Some(input.into());
            self
        }
        pub fn set_target_parameter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_parameter_name = input;
            self
        }
        pub fn targets(mut self, input: impl Into<crate::model::Target>) -> Self {
            let mut v = self.targets.unwrap_or_default();
            v.push(input.into());
            self.targets = Some(v);
            self
        }
        pub fn set_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Target>>,
        ) -> Self {
            self.targets = input;
            self
        }
        /// <p>The <code>MaxConcurrency</code> value specified by the user when the operation started,
        /// indicating the maximum number of resources that the runbook operation can run on at the same
        /// time.</p>
        pub fn max_concurrency(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_concurrency = Some(input.into());
            self
        }
        pub fn set_max_concurrency(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.max_concurrency = input;
            self
        }
        /// <p>The <code>MaxErrors</code> value specified by the user when the execution started,
        /// indicating the maximum number of errors that can occur during the operation before the updates
        /// are stopped or rolled back.</p>
        pub fn max_errors(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_errors = Some(input.into());
            self
        }
        pub fn set_max_errors(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_errors = input;
            self
        }
        pub fn target_locations(mut self, input: impl Into<crate::model::TargetLocation>) -> Self {
            let mut v = self.target_locations.unwrap_or_default();
            v.push(input.into());
            self.target_locations = Some(v);
            self
        }
        pub fn set_target_locations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TargetLocation>>,
        ) -> Self {
            self.target_locations = input;
            self
        }
        /// Consumes the builder and constructs a [`Runbook`](crate::model::Runbook)
        pub fn build(self) -> crate::model::Runbook {
            crate::model::Runbook {
                document_name: self.document_name,
                document_version: self.document_version,
                parameters: self.parameters,
                target_parameter_name: self.target_parameter_name,
                targets: self.targets,
                max_concurrency: self.max_concurrency,
                max_errors: self.max_errors,
                target_locations: self.target_locations,
            }
        }
    }
}
impl Runbook {
    /// Creates a new builder-style object to manufacture [`Runbook`](crate::model::Runbook)
    pub fn builder() -> crate::model::runbook::Builder {
        crate::model::runbook::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ExecutionMode {
    Auto,
    Interactive,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ExecutionMode {
    fn from(s: &str) -> Self {
        match s {
            "Auto" => ExecutionMode::Auto,
            "Interactive" => ExecutionMode::Interactive,
            other => ExecutionMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ExecutionMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ExecutionMode::from(s))
    }
}
impl ExecutionMode {
    pub fn as_str(&self) -> &str {
        match self {
            ExecutionMode::Auto => "Auto",
            ExecutionMode::Interactive => "Interactive",
            ExecutionMode::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ExecutionMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ExecutionMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Describes a command request.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct Command {
    /// <p>A unique identifier for this command.</p>
    #[serde(rename = "CommandId")]
    #[serde(default)]
    pub command_id: std::option::Option<std::string::String>,
    /// <p>The name of the document requested for execution.</p>
    #[serde(rename = "DocumentName")]
    #[serde(default)]
    pub document_name: std::option::Option<std::string::String>,
    /// <p>The SSM document version.</p>
    #[serde(rename = "DocumentVersion")]
    #[serde(default)]
    pub document_version: std::option::Option<std::string::String>,
    /// <p>User-specified information about the command, such as a brief description of what the
    /// command should do.</p>
    #[serde(rename = "Comment")]
    #[serde(default)]
    pub comment: std::option::Option<std::string::String>,
    /// <p>If this time is reached and the command has not already started running, it will not run.
    /// Calculated based on the ExpiresAfter user input provided as part of the SendCommand API.</p>
    #[serde(rename = "ExpiresAfter")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub expires_after: std::option::Option<smithy_types::Instant>,
    /// <p>The parameter values to be inserted in the document when running the command.</p>
    #[serde(rename = "Parameters")]
    #[serde(default)]
    pub parameters: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The instance IDs against which this command was requested.</p>
    #[serde(rename = "InstanceIds")]
    #[serde(default)]
    pub instance_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An array of search criteria that targets instances using a Key,Value combination that you
    /// specify. Targets is required if you don't provide one or more instance IDs in the call.</p>
    #[serde(rename = "Targets")]
    #[serde(default)]
    pub targets: std::option::Option<std::vec::Vec<crate::model::Target>>,
    /// <p>The date and time the command was requested.</p>
    #[serde(rename = "RequestedDateTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub requested_date_time: std::option::Option<smithy_types::Instant>,
    /// <p>The status of the command.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::CommandStatus>,
    /// <p>A detailed status of the command execution. StatusDetails includes more information than
    /// Status because it includes states resulting from error and concurrency control parameters.
    /// StatusDetails can show different results than Status. For more information about these statuses,
    /// see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html">Understanding command statuses</a> in the <i>AWS Systems Manager User Guide</i>.
    /// StatusDetails can be one of the following values:</p>
    /// <ul>
    /// <li>
    /// <p>Pending: The command has not been sent to any instances.</p>
    /// </li>
    /// <li>
    /// <p>In Progress: The command has been sent to at least one instance but has not reached a
    /// final state on all instances.</p>
    /// </li>
    /// <li>
    /// <p>Success: The command successfully ran on all invocations. This is a terminal state.</p>
    /// </li>
    /// <li>
    /// <p>Delivery Timed Out: The value of MaxErrors or more command invocations shows a status of
    /// Delivery Timed Out. This is a terminal state.</p>
    /// </li>
    /// <li>
    /// <p>Execution Timed Out: The value of MaxErrors or more command invocations shows a status of
    /// Execution Timed Out. This is a terminal state.</p>
    /// </li>
    /// <li>
    /// <p>Failed: The value of MaxErrors or more command invocations shows a status of Failed. This
    /// is a terminal state.</p>
    /// </li>
    /// <li>
    /// <p>Incomplete: The command was attempted on all instances and one or more invocations does
    /// not have a value of Success but not enough invocations failed for the status to be Failed. This
    /// is a terminal state.</p>
    /// </li>
    /// <li>
    /// <p>Canceled: The command was terminated before it was completed. This is a terminal
    /// state.</p>
    /// </li>
    /// <li>
    /// <p>Rate Exceeded: The number of instances targeted by the command exceeded the account limit
    /// for pending invocations. The system has canceled the command before running it on any instance.
    /// This is a terminal state.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "StatusDetails")]
    #[serde(default)]
    pub status_details: std::option::Option<std::string::String>,
    /// <p>(Deprecated) You can no longer specify this parameter. The system ignores it. Instead, Systems Manager
    /// automatically determines the Region of the S3 bucket.</p>
    #[serde(rename = "OutputS3Region")]
    #[serde(default)]
    pub output_s3_region: std::option::Option<std::string::String>,
    /// <p>The S3 bucket where the responses to the command executions should be stored. This was
    /// requested when issuing the command.</p>
    #[serde(rename = "OutputS3BucketName")]
    #[serde(default)]
    pub output_s3_bucket_name: std::option::Option<std::string::String>,
    /// <p>The S3 directory path inside the bucket where the responses to the command executions should
    /// be stored. This was requested when issuing the command.</p>
    #[serde(rename = "OutputS3KeyPrefix")]
    #[serde(default)]
    pub output_s3_key_prefix: std::option::Option<std::string::String>,
    /// <p>The maximum number of instances that are allowed to run the command at the same time. You
    /// can specify a number of instances, such as 10, or a percentage of instances, such as 10%. The
    /// default value is 50. For more information about how to use MaxConcurrency, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/run-command.html">Running commands
    /// using Systems Manager Run Command</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    #[serde(rename = "MaxConcurrency")]
    #[serde(default)]
    pub max_concurrency: std::option::Option<std::string::String>,
    /// <p>The maximum number of errors allowed before the system stops sending the command to
    /// additional targets. You can specify a number of errors, such as 10, or a percentage or errors,
    /// such as 10%. The default value is 0. For more information about how to use MaxErrors, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/run-command.html">Running commands
    /// using Systems Manager Run Command</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    #[serde(rename = "MaxErrors")]
    #[serde(default)]
    pub max_errors: std::option::Option<std::string::String>,
    /// <p>The number of targets for the command.</p>
    #[serde(rename = "TargetCount")]
    #[serde(default)]
    pub target_count: i32,
    /// <p>The number of targets for which the command invocation reached a terminal state. Terminal
    /// states include the following: Success, Failed, Execution Timed Out, Delivery Timed Out, Canceled,
    /// Terminated, or Undeliverable.</p>
    #[serde(rename = "CompletedCount")]
    #[serde(default)]
    pub completed_count: i32,
    /// <p>The number of targets for which the status is Failed or Execution Timed Out.</p>
    #[serde(rename = "ErrorCount")]
    #[serde(default)]
    pub error_count: i32,
    /// <p>The number of targets for which the status is Delivery Timed Out.</p>
    #[serde(rename = "DeliveryTimedOutCount")]
    #[serde(default)]
    pub delivery_timed_out_count: i32,
    /// <p>The IAM service role that Run Command uses to act on your behalf when sending notifications
    /// about command status changes. </p>
    #[serde(rename = "ServiceRole")]
    #[serde(default)]
    pub service_role: std::option::Option<std::string::String>,
    /// <p>Configurations for sending notifications about command status changes. </p>
    #[serde(rename = "NotificationConfig")]
    #[serde(default)]
    pub notification_config: std::option::Option<crate::model::NotificationConfig>,
    /// <p>CloudWatch Logs information where you want Systems Manager to send the command output.</p>
    #[serde(rename = "CloudWatchOutputConfig")]
    #[serde(default)]
    pub cloud_watch_output_config: std::option::Option<crate::model::CloudWatchOutputConfig>,
    /// <p>The <code>TimeoutSeconds</code> value specified for a command.</p>
    #[serde(rename = "TimeoutSeconds")]
    #[serde(default)]
    pub timeout_seconds: i32,
}
impl std::fmt::Debug for Command {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Command");
        formatter.field("command_id", &self.command_id);
        formatter.field("document_name", &self.document_name);
        formatter.field("document_version", &self.document_version);
        formatter.field("comment", &self.comment);
        formatter.field("expires_after", &self.expires_after);
        formatter.field("parameters", &self.parameters);
        formatter.field("instance_ids", &self.instance_ids);
        formatter.field("targets", &self.targets);
        formatter.field("requested_date_time", &self.requested_date_time);
        formatter.field("status", &self.status);
        formatter.field("status_details", &self.status_details);
        formatter.field("output_s3_region", &self.output_s3_region);
        formatter.field("output_s3_bucket_name", &self.output_s3_bucket_name);
        formatter.field("output_s3_key_prefix", &self.output_s3_key_prefix);
        formatter.field("max_concurrency", &self.max_concurrency);
        formatter.field("max_errors", &self.max_errors);
        formatter.field("target_count", &self.target_count);
        formatter.field("completed_count", &self.completed_count);
        formatter.field("error_count", &self.error_count);
        formatter.field("delivery_timed_out_count", &self.delivery_timed_out_count);
        formatter.field("service_role", &self.service_role);
        formatter.field("notification_config", &self.notification_config);
        formatter.field("cloud_watch_output_config", &self.cloud_watch_output_config);
        formatter.field("timeout_seconds", &self.timeout_seconds);
        formatter.finish()
    }
}
/// See [`Command`](crate::model::Command)
pub mod command {
    /// A builder for [`Command`](crate::model::Command)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) command_id: std::option::Option<std::string::String>,
        pub(crate) document_name: std::option::Option<std::string::String>,
        pub(crate) document_version: std::option::Option<std::string::String>,
        pub(crate) comment: std::option::Option<std::string::String>,
        pub(crate) expires_after: std::option::Option<smithy_types::Instant>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) instance_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) targets: std::option::Option<std::vec::Vec<crate::model::Target>>,
        pub(crate) requested_date_time: std::option::Option<smithy_types::Instant>,
        pub(crate) status: std::option::Option<crate::model::CommandStatus>,
        pub(crate) status_details: std::option::Option<std::string::String>,
        pub(crate) output_s3_region: std::option::Option<std::string::String>,
        pub(crate) output_s3_bucket_name: std::option::Option<std::string::String>,
        pub(crate) output_s3_key_prefix: std::option::Option<std::string::String>,
        pub(crate) max_concurrency: std::option::Option<std::string::String>,
        pub(crate) max_errors: std::option::Option<std::string::String>,
        pub(crate) target_count: std::option::Option<i32>,
        pub(crate) completed_count: std::option::Option<i32>,
        pub(crate) error_count: std::option::Option<i32>,
        pub(crate) delivery_timed_out_count: std::option::Option<i32>,
        pub(crate) service_role: std::option::Option<std::string::String>,
        pub(crate) notification_config: std::option::Option<crate::model::NotificationConfig>,
        pub(crate) cloud_watch_output_config:
            std::option::Option<crate::model::CloudWatchOutputConfig>,
        pub(crate) timeout_seconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>A unique identifier for this command.</p>
        pub fn command_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.command_id = Some(input.into());
            self
        }
        pub fn set_command_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.command_id = input;
            self
        }
        /// <p>The name of the document requested for execution.</p>
        pub fn document_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_name = Some(input.into());
            self
        }
        pub fn set_document_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_name = input;
            self
        }
        /// <p>The SSM document version.</p>
        pub fn document_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_version = Some(input.into());
            self
        }
        pub fn set_document_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_version = input;
            self
        }
        /// <p>User-specified information about the command, such as a brief description of what the
        /// command should do.</p>
        pub fn comment(mut self, input: impl Into<std::string::String>) -> Self {
            self.comment = Some(input.into());
            self
        }
        pub fn set_comment(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.comment = input;
            self
        }
        /// <p>If this time is reached and the command has not already started running, it will not run.
        /// Calculated based on the ExpiresAfter user input provided as part of the SendCommand API.</p>
        pub fn expires_after(mut self, input: smithy_types::Instant) -> Self {
            self.expires_after = Some(input);
            self
        }
        pub fn set_expires_after(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.expires_after = input;
            self
        }
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        pub fn instance_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.instance_ids.unwrap_or_default();
            v.push(input.into());
            self.instance_ids = Some(v);
            self
        }
        pub fn set_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.instance_ids = input;
            self
        }
        pub fn targets(mut self, input: impl Into<crate::model::Target>) -> Self {
            let mut v = self.targets.unwrap_or_default();
            v.push(input.into());
            self.targets = Some(v);
            self
        }
        pub fn set_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Target>>,
        ) -> Self {
            self.targets = input;
            self
        }
        /// <p>The date and time the command was requested.</p>
        pub fn requested_date_time(mut self, input: smithy_types::Instant) -> Self {
            self.requested_date_time = Some(input);
            self
        }
        pub fn set_requested_date_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.requested_date_time = input;
            self
        }
        /// <p>The status of the command.</p>
        pub fn status(mut self, input: crate::model::CommandStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::CommandStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>A detailed status of the command execution. StatusDetails includes more information than
        /// Status because it includes states resulting from error and concurrency control parameters.
        /// StatusDetails can show different results than Status. For more information about these statuses,
        /// see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html">Understanding command statuses</a> in the <i>AWS Systems Manager User Guide</i>.
        /// StatusDetails can be one of the following values:</p>
        /// <ul>
        /// <li>
        /// <p>Pending: The command has not been sent to any instances.</p>
        /// </li>
        /// <li>
        /// <p>In Progress: The command has been sent to at least one instance but has not reached a
        /// final state on all instances.</p>
        /// </li>
        /// <li>
        /// <p>Success: The command successfully ran on all invocations. This is a terminal state.</p>
        /// </li>
        /// <li>
        /// <p>Delivery Timed Out: The value of MaxErrors or more command invocations shows a status of
        /// Delivery Timed Out. This is a terminal state.</p>
        /// </li>
        /// <li>
        /// <p>Execution Timed Out: The value of MaxErrors or more command invocations shows a status of
        /// Execution Timed Out. This is a terminal state.</p>
        /// </li>
        /// <li>
        /// <p>Failed: The value of MaxErrors or more command invocations shows a status of Failed. This
        /// is a terminal state.</p>
        /// </li>
        /// <li>
        /// <p>Incomplete: The command was attempted on all instances and one or more invocations does
        /// not have a value of Success but not enough invocations failed for the status to be Failed. This
        /// is a terminal state.</p>
        /// </li>
        /// <li>
        /// <p>Canceled: The command was terminated before it was completed. This is a terminal
        /// state.</p>
        /// </li>
        /// <li>
        /// <p>Rate Exceeded: The number of instances targeted by the command exceeded the account limit
        /// for pending invocations. The system has canceled the command before running it on any instance.
        /// This is a terminal state.</p>
        /// </li>
        /// </ul>
        pub fn status_details(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_details = Some(input.into());
            self
        }
        pub fn set_status_details(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_details = input;
            self
        }
        /// <p>(Deprecated) You can no longer specify this parameter. The system ignores it. Instead, Systems Manager
        /// automatically determines the Region of the S3 bucket.</p>
        pub fn output_s3_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_s3_region = Some(input.into());
            self
        }
        pub fn set_output_s3_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_s3_region = input;
            self
        }
        /// <p>The S3 bucket where the responses to the command executions should be stored. This was
        /// requested when issuing the command.</p>
        pub fn output_s3_bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_s3_bucket_name = Some(input.into());
            self
        }
        pub fn set_output_s3_bucket_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_s3_bucket_name = input;
            self
        }
        /// <p>The S3 directory path inside the bucket where the responses to the command executions should
        /// be stored. This was requested when issuing the command.</p>
        pub fn output_s3_key_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_s3_key_prefix = Some(input.into());
            self
        }
        pub fn set_output_s3_key_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_s3_key_prefix = input;
            self
        }
        /// <p>The maximum number of instances that are allowed to run the command at the same time. You
        /// can specify a number of instances, such as 10, or a percentage of instances, such as 10%. The
        /// default value is 50. For more information about how to use MaxConcurrency, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/run-command.html">Running commands
        /// using Systems Manager Run Command</a> in the <i>AWS Systems Manager User Guide</i>.</p>
        pub fn max_concurrency(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_concurrency = Some(input.into());
            self
        }
        pub fn set_max_concurrency(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.max_concurrency = input;
            self
        }
        /// <p>The maximum number of errors allowed before the system stops sending the command to
        /// additional targets. You can specify a number of errors, such as 10, or a percentage or errors,
        /// such as 10%. The default value is 0. For more information about how to use MaxErrors, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/run-command.html">Running commands
        /// using Systems Manager Run Command</a> in the <i>AWS Systems Manager User Guide</i>.</p>
        pub fn max_errors(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_errors = Some(input.into());
            self
        }
        pub fn set_max_errors(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_errors = input;
            self
        }
        /// <p>The number of targets for the command.</p>
        pub fn target_count(mut self, input: i32) -> Self {
            self.target_count = Some(input);
            self
        }
        pub fn set_target_count(mut self, input: std::option::Option<i32>) -> Self {
            self.target_count = input;
            self
        }
        /// <p>The number of targets for which the command invocation reached a terminal state. Terminal
        /// states include the following: Success, Failed, Execution Timed Out, Delivery Timed Out, Canceled,
        /// Terminated, or Undeliverable.</p>
        pub fn completed_count(mut self, input: i32) -> Self {
            self.completed_count = Some(input);
            self
        }
        pub fn set_completed_count(mut self, input: std::option::Option<i32>) -> Self {
            self.completed_count = input;
            self
        }
        /// <p>The number of targets for which the status is Failed or Execution Timed Out.</p>
        pub fn error_count(mut self, input: i32) -> Self {
            self.error_count = Some(input);
            self
        }
        pub fn set_error_count(mut self, input: std::option::Option<i32>) -> Self {
            self.error_count = input;
            self
        }
        /// <p>The number of targets for which the status is Delivery Timed Out.</p>
        pub fn delivery_timed_out_count(mut self, input: i32) -> Self {
            self.delivery_timed_out_count = Some(input);
            self
        }
        pub fn set_delivery_timed_out_count(mut self, input: std::option::Option<i32>) -> Self {
            self.delivery_timed_out_count = input;
            self
        }
        /// <p>The IAM service role that Run Command uses to act on your behalf when sending notifications
        /// about command status changes. </p>
        pub fn service_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_role = Some(input.into());
            self
        }
        pub fn set_service_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_role = input;
            self
        }
        /// <p>Configurations for sending notifications about command status changes. </p>
        pub fn notification_config(mut self, input: crate::model::NotificationConfig) -> Self {
            self.notification_config = Some(input);
            self
        }
        pub fn set_notification_config(
            mut self,
            input: std::option::Option<crate::model::NotificationConfig>,
        ) -> Self {
            self.notification_config = input;
            self
        }
        /// <p>CloudWatch Logs information where you want Systems Manager to send the command output.</p>
        pub fn cloud_watch_output_config(
            mut self,
            input: crate::model::CloudWatchOutputConfig,
        ) -> Self {
            self.cloud_watch_output_config = Some(input);
            self
        }
        pub fn set_cloud_watch_output_config(
            mut self,
            input: std::option::Option<crate::model::CloudWatchOutputConfig>,
        ) -> Self {
            self.cloud_watch_output_config = input;
            self
        }
        /// <p>The <code>TimeoutSeconds</code> value specified for a command.</p>
        pub fn timeout_seconds(mut self, input: i32) -> Self {
            self.timeout_seconds = Some(input);
            self
        }
        pub fn set_timeout_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.timeout_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`Command`](crate::model::Command)
        pub fn build(self) -> crate::model::Command {
            crate::model::Command {
                command_id: self.command_id,
                document_name: self.document_name,
                document_version: self.document_version,
                comment: self.comment,
                expires_after: self.expires_after,
                parameters: self.parameters,
                instance_ids: self.instance_ids,
                targets: self.targets,
                requested_date_time: self.requested_date_time,
                status: self.status,
                status_details: self.status_details,
                output_s3_region: self.output_s3_region,
                output_s3_bucket_name: self.output_s3_bucket_name,
                output_s3_key_prefix: self.output_s3_key_prefix,
                max_concurrency: self.max_concurrency,
                max_errors: self.max_errors,
                target_count: self.target_count.unwrap_or_default(),
                completed_count: self.completed_count.unwrap_or_default(),
                error_count: self.error_count.unwrap_or_default(),
                delivery_timed_out_count: self.delivery_timed_out_count.unwrap_or_default(),
                service_role: self.service_role,
                notification_config: self.notification_config,
                cloud_watch_output_config: self.cloud_watch_output_config,
                timeout_seconds: self.timeout_seconds.unwrap_or_default(),
            }
        }
    }
}
impl Command {
    /// Creates a new builder-style object to manufacture [`Command`](crate::model::Command)
    pub fn builder() -> crate::model::command::Builder {
        crate::model::command::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CommandStatus {
    Cancelled,
    Cancelling,
    Failed,
    InProgress,
    Pending,
    Success,
    TimedOut,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CommandStatus {
    fn from(s: &str) -> Self {
        match s {
            "Cancelled" => CommandStatus::Cancelled,
            "Cancelling" => CommandStatus::Cancelling,
            "Failed" => CommandStatus::Failed,
            "InProgress" => CommandStatus::InProgress,
            "Pending" => CommandStatus::Pending,
            "Success" => CommandStatus::Success,
            "TimedOut" => CommandStatus::TimedOut,
            other => CommandStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CommandStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(CommandStatus::from(s))
    }
}
impl CommandStatus {
    pub fn as_str(&self) -> &str {
        match self {
            CommandStatus::Cancelled => "Cancelled",
            CommandStatus::Cancelling => "Cancelling",
            CommandStatus::Failed => "Failed",
            CommandStatus::InProgress => "InProgress",
            CommandStatus::Pending => "Pending",
            CommandStatus::Success => "Success",
            CommandStatus::TimedOut => "TimedOut",
            CommandStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for CommandStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for CommandStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SignalType {
    Approve,
    Reject,
    Resume,
    StartStep,
    StopStep,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SignalType {
    fn from(s: &str) -> Self {
        match s {
            "Approve" => SignalType::Approve,
            "Reject" => SignalType::Reject,
            "Resume" => SignalType::Resume,
            "StartStep" => SignalType::StartStep,
            "StopStep" => SignalType::StopStep,
            other => SignalType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SignalType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(SignalType::from(s))
    }
}
impl SignalType {
    pub fn as_str(&self) -> &str {
        match self {
            SignalType::Approve => "Approve",
            SignalType::Reject => "Reject",
            SignalType::Resume => "Resume",
            SignalType::StartStep => "StartStep",
            SignalType::StopStep => "StopStep",
            SignalType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for SignalType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for SignalType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>The service setting data structure.</p>
/// <p>
/// <code>ServiceSetting</code> is an account-level setting for an AWS service. This setting
/// defines how a user interacts with or uses a service or a feature of a service. For example, if an
/// AWS service charges money to the account based on feature or service usage, then the AWS service
/// team might create a default setting of "false". This means the user can't use this feature unless
/// they change the setting to "true" and intentionally opt in for a paid feature.</p>
/// <p>Services map a <code>SettingId</code> object to a setting value. AWS services teams define
/// the default value for a <code>SettingId</code>. You can't create a new <code>SettingId</code>,
/// but you can overwrite the default value if you have the <code>ssm:UpdateServiceSetting</code>
/// permission for the setting. Use the <a>UpdateServiceSetting</a> API action to change
/// the default setting. Or, use the <a>ResetServiceSetting</a> to change the value back
/// to the original value defined by the AWS service team.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceSetting {
    /// <p>The ID of the service setting.</p>
    #[serde(rename = "SettingId")]
    #[serde(default)]
    pub setting_id: std::option::Option<std::string::String>,
    /// <p>The value of the service setting.</p>
    #[serde(rename = "SettingValue")]
    #[serde(default)]
    pub setting_value: std::option::Option<std::string::String>,
    /// <p>The last time the service setting was modified.</p>
    #[serde(rename = "LastModifiedDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_date: std::option::Option<smithy_types::Instant>,
    /// <p>The ARN of the last modified user. This field is populated only if the setting value was
    /// overwritten.</p>
    #[serde(rename = "LastModifiedUser")]
    #[serde(default)]
    pub last_modified_user: std::option::Option<std::string::String>,
    /// <p>The ARN of the service setting.</p>
    #[serde(rename = "ARN")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The status of the service setting. The value can be Default, Customized or
    /// PendingUpdate.</p>
    /// <ul>
    /// <li>
    /// <p>Default: The current setting uses a default value provisioned by the AWS service
    /// team.</p>
    /// </li>
    /// <li>
    /// <p>Customized: The current setting use a custom value specified by the customer.</p>
    /// </li>
    /// <li>
    /// <p>PendingUpdate: The current setting uses a default or custom value, but a setting change
    /// request is pending approval.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceSetting {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceSetting");
        formatter.field("setting_id", &self.setting_id);
        formatter.field("setting_value", &self.setting_value);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("last_modified_user", &self.last_modified_user);
        formatter.field("arn", &self.arn);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`ServiceSetting`](crate::model::ServiceSetting)
pub mod service_setting {
    /// A builder for [`ServiceSetting`](crate::model::ServiceSetting)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) setting_id: std::option::Option<std::string::String>,
        pub(crate) setting_value: std::option::Option<std::string::String>,
        pub(crate) last_modified_date: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_user: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the service setting.</p>
        pub fn setting_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.setting_id = Some(input.into());
            self
        }
        pub fn set_setting_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.setting_id = input;
            self
        }
        /// <p>The value of the service setting.</p>
        pub fn setting_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.setting_value = Some(input.into());
            self
        }
        pub fn set_setting_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.setting_value = input;
            self
        }
        /// <p>The last time the service setting was modified.</p>
        pub fn last_modified_date(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_date = Some(input);
            self
        }
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>The ARN of the last modified user. This field is populated only if the setting value was
        /// overwritten.</p>
        pub fn last_modified_user(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_user = Some(input.into());
            self
        }
        pub fn set_last_modified_user(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_user = input;
            self
        }
        /// <p>The ARN of the service setting.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The status of the service setting. The value can be Default, Customized or
        /// PendingUpdate.</p>
        /// <ul>
        /// <li>
        /// <p>Default: The current setting uses a default value provisioned by the AWS service
        /// team.</p>
        /// </li>
        /// <li>
        /// <p>Customized: The current setting use a custom value specified by the customer.</p>
        /// </li>
        /// <li>
        /// <p>PendingUpdate: The current setting uses a default or custom value, but a setting change
        /// request is pending approval.</p>
        /// </li>
        /// </ul>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceSetting`](crate::model::ServiceSetting)
        pub fn build(self) -> crate::model::ServiceSetting {
            crate::model::ServiceSetting {
                setting_id: self.setting_id,
                setting_value: self.setting_value,
                last_modified_date: self.last_modified_date,
                last_modified_user: self.last_modified_user,
                arn: self.arn,
                status: self.status,
            }
        }
    }
}
impl ServiceSetting {
    /// Creates a new builder-style object to manufacture [`ServiceSetting`](crate::model::ServiceSetting)
    pub fn builder() -> crate::model::service_setting::Builder {
        crate::model::service_setting::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceTypeForTagging {
    Document,
    MaintenanceWindow,
    ManagedInstance,
    OpsItem,
    Opsmetadata,
    Parameter,
    PatchBaseline,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ResourceTypeForTagging {
    fn from(s: &str) -> Self {
        match s {
            "Document" => ResourceTypeForTagging::Document,
            "MaintenanceWindow" => ResourceTypeForTagging::MaintenanceWindow,
            "ManagedInstance" => ResourceTypeForTagging::ManagedInstance,
            "OpsItem" => ResourceTypeForTagging::OpsItem,
            "OpsMetadata" => ResourceTypeForTagging::Opsmetadata,
            "Parameter" => ResourceTypeForTagging::Parameter,
            "PatchBaseline" => ResourceTypeForTagging::PatchBaseline,
            other => ResourceTypeForTagging::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ResourceTypeForTagging {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ResourceTypeForTagging::from(s))
    }
}
impl ResourceTypeForTagging {
    pub fn as_str(&self) -> &str {
        match self {
            ResourceTypeForTagging::Document => "Document",
            ResourceTypeForTagging::MaintenanceWindow => "MaintenanceWindow",
            ResourceTypeForTagging::ManagedInstance => "ManagedInstance",
            ResourceTypeForTagging::OpsItem => "OpsItem",
            ResourceTypeForTagging::Opsmetadata => "OpsMetadata",
            ResourceTypeForTagging::Parameter => "Parameter",
            ResourceTypeForTagging::PatchBaseline => "PatchBaseline",
            ResourceTypeForTagging::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ResourceTypeForTagging {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ResourceTypeForTagging {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MaintenanceWindowTaskType {
    Automation,
    Lambda,
    RunCommand,
    StepFunctions,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MaintenanceWindowTaskType {
    fn from(s: &str) -> Self {
        match s {
            "AUTOMATION" => MaintenanceWindowTaskType::Automation,
            "LAMBDA" => MaintenanceWindowTaskType::Lambda,
            "RUN_COMMAND" => MaintenanceWindowTaskType::RunCommand,
            "STEP_FUNCTIONS" => MaintenanceWindowTaskType::StepFunctions,
            other => MaintenanceWindowTaskType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MaintenanceWindowTaskType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(MaintenanceWindowTaskType::from(s))
    }
}
impl MaintenanceWindowTaskType {
    pub fn as_str(&self) -> &str {
        match self {
            MaintenanceWindowTaskType::Automation => "AUTOMATION",
            MaintenanceWindowTaskType::Lambda => "LAMBDA",
            MaintenanceWindowTaskType::RunCommand => "RUN_COMMAND",
            MaintenanceWindowTaskType::StepFunctions => "STEP_FUNCTIONS",
            MaintenanceWindowTaskType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for MaintenanceWindowTaskType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for MaintenanceWindowTaskType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MaintenanceWindowResourceType {
    Instance,
    ResourceGroup,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MaintenanceWindowResourceType {
    fn from(s: &str) -> Self {
        match s {
            "INSTANCE" => MaintenanceWindowResourceType::Instance,
            "RESOURCE_GROUP" => MaintenanceWindowResourceType::ResourceGroup,
            other => MaintenanceWindowResourceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MaintenanceWindowResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(MaintenanceWindowResourceType::from(s))
    }
}
impl MaintenanceWindowResourceType {
    pub fn as_str(&self) -> &str {
        match self {
            MaintenanceWindowResourceType::Instance => "INSTANCE",
            MaintenanceWindowResourceType::ResourceGroup => "RESOURCE_GROUP",
            MaintenanceWindowResourceType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for MaintenanceWindowResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for MaintenanceWindowResourceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ParameterTier {
    Advanced,
    IntelligentTiering,
    Standard,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ParameterTier {
    fn from(s: &str) -> Self {
        match s {
            "Advanced" => ParameterTier::Advanced,
            "Intelligent-Tiering" => ParameterTier::IntelligentTiering,
            "Standard" => ParameterTier::Standard,
            other => ParameterTier::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ParameterTier {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ParameterTier::from(s))
    }
}
impl ParameterTier {
    pub fn as_str(&self) -> &str {
        match self {
            ParameterTier::Advanced => "Advanced",
            ParameterTier::IntelligentTiering => "Intelligent-Tiering",
            ParameterTier::Standard => "Standard",
            ParameterTier::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ParameterTier {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ParameterTier {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ParameterType {
    SecureString,
    String,
    StringList,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ParameterType {
    fn from(s: &str) -> Self {
        match s {
            "SecureString" => ParameterType::SecureString,
            "String" => ParameterType::String,
            "StringList" => ParameterType::StringList,
            other => ParameterType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ParameterType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ParameterType::from(s))
    }
}
impl ParameterType {
    pub fn as_str(&self) -> &str {
        match self {
            ParameterType::SecureString => "SecureString",
            ParameterType::String => "String",
            ParameterType::StringList => "StringList",
            ParameterType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ParameterType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ParameterType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Information collected from managed instances based on your inventory policy document</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InventoryItem {
    /// <p>The name of the inventory type. Default inventory item type names start with AWS. Custom
    /// inventory type names will start with Custom. Default inventory item types include the following:
    /// AWS:AWSComponent, AWS:Application, AWS:InstanceInformation, AWS:Network, and
    /// AWS:WindowsUpdate.</p>
    #[serde(rename = "TypeName")]
    #[serde(default)]
    pub type_name: std::option::Option<std::string::String>,
    /// <p>The schema version for the inventory item.</p>
    #[serde(rename = "SchemaVersion")]
    #[serde(default)]
    pub schema_version: std::option::Option<std::string::String>,
    /// <p>The time the inventory information was collected.</p>
    #[serde(rename = "CaptureTime")]
    #[serde(default)]
    pub capture_time: std::option::Option<std::string::String>,
    /// <p>MD5 hash of the inventory item type contents. The content hash is used to determine whether
    /// to update inventory information. The PutInventory API does not update the inventory item type
    /// contents if the MD5 hash has not changed since last update. </p>
    #[serde(rename = "ContentHash")]
    #[serde(default)]
    pub content_hash: std::option::Option<std::string::String>,
    /// <p>The inventory data of the inventory type.</p>
    #[serde(rename = "Content")]
    #[serde(default)]
    pub content: std::option::Option<
        std::vec::Vec<std::collections::HashMap<std::string::String, std::string::String>>,
    >,
    /// <p>A map of associated properties for a specified inventory type. For example, with this
    /// attribute, you can specify the <code>ExecutionId</code>, <code>ExecutionType</code>,
    /// <code>ComplianceType</code> properties of the <code>AWS:ComplianceItem</code> type.</p>
    #[serde(rename = "Context")]
    #[serde(default)]
    pub context:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for InventoryItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InventoryItem");
        formatter.field("type_name", &self.type_name);
        formatter.field("schema_version", &self.schema_version);
        formatter.field("capture_time", &self.capture_time);
        formatter.field("content_hash", &self.content_hash);
        formatter.field("content", &self.content);
        formatter.field("context", &self.context);
        formatter.finish()
    }
}
/// See [`InventoryItem`](crate::model::InventoryItem)
pub mod inventory_item {
    /// A builder for [`InventoryItem`](crate::model::InventoryItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) type_name: std::option::Option<std::string::String>,
        pub(crate) schema_version: std::option::Option<std::string::String>,
        pub(crate) capture_time: std::option::Option<std::string::String>,
        pub(crate) content_hash: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<
            std::vec::Vec<std::collections::HashMap<std::string::String, std::string::String>>,
        >,
        pub(crate) context: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the inventory type. Default inventory item type names start with AWS. Custom
        /// inventory type names will start with Custom. Default inventory item types include the following:
        /// AWS:AWSComponent, AWS:Application, AWS:InstanceInformation, AWS:Network, and
        /// AWS:WindowsUpdate.</p>
        pub fn type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.type_name = Some(input.into());
            self
        }
        pub fn set_type_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.type_name = input;
            self
        }
        /// <p>The schema version for the inventory item.</p>
        pub fn schema_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.schema_version = Some(input.into());
            self
        }
        pub fn set_schema_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.schema_version = input;
            self
        }
        /// <p>The time the inventory information was collected.</p>
        pub fn capture_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.capture_time = Some(input.into());
            self
        }
        pub fn set_capture_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.capture_time = input;
            self
        }
        /// <p>MD5 hash of the inventory item type contents. The content hash is used to determine whether
        /// to update inventory information. The PutInventory API does not update the inventory item type
        /// contents if the MD5 hash has not changed since last update. </p>
        pub fn content_hash(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_hash = Some(input.into());
            self
        }
        pub fn set_content_hash(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_hash = input;
            self
        }
        pub fn content(
            mut self,
            input: impl Into<std::collections::HashMap<std::string::String, std::string::String>>,
        ) -> Self {
            let mut v = self.content.unwrap_or_default();
            v.push(input.into());
            self.content = Some(v);
            self
        }
        pub fn set_content(
            mut self,
            input: std::option::Option<
                std::vec::Vec<std::collections::HashMap<std::string::String, std::string::String>>,
            >,
        ) -> Self {
            self.content = input;
            self
        }
        pub fn context(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.context.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.context = Some(hash_map);
            self
        }
        pub fn set_context(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.context = input;
            self
        }
        /// Consumes the builder and constructs a [`InventoryItem`](crate::model::InventoryItem)
        pub fn build(self) -> crate::model::InventoryItem {
            crate::model::InventoryItem {
                type_name: self.type_name,
                schema_version: self.schema_version,
                capture_time: self.capture_time,
                content_hash: self.content_hash,
                content: self.content,
                context: self.context,
            }
        }
    }
}
impl InventoryItem {
    /// Creates a new builder-style object to manufacture [`InventoryItem`](crate::model::InventoryItem)
    pub fn builder() -> crate::model::inventory_item::Builder {
        crate::model::inventory_item::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ComplianceUploadType {
    Complete,
    Partial,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ComplianceUploadType {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETE" => ComplianceUploadType::Complete,
            "PARTIAL" => ComplianceUploadType::Partial,
            other => ComplianceUploadType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ComplianceUploadType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ComplianceUploadType::from(s))
    }
}
impl ComplianceUploadType {
    pub fn as_str(&self) -> &str {
        match self {
            ComplianceUploadType::Complete => "COMPLETE",
            ComplianceUploadType::Partial => "PARTIAL",
            ComplianceUploadType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ComplianceUploadType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ComplianceUploadType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Information about a compliance item.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ComplianceItemEntry {
    /// <p>The compliance item ID. For example, if the compliance item is a Windows patch, the ID could
    /// be the number of the KB article.</p>
    #[serde(rename = "Id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The title of the compliance item. For example, if the compliance item is a Windows patch,
    /// the title could be the title of the KB article for the patch; for example: Security Update for
    /// Active Directory Federation Services. </p>
    #[serde(rename = "Title")]
    #[serde(default)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The severity of the compliance status. Severity can be one of the following: Critical, High,
    /// Medium, Low, Informational, Unspecified.</p>
    #[serde(rename = "Severity")]
    #[serde(default)]
    pub severity: std::option::Option<crate::model::ComplianceSeverity>,
    /// <p>The status of the compliance item. An item is either COMPLIANT or NON_COMPLIANT.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::ComplianceStatus>,
    /// <p>A "Key": "Value" tag combination for the compliance item.</p>
    #[serde(rename = "Details")]
    #[serde(default)]
    pub details:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for ComplianceItemEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ComplianceItemEntry");
        formatter.field("id", &self.id);
        formatter.field("title", &self.title);
        formatter.field("severity", &self.severity);
        formatter.field("status", &self.status);
        formatter.field("details", &self.details);
        formatter.finish()
    }
}
/// See [`ComplianceItemEntry`](crate::model::ComplianceItemEntry)
pub mod compliance_item_entry {
    /// A builder for [`ComplianceItemEntry`](crate::model::ComplianceItemEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) severity: std::option::Option<crate::model::ComplianceSeverity>,
        pub(crate) status: std::option::Option<crate::model::ComplianceStatus>,
        pub(crate) details: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The compliance item ID. For example, if the compliance item is a Windows patch, the ID could
        /// be the number of the KB article.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The title of the compliance item. For example, if the compliance item is a Windows patch,
        /// the title could be the title of the KB article for the patch; for example: Security Update for
        /// Active Directory Federation Services. </p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The severity of the compliance status. Severity can be one of the following: Critical, High,
        /// Medium, Low, Informational, Unspecified.</p>
        pub fn severity(mut self, input: crate::model::ComplianceSeverity) -> Self {
            self.severity = Some(input);
            self
        }
        pub fn set_severity(
            mut self,
            input: std::option::Option<crate::model::ComplianceSeverity>,
        ) -> Self {
            self.severity = input;
            self
        }
        /// <p>The status of the compliance item. An item is either COMPLIANT or NON_COMPLIANT.</p>
        pub fn status(mut self, input: crate::model::ComplianceStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ComplianceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        pub fn details(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.details.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.details = Some(hash_map);
            self
        }
        pub fn set_details(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.details = input;
            self
        }
        /// Consumes the builder and constructs a [`ComplianceItemEntry`](crate::model::ComplianceItemEntry)
        pub fn build(self) -> crate::model::ComplianceItemEntry {
            crate::model::ComplianceItemEntry {
                id: self.id,
                title: self.title,
                severity: self.severity,
                status: self.status,
                details: self.details,
            }
        }
    }
}
impl ComplianceItemEntry {
    /// Creates a new builder-style object to manufacture [`ComplianceItemEntry`](crate::model::ComplianceItemEntry)
    pub fn builder() -> crate::model::compliance_item_entry::Builder {
        crate::model::compliance_item_entry::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ComplianceStatus {
    Compliant,
    NonCompliant,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ComplianceStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLIANT" => ComplianceStatus::Compliant,
            "NON_COMPLIANT" => ComplianceStatus::NonCompliant,
            other => ComplianceStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ComplianceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ComplianceStatus::from(s))
    }
}
impl ComplianceStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ComplianceStatus::Compliant => "COMPLIANT",
            ComplianceStatus::NonCompliant => "NON_COMPLIANT",
            ComplianceStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ComplianceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ComplianceStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ComplianceSeverity {
    Critical,
    High,
    Informational,
    Low,
    Medium,
    Unspecified,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ComplianceSeverity {
    fn from(s: &str) -> Self {
        match s {
            "CRITICAL" => ComplianceSeverity::Critical,
            "HIGH" => ComplianceSeverity::High,
            "INFORMATIONAL" => ComplianceSeverity::Informational,
            "LOW" => ComplianceSeverity::Low,
            "MEDIUM" => ComplianceSeverity::Medium,
            "UNSPECIFIED" => ComplianceSeverity::Unspecified,
            other => ComplianceSeverity::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ComplianceSeverity {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ComplianceSeverity::from(s))
    }
}
impl ComplianceSeverity {
    pub fn as_str(&self) -> &str {
        match self {
            ComplianceSeverity::Critical => "CRITICAL",
            ComplianceSeverity::High => "HIGH",
            ComplianceSeverity::Informational => "INFORMATIONAL",
            ComplianceSeverity::Low => "LOW",
            ComplianceSeverity::Medium => "MEDIUM",
            ComplianceSeverity::Unspecified => "UNSPECIFIED",
            ComplianceSeverity::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ComplianceSeverity {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ComplianceSeverity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>A summary of the call execution that includes an execution ID, the type of execution (for
/// example, <code>Command</code>), and the date/time of the execution using a datetime object that
/// is saved in the following format: yyyy-MM-dd'T'HH:mm:ss'Z'.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ComplianceExecutionSummary {
    /// <p>The time the execution ran as a datetime object that is saved in the following format:
    /// yyyy-MM-dd'T'HH:mm:ss'Z'.</p>
    #[serde(rename = "ExecutionTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub execution_time: std::option::Option<smithy_types::Instant>,
    /// <p>An ID created by the system when <code>PutComplianceItems</code> was called. For example,
    /// <code>CommandID</code> is a valid execution ID. You can use this ID in subsequent calls.</p>
    #[serde(rename = "ExecutionId")]
    #[serde(default)]
    pub execution_id: std::option::Option<std::string::String>,
    /// <p>The type of execution. For example, <code>Command</code> is a valid execution type.</p>
    #[serde(rename = "ExecutionType")]
    #[serde(default)]
    pub execution_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ComplianceExecutionSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ComplianceExecutionSummary");
        formatter.field("execution_time", &self.execution_time);
        formatter.field("execution_id", &self.execution_id);
        formatter.field("execution_type", &self.execution_type);
        formatter.finish()
    }
}
/// See [`ComplianceExecutionSummary`](crate::model::ComplianceExecutionSummary)
pub mod compliance_execution_summary {
    /// A builder for [`ComplianceExecutionSummary`](crate::model::ComplianceExecutionSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) execution_time: std::option::Option<smithy_types::Instant>,
        pub(crate) execution_id: std::option::Option<std::string::String>,
        pub(crate) execution_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The time the execution ran as a datetime object that is saved in the following format:
        /// yyyy-MM-dd'T'HH:mm:ss'Z'.</p>
        pub fn execution_time(mut self, input: smithy_types::Instant) -> Self {
            self.execution_time = Some(input);
            self
        }
        pub fn set_execution_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.execution_time = input;
            self
        }
        /// <p>An ID created by the system when <code>PutComplianceItems</code> was called. For example,
        /// <code>CommandID</code> is a valid execution ID. You can use this ID in subsequent calls.</p>
        pub fn execution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.execution_id = Some(input.into());
            self
        }
        pub fn set_execution_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.execution_id = input;
            self
        }
        /// <p>The type of execution. For example, <code>Command</code> is a valid execution type.</p>
        pub fn execution_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.execution_type = Some(input.into());
            self
        }
        pub fn set_execution_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.execution_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ComplianceExecutionSummary`](crate::model::ComplianceExecutionSummary)
        pub fn build(self) -> crate::model::ComplianceExecutionSummary {
            crate::model::ComplianceExecutionSummary {
                execution_time: self.execution_time,
                execution_id: self.execution_id,
                execution_type: self.execution_type,
            }
        }
    }
}
impl ComplianceExecutionSummary {
    /// Creates a new builder-style object to manufacture [`ComplianceExecutionSummary`](crate::model::ComplianceExecutionSummary)
    pub fn builder() -> crate::model::compliance_execution_summary::Builder {
        crate::model::compliance_execution_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DocumentPermissionType {
    Share,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DocumentPermissionType {
    fn from(s: &str) -> Self {
        match s {
            "Share" => DocumentPermissionType::Share,
            other => DocumentPermissionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DocumentPermissionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(DocumentPermissionType::from(s))
    }
}
impl DocumentPermissionType {
    pub fn as_str(&self) -> &str {
        match self {
            DocumentPermissionType::Share => "Share",
            DocumentPermissionType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for DocumentPermissionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for DocumentPermissionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Information about a Resource Data Sync configuration, including its current status and last
/// successful sync.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceDataSyncItem {
    /// <p>The name of the Resource Data Sync.</p>
    #[serde(rename = "SyncName")]
    #[serde(default)]
    pub sync_name: std::option::Option<std::string::String>,
    /// <p>The type of resource data sync. If <code>SyncType</code> is <code>SyncToDestination</code>,
    /// then the resource data sync synchronizes data to an S3 bucket. If the <code>SyncType</code> is
    /// <code>SyncFromSource</code> then the resource data sync synchronizes data from AWS Organizations or from
    /// multiple AWS Regions.</p>
    #[serde(rename = "SyncType")]
    #[serde(default)]
    pub sync_type: std::option::Option<std::string::String>,
    /// <p>Information about the source where the data was synchronized. </p>
    #[serde(rename = "SyncSource")]
    #[serde(default)]
    pub sync_source: std::option::Option<crate::model::ResourceDataSyncSourceWithState>,
    /// <p>Configuration information for the target S3 bucket.</p>
    #[serde(rename = "S3Destination")]
    #[serde(default)]
    pub s3_destination: std::option::Option<crate::model::ResourceDataSyncS3Destination>,
    /// <p>The last time the configuration attempted to sync (UTC).</p>
    #[serde(rename = "LastSyncTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_sync_time: std::option::Option<smithy_types::Instant>,
    /// <p>The last time the sync operations returned a status of <code>SUCCESSFUL</code> (UTC).</p>
    #[serde(rename = "LastSuccessfulSyncTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_successful_sync_time: std::option::Option<smithy_types::Instant>,
    /// <p>The date and time the resource data sync was changed. </p>
    #[serde(rename = "SyncLastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub sync_last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The status reported by the last sync.</p>
    #[serde(rename = "LastStatus")]
    #[serde(default)]
    pub last_status: std::option::Option<crate::model::LastResourceDataSyncStatus>,
    /// <p>The date and time the configuration was created (UTC).</p>
    #[serde(rename = "SyncCreatedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub sync_created_time: std::option::Option<smithy_types::Instant>,
    /// <p>The status message details reported by the last sync.</p>
    #[serde(rename = "LastSyncStatusMessage")]
    #[serde(default)]
    pub last_sync_status_message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceDataSyncItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceDataSyncItem");
        formatter.field("sync_name", &self.sync_name);
        formatter.field("sync_type", &self.sync_type);
        formatter.field("sync_source", &self.sync_source);
        formatter.field("s3_destination", &self.s3_destination);
        formatter.field("last_sync_time", &self.last_sync_time);
        formatter.field("last_successful_sync_time", &self.last_successful_sync_time);
        formatter.field("sync_last_modified_time", &self.sync_last_modified_time);
        formatter.field("last_status", &self.last_status);
        formatter.field("sync_created_time", &self.sync_created_time);
        formatter.field("last_sync_status_message", &self.last_sync_status_message);
        formatter.finish()
    }
}
/// See [`ResourceDataSyncItem`](crate::model::ResourceDataSyncItem)
pub mod resource_data_sync_item {
    /// A builder for [`ResourceDataSyncItem`](crate::model::ResourceDataSyncItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sync_name: std::option::Option<std::string::String>,
        pub(crate) sync_type: std::option::Option<std::string::String>,
        pub(crate) sync_source: std::option::Option<crate::model::ResourceDataSyncSourceWithState>,
        pub(crate) s3_destination: std::option::Option<crate::model::ResourceDataSyncS3Destination>,
        pub(crate) last_sync_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_successful_sync_time: std::option::Option<smithy_types::Instant>,
        pub(crate) sync_last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_status: std::option::Option<crate::model::LastResourceDataSyncStatus>,
        pub(crate) sync_created_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_sync_status_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Resource Data Sync.</p>
        pub fn sync_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.sync_name = Some(input.into());
            self
        }
        pub fn set_sync_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sync_name = input;
            self
        }
        /// <p>The type of resource data sync. If <code>SyncType</code> is <code>SyncToDestination</code>,
        /// then the resource data sync synchronizes data to an S3 bucket. If the <code>SyncType</code> is
        /// <code>SyncFromSource</code> then the resource data sync synchronizes data from AWS Organizations or from
        /// multiple AWS Regions.</p>
        pub fn sync_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.sync_type = Some(input.into());
            self
        }
        pub fn set_sync_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sync_type = input;
            self
        }
        /// <p>Information about the source where the data was synchronized. </p>
        pub fn sync_source(mut self, input: crate::model::ResourceDataSyncSourceWithState) -> Self {
            self.sync_source = Some(input);
            self
        }
        pub fn set_sync_source(
            mut self,
            input: std::option::Option<crate::model::ResourceDataSyncSourceWithState>,
        ) -> Self {
            self.sync_source = input;
            self
        }
        /// <p>Configuration information for the target S3 bucket.</p>
        pub fn s3_destination(
            mut self,
            input: crate::model::ResourceDataSyncS3Destination,
        ) -> Self {
            self.s3_destination = Some(input);
            self
        }
        pub fn set_s3_destination(
            mut self,
            input: std::option::Option<crate::model::ResourceDataSyncS3Destination>,
        ) -> Self {
            self.s3_destination = input;
            self
        }
        /// <p>The last time the configuration attempted to sync (UTC).</p>
        pub fn last_sync_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_sync_time = Some(input);
            self
        }
        pub fn set_last_sync_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_sync_time = input;
            self
        }
        /// <p>The last time the sync operations returned a status of <code>SUCCESSFUL</code> (UTC).</p>
        pub fn last_successful_sync_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_successful_sync_time = Some(input);
            self
        }
        pub fn set_last_successful_sync_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_successful_sync_time = input;
            self
        }
        /// <p>The date and time the resource data sync was changed. </p>
        pub fn sync_last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.sync_last_modified_time = Some(input);
            self
        }
        pub fn set_sync_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.sync_last_modified_time = input;
            self
        }
        /// <p>The status reported by the last sync.</p>
        pub fn last_status(mut self, input: crate::model::LastResourceDataSyncStatus) -> Self {
            self.last_status = Some(input);
            self
        }
        pub fn set_last_status(
            mut self,
            input: std::option::Option<crate::model::LastResourceDataSyncStatus>,
        ) -> Self {
            self.last_status = input;
            self
        }
        /// <p>The date and time the configuration was created (UTC).</p>
        pub fn sync_created_time(mut self, input: smithy_types::Instant) -> Self {
            self.sync_created_time = Some(input);
            self
        }
        pub fn set_sync_created_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.sync_created_time = input;
            self
        }
        /// <p>The status message details reported by the last sync.</p>
        pub fn last_sync_status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_sync_status_message = Some(input.into());
            self
        }
        pub fn set_last_sync_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_sync_status_message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceDataSyncItem`](crate::model::ResourceDataSyncItem)
        pub fn build(self) -> crate::model::ResourceDataSyncItem {
            crate::model::ResourceDataSyncItem {
                sync_name: self.sync_name,
                sync_type: self.sync_type,
                sync_source: self.sync_source,
                s3_destination: self.s3_destination,
                last_sync_time: self.last_sync_time,
                last_successful_sync_time: self.last_successful_sync_time,
                sync_last_modified_time: self.sync_last_modified_time,
                last_status: self.last_status,
                sync_created_time: self.sync_created_time,
                last_sync_status_message: self.last_sync_status_message,
            }
        }
    }
}
impl ResourceDataSyncItem {
    /// Creates a new builder-style object to manufacture [`ResourceDataSyncItem`](crate::model::ResourceDataSyncItem)
    pub fn builder() -> crate::model::resource_data_sync_item::Builder {
        crate::model::resource_data_sync_item::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LastResourceDataSyncStatus {
    Failed,
    Inprogress,
    Successful,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LastResourceDataSyncStatus {
    fn from(s: &str) -> Self {
        match s {
            "Failed" => LastResourceDataSyncStatus::Failed,
            "InProgress" => LastResourceDataSyncStatus::Inprogress,
            "Successful" => LastResourceDataSyncStatus::Successful,
            other => LastResourceDataSyncStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LastResourceDataSyncStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(LastResourceDataSyncStatus::from(s))
    }
}
impl LastResourceDataSyncStatus {
    pub fn as_str(&self) -> &str {
        match self {
            LastResourceDataSyncStatus::Failed => "Failed",
            LastResourceDataSyncStatus::Inprogress => "InProgress",
            LastResourceDataSyncStatus::Successful => "Successful",
            LastResourceDataSyncStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for LastResourceDataSyncStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for LastResourceDataSyncStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Information about the target S3 bucket for the Resource Data Sync.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceDataSyncS3Destination {
    /// <p>The name of the S3 bucket where the aggregated data is stored.</p>
    #[serde(rename = "BucketName")]
    #[serde(default)]
    pub bucket_name: std::option::Option<std::string::String>,
    /// <p>An Amazon S3 prefix for the bucket.</p>
    #[serde(rename = "Prefix")]
    #[serde(default)]
    pub prefix: std::option::Option<std::string::String>,
    /// <p>A supported sync format. The following format is currently supported: JsonSerDe</p>
    #[serde(rename = "SyncFormat")]
    #[serde(default)]
    pub sync_format: std::option::Option<crate::model::ResourceDataSyncS3Format>,
    /// <p>The AWS Region with the S3 bucket targeted by the Resource Data Sync.</p>
    #[serde(rename = "Region")]
    #[serde(default)]
    pub region: std::option::Option<std::string::String>,
    /// <p>The ARN of an encryption key for a destination in Amazon S3. Must belong to the same Region as
    /// the destination S3 bucket.</p>
    #[serde(rename = "AWSKMSKeyARN")]
    #[serde(default)]
    pub awskms_key_arn: std::option::Option<std::string::String>,
    /// <p>Enables destination data sharing. By default, this field is <code>null</code>.</p>
    #[serde(rename = "DestinationDataSharing")]
    #[serde(default)]
    pub destination_data_sharing:
        std::option::Option<crate::model::ResourceDataSyncDestinationDataSharing>,
}
impl std::fmt::Debug for ResourceDataSyncS3Destination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceDataSyncS3Destination");
        formatter.field("bucket_name", &self.bucket_name);
        formatter.field("prefix", &self.prefix);
        formatter.field("sync_format", &self.sync_format);
        formatter.field("region", &self.region);
        formatter.field("awskms_key_arn", &self.awskms_key_arn);
        formatter.field("destination_data_sharing", &self.destination_data_sharing);
        formatter.finish()
    }
}
/// See [`ResourceDataSyncS3Destination`](crate::model::ResourceDataSyncS3Destination)
pub mod resource_data_sync_s3_destination {
    /// A builder for [`ResourceDataSyncS3Destination`](crate::model::ResourceDataSyncS3Destination)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_name: std::option::Option<std::string::String>,
        pub(crate) prefix: std::option::Option<std::string::String>,
        pub(crate) sync_format: std::option::Option<crate::model::ResourceDataSyncS3Format>,
        pub(crate) region: std::option::Option<std::string::String>,
        pub(crate) awskms_key_arn: std::option::Option<std::string::String>,
        pub(crate) destination_data_sharing:
            std::option::Option<crate::model::ResourceDataSyncDestinationDataSharing>,
    }
    impl Builder {
        /// <p>The name of the S3 bucket where the aggregated data is stored.</p>
        pub fn bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_name = Some(input.into());
            self
        }
        pub fn set_bucket_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket_name = input;
            self
        }
        /// <p>An Amazon S3 prefix for the bucket.</p>
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix = Some(input.into());
            self
        }
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix = input;
            self
        }
        /// <p>A supported sync format. The following format is currently supported: JsonSerDe</p>
        pub fn sync_format(mut self, input: crate::model::ResourceDataSyncS3Format) -> Self {
            self.sync_format = Some(input);
            self
        }
        pub fn set_sync_format(
            mut self,
            input: std::option::Option<crate::model::ResourceDataSyncS3Format>,
        ) -> Self {
            self.sync_format = input;
            self
        }
        /// <p>The AWS Region with the S3 bucket targeted by the Resource Data Sync.</p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// <p>The ARN of an encryption key for a destination in Amazon S3. Must belong to the same Region as
        /// the destination S3 bucket.</p>
        pub fn awskms_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.awskms_key_arn = Some(input.into());
            self
        }
        pub fn set_awskms_key_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.awskms_key_arn = input;
            self
        }
        /// <p>Enables destination data sharing. By default, this field is <code>null</code>.</p>
        pub fn destination_data_sharing(
            mut self,
            input: crate::model::ResourceDataSyncDestinationDataSharing,
        ) -> Self {
            self.destination_data_sharing = Some(input);
            self
        }
        pub fn set_destination_data_sharing(
            mut self,
            input: std::option::Option<crate::model::ResourceDataSyncDestinationDataSharing>,
        ) -> Self {
            self.destination_data_sharing = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceDataSyncS3Destination`](crate::model::ResourceDataSyncS3Destination)
        pub fn build(self) -> crate::model::ResourceDataSyncS3Destination {
            crate::model::ResourceDataSyncS3Destination {
                bucket_name: self.bucket_name,
                prefix: self.prefix,
                sync_format: self.sync_format,
                region: self.region,
                awskms_key_arn: self.awskms_key_arn,
                destination_data_sharing: self.destination_data_sharing,
            }
        }
    }
}
impl ResourceDataSyncS3Destination {
    /// Creates a new builder-style object to manufacture [`ResourceDataSyncS3Destination`](crate::model::ResourceDataSyncS3Destination)
    pub fn builder() -> crate::model::resource_data_sync_s3_destination::Builder {
        crate::model::resource_data_sync_s3_destination::Builder::default()
    }
}

/// <p>Synchronize Systems Manager Inventory data from multiple AWS accounts defined in AWS Organizations to
/// a centralized S3 bucket. Data is synchronized to individual key prefixes in the central bucket.
/// Each key prefix represents a different AWS account ID.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceDataSyncDestinationDataSharing {
    /// <p>The sharing data type. Only <code>Organization</code> is supported.</p>
    #[serde(rename = "DestinationDataSharingType")]
    #[serde(default)]
    pub destination_data_sharing_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceDataSyncDestinationDataSharing {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceDataSyncDestinationDataSharing");
        formatter.field(
            "destination_data_sharing_type",
            &self.destination_data_sharing_type,
        );
        formatter.finish()
    }
}
/// See [`ResourceDataSyncDestinationDataSharing`](crate::model::ResourceDataSyncDestinationDataSharing)
pub mod resource_data_sync_destination_data_sharing {
    /// A builder for [`ResourceDataSyncDestinationDataSharing`](crate::model::ResourceDataSyncDestinationDataSharing)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_data_sharing_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The sharing data type. Only <code>Organization</code> is supported.</p>
        pub fn destination_data_sharing_type(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.destination_data_sharing_type = Some(input.into());
            self
        }
        pub fn set_destination_data_sharing_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_data_sharing_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceDataSyncDestinationDataSharing`](crate::model::ResourceDataSyncDestinationDataSharing)
        pub fn build(self) -> crate::model::ResourceDataSyncDestinationDataSharing {
            crate::model::ResourceDataSyncDestinationDataSharing {
                destination_data_sharing_type: self.destination_data_sharing_type,
            }
        }
    }
}
impl ResourceDataSyncDestinationDataSharing {
    /// Creates a new builder-style object to manufacture [`ResourceDataSyncDestinationDataSharing`](crate::model::ResourceDataSyncDestinationDataSharing)
    pub fn builder() -> crate::model::resource_data_sync_destination_data_sharing::Builder {
        crate::model::resource_data_sync_destination_data_sharing::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceDataSyncS3Format {
    JsonSerde,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ResourceDataSyncS3Format {
    fn from(s: &str) -> Self {
        match s {
            "JsonSerDe" => ResourceDataSyncS3Format::JsonSerde,
            other => ResourceDataSyncS3Format::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ResourceDataSyncS3Format {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ResourceDataSyncS3Format::from(s))
    }
}
impl ResourceDataSyncS3Format {
    pub fn as_str(&self) -> &str {
        match self {
            ResourceDataSyncS3Format::JsonSerde => "JsonSerDe",
            ResourceDataSyncS3Format::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ResourceDataSyncS3Format {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ResourceDataSyncS3Format {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>The data type name for including resource data sync state. There are four sync
/// states:</p>
/// <p>
/// <code>OrganizationNotExists</code> (Your organization doesn't exist)</p>
/// <p>
/// <code>NoPermissions</code> (The system can't locate the service-linked role. This role is
/// automatically created when a user creates a resource data sync in Explorer.)</p>
/// <p>
/// <code>InvalidOrganizationalUnit</code> (You specified or selected an invalid unit in the
/// resource data sync configuration.)</p>
/// <p>
/// <code>TrustedAccessDisabled</code> (You disabled Systems Manager access in the organization in
/// AWS Organizations.)</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceDataSyncSourceWithState {
    /// <p>The type of data source for the resource data sync. <code>SourceType</code> is either
    /// <code>AwsOrganizations</code> (if an organization is present in AWS Organizations) or
    /// <code>singleAccountMultiRegions</code>.</p>
    #[serde(rename = "SourceType")]
    #[serde(default)]
    pub source_type: std::option::Option<std::string::String>,
    /// <p>The field name in <code>SyncSource</code> for the
    /// <code>ResourceDataSyncAwsOrganizationsSource</code> type.</p>
    #[serde(rename = "AwsOrganizationsSource")]
    #[serde(default)]
    pub aws_organizations_source:
        std::option::Option<crate::model::ResourceDataSyncAwsOrganizationsSource>,
    /// <p>The <code>SyncSource</code> AWS Regions included in the resource data sync.</p>
    #[serde(rename = "SourceRegions")]
    #[serde(default)]
    pub source_regions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Whether to automatically synchronize and aggregate data from new AWS Regions when those
    /// Regions come online.</p>
    #[serde(rename = "IncludeFutureRegions")]
    #[serde(default)]
    pub include_future_regions: bool,
    /// <p>The data type name for including resource data sync state. There are four sync
    /// states:</p>
    /// <p>
    /// <code>OrganizationNotExists</code>: Your organization doesn't exist.</p>
    /// <p>
    /// <code>NoPermissions</code>: The system can't locate the service-linked role. This role is
    /// automatically created when a user creates a resource data sync in Explorer.</p>
    /// <p>
    /// <code>InvalidOrganizationalUnit</code>: You specified or selected an invalid unit in the
    /// resource data sync configuration.</p>
    /// <p>
    /// <code>TrustedAccessDisabled</code>: You disabled Systems Manager access in the organization in
    /// AWS Organizations.</p>
    #[serde(rename = "State")]
    #[serde(default)]
    pub state: std::option::Option<std::string::String>,
    /// <p>When you create a resource data sync, if you choose one of the AWS Organizations options, then Systems Manager
    /// automatically enables all OpsData sources in the selected AWS Regions for all AWS accounts in
    /// your organization (or in the selected organization units). For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/Explorer-resouce-data-sync-multiple-accounts-and-regions.html">About multiple account and Region resource data syncs</a> in the
    /// <i>AWS Systems Manager User Guide</i>.</p>
    #[serde(rename = "EnableAllOpsDataSources")]
    #[serde(default)]
    pub enable_all_ops_data_sources: bool,
}
impl std::fmt::Debug for ResourceDataSyncSourceWithState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceDataSyncSourceWithState");
        formatter.field("source_type", &self.source_type);
        formatter.field("aws_organizations_source", &self.aws_organizations_source);
        formatter.field("source_regions", &self.source_regions);
        formatter.field("include_future_regions", &self.include_future_regions);
        formatter.field("state", &self.state);
        formatter.field(
            "enable_all_ops_data_sources",
            &self.enable_all_ops_data_sources,
        );
        formatter.finish()
    }
}
/// See [`ResourceDataSyncSourceWithState`](crate::model::ResourceDataSyncSourceWithState)
pub mod resource_data_sync_source_with_state {
    /// A builder for [`ResourceDataSyncSourceWithState`](crate::model::ResourceDataSyncSourceWithState)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_type: std::option::Option<std::string::String>,
        pub(crate) aws_organizations_source:
            std::option::Option<crate::model::ResourceDataSyncAwsOrganizationsSource>,
        pub(crate) source_regions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) include_future_regions: std::option::Option<bool>,
        pub(crate) state: std::option::Option<std::string::String>,
        pub(crate) enable_all_ops_data_sources: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The type of data source for the resource data sync. <code>SourceType</code> is either
        /// <code>AwsOrganizations</code> (if an organization is present in AWS Organizations) or
        /// <code>singleAccountMultiRegions</code>.</p>
        pub fn source_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_type = Some(input.into());
            self
        }
        pub fn set_source_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_type = input;
            self
        }
        /// <p>The field name in <code>SyncSource</code> for the
        /// <code>ResourceDataSyncAwsOrganizationsSource</code> type.</p>
        pub fn aws_organizations_source(
            mut self,
            input: crate::model::ResourceDataSyncAwsOrganizationsSource,
        ) -> Self {
            self.aws_organizations_source = Some(input);
            self
        }
        pub fn set_aws_organizations_source(
            mut self,
            input: std::option::Option<crate::model::ResourceDataSyncAwsOrganizationsSource>,
        ) -> Self {
            self.aws_organizations_source = input;
            self
        }
        pub fn source_regions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.source_regions.unwrap_or_default();
            v.push(input.into());
            self.source_regions = Some(v);
            self
        }
        pub fn set_source_regions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.source_regions = input;
            self
        }
        /// <p>Whether to automatically synchronize and aggregate data from new AWS Regions when those
        /// Regions come online.</p>
        pub fn include_future_regions(mut self, input: bool) -> Self {
            self.include_future_regions = Some(input);
            self
        }
        pub fn set_include_future_regions(mut self, input: std::option::Option<bool>) -> Self {
            self.include_future_regions = input;
            self
        }
        /// <p>The data type name for including resource data sync state. There are four sync
        /// states:</p>
        /// <p>
        /// <code>OrganizationNotExists</code>: Your organization doesn't exist.</p>
        /// <p>
        /// <code>NoPermissions</code>: The system can't locate the service-linked role. This role is
        /// automatically created when a user creates a resource data sync in Explorer.</p>
        /// <p>
        /// <code>InvalidOrganizationalUnit</code>: You specified or selected an invalid unit in the
        /// resource data sync configuration.</p>
        /// <p>
        /// <code>TrustedAccessDisabled</code>: You disabled Systems Manager access in the organization in
        /// AWS Organizations.</p>
        pub fn state(mut self, input: impl Into<std::string::String>) -> Self {
            self.state = Some(input.into());
            self
        }
        pub fn set_state(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.state = input;
            self
        }
        /// <p>When you create a resource data sync, if you choose one of the AWS Organizations options, then Systems Manager
        /// automatically enables all OpsData sources in the selected AWS Regions for all AWS accounts in
        /// your organization (or in the selected organization units). For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/Explorer-resouce-data-sync-multiple-accounts-and-regions.html">About multiple account and Region resource data syncs</a> in the
        /// <i>AWS Systems Manager User Guide</i>.</p>
        pub fn enable_all_ops_data_sources(mut self, input: bool) -> Self {
            self.enable_all_ops_data_sources = Some(input);
            self
        }
        pub fn set_enable_all_ops_data_sources(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_all_ops_data_sources = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceDataSyncSourceWithState`](crate::model::ResourceDataSyncSourceWithState)
        pub fn build(self) -> crate::model::ResourceDataSyncSourceWithState {
            crate::model::ResourceDataSyncSourceWithState {
                source_type: self.source_type,
                aws_organizations_source: self.aws_organizations_source,
                source_regions: self.source_regions,
                include_future_regions: self.include_future_regions.unwrap_or_default(),
                state: self.state,
                enable_all_ops_data_sources: self.enable_all_ops_data_sources.unwrap_or_default(),
            }
        }
    }
}
impl ResourceDataSyncSourceWithState {
    /// Creates a new builder-style object to manufacture [`ResourceDataSyncSourceWithState`](crate::model::ResourceDataSyncSourceWithState)
    pub fn builder() -> crate::model::resource_data_sync_source_with_state::Builder {
        crate::model::resource_data_sync_source_with_state::Builder::default()
    }
}

/// <p>Compliance summary information for a specific resource. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceComplianceSummaryItem {
    /// <p>The compliance type.</p>
    #[serde(rename = "ComplianceType")]
    #[serde(default)]
    pub compliance_type: std::option::Option<std::string::String>,
    /// <p>The resource type.</p>
    #[serde(rename = "ResourceType")]
    #[serde(default)]
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The resource ID.</p>
    #[serde(rename = "ResourceId")]
    #[serde(default)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The compliance status for the resource.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::ComplianceStatus>,
    /// <p>The highest severity item found for the resource. The resource is compliant for this
    /// item.</p>
    #[serde(rename = "OverallSeverity")]
    #[serde(default)]
    pub overall_severity: std::option::Option<crate::model::ComplianceSeverity>,
    /// <p>Information about the execution.</p>
    #[serde(rename = "ExecutionSummary")]
    #[serde(default)]
    pub execution_summary: std::option::Option<crate::model::ComplianceExecutionSummary>,
    /// <p>A list of items that are compliant for the resource.</p>
    #[serde(rename = "CompliantSummary")]
    #[serde(default)]
    pub compliant_summary: std::option::Option<crate::model::CompliantSummary>,
    /// <p>A list of items that aren't compliant for the resource.</p>
    #[serde(rename = "NonCompliantSummary")]
    #[serde(default)]
    pub non_compliant_summary: std::option::Option<crate::model::NonCompliantSummary>,
}
impl std::fmt::Debug for ResourceComplianceSummaryItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceComplianceSummaryItem");
        formatter.field("compliance_type", &self.compliance_type);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("resource_id", &self.resource_id);
        formatter.field("status", &self.status);
        formatter.field("overall_severity", &self.overall_severity);
        formatter.field("execution_summary", &self.execution_summary);
        formatter.field("compliant_summary", &self.compliant_summary);
        formatter.field("non_compliant_summary", &self.non_compliant_summary);
        formatter.finish()
    }
}
/// See [`ResourceComplianceSummaryItem`](crate::model::ResourceComplianceSummaryItem)
pub mod resource_compliance_summary_item {
    /// A builder for [`ResourceComplianceSummaryItem`](crate::model::ResourceComplianceSummaryItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) compliance_type: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ComplianceStatus>,
        pub(crate) overall_severity: std::option::Option<crate::model::ComplianceSeverity>,
        pub(crate) execution_summary: std::option::Option<crate::model::ComplianceExecutionSummary>,
        pub(crate) compliant_summary: std::option::Option<crate::model::CompliantSummary>,
        pub(crate) non_compliant_summary: std::option::Option<crate::model::NonCompliantSummary>,
    }
    impl Builder {
        /// <p>The compliance type.</p>
        pub fn compliance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.compliance_type = Some(input.into());
            self
        }
        pub fn set_compliance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.compliance_type = input;
            self
        }
        /// <p>The resource type.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The resource ID.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The compliance status for the resource.</p>
        pub fn status(mut self, input: crate::model::ComplianceStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ComplianceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The highest severity item found for the resource. The resource is compliant for this
        /// item.</p>
        pub fn overall_severity(mut self, input: crate::model::ComplianceSeverity) -> Self {
            self.overall_severity = Some(input);
            self
        }
        pub fn set_overall_severity(
            mut self,
            input: std::option::Option<crate::model::ComplianceSeverity>,
        ) -> Self {
            self.overall_severity = input;
            self
        }
        /// <p>Information about the execution.</p>
        pub fn execution_summary(
            mut self,
            input: crate::model::ComplianceExecutionSummary,
        ) -> Self {
            self.execution_summary = Some(input);
            self
        }
        pub fn set_execution_summary(
            mut self,
            input: std::option::Option<crate::model::ComplianceExecutionSummary>,
        ) -> Self {
            self.execution_summary = input;
            self
        }
        /// <p>A list of items that are compliant for the resource.</p>
        pub fn compliant_summary(mut self, input: crate::model::CompliantSummary) -> Self {
            self.compliant_summary = Some(input);
            self
        }
        pub fn set_compliant_summary(
            mut self,
            input: std::option::Option<crate::model::CompliantSummary>,
        ) -> Self {
            self.compliant_summary = input;
            self
        }
        /// <p>A list of items that aren't compliant for the resource.</p>
        pub fn non_compliant_summary(mut self, input: crate::model::NonCompliantSummary) -> Self {
            self.non_compliant_summary = Some(input);
            self
        }
        pub fn set_non_compliant_summary(
            mut self,
            input: std::option::Option<crate::model::NonCompliantSummary>,
        ) -> Self {
            self.non_compliant_summary = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceComplianceSummaryItem`](crate::model::ResourceComplianceSummaryItem)
        pub fn build(self) -> crate::model::ResourceComplianceSummaryItem {
            crate::model::ResourceComplianceSummaryItem {
                compliance_type: self.compliance_type,
                resource_type: self.resource_type,
                resource_id: self.resource_id,
                status: self.status,
                overall_severity: self.overall_severity,
                execution_summary: self.execution_summary,
                compliant_summary: self.compliant_summary,
                non_compliant_summary: self.non_compliant_summary,
            }
        }
    }
}
impl ResourceComplianceSummaryItem {
    /// Creates a new builder-style object to manufacture [`ResourceComplianceSummaryItem`](crate::model::ResourceComplianceSummaryItem)
    pub fn builder() -> crate::model::resource_compliance_summary_item::Builder {
        crate::model::resource_compliance_summary_item::Builder::default()
    }
}

/// <p>A summary of resources that are not compliant. The summary is organized according to
/// resource type.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct NonCompliantSummary {
    /// <p>The total number of compliance items that are not compliant.</p>
    #[serde(rename = "NonCompliantCount")]
    #[serde(default)]
    pub non_compliant_count: i32,
    /// <p>A summary of the non-compliance severity by compliance type</p>
    #[serde(rename = "SeveritySummary")]
    #[serde(default)]
    pub severity_summary: std::option::Option<crate::model::SeveritySummary>,
}
impl std::fmt::Debug for NonCompliantSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NonCompliantSummary");
        formatter.field("non_compliant_count", &self.non_compliant_count);
        formatter.field("severity_summary", &self.severity_summary);
        formatter.finish()
    }
}
/// See [`NonCompliantSummary`](crate::model::NonCompliantSummary)
pub mod non_compliant_summary {
    /// A builder for [`NonCompliantSummary`](crate::model::NonCompliantSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) non_compliant_count: std::option::Option<i32>,
        pub(crate) severity_summary: std::option::Option<crate::model::SeveritySummary>,
    }
    impl Builder {
        /// <p>The total number of compliance items that are not compliant.</p>
        pub fn non_compliant_count(mut self, input: i32) -> Self {
            self.non_compliant_count = Some(input);
            self
        }
        pub fn set_non_compliant_count(mut self, input: std::option::Option<i32>) -> Self {
            self.non_compliant_count = input;
            self
        }
        /// <p>A summary of the non-compliance severity by compliance type</p>
        pub fn severity_summary(mut self, input: crate::model::SeveritySummary) -> Self {
            self.severity_summary = Some(input);
            self
        }
        pub fn set_severity_summary(
            mut self,
            input: std::option::Option<crate::model::SeveritySummary>,
        ) -> Self {
            self.severity_summary = input;
            self
        }
        /// Consumes the builder and constructs a [`NonCompliantSummary`](crate::model::NonCompliantSummary)
        pub fn build(self) -> crate::model::NonCompliantSummary {
            crate::model::NonCompliantSummary {
                non_compliant_count: self.non_compliant_count.unwrap_or_default(),
                severity_summary: self.severity_summary,
            }
        }
    }
}
impl NonCompliantSummary {
    /// Creates a new builder-style object to manufacture [`NonCompliantSummary`](crate::model::NonCompliantSummary)
    pub fn builder() -> crate::model::non_compliant_summary::Builder {
        crate::model::non_compliant_summary::Builder::default()
    }
}

/// <p>The number of managed instances found for each patch severity level defined in the request
/// filter.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct SeveritySummary {
    /// <p>The total number of resources or compliance items that have a severity level of critical.
    /// Critical severity is determined by the organization that published the compliance items.</p>
    #[serde(rename = "CriticalCount")]
    #[serde(default)]
    pub critical_count: i32,
    /// <p>The total number of resources or compliance items that have a severity level of high. High
    /// severity is determined by the organization that published the compliance items.</p>
    #[serde(rename = "HighCount")]
    #[serde(default)]
    pub high_count: i32,
    /// <p>The total number of resources or compliance items that have a severity level of medium.
    /// Medium severity is determined by the organization that published the compliance items.</p>
    #[serde(rename = "MediumCount")]
    #[serde(default)]
    pub medium_count: i32,
    /// <p>The total number of resources or compliance items that have a severity level of low. Low
    /// severity is determined by the organization that published the compliance items.</p>
    #[serde(rename = "LowCount")]
    #[serde(default)]
    pub low_count: i32,
    /// <p>The total number of resources or compliance items that have a severity level of
    /// informational. Informational severity is determined by the organization that published the
    /// compliance items.</p>
    #[serde(rename = "InformationalCount")]
    #[serde(default)]
    pub informational_count: i32,
    /// <p>The total number of resources or compliance items that have a severity level of unspecified.
    /// Unspecified severity is determined by the organization that published the compliance
    /// items.</p>
    #[serde(rename = "UnspecifiedCount")]
    #[serde(default)]
    pub unspecified_count: i32,
}
impl std::fmt::Debug for SeveritySummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SeveritySummary");
        formatter.field("critical_count", &self.critical_count);
        formatter.field("high_count", &self.high_count);
        formatter.field("medium_count", &self.medium_count);
        formatter.field("low_count", &self.low_count);
        formatter.field("informational_count", &self.informational_count);
        formatter.field("unspecified_count", &self.unspecified_count);
        formatter.finish()
    }
}
/// See [`SeveritySummary`](crate::model::SeveritySummary)
pub mod severity_summary {
    /// A builder for [`SeveritySummary`](crate::model::SeveritySummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) critical_count: std::option::Option<i32>,
        pub(crate) high_count: std::option::Option<i32>,
        pub(crate) medium_count: std::option::Option<i32>,
        pub(crate) low_count: std::option::Option<i32>,
        pub(crate) informational_count: std::option::Option<i32>,
        pub(crate) unspecified_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The total number of resources or compliance items that have a severity level of critical.
        /// Critical severity is determined by the organization that published the compliance items.</p>
        pub fn critical_count(mut self, input: i32) -> Self {
            self.critical_count = Some(input);
            self
        }
        pub fn set_critical_count(mut self, input: std::option::Option<i32>) -> Self {
            self.critical_count = input;
            self
        }
        /// <p>The total number of resources or compliance items that have a severity level of high. High
        /// severity is determined by the organization that published the compliance items.</p>
        pub fn high_count(mut self, input: i32) -> Self {
            self.high_count = Some(input);
            self
        }
        pub fn set_high_count(mut self, input: std::option::Option<i32>) -> Self {
            self.high_count = input;
            self
        }
        /// <p>The total number of resources or compliance items that have a severity level of medium.
        /// Medium severity is determined by the organization that published the compliance items.</p>
        pub fn medium_count(mut self, input: i32) -> Self {
            self.medium_count = Some(input);
            self
        }
        pub fn set_medium_count(mut self, input: std::option::Option<i32>) -> Self {
            self.medium_count = input;
            self
        }
        /// <p>The total number of resources or compliance items that have a severity level of low. Low
        /// severity is determined by the organization that published the compliance items.</p>
        pub fn low_count(mut self, input: i32) -> Self {
            self.low_count = Some(input);
            self
        }
        pub fn set_low_count(mut self, input: std::option::Option<i32>) -> Self {
            self.low_count = input;
            self
        }
        /// <p>The total number of resources or compliance items that have a severity level of
        /// informational. Informational severity is determined by the organization that published the
        /// compliance items.</p>
        pub fn informational_count(mut self, input: i32) -> Self {
            self.informational_count = Some(input);
            self
        }
        pub fn set_informational_count(mut self, input: std::option::Option<i32>) -> Self {
            self.informational_count = input;
            self
        }
        /// <p>The total number of resources or compliance items that have a severity level of unspecified.
        /// Unspecified severity is determined by the organization that published the compliance
        /// items.</p>
        pub fn unspecified_count(mut self, input: i32) -> Self {
            self.unspecified_count = Some(input);
            self
        }
        pub fn set_unspecified_count(mut self, input: std::option::Option<i32>) -> Self {
            self.unspecified_count = input;
            self
        }
        /// Consumes the builder and constructs a [`SeveritySummary`](crate::model::SeveritySummary)
        pub fn build(self) -> crate::model::SeveritySummary {
            crate::model::SeveritySummary {
                critical_count: self.critical_count.unwrap_or_default(),
                high_count: self.high_count.unwrap_or_default(),
                medium_count: self.medium_count.unwrap_or_default(),
                low_count: self.low_count.unwrap_or_default(),
                informational_count: self.informational_count.unwrap_or_default(),
                unspecified_count: self.unspecified_count.unwrap_or_default(),
            }
        }
    }
}
impl SeveritySummary {
    /// Creates a new builder-style object to manufacture [`SeveritySummary`](crate::model::SeveritySummary)
    pub fn builder() -> crate::model::severity_summary::Builder {
        crate::model::severity_summary::Builder::default()
    }
}

/// <p>A summary of resources that are compliant. The summary is organized according to the
/// resource count for each compliance type.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CompliantSummary {
    /// <p>The total number of resources that are compliant.</p>
    #[serde(rename = "CompliantCount")]
    #[serde(default)]
    pub compliant_count: i32,
    /// <p>A summary of the compliance severity by compliance type.</p>
    #[serde(rename = "SeveritySummary")]
    #[serde(default)]
    pub severity_summary: std::option::Option<crate::model::SeveritySummary>,
}
impl std::fmt::Debug for CompliantSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CompliantSummary");
        formatter.field("compliant_count", &self.compliant_count);
        formatter.field("severity_summary", &self.severity_summary);
        formatter.finish()
    }
}
/// See [`CompliantSummary`](crate::model::CompliantSummary)
pub mod compliant_summary {
    /// A builder for [`CompliantSummary`](crate::model::CompliantSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) compliant_count: std::option::Option<i32>,
        pub(crate) severity_summary: std::option::Option<crate::model::SeveritySummary>,
    }
    impl Builder {
        /// <p>The total number of resources that are compliant.</p>
        pub fn compliant_count(mut self, input: i32) -> Self {
            self.compliant_count = Some(input);
            self
        }
        pub fn set_compliant_count(mut self, input: std::option::Option<i32>) -> Self {
            self.compliant_count = input;
            self
        }
        /// <p>A summary of the compliance severity by compliance type.</p>
        pub fn severity_summary(mut self, input: crate::model::SeveritySummary) -> Self {
            self.severity_summary = Some(input);
            self
        }
        pub fn set_severity_summary(
            mut self,
            input: std::option::Option<crate::model::SeveritySummary>,
        ) -> Self {
            self.severity_summary = input;
            self
        }
        /// Consumes the builder and constructs a [`CompliantSummary`](crate::model::CompliantSummary)
        pub fn build(self) -> crate::model::CompliantSummary {
            crate::model::CompliantSummary {
                compliant_count: self.compliant_count.unwrap_or_default(),
                severity_summary: self.severity_summary,
            }
        }
    }
}
impl CompliantSummary {
    /// Creates a new builder-style object to manufacture [`CompliantSummary`](crate::model::CompliantSummary)
    pub fn builder() -> crate::model::compliant_summary::Builder {
        crate::model::compliant_summary::Builder::default()
    }
}

/// <p>One or more filters. Use a filter to return a more specific list of results.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ComplianceStringFilter {
    /// <p>The name of the filter.</p>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The value for which to search.</p>
    #[serde(rename = "Values")]
    #[serde(default)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The type of comparison that should be performed for the value: Equal, NotEqual, BeginWith,
    /// LessThan, or GreaterThan.</p>
    #[serde(rename = "Type")]
    #[serde(default)]
    pub r#type: std::option::Option<crate::model::ComplianceQueryOperatorType>,
}
impl std::fmt::Debug for ComplianceStringFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ComplianceStringFilter");
        formatter.field("key", &self.key);
        formatter.field("values", &self.values);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`ComplianceStringFilter`](crate::model::ComplianceStringFilter)
pub mod compliance_string_filter {
    /// A builder for [`ComplianceStringFilter`](crate::model::ComplianceStringFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) r#type: std::option::Option<crate::model::ComplianceQueryOperatorType>,
    }
    impl Builder {
        /// <p>The name of the filter.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// <p>The type of comparison that should be performed for the value: Equal, NotEqual, BeginWith,
        /// LessThan, or GreaterThan.</p>
        pub fn r#type(mut self, input: crate::model::ComplianceQueryOperatorType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ComplianceQueryOperatorType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`ComplianceStringFilter`](crate::model::ComplianceStringFilter)
        pub fn build(self) -> crate::model::ComplianceStringFilter {
            crate::model::ComplianceStringFilter {
                key: self.key,
                values: self.values,
                r#type: self.r#type,
            }
        }
    }
}
impl ComplianceStringFilter {
    /// Creates a new builder-style object to manufacture [`ComplianceStringFilter`](crate::model::ComplianceStringFilter)
    pub fn builder() -> crate::model::compliance_string_filter::Builder {
        crate::model::compliance_string_filter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ComplianceQueryOperatorType {
    BeginWith,
    Equal,
    GreaterThan,
    LessThan,
    NotEqual,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ComplianceQueryOperatorType {
    fn from(s: &str) -> Self {
        match s {
            "BEGIN_WITH" => ComplianceQueryOperatorType::BeginWith,
            "EQUAL" => ComplianceQueryOperatorType::Equal,
            "GREATER_THAN" => ComplianceQueryOperatorType::GreaterThan,
            "LESS_THAN" => ComplianceQueryOperatorType::LessThan,
            "NOT_EQUAL" => ComplianceQueryOperatorType::NotEqual,
            other => ComplianceQueryOperatorType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ComplianceQueryOperatorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ComplianceQueryOperatorType::from(s))
    }
}
impl ComplianceQueryOperatorType {
    pub fn as_str(&self) -> &str {
        match self {
            ComplianceQueryOperatorType::BeginWith => "BEGIN_WITH",
            ComplianceQueryOperatorType::Equal => "EQUAL",
            ComplianceQueryOperatorType::GreaterThan => "GREATER_THAN",
            ComplianceQueryOperatorType::LessThan => "LESS_THAN",
            ComplianceQueryOperatorType::NotEqual => "NOT_EQUAL",
            ComplianceQueryOperatorType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ComplianceQueryOperatorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ComplianceQueryOperatorType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Operational metadata for an application in Application Manager.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsMetadata {
    /// <p>The ID of the Application Manager application.</p>
    #[serde(rename = "ResourceId")]
    #[serde(default)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the OpsMetadata Object or blob.</p>
    #[serde(rename = "OpsMetadataArn")]
    #[serde(default)]
    pub ops_metadata_arn: std::option::Option<std::string::String>,
    /// <p>The date the OpsMetadata object was last updated.</p>
    #[serde(rename = "LastModifiedDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_date: std::option::Option<smithy_types::Instant>,
    /// <p>The user name who last updated the OpsMetadata object.</p>
    #[serde(rename = "LastModifiedUser")]
    #[serde(default)]
    pub last_modified_user: std::option::Option<std::string::String>,
    /// <p>The date the OpsMetadata objects was created.</p>
    #[serde(rename = "CreationDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_date: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for OpsMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsMetadata");
        formatter.field("resource_id", &self.resource_id);
        formatter.field("ops_metadata_arn", &self.ops_metadata_arn);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("last_modified_user", &self.last_modified_user);
        formatter.field("creation_date", &self.creation_date);
        formatter.finish()
    }
}
/// See [`OpsMetadata`](crate::model::OpsMetadata)
pub mod ops_metadata {
    /// A builder for [`OpsMetadata`](crate::model::OpsMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) ops_metadata_arn: std::option::Option<std::string::String>,
        pub(crate) last_modified_date: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_user: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The ID of the Application Manager application.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the OpsMetadata Object or blob.</p>
        pub fn ops_metadata_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.ops_metadata_arn = Some(input.into());
            self
        }
        pub fn set_ops_metadata_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ops_metadata_arn = input;
            self
        }
        /// <p>The date the OpsMetadata object was last updated.</p>
        pub fn last_modified_date(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_date = Some(input);
            self
        }
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>The user name who last updated the OpsMetadata object.</p>
        pub fn last_modified_user(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_user = Some(input.into());
            self
        }
        pub fn set_last_modified_user(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_user = input;
            self
        }
        /// <p>The date the OpsMetadata objects was created.</p>
        pub fn creation_date(mut self, input: smithy_types::Instant) -> Self {
            self.creation_date = Some(input);
            self
        }
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsMetadata`](crate::model::OpsMetadata)
        pub fn build(self) -> crate::model::OpsMetadata {
            crate::model::OpsMetadata {
                resource_id: self.resource_id,
                ops_metadata_arn: self.ops_metadata_arn,
                last_modified_date: self.last_modified_date,
                last_modified_user: self.last_modified_user,
                creation_date: self.creation_date,
            }
        }
    }
}
impl OpsMetadata {
    /// Creates a new builder-style object to manufacture [`OpsMetadata`](crate::model::OpsMetadata)
    pub fn builder() -> crate::model::ops_metadata::Builder {
        crate::model::ops_metadata::Builder::default()
    }
}

/// <p>A filter to limit the number of OpsMetadata objects displayed.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsMetadataFilter {
    /// <p>A filter key.</p>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<std::string::String>,
    /// <p>A filter value.</p>
    #[serde(rename = "Values")]
    #[serde(default)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for OpsMetadataFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsMetadataFilter");
        formatter.field("key", &self.key);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`OpsMetadataFilter`](crate::model::OpsMetadataFilter)
pub mod ops_metadata_filter {
    /// A builder for [`OpsMetadataFilter`](crate::model::OpsMetadataFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>A filter key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsMetadataFilter`](crate::model::OpsMetadataFilter)
        pub fn build(self) -> crate::model::OpsMetadataFilter {
            crate::model::OpsMetadataFilter {
                key: self.key,
                values: self.values,
            }
        }
    }
}
impl OpsMetadataFilter {
    /// Creates a new builder-style object to manufacture [`OpsMetadataFilter`](crate::model::OpsMetadataFilter)
    pub fn builder() -> crate::model::ops_metadata_filter::Builder {
        crate::model::ops_metadata_filter::Builder::default()
    }
}

/// <p>Summary information about related-item resources for an OpsItem.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsItemRelatedItemSummary {
    /// <p>The OpsItem ID.</p>
    #[serde(rename = "OpsItemId")]
    #[serde(default)]
    pub ops_item_id: std::option::Option<std::string::String>,
    /// <p>The association ID.</p>
    #[serde(rename = "AssociationId")]
    #[serde(default)]
    pub association_id: std::option::Option<std::string::String>,
    /// <p>The resource type.</p>
    #[serde(rename = "ResourceType")]
    #[serde(default)]
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The association type.</p>
    #[serde(rename = "AssociationType")]
    #[serde(default)]
    pub association_type: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the related-item resource.</p>
    #[serde(rename = "ResourceUri")]
    #[serde(default)]
    pub resource_uri: std::option::Option<std::string::String>,
    /// <p>Information about the user or resource that created an OpsItem event.</p>
    #[serde(rename = "CreatedBy")]
    #[serde(default)]
    pub created_by: std::option::Option<crate::model::OpsItemIdentity>,
    /// <p>The time the related-item association was created.</p>
    #[serde(rename = "CreatedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub created_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the user or resource that created an OpsItem event.</p>
    #[serde(rename = "LastModifiedBy")]
    #[serde(default)]
    pub last_modified_by: std::option::Option<crate::model::OpsItemIdentity>,
    /// <p>The time the related-item association was last updated.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for OpsItemRelatedItemSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsItemRelatedItemSummary");
        formatter.field("ops_item_id", &self.ops_item_id);
        formatter.field("association_id", &self.association_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("association_type", &self.association_type);
        formatter.field("resource_uri", &self.resource_uri);
        formatter.field("created_by", &self.created_by);
        formatter.field("created_time", &self.created_time);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`OpsItemRelatedItemSummary`](crate::model::OpsItemRelatedItemSummary)
pub mod ops_item_related_item_summary {
    /// A builder for [`OpsItemRelatedItemSummary`](crate::model::OpsItemRelatedItemSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ops_item_id: std::option::Option<std::string::String>,
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) association_type: std::option::Option<std::string::String>,
        pub(crate) resource_uri: std::option::Option<std::string::String>,
        pub(crate) created_by: std::option::Option<crate::model::OpsItemIdentity>,
        pub(crate) created_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_by: std::option::Option<crate::model::OpsItemIdentity>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The OpsItem ID.</p>
        pub fn ops_item_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ops_item_id = Some(input.into());
            self
        }
        pub fn set_ops_item_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ops_item_id = input;
            self
        }
        /// <p>The association ID.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>The resource type.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The association type.</p>
        pub fn association_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_type = Some(input.into());
            self
        }
        pub fn set_association_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_type = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the related-item resource.</p>
        pub fn resource_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_uri = Some(input.into());
            self
        }
        pub fn set_resource_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_uri = input;
            self
        }
        /// <p>Information about the user or resource that created an OpsItem event.</p>
        pub fn created_by(mut self, input: crate::model::OpsItemIdentity) -> Self {
            self.created_by = Some(input);
            self
        }
        pub fn set_created_by(
            mut self,
            input: std::option::Option<crate::model::OpsItemIdentity>,
        ) -> Self {
            self.created_by = input;
            self
        }
        /// <p>The time the related-item association was created.</p>
        pub fn created_time(mut self, input: smithy_types::Instant) -> Self {
            self.created_time = Some(input);
            self
        }
        pub fn set_created_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>Information about the user or resource that created an OpsItem event.</p>
        pub fn last_modified_by(mut self, input: crate::model::OpsItemIdentity) -> Self {
            self.last_modified_by = Some(input);
            self
        }
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<crate::model::OpsItemIdentity>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// <p>The time the related-item association was last updated.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsItemRelatedItemSummary`](crate::model::OpsItemRelatedItemSummary)
        pub fn build(self) -> crate::model::OpsItemRelatedItemSummary {
            crate::model::OpsItemRelatedItemSummary {
                ops_item_id: self.ops_item_id,
                association_id: self.association_id,
                resource_type: self.resource_type,
                association_type: self.association_type,
                resource_uri: self.resource_uri,
                created_by: self.created_by,
                created_time: self.created_time,
                last_modified_by: self.last_modified_by,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl OpsItemRelatedItemSummary {
    /// Creates a new builder-style object to manufacture [`OpsItemRelatedItemSummary`](crate::model::OpsItemRelatedItemSummary)
    pub fn builder() -> crate::model::ops_item_related_item_summary::Builder {
        crate::model::ops_item_related_item_summary::Builder::default()
    }
}

/// <p>Information about the user or resource that created an OpsItem event.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsItemIdentity {
    /// <p>The Amazon Resource Name (ARN) of the IAM entity that created the OpsItem event.</p>
    #[serde(rename = "Arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OpsItemIdentity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsItemIdentity");
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}
/// See [`OpsItemIdentity`](crate::model::OpsItemIdentity)
pub mod ops_item_identity {
    /// A builder for [`OpsItemIdentity`](crate::model::OpsItemIdentity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the IAM entity that created the OpsItem event.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsItemIdentity`](crate::model::OpsItemIdentity)
        pub fn build(self) -> crate::model::OpsItemIdentity {
            crate::model::OpsItemIdentity { arn: self.arn }
        }
    }
}
impl OpsItemIdentity {
    /// Creates a new builder-style object to manufacture [`OpsItemIdentity`](crate::model::OpsItemIdentity)
    pub fn builder() -> crate::model::ops_item_identity::Builder {
        crate::model::ops_item_identity::Builder::default()
    }
}

/// <p>Describes a filter for a specific list of related-item resources. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsItemRelatedItemsFilter {
    /// <p>The name of the filter key. Supported values include <code>ResourceUri</code>,
    /// <code>ResourceType</code>, or <code>AssociationId</code>.</p>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<crate::model::OpsItemRelatedItemsFilterKey>,
    /// <p>The values for the filter.</p>
    #[serde(rename = "Values")]
    #[serde(default)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The operator used by the filter call. The only supported operator is
    /// <code>EQUAL</code>.</p>
    #[serde(rename = "Operator")]
    #[serde(default)]
    pub operator: std::option::Option<crate::model::OpsItemRelatedItemsFilterOperator>,
}
impl std::fmt::Debug for OpsItemRelatedItemsFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsItemRelatedItemsFilter");
        formatter.field("key", &self.key);
        formatter.field("values", &self.values);
        formatter.field("operator", &self.operator);
        formatter.finish()
    }
}
/// See [`OpsItemRelatedItemsFilter`](crate::model::OpsItemRelatedItemsFilter)
pub mod ops_item_related_items_filter {
    /// A builder for [`OpsItemRelatedItemsFilter`](crate::model::OpsItemRelatedItemsFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<crate::model::OpsItemRelatedItemsFilterKey>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) operator: std::option::Option<crate::model::OpsItemRelatedItemsFilterOperator>,
    }
    impl Builder {
        /// <p>The name of the filter key. Supported values include <code>ResourceUri</code>,
        /// <code>ResourceType</code>, or <code>AssociationId</code>.</p>
        pub fn key(mut self, input: crate::model::OpsItemRelatedItemsFilterKey) -> Self {
            self.key = Some(input);
            self
        }
        pub fn set_key(
            mut self,
            input: std::option::Option<crate::model::OpsItemRelatedItemsFilterKey>,
        ) -> Self {
            self.key = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// <p>The operator used by the filter call. The only supported operator is
        /// <code>EQUAL</code>.</p>
        pub fn operator(mut self, input: crate::model::OpsItemRelatedItemsFilterOperator) -> Self {
            self.operator = Some(input);
            self
        }
        pub fn set_operator(
            mut self,
            input: std::option::Option<crate::model::OpsItemRelatedItemsFilterOperator>,
        ) -> Self {
            self.operator = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsItemRelatedItemsFilter`](crate::model::OpsItemRelatedItemsFilter)
        pub fn build(self) -> crate::model::OpsItemRelatedItemsFilter {
            crate::model::OpsItemRelatedItemsFilter {
                key: self.key,
                values: self.values,
                operator: self.operator,
            }
        }
    }
}
impl OpsItemRelatedItemsFilter {
    /// Creates a new builder-style object to manufacture [`OpsItemRelatedItemsFilter`](crate::model::OpsItemRelatedItemsFilter)
    pub fn builder() -> crate::model::ops_item_related_items_filter::Builder {
        crate::model::ops_item_related_items_filter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OpsItemRelatedItemsFilterOperator {
    Equal,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OpsItemRelatedItemsFilterOperator {
    fn from(s: &str) -> Self {
        match s {
            "Equal" => OpsItemRelatedItemsFilterOperator::Equal,
            other => OpsItemRelatedItemsFilterOperator::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OpsItemRelatedItemsFilterOperator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(OpsItemRelatedItemsFilterOperator::from(s))
    }
}
impl OpsItemRelatedItemsFilterOperator {
    pub fn as_str(&self) -> &str {
        match self {
            OpsItemRelatedItemsFilterOperator::Equal => "Equal",
            OpsItemRelatedItemsFilterOperator::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for OpsItemRelatedItemsFilterOperator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for OpsItemRelatedItemsFilterOperator {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OpsItemRelatedItemsFilterKey {
    AssociationId,
    ResourceType,
    ResourceUri,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OpsItemRelatedItemsFilterKey {
    fn from(s: &str) -> Self {
        match s {
            "AssociationId" => OpsItemRelatedItemsFilterKey::AssociationId,
            "ResourceType" => OpsItemRelatedItemsFilterKey::ResourceType,
            "ResourceUri" => OpsItemRelatedItemsFilterKey::ResourceUri,
            other => OpsItemRelatedItemsFilterKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OpsItemRelatedItemsFilterKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(OpsItemRelatedItemsFilterKey::from(s))
    }
}
impl OpsItemRelatedItemsFilterKey {
    pub fn as_str(&self) -> &str {
        match self {
            OpsItemRelatedItemsFilterKey::AssociationId => "AssociationId",
            OpsItemRelatedItemsFilterKey::ResourceType => "ResourceType",
            OpsItemRelatedItemsFilterKey::ResourceUri => "ResourceUri",
            OpsItemRelatedItemsFilterKey::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for OpsItemRelatedItemsFilterKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for OpsItemRelatedItemsFilterKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Summary information about an OpsItem event or that associated an OpsItem with a related
/// item.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsItemEventSummary {
    /// <p>The ID of the OpsItem.</p>
    #[serde(rename = "OpsItemId")]
    #[serde(default)]
    pub ops_item_id: std::option::Option<std::string::String>,
    /// <p>The ID of the OpsItem event.</p>
    #[serde(rename = "EventId")]
    #[serde(default)]
    pub event_id: std::option::Option<std::string::String>,
    /// <p>The source of the OpsItem event.</p>
    #[serde(rename = "Source")]
    #[serde(default)]
    pub source: std::option::Option<std::string::String>,
    /// <p>The type of information provided as a detail.</p>
    #[serde(rename = "DetailType")]
    #[serde(default)]
    pub detail_type: std::option::Option<std::string::String>,
    /// <p>Specific information about the OpsItem event.</p>
    #[serde(rename = "Detail")]
    #[serde(default)]
    pub detail: std::option::Option<std::string::String>,
    /// <p>Information about the user or resource that created the OpsItem event.</p>
    #[serde(rename = "CreatedBy")]
    #[serde(default)]
    pub created_by: std::option::Option<crate::model::OpsItemIdentity>,
    /// <p>The date and time the OpsItem event was created.</p>
    #[serde(rename = "CreatedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub created_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for OpsItemEventSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsItemEventSummary");
        formatter.field("ops_item_id", &self.ops_item_id);
        formatter.field("event_id", &self.event_id);
        formatter.field("source", &self.source);
        formatter.field("detail_type", &self.detail_type);
        formatter.field("detail", &self.detail);
        formatter.field("created_by", &self.created_by);
        formatter.field("created_time", &self.created_time);
        formatter.finish()
    }
}
/// See [`OpsItemEventSummary`](crate::model::OpsItemEventSummary)
pub mod ops_item_event_summary {
    /// A builder for [`OpsItemEventSummary`](crate::model::OpsItemEventSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ops_item_id: std::option::Option<std::string::String>,
        pub(crate) event_id: std::option::Option<std::string::String>,
        pub(crate) source: std::option::Option<std::string::String>,
        pub(crate) detail_type: std::option::Option<std::string::String>,
        pub(crate) detail: std::option::Option<std::string::String>,
        pub(crate) created_by: std::option::Option<crate::model::OpsItemIdentity>,
        pub(crate) created_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The ID of the OpsItem.</p>
        pub fn ops_item_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ops_item_id = Some(input.into());
            self
        }
        pub fn set_ops_item_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ops_item_id = input;
            self
        }
        /// <p>The ID of the OpsItem event.</p>
        pub fn event_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_id = Some(input.into());
            self
        }
        pub fn set_event_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.event_id = input;
            self
        }
        /// <p>The source of the OpsItem event.</p>
        pub fn source(mut self, input: impl Into<std::string::String>) -> Self {
            self.source = Some(input.into());
            self
        }
        pub fn set_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source = input;
            self
        }
        /// <p>The type of information provided as a detail.</p>
        pub fn detail_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.detail_type = Some(input.into());
            self
        }
        pub fn set_detail_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.detail_type = input;
            self
        }
        /// <p>Specific information about the OpsItem event.</p>
        pub fn detail(mut self, input: impl Into<std::string::String>) -> Self {
            self.detail = Some(input.into());
            self
        }
        pub fn set_detail(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.detail = input;
            self
        }
        /// <p>Information about the user or resource that created the OpsItem event.</p>
        pub fn created_by(mut self, input: crate::model::OpsItemIdentity) -> Self {
            self.created_by = Some(input);
            self
        }
        pub fn set_created_by(
            mut self,
            input: std::option::Option<crate::model::OpsItemIdentity>,
        ) -> Self {
            self.created_by = input;
            self
        }
        /// <p>The date and time the OpsItem event was created.</p>
        pub fn created_time(mut self, input: smithy_types::Instant) -> Self {
            self.created_time = Some(input);
            self
        }
        pub fn set_created_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsItemEventSummary`](crate::model::OpsItemEventSummary)
        pub fn build(self) -> crate::model::OpsItemEventSummary {
            crate::model::OpsItemEventSummary {
                ops_item_id: self.ops_item_id,
                event_id: self.event_id,
                source: self.source,
                detail_type: self.detail_type,
                detail: self.detail,
                created_by: self.created_by,
                created_time: self.created_time,
            }
        }
    }
}
impl OpsItemEventSummary {
    /// Creates a new builder-style object to manufacture [`OpsItemEventSummary`](crate::model::OpsItemEventSummary)
    pub fn builder() -> crate::model::ops_item_event_summary::Builder {
        crate::model::ops_item_event_summary::Builder::default()
    }
}

/// <p>Describes a filter for a specific list of OpsItem events. You can filter event information
/// by using tags. You specify tags by using a key-value pair mapping. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsItemEventFilter {
    /// <p>The name of the filter key. Currently, the only supported value is
    /// <code>OpsItemId</code>.</p>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<crate::model::OpsItemEventFilterKey>,
    /// <p>The values for the filter, consisting of one or more OpsItem IDs.</p>
    #[serde(rename = "Values")]
    #[serde(default)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The operator used by the filter call. Currently, the only supported value is
    /// <code>Equal</code>.</p>
    #[serde(rename = "Operator")]
    #[serde(default)]
    pub operator: std::option::Option<crate::model::OpsItemEventFilterOperator>,
}
impl std::fmt::Debug for OpsItemEventFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsItemEventFilter");
        formatter.field("key", &self.key);
        formatter.field("values", &self.values);
        formatter.field("operator", &self.operator);
        formatter.finish()
    }
}
/// See [`OpsItemEventFilter`](crate::model::OpsItemEventFilter)
pub mod ops_item_event_filter {
    /// A builder for [`OpsItemEventFilter`](crate::model::OpsItemEventFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<crate::model::OpsItemEventFilterKey>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) operator: std::option::Option<crate::model::OpsItemEventFilterOperator>,
    }
    impl Builder {
        /// <p>The name of the filter key. Currently, the only supported value is
        /// <code>OpsItemId</code>.</p>
        pub fn key(mut self, input: crate::model::OpsItemEventFilterKey) -> Self {
            self.key = Some(input);
            self
        }
        pub fn set_key(
            mut self,
            input: std::option::Option<crate::model::OpsItemEventFilterKey>,
        ) -> Self {
            self.key = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// <p>The operator used by the filter call. Currently, the only supported value is
        /// <code>Equal</code>.</p>
        pub fn operator(mut self, input: crate::model::OpsItemEventFilterOperator) -> Self {
            self.operator = Some(input);
            self
        }
        pub fn set_operator(
            mut self,
            input: std::option::Option<crate::model::OpsItemEventFilterOperator>,
        ) -> Self {
            self.operator = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsItemEventFilter`](crate::model::OpsItemEventFilter)
        pub fn build(self) -> crate::model::OpsItemEventFilter {
            crate::model::OpsItemEventFilter {
                key: self.key,
                values: self.values,
                operator: self.operator,
            }
        }
    }
}
impl OpsItemEventFilter {
    /// Creates a new builder-style object to manufacture [`OpsItemEventFilter`](crate::model::OpsItemEventFilter)
    pub fn builder() -> crate::model::ops_item_event_filter::Builder {
        crate::model::ops_item_event_filter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OpsItemEventFilterOperator {
    Equal,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OpsItemEventFilterOperator {
    fn from(s: &str) -> Self {
        match s {
            "Equal" => OpsItemEventFilterOperator::Equal,
            other => OpsItemEventFilterOperator::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OpsItemEventFilterOperator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(OpsItemEventFilterOperator::from(s))
    }
}
impl OpsItemEventFilterOperator {
    pub fn as_str(&self) -> &str {
        match self {
            OpsItemEventFilterOperator::Equal => "Equal",
            OpsItemEventFilterOperator::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for OpsItemEventFilterOperator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for OpsItemEventFilterOperator {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OpsItemEventFilterKey {
    OpsitemId,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OpsItemEventFilterKey {
    fn from(s: &str) -> Self {
        match s {
            "OpsItemId" => OpsItemEventFilterKey::OpsitemId,
            other => OpsItemEventFilterKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OpsItemEventFilterKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(OpsItemEventFilterKey::from(s))
    }
}
impl OpsItemEventFilterKey {
    pub fn as_str(&self) -> &str {
        match self {
            OpsItemEventFilterKey::OpsitemId => "OpsItemId",
            OpsItemEventFilterKey::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for OpsItemEventFilterKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for OpsItemEventFilterKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>One or more filters. Use a filter to return a more specific list of results.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InventoryFilter {
    /// <p>The name of the filter key.</p>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<std::string::String>,
    /// <p>Inventory filter values. Example: inventory filter where instance IDs are specified as
    /// values Key=AWS:InstanceInformation.InstanceId,Values= i-a12b3c4d5e6g, i-1a2b3c4d5e6,Type=Equal
    /// </p>
    #[serde(rename = "Values")]
    #[serde(default)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The type of filter.</p>
    /// <note>
    /// <p>The <code>Exists</code> filter must be used with aggregators. For more information, see
    /// <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-inventory-aggregate.html">Aggregating inventory
    /// data</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    /// </note>
    #[serde(rename = "Type")]
    #[serde(default)]
    pub r#type: std::option::Option<crate::model::InventoryQueryOperatorType>,
}
impl std::fmt::Debug for InventoryFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InventoryFilter");
        formatter.field("key", &self.key);
        formatter.field("values", &self.values);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`InventoryFilter`](crate::model::InventoryFilter)
pub mod inventory_filter {
    /// A builder for [`InventoryFilter`](crate::model::InventoryFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) r#type: std::option::Option<crate::model::InventoryQueryOperatorType>,
    }
    impl Builder {
        /// <p>The name of the filter key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// <p>The type of filter.</p>
        /// <note>
        /// <p>The <code>Exists</code> filter must be used with aggregators. For more information, see
        /// <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-inventory-aggregate.html">Aggregating inventory
        /// data</a> in the <i>AWS Systems Manager User Guide</i>.</p>
        /// </note>
        pub fn r#type(mut self, input: crate::model::InventoryQueryOperatorType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::InventoryQueryOperatorType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`InventoryFilter`](crate::model::InventoryFilter)
        pub fn build(self) -> crate::model::InventoryFilter {
            crate::model::InventoryFilter {
                key: self.key,
                values: self.values,
                r#type: self.r#type,
            }
        }
    }
}
impl InventoryFilter {
    /// Creates a new builder-style object to manufacture [`InventoryFilter`](crate::model::InventoryFilter)
    pub fn builder() -> crate::model::inventory_filter::Builder {
        crate::model::inventory_filter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InventoryQueryOperatorType {
    BeginWith,
    Equal,
    Exists,
    GreaterThan,
    LessThan,
    NotEqual,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InventoryQueryOperatorType {
    fn from(s: &str) -> Self {
        match s {
            "BeginWith" => InventoryQueryOperatorType::BeginWith,
            "Equal" => InventoryQueryOperatorType::Equal,
            "Exists" => InventoryQueryOperatorType::Exists,
            "GreaterThan" => InventoryQueryOperatorType::GreaterThan,
            "LessThan" => InventoryQueryOperatorType::LessThan,
            "NotEqual" => InventoryQueryOperatorType::NotEqual,
            other => InventoryQueryOperatorType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InventoryQueryOperatorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(InventoryQueryOperatorType::from(s))
    }
}
impl InventoryQueryOperatorType {
    pub fn as_str(&self) -> &str {
        match self {
            InventoryQueryOperatorType::BeginWith => "BeginWith",
            InventoryQueryOperatorType::Equal => "Equal",
            InventoryQueryOperatorType::Exists => "Exists",
            InventoryQueryOperatorType::GreaterThan => "GreaterThan",
            InventoryQueryOperatorType::LessThan => "LessThan",
            InventoryQueryOperatorType::NotEqual => "NotEqual",
            InventoryQueryOperatorType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for InventoryQueryOperatorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for InventoryQueryOperatorType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Version information about the document.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DocumentVersionInfo {
    /// <p>The document name.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The friendly name of the Systems Manager document. This value can differ for each version of the
    /// document. If you want to update this value, see <a>UpdateDocument</a>.</p>
    #[serde(rename = "DisplayName")]
    #[serde(default)]
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The document version.</p>
    #[serde(rename = "DocumentVersion")]
    #[serde(default)]
    pub document_version: std::option::Option<std::string::String>,
    /// <p>The version of the artifact associated with the document. For example, "Release 12, Update
    /// 6". This value is unique across all versions of a document, and cannot be changed.</p>
    #[serde(rename = "VersionName")]
    #[serde(default)]
    pub version_name: std::option::Option<std::string::String>,
    /// <p>The date the document was created.</p>
    #[serde(rename = "CreatedDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub created_date: std::option::Option<smithy_types::Instant>,
    /// <p>An identifier for the default version of the document.</p>
    #[serde(rename = "IsDefaultVersion")]
    #[serde(default)]
    pub is_default_version: bool,
    /// <p>The document format, either JSON or YAML.</p>
    #[serde(rename = "DocumentFormat")]
    #[serde(default)]
    pub document_format: std::option::Option<crate::model::DocumentFormat>,
    /// <p>The status of the Systems Manager document, such as <code>Creating</code>, <code>Active</code>,
    /// <code>Failed</code>, and <code>Deleting</code>.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::DocumentStatus>,
    /// <p>A message returned by AWS Systems Manager that explains the <code>Status</code> value. For example, a
    /// <code>Failed</code> status might be explained by the <code>StatusInformation</code> message,
    /// "The specified S3 bucket does not exist. Verify that the URL of the S3 bucket is correct."</p>
    #[serde(rename = "StatusInformation")]
    #[serde(default)]
    pub status_information: std::option::Option<std::string::String>,
    /// <p>The current status of the approval review for the latest version of the document.</p>
    #[serde(rename = "ReviewStatus")]
    #[serde(default)]
    pub review_status: std::option::Option<crate::model::ReviewStatus>,
}
impl std::fmt::Debug for DocumentVersionInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DocumentVersionInfo");
        formatter.field("name", &self.name);
        formatter.field("display_name", &self.display_name);
        formatter.field("document_version", &self.document_version);
        formatter.field("version_name", &self.version_name);
        formatter.field("created_date", &self.created_date);
        formatter.field("is_default_version", &self.is_default_version);
        formatter.field("document_format", &self.document_format);
        formatter.field("status", &self.status);
        formatter.field("status_information", &self.status_information);
        formatter.field("review_status", &self.review_status);
        formatter.finish()
    }
}
/// See [`DocumentVersionInfo`](crate::model::DocumentVersionInfo)
pub mod document_version_info {
    /// A builder for [`DocumentVersionInfo`](crate::model::DocumentVersionInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) document_version: std::option::Option<std::string::String>,
        pub(crate) version_name: std::option::Option<std::string::String>,
        pub(crate) created_date: std::option::Option<smithy_types::Instant>,
        pub(crate) is_default_version: std::option::Option<bool>,
        pub(crate) document_format: std::option::Option<crate::model::DocumentFormat>,
        pub(crate) status: std::option::Option<crate::model::DocumentStatus>,
        pub(crate) status_information: std::option::Option<std::string::String>,
        pub(crate) review_status: std::option::Option<crate::model::ReviewStatus>,
    }
    impl Builder {
        /// <p>The document name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The friendly name of the Systems Manager document. This value can differ for each version of the
        /// document. If you want to update this value, see <a>UpdateDocument</a>.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>The document version.</p>
        pub fn document_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_version = Some(input.into());
            self
        }
        pub fn set_document_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_version = input;
            self
        }
        /// <p>The version of the artifact associated with the document. For example, "Release 12, Update
        /// 6". This value is unique across all versions of a document, and cannot be changed.</p>
        pub fn version_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_name = Some(input.into());
            self
        }
        pub fn set_version_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_name = input;
            self
        }
        /// <p>The date the document was created.</p>
        pub fn created_date(mut self, input: smithy_types::Instant) -> Self {
            self.created_date = Some(input);
            self
        }
        pub fn set_created_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.created_date = input;
            self
        }
        /// <p>An identifier for the default version of the document.</p>
        pub fn is_default_version(mut self, input: bool) -> Self {
            self.is_default_version = Some(input);
            self
        }
        pub fn set_is_default_version(mut self, input: std::option::Option<bool>) -> Self {
            self.is_default_version = input;
            self
        }
        /// <p>The document format, either JSON or YAML.</p>
        pub fn document_format(mut self, input: crate::model::DocumentFormat) -> Self {
            self.document_format = Some(input);
            self
        }
        pub fn set_document_format(
            mut self,
            input: std::option::Option<crate::model::DocumentFormat>,
        ) -> Self {
            self.document_format = input;
            self
        }
        /// <p>The status of the Systems Manager document, such as <code>Creating</code>, <code>Active</code>,
        /// <code>Failed</code>, and <code>Deleting</code>.</p>
        pub fn status(mut self, input: crate::model::DocumentStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::DocumentStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>A message returned by AWS Systems Manager that explains the <code>Status</code> value. For example, a
        /// <code>Failed</code> status might be explained by the <code>StatusInformation</code> message,
        /// "The specified S3 bucket does not exist. Verify that the URL of the S3 bucket is correct."</p>
        pub fn status_information(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_information = Some(input.into());
            self
        }
        pub fn set_status_information(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_information = input;
            self
        }
        /// <p>The current status of the approval review for the latest version of the document.</p>
        pub fn review_status(mut self, input: crate::model::ReviewStatus) -> Self {
            self.review_status = Some(input);
            self
        }
        pub fn set_review_status(
            mut self,
            input: std::option::Option<crate::model::ReviewStatus>,
        ) -> Self {
            self.review_status = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentVersionInfo`](crate::model::DocumentVersionInfo)
        pub fn build(self) -> crate::model::DocumentVersionInfo {
            crate::model::DocumentVersionInfo {
                name: self.name,
                display_name: self.display_name,
                document_version: self.document_version,
                version_name: self.version_name,
                created_date: self.created_date,
                is_default_version: self.is_default_version.unwrap_or_default(),
                document_format: self.document_format,
                status: self.status,
                status_information: self.status_information,
                review_status: self.review_status,
            }
        }
    }
}
impl DocumentVersionInfo {
    /// Creates a new builder-style object to manufacture [`DocumentVersionInfo`](crate::model::DocumentVersionInfo)
    pub fn builder() -> crate::model::document_version_info::Builder {
        crate::model::document_version_info::Builder::default()
    }
}

/// <p>Describes the name of a Systems Manager document.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DocumentIdentifier {
    /// <p>The name of the Systems Manager document.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The date the Systems Manager document was created.</p>
    #[serde(rename = "CreatedDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub created_date: std::option::Option<smithy_types::Instant>,
    /// <p>An optional field where you can specify a friendly name for the Systems Manager document. This value
    /// can differ for each version of the document. If you want to update this value, see <a>UpdateDocument</a>.</p>
    #[serde(rename = "DisplayName")]
    #[serde(default)]
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The AWS user account that created the document.</p>
    #[serde(rename = "Owner")]
    #[serde(default)]
    pub owner: std::option::Option<std::string::String>,
    /// <p>An optional field specifying the version of the artifact associated with the document. For
    /// example, "Release 12, Update 6". This value is unique across all versions of a document, and
    /// cannot be changed.</p>
    #[serde(rename = "VersionName")]
    #[serde(default)]
    pub version_name: std::option::Option<std::string::String>,
    /// <p>The operating system platform. </p>
    #[serde(rename = "PlatformTypes")]
    #[serde(default)]
    pub platform_types: std::option::Option<std::vec::Vec<crate::model::PlatformType>>,
    /// <p>The document version.</p>
    #[serde(rename = "DocumentVersion")]
    #[serde(default)]
    pub document_version: std::option::Option<std::string::String>,
    /// <p>The document type.</p>
    #[serde(rename = "DocumentType")]
    #[serde(default)]
    pub document_type: std::option::Option<crate::model::DocumentType>,
    /// <p>The schema version.</p>
    #[serde(rename = "SchemaVersion")]
    #[serde(default)]
    pub schema_version: std::option::Option<std::string::String>,
    /// <p>The document format, either JSON or YAML.</p>
    #[serde(rename = "DocumentFormat")]
    #[serde(default)]
    pub document_format: std::option::Option<crate::model::DocumentFormat>,
    /// <p>The target type which defines the kinds of resources the document can run on. For example,
    /// /AWS::EC2::Instance. For a list of valid resource types, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">AWS resource and property types
    /// reference</a> in the <i>AWS CloudFormation User Guide</i>. </p>
    #[serde(rename = "TargetType")]
    #[serde(default)]
    pub target_type: std::option::Option<std::string::String>,
    /// <p>The tags, or metadata, that have been applied to the document.</p>
    #[serde(rename = "Tags")]
    #[serde(default)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>A list of SSM documents required by a document. For example, an
    /// <code>ApplicationConfiguration</code> document requires an
    /// <code>ApplicationConfigurationSchema</code> document.</p>
    #[serde(rename = "Requires")]
    #[serde(default)]
    pub requires: std::option::Option<std::vec::Vec<crate::model::DocumentRequires>>,
    /// <p>The current status of a document review.</p>
    #[serde(rename = "ReviewStatus")]
    #[serde(default)]
    pub review_status: std::option::Option<crate::model::ReviewStatus>,
    /// <p>The user in your organization who created the document.</p>
    #[serde(rename = "Author")]
    #[serde(default)]
    pub author: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DocumentIdentifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DocumentIdentifier");
        formatter.field("name", &self.name);
        formatter.field("created_date", &self.created_date);
        formatter.field("display_name", &self.display_name);
        formatter.field("owner", &self.owner);
        formatter.field("version_name", &self.version_name);
        formatter.field("platform_types", &self.platform_types);
        formatter.field("document_version", &self.document_version);
        formatter.field("document_type", &self.document_type);
        formatter.field("schema_version", &self.schema_version);
        formatter.field("document_format", &self.document_format);
        formatter.field("target_type", &self.target_type);
        formatter.field("tags", &self.tags);
        formatter.field("requires", &self.requires);
        formatter.field("review_status", &self.review_status);
        formatter.field("author", &self.author);
        formatter.finish()
    }
}
/// See [`DocumentIdentifier`](crate::model::DocumentIdentifier)
pub mod document_identifier {
    /// A builder for [`DocumentIdentifier`](crate::model::DocumentIdentifier)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) created_date: std::option::Option<smithy_types::Instant>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) owner: std::option::Option<std::string::String>,
        pub(crate) version_name: std::option::Option<std::string::String>,
        pub(crate) platform_types: std::option::Option<std::vec::Vec<crate::model::PlatformType>>,
        pub(crate) document_version: std::option::Option<std::string::String>,
        pub(crate) document_type: std::option::Option<crate::model::DocumentType>,
        pub(crate) schema_version: std::option::Option<std::string::String>,
        pub(crate) document_format: std::option::Option<crate::model::DocumentFormat>,
        pub(crate) target_type: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) requires: std::option::Option<std::vec::Vec<crate::model::DocumentRequires>>,
        pub(crate) review_status: std::option::Option<crate::model::ReviewStatus>,
        pub(crate) author: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Systems Manager document.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The date the Systems Manager document was created.</p>
        pub fn created_date(mut self, input: smithy_types::Instant) -> Self {
            self.created_date = Some(input);
            self
        }
        pub fn set_created_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.created_date = input;
            self
        }
        /// <p>An optional field where you can specify a friendly name for the Systems Manager document. This value
        /// can differ for each version of the document. If you want to update this value, see <a>UpdateDocument</a>.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>The AWS user account that created the document.</p>
        pub fn owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner = Some(input.into());
            self
        }
        pub fn set_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner = input;
            self
        }
        /// <p>An optional field specifying the version of the artifact associated with the document. For
        /// example, "Release 12, Update 6". This value is unique across all versions of a document, and
        /// cannot be changed.</p>
        pub fn version_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_name = Some(input.into());
            self
        }
        pub fn set_version_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_name = input;
            self
        }
        pub fn platform_types(mut self, input: impl Into<crate::model::PlatformType>) -> Self {
            let mut v = self.platform_types.unwrap_or_default();
            v.push(input.into());
            self.platform_types = Some(v);
            self
        }
        pub fn set_platform_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PlatformType>>,
        ) -> Self {
            self.platform_types = input;
            self
        }
        /// <p>The document version.</p>
        pub fn document_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_version = Some(input.into());
            self
        }
        pub fn set_document_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_version = input;
            self
        }
        /// <p>The document type.</p>
        pub fn document_type(mut self, input: crate::model::DocumentType) -> Self {
            self.document_type = Some(input);
            self
        }
        pub fn set_document_type(
            mut self,
            input: std::option::Option<crate::model::DocumentType>,
        ) -> Self {
            self.document_type = input;
            self
        }
        /// <p>The schema version.</p>
        pub fn schema_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.schema_version = Some(input.into());
            self
        }
        pub fn set_schema_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.schema_version = input;
            self
        }
        /// <p>The document format, either JSON or YAML.</p>
        pub fn document_format(mut self, input: crate::model::DocumentFormat) -> Self {
            self.document_format = Some(input);
            self
        }
        pub fn set_document_format(
            mut self,
            input: std::option::Option<crate::model::DocumentFormat>,
        ) -> Self {
            self.document_format = input;
            self
        }
        /// <p>The target type which defines the kinds of resources the document can run on. For example,
        /// /AWS::EC2::Instance. For a list of valid resource types, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">AWS resource and property types
        /// reference</a> in the <i>AWS CloudFormation User Guide</i>. </p>
        pub fn target_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_type = Some(input.into());
            self
        }
        pub fn set_target_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_type = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        pub fn requires(mut self, input: impl Into<crate::model::DocumentRequires>) -> Self {
            let mut v = self.requires.unwrap_or_default();
            v.push(input.into());
            self.requires = Some(v);
            self
        }
        pub fn set_requires(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DocumentRequires>>,
        ) -> Self {
            self.requires = input;
            self
        }
        /// <p>The current status of a document review.</p>
        pub fn review_status(mut self, input: crate::model::ReviewStatus) -> Self {
            self.review_status = Some(input);
            self
        }
        pub fn set_review_status(
            mut self,
            input: std::option::Option<crate::model::ReviewStatus>,
        ) -> Self {
            self.review_status = input;
            self
        }
        /// <p>The user in your organization who created the document.</p>
        pub fn author(mut self, input: impl Into<std::string::String>) -> Self {
            self.author = Some(input.into());
            self
        }
        pub fn set_author(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.author = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentIdentifier`](crate::model::DocumentIdentifier)
        pub fn build(self) -> crate::model::DocumentIdentifier {
            crate::model::DocumentIdentifier {
                name: self.name,
                created_date: self.created_date,
                display_name: self.display_name,
                owner: self.owner,
                version_name: self.version_name,
                platform_types: self.platform_types,
                document_version: self.document_version,
                document_type: self.document_type,
                schema_version: self.schema_version,
                document_format: self.document_format,
                target_type: self.target_type,
                tags: self.tags,
                requires: self.requires,
                review_status: self.review_status,
                author: self.author,
            }
        }
    }
}
impl DocumentIdentifier {
    /// Creates a new builder-style object to manufacture [`DocumentIdentifier`](crate::model::DocumentIdentifier)
    pub fn builder() -> crate::model::document_identifier::Builder {
        crate::model::document_identifier::Builder::default()
    }
}

/// <p>One or more filters. Use a filter to return a more specific list of documents.</p>
/// <p>For keys, you can specify one or more tags that have been applied to a document. </p>
/// <p>You can also use AWS-provided keys, some of which have specific allowed values. These keys
/// and their associated values are as follows:</p>
/// <dl>
/// <dt>DocumentType</dt>
/// <dd>
/// <ul>
/// <li>
/// <p>ApplicationConfiguration</p>
/// </li>
/// <li>
/// <p>ApplicationConfigurationSchema</p>
/// </li>
/// <li>
/// <p>Automation</p>
/// </li>
/// <li>
/// <p>ChangeCalendar</p>
/// </li>
/// <li>
/// <p>Command</p>
/// </li>
/// <li>
/// <p>DeploymentStrategy</p>
/// </li>
/// <li>
/// <p>Package</p>
/// </li>
/// <li>
/// <p>Policy</p>
/// </li>
/// <li>
/// <p>Session</p>
/// </li>
/// </ul>
/// </dd>
/// <dt>Owner</dt>
/// <dd>
/// <p>Note that only one <code>Owner</code> can be specified in a request. For example:
/// <code>Key=Owner,Values=Self</code>.</p>
/// <ul>
/// <li>
/// <p>Amazon</p>
/// </li>
/// <li>
/// <p>Private</p>
/// </li>
/// <li>
/// <p>Public</p>
/// </li>
/// <li>
/// <p>Self</p>
/// </li>
/// <li>
/// <p>ThirdParty</p>
/// </li>
/// </ul>
/// </dd>
/// <dt>PlatformTypes</dt>
/// <dd>
/// <ul>
/// <li>
/// <p>Linux</p>
/// </li>
/// <li>
/// <p>Windows</p>
/// </li>
/// </ul>
/// </dd>
/// </dl>
/// <p>
/// <code>Name</code> is another AWS-provided key. If you use <code>Name</code> as a key, you
/// can use a name prefix to return a list of documents. For example, in the AWS CLI, to return a
/// list of all documents that begin with <code>Te</code>, run the following command:</p>
/// <p>
/// <code>aws ssm list-documents --filters Key=Name,Values=Te</code>
/// </p>
/// <p>You can also use the <code>TargetType</code> AWS-provided key. For a list of valid resource
/// type values that can be used with this key, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">AWS resource and property types
/// reference</a> in the <i>AWS CloudFormation User Guide</i>.</p>
/// <p>If you specify more than two keys, only documents that are identified by all the tags are
/// returned in the results. If you specify more than two values for a key, documents that are
/// identified by any of the values are returned in the results.</p>
/// <p>To specify a custom key and value pair, use the format
/// <code>Key=tag:tagName,Values=valueName</code>.</p>
/// <p>For example, if you created a key called region and are using the AWS CLI to call the
/// <code>list-documents</code> command: </p>
/// <p>
/// <code>aws ssm list-documents --filters Key=tag:region,Values=east,west
/// Key=Owner,Values=Self</code>
/// </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DocumentKeyValuesFilter {
    /// <p>The name of the filter key.</p>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The value for the filter key.</p>
    #[serde(rename = "Values")]
    #[serde(default)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for DocumentKeyValuesFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DocumentKeyValuesFilter");
        formatter.field("key", &self.key);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`DocumentKeyValuesFilter`](crate::model::DocumentKeyValuesFilter)
pub mod document_key_values_filter {
    /// A builder for [`DocumentKeyValuesFilter`](crate::model::DocumentKeyValuesFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the filter key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentKeyValuesFilter`](crate::model::DocumentKeyValuesFilter)
        pub fn build(self) -> crate::model::DocumentKeyValuesFilter {
            crate::model::DocumentKeyValuesFilter {
                key: self.key,
                values: self.values,
            }
        }
    }
}
impl DocumentKeyValuesFilter {
    /// Creates a new builder-style object to manufacture [`DocumentKeyValuesFilter`](crate::model::DocumentKeyValuesFilter)
    pub fn builder() -> crate::model::document_key_values_filter::Builder {
        crate::model::document_key_values_filter::Builder::default()
    }
}

/// <p>This data type is deprecated. Instead, use <a>DocumentKeyValuesFilter</a>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DocumentFilter {
    /// <p>The name of the filter.</p>
    #[serde(rename = "key")]
    #[serde(default)]
    pub key: std::option::Option<crate::model::DocumentFilterKey>,
    /// <p>The value of the filter.</p>
    #[serde(rename = "value")]
    #[serde(default)]
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DocumentFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DocumentFilter");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`DocumentFilter`](crate::model::DocumentFilter)
pub mod document_filter {
    /// A builder for [`DocumentFilter`](crate::model::DocumentFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<crate::model::DocumentFilterKey>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the filter.</p>
        pub fn key(mut self, input: crate::model::DocumentFilterKey) -> Self {
            self.key = Some(input);
            self
        }
        pub fn set_key(
            mut self,
            input: std::option::Option<crate::model::DocumentFilterKey>,
        ) -> Self {
            self.key = input;
            self
        }
        /// <p>The value of the filter.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentFilter`](crate::model::DocumentFilter)
        pub fn build(self) -> crate::model::DocumentFilter {
            crate::model::DocumentFilter {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl DocumentFilter {
    /// Creates a new builder-style object to manufacture [`DocumentFilter`](crate::model::DocumentFilter)
    pub fn builder() -> crate::model::document_filter::Builder {
        crate::model::document_filter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DocumentFilterKey {
    DocumentType,
    Name,
    Owner,
    PlatformTypes,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DocumentFilterKey {
    fn from(s: &str) -> Self {
        match s {
            "DocumentType" => DocumentFilterKey::DocumentType,
            "Name" => DocumentFilterKey::Name,
            "Owner" => DocumentFilterKey::Owner,
            "PlatformTypes" => DocumentFilterKey::PlatformTypes,
            other => DocumentFilterKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DocumentFilterKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(DocumentFilterKey::from(s))
    }
}
impl DocumentFilterKey {
    pub fn as_str(&self) -> &str {
        match self {
            DocumentFilterKey::DocumentType => "DocumentType",
            DocumentFilterKey::Name => "Name",
            DocumentFilterKey::Owner => "Owner",
            DocumentFilterKey::PlatformTypes => "PlatformTypes",
            DocumentFilterKey::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for DocumentFilterKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for DocumentFilterKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Details about the response to a document review request.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DocumentMetadataResponseInfo {
    /// <p>Details about a reviewer's response to a document review request.</p>
    #[serde(rename = "ReviewerResponse")]
    #[serde(default)]
    pub reviewer_response:
        std::option::Option<std::vec::Vec<crate::model::DocumentReviewerResponseSource>>,
}
impl std::fmt::Debug for DocumentMetadataResponseInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DocumentMetadataResponseInfo");
        formatter.field("reviewer_response", &self.reviewer_response);
        formatter.finish()
    }
}
/// See [`DocumentMetadataResponseInfo`](crate::model::DocumentMetadataResponseInfo)
pub mod document_metadata_response_info {
    /// A builder for [`DocumentMetadataResponseInfo`](crate::model::DocumentMetadataResponseInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reviewer_response:
            std::option::Option<std::vec::Vec<crate::model::DocumentReviewerResponseSource>>,
    }
    impl Builder {
        pub fn reviewer_response(
            mut self,
            input: impl Into<crate::model::DocumentReviewerResponseSource>,
        ) -> Self {
            let mut v = self.reviewer_response.unwrap_or_default();
            v.push(input.into());
            self.reviewer_response = Some(v);
            self
        }
        pub fn set_reviewer_response(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DocumentReviewerResponseSource>>,
        ) -> Self {
            self.reviewer_response = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentMetadataResponseInfo`](crate::model::DocumentMetadataResponseInfo)
        pub fn build(self) -> crate::model::DocumentMetadataResponseInfo {
            crate::model::DocumentMetadataResponseInfo {
                reviewer_response: self.reviewer_response,
            }
        }
    }
}
impl DocumentMetadataResponseInfo {
    /// Creates a new builder-style object to manufacture [`DocumentMetadataResponseInfo`](crate::model::DocumentMetadataResponseInfo)
    pub fn builder() -> crate::model::document_metadata_response_info::Builder {
        crate::model::document_metadata_response_info::Builder::default()
    }
}

/// <p>Information about a reviewer's response to a document review request.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DocumentReviewerResponseSource {
    /// <p>The date and time that a reviewer entered a response to a document review request.</p>
    #[serde(rename = "CreateTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub create_time: std::option::Option<smithy_types::Instant>,
    /// <p>The date and time that a reviewer last updated a response to a document review
    /// request.</p>
    #[serde(rename = "UpdatedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub updated_time: std::option::Option<smithy_types::Instant>,
    /// <p>The current review status of a new custom SSM document created by a member of your
    /// organization, or of the latest version of an existing SSM document.</p>
    /// <p>Only one version of a document can be in the APPROVED state at a time. When a new version is
    /// approved, the status of the previous version changes to REJECTED.</p>
    /// <p>Only one version of a document can be in review, or PENDING, at a time.</p>
    #[serde(rename = "ReviewStatus")]
    #[serde(default)]
    pub review_status: std::option::Option<crate::model::ReviewStatus>,
    /// <p>The comment entered by a reviewer as part of their document review response.</p>
    #[serde(rename = "Comment")]
    #[serde(default)]
    pub comment: std::option::Option<std::vec::Vec<crate::model::DocumentReviewCommentSource>>,
    /// <p>The user in your organization assigned to review a document request.</p>
    #[serde(rename = "Reviewer")]
    #[serde(default)]
    pub reviewer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DocumentReviewerResponseSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DocumentReviewerResponseSource");
        formatter.field("create_time", &self.create_time);
        formatter.field("updated_time", &self.updated_time);
        formatter.field("review_status", &self.review_status);
        formatter.field("comment", &self.comment);
        formatter.field("reviewer", &self.reviewer);
        formatter.finish()
    }
}
/// See [`DocumentReviewerResponseSource`](crate::model::DocumentReviewerResponseSource)
pub mod document_reviewer_response_source {
    /// A builder for [`DocumentReviewerResponseSource`](crate::model::DocumentReviewerResponseSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) create_time: std::option::Option<smithy_types::Instant>,
        pub(crate) updated_time: std::option::Option<smithy_types::Instant>,
        pub(crate) review_status: std::option::Option<crate::model::ReviewStatus>,
        pub(crate) comment:
            std::option::Option<std::vec::Vec<crate::model::DocumentReviewCommentSource>>,
        pub(crate) reviewer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The date and time that a reviewer entered a response to a document review request.</p>
        pub fn create_time(mut self, input: smithy_types::Instant) -> Self {
            self.create_time = Some(input);
            self
        }
        pub fn set_create_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The date and time that a reviewer last updated a response to a document review
        /// request.</p>
        pub fn updated_time(mut self, input: smithy_types::Instant) -> Self {
            self.updated_time = Some(input);
            self
        }
        pub fn set_updated_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.updated_time = input;
            self
        }
        /// <p>The current review status of a new custom SSM document created by a member of your
        /// organization, or of the latest version of an existing SSM document.</p>
        /// <p>Only one version of a document can be in the APPROVED state at a time. When a new version is
        /// approved, the status of the previous version changes to REJECTED.</p>
        /// <p>Only one version of a document can be in review, or PENDING, at a time.</p>
        pub fn review_status(mut self, input: crate::model::ReviewStatus) -> Self {
            self.review_status = Some(input);
            self
        }
        pub fn set_review_status(
            mut self,
            input: std::option::Option<crate::model::ReviewStatus>,
        ) -> Self {
            self.review_status = input;
            self
        }
        pub fn comment(
            mut self,
            input: impl Into<crate::model::DocumentReviewCommentSource>,
        ) -> Self {
            let mut v = self.comment.unwrap_or_default();
            v.push(input.into());
            self.comment = Some(v);
            self
        }
        pub fn set_comment(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DocumentReviewCommentSource>>,
        ) -> Self {
            self.comment = input;
            self
        }
        /// <p>The user in your organization assigned to review a document request.</p>
        pub fn reviewer(mut self, input: impl Into<std::string::String>) -> Self {
            self.reviewer = Some(input.into());
            self
        }
        pub fn set_reviewer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reviewer = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentReviewerResponseSource`](crate::model::DocumentReviewerResponseSource)
        pub fn build(self) -> crate::model::DocumentReviewerResponseSource {
            crate::model::DocumentReviewerResponseSource {
                create_time: self.create_time,
                updated_time: self.updated_time,
                review_status: self.review_status,
                comment: self.comment,
                reviewer: self.reviewer,
            }
        }
    }
}
impl DocumentReviewerResponseSource {
    /// Creates a new builder-style object to manufacture [`DocumentReviewerResponseSource`](crate::model::DocumentReviewerResponseSource)
    pub fn builder() -> crate::model::document_reviewer_response_source::Builder {
        crate::model::document_reviewer_response_source::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DocumentMetadataEnum {
    DocumentReviews,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DocumentMetadataEnum {
    fn from(s: &str) -> Self {
        match s {
            "DocumentReviews" => DocumentMetadataEnum::DocumentReviews,
            other => DocumentMetadataEnum::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DocumentMetadataEnum {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(DocumentMetadataEnum::from(s))
    }
}
impl DocumentMetadataEnum {
    pub fn as_str(&self) -> &str {
        match self {
            DocumentMetadataEnum::DocumentReviews => "DocumentReviews",
            DocumentMetadataEnum::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for DocumentMetadataEnum {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for DocumentMetadataEnum {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>A summary of compliance information by compliance type.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ComplianceSummaryItem {
    /// <p>The type of compliance item. For example, the compliance type can be Association, Patch, or
    /// Custom:string.</p>
    #[serde(rename = "ComplianceType")]
    #[serde(default)]
    pub compliance_type: std::option::Option<std::string::String>,
    /// <p>A list of COMPLIANT items for the specified compliance type.</p>
    #[serde(rename = "CompliantSummary")]
    #[serde(default)]
    pub compliant_summary: std::option::Option<crate::model::CompliantSummary>,
    /// <p>A list of NON_COMPLIANT items for the specified compliance type.</p>
    #[serde(rename = "NonCompliantSummary")]
    #[serde(default)]
    pub non_compliant_summary: std::option::Option<crate::model::NonCompliantSummary>,
}
impl std::fmt::Debug for ComplianceSummaryItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ComplianceSummaryItem");
        formatter.field("compliance_type", &self.compliance_type);
        formatter.field("compliant_summary", &self.compliant_summary);
        formatter.field("non_compliant_summary", &self.non_compliant_summary);
        formatter.finish()
    }
}
/// See [`ComplianceSummaryItem`](crate::model::ComplianceSummaryItem)
pub mod compliance_summary_item {
    /// A builder for [`ComplianceSummaryItem`](crate::model::ComplianceSummaryItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) compliance_type: std::option::Option<std::string::String>,
        pub(crate) compliant_summary: std::option::Option<crate::model::CompliantSummary>,
        pub(crate) non_compliant_summary: std::option::Option<crate::model::NonCompliantSummary>,
    }
    impl Builder {
        /// <p>The type of compliance item. For example, the compliance type can be Association, Patch, or
        /// Custom:string.</p>
        pub fn compliance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.compliance_type = Some(input.into());
            self
        }
        pub fn set_compliance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.compliance_type = input;
            self
        }
        /// <p>A list of COMPLIANT items for the specified compliance type.</p>
        pub fn compliant_summary(mut self, input: crate::model::CompliantSummary) -> Self {
            self.compliant_summary = Some(input);
            self
        }
        pub fn set_compliant_summary(
            mut self,
            input: std::option::Option<crate::model::CompliantSummary>,
        ) -> Self {
            self.compliant_summary = input;
            self
        }
        /// <p>A list of NON_COMPLIANT items for the specified compliance type.</p>
        pub fn non_compliant_summary(mut self, input: crate::model::NonCompliantSummary) -> Self {
            self.non_compliant_summary = Some(input);
            self
        }
        pub fn set_non_compliant_summary(
            mut self,
            input: std::option::Option<crate::model::NonCompliantSummary>,
        ) -> Self {
            self.non_compliant_summary = input;
            self
        }
        /// Consumes the builder and constructs a [`ComplianceSummaryItem`](crate::model::ComplianceSummaryItem)
        pub fn build(self) -> crate::model::ComplianceSummaryItem {
            crate::model::ComplianceSummaryItem {
                compliance_type: self.compliance_type,
                compliant_summary: self.compliant_summary,
                non_compliant_summary: self.non_compliant_summary,
            }
        }
    }
}
impl ComplianceSummaryItem {
    /// Creates a new builder-style object to manufacture [`ComplianceSummaryItem`](crate::model::ComplianceSummaryItem)
    pub fn builder() -> crate::model::compliance_summary_item::Builder {
        crate::model::compliance_summary_item::Builder::default()
    }
}

/// <p>Information about the compliance as defined by the resource type. For example, for a patch
/// resource type, <code>Items</code> includes information about the PatchSeverity, Classification,
/// and so on.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ComplianceItem {
    /// <p>The compliance type. For example, Association (for a State Manager association), Patch, or
    /// Custom:<code>string</code> are all valid compliance types.</p>
    #[serde(rename = "ComplianceType")]
    #[serde(default)]
    pub compliance_type: std::option::Option<std::string::String>,
    /// <p>The type of resource. <code>ManagedInstance</code> is currently the only supported resource
    /// type.</p>
    #[serde(rename = "ResourceType")]
    #[serde(default)]
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>An ID for the resource. For a managed instance, this is the instance ID.</p>
    #[serde(rename = "ResourceId")]
    #[serde(default)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>An ID for the compliance item. For example, if the compliance item is a Windows patch, the
    /// ID could be the number of the KB article; for example: KB4010320.</p>
    #[serde(rename = "Id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// <p>A title for the compliance item. For example, if the compliance item is a Windows patch, the
    /// title could be the title of the KB article for the patch; for example: Security Update for Active
    /// Directory Federation Services.</p>
    #[serde(rename = "Title")]
    #[serde(default)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The status of the compliance item. An item is either COMPLIANT, NON_COMPLIANT, or an empty
    /// string (for Windows patches that aren't applicable).</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::ComplianceStatus>,
    /// <p>The severity of the compliance status. Severity can be one of the following: Critical, High,
    /// Medium, Low, Informational, Unspecified.</p>
    #[serde(rename = "Severity")]
    #[serde(default)]
    pub severity: std::option::Option<crate::model::ComplianceSeverity>,
    /// <p>A summary for the compliance item. The summary includes an execution ID, the execution type
    /// (for example, command), and the execution time.</p>
    #[serde(rename = "ExecutionSummary")]
    #[serde(default)]
    pub execution_summary: std::option::Option<crate::model::ComplianceExecutionSummary>,
    /// <p>A "Key": "Value" tag combination for the compliance item.</p>
    #[serde(rename = "Details")]
    #[serde(default)]
    pub details:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for ComplianceItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ComplianceItem");
        formatter.field("compliance_type", &self.compliance_type);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("resource_id", &self.resource_id);
        formatter.field("id", &self.id);
        formatter.field("title", &self.title);
        formatter.field("status", &self.status);
        formatter.field("severity", &self.severity);
        formatter.field("execution_summary", &self.execution_summary);
        formatter.field("details", &self.details);
        formatter.finish()
    }
}
/// See [`ComplianceItem`](crate::model::ComplianceItem)
pub mod compliance_item {
    /// A builder for [`ComplianceItem`](crate::model::ComplianceItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) compliance_type: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ComplianceStatus>,
        pub(crate) severity: std::option::Option<crate::model::ComplianceSeverity>,
        pub(crate) execution_summary: std::option::Option<crate::model::ComplianceExecutionSummary>,
        pub(crate) details: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The compliance type. For example, Association (for a State Manager association), Patch, or
        /// Custom:<code>string</code> are all valid compliance types.</p>
        pub fn compliance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.compliance_type = Some(input.into());
            self
        }
        pub fn set_compliance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.compliance_type = input;
            self
        }
        /// <p>The type of resource. <code>ManagedInstance</code> is currently the only supported resource
        /// type.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>An ID for the resource. For a managed instance, this is the instance ID.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>An ID for the compliance item. For example, if the compliance item is a Windows patch, the
        /// ID could be the number of the KB article; for example: KB4010320.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>A title for the compliance item. For example, if the compliance item is a Windows patch, the
        /// title could be the title of the KB article for the patch; for example: Security Update for Active
        /// Directory Federation Services.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The status of the compliance item. An item is either COMPLIANT, NON_COMPLIANT, or an empty
        /// string (for Windows patches that aren't applicable).</p>
        pub fn status(mut self, input: crate::model::ComplianceStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ComplianceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The severity of the compliance status. Severity can be one of the following: Critical, High,
        /// Medium, Low, Informational, Unspecified.</p>
        pub fn severity(mut self, input: crate::model::ComplianceSeverity) -> Self {
            self.severity = Some(input);
            self
        }
        pub fn set_severity(
            mut self,
            input: std::option::Option<crate::model::ComplianceSeverity>,
        ) -> Self {
            self.severity = input;
            self
        }
        /// <p>A summary for the compliance item. The summary includes an execution ID, the execution type
        /// (for example, command), and the execution time.</p>
        pub fn execution_summary(
            mut self,
            input: crate::model::ComplianceExecutionSummary,
        ) -> Self {
            self.execution_summary = Some(input);
            self
        }
        pub fn set_execution_summary(
            mut self,
            input: std::option::Option<crate::model::ComplianceExecutionSummary>,
        ) -> Self {
            self.execution_summary = input;
            self
        }
        pub fn details(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.details.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.details = Some(hash_map);
            self
        }
        pub fn set_details(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.details = input;
            self
        }
        /// Consumes the builder and constructs a [`ComplianceItem`](crate::model::ComplianceItem)
        pub fn build(self) -> crate::model::ComplianceItem {
            crate::model::ComplianceItem {
                compliance_type: self.compliance_type,
                resource_type: self.resource_type,
                resource_id: self.resource_id,
                id: self.id,
                title: self.title,
                status: self.status,
                severity: self.severity,
                execution_summary: self.execution_summary,
                details: self.details,
            }
        }
    }
}
impl ComplianceItem {
    /// Creates a new builder-style object to manufacture [`ComplianceItem`](crate::model::ComplianceItem)
    pub fn builder() -> crate::model::compliance_item::Builder {
        crate::model::compliance_item::Builder::default()
    }
}

/// <p>Describes a command filter.</p>
/// <note>
/// <p>An instance ID can't be specified when a command status is <code>Pending</code> because the
/// command hasn't run on the instance yet.</p>
/// </note>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CommandFilter {
    /// <p>The name of the filter.</p>
    #[serde(rename = "key")]
    #[serde(default)]
    pub key: std::option::Option<crate::model::CommandFilterKey>,
    /// <p>The filter value. Valid values for each filter key are as follows:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>InvokedAfter</b>: Specify a timestamp to limit your results.
    /// For example, specify <code>2018-07-07T00:00:00Z</code> to see a list of command executions
    /// occurring July 7, 2018, and later.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>InvokedBefore</b>: Specify a timestamp to limit your results.
    /// For example, specify <code>2018-07-07T00:00:00Z</code> to see a list of command executions from
    /// before July 7, 2018.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Status</b>: Specify a valid command status to see a list of
    /// all command executions with that status. Status values you can specify include:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Pending</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>InProgress</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Success</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Cancelled</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Failed</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>TimedOut</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Cancelling</code>
    /// </p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>
    /// <b>DocumentName</b>: Specify name of the SSM document for which
    /// you want to see command execution results. For example, specify
    /// <code>AWS-RunPatchBaseline</code> to see command executions that used this SSM document to
    /// perform security patching operations on instances. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>ExecutionStage</b>: Specify one of the following
    /// values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Executing</code>: Returns a list of command executions that are currently still
    /// running.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Complete</code>: Returns a list of command executions that have already completed.
    /// </p>
    /// </li>
    /// </ul>
    /// </li>
    /// </ul>
    #[serde(rename = "value")]
    #[serde(default)]
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommandFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommandFilter");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`CommandFilter`](crate::model::CommandFilter)
pub mod command_filter {
    /// A builder for [`CommandFilter`](crate::model::CommandFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<crate::model::CommandFilterKey>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the filter.</p>
        pub fn key(mut self, input: crate::model::CommandFilterKey) -> Self {
            self.key = Some(input);
            self
        }
        pub fn set_key(
            mut self,
            input: std::option::Option<crate::model::CommandFilterKey>,
        ) -> Self {
            self.key = input;
            self
        }
        /// <p>The filter value. Valid values for each filter key are as follows:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>InvokedAfter</b>: Specify a timestamp to limit your results.
        /// For example, specify <code>2018-07-07T00:00:00Z</code> to see a list of command executions
        /// occurring July 7, 2018, and later.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>InvokedBefore</b>: Specify a timestamp to limit your results.
        /// For example, specify <code>2018-07-07T00:00:00Z</code> to see a list of command executions from
        /// before July 7, 2018.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Status</b>: Specify a valid command status to see a list of
        /// all command executions with that status. Status values you can specify include:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Pending</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>InProgress</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Success</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Cancelled</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Failed</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TimedOut</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Cancelling</code>
        /// </p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <b>DocumentName</b>: Specify name of the SSM document for which
        /// you want to see command execution results. For example, specify
        /// <code>AWS-RunPatchBaseline</code> to see command executions that used this SSM document to
        /// perform security patching operations on instances. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>ExecutionStage</b>: Specify one of the following
        /// values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Executing</code>: Returns a list of command executions that are currently still
        /// running.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Complete</code>: Returns a list of command executions that have already completed.
        /// </p>
        /// </li>
        /// </ul>
        /// </li>
        /// </ul>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`CommandFilter`](crate::model::CommandFilter)
        pub fn build(self) -> crate::model::CommandFilter {
            crate::model::CommandFilter {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl CommandFilter {
    /// Creates a new builder-style object to manufacture [`CommandFilter`](crate::model::CommandFilter)
    pub fn builder() -> crate::model::command_filter::Builder {
        crate::model::command_filter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CommandFilterKey {
    DocumentName,
    ExecutionStage,
    InvokedAfter,
    InvokedBefore,
    Status,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CommandFilterKey {
    fn from(s: &str) -> Self {
        match s {
            "DocumentName" => CommandFilterKey::DocumentName,
            "ExecutionStage" => CommandFilterKey::ExecutionStage,
            "InvokedAfter" => CommandFilterKey::InvokedAfter,
            "InvokedBefore" => CommandFilterKey::InvokedBefore,
            "Status" => CommandFilterKey::Status,
            other => CommandFilterKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CommandFilterKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(CommandFilterKey::from(s))
    }
}
impl CommandFilterKey {
    pub fn as_str(&self) -> &str {
        match self {
            CommandFilterKey::DocumentName => "DocumentName",
            CommandFilterKey::ExecutionStage => "ExecutionStage",
            CommandFilterKey::InvokedAfter => "InvokedAfter",
            CommandFilterKey::InvokedBefore => "InvokedBefore",
            CommandFilterKey::Status => "Status",
            CommandFilterKey::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for CommandFilterKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for CommandFilterKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>An invocation is copy of a command sent to a specific instance. A command can apply to one
/// or more instances. A command invocation applies to one instance. For example, if a user runs
/// SendCommand against three instances, then a command invocation is created for each requested
/// instance ID. A command invocation returns status and detail information about a command you ran.
/// </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CommandInvocation {
    /// <p>The command against which this invocation was requested.</p>
    #[serde(rename = "CommandId")]
    #[serde(default)]
    pub command_id: std::option::Option<std::string::String>,
    /// <p>The instance ID in which this invocation was requested.</p>
    #[serde(rename = "InstanceId")]
    #[serde(default)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The name of the invocation target. For EC2 instances this is the value for the aws:Name tag.
    /// For on-premises instances, this is the name of the instance.</p>
    #[serde(rename = "InstanceName")]
    #[serde(default)]
    pub instance_name: std::option::Option<std::string::String>,
    /// <p>User-specified information about the command, such as a brief description of what the
    /// command should do.</p>
    #[serde(rename = "Comment")]
    #[serde(default)]
    pub comment: std::option::Option<std::string::String>,
    /// <p>The document name that was requested for execution.</p>
    #[serde(rename = "DocumentName")]
    #[serde(default)]
    pub document_name: std::option::Option<std::string::String>,
    /// <p>The SSM document version.</p>
    #[serde(rename = "DocumentVersion")]
    #[serde(default)]
    pub document_version: std::option::Option<std::string::String>,
    /// <p>The time and date the request was sent to this instance.</p>
    #[serde(rename = "RequestedDateTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub requested_date_time: std::option::Option<smithy_types::Instant>,
    /// <p>Whether or not the invocation succeeded, failed, or is pending.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::CommandInvocationStatus>,
    /// <p>A detailed status of the command execution for each invocation (each instance targeted by
    /// the command). StatusDetails includes more information than Status because it includes states
    /// resulting from error and concurrency control parameters. StatusDetails can show different results
    /// than Status. For more information about these statuses, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html">Understanding command
    /// statuses</a> in the <i>AWS Systems Manager User Guide</i>. StatusDetails can be one of the
    /// following values:</p>
    /// <ul>
    /// <li>
    /// <p>Pending: The command has not been sent to the instance.</p>
    /// </li>
    /// <li>
    /// <p>In Progress: The command has been sent to the instance but has not reached a terminal
    /// state.</p>
    /// </li>
    /// <li>
    /// <p>Success: The execution of the command or plugin was successfully completed. This is a
    /// terminal state.</p>
    /// </li>
    /// <li>
    /// <p>Delivery Timed Out: The command was not delivered to the instance before the delivery
    /// timeout expired. Delivery timeouts do not count against the parent command's MaxErrors limit,
    /// but they do contribute to whether the parent command status is Success or Incomplete. This is a
    /// terminal state.</p>
    /// </li>
    /// <li>
    /// <p>Execution Timed Out: Command execution started on the instance, but the execution was not
    /// complete before the execution timeout expired. Execution timeouts count against the MaxErrors
    /// limit of the parent command. This is a terminal state.</p>
    /// </li>
    /// <li>
    /// <p>Failed: The command was not successful on the instance. For a plugin, this indicates that
    /// the result code was not zero. For a command invocation, this indicates that the result code for
    /// one or more plugins was not zero. Invocation failures count against the MaxErrors limit of the
    /// parent command. This is a terminal state.</p>
    /// </li>
    /// <li>
    /// <p>Canceled: The command was terminated before it was completed. This is a terminal
    /// state.</p>
    /// </li>
    /// <li>
    /// <p>Undeliverable: The command can't be delivered to the instance. The instance might not
    /// exist or might not be responding. Undeliverable invocations don't count against the parent
    /// command's MaxErrors limit and don't contribute to whether the parent command status is Success
    /// or Incomplete. This is a terminal state.</p>
    /// </li>
    /// <li>
    /// <p>Terminated: The parent command exceeded its MaxErrors limit and subsequent command
    /// invocations were canceled by the system. This is a terminal state.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "StatusDetails")]
    #[serde(default)]
    pub status_details: std::option::Option<std::string::String>,
    /// <p> Gets the trace output sent by the agent. </p>
    #[serde(rename = "TraceOutput")]
    #[serde(default)]
    pub trace_output: std::option::Option<std::string::String>,
    /// <p>The URL to the plugin's StdOut file in Amazon S3, if the S3 bucket was defined for the parent
    /// command. For an invocation, StandardOutputUrl is populated if there is just one plugin defined
    /// for the command, and the S3 bucket was defined for the command.</p>
    #[serde(rename = "StandardOutputUrl")]
    #[serde(default)]
    pub standard_output_url: std::option::Option<std::string::String>,
    /// <p>The URL to the plugin's StdErr file in Amazon S3, if the S3 bucket was defined for the parent
    /// command. For an invocation, StandardErrorUrl is populated if there is just one plugin defined for
    /// the command, and the S3 bucket was defined for the command.</p>
    #[serde(rename = "StandardErrorUrl")]
    #[serde(default)]
    pub standard_error_url: std::option::Option<std::string::String>,
    /// <p>Plugins processed by the command.</p>
    #[serde(rename = "CommandPlugins")]
    #[serde(default)]
    pub command_plugins: std::option::Option<std::vec::Vec<crate::model::CommandPlugin>>,
    /// <p>The IAM service role that Run Command uses to act on your behalf when sending notifications
    /// about command status changes on a per instance basis.</p>
    #[serde(rename = "ServiceRole")]
    #[serde(default)]
    pub service_role: std::option::Option<std::string::String>,
    /// <p>Configurations for sending notifications about command status changes on a per instance
    /// basis.</p>
    #[serde(rename = "NotificationConfig")]
    #[serde(default)]
    pub notification_config: std::option::Option<crate::model::NotificationConfig>,
    /// <p>CloudWatch Logs information where you want Systems Manager to send the command output.</p>
    #[serde(rename = "CloudWatchOutputConfig")]
    #[serde(default)]
    pub cloud_watch_output_config: std::option::Option<crate::model::CloudWatchOutputConfig>,
}
impl std::fmt::Debug for CommandInvocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommandInvocation");
        formatter.field("command_id", &self.command_id);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("instance_name", &self.instance_name);
        formatter.field("comment", &self.comment);
        formatter.field("document_name", &self.document_name);
        formatter.field("document_version", &self.document_version);
        formatter.field("requested_date_time", &self.requested_date_time);
        formatter.field("status", &self.status);
        formatter.field("status_details", &self.status_details);
        formatter.field("trace_output", &self.trace_output);
        formatter.field("standard_output_url", &self.standard_output_url);
        formatter.field("standard_error_url", &self.standard_error_url);
        formatter.field("command_plugins", &self.command_plugins);
        formatter.field("service_role", &self.service_role);
        formatter.field("notification_config", &self.notification_config);
        formatter.field("cloud_watch_output_config", &self.cloud_watch_output_config);
        formatter.finish()
    }
}
/// See [`CommandInvocation`](crate::model::CommandInvocation)
pub mod command_invocation {
    /// A builder for [`CommandInvocation`](crate::model::CommandInvocation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) command_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) instance_name: std::option::Option<std::string::String>,
        pub(crate) comment: std::option::Option<std::string::String>,
        pub(crate) document_name: std::option::Option<std::string::String>,
        pub(crate) document_version: std::option::Option<std::string::String>,
        pub(crate) requested_date_time: std::option::Option<smithy_types::Instant>,
        pub(crate) status: std::option::Option<crate::model::CommandInvocationStatus>,
        pub(crate) status_details: std::option::Option<std::string::String>,
        pub(crate) trace_output: std::option::Option<std::string::String>,
        pub(crate) standard_output_url: std::option::Option<std::string::String>,
        pub(crate) standard_error_url: std::option::Option<std::string::String>,
        pub(crate) command_plugins: std::option::Option<std::vec::Vec<crate::model::CommandPlugin>>,
        pub(crate) service_role: std::option::Option<std::string::String>,
        pub(crate) notification_config: std::option::Option<crate::model::NotificationConfig>,
        pub(crate) cloud_watch_output_config:
            std::option::Option<crate::model::CloudWatchOutputConfig>,
    }
    impl Builder {
        /// <p>The command against which this invocation was requested.</p>
        pub fn command_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.command_id = Some(input.into());
            self
        }
        pub fn set_command_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.command_id = input;
            self
        }
        /// <p>The instance ID in which this invocation was requested.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The name of the invocation target. For EC2 instances this is the value for the aws:Name tag.
        /// For on-premises instances, this is the name of the instance.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_name = Some(input.into());
            self
        }
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_name = input;
            self
        }
        /// <p>User-specified information about the command, such as a brief description of what the
        /// command should do.</p>
        pub fn comment(mut self, input: impl Into<std::string::String>) -> Self {
            self.comment = Some(input.into());
            self
        }
        pub fn set_comment(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.comment = input;
            self
        }
        /// <p>The document name that was requested for execution.</p>
        pub fn document_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_name = Some(input.into());
            self
        }
        pub fn set_document_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_name = input;
            self
        }
        /// <p>The SSM document version.</p>
        pub fn document_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_version = Some(input.into());
            self
        }
        pub fn set_document_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_version = input;
            self
        }
        /// <p>The time and date the request was sent to this instance.</p>
        pub fn requested_date_time(mut self, input: smithy_types::Instant) -> Self {
            self.requested_date_time = Some(input);
            self
        }
        pub fn set_requested_date_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.requested_date_time = input;
            self
        }
        /// <p>Whether or not the invocation succeeded, failed, or is pending.</p>
        pub fn status(mut self, input: crate::model::CommandInvocationStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::CommandInvocationStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>A detailed status of the command execution for each invocation (each instance targeted by
        /// the command). StatusDetails includes more information than Status because it includes states
        /// resulting from error and concurrency control parameters. StatusDetails can show different results
        /// than Status. For more information about these statuses, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html">Understanding command
        /// statuses</a> in the <i>AWS Systems Manager User Guide</i>. StatusDetails can be one of the
        /// following values:</p>
        /// <ul>
        /// <li>
        /// <p>Pending: The command has not been sent to the instance.</p>
        /// </li>
        /// <li>
        /// <p>In Progress: The command has been sent to the instance but has not reached a terminal
        /// state.</p>
        /// </li>
        /// <li>
        /// <p>Success: The execution of the command or plugin was successfully completed. This is a
        /// terminal state.</p>
        /// </li>
        /// <li>
        /// <p>Delivery Timed Out: The command was not delivered to the instance before the delivery
        /// timeout expired. Delivery timeouts do not count against the parent command's MaxErrors limit,
        /// but they do contribute to whether the parent command status is Success or Incomplete. This is a
        /// terminal state.</p>
        /// </li>
        /// <li>
        /// <p>Execution Timed Out: Command execution started on the instance, but the execution was not
        /// complete before the execution timeout expired. Execution timeouts count against the MaxErrors
        /// limit of the parent command. This is a terminal state.</p>
        /// </li>
        /// <li>
        /// <p>Failed: The command was not successful on the instance. For a plugin, this indicates that
        /// the result code was not zero. For a command invocation, this indicates that the result code for
        /// one or more plugins was not zero. Invocation failures count against the MaxErrors limit of the
        /// parent command. This is a terminal state.</p>
        /// </li>
        /// <li>
        /// <p>Canceled: The command was terminated before it was completed. This is a terminal
        /// state.</p>
        /// </li>
        /// <li>
        /// <p>Undeliverable: The command can't be delivered to the instance. The instance might not
        /// exist or might not be responding. Undeliverable invocations don't count against the parent
        /// command's MaxErrors limit and don't contribute to whether the parent command status is Success
        /// or Incomplete. This is a terminal state.</p>
        /// </li>
        /// <li>
        /// <p>Terminated: The parent command exceeded its MaxErrors limit and subsequent command
        /// invocations were canceled by the system. This is a terminal state.</p>
        /// </li>
        /// </ul>
        pub fn status_details(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_details = Some(input.into());
            self
        }
        pub fn set_status_details(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_details = input;
            self
        }
        /// <p> Gets the trace output sent by the agent. </p>
        pub fn trace_output(mut self, input: impl Into<std::string::String>) -> Self {
            self.trace_output = Some(input.into());
            self
        }
        pub fn set_trace_output(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.trace_output = input;
            self
        }
        /// <p>The URL to the plugin's StdOut file in Amazon S3, if the S3 bucket was defined for the parent
        /// command. For an invocation, StandardOutputUrl is populated if there is just one plugin defined
        /// for the command, and the S3 bucket was defined for the command.</p>
        pub fn standard_output_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.standard_output_url = Some(input.into());
            self
        }
        pub fn set_standard_output_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.standard_output_url = input;
            self
        }
        /// <p>The URL to the plugin's StdErr file in Amazon S3, if the S3 bucket was defined for the parent
        /// command. For an invocation, StandardErrorUrl is populated if there is just one plugin defined for
        /// the command, and the S3 bucket was defined for the command.</p>
        pub fn standard_error_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.standard_error_url = Some(input.into());
            self
        }
        pub fn set_standard_error_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.standard_error_url = input;
            self
        }
        pub fn command_plugins(mut self, input: impl Into<crate::model::CommandPlugin>) -> Self {
            let mut v = self.command_plugins.unwrap_or_default();
            v.push(input.into());
            self.command_plugins = Some(v);
            self
        }
        pub fn set_command_plugins(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CommandPlugin>>,
        ) -> Self {
            self.command_plugins = input;
            self
        }
        /// <p>The IAM service role that Run Command uses to act on your behalf when sending notifications
        /// about command status changes on a per instance basis.</p>
        pub fn service_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_role = Some(input.into());
            self
        }
        pub fn set_service_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_role = input;
            self
        }
        /// <p>Configurations for sending notifications about command status changes on a per instance
        /// basis.</p>
        pub fn notification_config(mut self, input: crate::model::NotificationConfig) -> Self {
            self.notification_config = Some(input);
            self
        }
        pub fn set_notification_config(
            mut self,
            input: std::option::Option<crate::model::NotificationConfig>,
        ) -> Self {
            self.notification_config = input;
            self
        }
        /// <p>CloudWatch Logs information where you want Systems Manager to send the command output.</p>
        pub fn cloud_watch_output_config(
            mut self,
            input: crate::model::CloudWatchOutputConfig,
        ) -> Self {
            self.cloud_watch_output_config = Some(input);
            self
        }
        pub fn set_cloud_watch_output_config(
            mut self,
            input: std::option::Option<crate::model::CloudWatchOutputConfig>,
        ) -> Self {
            self.cloud_watch_output_config = input;
            self
        }
        /// Consumes the builder and constructs a [`CommandInvocation`](crate::model::CommandInvocation)
        pub fn build(self) -> crate::model::CommandInvocation {
            crate::model::CommandInvocation {
                command_id: self.command_id,
                instance_id: self.instance_id,
                instance_name: self.instance_name,
                comment: self.comment,
                document_name: self.document_name,
                document_version: self.document_version,
                requested_date_time: self.requested_date_time,
                status: self.status,
                status_details: self.status_details,
                trace_output: self.trace_output,
                standard_output_url: self.standard_output_url,
                standard_error_url: self.standard_error_url,
                command_plugins: self.command_plugins,
                service_role: self.service_role,
                notification_config: self.notification_config,
                cloud_watch_output_config: self.cloud_watch_output_config,
            }
        }
    }
}
impl CommandInvocation {
    /// Creates a new builder-style object to manufacture [`CommandInvocation`](crate::model::CommandInvocation)
    pub fn builder() -> crate::model::command_invocation::Builder {
        crate::model::command_invocation::Builder::default()
    }
}

/// <p>Describes plugin details.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CommandPlugin {
    /// <p>The name of the plugin. Must be one of the following: aws:updateAgent, aws:domainjoin,
    /// aws:applications, aws:runPowerShellScript, aws:psmodule, aws:cloudWatch, aws:runShellScript, or
    /// aws:updateSSMAgent. </p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The status of this plugin. You can run a document with multiple plugins.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::CommandPluginStatus>,
    /// <p>A detailed status of the plugin execution. StatusDetails includes more information than
    /// Status because it includes states resulting from error and concurrency control parameters.
    /// StatusDetails can show different results than Status. For more information about these statuses,
    /// see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html">Understanding command statuses</a> in the <i>AWS Systems Manager User Guide</i>.
    /// StatusDetails can be one of the following values:</p>
    /// <ul>
    /// <li>
    /// <p>Pending: The command has not been sent to the instance.</p>
    /// </li>
    /// <li>
    /// <p>In Progress: The command has been sent to the instance but has not reached a terminal
    /// state.</p>
    /// </li>
    /// <li>
    /// <p>Success: The execution of the command or plugin was successfully completed. This is a
    /// terminal state.</p>
    /// </li>
    /// <li>
    /// <p>Delivery Timed Out: The command was not delivered to the instance before the delivery
    /// timeout expired. Delivery timeouts do not count against the parent command's MaxErrors limit,
    /// but they do contribute to whether the parent command status is Success or Incomplete. This is a
    /// terminal state.</p>
    /// </li>
    /// <li>
    /// <p>Execution Timed Out: Command execution started on the instance, but the execution was not
    /// complete before the execution timeout expired. Execution timeouts count against the MaxErrors
    /// limit of the parent command. This is a terminal state.</p>
    /// </li>
    /// <li>
    /// <p>Failed: The command was not successful on the instance. For a plugin, this indicates that
    /// the result code was not zero. For a command invocation, this indicates that the result code for
    /// one or more plugins was not zero. Invocation failures count against the MaxErrors limit of the
    /// parent command. This is a terminal state.</p>
    /// </li>
    /// <li>
    /// <p>Canceled: The command was terminated before it was completed. This is a terminal
    /// state.</p>
    /// </li>
    /// <li>
    /// <p>Undeliverable: The command can't be delivered to the instance. The instance might not
    /// exist, or it might not be responding. Undeliverable invocations don't count against the parent
    /// command's MaxErrors limit, and they don't contribute to whether the parent command status is
    /// Success or Incomplete. This is a terminal state.</p>
    /// </li>
    /// <li>
    /// <p>Terminated: The parent command exceeded its MaxErrors limit and subsequent command
    /// invocations were canceled by the system. This is a terminal state.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "StatusDetails")]
    #[serde(default)]
    pub status_details: std::option::Option<std::string::String>,
    /// <p>A numeric response code generated after running the plugin. </p>
    #[serde(rename = "ResponseCode")]
    #[serde(default)]
    pub response_code: i32,
    /// <p>The time the plugin started running. </p>
    #[serde(rename = "ResponseStartDateTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub response_start_date_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time the plugin stopped running. Could stop prematurely if, for example, a cancel
    /// command was sent. </p>
    #[serde(rename = "ResponseFinishDateTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub response_finish_date_time: std::option::Option<smithy_types::Instant>,
    /// <p>Output of the plugin execution.</p>
    #[serde(rename = "Output")]
    #[serde(default)]
    pub output: std::option::Option<std::string::String>,
    /// <p>The URL for the complete text written by the plugin to stdout in Amazon S3. If the S3 bucket for
    /// the command was not specified, then this string is empty.</p>
    #[serde(rename = "StandardOutputUrl")]
    #[serde(default)]
    pub standard_output_url: std::option::Option<std::string::String>,
    /// <p>The URL for the complete text written by the plugin to stderr. If execution is not yet
    /// complete, then this string is empty.</p>
    #[serde(rename = "StandardErrorUrl")]
    #[serde(default)]
    pub standard_error_url: std::option::Option<std::string::String>,
    /// <p>(Deprecated) You can no longer specify this parameter. The system ignores it. Instead, Systems Manager
    /// automatically determines the S3 bucket region.</p>
    #[serde(rename = "OutputS3Region")]
    #[serde(default)]
    pub output_s3_region: std::option::Option<std::string::String>,
    /// <p>The S3 bucket where the responses to the command executions should be stored. This was
    /// requested when issuing the command. For example, in the following response:</p>
    /// <p>doc-example-bucket/ab19cb99-a030-46dd-9dfc-8eSAMPLEPre-Fix/i-02573cafcfEXAMPLE/awsrunShellScript </p>
    /// <p>doc-example-bucket is the name of the S3 bucket;</p>
    /// <p>ab19cb99-a030-46dd-9dfc-8eSAMPLEPre-Fix is the name of the S3 prefix;</p>
    /// <p>i-02573cafcfEXAMPLE is the instance ID;</p>
    /// <p>awsrunShellScript is the name of the plugin.</p>
    #[serde(rename = "OutputS3BucketName")]
    #[serde(default)]
    pub output_s3_bucket_name: std::option::Option<std::string::String>,
    /// <p>The S3 directory path inside the bucket where the responses to the command executions should
    /// be stored. This was requested when issuing the command. For example, in the following
    /// response:</p>
    /// <p>doc-example-bucket/ab19cb99-a030-46dd-9dfc-8eSAMPLEPre-Fix/i-02573cafcfEXAMPLE/awsrunShellScript </p>
    /// <p>doc-example-bucket is the name of the S3 bucket;</p>
    /// <p>ab19cb99-a030-46dd-9dfc-8eSAMPLEPre-Fix is the name of the S3 prefix;</p>
    /// <p>i-02573cafcfEXAMPLE is the instance ID;</p>
    /// <p>awsrunShellScript is the name of the plugin.</p>
    #[serde(rename = "OutputS3KeyPrefix")]
    #[serde(default)]
    pub output_s3_key_prefix: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommandPlugin {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommandPlugin");
        formatter.field("name", &self.name);
        formatter.field("status", &self.status);
        formatter.field("status_details", &self.status_details);
        formatter.field("response_code", &self.response_code);
        formatter.field("response_start_date_time", &self.response_start_date_time);
        formatter.field("response_finish_date_time", &self.response_finish_date_time);
        formatter.field("output", &self.output);
        formatter.field("standard_output_url", &self.standard_output_url);
        formatter.field("standard_error_url", &self.standard_error_url);
        formatter.field("output_s3_region", &self.output_s3_region);
        formatter.field("output_s3_bucket_name", &self.output_s3_bucket_name);
        formatter.field("output_s3_key_prefix", &self.output_s3_key_prefix);
        formatter.finish()
    }
}
/// See [`CommandPlugin`](crate::model::CommandPlugin)
pub mod command_plugin {
    /// A builder for [`CommandPlugin`](crate::model::CommandPlugin)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::CommandPluginStatus>,
        pub(crate) status_details: std::option::Option<std::string::String>,
        pub(crate) response_code: std::option::Option<i32>,
        pub(crate) response_start_date_time: std::option::Option<smithy_types::Instant>,
        pub(crate) response_finish_date_time: std::option::Option<smithy_types::Instant>,
        pub(crate) output: std::option::Option<std::string::String>,
        pub(crate) standard_output_url: std::option::Option<std::string::String>,
        pub(crate) standard_error_url: std::option::Option<std::string::String>,
        pub(crate) output_s3_region: std::option::Option<std::string::String>,
        pub(crate) output_s3_bucket_name: std::option::Option<std::string::String>,
        pub(crate) output_s3_key_prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the plugin. Must be one of the following: aws:updateAgent, aws:domainjoin,
        /// aws:applications, aws:runPowerShellScript, aws:psmodule, aws:cloudWatch, aws:runShellScript, or
        /// aws:updateSSMAgent. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The status of this plugin. You can run a document with multiple plugins.</p>
        pub fn status(mut self, input: crate::model::CommandPluginStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::CommandPluginStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>A detailed status of the plugin execution. StatusDetails includes more information than
        /// Status because it includes states resulting from error and concurrency control parameters.
        /// StatusDetails can show different results than Status. For more information about these statuses,
        /// see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html">Understanding command statuses</a> in the <i>AWS Systems Manager User Guide</i>.
        /// StatusDetails can be one of the following values:</p>
        /// <ul>
        /// <li>
        /// <p>Pending: The command has not been sent to the instance.</p>
        /// </li>
        /// <li>
        /// <p>In Progress: The command has been sent to the instance but has not reached a terminal
        /// state.</p>
        /// </li>
        /// <li>
        /// <p>Success: The execution of the command or plugin was successfully completed. This is a
        /// terminal state.</p>
        /// </li>
        /// <li>
        /// <p>Delivery Timed Out: The command was not delivered to the instance before the delivery
        /// timeout expired. Delivery timeouts do not count against the parent command's MaxErrors limit,
        /// but they do contribute to whether the parent command status is Success or Incomplete. This is a
        /// terminal state.</p>
        /// </li>
        /// <li>
        /// <p>Execution Timed Out: Command execution started on the instance, but the execution was not
        /// complete before the execution timeout expired. Execution timeouts count against the MaxErrors
        /// limit of the parent command. This is a terminal state.</p>
        /// </li>
        /// <li>
        /// <p>Failed: The command was not successful on the instance. For a plugin, this indicates that
        /// the result code was not zero. For a command invocation, this indicates that the result code for
        /// one or more plugins was not zero. Invocation failures count against the MaxErrors limit of the
        /// parent command. This is a terminal state.</p>
        /// </li>
        /// <li>
        /// <p>Canceled: The command was terminated before it was completed. This is a terminal
        /// state.</p>
        /// </li>
        /// <li>
        /// <p>Undeliverable: The command can't be delivered to the instance. The instance might not
        /// exist, or it might not be responding. Undeliverable invocations don't count against the parent
        /// command's MaxErrors limit, and they don't contribute to whether the parent command status is
        /// Success or Incomplete. This is a terminal state.</p>
        /// </li>
        /// <li>
        /// <p>Terminated: The parent command exceeded its MaxErrors limit and subsequent command
        /// invocations were canceled by the system. This is a terminal state.</p>
        /// </li>
        /// </ul>
        pub fn status_details(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_details = Some(input.into());
            self
        }
        pub fn set_status_details(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_details = input;
            self
        }
        /// <p>A numeric response code generated after running the plugin. </p>
        pub fn response_code(mut self, input: i32) -> Self {
            self.response_code = Some(input);
            self
        }
        pub fn set_response_code(mut self, input: std::option::Option<i32>) -> Self {
            self.response_code = input;
            self
        }
        /// <p>The time the plugin started running. </p>
        pub fn response_start_date_time(mut self, input: smithy_types::Instant) -> Self {
            self.response_start_date_time = Some(input);
            self
        }
        pub fn set_response_start_date_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.response_start_date_time = input;
            self
        }
        /// <p>The time the plugin stopped running. Could stop prematurely if, for example, a cancel
        /// command was sent. </p>
        pub fn response_finish_date_time(mut self, input: smithy_types::Instant) -> Self {
            self.response_finish_date_time = Some(input);
            self
        }
        pub fn set_response_finish_date_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.response_finish_date_time = input;
            self
        }
        /// <p>Output of the plugin execution.</p>
        pub fn output(mut self, input: impl Into<std::string::String>) -> Self {
            self.output = Some(input.into());
            self
        }
        pub fn set_output(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.output = input;
            self
        }
        /// <p>The URL for the complete text written by the plugin to stdout in Amazon S3. If the S3 bucket for
        /// the command was not specified, then this string is empty.</p>
        pub fn standard_output_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.standard_output_url = Some(input.into());
            self
        }
        pub fn set_standard_output_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.standard_output_url = input;
            self
        }
        /// <p>The URL for the complete text written by the plugin to stderr. If execution is not yet
        /// complete, then this string is empty.</p>
        pub fn standard_error_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.standard_error_url = Some(input.into());
            self
        }
        pub fn set_standard_error_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.standard_error_url = input;
            self
        }
        /// <p>(Deprecated) You can no longer specify this parameter. The system ignores it. Instead, Systems Manager
        /// automatically determines the S3 bucket region.</p>
        pub fn output_s3_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_s3_region = Some(input.into());
            self
        }
        pub fn set_output_s3_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_s3_region = input;
            self
        }
        /// <p>The S3 bucket where the responses to the command executions should be stored. This was
        /// requested when issuing the command. For example, in the following response:</p>
        /// <p>doc-example-bucket/ab19cb99-a030-46dd-9dfc-8eSAMPLEPre-Fix/i-02573cafcfEXAMPLE/awsrunShellScript </p>
        /// <p>doc-example-bucket is the name of the S3 bucket;</p>
        /// <p>ab19cb99-a030-46dd-9dfc-8eSAMPLEPre-Fix is the name of the S3 prefix;</p>
        /// <p>i-02573cafcfEXAMPLE is the instance ID;</p>
        /// <p>awsrunShellScript is the name of the plugin.</p>
        pub fn output_s3_bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_s3_bucket_name = Some(input.into());
            self
        }
        pub fn set_output_s3_bucket_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_s3_bucket_name = input;
            self
        }
        /// <p>The S3 directory path inside the bucket where the responses to the command executions should
        /// be stored. This was requested when issuing the command. For example, in the following
        /// response:</p>
        /// <p>doc-example-bucket/ab19cb99-a030-46dd-9dfc-8eSAMPLEPre-Fix/i-02573cafcfEXAMPLE/awsrunShellScript </p>
        /// <p>doc-example-bucket is the name of the S3 bucket;</p>
        /// <p>ab19cb99-a030-46dd-9dfc-8eSAMPLEPre-Fix is the name of the S3 prefix;</p>
        /// <p>i-02573cafcfEXAMPLE is the instance ID;</p>
        /// <p>awsrunShellScript is the name of the plugin.</p>
        pub fn output_s3_key_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_s3_key_prefix = Some(input.into());
            self
        }
        pub fn set_output_s3_key_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_s3_key_prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`CommandPlugin`](crate::model::CommandPlugin)
        pub fn build(self) -> crate::model::CommandPlugin {
            crate::model::CommandPlugin {
                name: self.name,
                status: self.status,
                status_details: self.status_details,
                response_code: self.response_code.unwrap_or_default(),
                response_start_date_time: self.response_start_date_time,
                response_finish_date_time: self.response_finish_date_time,
                output: self.output,
                standard_output_url: self.standard_output_url,
                standard_error_url: self.standard_error_url,
                output_s3_region: self.output_s3_region,
                output_s3_bucket_name: self.output_s3_bucket_name,
                output_s3_key_prefix: self.output_s3_key_prefix,
            }
        }
    }
}
impl CommandPlugin {
    /// Creates a new builder-style object to manufacture [`CommandPlugin`](crate::model::CommandPlugin)
    pub fn builder() -> crate::model::command_plugin::Builder {
        crate::model::command_plugin::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CommandPluginStatus {
    Cancelled,
    Failed,
    InProgress,
    Pending,
    Success,
    TimedOut,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CommandPluginStatus {
    fn from(s: &str) -> Self {
        match s {
            "Cancelled" => CommandPluginStatus::Cancelled,
            "Failed" => CommandPluginStatus::Failed,
            "InProgress" => CommandPluginStatus::InProgress,
            "Pending" => CommandPluginStatus::Pending,
            "Success" => CommandPluginStatus::Success,
            "TimedOut" => CommandPluginStatus::TimedOut,
            other => CommandPluginStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CommandPluginStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(CommandPluginStatus::from(s))
    }
}
impl CommandPluginStatus {
    pub fn as_str(&self) -> &str {
        match self {
            CommandPluginStatus::Cancelled => "Cancelled",
            CommandPluginStatus::Failed => "Failed",
            CommandPluginStatus::InProgress => "InProgress",
            CommandPluginStatus::Pending => "Pending",
            CommandPluginStatus::Success => "Success",
            CommandPluginStatus::TimedOut => "TimedOut",
            CommandPluginStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for CommandPluginStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for CommandPluginStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CommandInvocationStatus {
    Cancelled,
    Cancelling,
    Delayed,
    Failed,
    InProgress,
    Pending,
    Success,
    TimedOut,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CommandInvocationStatus {
    fn from(s: &str) -> Self {
        match s {
            "Cancelled" => CommandInvocationStatus::Cancelled,
            "Cancelling" => CommandInvocationStatus::Cancelling,
            "Delayed" => CommandInvocationStatus::Delayed,
            "Failed" => CommandInvocationStatus::Failed,
            "InProgress" => CommandInvocationStatus::InProgress,
            "Pending" => CommandInvocationStatus::Pending,
            "Success" => CommandInvocationStatus::Success,
            "TimedOut" => CommandInvocationStatus::TimedOut,
            other => CommandInvocationStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CommandInvocationStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(CommandInvocationStatus::from(s))
    }
}
impl CommandInvocationStatus {
    pub fn as_str(&self) -> &str {
        match self {
            CommandInvocationStatus::Cancelled => "Cancelled",
            CommandInvocationStatus::Cancelling => "Cancelling",
            CommandInvocationStatus::Delayed => "Delayed",
            CommandInvocationStatus::Failed => "Failed",
            CommandInvocationStatus::InProgress => "InProgress",
            CommandInvocationStatus::Pending => "Pending",
            CommandInvocationStatus::Success => "Success",
            CommandInvocationStatus::TimedOut => "TimedOut",
            CommandInvocationStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for CommandInvocationStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for CommandInvocationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Information about the association version.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociationVersionInfo {
    /// <p>The ID created by the system when the association was created.</p>
    #[serde(rename = "AssociationId")]
    #[serde(default)]
    pub association_id: std::option::Option<std::string::String>,
    /// <p>The association version.</p>
    #[serde(rename = "AssociationVersion")]
    #[serde(default)]
    pub association_version: std::option::Option<std::string::String>,
    /// <p>The date the association version was created.</p>
    #[serde(rename = "CreatedDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub created_date: std::option::Option<smithy_types::Instant>,
    /// <p>The name specified when the association was created.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The version of a Systems Manager document used when the association version was created.</p>
    #[serde(rename = "DocumentVersion")]
    #[serde(default)]
    pub document_version: std::option::Option<std::string::String>,
    /// <p>Parameters specified when the association version was created.</p>
    #[serde(rename = "Parameters")]
    #[serde(default)]
    pub parameters: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The targets specified for the association when the association version was created. </p>
    #[serde(rename = "Targets")]
    #[serde(default)]
    pub targets: std::option::Option<std::vec::Vec<crate::model::Target>>,
    /// <p>The cron or rate schedule specified for the association when the association version was
    /// created.</p>
    #[serde(rename = "ScheduleExpression")]
    #[serde(default)]
    pub schedule_expression: std::option::Option<std::string::String>,
    /// <p>The location in Amazon S3 specified for the association when the association version was
    /// created.</p>
    #[serde(rename = "OutputLocation")]
    #[serde(default)]
    pub output_location: std::option::Option<crate::model::InstanceAssociationOutputLocation>,
    /// <p>The name specified for the association version when the association version was
    /// created.</p>
    #[serde(rename = "AssociationName")]
    #[serde(default)]
    pub association_name: std::option::Option<std::string::String>,
    /// <p>The number of errors that are allowed before the system stops sending requests to run the
    /// association on additional targets. You can specify either an absolute number of errors, for
    /// example 10, or a percentage of the target set, for example 10%. If you specify 3, for example,
    /// the system stops sending requests when the fourth error is received. If you specify 0, then the
    /// system stops sending requests after the first error is returned. If you run an association on 50
    /// instances and set MaxError to 10%, then the system stops sending the request when the sixth error
    /// is received.</p>
    /// <p>Executions that are already running an association when MaxErrors is reached are allowed to
    /// complete, but some of these executions may fail as well. If you need to ensure that there won't
    /// be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one
    /// at a time.</p>
    #[serde(rename = "MaxErrors")]
    #[serde(default)]
    pub max_errors: std::option::Option<std::string::String>,
    /// <p>The maximum number of targets allowed to run the association at the same time. You can
    /// specify a number, for example 10, or a percentage of the target set, for example 10%. The default
    /// value is 100%, which means all targets run the association at the same time.</p>
    /// <p>If a new instance starts and attempts to run an association while Systems Manager is running
    /// MaxConcurrency associations, the association is allowed to run. During the next association
    /// interval, the new instance will process its association within the limit specified for
    /// MaxConcurrency.</p>
    #[serde(rename = "MaxConcurrency")]
    #[serde(default)]
    pub max_concurrency: std::option::Option<std::string::String>,
    /// <p>The severity level that is assigned to the association.</p>
    #[serde(rename = "ComplianceSeverity")]
    #[serde(default)]
    pub compliance_severity: std::option::Option<crate::model::AssociationComplianceSeverity>,
    /// <p>The mode for generating association compliance. You can specify <code>AUTO</code> or
    /// <code>MANUAL</code>. In <code>AUTO</code> mode, the system uses the status of the association
    /// execution to determine the compliance status. If the association execution runs successfully,
    /// then the association is <code>COMPLIANT</code>. If the association execution doesn't run
    /// successfully, the association is <code>NON-COMPLIANT</code>.</p>
    /// <p>In <code>MANUAL</code> mode, you must specify the <code>AssociationId</code> as a parameter
    /// for the <a>PutComplianceItems</a> API action. In this case, compliance data is not
    /// managed by State Manager. It is managed by your direct call to the <a>PutComplianceItems</a> API action.</p>
    /// <p>By default, all associations use <code>AUTO</code> mode.</p>
    #[serde(rename = "SyncCompliance")]
    #[serde(default)]
    pub sync_compliance: std::option::Option<crate::model::AssociationSyncCompliance>,
    /// <p>By default, when you create a new associations, the system runs it immediately after it is
    /// created and then according to the schedule you specified. Specify this option if you don't want
    /// an association to run immediately after you create it. This parameter is not supported for rate
    /// expressions.</p>
    #[serde(rename = "ApplyOnlyAtCronInterval")]
    #[serde(default)]
    pub apply_only_at_cron_interval: bool,
    /// <p>The names or Amazon Resource Names (ARNs) of the Systems Manager Change Calendar type
    /// documents your associations are gated under. The associations for this version only run when
    /// that Change Calendar is open.  For more information, see
    /// <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar">AWS Systems Manager Change Calendar</a>.</p>
    #[serde(rename = "CalendarNames")]
    #[serde(default)]
    pub calendar_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The combination of AWS Regions and AWS accounts where you wanted to run the association when
    /// this association version was created.</p>
    #[serde(rename = "TargetLocations")]
    #[serde(default)]
    pub target_locations: std::option::Option<std::vec::Vec<crate::model::TargetLocation>>,
}
impl std::fmt::Debug for AssociationVersionInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociationVersionInfo");
        formatter.field("association_id", &self.association_id);
        formatter.field("association_version", &self.association_version);
        formatter.field("created_date", &self.created_date);
        formatter.field("name", &self.name);
        formatter.field("document_version", &self.document_version);
        formatter.field("parameters", &self.parameters);
        formatter.field("targets", &self.targets);
        formatter.field("schedule_expression", &self.schedule_expression);
        formatter.field("output_location", &self.output_location);
        formatter.field("association_name", &self.association_name);
        formatter.field("max_errors", &self.max_errors);
        formatter.field("max_concurrency", &self.max_concurrency);
        formatter.field("compliance_severity", &self.compliance_severity);
        formatter.field("sync_compliance", &self.sync_compliance);
        formatter.field(
            "apply_only_at_cron_interval",
            &self.apply_only_at_cron_interval,
        );
        formatter.field("calendar_names", &self.calendar_names);
        formatter.field("target_locations", &self.target_locations);
        formatter.finish()
    }
}
/// See [`AssociationVersionInfo`](crate::model::AssociationVersionInfo)
pub mod association_version_info {
    /// A builder for [`AssociationVersionInfo`](crate::model::AssociationVersionInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) association_version: std::option::Option<std::string::String>,
        pub(crate) created_date: std::option::Option<smithy_types::Instant>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) document_version: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) targets: std::option::Option<std::vec::Vec<crate::model::Target>>,
        pub(crate) schedule_expression: std::option::Option<std::string::String>,
        pub(crate) output_location:
            std::option::Option<crate::model::InstanceAssociationOutputLocation>,
        pub(crate) association_name: std::option::Option<std::string::String>,
        pub(crate) max_errors: std::option::Option<std::string::String>,
        pub(crate) max_concurrency: std::option::Option<std::string::String>,
        pub(crate) compliance_severity:
            std::option::Option<crate::model::AssociationComplianceSeverity>,
        pub(crate) sync_compliance: std::option::Option<crate::model::AssociationSyncCompliance>,
        pub(crate) apply_only_at_cron_interval: std::option::Option<bool>,
        pub(crate) calendar_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) target_locations:
            std::option::Option<std::vec::Vec<crate::model::TargetLocation>>,
    }
    impl Builder {
        /// <p>The ID created by the system when the association was created.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>The association version.</p>
        pub fn association_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_version = Some(input.into());
            self
        }
        pub fn set_association_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_version = input;
            self
        }
        /// <p>The date the association version was created.</p>
        pub fn created_date(mut self, input: smithy_types::Instant) -> Self {
            self.created_date = Some(input);
            self
        }
        pub fn set_created_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.created_date = input;
            self
        }
        /// <p>The name specified when the association was created.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The version of a Systems Manager document used when the association version was created.</p>
        pub fn document_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_version = Some(input.into());
            self
        }
        pub fn set_document_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_version = input;
            self
        }
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        pub fn targets(mut self, input: impl Into<crate::model::Target>) -> Self {
            let mut v = self.targets.unwrap_or_default();
            v.push(input.into());
            self.targets = Some(v);
            self
        }
        pub fn set_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Target>>,
        ) -> Self {
            self.targets = input;
            self
        }
        /// <p>The cron or rate schedule specified for the association when the association version was
        /// created.</p>
        pub fn schedule_expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.schedule_expression = Some(input.into());
            self
        }
        pub fn set_schedule_expression(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.schedule_expression = input;
            self
        }
        /// <p>The location in Amazon S3 specified for the association when the association version was
        /// created.</p>
        pub fn output_location(
            mut self,
            input: crate::model::InstanceAssociationOutputLocation,
        ) -> Self {
            self.output_location = Some(input);
            self
        }
        pub fn set_output_location(
            mut self,
            input: std::option::Option<crate::model::InstanceAssociationOutputLocation>,
        ) -> Self {
            self.output_location = input;
            self
        }
        /// <p>The name specified for the association version when the association version was
        /// created.</p>
        pub fn association_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_name = Some(input.into());
            self
        }
        pub fn set_association_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_name = input;
            self
        }
        /// <p>The number of errors that are allowed before the system stops sending requests to run the
        /// association on additional targets. You can specify either an absolute number of errors, for
        /// example 10, or a percentage of the target set, for example 10%. If you specify 3, for example,
        /// the system stops sending requests when the fourth error is received. If you specify 0, then the
        /// system stops sending requests after the first error is returned. If you run an association on 50
        /// instances and set MaxError to 10%, then the system stops sending the request when the sixth error
        /// is received.</p>
        /// <p>Executions that are already running an association when MaxErrors is reached are allowed to
        /// complete, but some of these executions may fail as well. If you need to ensure that there won't
        /// be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one
        /// at a time.</p>
        pub fn max_errors(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_errors = Some(input.into());
            self
        }
        pub fn set_max_errors(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_errors = input;
            self
        }
        /// <p>The maximum number of targets allowed to run the association at the same time. You can
        /// specify a number, for example 10, or a percentage of the target set, for example 10%. The default
        /// value is 100%, which means all targets run the association at the same time.</p>
        /// <p>If a new instance starts and attempts to run an association while Systems Manager is running
        /// MaxConcurrency associations, the association is allowed to run. During the next association
        /// interval, the new instance will process its association within the limit specified for
        /// MaxConcurrency.</p>
        pub fn max_concurrency(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_concurrency = Some(input.into());
            self
        }
        pub fn set_max_concurrency(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.max_concurrency = input;
            self
        }
        /// <p>The severity level that is assigned to the association.</p>
        pub fn compliance_severity(
            mut self,
            input: crate::model::AssociationComplianceSeverity,
        ) -> Self {
            self.compliance_severity = Some(input);
            self
        }
        pub fn set_compliance_severity(
            mut self,
            input: std::option::Option<crate::model::AssociationComplianceSeverity>,
        ) -> Self {
            self.compliance_severity = input;
            self
        }
        /// <p>The mode for generating association compliance. You can specify <code>AUTO</code> or
        /// <code>MANUAL</code>. In <code>AUTO</code> mode, the system uses the status of the association
        /// execution to determine the compliance status. If the association execution runs successfully,
        /// then the association is <code>COMPLIANT</code>. If the association execution doesn't run
        /// successfully, the association is <code>NON-COMPLIANT</code>.</p>
        /// <p>In <code>MANUAL</code> mode, you must specify the <code>AssociationId</code> as a parameter
        /// for the <a>PutComplianceItems</a> API action. In this case, compliance data is not
        /// managed by State Manager. It is managed by your direct call to the <a>PutComplianceItems</a> API action.</p>
        /// <p>By default, all associations use <code>AUTO</code> mode.</p>
        pub fn sync_compliance(mut self, input: crate::model::AssociationSyncCompliance) -> Self {
            self.sync_compliance = Some(input);
            self
        }
        pub fn set_sync_compliance(
            mut self,
            input: std::option::Option<crate::model::AssociationSyncCompliance>,
        ) -> Self {
            self.sync_compliance = input;
            self
        }
        /// <p>By default, when you create a new associations, the system runs it immediately after it is
        /// created and then according to the schedule you specified. Specify this option if you don't want
        /// an association to run immediately after you create it. This parameter is not supported for rate
        /// expressions.</p>
        pub fn apply_only_at_cron_interval(mut self, input: bool) -> Self {
            self.apply_only_at_cron_interval = Some(input);
            self
        }
        pub fn set_apply_only_at_cron_interval(mut self, input: std::option::Option<bool>) -> Self {
            self.apply_only_at_cron_interval = input;
            self
        }
        pub fn calendar_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.calendar_names.unwrap_or_default();
            v.push(input.into());
            self.calendar_names = Some(v);
            self
        }
        pub fn set_calendar_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.calendar_names = input;
            self
        }
        pub fn target_locations(mut self, input: impl Into<crate::model::TargetLocation>) -> Self {
            let mut v = self.target_locations.unwrap_or_default();
            v.push(input.into());
            self.target_locations = Some(v);
            self
        }
        pub fn set_target_locations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TargetLocation>>,
        ) -> Self {
            self.target_locations = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociationVersionInfo`](crate::model::AssociationVersionInfo)
        pub fn build(self) -> crate::model::AssociationVersionInfo {
            crate::model::AssociationVersionInfo {
                association_id: self.association_id,
                association_version: self.association_version,
                created_date: self.created_date,
                name: self.name,
                document_version: self.document_version,
                parameters: self.parameters,
                targets: self.targets,
                schedule_expression: self.schedule_expression,
                output_location: self.output_location,
                association_name: self.association_name,
                max_errors: self.max_errors,
                max_concurrency: self.max_concurrency,
                compliance_severity: self.compliance_severity,
                sync_compliance: self.sync_compliance,
                apply_only_at_cron_interval: self.apply_only_at_cron_interval.unwrap_or_default(),
                calendar_names: self.calendar_names,
                target_locations: self.target_locations,
            }
        }
    }
}
impl AssociationVersionInfo {
    /// Creates a new builder-style object to manufacture [`AssociationVersionInfo`](crate::model::AssociationVersionInfo)
    pub fn builder() -> crate::model::association_version_info::Builder {
        crate::model::association_version_info::Builder::default()
    }
}

/// <p>Describes an association of a Systems Manager document and an instance.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct Association {
    /// <p>The name of the Systems Manager document.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The ID of the instance.</p>
    #[serde(rename = "InstanceId")]
    #[serde(default)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The ID created by the system when you create an association. An association is a binding
    /// between a document and a set of targets with a schedule.</p>
    #[serde(rename = "AssociationId")]
    #[serde(default)]
    pub association_id: std::option::Option<std::string::String>,
    /// <p>The association version.</p>
    #[serde(rename = "AssociationVersion")]
    #[serde(default)]
    pub association_version: std::option::Option<std::string::String>,
    /// <p>The version of the document used in the association.</p>
    #[serde(rename = "DocumentVersion")]
    #[serde(default)]
    pub document_version: std::option::Option<std::string::String>,
    /// <p>The instances targeted by the request to create an association. </p>
    #[serde(rename = "Targets")]
    #[serde(default)]
    pub targets: std::option::Option<std::vec::Vec<crate::model::Target>>,
    /// <p>The date on which the association was last run.</p>
    #[serde(rename = "LastExecutionDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_execution_date: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the association.</p>
    #[serde(rename = "Overview")]
    #[serde(default)]
    pub overview: std::option::Option<crate::model::AssociationOverview>,
    /// <p>A cron expression that specifies a schedule when the association runs. The schedule runs in
    /// Coordinated Universal Time (UTC).</p>
    #[serde(rename = "ScheduleExpression")]
    #[serde(default)]
    pub schedule_expression: std::option::Option<std::string::String>,
    /// <p>The association name.</p>
    #[serde(rename = "AssociationName")]
    #[serde(default)]
    pub association_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Association {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Association");
        formatter.field("name", &self.name);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("association_id", &self.association_id);
        formatter.field("association_version", &self.association_version);
        formatter.field("document_version", &self.document_version);
        formatter.field("targets", &self.targets);
        formatter.field("last_execution_date", &self.last_execution_date);
        formatter.field("overview", &self.overview);
        formatter.field("schedule_expression", &self.schedule_expression);
        formatter.field("association_name", &self.association_name);
        formatter.finish()
    }
}
/// See [`Association`](crate::model::Association)
pub mod association {
    /// A builder for [`Association`](crate::model::Association)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) association_version: std::option::Option<std::string::String>,
        pub(crate) document_version: std::option::Option<std::string::String>,
        pub(crate) targets: std::option::Option<std::vec::Vec<crate::model::Target>>,
        pub(crate) last_execution_date: std::option::Option<smithy_types::Instant>,
        pub(crate) overview: std::option::Option<crate::model::AssociationOverview>,
        pub(crate) schedule_expression: std::option::Option<std::string::String>,
        pub(crate) association_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Systems Manager document.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The ID created by the system when you create an association. An association is a binding
        /// between a document and a set of targets with a schedule.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>The association version.</p>
        pub fn association_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_version = Some(input.into());
            self
        }
        pub fn set_association_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_version = input;
            self
        }
        /// <p>The version of the document used in the association.</p>
        pub fn document_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_version = Some(input.into());
            self
        }
        pub fn set_document_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_version = input;
            self
        }
        pub fn targets(mut self, input: impl Into<crate::model::Target>) -> Self {
            let mut v = self.targets.unwrap_or_default();
            v.push(input.into());
            self.targets = Some(v);
            self
        }
        pub fn set_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Target>>,
        ) -> Self {
            self.targets = input;
            self
        }
        /// <p>The date on which the association was last run.</p>
        pub fn last_execution_date(mut self, input: smithy_types::Instant) -> Self {
            self.last_execution_date = Some(input);
            self
        }
        pub fn set_last_execution_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_execution_date = input;
            self
        }
        /// <p>Information about the association.</p>
        pub fn overview(mut self, input: crate::model::AssociationOverview) -> Self {
            self.overview = Some(input);
            self
        }
        pub fn set_overview(
            mut self,
            input: std::option::Option<crate::model::AssociationOverview>,
        ) -> Self {
            self.overview = input;
            self
        }
        /// <p>A cron expression that specifies a schedule when the association runs. The schedule runs in
        /// Coordinated Universal Time (UTC).</p>
        pub fn schedule_expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.schedule_expression = Some(input.into());
            self
        }
        pub fn set_schedule_expression(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.schedule_expression = input;
            self
        }
        /// <p>The association name.</p>
        pub fn association_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_name = Some(input.into());
            self
        }
        pub fn set_association_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_name = input;
            self
        }
        /// Consumes the builder and constructs a [`Association`](crate::model::Association)
        pub fn build(self) -> crate::model::Association {
            crate::model::Association {
                name: self.name,
                instance_id: self.instance_id,
                association_id: self.association_id,
                association_version: self.association_version,
                document_version: self.document_version,
                targets: self.targets,
                last_execution_date: self.last_execution_date,
                overview: self.overview,
                schedule_expression: self.schedule_expression,
                association_name: self.association_name,
            }
        }
    }
}
impl Association {
    /// Creates a new builder-style object to manufacture [`Association`](crate::model::Association)
    pub fn builder() -> crate::model::association::Builder {
        crate::model::association::Builder::default()
    }
}

/// <p>Describes a filter.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociationFilter {
    /// <p>The name of the filter.</p>
    /// <note>
    /// <p>
    /// <code>InstanceId</code> has been deprecated.</p>
    /// </note>
    #[serde(rename = "key")]
    #[serde(default)]
    pub key: std::option::Option<crate::model::AssociationFilterKey>,
    /// <p>The filter value.</p>
    #[serde(rename = "value")]
    #[serde(default)]
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AssociationFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociationFilter");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`AssociationFilter`](crate::model::AssociationFilter)
pub mod association_filter {
    /// A builder for [`AssociationFilter`](crate::model::AssociationFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<crate::model::AssociationFilterKey>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the filter.</p>
        /// <note>
        /// <p>
        /// <code>InstanceId</code> has been deprecated.</p>
        /// </note>
        pub fn key(mut self, input: crate::model::AssociationFilterKey) -> Self {
            self.key = Some(input);
            self
        }
        pub fn set_key(
            mut self,
            input: std::option::Option<crate::model::AssociationFilterKey>,
        ) -> Self {
            self.key = input;
            self
        }
        /// <p>The filter value.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociationFilter`](crate::model::AssociationFilter)
        pub fn build(self) -> crate::model::AssociationFilter {
            crate::model::AssociationFilter {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl AssociationFilter {
    /// Creates a new builder-style object to manufacture [`AssociationFilter`](crate::model::AssociationFilter)
    pub fn builder() -> crate::model::association_filter::Builder {
        crate::model::association_filter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssociationFilterKey {
    AssociationId,
    AssociationName,
    Status,
    InstanceId,
    LastExecutedAfter,
    LastExecutedBefore,
    Name,
    ResourceGroupName,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AssociationFilterKey {
    fn from(s: &str) -> Self {
        match s {
            "AssociationId" => AssociationFilterKey::AssociationId,
            "AssociationName" => AssociationFilterKey::AssociationName,
            "AssociationStatusName" => AssociationFilterKey::Status,
            "InstanceId" => AssociationFilterKey::InstanceId,
            "LastExecutedAfter" => AssociationFilterKey::LastExecutedAfter,
            "LastExecutedBefore" => AssociationFilterKey::LastExecutedBefore,
            "Name" => AssociationFilterKey::Name,
            "ResourceGroupName" => AssociationFilterKey::ResourceGroupName,
            other => AssociationFilterKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AssociationFilterKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(AssociationFilterKey::from(s))
    }
}
impl AssociationFilterKey {
    pub fn as_str(&self) -> &str {
        match self {
            AssociationFilterKey::AssociationId => "AssociationId",
            AssociationFilterKey::AssociationName => "AssociationName",
            AssociationFilterKey::Status => "AssociationStatusName",
            AssociationFilterKey::InstanceId => "InstanceId",
            AssociationFilterKey::LastExecutedAfter => "LastExecutedAfter",
            AssociationFilterKey::LastExecutedBefore => "LastExecutedBefore",
            AssociationFilterKey::Name => "Name",
            AssociationFilterKey::ResourceGroupName => "ResourceGroupName",
            AssociationFilterKey::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for AssociationFilterKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for AssociationFilterKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>An Systems Manager parameter in Parameter Store.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct Parameter {
    /// <p>The name of the parameter.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of parameter. Valid values include the following: <code>String</code>,
    /// <code>StringList</code>, and <code>SecureString</code>.</p>
    #[serde(rename = "Type")]
    #[serde(default)]
    pub r#type: std::option::Option<crate::model::ParameterType>,
    /// <p>The parameter value.</p>
    #[serde(rename = "Value")]
    #[serde(default)]
    pub value: std::option::Option<std::string::String>,
    /// <p>The parameter version.</p>
    #[serde(rename = "Version")]
    #[serde(default)]
    pub version: i64,
    /// <p>Either the version number or the label used to retrieve the parameter value. Specify
    /// selectors by using one of the following formats:</p>
    /// <p>parameter_name:version</p>
    /// <p>parameter_name:label</p>
    #[serde(rename = "Selector")]
    #[serde(default)]
    pub selector: std::option::Option<std::string::String>,
    /// <p>Applies to parameters that reference information in other AWS services. SourceResult is the
    /// raw result or response from the source.</p>
    #[serde(rename = "SourceResult")]
    #[serde(default)]
    pub source_result: std::option::Option<std::string::String>,
    /// <p>Date the parameter was last changed or updated and the parameter version was created.</p>
    #[serde(rename = "LastModifiedDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_date: std::option::Option<smithy_types::Instant>,
    /// <p>The Amazon Resource Name (ARN) of the parameter.</p>
    #[serde(rename = "ARN")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The data type of the parameter, such as <code>text</code> or <code>aws:ec2:image</code>. The
    /// default is <code>text</code>.</p>
    #[serde(rename = "DataType")]
    #[serde(default)]
    pub data_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Parameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Parameter");
        formatter.field("name", &self.name);
        formatter.field("r#type", &self.r#type);
        formatter.field("value", &self.value);
        formatter.field("version", &self.version);
        formatter.field("selector", &self.selector);
        formatter.field("source_result", &self.source_result);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("arn", &self.arn);
        formatter.field("data_type", &self.data_type);
        formatter.finish()
    }
}
/// See [`Parameter`](crate::model::Parameter)
pub mod parameter {
    /// A builder for [`Parameter`](crate::model::Parameter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ParameterType>,
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<i64>,
        pub(crate) selector: std::option::Option<std::string::String>,
        pub(crate) source_result: std::option::Option<std::string::String>,
        pub(crate) last_modified_date: std::option::Option<smithy_types::Instant>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) data_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the parameter.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of parameter. Valid values include the following: <code>String</code>,
        /// <code>StringList</code>, and <code>SecureString</code>.</p>
        pub fn r#type(mut self, input: crate::model::ParameterType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::ParameterType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The parameter value.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>The parameter version.</p>
        pub fn version(mut self, input: i64) -> Self {
            self.version = Some(input);
            self
        }
        pub fn set_version(mut self, input: std::option::Option<i64>) -> Self {
            self.version = input;
            self
        }
        /// <p>Either the version number or the label used to retrieve the parameter value. Specify
        /// selectors by using one of the following formats:</p>
        /// <p>parameter_name:version</p>
        /// <p>parameter_name:label</p>
        pub fn selector(mut self, input: impl Into<std::string::String>) -> Self {
            self.selector = Some(input.into());
            self
        }
        pub fn set_selector(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.selector = input;
            self
        }
        /// <p>Applies to parameters that reference information in other AWS services. SourceResult is the
        /// raw result or response from the source.</p>
        pub fn source_result(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_result = Some(input.into());
            self
        }
        pub fn set_source_result(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_result = input;
            self
        }
        /// <p>Date the parameter was last changed or updated and the parameter version was created.</p>
        pub fn last_modified_date(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_date = Some(input);
            self
        }
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the parameter.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The data type of the parameter, such as <code>text</code> or <code>aws:ec2:image</code>. The
        /// default is <code>text</code>.</p>
        pub fn data_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_type = Some(input.into());
            self
        }
        pub fn set_data_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_type = input;
            self
        }
        /// Consumes the builder and constructs a [`Parameter`](crate::model::Parameter)
        pub fn build(self) -> crate::model::Parameter {
            crate::model::Parameter {
                name: self.name,
                r#type: self.r#type,
                value: self.value,
                version: self.version.unwrap_or_default(),
                selector: self.selector,
                source_result: self.source_result,
                last_modified_date: self.last_modified_date,
                arn: self.arn,
                data_type: self.data_type,
            }
        }
    }
}
impl Parameter {
    /// Creates a new builder-style object to manufacture [`Parameter`](crate::model::Parameter)
    pub fn builder() -> crate::model::parameter::Builder {
        crate::model::parameter::Builder::default()
    }
}

/// <p>One or more filters. Use a filter to return a more specific list of results.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ParameterStringFilter {
    /// <p>The name of the filter.</p>
    /// <note>
    /// <p>The <code>ParameterStringFilter</code> object is used by the <a>DescribeParameters</a> and <a>GetParametersByPath</a> API actions. However,
    /// not all of the pattern values listed for <code>Key</code> can be used with both actions.</p>
    /// <p>For <code>DescribeActions</code>, all of the listed patterns are valid, with the exception
    /// of <code>Label</code>.</p>
    /// <p>For <code>GetParametersByPath</code>, the following patterns listed for <code>Key</code>
    /// are not valid: <code>tag</code>, <code>Name</code>, <code>Path</code>, and
    /// <code>Tier</code>.</p>
    /// <p>For examples of CLI commands demonstrating valid parameter filter constructions, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-search.html">Searching for
    /// Systems Manager parameters</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    /// </note>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<std::string::String>,
    /// <p>For all filters used with <a>DescribeParameters</a>, valid options include
    /// <code>Equals</code> and <code>BeginsWith</code>. The <code>Name</code> filter additionally
    /// supports the <code>Contains</code> option. (Exception: For filters using the key
    /// <code>Path</code>, valid options include <code>Recursive</code> and
    /// <code>OneLevel</code>.)</p>
    /// <p>For filters used with <a>GetParametersByPath</a>, valid options include
    /// <code>Equals</code> and <code>BeginsWith</code>. (Exception: For filters using
    /// <code>Label</code> as the Key name, the only valid option is <code>Equals</code>.)</p>
    #[serde(rename = "Option")]
    #[serde(default)]
    pub option: std::option::Option<std::string::String>,
    /// <p>The value you want to search for.</p>
    #[serde(rename = "Values")]
    #[serde(default)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for ParameterStringFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParameterStringFilter");
        formatter.field("key", &self.key);
        formatter.field("option", &self.option);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`ParameterStringFilter`](crate::model::ParameterStringFilter)
pub mod parameter_string_filter {
    /// A builder for [`ParameterStringFilter`](crate::model::ParameterStringFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) option: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the filter.</p>
        /// <note>
        /// <p>The <code>ParameterStringFilter</code> object is used by the <a>DescribeParameters</a> and <a>GetParametersByPath</a> API actions. However,
        /// not all of the pattern values listed for <code>Key</code> can be used with both actions.</p>
        /// <p>For <code>DescribeActions</code>, all of the listed patterns are valid, with the exception
        /// of <code>Label</code>.</p>
        /// <p>For <code>GetParametersByPath</code>, the following patterns listed for <code>Key</code>
        /// are not valid: <code>tag</code>, <code>Name</code>, <code>Path</code>, and
        /// <code>Tier</code>.</p>
        /// <p>For examples of CLI commands demonstrating valid parameter filter constructions, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-search.html">Searching for
        /// Systems Manager parameters</a> in the <i>AWS Systems Manager User Guide</i>.</p>
        /// </note>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>For all filters used with <a>DescribeParameters</a>, valid options include
        /// <code>Equals</code> and <code>BeginsWith</code>. The <code>Name</code> filter additionally
        /// supports the <code>Contains</code> option. (Exception: For filters using the key
        /// <code>Path</code>, valid options include <code>Recursive</code> and
        /// <code>OneLevel</code>.)</p>
        /// <p>For filters used with <a>GetParametersByPath</a>, valid options include
        /// <code>Equals</code> and <code>BeginsWith</code>. (Exception: For filters using
        /// <code>Label</code> as the Key name, the only valid option is <code>Equals</code>.)</p>
        pub fn option(mut self, input: impl Into<std::string::String>) -> Self {
            self.option = Some(input.into());
            self
        }
        pub fn set_option(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.option = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterStringFilter`](crate::model::ParameterStringFilter)
        pub fn build(self) -> crate::model::ParameterStringFilter {
            crate::model::ParameterStringFilter {
                key: self.key,
                option: self.option,
                values: self.values,
            }
        }
    }
}
impl ParameterStringFilter {
    /// Creates a new builder-style object to manufacture [`ParameterStringFilter`](crate::model::ParameterStringFilter)
    pub fn builder() -> crate::model::parameter_string_filter::Builder {
        crate::model::parameter_string_filter::Builder::default()
    }
}

/// <p>Information about parameter usage.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ParameterHistory {
    /// <p>The name of the parameter.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of parameter used.</p>
    #[serde(rename = "Type")]
    #[serde(default)]
    pub r#type: std::option::Option<crate::model::ParameterType>,
    /// <p>The ID of the query key used for this parameter.</p>
    #[serde(rename = "KeyId")]
    #[serde(default)]
    pub key_id: std::option::Option<std::string::String>,
    /// <p>Date the parameter was last changed or updated.</p>
    #[serde(rename = "LastModifiedDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_date: std::option::Option<smithy_types::Instant>,
    /// <p>Amazon Resource Name (ARN) of the AWS user who last changed the parameter.</p>
    #[serde(rename = "LastModifiedUser")]
    #[serde(default)]
    pub last_modified_user: std::option::Option<std::string::String>,
    /// <p>Information about the parameter.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The parameter value.</p>
    #[serde(rename = "Value")]
    #[serde(default)]
    pub value: std::option::Option<std::string::String>,
    /// <p>Parameter names can include the following letters and symbols.</p>
    /// <p>a-zA-Z0-9_.-</p>
    #[serde(rename = "AllowedPattern")]
    #[serde(default)]
    pub allowed_pattern: std::option::Option<std::string::String>,
    /// <p>The parameter version.</p>
    #[serde(rename = "Version")]
    #[serde(default)]
    pub version: i64,
    /// <p>Labels assigned to the parameter version.</p>
    #[serde(rename = "Labels")]
    #[serde(default)]
    pub labels: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The parameter tier.</p>
    #[serde(rename = "Tier")]
    #[serde(default)]
    pub tier: std::option::Option<crate::model::ParameterTier>,
    /// <p>Information about the policies assigned to a parameter.</p>
    /// <p>
    /// <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-policies.html">Assigning parameter
    /// policies</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    #[serde(rename = "Policies")]
    #[serde(default)]
    pub policies: std::option::Option<std::vec::Vec<crate::model::ParameterInlinePolicy>>,
    /// <p>The data type of the parameter, such as <code>text</code> or <code>aws:ec2:image</code>. The
    /// default is <code>text</code>.</p>
    #[serde(rename = "DataType")]
    #[serde(default)]
    pub data_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ParameterHistory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParameterHistory");
        formatter.field("name", &self.name);
        formatter.field("r#type", &self.r#type);
        formatter.field("key_id", &self.key_id);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("last_modified_user", &self.last_modified_user);
        formatter.field("description", &self.description);
        formatter.field("value", &self.value);
        formatter.field("allowed_pattern", &self.allowed_pattern);
        formatter.field("version", &self.version);
        formatter.field("labels", &self.labels);
        formatter.field("tier", &self.tier);
        formatter.field("policies", &self.policies);
        formatter.field("data_type", &self.data_type);
        formatter.finish()
    }
}
/// See [`ParameterHistory`](crate::model::ParameterHistory)
pub mod parameter_history {
    /// A builder for [`ParameterHistory`](crate::model::ParameterHistory)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ParameterType>,
        pub(crate) key_id: std::option::Option<std::string::String>,
        pub(crate) last_modified_date: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_user: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) allowed_pattern: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<i64>,
        pub(crate) labels: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) tier: std::option::Option<crate::model::ParameterTier>,
        pub(crate) policies:
            std::option::Option<std::vec::Vec<crate::model::ParameterInlinePolicy>>,
        pub(crate) data_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the parameter.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of parameter used.</p>
        pub fn r#type(mut self, input: crate::model::ParameterType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::ParameterType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The ID of the query key used for this parameter.</p>
        pub fn key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_id = Some(input.into());
            self
        }
        pub fn set_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_id = input;
            self
        }
        /// <p>Date the parameter was last changed or updated.</p>
        pub fn last_modified_date(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_date = Some(input);
            self
        }
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>Amazon Resource Name (ARN) of the AWS user who last changed the parameter.</p>
        pub fn last_modified_user(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_user = Some(input.into());
            self
        }
        pub fn set_last_modified_user(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_user = input;
            self
        }
        /// <p>Information about the parameter.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The parameter value.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>Parameter names can include the following letters and symbols.</p>
        /// <p>a-zA-Z0-9_.-</p>
        pub fn allowed_pattern(mut self, input: impl Into<std::string::String>) -> Self {
            self.allowed_pattern = Some(input.into());
            self
        }
        pub fn set_allowed_pattern(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.allowed_pattern = input;
            self
        }
        /// <p>The parameter version.</p>
        pub fn version(mut self, input: i64) -> Self {
            self.version = Some(input);
            self
        }
        pub fn set_version(mut self, input: std::option::Option<i64>) -> Self {
            self.version = input;
            self
        }
        pub fn labels(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.labels.unwrap_or_default();
            v.push(input.into());
            self.labels = Some(v);
            self
        }
        pub fn set_labels(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.labels = input;
            self
        }
        /// <p>The parameter tier.</p>
        pub fn tier(mut self, input: crate::model::ParameterTier) -> Self {
            self.tier = Some(input);
            self
        }
        pub fn set_tier(mut self, input: std::option::Option<crate::model::ParameterTier>) -> Self {
            self.tier = input;
            self
        }
        pub fn policies(mut self, input: impl Into<crate::model::ParameterInlinePolicy>) -> Self {
            let mut v = self.policies.unwrap_or_default();
            v.push(input.into());
            self.policies = Some(v);
            self
        }
        pub fn set_policies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ParameterInlinePolicy>>,
        ) -> Self {
            self.policies = input;
            self
        }
        /// <p>The data type of the parameter, such as <code>text</code> or <code>aws:ec2:image</code>. The
        /// default is <code>text</code>.</p>
        pub fn data_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_type = Some(input.into());
            self
        }
        pub fn set_data_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterHistory`](crate::model::ParameterHistory)
        pub fn build(self) -> crate::model::ParameterHistory {
            crate::model::ParameterHistory {
                name: self.name,
                r#type: self.r#type,
                key_id: self.key_id,
                last_modified_date: self.last_modified_date,
                last_modified_user: self.last_modified_user,
                description: self.description,
                value: self.value,
                allowed_pattern: self.allowed_pattern,
                version: self.version.unwrap_or_default(),
                labels: self.labels,
                tier: self.tier,
                policies: self.policies,
                data_type: self.data_type,
            }
        }
    }
}
impl ParameterHistory {
    /// Creates a new builder-style object to manufacture [`ParameterHistory`](crate::model::ParameterHistory)
    pub fn builder() -> crate::model::parameter_history::Builder {
        crate::model::parameter_history::Builder::default()
    }
}

/// <p>One or more policies assigned to a parameter.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ParameterInlinePolicy {
    /// <p>The JSON text of the policy.</p>
    #[serde(rename = "PolicyText")]
    #[serde(default)]
    pub policy_text: std::option::Option<std::string::String>,
    /// <p>The type of policy. Parameter Store supports the following policy types: Expiration,
    /// ExpirationNotification, and NoChangeNotification. </p>
    #[serde(rename = "PolicyType")]
    #[serde(default)]
    pub policy_type: std::option::Option<std::string::String>,
    /// <p>The status of the policy. Policies report the following statuses: Pending (the policy has
    /// not been enforced or applied yet), Finished (the policy was applied), Failed (the policy was not
    /// applied), or InProgress (the policy is being applied now). </p>
    #[serde(rename = "PolicyStatus")]
    #[serde(default)]
    pub policy_status: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ParameterInlinePolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParameterInlinePolicy");
        formatter.field("policy_text", &self.policy_text);
        formatter.field("policy_type", &self.policy_type);
        formatter.field("policy_status", &self.policy_status);
        formatter.finish()
    }
}
/// See [`ParameterInlinePolicy`](crate::model::ParameterInlinePolicy)
pub mod parameter_inline_policy {
    /// A builder for [`ParameterInlinePolicy`](crate::model::ParameterInlinePolicy)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_text: std::option::Option<std::string::String>,
        pub(crate) policy_type: std::option::Option<std::string::String>,
        pub(crate) policy_status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The JSON text of the policy.</p>
        pub fn policy_text(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_text = Some(input.into());
            self
        }
        pub fn set_policy_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_text = input;
            self
        }
        /// <p>The type of policy. Parameter Store supports the following policy types: Expiration,
        /// ExpirationNotification, and NoChangeNotification. </p>
        pub fn policy_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_type = Some(input.into());
            self
        }
        pub fn set_policy_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_type = input;
            self
        }
        /// <p>The status of the policy. Policies report the following statuses: Pending (the policy has
        /// not been enforced or applied yet), Finished (the policy was applied), Failed (the policy was not
        /// applied), or InProgress (the policy is being applied now). </p>
        pub fn policy_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_status = Some(input.into());
            self
        }
        pub fn set_policy_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_status = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterInlinePolicy`](crate::model::ParameterInlinePolicy)
        pub fn build(self) -> crate::model::ParameterInlinePolicy {
            crate::model::ParameterInlinePolicy {
                policy_text: self.policy_text,
                policy_type: self.policy_type,
                policy_status: self.policy_status,
            }
        }
    }
}
impl ParameterInlinePolicy {
    /// Creates a new builder-style object to manufacture [`ParameterInlinePolicy`](crate::model::ParameterInlinePolicy)
    pub fn builder() -> crate::model::parameter_inline_policy::Builder {
        crate::model::parameter_inline_policy::Builder::default()
    }
}

/// <p>The result of the query.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsEntity {
    /// <p>The query ID.</p>
    #[serde(rename = "Id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The data returned by the query.</p>
    #[serde(rename = "Data")]
    #[serde(default)]
    pub data: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::OpsEntityItem>,
    >,
}
impl std::fmt::Debug for OpsEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsEntity");
        formatter.field("id", &self.id);
        formatter.field("data", &self.data);
        formatter.finish()
    }
}
/// See [`OpsEntity`](crate::model::OpsEntity)
pub mod ops_entity {
    /// A builder for [`OpsEntity`](crate::model::OpsEntity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) data: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::OpsEntityItem>,
        >,
    }
    impl Builder {
        /// <p>The query ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        pub fn data(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::OpsEntityItem>,
        ) -> Self {
            let mut hash_map = self.data.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.data = Some(hash_map);
            self
        }
        pub fn set_data(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::OpsEntityItem>,
            >,
        ) -> Self {
            self.data = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsEntity`](crate::model::OpsEntity)
        pub fn build(self) -> crate::model::OpsEntity {
            crate::model::OpsEntity {
                id: self.id,
                data: self.data,
            }
        }
    }
}
impl OpsEntity {
    /// Creates a new builder-style object to manufacture [`OpsEntity`](crate::model::OpsEntity)
    pub fn builder() -> crate::model::ops_entity::Builder {
        crate::model::ops_entity::Builder::default()
    }
}

/// <p>The OpsItem summaries result item.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsEntityItem {
    /// <p>The time OpsItem data was captured.</p>
    #[serde(rename = "CaptureTime")]
    #[serde(default)]
    pub capture_time: std::option::Option<std::string::String>,
    /// <p>The detailed data content for an OpsItem summaries result item.</p>
    #[serde(rename = "Content")]
    #[serde(default)]
    pub content: std::option::Option<
        std::vec::Vec<std::collections::HashMap<std::string::String, std::string::String>>,
    >,
}
impl std::fmt::Debug for OpsEntityItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsEntityItem");
        formatter.field("capture_time", &self.capture_time);
        formatter.field("content", &self.content);
        formatter.finish()
    }
}
/// See [`OpsEntityItem`](crate::model::OpsEntityItem)
pub mod ops_entity_item {
    /// A builder for [`OpsEntityItem`](crate::model::OpsEntityItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) capture_time: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<
            std::vec::Vec<std::collections::HashMap<std::string::String, std::string::String>>,
        >,
    }
    impl Builder {
        /// <p>The time OpsItem data was captured.</p>
        pub fn capture_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.capture_time = Some(input.into());
            self
        }
        pub fn set_capture_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.capture_time = input;
            self
        }
        pub fn content(
            mut self,
            input: impl Into<std::collections::HashMap<std::string::String, std::string::String>>,
        ) -> Self {
            let mut v = self.content.unwrap_or_default();
            v.push(input.into());
            self.content = Some(v);
            self
        }
        pub fn set_content(
            mut self,
            input: std::option::Option<
                std::vec::Vec<std::collections::HashMap<std::string::String, std::string::String>>,
            >,
        ) -> Self {
            self.content = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsEntityItem`](crate::model::OpsEntityItem)
        pub fn build(self) -> crate::model::OpsEntityItem {
            crate::model::OpsEntityItem {
                capture_time: self.capture_time,
                content: self.content,
            }
        }
    }
}
impl OpsEntityItem {
    /// Creates a new builder-style object to manufacture [`OpsEntityItem`](crate::model::OpsEntityItem)
    pub fn builder() -> crate::model::ops_entity_item::Builder {
        crate::model::ops_entity_item::Builder::default()
    }
}

/// <p>The OpsItem data type to return.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsResultAttribute {
    /// <p>Name of the data type. Valid value: AWS:OpsItem, AWS:EC2InstanceInformation,
    /// AWS:OpsItemTrendline, or AWS:ComplianceSummary.</p>
    #[serde(rename = "TypeName")]
    #[serde(default)]
    pub type_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OpsResultAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsResultAttribute");
        formatter.field("type_name", &self.type_name);
        formatter.finish()
    }
}
/// See [`OpsResultAttribute`](crate::model::OpsResultAttribute)
pub mod ops_result_attribute {
    /// A builder for [`OpsResultAttribute`](crate::model::OpsResultAttribute)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) type_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Name of the data type. Valid value: AWS:OpsItem, AWS:EC2InstanceInformation,
        /// AWS:OpsItemTrendline, or AWS:ComplianceSummary.</p>
        pub fn type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.type_name = Some(input.into());
            self
        }
        pub fn set_type_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.type_name = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsResultAttribute`](crate::model::OpsResultAttribute)
        pub fn build(self) -> crate::model::OpsResultAttribute {
            crate::model::OpsResultAttribute {
                type_name: self.type_name,
            }
        }
    }
}
impl OpsResultAttribute {
    /// Creates a new builder-style object to manufacture [`OpsResultAttribute`](crate::model::OpsResultAttribute)
    pub fn builder() -> crate::model::ops_result_attribute::Builder {
        crate::model::ops_result_attribute::Builder::default()
    }
}

/// <p>One or more aggregators for viewing counts of OpsItems using different dimensions such as
/// <code>Source</code>, <code>CreatedTime</code>, or <code>Source and CreatedTime</code>, to name a
/// few.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsAggregator {
    /// <p>Either a Range or Count aggregator for limiting an OpsItem summary.</p>
    #[serde(rename = "AggregatorType")]
    #[serde(default)]
    pub aggregator_type: std::option::Option<std::string::String>,
    /// <p>The data type name to use for viewing counts of OpsItems.</p>
    #[serde(rename = "TypeName")]
    #[serde(default)]
    pub type_name: std::option::Option<std::string::String>,
    /// <p>The name of an OpsItem attribute on which to limit the count of OpsItems.</p>
    #[serde(rename = "AttributeName")]
    #[serde(default)]
    pub attribute_name: std::option::Option<std::string::String>,
    /// <p>The aggregator value.</p>
    #[serde(rename = "Values")]
    #[serde(default)]
    pub values:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The aggregator filters.</p>
    #[serde(rename = "Filters")]
    #[serde(default)]
    pub filters: std::option::Option<std::vec::Vec<crate::model::OpsFilter>>,
    /// <p>A nested aggregator for viewing counts of OpsItems.</p>
    #[serde(rename = "Aggregators")]
    #[serde(default)]
    pub aggregators: std::option::Option<std::vec::Vec<crate::model::OpsAggregator>>,
}
impl std::fmt::Debug for OpsAggregator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsAggregator");
        formatter.field("aggregator_type", &self.aggregator_type);
        formatter.field("type_name", &self.type_name);
        formatter.field("attribute_name", &self.attribute_name);
        formatter.field("values", &self.values);
        formatter.field("filters", &self.filters);
        formatter.field("aggregators", &self.aggregators);
        formatter.finish()
    }
}
/// See [`OpsAggregator`](crate::model::OpsAggregator)
pub mod ops_aggregator {
    /// A builder for [`OpsAggregator`](crate::model::OpsAggregator)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) aggregator_type: std::option::Option<std::string::String>,
        pub(crate) type_name: std::option::Option<std::string::String>,
        pub(crate) attribute_name: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) filters: std::option::Option<std::vec::Vec<crate::model::OpsFilter>>,
        pub(crate) aggregators: std::option::Option<std::vec::Vec<crate::model::OpsAggregator>>,
    }
    impl Builder {
        /// <p>Either a Range or Count aggregator for limiting an OpsItem summary.</p>
        pub fn aggregator_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.aggregator_type = Some(input.into());
            self
        }
        pub fn set_aggregator_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.aggregator_type = input;
            self
        }
        /// <p>The data type name to use for viewing counts of OpsItems.</p>
        pub fn type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.type_name = Some(input.into());
            self
        }
        pub fn set_type_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.type_name = input;
            self
        }
        /// <p>The name of an OpsItem attribute on which to limit the count of OpsItems.</p>
        pub fn attribute_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.attribute_name = Some(input.into());
            self
        }
        pub fn set_attribute_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attribute_name = input;
            self
        }
        pub fn values(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.values.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.values = Some(hash_map);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.values = input;
            self
        }
        pub fn filters(mut self, input: impl Into<crate::model::OpsFilter>) -> Self {
            let mut v = self.filters.unwrap_or_default();
            v.push(input.into());
            self.filters = Some(v);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::OpsFilter>>,
        ) -> Self {
            self.filters = input;
            self
        }
        pub fn aggregators(mut self, input: impl Into<crate::model::OpsAggregator>) -> Self {
            let mut v = self.aggregators.unwrap_or_default();
            v.push(input.into());
            self.aggregators = Some(v);
            self
        }
        pub fn set_aggregators(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::OpsAggregator>>,
        ) -> Self {
            self.aggregators = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsAggregator`](crate::model::OpsAggregator)
        pub fn build(self) -> crate::model::OpsAggregator {
            crate::model::OpsAggregator {
                aggregator_type: self.aggregator_type,
                type_name: self.type_name,
                attribute_name: self.attribute_name,
                values: self.values,
                filters: self.filters,
                aggregators: self.aggregators,
            }
        }
    }
}
impl OpsAggregator {
    /// Creates a new builder-style object to manufacture [`OpsAggregator`](crate::model::OpsAggregator)
    pub fn builder() -> crate::model::ops_aggregator::Builder {
        crate::model::ops_aggregator::Builder::default()
    }
}

/// <p>A filter for viewing OpsItem summaries.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsFilter {
    /// <p>The name of the filter.</p>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The filter value.</p>
    #[serde(rename = "Values")]
    #[serde(default)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The type of filter.</p>
    #[serde(rename = "Type")]
    #[serde(default)]
    pub r#type: std::option::Option<crate::model::OpsFilterOperatorType>,
}
impl std::fmt::Debug for OpsFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsFilter");
        formatter.field("key", &self.key);
        formatter.field("values", &self.values);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`OpsFilter`](crate::model::OpsFilter)
pub mod ops_filter {
    /// A builder for [`OpsFilter`](crate::model::OpsFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) r#type: std::option::Option<crate::model::OpsFilterOperatorType>,
    }
    impl Builder {
        /// <p>The name of the filter.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// <p>The type of filter.</p>
        pub fn r#type(mut self, input: crate::model::OpsFilterOperatorType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::OpsFilterOperatorType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsFilter`](crate::model::OpsFilter)
        pub fn build(self) -> crate::model::OpsFilter {
            crate::model::OpsFilter {
                key: self.key,
                values: self.values,
                r#type: self.r#type,
            }
        }
    }
}
impl OpsFilter {
    /// Creates a new builder-style object to manufacture [`OpsFilter`](crate::model::OpsFilter)
    pub fn builder() -> crate::model::ops_filter::Builder {
        crate::model::ops_filter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OpsFilterOperatorType {
    BeginWith,
    Equal,
    Exists,
    GreaterThan,
    LessThan,
    NotEqual,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OpsFilterOperatorType {
    fn from(s: &str) -> Self {
        match s {
            "BeginWith" => OpsFilterOperatorType::BeginWith,
            "Equal" => OpsFilterOperatorType::Equal,
            "Exists" => OpsFilterOperatorType::Exists,
            "GreaterThan" => OpsFilterOperatorType::GreaterThan,
            "LessThan" => OpsFilterOperatorType::LessThan,
            "NotEqual" => OpsFilterOperatorType::NotEqual,
            other => OpsFilterOperatorType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OpsFilterOperatorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(OpsFilterOperatorType::from(s))
    }
}
impl OpsFilterOperatorType {
    pub fn as_str(&self) -> &str {
        match self {
            OpsFilterOperatorType::BeginWith => "BeginWith",
            OpsFilterOperatorType::Equal => "Equal",
            OpsFilterOperatorType::Exists => "Exists",
            OpsFilterOperatorType::GreaterThan => "GreaterThan",
            OpsFilterOperatorType::LessThan => "LessThan",
            OpsFilterOperatorType::NotEqual => "NotEqual",
            OpsFilterOperatorType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for OpsFilterOperatorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for OpsFilterOperatorType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Operations engineers and IT professionals use OpsCenter to view, investigate, and remediate
/// operational issues impacting the performance and health of their AWS resources. For more
/// information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter.html">AWS Systems Manager OpsCenter</a> in the
/// <i>AWS Systems Manager User Guide</i>. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsItem {
    /// <p>The ARN of the AWS account that created the OpsItem.</p>
    #[serde(rename = "CreatedBy")]
    #[serde(default)]
    pub created_by: std::option::Option<std::string::String>,
    /// <p>The type of OpsItem. Currently, the only valid values are <code>/aws/changerequest</code>
    /// and <code>/aws/issue</code>.</p>
    #[serde(rename = "OpsItemType")]
    #[serde(default)]
    pub ops_item_type: std::option::Option<std::string::String>,
    /// <p>The date and time the OpsItem was created.</p>
    #[serde(rename = "CreatedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub created_time: std::option::Option<smithy_types::Instant>,
    /// <p>The OpsItem description.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The ARN of the AWS account that last updated the OpsItem.</p>
    #[serde(rename = "LastModifiedBy")]
    #[serde(default)]
    pub last_modified_by: std::option::Option<std::string::String>,
    /// <p>The date and time the OpsItem was last updated.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The Amazon Resource Name (ARN) of an SNS topic where notifications are sent when this
    /// OpsItem is edited or changed.</p>
    #[serde(rename = "Notifications")]
    #[serde(default)]
    pub notifications: std::option::Option<std::vec::Vec<crate::model::OpsItemNotification>>,
    /// <p>The importance of this OpsItem in relation to other OpsItems in the system.</p>
    #[serde(rename = "Priority")]
    #[serde(default)]
    pub priority: std::option::Option<i32>,
    /// <p>One or more OpsItems that share something in common with the current OpsItem. For example,
    /// related OpsItems can include OpsItems with similar error messages, impacted resources, or
    /// statuses for the impacted resource.</p>
    #[serde(rename = "RelatedOpsItems")]
    #[serde(default)]
    pub related_ops_items: std::option::Option<std::vec::Vec<crate::model::RelatedOpsItem>>,
    /// <p>The OpsItem status. Status can be <code>Open</code>, <code>In Progress</code>, or
    /// <code>Resolved</code>. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-working-with-OpsItems-editing-details.html">Editing OpsItem details</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::OpsItemStatus>,
    /// <p>The ID of the OpsItem.</p>
    #[serde(rename = "OpsItemId")]
    #[serde(default)]
    pub ops_item_id: std::option::Option<std::string::String>,
    /// <p>The version of this OpsItem. Each time the OpsItem is edited the version number increments
    /// by one.</p>
    #[serde(rename = "Version")]
    #[serde(default)]
    pub version: std::option::Option<std::string::String>,
    /// <p>A short heading that describes the nature of the OpsItem and the impacted resource.</p>
    #[serde(rename = "Title")]
    #[serde(default)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The origin of the OpsItem, such as Amazon EC2 or Systems Manager. The impacted resource is a subset of
    /// source.</p>
    #[serde(rename = "Source")]
    #[serde(default)]
    pub source: std::option::Option<std::string::String>,
    /// <p>Operational data is custom data that provides useful reference details about the OpsItem.
    /// For example, you can specify log files, error strings, license keys, troubleshooting tips, or
    /// other relevant data. You enter operational data as key-value pairs. The key has a maximum length
    /// of 128 characters. The value has a maximum size of 20 KB.</p>
    /// <important>
    /// <p>Operational data keys <i>can't</i> begin with the following: amazon, aws,
    /// amzn, ssm, /amazon, /aws, /amzn, /ssm.</p>
    /// </important>
    /// <p>You can choose to make the data searchable by other users in the account or you can restrict
    /// search access. Searchable data means that all users with access to the OpsItem Overview page (as
    /// provided by the <a>DescribeOpsItems</a> API action) can view and search on the
    /// specified data. Operational data that is not searchable is only viewable by users who have access
    /// to the OpsItem (as provided by the <a>GetOpsItem</a> API action).</p>
    /// <p>Use the <code>/aws/resources</code> key in OperationalData to specify a related resource in
    /// the request. Use the <code>/aws/automations</code> key in OperationalData to associate an
    /// Automation runbook with the OpsItem. To view AWS CLI example commands that use these keys, see
    /// <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-creating-OpsItems.html#OpsCenter-manually-create-OpsItems">Creating OpsItems manually</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    #[serde(rename = "OperationalData")]
    #[serde(default)]
    pub operational_data: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::OpsItemDataValue>,
    >,
    /// <p>An OpsItem category. Category options include: Availability, Cost, Performance, Recovery,
    /// Security.</p>
    #[serde(rename = "Category")]
    #[serde(default)]
    pub category: std::option::Option<std::string::String>,
    /// <p>The severity of the OpsItem. Severity options range from 1 to 4.</p>
    #[serde(rename = "Severity")]
    #[serde(default)]
    pub severity: std::option::Option<std::string::String>,
    /// <p>The time a runbook workflow started. Currently reported only for the OpsItem type
    /// <code>/aws/changerequest</code>.</p>
    #[serde(rename = "ActualStartTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub actual_start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time a runbook workflow ended. Currently reported only for the OpsItem type
    /// <code>/aws/changerequest</code>.</p>
    #[serde(rename = "ActualEndTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub actual_end_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time specified in a change request for a runbook workflow to start. Currently supported
    /// only for the OpsItem type <code>/aws/changerequest</code>.</p>
    #[serde(rename = "PlannedStartTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub planned_start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time specified in a change request for a runbook workflow to end. Currently supported
    /// only for the OpsItem type <code>/aws/changerequest</code>.</p>
    #[serde(rename = "PlannedEndTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub planned_end_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for OpsItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsItem");
        formatter.field("created_by", &self.created_by);
        formatter.field("ops_item_type", &self.ops_item_type);
        formatter.field("created_time", &self.created_time);
        formatter.field("description", &self.description);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("notifications", &self.notifications);
        formatter.field("priority", &self.priority);
        formatter.field("related_ops_items", &self.related_ops_items);
        formatter.field("status", &self.status);
        formatter.field("ops_item_id", &self.ops_item_id);
        formatter.field("version", &self.version);
        formatter.field("title", &self.title);
        formatter.field("source", &self.source);
        formatter.field("operational_data", &self.operational_data);
        formatter.field("category", &self.category);
        formatter.field("severity", &self.severity);
        formatter.field("actual_start_time", &self.actual_start_time);
        formatter.field("actual_end_time", &self.actual_end_time);
        formatter.field("planned_start_time", &self.planned_start_time);
        formatter.field("planned_end_time", &self.planned_end_time);
        formatter.finish()
    }
}
/// See [`OpsItem`](crate::model::OpsItem)
pub mod ops_item {
    /// A builder for [`OpsItem`](crate::model::OpsItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) ops_item_type: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<smithy_types::Instant>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) last_modified_by: std::option::Option<std::string::String>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) notifications:
            std::option::Option<std::vec::Vec<crate::model::OpsItemNotification>>,
        pub(crate) priority: std::option::Option<i32>,
        pub(crate) related_ops_items:
            std::option::Option<std::vec::Vec<crate::model::RelatedOpsItem>>,
        pub(crate) status: std::option::Option<crate::model::OpsItemStatus>,
        pub(crate) ops_item_id: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) source: std::option::Option<std::string::String>,
        pub(crate) operational_data: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::OpsItemDataValue>,
        >,
        pub(crate) category: std::option::Option<std::string::String>,
        pub(crate) severity: std::option::Option<std::string::String>,
        pub(crate) actual_start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) actual_end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) planned_start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) planned_end_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The ARN of the AWS account that created the OpsItem.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>The type of OpsItem. Currently, the only valid values are <code>/aws/changerequest</code>
        /// and <code>/aws/issue</code>.</p>
        pub fn ops_item_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.ops_item_type = Some(input.into());
            self
        }
        pub fn set_ops_item_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ops_item_type = input;
            self
        }
        /// <p>The date and time the OpsItem was created.</p>
        pub fn created_time(mut self, input: smithy_types::Instant) -> Self {
            self.created_time = Some(input);
            self
        }
        pub fn set_created_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The OpsItem description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The ARN of the AWS account that last updated the OpsItem.</p>
        pub fn last_modified_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_by = Some(input.into());
            self
        }
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// <p>The date and time the OpsItem was last updated.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        pub fn notifications(
            mut self,
            input: impl Into<crate::model::OpsItemNotification>,
        ) -> Self {
            let mut v = self.notifications.unwrap_or_default();
            v.push(input.into());
            self.notifications = Some(v);
            self
        }
        pub fn set_notifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::OpsItemNotification>>,
        ) -> Self {
            self.notifications = input;
            self
        }
        /// <p>The importance of this OpsItem in relation to other OpsItems in the system.</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input;
            self
        }
        pub fn related_ops_items(mut self, input: impl Into<crate::model::RelatedOpsItem>) -> Self {
            let mut v = self.related_ops_items.unwrap_or_default();
            v.push(input.into());
            self.related_ops_items = Some(v);
            self
        }
        pub fn set_related_ops_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RelatedOpsItem>>,
        ) -> Self {
            self.related_ops_items = input;
            self
        }
        /// <p>The OpsItem status. Status can be <code>Open</code>, <code>In Progress</code>, or
        /// <code>Resolved</code>. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-working-with-OpsItems-editing-details.html">Editing OpsItem details</a> in the <i>AWS Systems Manager User Guide</i>.</p>
        pub fn status(mut self, input: crate::model::OpsItemStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OpsItemStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The ID of the OpsItem.</p>
        pub fn ops_item_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ops_item_id = Some(input.into());
            self
        }
        pub fn set_ops_item_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ops_item_id = input;
            self
        }
        /// <p>The version of this OpsItem. Each time the OpsItem is edited the version number increments
        /// by one.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// <p>A short heading that describes the nature of the OpsItem and the impacted resource.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The origin of the OpsItem, such as Amazon EC2 or Systems Manager. The impacted resource is a subset of
        /// source.</p>
        pub fn source(mut self, input: impl Into<std::string::String>) -> Self {
            self.source = Some(input.into());
            self
        }
        pub fn set_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source = input;
            self
        }
        pub fn operational_data(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::OpsItemDataValue>,
        ) -> Self {
            let mut hash_map = self.operational_data.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.operational_data = Some(hash_map);
            self
        }
        pub fn set_operational_data(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::OpsItemDataValue>,
            >,
        ) -> Self {
            self.operational_data = input;
            self
        }
        /// <p>An OpsItem category. Category options include: Availability, Cost, Performance, Recovery,
        /// Security.</p>
        pub fn category(mut self, input: impl Into<std::string::String>) -> Self {
            self.category = Some(input.into());
            self
        }
        pub fn set_category(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.category = input;
            self
        }
        /// <p>The severity of the OpsItem. Severity options range from 1 to 4.</p>
        pub fn severity(mut self, input: impl Into<std::string::String>) -> Self {
            self.severity = Some(input.into());
            self
        }
        pub fn set_severity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.severity = input;
            self
        }
        /// <p>The time a runbook workflow started. Currently reported only for the OpsItem type
        /// <code>/aws/changerequest</code>.</p>
        pub fn actual_start_time(mut self, input: smithy_types::Instant) -> Self {
            self.actual_start_time = Some(input);
            self
        }
        pub fn set_actual_start_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.actual_start_time = input;
            self
        }
        /// <p>The time a runbook workflow ended. Currently reported only for the OpsItem type
        /// <code>/aws/changerequest</code>.</p>
        pub fn actual_end_time(mut self, input: smithy_types::Instant) -> Self {
            self.actual_end_time = Some(input);
            self
        }
        pub fn set_actual_end_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.actual_end_time = input;
            self
        }
        /// <p>The time specified in a change request for a runbook workflow to start. Currently supported
        /// only for the OpsItem type <code>/aws/changerequest</code>.</p>
        pub fn planned_start_time(mut self, input: smithy_types::Instant) -> Self {
            self.planned_start_time = Some(input);
            self
        }
        pub fn set_planned_start_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.planned_start_time = input;
            self
        }
        /// <p>The time specified in a change request for a runbook workflow to end. Currently supported
        /// only for the OpsItem type <code>/aws/changerequest</code>.</p>
        pub fn planned_end_time(mut self, input: smithy_types::Instant) -> Self {
            self.planned_end_time = Some(input);
            self
        }
        pub fn set_planned_end_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.planned_end_time = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsItem`](crate::model::OpsItem)
        pub fn build(self) -> crate::model::OpsItem {
            crate::model::OpsItem {
                created_by: self.created_by,
                ops_item_type: self.ops_item_type,
                created_time: self.created_time,
                description: self.description,
                last_modified_by: self.last_modified_by,
                last_modified_time: self.last_modified_time,
                notifications: self.notifications,
                priority: self.priority,
                related_ops_items: self.related_ops_items,
                status: self.status,
                ops_item_id: self.ops_item_id,
                version: self.version,
                title: self.title,
                source: self.source,
                operational_data: self.operational_data,
                category: self.category,
                severity: self.severity,
                actual_start_time: self.actual_start_time,
                actual_end_time: self.actual_end_time,
                planned_start_time: self.planned_start_time,
                planned_end_time: self.planned_end_time,
            }
        }
    }
}
impl OpsItem {
    /// Creates a new builder-style object to manufacture [`OpsItem`](crate::model::OpsItem)
    pub fn builder() -> crate::model::ops_item::Builder {
        crate::model::ops_item::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MaintenanceWindowExecutionStatus {
    Cancelled,
    Cancelling,
    Failed,
    InProgress,
    Pending,
    SkippedOverlapping,
    Success,
    TimedOut,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MaintenanceWindowExecutionStatus {
    fn from(s: &str) -> Self {
        match s {
            "CANCELLED" => MaintenanceWindowExecutionStatus::Cancelled,
            "CANCELLING" => MaintenanceWindowExecutionStatus::Cancelling,
            "FAILED" => MaintenanceWindowExecutionStatus::Failed,
            "IN_PROGRESS" => MaintenanceWindowExecutionStatus::InProgress,
            "PENDING" => MaintenanceWindowExecutionStatus::Pending,
            "SKIPPED_OVERLAPPING" => MaintenanceWindowExecutionStatus::SkippedOverlapping,
            "SUCCESS" => MaintenanceWindowExecutionStatus::Success,
            "TIMED_OUT" => MaintenanceWindowExecutionStatus::TimedOut,
            other => MaintenanceWindowExecutionStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MaintenanceWindowExecutionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(MaintenanceWindowExecutionStatus::from(s))
    }
}
impl MaintenanceWindowExecutionStatus {
    pub fn as_str(&self) -> &str {
        match self {
            MaintenanceWindowExecutionStatus::Cancelled => "CANCELLED",
            MaintenanceWindowExecutionStatus::Cancelling => "CANCELLING",
            MaintenanceWindowExecutionStatus::Failed => "FAILED",
            MaintenanceWindowExecutionStatus::InProgress => "IN_PROGRESS",
            MaintenanceWindowExecutionStatus::Pending => "PENDING",
            MaintenanceWindowExecutionStatus::SkippedOverlapping => "SKIPPED_OVERLAPPING",
            MaintenanceWindowExecutionStatus::Success => "SUCCESS",
            MaintenanceWindowExecutionStatus::TimedOut => "TIMED_OUT",
            MaintenanceWindowExecutionStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for MaintenanceWindowExecutionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for MaintenanceWindowExecutionStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>The inventory item schema definition. Users can use this to compose inventory query
/// filters.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InventoryItemSchema {
    /// <p>The name of the inventory type. Default inventory item type names start with AWS. Custom
    /// inventory type names will start with Custom. Default inventory item types include the following:
    /// AWS:AWSComponent, AWS:Application, AWS:InstanceInformation, AWS:Network, and
    /// AWS:WindowsUpdate.</p>
    #[serde(rename = "TypeName")]
    #[serde(default)]
    pub type_name: std::option::Option<std::string::String>,
    /// <p>The schema version for the inventory item.</p>
    #[serde(rename = "Version")]
    #[serde(default)]
    pub version: std::option::Option<std::string::String>,
    /// <p>The schema attributes for inventory. This contains data type and attribute name.</p>
    #[serde(rename = "Attributes")]
    #[serde(default)]
    pub attributes: std::option::Option<std::vec::Vec<crate::model::InventoryItemAttribute>>,
    /// <p>The alias name of the inventory type. The alias name is used for display purposes.</p>
    #[serde(rename = "DisplayName")]
    #[serde(default)]
    pub display_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InventoryItemSchema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InventoryItemSchema");
        formatter.field("type_name", &self.type_name);
        formatter.field("version", &self.version);
        formatter.field("attributes", &self.attributes);
        formatter.field("display_name", &self.display_name);
        formatter.finish()
    }
}
/// See [`InventoryItemSchema`](crate::model::InventoryItemSchema)
pub mod inventory_item_schema {
    /// A builder for [`InventoryItemSchema`](crate::model::InventoryItemSchema)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) type_name: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
        pub(crate) attributes:
            std::option::Option<std::vec::Vec<crate::model::InventoryItemAttribute>>,
        pub(crate) display_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the inventory type. Default inventory item type names start with AWS. Custom
        /// inventory type names will start with Custom. Default inventory item types include the following:
        /// AWS:AWSComponent, AWS:Application, AWS:InstanceInformation, AWS:Network, and
        /// AWS:WindowsUpdate.</p>
        pub fn type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.type_name = Some(input.into());
            self
        }
        pub fn set_type_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.type_name = input;
            self
        }
        /// <p>The schema version for the inventory item.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        pub fn attributes(
            mut self,
            input: impl Into<crate::model::InventoryItemAttribute>,
        ) -> Self {
            let mut v = self.attributes.unwrap_or_default();
            v.push(input.into());
            self.attributes = Some(v);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InventoryItemAttribute>>,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// <p>The alias name of the inventory type. The alias name is used for display purposes.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// Consumes the builder and constructs a [`InventoryItemSchema`](crate::model::InventoryItemSchema)
        pub fn build(self) -> crate::model::InventoryItemSchema {
            crate::model::InventoryItemSchema {
                type_name: self.type_name,
                version: self.version,
                attributes: self.attributes,
                display_name: self.display_name,
            }
        }
    }
}
impl InventoryItemSchema {
    /// Creates a new builder-style object to manufacture [`InventoryItemSchema`](crate::model::InventoryItemSchema)
    pub fn builder() -> crate::model::inventory_item_schema::Builder {
        crate::model::inventory_item_schema::Builder::default()
    }
}

/// <p>Attributes are the entries within the inventory item content. It contains name and
/// value.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InventoryItemAttribute {
    /// <p>Name of the inventory item attribute.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data type of the inventory item attribute. </p>
    #[serde(rename = "DataType")]
    #[serde(default)]
    pub data_type: std::option::Option<crate::model::InventoryAttributeDataType>,
}
impl std::fmt::Debug for InventoryItemAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InventoryItemAttribute");
        formatter.field("name", &self.name);
        formatter.field("data_type", &self.data_type);
        formatter.finish()
    }
}
/// See [`InventoryItemAttribute`](crate::model::InventoryItemAttribute)
pub mod inventory_item_attribute {
    /// A builder for [`InventoryItemAttribute`](crate::model::InventoryItemAttribute)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) data_type: std::option::Option<crate::model::InventoryAttributeDataType>,
    }
    impl Builder {
        /// <p>Name of the inventory item attribute.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The data type of the inventory item attribute. </p>
        pub fn data_type(mut self, input: crate::model::InventoryAttributeDataType) -> Self {
            self.data_type = Some(input);
            self
        }
        pub fn set_data_type(
            mut self,
            input: std::option::Option<crate::model::InventoryAttributeDataType>,
        ) -> Self {
            self.data_type = input;
            self
        }
        /// Consumes the builder and constructs a [`InventoryItemAttribute`](crate::model::InventoryItemAttribute)
        pub fn build(self) -> crate::model::InventoryItemAttribute {
            crate::model::InventoryItemAttribute {
                name: self.name,
                data_type: self.data_type,
            }
        }
    }
}
impl InventoryItemAttribute {
    /// Creates a new builder-style object to manufacture [`InventoryItemAttribute`](crate::model::InventoryItemAttribute)
    pub fn builder() -> crate::model::inventory_item_attribute::Builder {
        crate::model::inventory_item_attribute::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InventoryAttributeDataType {
    Number,
    String,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InventoryAttributeDataType {
    fn from(s: &str) -> Self {
        match s {
            "number" => InventoryAttributeDataType::Number,
            "string" => InventoryAttributeDataType::String,
            other => InventoryAttributeDataType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InventoryAttributeDataType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(InventoryAttributeDataType::from(s))
    }
}
impl InventoryAttributeDataType {
    pub fn as_str(&self) -> &str {
        match self {
            InventoryAttributeDataType::Number => "number",
            InventoryAttributeDataType::String => "string",
            InventoryAttributeDataType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for InventoryAttributeDataType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for InventoryAttributeDataType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Inventory query results.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InventoryResultEntity {
    /// <p>ID of the inventory result entity. For example, for managed instance inventory the result
    /// will be the managed instance ID. For EC2 instance inventory, the result will be the instance ID.
    /// </p>
    #[serde(rename = "Id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The data section in the inventory result entity JSON.</p>
    #[serde(rename = "Data")]
    #[serde(default)]
    pub data: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::InventoryResultItem>,
    >,
}
impl std::fmt::Debug for InventoryResultEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InventoryResultEntity");
        formatter.field("id", &self.id);
        formatter.field("data", &self.data);
        formatter.finish()
    }
}
/// See [`InventoryResultEntity`](crate::model::InventoryResultEntity)
pub mod inventory_result_entity {
    /// A builder for [`InventoryResultEntity`](crate::model::InventoryResultEntity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) data: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::InventoryResultItem>,
        >,
    }
    impl Builder {
        /// <p>ID of the inventory result entity. For example, for managed instance inventory the result
        /// will be the managed instance ID. For EC2 instance inventory, the result will be the instance ID.
        /// </p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        pub fn data(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::InventoryResultItem>,
        ) -> Self {
            let mut hash_map = self.data.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.data = Some(hash_map);
            self
        }
        pub fn set_data(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::InventoryResultItem>,
            >,
        ) -> Self {
            self.data = input;
            self
        }
        /// Consumes the builder and constructs a [`InventoryResultEntity`](crate::model::InventoryResultEntity)
        pub fn build(self) -> crate::model::InventoryResultEntity {
            crate::model::InventoryResultEntity {
                id: self.id,
                data: self.data,
            }
        }
    }
}
impl InventoryResultEntity {
    /// Creates a new builder-style object to manufacture [`InventoryResultEntity`](crate::model::InventoryResultEntity)
    pub fn builder() -> crate::model::inventory_result_entity::Builder {
        crate::model::inventory_result_entity::Builder::default()
    }
}

/// <p>The inventory result item.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InventoryResultItem {
    /// <p>The name of the inventory result item type.</p>
    #[serde(rename = "TypeName")]
    #[serde(default)]
    pub type_name: std::option::Option<std::string::String>,
    /// <p>The schema version for the inventory result item/</p>
    #[serde(rename = "SchemaVersion")]
    #[serde(default)]
    pub schema_version: std::option::Option<std::string::String>,
    /// <p>The time inventory item data was captured.</p>
    #[serde(rename = "CaptureTime")]
    #[serde(default)]
    pub capture_time: std::option::Option<std::string::String>,
    /// <p>MD5 hash of the inventory item type contents. The content hash is used to determine whether
    /// to update inventory information. The PutInventory API does not update the inventory item type
    /// contents if the MD5 hash has not changed since last update. </p>
    #[serde(rename = "ContentHash")]
    #[serde(default)]
    pub content_hash: std::option::Option<std::string::String>,
    /// <p>Contains all the inventory data of the item type. Results include attribute names and
    /// values. </p>
    #[serde(rename = "Content")]
    #[serde(default)]
    pub content: std::option::Option<
        std::vec::Vec<std::collections::HashMap<std::string::String, std::string::String>>,
    >,
}
impl std::fmt::Debug for InventoryResultItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InventoryResultItem");
        formatter.field("type_name", &self.type_name);
        formatter.field("schema_version", &self.schema_version);
        formatter.field("capture_time", &self.capture_time);
        formatter.field("content_hash", &self.content_hash);
        formatter.field("content", &self.content);
        formatter.finish()
    }
}
/// See [`InventoryResultItem`](crate::model::InventoryResultItem)
pub mod inventory_result_item {
    /// A builder for [`InventoryResultItem`](crate::model::InventoryResultItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) type_name: std::option::Option<std::string::String>,
        pub(crate) schema_version: std::option::Option<std::string::String>,
        pub(crate) capture_time: std::option::Option<std::string::String>,
        pub(crate) content_hash: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<
            std::vec::Vec<std::collections::HashMap<std::string::String, std::string::String>>,
        >,
    }
    impl Builder {
        /// <p>The name of the inventory result item type.</p>
        pub fn type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.type_name = Some(input.into());
            self
        }
        pub fn set_type_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.type_name = input;
            self
        }
        /// <p>The schema version for the inventory result item/</p>
        pub fn schema_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.schema_version = Some(input.into());
            self
        }
        pub fn set_schema_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.schema_version = input;
            self
        }
        /// <p>The time inventory item data was captured.</p>
        pub fn capture_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.capture_time = Some(input.into());
            self
        }
        pub fn set_capture_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.capture_time = input;
            self
        }
        /// <p>MD5 hash of the inventory item type contents. The content hash is used to determine whether
        /// to update inventory information. The PutInventory API does not update the inventory item type
        /// contents if the MD5 hash has not changed since last update. </p>
        pub fn content_hash(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_hash = Some(input.into());
            self
        }
        pub fn set_content_hash(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_hash = input;
            self
        }
        pub fn content(
            mut self,
            input: impl Into<std::collections::HashMap<std::string::String, std::string::String>>,
        ) -> Self {
            let mut v = self.content.unwrap_or_default();
            v.push(input.into());
            self.content = Some(v);
            self
        }
        pub fn set_content(
            mut self,
            input: std::option::Option<
                std::vec::Vec<std::collections::HashMap<std::string::String, std::string::String>>,
            >,
        ) -> Self {
            self.content = input;
            self
        }
        /// Consumes the builder and constructs a [`InventoryResultItem`](crate::model::InventoryResultItem)
        pub fn build(self) -> crate::model::InventoryResultItem {
            crate::model::InventoryResultItem {
                type_name: self.type_name,
                schema_version: self.schema_version,
                capture_time: self.capture_time,
                content_hash: self.content_hash,
                content: self.content,
            }
        }
    }
}
impl InventoryResultItem {
    /// Creates a new builder-style object to manufacture [`InventoryResultItem`](crate::model::InventoryResultItem)
    pub fn builder() -> crate::model::inventory_result_item::Builder {
        crate::model::inventory_result_item::Builder::default()
    }
}

/// <p>The inventory item result attribute.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResultAttribute {
    /// <p>Name of the inventory item type. Valid value: AWS:InstanceInformation. Default Value:
    /// AWS:InstanceInformation.</p>
    #[serde(rename = "TypeName")]
    #[serde(default)]
    pub type_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResultAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResultAttribute");
        formatter.field("type_name", &self.type_name);
        formatter.finish()
    }
}
/// See [`ResultAttribute`](crate::model::ResultAttribute)
pub mod result_attribute {
    /// A builder for [`ResultAttribute`](crate::model::ResultAttribute)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) type_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Name of the inventory item type. Valid value: AWS:InstanceInformation. Default Value:
        /// AWS:InstanceInformation.</p>
        pub fn type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.type_name = Some(input.into());
            self
        }
        pub fn set_type_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.type_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ResultAttribute`](crate::model::ResultAttribute)
        pub fn build(self) -> crate::model::ResultAttribute {
            crate::model::ResultAttribute {
                type_name: self.type_name,
            }
        }
    }
}
impl ResultAttribute {
    /// Creates a new builder-style object to manufacture [`ResultAttribute`](crate::model::ResultAttribute)
    pub fn builder() -> crate::model::result_attribute::Builder {
        crate::model::result_attribute::Builder::default()
    }
}

/// <p>Specifies the inventory type and attribute for the aggregation execution.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InventoryAggregator {
    /// <p>The inventory type and attribute name for aggregation.</p>
    #[serde(rename = "Expression")]
    #[serde(default)]
    pub expression: std::option::Option<std::string::String>,
    /// <p>Nested aggregators to further refine aggregation for an inventory type.</p>
    #[serde(rename = "Aggregators")]
    #[serde(default)]
    pub aggregators: std::option::Option<std::vec::Vec<crate::model::InventoryAggregator>>,
    /// <p>A user-defined set of one or more filters on which to aggregate inventory data. Groups
    /// return a count of resources that match and don't match the specified criteria.</p>
    #[serde(rename = "Groups")]
    #[serde(default)]
    pub groups: std::option::Option<std::vec::Vec<crate::model::InventoryGroup>>,
}
impl std::fmt::Debug for InventoryAggregator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InventoryAggregator");
        formatter.field("expression", &self.expression);
        formatter.field("aggregators", &self.aggregators);
        formatter.field("groups", &self.groups);
        formatter.finish()
    }
}
/// See [`InventoryAggregator`](crate::model::InventoryAggregator)
pub mod inventory_aggregator {
    /// A builder for [`InventoryAggregator`](crate::model::InventoryAggregator)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) expression: std::option::Option<std::string::String>,
        pub(crate) aggregators:
            std::option::Option<std::vec::Vec<crate::model::InventoryAggregator>>,
        pub(crate) groups: std::option::Option<std::vec::Vec<crate::model::InventoryGroup>>,
    }
    impl Builder {
        /// <p>The inventory type and attribute name for aggregation.</p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.expression = Some(input.into());
            self
        }
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.expression = input;
            self
        }
        pub fn aggregators(mut self, input: impl Into<crate::model::InventoryAggregator>) -> Self {
            let mut v = self.aggregators.unwrap_or_default();
            v.push(input.into());
            self.aggregators = Some(v);
            self
        }
        pub fn set_aggregators(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InventoryAggregator>>,
        ) -> Self {
            self.aggregators = input;
            self
        }
        pub fn groups(mut self, input: impl Into<crate::model::InventoryGroup>) -> Self {
            let mut v = self.groups.unwrap_or_default();
            v.push(input.into());
            self.groups = Some(v);
            self
        }
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InventoryGroup>>,
        ) -> Self {
            self.groups = input;
            self
        }
        /// Consumes the builder and constructs a [`InventoryAggregator`](crate::model::InventoryAggregator)
        pub fn build(self) -> crate::model::InventoryAggregator {
            crate::model::InventoryAggregator {
                expression: self.expression,
                aggregators: self.aggregators,
                groups: self.groups,
            }
        }
    }
}
impl InventoryAggregator {
    /// Creates a new builder-style object to manufacture [`InventoryAggregator`](crate::model::InventoryAggregator)
    pub fn builder() -> crate::model::inventory_aggregator::Builder {
        crate::model::inventory_aggregator::Builder::default()
    }
}

/// <p>A user-defined set of one or more filters on which to aggregate inventory data. Groups
/// return a count of resources that match and don't match the specified criteria.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InventoryGroup {
    /// <p>The name of the group.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Filters define the criteria for the group. The <code>matchingCount</code> field displays the
    /// number of resources that match the criteria. The <code>notMatchingCount</code> field displays the
    /// number of resources that don't match the criteria. </p>
    #[serde(rename = "Filters")]
    #[serde(default)]
    pub filters: std::option::Option<std::vec::Vec<crate::model::InventoryFilter>>,
}
impl std::fmt::Debug for InventoryGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InventoryGroup");
        formatter.field("name", &self.name);
        formatter.field("filters", &self.filters);
        formatter.finish()
    }
}
/// See [`InventoryGroup`](crate::model::InventoryGroup)
pub mod inventory_group {
    /// A builder for [`InventoryGroup`](crate::model::InventoryGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) filters: std::option::Option<std::vec::Vec<crate::model::InventoryFilter>>,
    }
    impl Builder {
        /// <p>The name of the group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        pub fn filters(mut self, input: impl Into<crate::model::InventoryFilter>) -> Self {
            let mut v = self.filters.unwrap_or_default();
            v.push(input.into());
            self.filters = Some(v);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InventoryFilter>>,
        ) -> Self {
            self.filters = input;
            self
        }
        /// Consumes the builder and constructs a [`InventoryGroup`](crate::model::InventoryGroup)
        pub fn build(self) -> crate::model::InventoryGroup {
            crate::model::InventoryGroup {
                name: self.name,
                filters: self.filters,
            }
        }
    }
}
impl InventoryGroup {
    /// Creates a new builder-style object to manufacture [`InventoryGroup`](crate::model::InventoryGroup)
    pub fn builder() -> crate::model::inventory_group::Builder {
        crate::model::inventory_group::Builder::default()
    }
}

/// <p>A structure that includes attributes that describe a document attachment.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AttachmentContent {
    /// <p>The name of an attachment.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The size of an attachment in bytes.</p>
    #[serde(rename = "Size")]
    #[serde(default)]
    pub size: i64,
    /// <p>The cryptographic hash value of the document content.</p>
    #[serde(rename = "Hash")]
    #[serde(default)]
    pub hash: std::option::Option<std::string::String>,
    /// <p>The hash algorithm used to calculate the hash value.</p>
    #[serde(rename = "HashType")]
    #[serde(default)]
    pub hash_type: std::option::Option<crate::model::AttachmentHashType>,
    /// <p>The URL location of the attachment content.</p>
    #[serde(rename = "Url")]
    #[serde(default)]
    pub url: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AttachmentContent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttachmentContent");
        formatter.field("name", &self.name);
        formatter.field("size", &self.size);
        formatter.field("hash", &self.hash);
        formatter.field("hash_type", &self.hash_type);
        formatter.field("url", &self.url);
        formatter.finish()
    }
}
/// See [`AttachmentContent`](crate::model::AttachmentContent)
pub mod attachment_content {
    /// A builder for [`AttachmentContent`](crate::model::AttachmentContent)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) size: std::option::Option<i64>,
        pub(crate) hash: std::option::Option<std::string::String>,
        pub(crate) hash_type: std::option::Option<crate::model::AttachmentHashType>,
        pub(crate) url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of an attachment.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The size of an attachment in bytes.</p>
        pub fn size(mut self, input: i64) -> Self {
            self.size = Some(input);
            self
        }
        pub fn set_size(mut self, input: std::option::Option<i64>) -> Self {
            self.size = input;
            self
        }
        /// <p>The cryptographic hash value of the document content.</p>
        pub fn hash(mut self, input: impl Into<std::string::String>) -> Self {
            self.hash = Some(input.into());
            self
        }
        pub fn set_hash(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hash = input;
            self
        }
        /// <p>The hash algorithm used to calculate the hash value.</p>
        pub fn hash_type(mut self, input: crate::model::AttachmentHashType) -> Self {
            self.hash_type = Some(input);
            self
        }
        pub fn set_hash_type(
            mut self,
            input: std::option::Option<crate::model::AttachmentHashType>,
        ) -> Self {
            self.hash_type = input;
            self
        }
        /// <p>The URL location of the attachment content.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// Consumes the builder and constructs a [`AttachmentContent`](crate::model::AttachmentContent)
        pub fn build(self) -> crate::model::AttachmentContent {
            crate::model::AttachmentContent {
                name: self.name,
                size: self.size.unwrap_or_default(),
                hash: self.hash,
                hash_type: self.hash_type,
                url: self.url,
            }
        }
    }
}
impl AttachmentContent {
    /// Creates a new builder-style object to manufacture [`AttachmentContent`](crate::model::AttachmentContent)
    pub fn builder() -> crate::model::attachment_content::Builder {
        crate::model::attachment_content::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AttachmentHashType {
    Sha256,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AttachmentHashType {
    fn from(s: &str) -> Self {
        match s {
            "Sha256" => AttachmentHashType::Sha256,
            other => AttachmentHashType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AttachmentHashType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(AttachmentHashType::from(s))
    }
}
impl AttachmentHashType {
    pub fn as_str(&self) -> &str {
        match self {
            AttachmentHashType::Sha256 => "Sha256",
            AttachmentHashType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for AttachmentHashType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for AttachmentHashType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Defines the basic information about a patch baseline override.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct BaselineOverride {
    /// <p>The operating system rule used by the patch baseline override.</p>
    #[serde(rename = "OperatingSystem")]
    #[serde(default)]
    pub operating_system: std::option::Option<crate::model::OperatingSystem>,
    /// <p>A set of patch filters, typically used for approval rules.</p>
    #[serde(rename = "GlobalFilters")]
    #[serde(default)]
    pub global_filters: std::option::Option<crate::model::PatchFilterGroup>,
    /// <p>A set of rules defining the approval rules for a patch baseline.</p>
    #[serde(rename = "ApprovalRules")]
    #[serde(default)]
    pub approval_rules: std::option::Option<crate::model::PatchRuleGroup>,
    /// <p>A list of explicitly approved patches for the baseline.</p>
    /// <p>For information about accepted formats for lists of approved patches and rejected patches,
    /// see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">About
    /// package name formats for approved and rejected patch lists</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    #[serde(rename = "ApprovedPatches")]
    #[serde(default)]
    pub approved_patches: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Defines the compliance level for approved patches. When an approved patch is reported as
    /// missing, this value describes the severity of the compliance violation.</p>
    #[serde(rename = "ApprovedPatchesComplianceLevel")]
    #[serde(default)]
    pub approved_patches_compliance_level: std::option::Option<crate::model::PatchComplianceLevel>,
    /// <p>A list of explicitly rejected patches for the baseline.</p>
    /// <p>For information about accepted formats for lists of approved patches and rejected patches,
    /// see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">About
    /// package name formats for approved and rejected patch lists</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    #[serde(rename = "RejectedPatches")]
    #[serde(default)]
    pub rejected_patches: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The action for Patch Manager to take on patches included in the RejectedPackages list. A
    /// patch can be allowed only if it is a dependency of another package, or blocked entirely along
    /// with packages that include it as a dependency.</p>
    #[serde(rename = "RejectedPatchesAction")]
    #[serde(default)]
    pub rejected_patches_action: std::option::Option<crate::model::PatchAction>,
    /// <p>Indicates whether the list of approved patches includes non-security updates that should be
    /// applied to the instances. The default value is 'false'. Applies to Linux instances only.</p>
    #[serde(rename = "ApprovedPatchesEnableNonSecurity")]
    #[serde(default)]
    pub approved_patches_enable_non_security: bool,
    /// <p>Information about the patches to use to update the instances, including target operating
    /// systems and source repositories. Applies to Linux instances only.</p>
    #[serde(rename = "Sources")]
    #[serde(default)]
    pub sources: std::option::Option<std::vec::Vec<crate::model::PatchSource>>,
}
impl std::fmt::Debug for BaselineOverride {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BaselineOverride");
        formatter.field("operating_system", &self.operating_system);
        formatter.field("global_filters", &self.global_filters);
        formatter.field("approval_rules", &self.approval_rules);
        formatter.field("approved_patches", &self.approved_patches);
        formatter.field(
            "approved_patches_compliance_level",
            &self.approved_patches_compliance_level,
        );
        formatter.field("rejected_patches", &self.rejected_patches);
        formatter.field("rejected_patches_action", &self.rejected_patches_action);
        formatter.field(
            "approved_patches_enable_non_security",
            &self.approved_patches_enable_non_security,
        );
        formatter.field("sources", &self.sources);
        formatter.finish()
    }
}
/// See [`BaselineOverride`](crate::model::BaselineOverride)
pub mod baseline_override {
    /// A builder for [`BaselineOverride`](crate::model::BaselineOverride)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) operating_system: std::option::Option<crate::model::OperatingSystem>,
        pub(crate) global_filters: std::option::Option<crate::model::PatchFilterGroup>,
        pub(crate) approval_rules: std::option::Option<crate::model::PatchRuleGroup>,
        pub(crate) approved_patches: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) approved_patches_compliance_level:
            std::option::Option<crate::model::PatchComplianceLevel>,
        pub(crate) rejected_patches: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) rejected_patches_action: std::option::Option<crate::model::PatchAction>,
        pub(crate) approved_patches_enable_non_security: std::option::Option<bool>,
        pub(crate) sources: std::option::Option<std::vec::Vec<crate::model::PatchSource>>,
    }
    impl Builder {
        /// <p>The operating system rule used by the patch baseline override.</p>
        pub fn operating_system(mut self, input: crate::model::OperatingSystem) -> Self {
            self.operating_system = Some(input);
            self
        }
        pub fn set_operating_system(
            mut self,
            input: std::option::Option<crate::model::OperatingSystem>,
        ) -> Self {
            self.operating_system = input;
            self
        }
        /// <p>A set of patch filters, typically used for approval rules.</p>
        pub fn global_filters(mut self, input: crate::model::PatchFilterGroup) -> Self {
            self.global_filters = Some(input);
            self
        }
        pub fn set_global_filters(
            mut self,
            input: std::option::Option<crate::model::PatchFilterGroup>,
        ) -> Self {
            self.global_filters = input;
            self
        }
        /// <p>A set of rules defining the approval rules for a patch baseline.</p>
        pub fn approval_rules(mut self, input: crate::model::PatchRuleGroup) -> Self {
            self.approval_rules = Some(input);
            self
        }
        pub fn set_approval_rules(
            mut self,
            input: std::option::Option<crate::model::PatchRuleGroup>,
        ) -> Self {
            self.approval_rules = input;
            self
        }
        pub fn approved_patches(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.approved_patches.unwrap_or_default();
            v.push(input.into());
            self.approved_patches = Some(v);
            self
        }
        pub fn set_approved_patches(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.approved_patches = input;
            self
        }
        /// <p>Defines the compliance level for approved patches. When an approved patch is reported as
        /// missing, this value describes the severity of the compliance violation.</p>
        pub fn approved_patches_compliance_level(
            mut self,
            input: crate::model::PatchComplianceLevel,
        ) -> Self {
            self.approved_patches_compliance_level = Some(input);
            self
        }
        pub fn set_approved_patches_compliance_level(
            mut self,
            input: std::option::Option<crate::model::PatchComplianceLevel>,
        ) -> Self {
            self.approved_patches_compliance_level = input;
            self
        }
        pub fn rejected_patches(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.rejected_patches.unwrap_or_default();
            v.push(input.into());
            self.rejected_patches = Some(v);
            self
        }
        pub fn set_rejected_patches(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.rejected_patches = input;
            self
        }
        /// <p>The action for Patch Manager to take on patches included in the RejectedPackages list. A
        /// patch can be allowed only if it is a dependency of another package, or blocked entirely along
        /// with packages that include it as a dependency.</p>
        pub fn rejected_patches_action(mut self, input: crate::model::PatchAction) -> Self {
            self.rejected_patches_action = Some(input);
            self
        }
        pub fn set_rejected_patches_action(
            mut self,
            input: std::option::Option<crate::model::PatchAction>,
        ) -> Self {
            self.rejected_patches_action = input;
            self
        }
        /// <p>Indicates whether the list of approved patches includes non-security updates that should be
        /// applied to the instances. The default value is 'false'. Applies to Linux instances only.</p>
        pub fn approved_patches_enable_non_security(mut self, input: bool) -> Self {
            self.approved_patches_enable_non_security = Some(input);
            self
        }
        pub fn set_approved_patches_enable_non_security(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.approved_patches_enable_non_security = input;
            self
        }
        pub fn sources(mut self, input: impl Into<crate::model::PatchSource>) -> Self {
            let mut v = self.sources.unwrap_or_default();
            v.push(input.into());
            self.sources = Some(v);
            self
        }
        pub fn set_sources(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PatchSource>>,
        ) -> Self {
            self.sources = input;
            self
        }
        /// Consumes the builder and constructs a [`BaselineOverride`](crate::model::BaselineOverride)
        pub fn build(self) -> crate::model::BaselineOverride {
            crate::model::BaselineOverride {
                operating_system: self.operating_system,
                global_filters: self.global_filters,
                approval_rules: self.approval_rules,
                approved_patches: self.approved_patches,
                approved_patches_compliance_level: self.approved_patches_compliance_level,
                rejected_patches: self.rejected_patches,
                rejected_patches_action: self.rejected_patches_action,
                approved_patches_enable_non_security: self
                    .approved_patches_enable_non_security
                    .unwrap_or_default(),
                sources: self.sources,
            }
        }
    }
}
impl BaselineOverride {
    /// Creates a new builder-style object to manufacture [`BaselineOverride`](crate::model::BaselineOverride)
    pub fn builder() -> crate::model::baseline_override::Builder {
        crate::model::baseline_override::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConnectionStatus {
    Connected,
    NotConnected,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ConnectionStatus {
    fn from(s: &str) -> Self {
        match s {
            "Connected" => ConnectionStatus::Connected,
            "NotConnected" => ConnectionStatus::NotConnected,
            other => ConnectionStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ConnectionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ConnectionStatus::from(s))
    }
}
impl ConnectionStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ConnectionStatus::Connected => "Connected",
            ConnectionStatus::NotConnected => "NotConnected",
            ConnectionStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ConnectionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ConnectionStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CalendarState {
    Closed,
    Open,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CalendarState {
    fn from(s: &str) -> Self {
        match s {
            "CLOSED" => CalendarState::Closed,
            "OPEN" => CalendarState::Open,
            other => CalendarState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CalendarState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(CalendarState::from(s))
    }
}
impl CalendarState {
    pub fn as_str(&self) -> &str {
        match self {
            CalendarState::Closed => "CLOSED",
            CalendarState::Open => "OPEN",
            CalendarState::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for CalendarState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for CalendarState {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Detailed information about the current state of an individual Automation execution.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AutomationExecution {
    /// <p>The execution ID.</p>
    #[serde(rename = "AutomationExecutionId")]
    #[serde(default)]
    pub automation_execution_id: std::option::Option<std::string::String>,
    /// <p>The name of the Automation document used during the execution.</p>
    #[serde(rename = "DocumentName")]
    #[serde(default)]
    pub document_name: std::option::Option<std::string::String>,
    /// <p>The version of the document to use during execution.</p>
    #[serde(rename = "DocumentVersion")]
    #[serde(default)]
    pub document_version: std::option::Option<std::string::String>,
    /// <p>The time the execution started.</p>
    #[serde(rename = "ExecutionStartTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub execution_start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time the execution finished.</p>
    #[serde(rename = "ExecutionEndTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub execution_end_time: std::option::Option<smithy_types::Instant>,
    /// <p>The execution status of the Automation.</p>
    #[serde(rename = "AutomationExecutionStatus")]
    #[serde(default)]
    pub automation_execution_status: std::option::Option<crate::model::AutomationExecutionStatus>,
    /// <p>A list of details about the current state of all steps that comprise an execution. An
    /// Automation document contains a list of steps that are run in order.</p>
    #[serde(rename = "StepExecutions")]
    #[serde(default)]
    pub step_executions: std::option::Option<std::vec::Vec<crate::model::StepExecution>>,
    /// <p>A boolean value that indicates if the response contains the full list of the Automation step
    /// executions. If true, use the DescribeAutomationStepExecutions API action to get the full list of
    /// step executions.</p>
    #[serde(rename = "StepExecutionsTruncated")]
    #[serde(default)]
    pub step_executions_truncated: bool,
    /// <p>The key-value map of execution parameters, which were supplied when calling
    /// StartAutomationExecution.</p>
    #[serde(rename = "Parameters")]
    #[serde(default)]
    pub parameters: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The list of execution outputs as defined in the automation document.</p>
    #[serde(rename = "Outputs")]
    #[serde(default)]
    pub outputs: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>A message describing why an execution has failed, if the status is set to Failed.</p>
    #[serde(rename = "FailureMessage")]
    #[serde(default)]
    pub failure_message: std::option::Option<std::string::String>,
    /// <p>The automation execution mode.</p>
    #[serde(rename = "Mode")]
    #[serde(default)]
    pub mode: std::option::Option<crate::model::ExecutionMode>,
    /// <p>The AutomationExecutionId of the parent automation.</p>
    #[serde(rename = "ParentAutomationExecutionId")]
    #[serde(default)]
    pub parent_automation_execution_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the user who ran the automation.</p>
    #[serde(rename = "ExecutedBy")]
    #[serde(default)]
    pub executed_by: std::option::Option<std::string::String>,
    /// <p>The name of the step that is currently running.</p>
    #[serde(rename = "CurrentStepName")]
    #[serde(default)]
    pub current_step_name: std::option::Option<std::string::String>,
    /// <p>The action of the step that is currently running.</p>
    #[serde(rename = "CurrentAction")]
    #[serde(default)]
    pub current_action: std::option::Option<std::string::String>,
    /// <p>The parameter name.</p>
    #[serde(rename = "TargetParameterName")]
    #[serde(default)]
    pub target_parameter_name: std::option::Option<std::string::String>,
    /// <p>The specified targets.</p>
    #[serde(rename = "Targets")]
    #[serde(default)]
    pub targets: std::option::Option<std::vec::Vec<crate::model::Target>>,
    /// <p>The specified key-value mapping of document parameters to target resources.</p>
    #[serde(rename = "TargetMaps")]
    #[serde(default)]
    pub target_maps: std::option::Option<
        std::vec::Vec<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
    >,
    /// <p>A list of resolved targets in the rate control execution.</p>
    #[serde(rename = "ResolvedTargets")]
    #[serde(default)]
    pub resolved_targets: std::option::Option<crate::model::ResolvedTargets>,
    /// <p>The MaxConcurrency value specified by the user when the execution started.</p>
    #[serde(rename = "MaxConcurrency")]
    #[serde(default)]
    pub max_concurrency: std::option::Option<std::string::String>,
    /// <p>The MaxErrors value specified by the user when the execution started.</p>
    #[serde(rename = "MaxErrors")]
    #[serde(default)]
    pub max_errors: std::option::Option<std::string::String>,
    /// <p>The target of the execution.</p>
    #[serde(rename = "Target")]
    #[serde(default)]
    pub target: std::option::Option<std::string::String>,
    /// <p>The combination of AWS Regions and/or AWS accounts where you want to run the
    /// Automation.</p>
    #[serde(rename = "TargetLocations")]
    #[serde(default)]
    pub target_locations: std::option::Option<std::vec::Vec<crate::model::TargetLocation>>,
    /// <p>An aggregate of step execution statuses displayed in the AWS Console for a multi-Region and
    /// multi-account Automation execution.</p>
    #[serde(rename = "ProgressCounters")]
    #[serde(default)]
    pub progress_counters: std::option::Option<crate::model::ProgressCounters>,
    /// <p>The subtype of the Automation operation. Currently, the only supported value is
    /// <code>ChangeRequest</code>.</p>
    #[serde(rename = "AutomationSubtype")]
    #[serde(default)]
    pub automation_subtype: std::option::Option<crate::model::AutomationSubtype>,
    /// <p>The date and time the Automation operation is scheduled to start.</p>
    #[serde(rename = "ScheduledTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub scheduled_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the Automation runbooks (Automation documents) that are run as part of a
    /// runbook workflow.</p>
    /// <note>
    /// <p>The Automation runbooks specified for the runbook workflow can't run until all required
    /// approvals for the change request have been received.</p>
    /// </note>
    #[serde(rename = "Runbooks")]
    #[serde(default)]
    pub runbooks: std::option::Option<std::vec::Vec<crate::model::Runbook>>,
    /// <p>The ID of an OpsItem that is created to represent a Change Manager change request.</p>
    #[serde(rename = "OpsItemId")]
    #[serde(default)]
    pub ops_item_id: std::option::Option<std::string::String>,
    /// <p>The ID of a State Manager association used in the Automation operation.</p>
    #[serde(rename = "AssociationId")]
    #[serde(default)]
    pub association_id: std::option::Option<std::string::String>,
    /// <p>The name of the Change Manager change request.</p>
    #[serde(rename = "ChangeRequestName")]
    #[serde(default)]
    pub change_request_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AutomationExecution {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutomationExecution");
        formatter.field("automation_execution_id", &self.automation_execution_id);
        formatter.field("document_name", &self.document_name);
        formatter.field("document_version", &self.document_version);
        formatter.field("execution_start_time", &self.execution_start_time);
        formatter.field("execution_end_time", &self.execution_end_time);
        formatter.field(
            "automation_execution_status",
            &self.automation_execution_status,
        );
        formatter.field("step_executions", &self.step_executions);
        formatter.field("step_executions_truncated", &self.step_executions_truncated);
        formatter.field("parameters", &self.parameters);
        formatter.field("outputs", &self.outputs);
        formatter.field("failure_message", &self.failure_message);
        formatter.field("mode", &self.mode);
        formatter.field(
            "parent_automation_execution_id",
            &self.parent_automation_execution_id,
        );
        formatter.field("executed_by", &self.executed_by);
        formatter.field("current_step_name", &self.current_step_name);
        formatter.field("current_action", &self.current_action);
        formatter.field("target_parameter_name", &self.target_parameter_name);
        formatter.field("targets", &self.targets);
        formatter.field("target_maps", &self.target_maps);
        formatter.field("resolved_targets", &self.resolved_targets);
        formatter.field("max_concurrency", &self.max_concurrency);
        formatter.field("max_errors", &self.max_errors);
        formatter.field("target", &self.target);
        formatter.field("target_locations", &self.target_locations);
        formatter.field("progress_counters", &self.progress_counters);
        formatter.field("automation_subtype", &self.automation_subtype);
        formatter.field("scheduled_time", &self.scheduled_time);
        formatter.field("runbooks", &self.runbooks);
        formatter.field("ops_item_id", &self.ops_item_id);
        formatter.field("association_id", &self.association_id);
        formatter.field("change_request_name", &self.change_request_name);
        formatter.finish()
    }
}
/// See [`AutomationExecution`](crate::model::AutomationExecution)
pub mod automation_execution {
    /// A builder for [`AutomationExecution`](crate::model::AutomationExecution)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) automation_execution_id: std::option::Option<std::string::String>,
        pub(crate) document_name: std::option::Option<std::string::String>,
        pub(crate) document_version: std::option::Option<std::string::String>,
        pub(crate) execution_start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) execution_end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) automation_execution_status:
            std::option::Option<crate::model::AutomationExecutionStatus>,
        pub(crate) step_executions: std::option::Option<std::vec::Vec<crate::model::StepExecution>>,
        pub(crate) step_executions_truncated: std::option::Option<bool>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) outputs: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) failure_message: std::option::Option<std::string::String>,
        pub(crate) mode: std::option::Option<crate::model::ExecutionMode>,
        pub(crate) parent_automation_execution_id: std::option::Option<std::string::String>,
        pub(crate) executed_by: std::option::Option<std::string::String>,
        pub(crate) current_step_name: std::option::Option<std::string::String>,
        pub(crate) current_action: std::option::Option<std::string::String>,
        pub(crate) target_parameter_name: std::option::Option<std::string::String>,
        pub(crate) targets: std::option::Option<std::vec::Vec<crate::model::Target>>,
        pub(crate) target_maps: std::option::Option<
            std::vec::Vec<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        >,
        pub(crate) resolved_targets: std::option::Option<crate::model::ResolvedTargets>,
        pub(crate) max_concurrency: std::option::Option<std::string::String>,
        pub(crate) max_errors: std::option::Option<std::string::String>,
        pub(crate) target: std::option::Option<std::string::String>,
        pub(crate) target_locations:
            std::option::Option<std::vec::Vec<crate::model::TargetLocation>>,
        pub(crate) progress_counters: std::option::Option<crate::model::ProgressCounters>,
        pub(crate) automation_subtype: std::option::Option<crate::model::AutomationSubtype>,
        pub(crate) scheduled_time: std::option::Option<smithy_types::Instant>,
        pub(crate) runbooks: std::option::Option<std::vec::Vec<crate::model::Runbook>>,
        pub(crate) ops_item_id: std::option::Option<std::string::String>,
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) change_request_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The execution ID.</p>
        pub fn automation_execution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.automation_execution_id = Some(input.into());
            self
        }
        pub fn set_automation_execution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.automation_execution_id = input;
            self
        }
        /// <p>The name of the Automation document used during the execution.</p>
        pub fn document_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_name = Some(input.into());
            self
        }
        pub fn set_document_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_name = input;
            self
        }
        /// <p>The version of the document to use during execution.</p>
        pub fn document_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_version = Some(input.into());
            self
        }
        pub fn set_document_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_version = input;
            self
        }
        /// <p>The time the execution started.</p>
        pub fn execution_start_time(mut self, input: smithy_types::Instant) -> Self {
            self.execution_start_time = Some(input);
            self
        }
        pub fn set_execution_start_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.execution_start_time = input;
            self
        }
        /// <p>The time the execution finished.</p>
        pub fn execution_end_time(mut self, input: smithy_types::Instant) -> Self {
            self.execution_end_time = Some(input);
            self
        }
        pub fn set_execution_end_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.execution_end_time = input;
            self
        }
        /// <p>The execution status of the Automation.</p>
        pub fn automation_execution_status(
            mut self,
            input: crate::model::AutomationExecutionStatus,
        ) -> Self {
            self.automation_execution_status = Some(input);
            self
        }
        pub fn set_automation_execution_status(
            mut self,
            input: std::option::Option<crate::model::AutomationExecutionStatus>,
        ) -> Self {
            self.automation_execution_status = input;
            self
        }
        pub fn step_executions(mut self, input: impl Into<crate::model::StepExecution>) -> Self {
            let mut v = self.step_executions.unwrap_or_default();
            v.push(input.into());
            self.step_executions = Some(v);
            self
        }
        pub fn set_step_executions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StepExecution>>,
        ) -> Self {
            self.step_executions = input;
            self
        }
        /// <p>A boolean value that indicates if the response contains the full list of the Automation step
        /// executions. If true, use the DescribeAutomationStepExecutions API action to get the full list of
        /// step executions.</p>
        pub fn step_executions_truncated(mut self, input: bool) -> Self {
            self.step_executions_truncated = Some(input);
            self
        }
        pub fn set_step_executions_truncated(mut self, input: std::option::Option<bool>) -> Self {
            self.step_executions_truncated = input;
            self
        }
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        pub fn outputs(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.outputs.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.outputs = Some(hash_map);
            self
        }
        pub fn set_outputs(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.outputs = input;
            self
        }
        /// <p>A message describing why an execution has failed, if the status is set to Failed.</p>
        pub fn failure_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_message = Some(input.into());
            self
        }
        pub fn set_failure_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_message = input;
            self
        }
        /// <p>The automation execution mode.</p>
        pub fn mode(mut self, input: crate::model::ExecutionMode) -> Self {
            self.mode = Some(input);
            self
        }
        pub fn set_mode(mut self, input: std::option::Option<crate::model::ExecutionMode>) -> Self {
            self.mode = input;
            self
        }
        /// <p>The AutomationExecutionId of the parent automation.</p>
        pub fn parent_automation_execution_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.parent_automation_execution_id = Some(input.into());
            self
        }
        pub fn set_parent_automation_execution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parent_automation_execution_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the user who ran the automation.</p>
        pub fn executed_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.executed_by = Some(input.into());
            self
        }
        pub fn set_executed_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.executed_by = input;
            self
        }
        /// <p>The name of the step that is currently running.</p>
        pub fn current_step_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.current_step_name = Some(input.into());
            self
        }
        pub fn set_current_step_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.current_step_name = input;
            self
        }
        /// <p>The action of the step that is currently running.</p>
        pub fn current_action(mut self, input: impl Into<std::string::String>) -> Self {
            self.current_action = Some(input.into());
            self
        }
        pub fn set_current_action(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.current_action = input;
            self
        }
        /// <p>The parameter name.</p>
        pub fn target_parameter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_parameter_name = Some(input.into());
            self
        }
        pub fn set_target_parameter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_parameter_name = input;
            self
        }
        pub fn targets(mut self, input: impl Into<crate::model::Target>) -> Self {
            let mut v = self.targets.unwrap_or_default();
            v.push(input.into());
            self.targets = Some(v);
            self
        }
        pub fn set_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Target>>,
        ) -> Self {
            self.targets = input;
            self
        }
        pub fn target_maps(
            mut self,
            input: impl Into<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            let mut v = self.target_maps.unwrap_or_default();
            v.push(input.into());
            self.target_maps = Some(v);
            self
        }
        pub fn set_target_maps(
            mut self,
            input: std::option::Option<
                std::vec::Vec<
                    std::collections::HashMap<
                        std::string::String,
                        std::vec::Vec<std::string::String>,
                    >,
                >,
            >,
        ) -> Self {
            self.target_maps = input;
            self
        }
        /// <p>A list of resolved targets in the rate control execution.</p>
        pub fn resolved_targets(mut self, input: crate::model::ResolvedTargets) -> Self {
            self.resolved_targets = Some(input);
            self
        }
        pub fn set_resolved_targets(
            mut self,
            input: std::option::Option<crate::model::ResolvedTargets>,
        ) -> Self {
            self.resolved_targets = input;
            self
        }
        /// <p>The MaxConcurrency value specified by the user when the execution started.</p>
        pub fn max_concurrency(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_concurrency = Some(input.into());
            self
        }
        pub fn set_max_concurrency(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.max_concurrency = input;
            self
        }
        /// <p>The MaxErrors value specified by the user when the execution started.</p>
        pub fn max_errors(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_errors = Some(input.into());
            self
        }
        pub fn set_max_errors(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_errors = input;
            self
        }
        /// <p>The target of the execution.</p>
        pub fn target(mut self, input: impl Into<std::string::String>) -> Self {
            self.target = Some(input.into());
            self
        }
        pub fn set_target(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target = input;
            self
        }
        pub fn target_locations(mut self, input: impl Into<crate::model::TargetLocation>) -> Self {
            let mut v = self.target_locations.unwrap_or_default();
            v.push(input.into());
            self.target_locations = Some(v);
            self
        }
        pub fn set_target_locations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TargetLocation>>,
        ) -> Self {
            self.target_locations = input;
            self
        }
        /// <p>An aggregate of step execution statuses displayed in the AWS Console for a multi-Region and
        /// multi-account Automation execution.</p>
        pub fn progress_counters(mut self, input: crate::model::ProgressCounters) -> Self {
            self.progress_counters = Some(input);
            self
        }
        pub fn set_progress_counters(
            mut self,
            input: std::option::Option<crate::model::ProgressCounters>,
        ) -> Self {
            self.progress_counters = input;
            self
        }
        /// <p>The subtype of the Automation operation. Currently, the only supported value is
        /// <code>ChangeRequest</code>.</p>
        pub fn automation_subtype(mut self, input: crate::model::AutomationSubtype) -> Self {
            self.automation_subtype = Some(input);
            self
        }
        pub fn set_automation_subtype(
            mut self,
            input: std::option::Option<crate::model::AutomationSubtype>,
        ) -> Self {
            self.automation_subtype = input;
            self
        }
        /// <p>The date and time the Automation operation is scheduled to start.</p>
        pub fn scheduled_time(mut self, input: smithy_types::Instant) -> Self {
            self.scheduled_time = Some(input);
            self
        }
        pub fn set_scheduled_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.scheduled_time = input;
            self
        }
        pub fn runbooks(mut self, input: impl Into<crate::model::Runbook>) -> Self {
            let mut v = self.runbooks.unwrap_or_default();
            v.push(input.into());
            self.runbooks = Some(v);
            self
        }
        pub fn set_runbooks(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Runbook>>,
        ) -> Self {
            self.runbooks = input;
            self
        }
        /// <p>The ID of an OpsItem that is created to represent a Change Manager change request.</p>
        pub fn ops_item_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ops_item_id = Some(input.into());
            self
        }
        pub fn set_ops_item_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ops_item_id = input;
            self
        }
        /// <p>The ID of a State Manager association used in the Automation operation.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>The name of the Change Manager change request.</p>
        pub fn change_request_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.change_request_name = Some(input.into());
            self
        }
        pub fn set_change_request_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.change_request_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AutomationExecution`](crate::model::AutomationExecution)
        pub fn build(self) -> crate::model::AutomationExecution {
            crate::model::AutomationExecution {
                automation_execution_id: self.automation_execution_id,
                document_name: self.document_name,
                document_version: self.document_version,
                execution_start_time: self.execution_start_time,
                execution_end_time: self.execution_end_time,
                automation_execution_status: self.automation_execution_status,
                step_executions: self.step_executions,
                step_executions_truncated: self.step_executions_truncated.unwrap_or_default(),
                parameters: self.parameters,
                outputs: self.outputs,
                failure_message: self.failure_message,
                mode: self.mode,
                parent_automation_execution_id: self.parent_automation_execution_id,
                executed_by: self.executed_by,
                current_step_name: self.current_step_name,
                current_action: self.current_action,
                target_parameter_name: self.target_parameter_name,
                targets: self.targets,
                target_maps: self.target_maps,
                resolved_targets: self.resolved_targets,
                max_concurrency: self.max_concurrency,
                max_errors: self.max_errors,
                target: self.target,
                target_locations: self.target_locations,
                progress_counters: self.progress_counters,
                automation_subtype: self.automation_subtype,
                scheduled_time: self.scheduled_time,
                runbooks: self.runbooks,
                ops_item_id: self.ops_item_id,
                association_id: self.association_id,
                change_request_name: self.change_request_name,
            }
        }
    }
}
impl AutomationExecution {
    /// Creates a new builder-style object to manufacture [`AutomationExecution`](crate::model::AutomationExecution)
    pub fn builder() -> crate::model::automation_execution::Builder {
        crate::model::automation_execution::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutomationSubtype {
    ChangeRequest,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutomationSubtype {
    fn from(s: &str) -> Self {
        match s {
            "ChangeRequest" => AutomationSubtype::ChangeRequest,
            other => AutomationSubtype::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutomationSubtype {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(AutomationSubtype::from(s))
    }
}
impl AutomationSubtype {
    pub fn as_str(&self) -> &str {
        match self {
            AutomationSubtype::ChangeRequest => "ChangeRequest",
            AutomationSubtype::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for AutomationSubtype {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for AutomationSubtype {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>An aggregate of step execution statuses displayed in the AWS Console for a multi-Region and
/// multi-account Automation execution.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ProgressCounters {
    /// <p>The total number of steps run in all specified AWS Regions and accounts for the current
    /// Automation execution.</p>
    #[serde(rename = "TotalSteps")]
    #[serde(default)]
    pub total_steps: i32,
    /// <p>The total number of steps that successfully completed in all specified AWS Regions and
    /// accounts for the current Automation execution.</p>
    #[serde(rename = "SuccessSteps")]
    #[serde(default)]
    pub success_steps: i32,
    /// <p>The total number of steps that failed to run in all specified AWS Regions and accounts for
    /// the current Automation execution.</p>
    #[serde(rename = "FailedSteps")]
    #[serde(default)]
    pub failed_steps: i32,
    /// <p>The total number of steps that the system cancelled in all specified AWS Regions and
    /// accounts for the current Automation execution.</p>
    #[serde(rename = "CancelledSteps")]
    #[serde(default)]
    pub cancelled_steps: i32,
    /// <p>The total number of steps that timed out in all specified AWS Regions and accounts for the
    /// current Automation execution.</p>
    #[serde(rename = "TimedOutSteps")]
    #[serde(default)]
    pub timed_out_steps: i32,
}
impl std::fmt::Debug for ProgressCounters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProgressCounters");
        formatter.field("total_steps", &self.total_steps);
        formatter.field("success_steps", &self.success_steps);
        formatter.field("failed_steps", &self.failed_steps);
        formatter.field("cancelled_steps", &self.cancelled_steps);
        formatter.field("timed_out_steps", &self.timed_out_steps);
        formatter.finish()
    }
}
/// See [`ProgressCounters`](crate::model::ProgressCounters)
pub mod progress_counters {
    /// A builder for [`ProgressCounters`](crate::model::ProgressCounters)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) total_steps: std::option::Option<i32>,
        pub(crate) success_steps: std::option::Option<i32>,
        pub(crate) failed_steps: std::option::Option<i32>,
        pub(crate) cancelled_steps: std::option::Option<i32>,
        pub(crate) timed_out_steps: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The total number of steps run in all specified AWS Regions and accounts for the current
        /// Automation execution.</p>
        pub fn total_steps(mut self, input: i32) -> Self {
            self.total_steps = Some(input);
            self
        }
        pub fn set_total_steps(mut self, input: std::option::Option<i32>) -> Self {
            self.total_steps = input;
            self
        }
        /// <p>The total number of steps that successfully completed in all specified AWS Regions and
        /// accounts for the current Automation execution.</p>
        pub fn success_steps(mut self, input: i32) -> Self {
            self.success_steps = Some(input);
            self
        }
        pub fn set_success_steps(mut self, input: std::option::Option<i32>) -> Self {
            self.success_steps = input;
            self
        }
        /// <p>The total number of steps that failed to run in all specified AWS Regions and accounts for
        /// the current Automation execution.</p>
        pub fn failed_steps(mut self, input: i32) -> Self {
            self.failed_steps = Some(input);
            self
        }
        pub fn set_failed_steps(mut self, input: std::option::Option<i32>) -> Self {
            self.failed_steps = input;
            self
        }
        /// <p>The total number of steps that the system cancelled in all specified AWS Regions and
        /// accounts for the current Automation execution.</p>
        pub fn cancelled_steps(mut self, input: i32) -> Self {
            self.cancelled_steps = Some(input);
            self
        }
        pub fn set_cancelled_steps(mut self, input: std::option::Option<i32>) -> Self {
            self.cancelled_steps = input;
            self
        }
        /// <p>The total number of steps that timed out in all specified AWS Regions and accounts for the
        /// current Automation execution.</p>
        pub fn timed_out_steps(mut self, input: i32) -> Self {
            self.timed_out_steps = Some(input);
            self
        }
        pub fn set_timed_out_steps(mut self, input: std::option::Option<i32>) -> Self {
            self.timed_out_steps = input;
            self
        }
        /// Consumes the builder and constructs a [`ProgressCounters`](crate::model::ProgressCounters)
        pub fn build(self) -> crate::model::ProgressCounters {
            crate::model::ProgressCounters {
                total_steps: self.total_steps.unwrap_or_default(),
                success_steps: self.success_steps.unwrap_or_default(),
                failed_steps: self.failed_steps.unwrap_or_default(),
                cancelled_steps: self.cancelled_steps.unwrap_or_default(),
                timed_out_steps: self.timed_out_steps.unwrap_or_default(),
            }
        }
    }
}
impl ProgressCounters {
    /// Creates a new builder-style object to manufacture [`ProgressCounters`](crate::model::ProgressCounters)
    pub fn builder() -> crate::model::progress_counters::Builder {
        crate::model::progress_counters::Builder::default()
    }
}

/// <p>Information about targets that resolved during the Automation execution.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResolvedTargets {
    /// <p>A list of parameter values sent to targets that resolved during the Automation
    /// execution.</p>
    #[serde(rename = "ParameterValues")]
    #[serde(default)]
    pub parameter_values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A boolean value indicating whether the resolved target list is truncated.</p>
    #[serde(rename = "Truncated")]
    #[serde(default)]
    pub truncated: bool,
}
impl std::fmt::Debug for ResolvedTargets {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResolvedTargets");
        formatter.field("parameter_values", &self.parameter_values);
        formatter.field("truncated", &self.truncated);
        formatter.finish()
    }
}
/// See [`ResolvedTargets`](crate::model::ResolvedTargets)
pub mod resolved_targets {
    /// A builder for [`ResolvedTargets`](crate::model::ResolvedTargets)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter_values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) truncated: std::option::Option<bool>,
    }
    impl Builder {
        pub fn parameter_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.parameter_values.unwrap_or_default();
            v.push(input.into());
            self.parameter_values = Some(v);
            self
        }
        pub fn set_parameter_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.parameter_values = input;
            self
        }
        /// <p>A boolean value indicating whether the resolved target list is truncated.</p>
        pub fn truncated(mut self, input: bool) -> Self {
            self.truncated = Some(input);
            self
        }
        pub fn set_truncated(mut self, input: std::option::Option<bool>) -> Self {
            self.truncated = input;
            self
        }
        /// Consumes the builder and constructs a [`ResolvedTargets`](crate::model::ResolvedTargets)
        pub fn build(self) -> crate::model::ResolvedTargets {
            crate::model::ResolvedTargets {
                parameter_values: self.parameter_values,
                truncated: self.truncated.unwrap_or_default(),
            }
        }
    }
}
impl ResolvedTargets {
    /// Creates a new builder-style object to manufacture [`ResolvedTargets`](crate::model::ResolvedTargets)
    pub fn builder() -> crate::model::resolved_targets::Builder {
        crate::model::resolved_targets::Builder::default()
    }
}

/// <p>Detailed information about an the execution state of an Automation step.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct StepExecution {
    /// <p>The name of this execution step.</p>
    #[serde(rename = "StepName")]
    #[serde(default)]
    pub step_name: std::option::Option<std::string::String>,
    /// <p>The action this step performs. The action determines the behavior of the step.</p>
    #[serde(rename = "Action")]
    #[serde(default)]
    pub action: std::option::Option<std::string::String>,
    /// <p>The timeout seconds of the step.</p>
    #[serde(rename = "TimeoutSeconds")]
    #[serde(default)]
    pub timeout_seconds: std::option::Option<i64>,
    /// <p>The action to take if the step fails. The default value is Abort.</p>
    #[serde(rename = "OnFailure")]
    #[serde(default)]
    pub on_failure: std::option::Option<std::string::String>,
    /// <p>The maximum number of tries to run the action of the step. The default value is 1.</p>
    #[serde(rename = "MaxAttempts")]
    #[serde(default)]
    pub max_attempts: std::option::Option<i32>,
    /// <p>If a step has begun execution, this contains the time the step started. If the step is in
    /// Pending status, this field is not populated.</p>
    #[serde(rename = "ExecutionStartTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub execution_start_time: std::option::Option<smithy_types::Instant>,
    /// <p>If a step has finished execution, this contains the time the execution ended. If the step
    /// has not yet concluded, this field is not populated.</p>
    #[serde(rename = "ExecutionEndTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub execution_end_time: std::option::Option<smithy_types::Instant>,
    /// <p>The execution status for this step.</p>
    #[serde(rename = "StepStatus")]
    #[serde(default)]
    pub step_status: std::option::Option<crate::model::AutomationExecutionStatus>,
    /// <p>The response code returned by the execution of the step.</p>
    #[serde(rename = "ResponseCode")]
    #[serde(default)]
    pub response_code: std::option::Option<std::string::String>,
    /// <p>Fully-resolved values passed into the step before execution.</p>
    #[serde(rename = "Inputs")]
    #[serde(default)]
    pub inputs:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Returned values from the execution of the step.</p>
    #[serde(rename = "Outputs")]
    #[serde(default)]
    pub outputs: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>A message associated with the response code for an execution.</p>
    #[serde(rename = "Response")]
    #[serde(default)]
    pub response: std::option::Option<std::string::String>,
    /// <p>If a step failed, this message explains why the execution failed.</p>
    #[serde(rename = "FailureMessage")]
    #[serde(default)]
    pub failure_message: std::option::Option<std::string::String>,
    /// <p>Information about the Automation failure.</p>
    #[serde(rename = "FailureDetails")]
    #[serde(default)]
    pub failure_details: std::option::Option<crate::model::FailureDetails>,
    /// <p>The unique ID of a step execution.</p>
    #[serde(rename = "StepExecutionId")]
    #[serde(default)]
    pub step_execution_id: std::option::Option<std::string::String>,
    /// <p>A user-specified list of parameters to override when running a step.</p>
    #[serde(rename = "OverriddenParameters")]
    #[serde(default)]
    pub overridden_parameters: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The flag which can be used to end automation no matter whether the step succeeds or
    /// fails.</p>
    #[serde(rename = "IsEnd")]
    #[serde(default)]
    pub is_end: std::option::Option<bool>,
    /// <p>The next step after the step succeeds.</p>
    #[serde(rename = "NextStep")]
    #[serde(default)]
    pub next_step: std::option::Option<std::string::String>,
    /// <p>The flag which can be used to help decide whether the failure of current step leads to the
    /// Automation failure.</p>
    #[serde(rename = "IsCritical")]
    #[serde(default)]
    pub is_critical: std::option::Option<bool>,
    /// <p>Strategies used when step fails, we support Continue and Abort. Abort will fail the
    /// automation when the step fails. Continue will ignore the failure of current step and allow
    /// automation to run the next step. With conditional branching, we add step:stepName to support the
    /// automation to go to another specific step.</p>
    #[serde(rename = "ValidNextSteps")]
    #[serde(default)]
    pub valid_next_steps: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The targets for the step execution.</p>
    #[serde(rename = "Targets")]
    #[serde(default)]
    pub targets: std::option::Option<std::vec::Vec<crate::model::Target>>,
    /// <p>The combination of AWS Regions and accounts targeted by the current Automation
    /// execution.</p>
    #[serde(rename = "TargetLocation")]
    #[serde(default)]
    pub target_location: std::option::Option<crate::model::TargetLocation>,
}
impl std::fmt::Debug for StepExecution {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StepExecution");
        formatter.field("step_name", &self.step_name);
        formatter.field("action", &self.action);
        formatter.field("timeout_seconds", &self.timeout_seconds);
        formatter.field("on_failure", &self.on_failure);
        formatter.field("max_attempts", &self.max_attempts);
        formatter.field("execution_start_time", &self.execution_start_time);
        formatter.field("execution_end_time", &self.execution_end_time);
        formatter.field("step_status", &self.step_status);
        formatter.field("response_code", &self.response_code);
        formatter.field("inputs", &self.inputs);
        formatter.field("outputs", &self.outputs);
        formatter.field("response", &self.response);
        formatter.field("failure_message", &self.failure_message);
        formatter.field("failure_details", &self.failure_details);
        formatter.field("step_execution_id", &self.step_execution_id);
        formatter.field("overridden_parameters", &self.overridden_parameters);
        formatter.field("is_end", &self.is_end);
        formatter.field("next_step", &self.next_step);
        formatter.field("is_critical", &self.is_critical);
        formatter.field("valid_next_steps", &self.valid_next_steps);
        formatter.field("targets", &self.targets);
        formatter.field("target_location", &self.target_location);
        formatter.finish()
    }
}
/// See [`StepExecution`](crate::model::StepExecution)
pub mod step_execution {
    /// A builder for [`StepExecution`](crate::model::StepExecution)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) step_name: std::option::Option<std::string::String>,
        pub(crate) action: std::option::Option<std::string::String>,
        pub(crate) timeout_seconds: std::option::Option<i64>,
        pub(crate) on_failure: std::option::Option<std::string::String>,
        pub(crate) max_attempts: std::option::Option<i32>,
        pub(crate) execution_start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) execution_end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) step_status: std::option::Option<crate::model::AutomationExecutionStatus>,
        pub(crate) response_code: std::option::Option<std::string::String>,
        pub(crate) inputs: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) outputs: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) response: std::option::Option<std::string::String>,
        pub(crate) failure_message: std::option::Option<std::string::String>,
        pub(crate) failure_details: std::option::Option<crate::model::FailureDetails>,
        pub(crate) step_execution_id: std::option::Option<std::string::String>,
        pub(crate) overridden_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) is_end: std::option::Option<bool>,
        pub(crate) next_step: std::option::Option<std::string::String>,
        pub(crate) is_critical: std::option::Option<bool>,
        pub(crate) valid_next_steps: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) targets: std::option::Option<std::vec::Vec<crate::model::Target>>,
        pub(crate) target_location: std::option::Option<crate::model::TargetLocation>,
    }
    impl Builder {
        /// <p>The name of this execution step.</p>
        pub fn step_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.step_name = Some(input.into());
            self
        }
        pub fn set_step_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.step_name = input;
            self
        }
        /// <p>The action this step performs. The action determines the behavior of the step.</p>
        pub fn action(mut self, input: impl Into<std::string::String>) -> Self {
            self.action = Some(input.into());
            self
        }
        pub fn set_action(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action = input;
            self
        }
        /// <p>The timeout seconds of the step.</p>
        pub fn timeout_seconds(mut self, input: i64) -> Self {
            self.timeout_seconds = Some(input);
            self
        }
        pub fn set_timeout_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.timeout_seconds = input;
            self
        }
        /// <p>The action to take if the step fails. The default value is Abort.</p>
        pub fn on_failure(mut self, input: impl Into<std::string::String>) -> Self {
            self.on_failure = Some(input.into());
            self
        }
        pub fn set_on_failure(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.on_failure = input;
            self
        }
        /// <p>The maximum number of tries to run the action of the step. The default value is 1.</p>
        pub fn max_attempts(mut self, input: i32) -> Self {
            self.max_attempts = Some(input);
            self
        }
        pub fn set_max_attempts(mut self, input: std::option::Option<i32>) -> Self {
            self.max_attempts = input;
            self
        }
        /// <p>If a step has begun execution, this contains the time the step started. If the step is in
        /// Pending status, this field is not populated.</p>
        pub fn execution_start_time(mut self, input: smithy_types::Instant) -> Self {
            self.execution_start_time = Some(input);
            self
        }
        pub fn set_execution_start_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.execution_start_time = input;
            self
        }
        /// <p>If a step has finished execution, this contains the time the execution ended. If the step
        /// has not yet concluded, this field is not populated.</p>
        pub fn execution_end_time(mut self, input: smithy_types::Instant) -> Self {
            self.execution_end_time = Some(input);
            self
        }
        pub fn set_execution_end_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.execution_end_time = input;
            self
        }
        /// <p>The execution status for this step.</p>
        pub fn step_status(mut self, input: crate::model::AutomationExecutionStatus) -> Self {
            self.step_status = Some(input);
            self
        }
        pub fn set_step_status(
            mut self,
            input: std::option::Option<crate::model::AutomationExecutionStatus>,
        ) -> Self {
            self.step_status = input;
            self
        }
        /// <p>The response code returned by the execution of the step.</p>
        pub fn response_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.response_code = Some(input.into());
            self
        }
        pub fn set_response_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.response_code = input;
            self
        }
        pub fn inputs(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.inputs.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.inputs = Some(hash_map);
            self
        }
        pub fn set_inputs(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inputs = input;
            self
        }
        pub fn outputs(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.outputs.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.outputs = Some(hash_map);
            self
        }
        pub fn set_outputs(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.outputs = input;
            self
        }
        /// <p>A message associated with the response code for an execution.</p>
        pub fn response(mut self, input: impl Into<std::string::String>) -> Self {
            self.response = Some(input.into());
            self
        }
        pub fn set_response(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.response = input;
            self
        }
        /// <p>If a step failed, this message explains why the execution failed.</p>
        pub fn failure_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_message = Some(input.into());
            self
        }
        pub fn set_failure_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_message = input;
            self
        }
        /// <p>Information about the Automation failure.</p>
        pub fn failure_details(mut self, input: crate::model::FailureDetails) -> Self {
            self.failure_details = Some(input);
            self
        }
        pub fn set_failure_details(
            mut self,
            input: std::option::Option<crate::model::FailureDetails>,
        ) -> Self {
            self.failure_details = input;
            self
        }
        /// <p>The unique ID of a step execution.</p>
        pub fn step_execution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.step_execution_id = Some(input.into());
            self
        }
        pub fn set_step_execution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.step_execution_id = input;
            self
        }
        pub fn overridden_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.overridden_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.overridden_parameters = Some(hash_map);
            self
        }
        pub fn set_overridden_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.overridden_parameters = input;
            self
        }
        /// <p>The flag which can be used to end automation no matter whether the step succeeds or
        /// fails.</p>
        pub fn is_end(mut self, input: bool) -> Self {
            self.is_end = Some(input);
            self
        }
        pub fn set_is_end(mut self, input: std::option::Option<bool>) -> Self {
            self.is_end = input;
            self
        }
        /// <p>The next step after the step succeeds.</p>
        pub fn next_step(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_step = Some(input.into());
            self
        }
        pub fn set_next_step(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_step = input;
            self
        }
        /// <p>The flag which can be used to help decide whether the failure of current step leads to the
        /// Automation failure.</p>
        pub fn is_critical(mut self, input: bool) -> Self {
            self.is_critical = Some(input);
            self
        }
        pub fn set_is_critical(mut self, input: std::option::Option<bool>) -> Self {
            self.is_critical = input;
            self
        }
        pub fn valid_next_steps(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.valid_next_steps.unwrap_or_default();
            v.push(input.into());
            self.valid_next_steps = Some(v);
            self
        }
        pub fn set_valid_next_steps(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.valid_next_steps = input;
            self
        }
        pub fn targets(mut self, input: impl Into<crate::model::Target>) -> Self {
            let mut v = self.targets.unwrap_or_default();
            v.push(input.into());
            self.targets = Some(v);
            self
        }
        pub fn set_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Target>>,
        ) -> Self {
            self.targets = input;
            self
        }
        /// <p>The combination of AWS Regions and accounts targeted by the current Automation
        /// execution.</p>
        pub fn target_location(mut self, input: crate::model::TargetLocation) -> Self {
            self.target_location = Some(input);
            self
        }
        pub fn set_target_location(
            mut self,
            input: std::option::Option<crate::model::TargetLocation>,
        ) -> Self {
            self.target_location = input;
            self
        }
        /// Consumes the builder and constructs a [`StepExecution`](crate::model::StepExecution)
        pub fn build(self) -> crate::model::StepExecution {
            crate::model::StepExecution {
                step_name: self.step_name,
                action: self.action,
                timeout_seconds: self.timeout_seconds,
                on_failure: self.on_failure,
                max_attempts: self.max_attempts,
                execution_start_time: self.execution_start_time,
                execution_end_time: self.execution_end_time,
                step_status: self.step_status,
                response_code: self.response_code,
                inputs: self.inputs,
                outputs: self.outputs,
                response: self.response,
                failure_message: self.failure_message,
                failure_details: self.failure_details,
                step_execution_id: self.step_execution_id,
                overridden_parameters: self.overridden_parameters,
                is_end: self.is_end,
                next_step: self.next_step,
                is_critical: self.is_critical,
                valid_next_steps: self.valid_next_steps,
                targets: self.targets,
                target_location: self.target_location,
            }
        }
    }
}
impl StepExecution {
    /// Creates a new builder-style object to manufacture [`StepExecution`](crate::model::StepExecution)
    pub fn builder() -> crate::model::step_execution::Builder {
        crate::model::step_execution::Builder::default()
    }
}

/// <p>Information about an Automation failure.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct FailureDetails {
    /// <p>The stage of the Automation execution when the failure occurred. The stages include the
    /// following: InputValidation, PreVerification, Invocation, PostVerification.</p>
    #[serde(rename = "FailureStage")]
    #[serde(default)]
    pub failure_stage: std::option::Option<std::string::String>,
    /// <p>The type of Automation failure. Failure types include the following: Action, Permission,
    /// Throttling, Verification, Internal.</p>
    #[serde(rename = "FailureType")]
    #[serde(default)]
    pub failure_type: std::option::Option<std::string::String>,
    /// <p>Detailed information about the Automation step failure.</p>
    #[serde(rename = "Details")]
    #[serde(default)]
    pub details: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
}
impl std::fmt::Debug for FailureDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FailureDetails");
        formatter.field("failure_stage", &self.failure_stage);
        formatter.field("failure_type", &self.failure_type);
        formatter.field("details", &self.details);
        formatter.finish()
    }
}
/// See [`FailureDetails`](crate::model::FailureDetails)
pub mod failure_details {
    /// A builder for [`FailureDetails`](crate::model::FailureDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) failure_stage: std::option::Option<std::string::String>,
        pub(crate) failure_type: std::option::Option<std::string::String>,
        pub(crate) details: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
    }
    impl Builder {
        /// <p>The stage of the Automation execution when the failure occurred. The stages include the
        /// following: InputValidation, PreVerification, Invocation, PostVerification.</p>
        pub fn failure_stage(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_stage = Some(input.into());
            self
        }
        pub fn set_failure_stage(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_stage = input;
            self
        }
        /// <p>The type of Automation failure. Failure types include the following: Action, Permission,
        /// Throttling, Verification, Internal.</p>
        pub fn failure_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_type = Some(input.into());
            self
        }
        pub fn set_failure_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.failure_type = input;
            self
        }
        pub fn details(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.details.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.details = Some(hash_map);
            self
        }
        pub fn set_details(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.details = input;
            self
        }
        /// Consumes the builder and constructs a [`FailureDetails`](crate::model::FailureDetails)
        pub fn build(self) -> crate::model::FailureDetails {
            crate::model::FailureDetails {
                failure_stage: self.failure_stage,
                failure_type: self.failure_type,
                details: self.details,
            }
        }
    }
}
impl FailureDetails {
    /// Creates a new builder-style object to manufacture [`FailureDetails`](crate::model::FailureDetails)
    pub fn builder() -> crate::model::failure_details::Builder {
        crate::model::failure_details::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutomationExecutionStatus {
    Approved,
    Cancelled,
    Cancelling,
    ChangeCalendarOverrideApproved,
    ChangeCalendarOverrideRejected,
    CompletedWithFailure,
    CompletedWithSuccess,
    Failed,
    Inprogress,
    Pending,
    PendingApproval,
    PendingChangeCalendarOverride,
    Rejected,
    RunbookInprogress,
    Scheduled,
    Success,
    Timedout,
    Waiting,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutomationExecutionStatus {
    fn from(s: &str) -> Self {
        match s {
            "Approved" => AutomationExecutionStatus::Approved,
            "Cancelled" => AutomationExecutionStatus::Cancelled,
            "Cancelling" => AutomationExecutionStatus::Cancelling,
            "ChangeCalendarOverrideApproved" => {
                AutomationExecutionStatus::ChangeCalendarOverrideApproved
            }
            "ChangeCalendarOverrideRejected" => {
                AutomationExecutionStatus::ChangeCalendarOverrideRejected
            }
            "CompletedWithFailure" => AutomationExecutionStatus::CompletedWithFailure,
            "CompletedWithSuccess" => AutomationExecutionStatus::CompletedWithSuccess,
            "Failed" => AutomationExecutionStatus::Failed,
            "InProgress" => AutomationExecutionStatus::Inprogress,
            "Pending" => AutomationExecutionStatus::Pending,
            "PendingApproval" => AutomationExecutionStatus::PendingApproval,
            "PendingChangeCalendarOverride" => {
                AutomationExecutionStatus::PendingChangeCalendarOverride
            }
            "Rejected" => AutomationExecutionStatus::Rejected,
            "RunbookInProgress" => AutomationExecutionStatus::RunbookInprogress,
            "Scheduled" => AutomationExecutionStatus::Scheduled,
            "Success" => AutomationExecutionStatus::Success,
            "TimedOut" => AutomationExecutionStatus::Timedout,
            "Waiting" => AutomationExecutionStatus::Waiting,
            other => AutomationExecutionStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutomationExecutionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(AutomationExecutionStatus::from(s))
    }
}
impl AutomationExecutionStatus {
    pub fn as_str(&self) -> &str {
        match self {
            AutomationExecutionStatus::Approved => "Approved",
            AutomationExecutionStatus::Cancelled => "Cancelled",
            AutomationExecutionStatus::Cancelling => "Cancelling",
            AutomationExecutionStatus::ChangeCalendarOverrideApproved => {
                "ChangeCalendarOverrideApproved"
            }
            AutomationExecutionStatus::ChangeCalendarOverrideRejected => {
                "ChangeCalendarOverrideRejected"
            }
            AutomationExecutionStatus::CompletedWithFailure => "CompletedWithFailure",
            AutomationExecutionStatus::CompletedWithSuccess => "CompletedWithSuccess",
            AutomationExecutionStatus::Failed => "Failed",
            AutomationExecutionStatus::Inprogress => "InProgress",
            AutomationExecutionStatus::Pending => "Pending",
            AutomationExecutionStatus::PendingApproval => "PendingApproval",
            AutomationExecutionStatus::PendingChangeCalendarOverride => {
                "PendingChangeCalendarOverride"
            }
            AutomationExecutionStatus::Rejected => "Rejected",
            AutomationExecutionStatus::RunbookInprogress => "RunbookInProgress",
            AutomationExecutionStatus::Scheduled => "Scheduled",
            AutomationExecutionStatus::Success => "Success",
            AutomationExecutionStatus::Timedout => "TimedOut",
            AutomationExecutionStatus::Waiting => "Waiting",
            AutomationExecutionStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for AutomationExecutionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for AutomationExecutionStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Information about a Session Manager connection to an instance.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct Session {
    /// <p>The ID of the session.</p>
    #[serde(rename = "SessionId")]
    #[serde(default)]
    pub session_id: std::option::Option<std::string::String>,
    /// <p>The instance that the Session Manager session connected to.</p>
    #[serde(rename = "Target")]
    #[serde(default)]
    pub target: std::option::Option<std::string::String>,
    /// <p>The status of the session. For example, "Connected" or "Terminated".</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::SessionStatus>,
    /// <p>The date and time, in ISO-8601 Extended format, when the session began.</p>
    #[serde(rename = "StartDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub start_date: std::option::Option<smithy_types::Instant>,
    /// <p>The date and time, in ISO-8601 Extended format, when the session was terminated.</p>
    #[serde(rename = "EndDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub end_date: std::option::Option<smithy_types::Instant>,
    /// <p>The name of the Session Manager SSM document used to define the parameters and plugin settings for the
    /// session. For example, <code>SSM-SessionManagerRunShell</code>.</p>
    #[serde(rename = "DocumentName")]
    #[serde(default)]
    pub document_name: std::option::Option<std::string::String>,
    /// <p>The ID of the AWS user account that started the session.</p>
    #[serde(rename = "Owner")]
    #[serde(default)]
    pub owner: std::option::Option<std::string::String>,
    /// <p>Reserved for future use.</p>
    #[serde(rename = "Details")]
    #[serde(default)]
    pub details: std::option::Option<std::string::String>,
    /// <p>Reserved for future use.</p>
    #[serde(rename = "OutputUrl")]
    #[serde(default)]
    pub output_url: std::option::Option<crate::model::SessionManagerOutputUrl>,
}
impl std::fmt::Debug for Session {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Session");
        formatter.field("session_id", &self.session_id);
        formatter.field("target", &self.target);
        formatter.field("status", &self.status);
        formatter.field("start_date", &self.start_date);
        formatter.field("end_date", &self.end_date);
        formatter.field("document_name", &self.document_name);
        formatter.field("owner", &self.owner);
        formatter.field("details", &self.details);
        formatter.field("output_url", &self.output_url);
        formatter.finish()
    }
}
/// See [`Session`](crate::model::Session)
pub mod session {
    /// A builder for [`Session`](crate::model::Session)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) session_id: std::option::Option<std::string::String>,
        pub(crate) target: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::SessionStatus>,
        pub(crate) start_date: std::option::Option<smithy_types::Instant>,
        pub(crate) end_date: std::option::Option<smithy_types::Instant>,
        pub(crate) document_name: std::option::Option<std::string::String>,
        pub(crate) owner: std::option::Option<std::string::String>,
        pub(crate) details: std::option::Option<std::string::String>,
        pub(crate) output_url: std::option::Option<crate::model::SessionManagerOutputUrl>,
    }
    impl Builder {
        /// <p>The ID of the session.</p>
        pub fn session_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.session_id = Some(input.into());
            self
        }
        pub fn set_session_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.session_id = input;
            self
        }
        /// <p>The instance that the Session Manager session connected to.</p>
        pub fn target(mut self, input: impl Into<std::string::String>) -> Self {
            self.target = Some(input.into());
            self
        }
        pub fn set_target(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target = input;
            self
        }
        /// <p>The status of the session. For example, "Connected" or "Terminated".</p>
        pub fn status(mut self, input: crate::model::SessionStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::SessionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The date and time, in ISO-8601 Extended format, when the session began.</p>
        pub fn start_date(mut self, input: smithy_types::Instant) -> Self {
            self.start_date = Some(input);
            self
        }
        pub fn set_start_date(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start_date = input;
            self
        }
        /// <p>The date and time, in ISO-8601 Extended format, when the session was terminated.</p>
        pub fn end_date(mut self, input: smithy_types::Instant) -> Self {
            self.end_date = Some(input);
            self
        }
        pub fn set_end_date(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.end_date = input;
            self
        }
        /// <p>The name of the Session Manager SSM document used to define the parameters and plugin settings for the
        /// session. For example, <code>SSM-SessionManagerRunShell</code>.</p>
        pub fn document_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_name = Some(input.into());
            self
        }
        pub fn set_document_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_name = input;
            self
        }
        /// <p>The ID of the AWS user account that started the session.</p>
        pub fn owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner = Some(input.into());
            self
        }
        pub fn set_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner = input;
            self
        }
        /// <p>Reserved for future use.</p>
        pub fn details(mut self, input: impl Into<std::string::String>) -> Self {
            self.details = Some(input.into());
            self
        }
        pub fn set_details(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.details = input;
            self
        }
        /// <p>Reserved for future use.</p>
        pub fn output_url(mut self, input: crate::model::SessionManagerOutputUrl) -> Self {
            self.output_url = Some(input);
            self
        }
        pub fn set_output_url(
            mut self,
            input: std::option::Option<crate::model::SessionManagerOutputUrl>,
        ) -> Self {
            self.output_url = input;
            self
        }
        /// Consumes the builder and constructs a [`Session`](crate::model::Session)
        pub fn build(self) -> crate::model::Session {
            crate::model::Session {
                session_id: self.session_id,
                target: self.target,
                status: self.status,
                start_date: self.start_date,
                end_date: self.end_date,
                document_name: self.document_name,
                owner: self.owner,
                details: self.details,
                output_url: self.output_url,
            }
        }
    }
}
impl Session {
    /// Creates a new builder-style object to manufacture [`Session`](crate::model::Session)
    pub fn builder() -> crate::model::session::Builder {
        crate::model::session::Builder::default()
    }
}

/// <p>Reserved for future use.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct SessionManagerOutputUrl {
    /// <p>Reserved for future use.</p>
    #[serde(rename = "S3OutputUrl")]
    #[serde(default)]
    pub s3_output_url: std::option::Option<std::string::String>,
    /// <p>Reserved for future use.</p>
    #[serde(rename = "CloudWatchOutputUrl")]
    #[serde(default)]
    pub cloud_watch_output_url: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SessionManagerOutputUrl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SessionManagerOutputUrl");
        formatter.field("s3_output_url", &self.s3_output_url);
        formatter.field("cloud_watch_output_url", &self.cloud_watch_output_url);
        formatter.finish()
    }
}
/// See [`SessionManagerOutputUrl`](crate::model::SessionManagerOutputUrl)
pub mod session_manager_output_url {
    /// A builder for [`SessionManagerOutputUrl`](crate::model::SessionManagerOutputUrl)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_output_url: std::option::Option<std::string::String>,
        pub(crate) cloud_watch_output_url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Reserved for future use.</p>
        pub fn s3_output_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_url = Some(input.into());
            self
        }
        pub fn set_s3_output_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_url = input;
            self
        }
        /// <p>Reserved for future use.</p>
        pub fn cloud_watch_output_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.cloud_watch_output_url = Some(input.into());
            self
        }
        pub fn set_cloud_watch_output_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cloud_watch_output_url = input;
            self
        }
        /// Consumes the builder and constructs a [`SessionManagerOutputUrl`](crate::model::SessionManagerOutputUrl)
        pub fn build(self) -> crate::model::SessionManagerOutputUrl {
            crate::model::SessionManagerOutputUrl {
                s3_output_url: self.s3_output_url,
                cloud_watch_output_url: self.cloud_watch_output_url,
            }
        }
    }
}
impl SessionManagerOutputUrl {
    /// Creates a new builder-style object to manufacture [`SessionManagerOutputUrl`](crate::model::SessionManagerOutputUrl)
    pub fn builder() -> crate::model::session_manager_output_url::Builder {
        crate::model::session_manager_output_url::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SessionStatus {
    Connected,
    Connecting,
    Disconnected,
    Failed,
    Terminated,
    Terminating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SessionStatus {
    fn from(s: &str) -> Self {
        match s {
            "Connected" => SessionStatus::Connected,
            "Connecting" => SessionStatus::Connecting,
            "Disconnected" => SessionStatus::Disconnected,
            "Failed" => SessionStatus::Failed,
            "Terminated" => SessionStatus::Terminated,
            "Terminating" => SessionStatus::Terminating,
            other => SessionStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SessionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(SessionStatus::from(s))
    }
}
impl SessionStatus {
    pub fn as_str(&self) -> &str {
        match self {
            SessionStatus::Connected => "Connected",
            SessionStatus::Connecting => "Connecting",
            SessionStatus::Disconnected => "Disconnected",
            SessionStatus::Failed => "Failed",
            SessionStatus::Terminated => "Terminated",
            SessionStatus::Terminating => "Terminating",
            SessionStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for SessionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for SessionStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Describes a filter for Session Manager information.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct SessionFilter {
    /// <p>The name of the filter.</p>
    #[serde(rename = "key")]
    #[serde(default)]
    pub key: std::option::Option<crate::model::SessionFilterKey>,
    /// <p>The filter value. Valid values for each filter key are as follows:</p>
    /// <ul>
    /// <li>
    /// <p>InvokedAfter: Specify a timestamp to limit your results. For example, specify
    /// 2018-08-29T00:00:00Z to see sessions that started August 29, 2018, and later.</p>
    /// </li>
    /// <li>
    /// <p>InvokedBefore: Specify a timestamp to limit your results. For example, specify
    /// 2018-08-29T00:00:00Z to see sessions that started before August 29, 2018.</p>
    /// </li>
    /// <li>
    /// <p>Target: Specify an instance to which session connections have been made.</p>
    /// </li>
    /// <li>
    /// <p>Owner: Specify an AWS user account to see a list of sessions started by that user.</p>
    /// </li>
    /// <li>
    /// <p>Status: Specify a valid session status to see a list of all sessions with that status.
    /// Status values you can specify include:</p>
    /// <ul>
    /// <li>
    /// <p>Connected</p>
    /// </li>
    /// <li>
    /// <p>Connecting</p>
    /// </li>
    /// <li>
    /// <p>Disconnected</p>
    /// </li>
    /// <li>
    /// <p>Terminated</p>
    /// </li>
    /// <li>
    /// <p>Terminating</p>
    /// </li>
    /// <li>
    /// <p>Failed</p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>SessionId: Specify a session ID to return details about the session.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "value")]
    #[serde(default)]
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SessionFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SessionFilter");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`SessionFilter`](crate::model::SessionFilter)
pub mod session_filter {
    /// A builder for [`SessionFilter`](crate::model::SessionFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<crate::model::SessionFilterKey>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the filter.</p>
        pub fn key(mut self, input: crate::model::SessionFilterKey) -> Self {
            self.key = Some(input);
            self
        }
        pub fn set_key(
            mut self,
            input: std::option::Option<crate::model::SessionFilterKey>,
        ) -> Self {
            self.key = input;
            self
        }
        /// <p>The filter value. Valid values for each filter key are as follows:</p>
        /// <ul>
        /// <li>
        /// <p>InvokedAfter: Specify a timestamp to limit your results. For example, specify
        /// 2018-08-29T00:00:00Z to see sessions that started August 29, 2018, and later.</p>
        /// </li>
        /// <li>
        /// <p>InvokedBefore: Specify a timestamp to limit your results. For example, specify
        /// 2018-08-29T00:00:00Z to see sessions that started before August 29, 2018.</p>
        /// </li>
        /// <li>
        /// <p>Target: Specify an instance to which session connections have been made.</p>
        /// </li>
        /// <li>
        /// <p>Owner: Specify an AWS user account to see a list of sessions started by that user.</p>
        /// </li>
        /// <li>
        /// <p>Status: Specify a valid session status to see a list of all sessions with that status.
        /// Status values you can specify include:</p>
        /// <ul>
        /// <li>
        /// <p>Connected</p>
        /// </li>
        /// <li>
        /// <p>Connecting</p>
        /// </li>
        /// <li>
        /// <p>Disconnected</p>
        /// </li>
        /// <li>
        /// <p>Terminated</p>
        /// </li>
        /// <li>
        /// <p>Terminating</p>
        /// </li>
        /// <li>
        /// <p>Failed</p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>SessionId: Specify a session ID to return details about the session.</p>
        /// </li>
        /// </ul>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`SessionFilter`](crate::model::SessionFilter)
        pub fn build(self) -> crate::model::SessionFilter {
            crate::model::SessionFilter {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl SessionFilter {
    /// Creates a new builder-style object to manufacture [`SessionFilter`](crate::model::SessionFilter)
    pub fn builder() -> crate::model::session_filter::Builder {
        crate::model::session_filter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SessionFilterKey {
    InvokedAfter,
    InvokedBefore,
    Owner,
    SessionId,
    Status,
    TargetId,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SessionFilterKey {
    fn from(s: &str) -> Self {
        match s {
            "InvokedAfter" => SessionFilterKey::InvokedAfter,
            "InvokedBefore" => SessionFilterKey::InvokedBefore,
            "Owner" => SessionFilterKey::Owner,
            "SessionId" => SessionFilterKey::SessionId,
            "Status" => SessionFilterKey::Status,
            "Target" => SessionFilterKey::TargetId,
            other => SessionFilterKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SessionFilterKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(SessionFilterKey::from(s))
    }
}
impl SessionFilterKey {
    pub fn as_str(&self) -> &str {
        match self {
            SessionFilterKey::InvokedAfter => "InvokedAfter",
            SessionFilterKey::InvokedBefore => "InvokedBefore",
            SessionFilterKey::Owner => "Owner",
            SessionFilterKey::SessionId => "SessionId",
            SessionFilterKey::Status => "Status",
            SessionFilterKey::TargetId => "Target",
            SessionFilterKey::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for SessionFilterKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for SessionFilterKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SessionState {
    Active,
    History,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SessionState {
    fn from(s: &str) -> Self {
        match s {
            "Active" => SessionState::Active,
            "History" => SessionState::History,
            other => SessionState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SessionState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(SessionState::from(s))
    }
}
impl SessionState {
    pub fn as_str(&self) -> &str {
        match self {
            SessionState::Active => "Active",
            SessionState::History => "History",
            SessionState::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for SessionState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for SessionState {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PatchSet {
    Application,
    Os,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PatchSet {
    fn from(s: &str) -> Self {
        match s {
            "APPLICATION" => PatchSet::Application,
            "OS" => PatchSet::Os,
            other => PatchSet::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PatchSet {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(PatchSet::from(s))
    }
}
impl PatchSet {
    pub fn as_str(&self) -> &str {
        match self {
            PatchSet::Application => "APPLICATION",
            PatchSet::Os => "OS",
            PatchSet::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for PatchSet {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for PatchSet {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PatchProperty {
    PatchClassification,
    PatchMsrcSeverity,
    PatchPriority,
    Product,
    PatchProductFamily,
    PatchSeverity,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PatchProperty {
    fn from(s: &str) -> Self {
        match s {
            "CLASSIFICATION" => PatchProperty::PatchClassification,
            "MSRC_SEVERITY" => PatchProperty::PatchMsrcSeverity,
            "PRIORITY" => PatchProperty::PatchPriority,
            "PRODUCT" => PatchProperty::Product,
            "PRODUCT_FAMILY" => PatchProperty::PatchProductFamily,
            "SEVERITY" => PatchProperty::PatchSeverity,
            other => PatchProperty::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PatchProperty {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(PatchProperty::from(s))
    }
}
impl PatchProperty {
    pub fn as_str(&self) -> &str {
        match self {
            PatchProperty::PatchClassification => "CLASSIFICATION",
            PatchProperty::PatchMsrcSeverity => "MSRC_SEVERITY",
            PatchProperty::PatchPriority => "PRIORITY",
            PatchProperty::Product => "PRODUCT",
            PatchProperty::PatchProductFamily => "PRODUCT_FAMILY",
            PatchProperty::PatchSeverity => "SEVERITY",
            PatchProperty::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for PatchProperty {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for PatchProperty {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>The mapping between a patch group and the patch baseline the patch group is registered
/// with.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PatchGroupPatchBaselineMapping {
    /// <p>The name of the patch group registered with the patch baseline.</p>
    #[serde(rename = "PatchGroup")]
    #[serde(default)]
    pub patch_group: std::option::Option<std::string::String>,
    /// <p>The patch baseline the patch group is registered with.</p>
    #[serde(rename = "BaselineIdentity")]
    #[serde(default)]
    pub baseline_identity: std::option::Option<crate::model::PatchBaselineIdentity>,
}
impl std::fmt::Debug for PatchGroupPatchBaselineMapping {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PatchGroupPatchBaselineMapping");
        formatter.field("patch_group", &self.patch_group);
        formatter.field("baseline_identity", &self.baseline_identity);
        formatter.finish()
    }
}
/// See [`PatchGroupPatchBaselineMapping`](crate::model::PatchGroupPatchBaselineMapping)
pub mod patch_group_patch_baseline_mapping {
    /// A builder for [`PatchGroupPatchBaselineMapping`](crate::model::PatchGroupPatchBaselineMapping)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) patch_group: std::option::Option<std::string::String>,
        pub(crate) baseline_identity: std::option::Option<crate::model::PatchBaselineIdentity>,
    }
    impl Builder {
        /// <p>The name of the patch group registered with the patch baseline.</p>
        pub fn patch_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.patch_group = Some(input.into());
            self
        }
        pub fn set_patch_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.patch_group = input;
            self
        }
        /// <p>The patch baseline the patch group is registered with.</p>
        pub fn baseline_identity(mut self, input: crate::model::PatchBaselineIdentity) -> Self {
            self.baseline_identity = Some(input);
            self
        }
        pub fn set_baseline_identity(
            mut self,
            input: std::option::Option<crate::model::PatchBaselineIdentity>,
        ) -> Self {
            self.baseline_identity = input;
            self
        }
        /// Consumes the builder and constructs a [`PatchGroupPatchBaselineMapping`](crate::model::PatchGroupPatchBaselineMapping)
        pub fn build(self) -> crate::model::PatchGroupPatchBaselineMapping {
            crate::model::PatchGroupPatchBaselineMapping {
                patch_group: self.patch_group,
                baseline_identity: self.baseline_identity,
            }
        }
    }
}
impl PatchGroupPatchBaselineMapping {
    /// Creates a new builder-style object to manufacture [`PatchGroupPatchBaselineMapping`](crate::model::PatchGroupPatchBaselineMapping)
    pub fn builder() -> crate::model::patch_group_patch_baseline_mapping::Builder {
        crate::model::patch_group_patch_baseline_mapping::Builder::default()
    }
}

/// <p>Defines the basic information about a patch baseline.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PatchBaselineIdentity {
    /// <p>The ID of the patch baseline.</p>
    #[serde(rename = "BaselineId")]
    #[serde(default)]
    pub baseline_id: std::option::Option<std::string::String>,
    /// <p>The name of the patch baseline.</p>
    #[serde(rename = "BaselineName")]
    #[serde(default)]
    pub baseline_name: std::option::Option<std::string::String>,
    /// <p>Defines the operating system the patch baseline applies to. The Default value is WINDOWS.
    /// </p>
    #[serde(rename = "OperatingSystem")]
    #[serde(default)]
    pub operating_system: std::option::Option<crate::model::OperatingSystem>,
    /// <p>The description of the patch baseline.</p>
    #[serde(rename = "BaselineDescription")]
    #[serde(default)]
    pub baseline_description: std::option::Option<std::string::String>,
    /// <p>Whether this is the default baseline. Note that Systems Manager supports creating multiple default
    /// patch baselines. For example, you can create a default patch baseline for each operating
    /// system.</p>
    #[serde(rename = "DefaultBaseline")]
    #[serde(default)]
    pub default_baseline: bool,
}
impl std::fmt::Debug for PatchBaselineIdentity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PatchBaselineIdentity");
        formatter.field("baseline_id", &self.baseline_id);
        formatter.field("baseline_name", &self.baseline_name);
        formatter.field("operating_system", &self.operating_system);
        formatter.field("baseline_description", &self.baseline_description);
        formatter.field("default_baseline", &self.default_baseline);
        formatter.finish()
    }
}
/// See [`PatchBaselineIdentity`](crate::model::PatchBaselineIdentity)
pub mod patch_baseline_identity {
    /// A builder for [`PatchBaselineIdentity`](crate::model::PatchBaselineIdentity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) baseline_id: std::option::Option<std::string::String>,
        pub(crate) baseline_name: std::option::Option<std::string::String>,
        pub(crate) operating_system: std::option::Option<crate::model::OperatingSystem>,
        pub(crate) baseline_description: std::option::Option<std::string::String>,
        pub(crate) default_baseline: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The ID of the patch baseline.</p>
        pub fn baseline_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.baseline_id = Some(input.into());
            self
        }
        pub fn set_baseline_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.baseline_id = input;
            self
        }
        /// <p>The name of the patch baseline.</p>
        pub fn baseline_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.baseline_name = Some(input.into());
            self
        }
        pub fn set_baseline_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.baseline_name = input;
            self
        }
        /// <p>Defines the operating system the patch baseline applies to. The Default value is WINDOWS.
        /// </p>
        pub fn operating_system(mut self, input: crate::model::OperatingSystem) -> Self {
            self.operating_system = Some(input);
            self
        }
        pub fn set_operating_system(
            mut self,
            input: std::option::Option<crate::model::OperatingSystem>,
        ) -> Self {
            self.operating_system = input;
            self
        }
        /// <p>The description of the patch baseline.</p>
        pub fn baseline_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.baseline_description = Some(input.into());
            self
        }
        pub fn set_baseline_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.baseline_description = input;
            self
        }
        /// <p>Whether this is the default baseline. Note that Systems Manager supports creating multiple default
        /// patch baselines. For example, you can create a default patch baseline for each operating
        /// system.</p>
        pub fn default_baseline(mut self, input: bool) -> Self {
            self.default_baseline = Some(input);
            self
        }
        pub fn set_default_baseline(mut self, input: std::option::Option<bool>) -> Self {
            self.default_baseline = input;
            self
        }
        /// Consumes the builder and constructs a [`PatchBaselineIdentity`](crate::model::PatchBaselineIdentity)
        pub fn build(self) -> crate::model::PatchBaselineIdentity {
            crate::model::PatchBaselineIdentity {
                baseline_id: self.baseline_id,
                baseline_name: self.baseline_name,
                operating_system: self.operating_system,
                baseline_description: self.baseline_description,
                default_baseline: self.default_baseline.unwrap_or_default(),
            }
        }
    }
}
impl PatchBaselineIdentity {
    /// Creates a new builder-style object to manufacture [`PatchBaselineIdentity`](crate::model::PatchBaselineIdentity)
    pub fn builder() -> crate::model::patch_baseline_identity::Builder {
        crate::model::patch_baseline_identity::Builder::default()
    }
}

/// <p>Defines a filter used in Patch Manager APIs.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PatchOrchestratorFilter {
    /// <p>The key for the filter.</p>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The value for the filter.</p>
    #[serde(rename = "Values")]
    #[serde(default)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for PatchOrchestratorFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PatchOrchestratorFilter");
        formatter.field("key", &self.key);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`PatchOrchestratorFilter`](crate::model::PatchOrchestratorFilter)
pub mod patch_orchestrator_filter {
    /// A builder for [`PatchOrchestratorFilter`](crate::model::PatchOrchestratorFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The key for the filter.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`PatchOrchestratorFilter`](crate::model::PatchOrchestratorFilter)
        pub fn build(self) -> crate::model::PatchOrchestratorFilter {
            crate::model::PatchOrchestratorFilter {
                key: self.key,
                values: self.values,
            }
        }
    }
}
impl PatchOrchestratorFilter {
    /// Creates a new builder-style object to manufacture [`PatchOrchestratorFilter`](crate::model::PatchOrchestratorFilter)
    pub fn builder() -> crate::model::patch_orchestrator_filter::Builder {
        crate::model::patch_orchestrator_filter::Builder::default()
    }
}

/// <p>Metadata includes information like the ARN of the last user and the date/time the parameter
/// was last used.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ParameterMetadata {
    /// <p>The parameter name.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of parameter. Valid parameter types include the following: <code>String</code>,
    /// <code>StringList</code>, and <code>SecureString</code>.</p>
    #[serde(rename = "Type")]
    #[serde(default)]
    pub r#type: std::option::Option<crate::model::ParameterType>,
    /// <p>The ID of the query key used for this parameter.</p>
    #[serde(rename = "KeyId")]
    #[serde(default)]
    pub key_id: std::option::Option<std::string::String>,
    /// <p>Date the parameter was last changed or updated.</p>
    #[serde(rename = "LastModifiedDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_date: std::option::Option<smithy_types::Instant>,
    /// <p>Amazon Resource Name (ARN) of the AWS user who last changed the parameter.</p>
    #[serde(rename = "LastModifiedUser")]
    #[serde(default)]
    pub last_modified_user: std::option::Option<std::string::String>,
    /// <p>Description of the parameter actions.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>A parameter name can include only the following letters and symbols.</p>
    /// <p>a-zA-Z0-9_.-</p>
    #[serde(rename = "AllowedPattern")]
    #[serde(default)]
    pub allowed_pattern: std::option::Option<std::string::String>,
    /// <p>The parameter version.</p>
    #[serde(rename = "Version")]
    #[serde(default)]
    pub version: i64,
    /// <p>The parameter tier.</p>
    #[serde(rename = "Tier")]
    #[serde(default)]
    pub tier: std::option::Option<crate::model::ParameterTier>,
    /// <p>A list of policies associated with a parameter.</p>
    #[serde(rename = "Policies")]
    #[serde(default)]
    pub policies: std::option::Option<std::vec::Vec<crate::model::ParameterInlinePolicy>>,
    /// <p>The data type of the parameter, such as <code>text</code> or <code>aws:ec2:image</code>. The
    /// default is <code>text</code>.</p>
    #[serde(rename = "DataType")]
    #[serde(default)]
    pub data_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ParameterMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParameterMetadata");
        formatter.field("name", &self.name);
        formatter.field("r#type", &self.r#type);
        formatter.field("key_id", &self.key_id);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("last_modified_user", &self.last_modified_user);
        formatter.field("description", &self.description);
        formatter.field("allowed_pattern", &self.allowed_pattern);
        formatter.field("version", &self.version);
        formatter.field("tier", &self.tier);
        formatter.field("policies", &self.policies);
        formatter.field("data_type", &self.data_type);
        formatter.finish()
    }
}
/// See [`ParameterMetadata`](crate::model::ParameterMetadata)
pub mod parameter_metadata {
    /// A builder for [`ParameterMetadata`](crate::model::ParameterMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ParameterType>,
        pub(crate) key_id: std::option::Option<std::string::String>,
        pub(crate) last_modified_date: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_user: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) allowed_pattern: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<i64>,
        pub(crate) tier: std::option::Option<crate::model::ParameterTier>,
        pub(crate) policies:
            std::option::Option<std::vec::Vec<crate::model::ParameterInlinePolicy>>,
        pub(crate) data_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The parameter name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of parameter. Valid parameter types include the following: <code>String</code>,
        /// <code>StringList</code>, and <code>SecureString</code>.</p>
        pub fn r#type(mut self, input: crate::model::ParameterType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::ParameterType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The ID of the query key used for this parameter.</p>
        pub fn key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_id = Some(input.into());
            self
        }
        pub fn set_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_id = input;
            self
        }
        /// <p>Date the parameter was last changed or updated.</p>
        pub fn last_modified_date(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_date = Some(input);
            self
        }
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>Amazon Resource Name (ARN) of the AWS user who last changed the parameter.</p>
        pub fn last_modified_user(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_user = Some(input.into());
            self
        }
        pub fn set_last_modified_user(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_user = input;
            self
        }
        /// <p>Description of the parameter actions.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>A parameter name can include only the following letters and symbols.</p>
        /// <p>a-zA-Z0-9_.-</p>
        pub fn allowed_pattern(mut self, input: impl Into<std::string::String>) -> Self {
            self.allowed_pattern = Some(input.into());
            self
        }
        pub fn set_allowed_pattern(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.allowed_pattern = input;
            self
        }
        /// <p>The parameter version.</p>
        pub fn version(mut self, input: i64) -> Self {
            self.version = Some(input);
            self
        }
        pub fn set_version(mut self, input: std::option::Option<i64>) -> Self {
            self.version = input;
            self
        }
        /// <p>The parameter tier.</p>
        pub fn tier(mut self, input: crate::model::ParameterTier) -> Self {
            self.tier = Some(input);
            self
        }
        pub fn set_tier(mut self, input: std::option::Option<crate::model::ParameterTier>) -> Self {
            self.tier = input;
            self
        }
        pub fn policies(mut self, input: impl Into<crate::model::ParameterInlinePolicy>) -> Self {
            let mut v = self.policies.unwrap_or_default();
            v.push(input.into());
            self.policies = Some(v);
            self
        }
        pub fn set_policies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ParameterInlinePolicy>>,
        ) -> Self {
            self.policies = input;
            self
        }
        /// <p>The data type of the parameter, such as <code>text</code> or <code>aws:ec2:image</code>. The
        /// default is <code>text</code>.</p>
        pub fn data_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_type = Some(input.into());
            self
        }
        pub fn set_data_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterMetadata`](crate::model::ParameterMetadata)
        pub fn build(self) -> crate::model::ParameterMetadata {
            crate::model::ParameterMetadata {
                name: self.name,
                r#type: self.r#type,
                key_id: self.key_id,
                last_modified_date: self.last_modified_date,
                last_modified_user: self.last_modified_user,
                description: self.description,
                allowed_pattern: self.allowed_pattern,
                version: self.version.unwrap_or_default(),
                tier: self.tier,
                policies: self.policies,
                data_type: self.data_type,
            }
        }
    }
}
impl ParameterMetadata {
    /// Creates a new builder-style object to manufacture [`ParameterMetadata`](crate::model::ParameterMetadata)
    pub fn builder() -> crate::model::parameter_metadata::Builder {
        crate::model::parameter_metadata::Builder::default()
    }
}

/// <p>This data type is deprecated. Instead, use <a>ParameterStringFilter</a>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ParametersFilter {
    /// <p>The name of the filter.</p>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<crate::model::ParametersFilterKey>,
    /// <p>The filter values.</p>
    #[serde(rename = "Values")]
    #[serde(default)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for ParametersFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParametersFilter");
        formatter.field("key", &self.key);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`ParametersFilter`](crate::model::ParametersFilter)
pub mod parameters_filter {
    /// A builder for [`ParametersFilter`](crate::model::ParametersFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<crate::model::ParametersFilterKey>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the filter.</p>
        pub fn key(mut self, input: crate::model::ParametersFilterKey) -> Self {
            self.key = Some(input);
            self
        }
        pub fn set_key(
            mut self,
            input: std::option::Option<crate::model::ParametersFilterKey>,
        ) -> Self {
            self.key = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`ParametersFilter`](crate::model::ParametersFilter)
        pub fn build(self) -> crate::model::ParametersFilter {
            crate::model::ParametersFilter {
                key: self.key,
                values: self.values,
            }
        }
    }
}
impl ParametersFilter {
    /// Creates a new builder-style object to manufacture [`ParametersFilter`](crate::model::ParametersFilter)
    pub fn builder() -> crate::model::parameters_filter::Builder {
        crate::model::parameters_filter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ParametersFilterKey {
    KeyId,
    Name,
    Type,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ParametersFilterKey {
    fn from(s: &str) -> Self {
        match s {
            "KeyId" => ParametersFilterKey::KeyId,
            "Name" => ParametersFilterKey::Name,
            "Type" => ParametersFilterKey::Type,
            other => ParametersFilterKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ParametersFilterKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ParametersFilterKey::from(s))
    }
}
impl ParametersFilterKey {
    pub fn as_str(&self) -> &str {
        match self {
            ParametersFilterKey::KeyId => "KeyId",
            ParametersFilterKey::Name => "Name",
            ParametersFilterKey::Type => "Type",
            ParametersFilterKey::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ParametersFilterKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ParametersFilterKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>A count of OpsItems.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsItemSummary {
    /// <p>The Amazon Resource Name (ARN) of the IAM entity that created the OpsItem.</p>
    #[serde(rename = "CreatedBy")]
    #[serde(default)]
    pub created_by: std::option::Option<std::string::String>,
    /// <p>The date and time the OpsItem was created.</p>
    #[serde(rename = "CreatedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub created_time: std::option::Option<smithy_types::Instant>,
    /// <p>The Amazon Resource Name (ARN) of the IAM entity that created the OpsItem.</p>
    #[serde(rename = "LastModifiedBy")]
    #[serde(default)]
    pub last_modified_by: std::option::Option<std::string::String>,
    /// <p>The date and time the OpsItem was last updated.</p>
    #[serde(rename = "LastModifiedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The importance of this OpsItem in relation to other OpsItems in the system.</p>
    #[serde(rename = "Priority")]
    #[serde(default)]
    pub priority: std::option::Option<i32>,
    /// <p>The impacted AWS resource.</p>
    #[serde(rename = "Source")]
    #[serde(default)]
    pub source: std::option::Option<std::string::String>,
    /// <p>The OpsItem status. Status can be <code>Open</code>, <code>In Progress</code>, or
    /// <code>Resolved</code>.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::OpsItemStatus>,
    /// <p>The ID of the OpsItem.</p>
    #[serde(rename = "OpsItemId")]
    #[serde(default)]
    pub ops_item_id: std::option::Option<std::string::String>,
    /// <p>A short heading that describes the nature of the OpsItem and the impacted resource.</p>
    #[serde(rename = "Title")]
    #[serde(default)]
    pub title: std::option::Option<std::string::String>,
    /// <p>Operational data is custom data that provides useful reference details about the OpsItem.
    /// </p>
    #[serde(rename = "OperationalData")]
    #[serde(default)]
    pub operational_data: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::OpsItemDataValue>,
    >,
    /// <p>A list of OpsItems by category.</p>
    #[serde(rename = "Category")]
    #[serde(default)]
    pub category: std::option::Option<std::string::String>,
    /// <p>A list of OpsItems by severity.</p>
    #[serde(rename = "Severity")]
    #[serde(default)]
    pub severity: std::option::Option<std::string::String>,
    /// <p>The type of OpsItem. Currently, the only valid values are <code>/aws/changerequest</code>
    /// and <code>/aws/issue</code>.</p>
    #[serde(rename = "OpsItemType")]
    #[serde(default)]
    pub ops_item_type: std::option::Option<std::string::String>,
    /// <p>The time a runbook workflow started. Currently reported only for the OpsItem type
    /// <code>/aws/changerequest</code>.</p>
    #[serde(rename = "ActualStartTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub actual_start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time a runbook workflow ended. Currently reported only for the OpsItem type
    /// <code>/aws/changerequest</code>.</p>
    #[serde(rename = "ActualEndTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub actual_end_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time specified in a change request for a runbook workflow to start. Currently supported
    /// only for the OpsItem type <code>/aws/changerequest</code>.</p>
    #[serde(rename = "PlannedStartTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub planned_start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time specified in a change request for a runbook workflow to end. Currently supported
    /// only for the OpsItem type <code>/aws/changerequest</code>.</p>
    #[serde(rename = "PlannedEndTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub planned_end_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for OpsItemSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsItemSummary");
        formatter.field("created_by", &self.created_by);
        formatter.field("created_time", &self.created_time);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("priority", &self.priority);
        formatter.field("source", &self.source);
        formatter.field("status", &self.status);
        formatter.field("ops_item_id", &self.ops_item_id);
        formatter.field("title", &self.title);
        formatter.field("operational_data", &self.operational_data);
        formatter.field("category", &self.category);
        formatter.field("severity", &self.severity);
        formatter.field("ops_item_type", &self.ops_item_type);
        formatter.field("actual_start_time", &self.actual_start_time);
        formatter.field("actual_end_time", &self.actual_end_time);
        formatter.field("planned_start_time", &self.planned_start_time);
        formatter.field("planned_end_time", &self.planned_end_time);
        formatter.finish()
    }
}
/// See [`OpsItemSummary`](crate::model::OpsItemSummary)
pub mod ops_item_summary {
    /// A builder for [`OpsItemSummary`](crate::model::OpsItemSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_by: std::option::Option<std::string::String>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) priority: std::option::Option<i32>,
        pub(crate) source: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::OpsItemStatus>,
        pub(crate) ops_item_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) operational_data: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::OpsItemDataValue>,
        >,
        pub(crate) category: std::option::Option<std::string::String>,
        pub(crate) severity: std::option::Option<std::string::String>,
        pub(crate) ops_item_type: std::option::Option<std::string::String>,
        pub(crate) actual_start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) actual_end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) planned_start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) planned_end_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the IAM entity that created the OpsItem.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>The date and time the OpsItem was created.</p>
        pub fn created_time(mut self, input: smithy_types::Instant) -> Self {
            self.created_time = Some(input);
            self
        }
        pub fn set_created_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM entity that created the OpsItem.</p>
        pub fn last_modified_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_by = Some(input.into());
            self
        }
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// <p>The date and time the OpsItem was last updated.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The importance of this OpsItem in relation to other OpsItems in the system.</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input;
            self
        }
        /// <p>The impacted AWS resource.</p>
        pub fn source(mut self, input: impl Into<std::string::String>) -> Self {
            self.source = Some(input.into());
            self
        }
        pub fn set_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source = input;
            self
        }
        /// <p>The OpsItem status. Status can be <code>Open</code>, <code>In Progress</code>, or
        /// <code>Resolved</code>.</p>
        pub fn status(mut self, input: crate::model::OpsItemStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OpsItemStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The ID of the OpsItem.</p>
        pub fn ops_item_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ops_item_id = Some(input.into());
            self
        }
        pub fn set_ops_item_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ops_item_id = input;
            self
        }
        /// <p>A short heading that describes the nature of the OpsItem and the impacted resource.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        pub fn operational_data(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::OpsItemDataValue>,
        ) -> Self {
            let mut hash_map = self.operational_data.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.operational_data = Some(hash_map);
            self
        }
        pub fn set_operational_data(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::OpsItemDataValue>,
            >,
        ) -> Self {
            self.operational_data = input;
            self
        }
        /// <p>A list of OpsItems by category.</p>
        pub fn category(mut self, input: impl Into<std::string::String>) -> Self {
            self.category = Some(input.into());
            self
        }
        pub fn set_category(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.category = input;
            self
        }
        /// <p>A list of OpsItems by severity.</p>
        pub fn severity(mut self, input: impl Into<std::string::String>) -> Self {
            self.severity = Some(input.into());
            self
        }
        pub fn set_severity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.severity = input;
            self
        }
        /// <p>The type of OpsItem. Currently, the only valid values are <code>/aws/changerequest</code>
        /// and <code>/aws/issue</code>.</p>
        pub fn ops_item_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.ops_item_type = Some(input.into());
            self
        }
        pub fn set_ops_item_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ops_item_type = input;
            self
        }
        /// <p>The time a runbook workflow started. Currently reported only for the OpsItem type
        /// <code>/aws/changerequest</code>.</p>
        pub fn actual_start_time(mut self, input: smithy_types::Instant) -> Self {
            self.actual_start_time = Some(input);
            self
        }
        pub fn set_actual_start_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.actual_start_time = input;
            self
        }
        /// <p>The time a runbook workflow ended. Currently reported only for the OpsItem type
        /// <code>/aws/changerequest</code>.</p>
        pub fn actual_end_time(mut self, input: smithy_types::Instant) -> Self {
            self.actual_end_time = Some(input);
            self
        }
        pub fn set_actual_end_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.actual_end_time = input;
            self
        }
        /// <p>The time specified in a change request for a runbook workflow to start. Currently supported
        /// only for the OpsItem type <code>/aws/changerequest</code>.</p>
        pub fn planned_start_time(mut self, input: smithy_types::Instant) -> Self {
            self.planned_start_time = Some(input);
            self
        }
        pub fn set_planned_start_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.planned_start_time = input;
            self
        }
        /// <p>The time specified in a change request for a runbook workflow to end. Currently supported
        /// only for the OpsItem type <code>/aws/changerequest</code>.</p>
        pub fn planned_end_time(mut self, input: smithy_types::Instant) -> Self {
            self.planned_end_time = Some(input);
            self
        }
        pub fn set_planned_end_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.planned_end_time = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsItemSummary`](crate::model::OpsItemSummary)
        pub fn build(self) -> crate::model::OpsItemSummary {
            crate::model::OpsItemSummary {
                created_by: self.created_by,
                created_time: self.created_time,
                last_modified_by: self.last_modified_by,
                last_modified_time: self.last_modified_time,
                priority: self.priority,
                source: self.source,
                status: self.status,
                ops_item_id: self.ops_item_id,
                title: self.title,
                operational_data: self.operational_data,
                category: self.category,
                severity: self.severity,
                ops_item_type: self.ops_item_type,
                actual_start_time: self.actual_start_time,
                actual_end_time: self.actual_end_time,
                planned_start_time: self.planned_start_time,
                planned_end_time: self.planned_end_time,
            }
        }
    }
}
impl OpsItemSummary {
    /// Creates a new builder-style object to manufacture [`OpsItemSummary`](crate::model::OpsItemSummary)
    pub fn builder() -> crate::model::ops_item_summary::Builder {
        crate::model::ops_item_summary::Builder::default()
    }
}

/// <p>Describes an OpsItem filter.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OpsItemFilter {
    /// <p>The name of the filter.</p>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<crate::model::OpsItemFilterKey>,
    /// <p>The filter value.</p>
    #[serde(rename = "Values")]
    #[serde(default)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The operator used by the filter call.</p>
    #[serde(rename = "Operator")]
    #[serde(default)]
    pub operator: std::option::Option<crate::model::OpsItemFilterOperator>,
}
impl std::fmt::Debug for OpsItemFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpsItemFilter");
        formatter.field("key", &self.key);
        formatter.field("values", &self.values);
        formatter.field("operator", &self.operator);
        formatter.finish()
    }
}
/// See [`OpsItemFilter`](crate::model::OpsItemFilter)
pub mod ops_item_filter {
    /// A builder for [`OpsItemFilter`](crate::model::OpsItemFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<crate::model::OpsItemFilterKey>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) operator: std::option::Option<crate::model::OpsItemFilterOperator>,
    }
    impl Builder {
        /// <p>The name of the filter.</p>
        pub fn key(mut self, input: crate::model::OpsItemFilterKey) -> Self {
            self.key = Some(input);
            self
        }
        pub fn set_key(
            mut self,
            input: std::option::Option<crate::model::OpsItemFilterKey>,
        ) -> Self {
            self.key = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// <p>The operator used by the filter call.</p>
        pub fn operator(mut self, input: crate::model::OpsItemFilterOperator) -> Self {
            self.operator = Some(input);
            self
        }
        pub fn set_operator(
            mut self,
            input: std::option::Option<crate::model::OpsItemFilterOperator>,
        ) -> Self {
            self.operator = input;
            self
        }
        /// Consumes the builder and constructs a [`OpsItemFilter`](crate::model::OpsItemFilter)
        pub fn build(self) -> crate::model::OpsItemFilter {
            crate::model::OpsItemFilter {
                key: self.key,
                values: self.values,
                operator: self.operator,
            }
        }
    }
}
impl OpsItemFilter {
    /// Creates a new builder-style object to manufacture [`OpsItemFilter`](crate::model::OpsItemFilter)
    pub fn builder() -> crate::model::ops_item_filter::Builder {
        crate::model::ops_item_filter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OpsItemFilterOperator {
    Contains,
    Equal,
    GreaterThan,
    LessThan,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OpsItemFilterOperator {
    fn from(s: &str) -> Self {
        match s {
            "Contains" => OpsItemFilterOperator::Contains,
            "Equal" => OpsItemFilterOperator::Equal,
            "GreaterThan" => OpsItemFilterOperator::GreaterThan,
            "LessThan" => OpsItemFilterOperator::LessThan,
            other => OpsItemFilterOperator::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OpsItemFilterOperator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(OpsItemFilterOperator::from(s))
    }
}
impl OpsItemFilterOperator {
    pub fn as_str(&self) -> &str {
        match self {
            OpsItemFilterOperator::Contains => "Contains",
            OpsItemFilterOperator::Equal => "Equal",
            OpsItemFilterOperator::GreaterThan => "GreaterThan",
            OpsItemFilterOperator::LessThan => "LessThan",
            OpsItemFilterOperator::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for OpsItemFilterOperator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for OpsItemFilterOperator {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OpsItemFilterKey {
    ActualEndTime,
    ActualStartTime,
    AutomationId,
    Category,
    ChangeRequestApproverArn,
    ChangeRequestApproverName,
    ChangeRequestRequesterArn,
    ChangeRequestRequesterName,
    ChangeRequestTargetsResourceGroup,
    ChangeRequestTemplate,
    CreatedBy,
    CreatedTime,
    LastModifiedTime,
    OperationalData,
    OperationalDataKey,
    OperationalDataValue,
    OpsitemId,
    OpsitemType,
    PlannedEndTime,
    PlannedStartTime,
    Priority,
    ResourceId,
    Severity,
    Source,
    Status,
    Title,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OpsItemFilterKey {
    fn from(s: &str) -> Self {
        match s {
            "ActualEndTime" => OpsItemFilterKey::ActualEndTime,
            "ActualStartTime" => OpsItemFilterKey::ActualStartTime,
            "AutomationId" => OpsItemFilterKey::AutomationId,
            "Category" => OpsItemFilterKey::Category,
            "ChangeRequestByApproverArn" => OpsItemFilterKey::ChangeRequestApproverArn,
            "ChangeRequestByApproverName" => OpsItemFilterKey::ChangeRequestApproverName,
            "ChangeRequestByRequesterArn" => OpsItemFilterKey::ChangeRequestRequesterArn,
            "ChangeRequestByRequesterName" => OpsItemFilterKey::ChangeRequestRequesterName,
            "ChangeRequestByTargetsResourceGroup" => {
                OpsItemFilterKey::ChangeRequestTargetsResourceGroup
            }
            "ChangeRequestByTemplate" => OpsItemFilterKey::ChangeRequestTemplate,
            "CreatedBy" => OpsItemFilterKey::CreatedBy,
            "CreatedTime" => OpsItemFilterKey::CreatedTime,
            "LastModifiedTime" => OpsItemFilterKey::LastModifiedTime,
            "OperationalData" => OpsItemFilterKey::OperationalData,
            "OperationalDataKey" => OpsItemFilterKey::OperationalDataKey,
            "OperationalDataValue" => OpsItemFilterKey::OperationalDataValue,
            "OpsItemId" => OpsItemFilterKey::OpsitemId,
            "OpsItemType" => OpsItemFilterKey::OpsitemType,
            "PlannedEndTime" => OpsItemFilterKey::PlannedEndTime,
            "PlannedStartTime" => OpsItemFilterKey::PlannedStartTime,
            "Priority" => OpsItemFilterKey::Priority,
            "ResourceId" => OpsItemFilterKey::ResourceId,
            "Severity" => OpsItemFilterKey::Severity,
            "Source" => OpsItemFilterKey::Source,
            "Status" => OpsItemFilterKey::Status,
            "Title" => OpsItemFilterKey::Title,
            other => OpsItemFilterKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OpsItemFilterKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(OpsItemFilterKey::from(s))
    }
}
impl OpsItemFilterKey {
    pub fn as_str(&self) -> &str {
        match self {
            OpsItemFilterKey::ActualEndTime => "ActualEndTime",
            OpsItemFilterKey::ActualStartTime => "ActualStartTime",
            OpsItemFilterKey::AutomationId => "AutomationId",
            OpsItemFilterKey::Category => "Category",
            OpsItemFilterKey::ChangeRequestApproverArn => "ChangeRequestByApproverArn",
            OpsItemFilterKey::ChangeRequestApproverName => "ChangeRequestByApproverName",
            OpsItemFilterKey::ChangeRequestRequesterArn => "ChangeRequestByRequesterArn",
            OpsItemFilterKey::ChangeRequestRequesterName => "ChangeRequestByRequesterName",
            OpsItemFilterKey::ChangeRequestTargetsResourceGroup => {
                "ChangeRequestByTargetsResourceGroup"
            }
            OpsItemFilterKey::ChangeRequestTemplate => "ChangeRequestByTemplate",
            OpsItemFilterKey::CreatedBy => "CreatedBy",
            OpsItemFilterKey::CreatedTime => "CreatedTime",
            OpsItemFilterKey::LastModifiedTime => "LastModifiedTime",
            OpsItemFilterKey::OperationalData => "OperationalData",
            OpsItemFilterKey::OperationalDataKey => "OperationalDataKey",
            OpsItemFilterKey::OperationalDataValue => "OperationalDataValue",
            OpsItemFilterKey::OpsitemId => "OpsItemId",
            OpsItemFilterKey::OpsitemType => "OpsItemType",
            OpsItemFilterKey::PlannedEndTime => "PlannedEndTime",
            OpsItemFilterKey::PlannedStartTime => "PlannedStartTime",
            OpsItemFilterKey::Priority => "Priority",
            OpsItemFilterKey::ResourceId => "ResourceId",
            OpsItemFilterKey::Severity => "Severity",
            OpsItemFilterKey::Source => "Source",
            OpsItemFilterKey::Status => "Status",
            OpsItemFilterKey::Title => "Title",
            OpsItemFilterKey::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for OpsItemFilterKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for OpsItemFilterKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Information about a task defined for a maintenance window.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MaintenanceWindowTask {
    /// <p>The ID of the maintenance window where the task is registered.</p>
    #[serde(rename = "WindowId")]
    #[serde(default)]
    pub window_id: std::option::Option<std::string::String>,
    /// <p>The task ID.</p>
    #[serde(rename = "WindowTaskId")]
    #[serde(default)]
    pub window_task_id: std::option::Option<std::string::String>,
    /// <p>The resource that the task uses during execution. For RUN_COMMAND and AUTOMATION task types,
    /// <code>TaskArn</code> is the Systems Manager document name or ARN. For LAMBDA tasks, it's the function name
    /// or ARN. For STEP_FUNCTIONS tasks, it's the state machine ARN.</p>
    #[serde(rename = "TaskArn")]
    #[serde(default)]
    pub task_arn: std::option::Option<std::string::String>,
    /// <p>The type of task. The type can be one of the following: RUN_COMMAND, AUTOMATION, LAMBDA, or
    /// STEP_FUNCTIONS.</p>
    #[serde(rename = "Type")]
    #[serde(default)]
    pub r#type: std::option::Option<crate::model::MaintenanceWindowTaskType>,
    /// <p>The targets (either instances or tags). Instances are specified using
    /// Key=instanceids,Values=<instanceid1>,<instanceid2>. Tags are specified using
    /// Key=<tag name>,Values=<tag value>.</p>
    #[serde(rename = "Targets")]
    #[serde(default)]
    pub targets: std::option::Option<std::vec::Vec<crate::model::Target>>,
    /// <p>The parameters that should be passed to the task when it is run.</p>
    /// <note>
    /// <p>
    /// <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs,
    /// instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information
    /// about how Systems Manager handles these options for the supported maintenance window task
    /// types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
    /// </note>
    #[serde(rename = "TaskParameters")]
    #[serde(default)]
    pub task_parameters: std::option::Option<
        std::collections::HashMap<
            std::string::String,
            crate::model::MaintenanceWindowTaskParameterValueExpression,
        >,
    >,
    /// <p>The priority of the task in the maintenance window. The lower the number, the higher the
    /// priority. Tasks that have the same priority are scheduled in parallel.</p>
    #[serde(rename = "Priority")]
    #[serde(default)]
    pub priority: i32,
    /// <p>Information about an S3 bucket to write task-level logs to.</p>
    /// <note>
    /// <p>
    /// <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the
    /// <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure.
    /// For information about how Systems Manager handles these options for the supported maintenance
    /// window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
    /// </note>
    #[serde(rename = "LoggingInfo")]
    #[serde(default)]
    pub logging_info: std::option::Option<crate::model::LoggingInfo>,
    /// <p>The ARN of the IAM service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for
    /// maintenance window Run Command tasks.</p>
    #[serde(rename = "ServiceRoleArn")]
    #[serde(default)]
    pub service_role_arn: std::option::Option<std::string::String>,
    /// <p>The maximum number of targets this task can be run for, in parallel.</p>
    #[serde(rename = "MaxConcurrency")]
    #[serde(default)]
    pub max_concurrency: std::option::Option<std::string::String>,
    /// <p>The maximum number of errors allowed before this task stops being scheduled.</p>
    #[serde(rename = "MaxErrors")]
    #[serde(default)]
    pub max_errors: std::option::Option<std::string::String>,
    /// <p>The task name.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A description of the task.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaintenanceWindowTask {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaintenanceWindowTask");
        formatter.field("window_id", &self.window_id);
        formatter.field("window_task_id", &self.window_task_id);
        formatter.field("task_arn", &self.task_arn);
        formatter.field("r#type", &self.r#type);
        formatter.field("targets", &self.targets);
        formatter.field("task_parameters", &"*** Sensitive Data Redacted ***");
        formatter.field("priority", &self.priority);
        formatter.field("logging_info", &self.logging_info);
        formatter.field("service_role_arn", &self.service_role_arn);
        formatter.field("max_concurrency", &self.max_concurrency);
        formatter.field("max_errors", &self.max_errors);
        formatter.field("name", &self.name);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`MaintenanceWindowTask`](crate::model::MaintenanceWindowTask)
pub mod maintenance_window_task {
    /// A builder for [`MaintenanceWindowTask`](crate::model::MaintenanceWindowTask)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) window_id: std::option::Option<std::string::String>,
        pub(crate) window_task_id: std::option::Option<std::string::String>,
        pub(crate) task_arn: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::MaintenanceWindowTaskType>,
        pub(crate) targets: std::option::Option<std::vec::Vec<crate::model::Target>>,
        pub(crate) task_parameters: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                crate::model::MaintenanceWindowTaskParameterValueExpression,
            >,
        >,
        pub(crate) priority: std::option::Option<i32>,
        pub(crate) logging_info: std::option::Option<crate::model::LoggingInfo>,
        pub(crate) service_role_arn: std::option::Option<std::string::String>,
        pub(crate) max_concurrency: std::option::Option<std::string::String>,
        pub(crate) max_errors: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the maintenance window where the task is registered.</p>
        pub fn window_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.window_id = Some(input.into());
            self
        }
        pub fn set_window_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.window_id = input;
            self
        }
        /// <p>The task ID.</p>
        pub fn window_task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.window_task_id = Some(input.into());
            self
        }
        pub fn set_window_task_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.window_task_id = input;
            self
        }
        /// <p>The resource that the task uses during execution. For RUN_COMMAND and AUTOMATION task types,
        /// <code>TaskArn</code> is the Systems Manager document name or ARN. For LAMBDA tasks, it's the function name
        /// or ARN. For STEP_FUNCTIONS tasks, it's the state machine ARN.</p>
        pub fn task_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_arn = Some(input.into());
            self
        }
        pub fn set_task_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_arn = input;
            self
        }
        /// <p>The type of task. The type can be one of the following: RUN_COMMAND, AUTOMATION, LAMBDA, or
        /// STEP_FUNCTIONS.</p>
        pub fn r#type(mut self, input: crate::model::MaintenanceWindowTaskType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::MaintenanceWindowTaskType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        pub fn targets(mut self, input: impl Into<crate::model::Target>) -> Self {
            let mut v = self.targets.unwrap_or_default();
            v.push(input.into());
            self.targets = Some(v);
            self
        }
        pub fn set_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Target>>,
        ) -> Self {
            self.targets = input;
            self
        }
        pub fn task_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::MaintenanceWindowTaskParameterValueExpression>,
        ) -> Self {
            let mut hash_map = self.task_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.task_parameters = Some(hash_map);
            self
        }
        pub fn set_task_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::MaintenanceWindowTaskParameterValueExpression,
                >,
            >,
        ) -> Self {
            self.task_parameters = input;
            self
        }
        /// <p>The priority of the task in the maintenance window. The lower the number, the higher the
        /// priority. Tasks that have the same priority are scheduled in parallel.</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input;
            self
        }
        /// <p>Information about an S3 bucket to write task-level logs to.</p>
        /// <note>
        /// <p>
        /// <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the
        /// <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure.
        /// For information about how Systems Manager handles these options for the supported maintenance
        /// window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
        /// </note>
        pub fn logging_info(mut self, input: crate::model::LoggingInfo) -> Self {
            self.logging_info = Some(input);
            self
        }
        pub fn set_logging_info(
            mut self,
            input: std::option::Option<crate::model::LoggingInfo>,
        ) -> Self {
            self.logging_info = input;
            self
        }
        /// <p>The ARN of the IAM service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for
        /// maintenance window Run Command tasks.</p>
        pub fn service_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_role_arn = Some(input.into());
            self
        }
        pub fn set_service_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.service_role_arn = input;
            self
        }
        /// <p>The maximum number of targets this task can be run for, in parallel.</p>
        pub fn max_concurrency(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_concurrency = Some(input.into());
            self
        }
        pub fn set_max_concurrency(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.max_concurrency = input;
            self
        }
        /// <p>The maximum number of errors allowed before this task stops being scheduled.</p>
        pub fn max_errors(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_errors = Some(input.into());
            self
        }
        pub fn set_max_errors(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_errors = input;
            self
        }
        /// <p>The task name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A description of the task.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`MaintenanceWindowTask`](crate::model::MaintenanceWindowTask)
        pub fn build(self) -> crate::model::MaintenanceWindowTask {
            crate::model::MaintenanceWindowTask {
                window_id: self.window_id,
                window_task_id: self.window_task_id,
                task_arn: self.task_arn,
                r#type: self.r#type,
                targets: self.targets,
                task_parameters: self.task_parameters,
                priority: self.priority.unwrap_or_default(),
                logging_info: self.logging_info,
                service_role_arn: self.service_role_arn,
                max_concurrency: self.max_concurrency,
                max_errors: self.max_errors,
                name: self.name,
                description: self.description,
            }
        }
    }
}
impl MaintenanceWindowTask {
    /// Creates a new builder-style object to manufacture [`MaintenanceWindowTask`](crate::model::MaintenanceWindowTask)
    pub fn builder() -> crate::model::maintenance_window_task::Builder {
        crate::model::maintenance_window_task::Builder::default()
    }
}

/// <p>Filter used in the request. Supported filter keys are Name and Enabled.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MaintenanceWindowFilter {
    /// <p>The name of the filter.</p>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The filter values.</p>
    #[serde(rename = "Values")]
    #[serde(default)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for MaintenanceWindowFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaintenanceWindowFilter");
        formatter.field("key", &self.key);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`MaintenanceWindowFilter`](crate::model::MaintenanceWindowFilter)
pub mod maintenance_window_filter {
    /// A builder for [`MaintenanceWindowFilter`](crate::model::MaintenanceWindowFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the filter.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`MaintenanceWindowFilter`](crate::model::MaintenanceWindowFilter)
        pub fn build(self) -> crate::model::MaintenanceWindowFilter {
            crate::model::MaintenanceWindowFilter {
                key: self.key,
                values: self.values,
            }
        }
    }
}
impl MaintenanceWindowFilter {
    /// Creates a new builder-style object to manufacture [`MaintenanceWindowFilter`](crate::model::MaintenanceWindowFilter)
    pub fn builder() -> crate::model::maintenance_window_filter::Builder {
        crate::model::maintenance_window_filter::Builder::default()
    }
}

/// <p>The target registered with the maintenance window.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MaintenanceWindowTarget {
    /// <p>The ID of the maintenance window to register the target with.</p>
    #[serde(rename = "WindowId")]
    #[serde(default)]
    pub window_id: std::option::Option<std::string::String>,
    /// <p>The ID of the target.</p>
    #[serde(rename = "WindowTargetId")]
    #[serde(default)]
    pub window_target_id: std::option::Option<std::string::String>,
    /// <p>The type of target that is being registered with the maintenance window.</p>
    #[serde(rename = "ResourceType")]
    #[serde(default)]
    pub resource_type: std::option::Option<crate::model::MaintenanceWindowResourceType>,
    /// <p>The targets, either instances or tags.</p>
    /// <p>Specify instances using the following format:</p>
    /// <p>
    /// <code>Key=instanceids,Values=<instanceid1>,<instanceid2></code>
    /// </p>
    /// <p>Tags are specified using the following format:</p>
    /// <p>
    /// <code>Key=<tag name>,Values=<tag value></code>.</p>
    #[serde(rename = "Targets")]
    #[serde(default)]
    pub targets: std::option::Option<std::vec::Vec<crate::model::Target>>,
    /// <p>A user-provided value that will be included in any CloudWatch events that are raised while
    /// running tasks for these targets in this maintenance window.</p>
    #[serde(rename = "OwnerInformation")]
    #[serde(default)]
    pub owner_information: std::option::Option<std::string::String>,
    /// <p>The name for the maintenance window target.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A description for the target.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaintenanceWindowTarget {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaintenanceWindowTarget");
        formatter.field("window_id", &self.window_id);
        formatter.field("window_target_id", &self.window_target_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("targets", &self.targets);
        formatter.field("owner_information", &"*** Sensitive Data Redacted ***");
        formatter.field("name", &self.name);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`MaintenanceWindowTarget`](crate::model::MaintenanceWindowTarget)
pub mod maintenance_window_target {
    /// A builder for [`MaintenanceWindowTarget`](crate::model::MaintenanceWindowTarget)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) window_id: std::option::Option<std::string::String>,
        pub(crate) window_target_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<crate::model::MaintenanceWindowResourceType>,
        pub(crate) targets: std::option::Option<std::vec::Vec<crate::model::Target>>,
        pub(crate) owner_information: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the maintenance window to register the target with.</p>
        pub fn window_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.window_id = Some(input.into());
            self
        }
        pub fn set_window_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.window_id = input;
            self
        }
        /// <p>The ID of the target.</p>
        pub fn window_target_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.window_target_id = Some(input.into());
            self
        }
        pub fn set_window_target_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.window_target_id = input;
            self
        }
        /// <p>The type of target that is being registered with the maintenance window.</p>
        pub fn resource_type(mut self, input: crate::model::MaintenanceWindowResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::MaintenanceWindowResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        pub fn targets(mut self, input: impl Into<crate::model::Target>) -> Self {
            let mut v = self.targets.unwrap_or_default();
            v.push(input.into());
            self.targets = Some(v);
            self
        }
        pub fn set_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Target>>,
        ) -> Self {
            self.targets = input;
            self
        }
        /// <p>A user-provided value that will be included in any CloudWatch events that are raised while
        /// running tasks for these targets in this maintenance window.</p>
        pub fn owner_information(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_information = Some(input.into());
            self
        }
        pub fn set_owner_information(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.owner_information = input;
            self
        }
        /// <p>The name for the maintenance window target.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A description for the target.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`MaintenanceWindowTarget`](crate::model::MaintenanceWindowTarget)
        pub fn build(self) -> crate::model::MaintenanceWindowTarget {
            crate::model::MaintenanceWindowTarget {
                window_id: self.window_id,
                window_target_id: self.window_target_id,
                resource_type: self.resource_type,
                targets: self.targets,
                owner_information: self.owner_information,
                name: self.name,
                description: self.description,
            }
        }
    }
}
impl MaintenanceWindowTarget {
    /// Creates a new builder-style object to manufacture [`MaintenanceWindowTarget`](crate::model::MaintenanceWindowTarget)
    pub fn builder() -> crate::model::maintenance_window_target::Builder {
        crate::model::maintenance_window_target::Builder::default()
    }
}

/// <p>The maintenance window to which the specified target belongs.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MaintenanceWindowIdentityForTarget {
    /// <p>The ID of the maintenance window.</p>
    #[serde(rename = "WindowId")]
    #[serde(default)]
    pub window_id: std::option::Option<std::string::String>,
    /// <p>The name of the maintenance window.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaintenanceWindowIdentityForTarget {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaintenanceWindowIdentityForTarget");
        formatter.field("window_id", &self.window_id);
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`MaintenanceWindowIdentityForTarget`](crate::model::MaintenanceWindowIdentityForTarget)
pub mod maintenance_window_identity_for_target {
    /// A builder for [`MaintenanceWindowIdentityForTarget`](crate::model::MaintenanceWindowIdentityForTarget)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) window_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the maintenance window.</p>
        pub fn window_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.window_id = Some(input.into());
            self
        }
        pub fn set_window_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.window_id = input;
            self
        }
        /// <p>The name of the maintenance window.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`MaintenanceWindowIdentityForTarget`](crate::model::MaintenanceWindowIdentityForTarget)
        pub fn build(self) -> crate::model::MaintenanceWindowIdentityForTarget {
            crate::model::MaintenanceWindowIdentityForTarget {
                window_id: self.window_id,
                name: self.name,
            }
        }
    }
}
impl MaintenanceWindowIdentityForTarget {
    /// Creates a new builder-style object to manufacture [`MaintenanceWindowIdentityForTarget`](crate::model::MaintenanceWindowIdentityForTarget)
    pub fn builder() -> crate::model::maintenance_window_identity_for_target::Builder {
        crate::model::maintenance_window_identity_for_target::Builder::default()
    }
}

/// <p>Information about a scheduled execution for a maintenance window.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ScheduledWindowExecution {
    /// <p>The ID of the maintenance window to be run.</p>
    #[serde(rename = "WindowId")]
    #[serde(default)]
    pub window_id: std::option::Option<std::string::String>,
    /// <p>The name of the maintenance window to be run.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The time, in ISO-8601 Extended format, that the maintenance window is scheduled to be
    /// run.</p>
    #[serde(rename = "ExecutionTime")]
    #[serde(default)]
    pub execution_time: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ScheduledWindowExecution {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScheduledWindowExecution");
        formatter.field("window_id", &self.window_id);
        formatter.field("name", &self.name);
        formatter.field("execution_time", &self.execution_time);
        formatter.finish()
    }
}
/// See [`ScheduledWindowExecution`](crate::model::ScheduledWindowExecution)
pub mod scheduled_window_execution {
    /// A builder for [`ScheduledWindowExecution`](crate::model::ScheduledWindowExecution)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) window_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) execution_time: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the maintenance window to be run.</p>
        pub fn window_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.window_id = Some(input.into());
            self
        }
        pub fn set_window_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.window_id = input;
            self
        }
        /// <p>The name of the maintenance window to be run.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The time, in ISO-8601 Extended format, that the maintenance window is scheduled to be
        /// run.</p>
        pub fn execution_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.execution_time = Some(input.into());
            self
        }
        pub fn set_execution_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.execution_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduledWindowExecution`](crate::model::ScheduledWindowExecution)
        pub fn build(self) -> crate::model::ScheduledWindowExecution {
            crate::model::ScheduledWindowExecution {
                window_id: self.window_id,
                name: self.name,
                execution_time: self.execution_time,
            }
        }
    }
}
impl ScheduledWindowExecution {
    /// Creates a new builder-style object to manufacture [`ScheduledWindowExecution`](crate::model::ScheduledWindowExecution)
    pub fn builder() -> crate::model::scheduled_window_execution::Builder {
        crate::model::scheduled_window_execution::Builder::default()
    }
}

/// <p>Information about the maintenance window.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MaintenanceWindowIdentity {
    /// <p>The ID of the maintenance window.</p>
    #[serde(rename = "WindowId")]
    #[serde(default)]
    pub window_id: std::option::Option<std::string::String>,
    /// <p>The name of the maintenance window.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A description of the maintenance window.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Indicates whether the maintenance window is enabled.</p>
    #[serde(rename = "Enabled")]
    #[serde(default)]
    pub enabled: bool,
    /// <p>The duration of the maintenance window in hours.</p>
    #[serde(rename = "Duration")]
    #[serde(default)]
    pub duration: i32,
    /// <p>The number of hours before the end of the maintenance window that Systems Manager stops scheduling new
    /// tasks for execution.</p>
    #[serde(rename = "Cutoff")]
    #[serde(default)]
    pub cutoff: i32,
    /// <p>The schedule of the maintenance window in the form of a cron or rate expression.</p>
    #[serde(rename = "Schedule")]
    #[serde(default)]
    pub schedule: std::option::Option<std::string::String>,
    /// <p>The time zone that the scheduled maintenance window executions are based on, in Internet
    /// Assigned Numbers Authority (IANA) format.</p>
    #[serde(rename = "ScheduleTimezone")]
    #[serde(default)]
    pub schedule_timezone: std::option::Option<std::string::String>,
    /// <p>The number of days to wait to run a maintenance window after the scheduled CRON expression
    /// date and time.</p>
    #[serde(rename = "ScheduleOffset")]
    #[serde(default)]
    pub schedule_offset: std::option::Option<i32>,
    /// <p>The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled
    /// to become inactive.</p>
    #[serde(rename = "EndDate")]
    #[serde(default)]
    pub end_date: std::option::Option<std::string::String>,
    /// <p>The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled
    /// to become active.</p>
    #[serde(rename = "StartDate")]
    #[serde(default)]
    pub start_date: std::option::Option<std::string::String>,
    /// <p>The next time the maintenance window will actually run, taking into account any specified
    /// times for the maintenance window to become active or inactive.</p>
    #[serde(rename = "NextExecutionTime")]
    #[serde(default)]
    pub next_execution_time: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaintenanceWindowIdentity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaintenanceWindowIdentity");
        formatter.field("window_id", &self.window_id);
        formatter.field("name", &self.name);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("enabled", &self.enabled);
        formatter.field("duration", &self.duration);
        formatter.field("cutoff", &self.cutoff);
        formatter.field("schedule", &self.schedule);
        formatter.field("schedule_timezone", &self.schedule_timezone);
        formatter.field("schedule_offset", &self.schedule_offset);
        formatter.field("end_date", &self.end_date);
        formatter.field("start_date", &self.start_date);
        formatter.field("next_execution_time", &self.next_execution_time);
        formatter.finish()
    }
}
/// See [`MaintenanceWindowIdentity`](crate::model::MaintenanceWindowIdentity)
pub mod maintenance_window_identity {
    /// A builder for [`MaintenanceWindowIdentity`](crate::model::MaintenanceWindowIdentity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) window_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) duration: std::option::Option<i32>,
        pub(crate) cutoff: std::option::Option<i32>,
        pub(crate) schedule: std::option::Option<std::string::String>,
        pub(crate) schedule_timezone: std::option::Option<std::string::String>,
        pub(crate) schedule_offset: std::option::Option<i32>,
        pub(crate) end_date: std::option::Option<std::string::String>,
        pub(crate) start_date: std::option::Option<std::string::String>,
        pub(crate) next_execution_time: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the maintenance window.</p>
        pub fn window_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.window_id = Some(input.into());
            self
        }
        pub fn set_window_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.window_id = input;
            self
        }
        /// <p>The name of the maintenance window.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A description of the maintenance window.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Indicates whether the maintenance window is enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The duration of the maintenance window in hours.</p>
        pub fn duration(mut self, input: i32) -> Self {
            self.duration = Some(input);
            self
        }
        pub fn set_duration(mut self, input: std::option::Option<i32>) -> Self {
            self.duration = input;
            self
        }
        /// <p>The number of hours before the end of the maintenance window that Systems Manager stops scheduling new
        /// tasks for execution.</p>
        pub fn cutoff(mut self, input: i32) -> Self {
            self.cutoff = Some(input);
            self
        }
        pub fn set_cutoff(mut self, input: std::option::Option<i32>) -> Self {
            self.cutoff = input;
            self
        }
        /// <p>The schedule of the maintenance window in the form of a cron or rate expression.</p>
        pub fn schedule(mut self, input: impl Into<std::string::String>) -> Self {
            self.schedule = Some(input.into());
            self
        }
        pub fn set_schedule(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.schedule = input;
            self
        }
        /// <p>The time zone that the scheduled maintenance window executions are based on, in Internet
        /// Assigned Numbers Authority (IANA) format.</p>
        pub fn schedule_timezone(mut self, input: impl Into<std::string::String>) -> Self {
            self.schedule_timezone = Some(input.into());
            self
        }
        pub fn set_schedule_timezone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.schedule_timezone = input;
            self
        }
        /// <p>The number of days to wait to run a maintenance window after the scheduled CRON expression
        /// date and time.</p>
        pub fn schedule_offset(mut self, input: i32) -> Self {
            self.schedule_offset = Some(input);
            self
        }
        pub fn set_schedule_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.schedule_offset = input;
            self
        }
        /// <p>The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled
        /// to become inactive.</p>
        pub fn end_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.end_date = Some(input.into());
            self
        }
        pub fn set_end_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.end_date = input;
            self
        }
        /// <p>The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled
        /// to become active.</p>
        pub fn start_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.start_date = Some(input.into());
            self
        }
        pub fn set_start_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.start_date = input;
            self
        }
        /// <p>The next time the maintenance window will actually run, taking into account any specified
        /// times for the maintenance window to become active or inactive.</p>
        pub fn next_execution_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_execution_time = Some(input.into());
            self
        }
        pub fn set_next_execution_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_execution_time = input;
            self
        }
        /// Consumes the builder and constructs a [`MaintenanceWindowIdentity`](crate::model::MaintenanceWindowIdentity)
        pub fn build(self) -> crate::model::MaintenanceWindowIdentity {
            crate::model::MaintenanceWindowIdentity {
                window_id: self.window_id,
                name: self.name,
                description: self.description,
                enabled: self.enabled.unwrap_or_default(),
                duration: self.duration.unwrap_or_default(),
                cutoff: self.cutoff.unwrap_or_default(),
                schedule: self.schedule,
                schedule_timezone: self.schedule_timezone,
                schedule_offset: self.schedule_offset,
                end_date: self.end_date,
                start_date: self.start_date,
                next_execution_time: self.next_execution_time,
            }
        }
    }
}
impl MaintenanceWindowIdentity {
    /// Creates a new builder-style object to manufacture [`MaintenanceWindowIdentity`](crate::model::MaintenanceWindowIdentity)
    pub fn builder() -> crate::model::maintenance_window_identity::Builder {
        crate::model::maintenance_window_identity::Builder::default()
    }
}

/// <p>Information about a task execution performed as part of a maintenance window
/// execution.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MaintenanceWindowExecutionTaskIdentity {
    /// <p>The ID of the maintenance window execution that ran the task.</p>
    #[serde(rename = "WindowExecutionId")]
    #[serde(default)]
    pub window_execution_id: std::option::Option<std::string::String>,
    /// <p>The ID of the specific task execution in the maintenance window execution.</p>
    #[serde(rename = "TaskExecutionId")]
    #[serde(default)]
    pub task_execution_id: std::option::Option<std::string::String>,
    /// <p>The status of the task execution.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::MaintenanceWindowExecutionStatus>,
    /// <p>The details explaining the status of the task execution. Only available for certain status
    /// values.</p>
    #[serde(rename = "StatusDetails")]
    #[serde(default)]
    pub status_details: std::option::Option<std::string::String>,
    /// <p>The time the task execution started.</p>
    #[serde(rename = "StartTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time the task execution finished.</p>
    #[serde(rename = "EndTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub end_time: std::option::Option<smithy_types::Instant>,
    /// <p>The ARN of the task that ran.</p>
    #[serde(rename = "TaskArn")]
    #[serde(default)]
    pub task_arn: std::option::Option<std::string::String>,
    /// <p>The type of task that ran.</p>
    #[serde(rename = "TaskType")]
    #[serde(default)]
    pub task_type: std::option::Option<crate::model::MaintenanceWindowTaskType>,
}
impl std::fmt::Debug for MaintenanceWindowExecutionTaskIdentity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaintenanceWindowExecutionTaskIdentity");
        formatter.field("window_execution_id", &self.window_execution_id);
        formatter.field("task_execution_id", &self.task_execution_id);
        formatter.field("status", &self.status);
        formatter.field("status_details", &self.status_details);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("task_arn", &self.task_arn);
        formatter.field("task_type", &self.task_type);
        formatter.finish()
    }
}
/// See [`MaintenanceWindowExecutionTaskIdentity`](crate::model::MaintenanceWindowExecutionTaskIdentity)
pub mod maintenance_window_execution_task_identity {
    /// A builder for [`MaintenanceWindowExecutionTaskIdentity`](crate::model::MaintenanceWindowExecutionTaskIdentity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) window_execution_id: std::option::Option<std::string::String>,
        pub(crate) task_execution_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::MaintenanceWindowExecutionStatus>,
        pub(crate) status_details: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) task_arn: std::option::Option<std::string::String>,
        pub(crate) task_type: std::option::Option<crate::model::MaintenanceWindowTaskType>,
    }
    impl Builder {
        /// <p>The ID of the maintenance window execution that ran the task.</p>
        pub fn window_execution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.window_execution_id = Some(input.into());
            self
        }
        pub fn set_window_execution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.window_execution_id = input;
            self
        }
        /// <p>The ID of the specific task execution in the maintenance window execution.</p>
        pub fn task_execution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_execution_id = Some(input.into());
            self
        }
        pub fn set_task_execution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.task_execution_id = input;
            self
        }
        /// <p>The status of the task execution.</p>
        pub fn status(mut self, input: crate::model::MaintenanceWindowExecutionStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::MaintenanceWindowExecutionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The details explaining the status of the task execution. Only available for certain status
        /// values.</p>
        pub fn status_details(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_details = Some(input.into());
            self
        }
        pub fn set_status_details(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_details = input;
            self
        }
        /// <p>The time the task execution started.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The time the task execution finished.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The ARN of the task that ran.</p>
        pub fn task_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_arn = Some(input.into());
            self
        }
        pub fn set_task_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_arn = input;
            self
        }
        /// <p>The type of task that ran.</p>
        pub fn task_type(mut self, input: crate::model::MaintenanceWindowTaskType) -> Self {
            self.task_type = Some(input);
            self
        }
        pub fn set_task_type(
            mut self,
            input: std::option::Option<crate::model::MaintenanceWindowTaskType>,
        ) -> Self {
            self.task_type = input;
            self
        }
        /// Consumes the builder and constructs a [`MaintenanceWindowExecutionTaskIdentity`](crate::model::MaintenanceWindowExecutionTaskIdentity)
        pub fn build(self) -> crate::model::MaintenanceWindowExecutionTaskIdentity {
            crate::model::MaintenanceWindowExecutionTaskIdentity {
                window_execution_id: self.window_execution_id,
                task_execution_id: self.task_execution_id,
                status: self.status,
                status_details: self.status_details,
                start_time: self.start_time,
                end_time: self.end_time,
                task_arn: self.task_arn,
                task_type: self.task_type,
            }
        }
    }
}
impl MaintenanceWindowExecutionTaskIdentity {
    /// Creates a new builder-style object to manufacture [`MaintenanceWindowExecutionTaskIdentity`](crate::model::MaintenanceWindowExecutionTaskIdentity)
    pub fn builder() -> crate::model::maintenance_window_execution_task_identity::Builder {
        crate::model::maintenance_window_execution_task_identity::Builder::default()
    }
}

/// <p>Describes the information about a task invocation for a particular target as part of a task
/// execution performed as part of a maintenance window execution.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MaintenanceWindowExecutionTaskInvocationIdentity {
    /// <p>The ID of the maintenance window execution that ran the task.</p>
    #[serde(rename = "WindowExecutionId")]
    #[serde(default)]
    pub window_execution_id: std::option::Option<std::string::String>,
    /// <p>The ID of the specific task execution in the maintenance window execution.</p>
    #[serde(rename = "TaskExecutionId")]
    #[serde(default)]
    pub task_execution_id: std::option::Option<std::string::String>,
    /// <p>The ID of the task invocation.</p>
    #[serde(rename = "InvocationId")]
    #[serde(default)]
    pub invocation_id: std::option::Option<std::string::String>,
    /// <p>The ID of the action performed in the service that actually handled the task invocation. If
    /// the task type is RUN_COMMAND, this value is the command ID.</p>
    #[serde(rename = "ExecutionId")]
    #[serde(default)]
    pub execution_id: std::option::Option<std::string::String>,
    /// <p>The task type.</p>
    #[serde(rename = "TaskType")]
    #[serde(default)]
    pub task_type: std::option::Option<crate::model::MaintenanceWindowTaskType>,
    /// <p>The parameters that were provided for the invocation when it was run.</p>
    #[serde(rename = "Parameters")]
    #[serde(default)]
    pub parameters: std::option::Option<std::string::String>,
    /// <p>The status of the task invocation.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::MaintenanceWindowExecutionStatus>,
    /// <p>The details explaining the status of the task invocation. Only available for certain Status
    /// values. </p>
    #[serde(rename = "StatusDetails")]
    #[serde(default)]
    pub status_details: std::option::Option<std::string::String>,
    /// <p>The time the invocation started.</p>
    #[serde(rename = "StartTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time the invocation finished.</p>
    #[serde(rename = "EndTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub end_time: std::option::Option<smithy_types::Instant>,
    /// <p>User-provided value that was specified when the target was registered with the maintenance
    /// window. This was also included in any CloudWatch events raised during the task invocation.</p>
    #[serde(rename = "OwnerInformation")]
    #[serde(default)]
    pub owner_information: std::option::Option<std::string::String>,
    /// <p>The ID of the target definition in this maintenance window the invocation was performed
    /// for.</p>
    #[serde(rename = "WindowTargetId")]
    #[serde(default)]
    pub window_target_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaintenanceWindowExecutionTaskInvocationIdentity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaintenanceWindowExecutionTaskInvocationIdentity");
        formatter.field("window_execution_id", &self.window_execution_id);
        formatter.field("task_execution_id", &self.task_execution_id);
        formatter.field("invocation_id", &self.invocation_id);
        formatter.field("execution_id", &self.execution_id);
        formatter.field("task_type", &self.task_type);
        formatter.field("parameters", &"*** Sensitive Data Redacted ***");
        formatter.field("status", &self.status);
        formatter.field("status_details", &self.status_details);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("owner_information", &"*** Sensitive Data Redacted ***");
        formatter.field("window_target_id", &self.window_target_id);
        formatter.finish()
    }
}
/// See [`MaintenanceWindowExecutionTaskInvocationIdentity`](crate::model::MaintenanceWindowExecutionTaskInvocationIdentity)
pub mod maintenance_window_execution_task_invocation_identity {
    /// A builder for [`MaintenanceWindowExecutionTaskInvocationIdentity`](crate::model::MaintenanceWindowExecutionTaskInvocationIdentity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) window_execution_id: std::option::Option<std::string::String>,
        pub(crate) task_execution_id: std::option::Option<std::string::String>,
        pub(crate) invocation_id: std::option::Option<std::string::String>,
        pub(crate) execution_id: std::option::Option<std::string::String>,
        pub(crate) task_type: std::option::Option<crate::model::MaintenanceWindowTaskType>,
        pub(crate) parameters: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::MaintenanceWindowExecutionStatus>,
        pub(crate) status_details: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) owner_information: std::option::Option<std::string::String>,
        pub(crate) window_target_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the maintenance window execution that ran the task.</p>
        pub fn window_execution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.window_execution_id = Some(input.into());
            self
        }
        pub fn set_window_execution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.window_execution_id = input;
            self
        }
        /// <p>The ID of the specific task execution in the maintenance window execution.</p>
        pub fn task_execution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_execution_id = Some(input.into());
            self
        }
        pub fn set_task_execution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.task_execution_id = input;
            self
        }
        /// <p>The ID of the task invocation.</p>
        pub fn invocation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.invocation_id = Some(input.into());
            self
        }
        pub fn set_invocation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.invocation_id = input;
            self
        }
        /// <p>The ID of the action performed in the service that actually handled the task invocation. If
        /// the task type is RUN_COMMAND, this value is the command ID.</p>
        pub fn execution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.execution_id = Some(input.into());
            self
        }
        pub fn set_execution_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.execution_id = input;
            self
        }
        /// <p>The task type.</p>
        pub fn task_type(mut self, input: crate::model::MaintenanceWindowTaskType) -> Self {
            self.task_type = Some(input);
            self
        }
        pub fn set_task_type(
            mut self,
            input: std::option::Option<crate::model::MaintenanceWindowTaskType>,
        ) -> Self {
            self.task_type = input;
            self
        }
        /// <p>The parameters that were provided for the invocation when it was run.</p>
        pub fn parameters(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameters = Some(input.into());
            self
        }
        pub fn set_parameters(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.parameters = input;
            self
        }
        /// <p>The status of the task invocation.</p>
        pub fn status(mut self, input: crate::model::MaintenanceWindowExecutionStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::MaintenanceWindowExecutionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The details explaining the status of the task invocation. Only available for certain Status
        /// values. </p>
        pub fn status_details(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_details = Some(input.into());
            self
        }
        pub fn set_status_details(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_details = input;
            self
        }
        /// <p>The time the invocation started.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The time the invocation finished.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.end_time = input;
            self
        }
        /// <p>User-provided value that was specified when the target was registered with the maintenance
        /// window. This was also included in any CloudWatch events raised during the task invocation.</p>
        pub fn owner_information(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_information = Some(input.into());
            self
        }
        pub fn set_owner_information(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.owner_information = input;
            self
        }
        /// <p>The ID of the target definition in this maintenance window the invocation was performed
        /// for.</p>
        pub fn window_target_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.window_target_id = Some(input.into());
            self
        }
        pub fn set_window_target_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.window_target_id = input;
            self
        }
        /// Consumes the builder and constructs a [`MaintenanceWindowExecutionTaskInvocationIdentity`](crate::model::MaintenanceWindowExecutionTaskInvocationIdentity)
        pub fn build(self) -> crate::model::MaintenanceWindowExecutionTaskInvocationIdentity {
            crate::model::MaintenanceWindowExecutionTaskInvocationIdentity {
                window_execution_id: self.window_execution_id,
                task_execution_id: self.task_execution_id,
                invocation_id: self.invocation_id,
                execution_id: self.execution_id,
                task_type: self.task_type,
                parameters: self.parameters,
                status: self.status,
                status_details: self.status_details,
                start_time: self.start_time,
                end_time: self.end_time,
                owner_information: self.owner_information,
                window_target_id: self.window_target_id,
            }
        }
    }
}
impl MaintenanceWindowExecutionTaskInvocationIdentity {
    /// Creates a new builder-style object to manufacture [`MaintenanceWindowExecutionTaskInvocationIdentity`](crate::model::MaintenanceWindowExecutionTaskInvocationIdentity)
    pub fn builder() -> crate::model::maintenance_window_execution_task_invocation_identity::Builder
    {
        crate::model::maintenance_window_execution_task_invocation_identity::Builder::default()
    }
}

/// <p>Describes the information about an execution of a maintenance window. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MaintenanceWindowExecution {
    /// <p>The ID of the maintenance window.</p>
    #[serde(rename = "WindowId")]
    #[serde(default)]
    pub window_id: std::option::Option<std::string::String>,
    /// <p>The ID of the maintenance window execution.</p>
    #[serde(rename = "WindowExecutionId")]
    #[serde(default)]
    pub window_execution_id: std::option::Option<std::string::String>,
    /// <p>The status of the execution.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::MaintenanceWindowExecutionStatus>,
    /// <p>The details explaining the Status. Only available for certain status values.</p>
    #[serde(rename = "StatusDetails")]
    #[serde(default)]
    pub status_details: std::option::Option<std::string::String>,
    /// <p>The time the execution started.</p>
    #[serde(rename = "StartTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time the execution finished.</p>
    #[serde(rename = "EndTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub end_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for MaintenanceWindowExecution {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaintenanceWindowExecution");
        formatter.field("window_id", &self.window_id);
        formatter.field("window_execution_id", &self.window_execution_id);
        formatter.field("status", &self.status);
        formatter.field("status_details", &self.status_details);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.finish()
    }
}
/// See [`MaintenanceWindowExecution`](crate::model::MaintenanceWindowExecution)
pub mod maintenance_window_execution {
    /// A builder for [`MaintenanceWindowExecution`](crate::model::MaintenanceWindowExecution)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) window_id: std::option::Option<std::string::String>,
        pub(crate) window_execution_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::MaintenanceWindowExecutionStatus>,
        pub(crate) status_details: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The ID of the maintenance window.</p>
        pub fn window_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.window_id = Some(input.into());
            self
        }
        pub fn set_window_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.window_id = input;
            self
        }
        /// <p>The ID of the maintenance window execution.</p>
        pub fn window_execution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.window_execution_id = Some(input.into());
            self
        }
        pub fn set_window_execution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.window_execution_id = input;
            self
        }
        /// <p>The status of the execution.</p>
        pub fn status(mut self, input: crate::model::MaintenanceWindowExecutionStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::MaintenanceWindowExecutionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The details explaining the Status. Only available for certain status values.</p>
        pub fn status_details(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_details = Some(input.into());
            self
        }
        pub fn set_status_details(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_details = input;
            self
        }
        /// <p>The time the execution started.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The time the execution finished.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.end_time = input;
            self
        }
        /// Consumes the builder and constructs a [`MaintenanceWindowExecution`](crate::model::MaintenanceWindowExecution)
        pub fn build(self) -> crate::model::MaintenanceWindowExecution {
            crate::model::MaintenanceWindowExecution {
                window_id: self.window_id,
                window_execution_id: self.window_execution_id,
                status: self.status,
                status_details: self.status_details,
                start_time: self.start_time,
                end_time: self.end_time,
            }
        }
    }
}
impl MaintenanceWindowExecution {
    /// Creates a new builder-style object to manufacture [`MaintenanceWindowExecution`](crate::model::MaintenanceWindowExecution)
    pub fn builder() -> crate::model::maintenance_window_execution::Builder {
        crate::model::maintenance_window_execution::Builder::default()
    }
}

/// <p>Status information returned by the <code>DeleteInventory</code> action.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InventoryDeletionStatusItem {
    /// <p>The deletion ID returned by the <code>DeleteInventory</code> action.</p>
    #[serde(rename = "DeletionId")]
    #[serde(default)]
    pub deletion_id: std::option::Option<std::string::String>,
    /// <p>The name of the inventory data type.</p>
    #[serde(rename = "TypeName")]
    #[serde(default)]
    pub type_name: std::option::Option<std::string::String>,
    /// <p>The UTC timestamp when the delete operation started.</p>
    #[serde(rename = "DeletionStartTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub deletion_start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The status of the operation. Possible values are InProgress and Complete.</p>
    #[serde(rename = "LastStatus")]
    #[serde(default)]
    pub last_status: std::option::Option<crate::model::InventoryDeletionStatus>,
    /// <p>Information about the status.</p>
    #[serde(rename = "LastStatusMessage")]
    #[serde(default)]
    pub last_status_message: std::option::Option<std::string::String>,
    /// <p>Information about the delete operation. For more information about this summary, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-inventory-custom.html#sysman-inventory-delete">Understanding the delete inventory summary</a> in the
    /// <i>AWS Systems Manager User Guide</i>.</p>
    #[serde(rename = "DeletionSummary")]
    #[serde(default)]
    pub deletion_summary: std::option::Option<crate::model::InventoryDeletionSummary>,
    /// <p>The UTC timestamp of when the last status report.</p>
    #[serde(rename = "LastStatusUpdateTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_status_update_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for InventoryDeletionStatusItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InventoryDeletionStatusItem");
        formatter.field("deletion_id", &self.deletion_id);
        formatter.field("type_name", &self.type_name);
        formatter.field("deletion_start_time", &self.deletion_start_time);
        formatter.field("last_status", &self.last_status);
        formatter.field("last_status_message", &self.last_status_message);
        formatter.field("deletion_summary", &self.deletion_summary);
        formatter.field("last_status_update_time", &self.last_status_update_time);
        formatter.finish()
    }
}
/// See [`InventoryDeletionStatusItem`](crate::model::InventoryDeletionStatusItem)
pub mod inventory_deletion_status_item {
    /// A builder for [`InventoryDeletionStatusItem`](crate::model::InventoryDeletionStatusItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) deletion_id: std::option::Option<std::string::String>,
        pub(crate) type_name: std::option::Option<std::string::String>,
        pub(crate) deletion_start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_status: std::option::Option<crate::model::InventoryDeletionStatus>,
        pub(crate) last_status_message: std::option::Option<std::string::String>,
        pub(crate) deletion_summary: std::option::Option<crate::model::InventoryDeletionSummary>,
        pub(crate) last_status_update_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The deletion ID returned by the <code>DeleteInventory</code> action.</p>
        pub fn deletion_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.deletion_id = Some(input.into());
            self
        }
        pub fn set_deletion_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.deletion_id = input;
            self
        }
        /// <p>The name of the inventory data type.</p>
        pub fn type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.type_name = Some(input.into());
            self
        }
        pub fn set_type_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.type_name = input;
            self
        }
        /// <p>The UTC timestamp when the delete operation started.</p>
        pub fn deletion_start_time(mut self, input: smithy_types::Instant) -> Self {
            self.deletion_start_time = Some(input);
            self
        }
        pub fn set_deletion_start_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.deletion_start_time = input;
            self
        }
        /// <p>The status of the operation. Possible values are InProgress and Complete.</p>
        pub fn last_status(mut self, input: crate::model::InventoryDeletionStatus) -> Self {
            self.last_status = Some(input);
            self
        }
        pub fn set_last_status(
            mut self,
            input: std::option::Option<crate::model::InventoryDeletionStatus>,
        ) -> Self {
            self.last_status = input;
            self
        }
        /// <p>Information about the status.</p>
        pub fn last_status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_status_message = Some(input.into());
            self
        }
        pub fn set_last_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_status_message = input;
            self
        }
        /// <p>Information about the delete operation. For more information about this summary, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-inventory-custom.html#sysman-inventory-delete">Understanding the delete inventory summary</a> in the
        /// <i>AWS Systems Manager User Guide</i>.</p>
        pub fn deletion_summary(mut self, input: crate::model::InventoryDeletionSummary) -> Self {
            self.deletion_summary = Some(input);
            self
        }
        pub fn set_deletion_summary(
            mut self,
            input: std::option::Option<crate::model::InventoryDeletionSummary>,
        ) -> Self {
            self.deletion_summary = input;
            self
        }
        /// <p>The UTC timestamp of when the last status report.</p>
        pub fn last_status_update_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_status_update_time = Some(input);
            self
        }
        pub fn set_last_status_update_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_status_update_time = input;
            self
        }
        /// Consumes the builder and constructs a [`InventoryDeletionStatusItem`](crate::model::InventoryDeletionStatusItem)
        pub fn build(self) -> crate::model::InventoryDeletionStatusItem {
            crate::model::InventoryDeletionStatusItem {
                deletion_id: self.deletion_id,
                type_name: self.type_name,
                deletion_start_time: self.deletion_start_time,
                last_status: self.last_status,
                last_status_message: self.last_status_message,
                deletion_summary: self.deletion_summary,
                last_status_update_time: self.last_status_update_time,
            }
        }
    }
}
impl InventoryDeletionStatusItem {
    /// Creates a new builder-style object to manufacture [`InventoryDeletionStatusItem`](crate::model::InventoryDeletionStatusItem)
    pub fn builder() -> crate::model::inventory_deletion_status_item::Builder {
        crate::model::inventory_deletion_status_item::Builder::default()
    }
}

/// <p>Information about the delete operation.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InventoryDeletionSummary {
    /// <p>The total number of items to delete. This count does not change during the delete
    /// operation.</p>
    #[serde(rename = "TotalCount")]
    #[serde(default)]
    pub total_count: i32,
    /// <p>Remaining number of items to delete.</p>
    #[serde(rename = "RemainingCount")]
    #[serde(default)]
    pub remaining_count: i32,
    /// <p>A list of counts and versions for deleted items.</p>
    #[serde(rename = "SummaryItems")]
    #[serde(default)]
    pub summary_items:
        std::option::Option<std::vec::Vec<crate::model::InventoryDeletionSummaryItem>>,
}
impl std::fmt::Debug for InventoryDeletionSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InventoryDeletionSummary");
        formatter.field("total_count", &self.total_count);
        formatter.field("remaining_count", &self.remaining_count);
        formatter.field("summary_items", &self.summary_items);
        formatter.finish()
    }
}
/// See [`InventoryDeletionSummary`](crate::model::InventoryDeletionSummary)
pub mod inventory_deletion_summary {
    /// A builder for [`InventoryDeletionSummary`](crate::model::InventoryDeletionSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) total_count: std::option::Option<i32>,
        pub(crate) remaining_count: std::option::Option<i32>,
        pub(crate) summary_items:
            std::option::Option<std::vec::Vec<crate::model::InventoryDeletionSummaryItem>>,
    }
    impl Builder {
        /// <p>The total number of items to delete. This count does not change during the delete
        /// operation.</p>
        pub fn total_count(mut self, input: i32) -> Self {
            self.total_count = Some(input);
            self
        }
        pub fn set_total_count(mut self, input: std::option::Option<i32>) -> Self {
            self.total_count = input;
            self
        }
        /// <p>Remaining number of items to delete.</p>
        pub fn remaining_count(mut self, input: i32) -> Self {
            self.remaining_count = Some(input);
            self
        }
        pub fn set_remaining_count(mut self, input: std::option::Option<i32>) -> Self {
            self.remaining_count = input;
            self
        }
        pub fn summary_items(
            mut self,
            input: impl Into<crate::model::InventoryDeletionSummaryItem>,
        ) -> Self {
            let mut v = self.summary_items.unwrap_or_default();
            v.push(input.into());
            self.summary_items = Some(v);
            self
        }
        pub fn set_summary_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InventoryDeletionSummaryItem>>,
        ) -> Self {
            self.summary_items = input;
            self
        }
        /// Consumes the builder and constructs a [`InventoryDeletionSummary`](crate::model::InventoryDeletionSummary)
        pub fn build(self) -> crate::model::InventoryDeletionSummary {
            crate::model::InventoryDeletionSummary {
                total_count: self.total_count.unwrap_or_default(),
                remaining_count: self.remaining_count.unwrap_or_default(),
                summary_items: self.summary_items,
            }
        }
    }
}
impl InventoryDeletionSummary {
    /// Creates a new builder-style object to manufacture [`InventoryDeletionSummary`](crate::model::InventoryDeletionSummary)
    pub fn builder() -> crate::model::inventory_deletion_summary::Builder {
        crate::model::inventory_deletion_summary::Builder::default()
    }
}

/// <p>Either a count, remaining count, or a version number in a delete inventory summary.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InventoryDeletionSummaryItem {
    /// <p>The inventory type version.</p>
    #[serde(rename = "Version")]
    #[serde(default)]
    pub version: std::option::Option<std::string::String>,
    /// <p>A count of the number of deleted items.</p>
    #[serde(rename = "Count")]
    #[serde(default)]
    pub count: i32,
    /// <p>The remaining number of items to delete.</p>
    #[serde(rename = "RemainingCount")]
    #[serde(default)]
    pub remaining_count: i32,
}
impl std::fmt::Debug for InventoryDeletionSummaryItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InventoryDeletionSummaryItem");
        formatter.field("version", &self.version);
        formatter.field("count", &self.count);
        formatter.field("remaining_count", &self.remaining_count);
        formatter.finish()
    }
}
/// See [`InventoryDeletionSummaryItem`](crate::model::InventoryDeletionSummaryItem)
pub mod inventory_deletion_summary_item {
    /// A builder for [`InventoryDeletionSummaryItem`](crate::model::InventoryDeletionSummaryItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) version: std::option::Option<std::string::String>,
        pub(crate) count: std::option::Option<i32>,
        pub(crate) remaining_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The inventory type version.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// <p>A count of the number of deleted items.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// <p>The remaining number of items to delete.</p>
        pub fn remaining_count(mut self, input: i32) -> Self {
            self.remaining_count = Some(input);
            self
        }
        pub fn set_remaining_count(mut self, input: std::option::Option<i32>) -> Self {
            self.remaining_count = input;
            self
        }
        /// Consumes the builder and constructs a [`InventoryDeletionSummaryItem`](crate::model::InventoryDeletionSummaryItem)
        pub fn build(self) -> crate::model::InventoryDeletionSummaryItem {
            crate::model::InventoryDeletionSummaryItem {
                version: self.version,
                count: self.count.unwrap_or_default(),
                remaining_count: self.remaining_count.unwrap_or_default(),
            }
        }
    }
}
impl InventoryDeletionSummaryItem {
    /// Creates a new builder-style object to manufacture [`InventoryDeletionSummaryItem`](crate::model::InventoryDeletionSummaryItem)
    pub fn builder() -> crate::model::inventory_deletion_summary_item::Builder {
        crate::model::inventory_deletion_summary_item::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InventoryDeletionStatus {
    Complete,
    InProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InventoryDeletionStatus {
    fn from(s: &str) -> Self {
        match s {
            "Complete" => InventoryDeletionStatus::Complete,
            "InProgress" => InventoryDeletionStatus::InProgress,
            other => InventoryDeletionStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InventoryDeletionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(InventoryDeletionStatus::from(s))
    }
}
impl InventoryDeletionStatus {
    pub fn as_str(&self) -> &str {
        match self {
            InventoryDeletionStatus::Complete => "Complete",
            InventoryDeletionStatus::InProgress => "InProgress",
            InventoryDeletionStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for InventoryDeletionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for InventoryDeletionStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Defines the high-level patch compliance state for a managed instance, providing information
/// about the number of installed, missing, not applicable, and failed patches along with metadata
/// about the operation when this information was gathered for the instance.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InstancePatchState {
    /// <p>The ID of the managed instance the high-level patch compliance information was collected
    /// for.</p>
    #[serde(rename = "InstanceId")]
    #[serde(default)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The name of the patch group the managed instance belongs to.</p>
    #[serde(rename = "PatchGroup")]
    #[serde(default)]
    pub patch_group: std::option::Option<std::string::String>,
    /// <p>The ID of the patch baseline used to patch the instance.</p>
    #[serde(rename = "BaselineId")]
    #[serde(default)]
    pub baseline_id: std::option::Option<std::string::String>,
    /// <p>The ID of the patch baseline snapshot used during the patching operation when this
    /// compliance data was collected.</p>
    #[serde(rename = "SnapshotId")]
    #[serde(default)]
    pub snapshot_id: std::option::Option<std::string::String>,
    /// <p>An https URL or an Amazon S3 path-style URL to a list of patches to be installed. This patch
    /// installation list, which you maintain in an S3 bucket in YAML format and specify in the SSM
    /// document <code>AWS-RunPatchBaseline</code>, overrides the patches specified by the default patch
    /// baseline.</p>
    /// <p>For more information about the <code>InstallOverrideList</code> parameter, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-about-aws-runpatchbaseline.html">About the
    /// SSM document AWS-RunPatchBaseline</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    #[serde(rename = "InstallOverrideList")]
    #[serde(default)]
    pub install_override_list: std::option::Option<std::string::String>,
    /// <p>Placeholder information. This field will always be empty in the current release of the
    /// service.</p>
    #[serde(rename = "OwnerInformation")]
    #[serde(default)]
    pub owner_information: std::option::Option<std::string::String>,
    /// <p>The number of patches from the patch baseline that are installed on the instance.</p>
    #[serde(rename = "InstalledCount")]
    #[serde(default)]
    pub installed_count: i32,
    /// <p>The number of patches not specified in the patch baseline that are installed on the
    /// instance.</p>
    #[serde(rename = "InstalledOtherCount")]
    #[serde(default)]
    pub installed_other_count: i32,
    /// <p>The number of patches installed by Patch Manager since the last time the instance was
    /// rebooted.</p>
    #[serde(rename = "InstalledPendingRebootCount")]
    #[serde(default)]
    pub installed_pending_reboot_count: std::option::Option<i32>,
    /// <p>The number of patches installed on an instance that are specified in a
    /// <code>RejectedPatches</code> list. Patches with a status of
    /// <i>InstalledRejected</i> were typically installed before they were added to a
    /// <code>RejectedPatches</code> list.</p>
    /// <note>
    /// <p>If <code>ALLOW_AS_DEPENDENCY</code> is the specified option for
    /// <code>RejectedPatchesAction</code>, the value of <code>InstalledRejectedCount</code> will
    /// always be <code>0</code> (zero).</p>
    /// </note>
    #[serde(rename = "InstalledRejectedCount")]
    #[serde(default)]
    pub installed_rejected_count: std::option::Option<i32>,
    /// <p>The number of patches from the patch baseline that are applicable for the instance but
    /// aren't currently installed.</p>
    #[serde(rename = "MissingCount")]
    #[serde(default)]
    pub missing_count: i32,
    /// <p>The number of patches from the patch baseline that were attempted to be installed during the
    /// last patching operation, but failed to install.</p>
    #[serde(rename = "FailedCount")]
    #[serde(default)]
    pub failed_count: i32,
    /// <p>The number of patches beyond the supported limit of <code>NotApplicableCount</code> that are
    /// not reported by name to Systems Manager Inventory.</p>
    #[serde(rename = "UnreportedNotApplicableCount")]
    #[serde(default)]
    pub unreported_not_applicable_count: std::option::Option<i32>,
    /// <p>The number of patches from the patch baseline that aren't applicable for the instance and
    /// therefore aren't installed on the instance. This number may be truncated if the list of patch
    /// names is very large. The number of patches beyond this limit are reported in
    /// <code>UnreportedNotApplicableCount</code>.</p>
    #[serde(rename = "NotApplicableCount")]
    #[serde(default)]
    pub not_applicable_count: i32,
    /// <p>The time the most recent patching operation was started on the instance.</p>
    #[serde(rename = "OperationStartTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub operation_start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time the most recent patching operation completed on the instance.</p>
    #[serde(rename = "OperationEndTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub operation_end_time: std::option::Option<smithy_types::Instant>,
    /// <p>The type of patching operation that was performed: <code>SCAN</code> (assess patch
    /// compliance state) or <code>INSTALL</code> (install missing patches).</p>
    #[serde(rename = "Operation")]
    #[serde(default)]
    pub operation: std::option::Option<crate::model::PatchOperationType>,
    /// <p>The time of the last attempt to patch the instance with <code>NoReboot</code> specified as
    /// the reboot option.</p>
    #[serde(rename = "LastNoRebootInstallOperationTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_no_reboot_install_operation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Indicates the reboot option specified in the patch baseline.</p>
    /// <note>
    /// <p>Reboot options apply to <code>Install</code> operations only. Reboots are not attempted for
    /// Patch Manager <code>Scan</code> operations.</p>
    /// </note>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>RebootIfNeeded</b>: Patch Manager tries to reboot the
    /// instance if it installed any patches, or if any patches are detected with a status of
    /// <code>InstalledPendingReboot</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>NoReboot</b>: Patch Manager attempts to install missing
    /// packages without trying to reboot the system. Patches installed with this option are assigned a
    /// status of <code>InstalledPendingReboot</code>. These patches might not be in effect until a
    /// reboot is performed.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "RebootOption")]
    #[serde(default)]
    pub reboot_option: std::option::Option<crate::model::RebootOption>,
    /// <p>The number of instances where patches that are specified as "Critical" for compliance
    /// reporting in the patch baseline are not installed. These patches might be missing, have failed
    /// installation, were rejected, or were installed but awaiting a required instance reboot. The
    /// status of these instances is <code>NON_COMPLIANT</code>.</p>
    #[serde(rename = "CriticalNonCompliantCount")]
    #[serde(default)]
    pub critical_non_compliant_count: std::option::Option<i32>,
    /// <p>The number of instances where patches that are specified as "Security" in a patch advisory
    /// are not installed. These patches might be missing, have failed installation, were rejected, or
    /// were installed but awaiting a required instance reboot. The status of these instances is
    /// <code>NON_COMPLIANT</code>.</p>
    #[serde(rename = "SecurityNonCompliantCount")]
    #[serde(default)]
    pub security_non_compliant_count: std::option::Option<i32>,
    /// <p>The number of instances with patches installed that are specified as other than "Critical"
    /// or "Security" but are not compliant with the patch baseline. The status of these instances is
    /// NON_COMPLIANT.</p>
    #[serde(rename = "OtherNonCompliantCount")]
    #[serde(default)]
    pub other_non_compliant_count: std::option::Option<i32>,
}
impl std::fmt::Debug for InstancePatchState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstancePatchState");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("patch_group", &self.patch_group);
        formatter.field("baseline_id", &self.baseline_id);
        formatter.field("snapshot_id", &self.snapshot_id);
        formatter.field("install_override_list", &self.install_override_list);
        formatter.field("owner_information", &"*** Sensitive Data Redacted ***");
        formatter.field("installed_count", &self.installed_count);
        formatter.field("installed_other_count", &self.installed_other_count);
        formatter.field(
            "installed_pending_reboot_count",
            &self.installed_pending_reboot_count,
        );
        formatter.field("installed_rejected_count", &self.installed_rejected_count);
        formatter.field("missing_count", &self.missing_count);
        formatter.field("failed_count", &self.failed_count);
        formatter.field(
            "unreported_not_applicable_count",
            &self.unreported_not_applicable_count,
        );
        formatter.field("not_applicable_count", &self.not_applicable_count);
        formatter.field("operation_start_time", &self.operation_start_time);
        formatter.field("operation_end_time", &self.operation_end_time);
        formatter.field("operation", &self.operation);
        formatter.field(
            "last_no_reboot_install_operation_time",
            &self.last_no_reboot_install_operation_time,
        );
        formatter.field("reboot_option", &self.reboot_option);
        formatter.field(
            "critical_non_compliant_count",
            &self.critical_non_compliant_count,
        );
        formatter.field(
            "security_non_compliant_count",
            &self.security_non_compliant_count,
        );
        formatter.field("other_non_compliant_count", &self.other_non_compliant_count);
        formatter.finish()
    }
}
/// See [`InstancePatchState`](crate::model::InstancePatchState)
pub mod instance_patch_state {
    /// A builder for [`InstancePatchState`](crate::model::InstancePatchState)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) patch_group: std::option::Option<std::string::String>,
        pub(crate) baseline_id: std::option::Option<std::string::String>,
        pub(crate) snapshot_id: std::option::Option<std::string::String>,
        pub(crate) install_override_list: std::option::Option<std::string::String>,
        pub(crate) owner_information: std::option::Option<std::string::String>,
        pub(crate) installed_count: std::option::Option<i32>,
        pub(crate) installed_other_count: std::option::Option<i32>,
        pub(crate) installed_pending_reboot_count: std::option::Option<i32>,
        pub(crate) installed_rejected_count: std::option::Option<i32>,
        pub(crate) missing_count: std::option::Option<i32>,
        pub(crate) failed_count: std::option::Option<i32>,
        pub(crate) unreported_not_applicable_count: std::option::Option<i32>,
        pub(crate) not_applicable_count: std::option::Option<i32>,
        pub(crate) operation_start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) operation_end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) operation: std::option::Option<crate::model::PatchOperationType>,
        pub(crate) last_no_reboot_install_operation_time:
            std::option::Option<smithy_types::Instant>,
        pub(crate) reboot_option: std::option::Option<crate::model::RebootOption>,
        pub(crate) critical_non_compliant_count: std::option::Option<i32>,
        pub(crate) security_non_compliant_count: std::option::Option<i32>,
        pub(crate) other_non_compliant_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of the managed instance the high-level patch compliance information was collected
        /// for.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The name of the patch group the managed instance belongs to.</p>
        pub fn patch_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.patch_group = Some(input.into());
            self
        }
        pub fn set_patch_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.patch_group = input;
            self
        }
        /// <p>The ID of the patch baseline used to patch the instance.</p>
        pub fn baseline_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.baseline_id = Some(input.into());
            self
        }
        pub fn set_baseline_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.baseline_id = input;
            self
        }
        /// <p>The ID of the patch baseline snapshot used during the patching operation when this
        /// compliance data was collected.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_id = Some(input.into());
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.snapshot_id = input;
            self
        }
        /// <p>An https URL or an Amazon S3 path-style URL to a list of patches to be installed. This patch
        /// installation list, which you maintain in an S3 bucket in YAML format and specify in the SSM
        /// document <code>AWS-RunPatchBaseline</code>, overrides the patches specified by the default patch
        /// baseline.</p>
        /// <p>For more information about the <code>InstallOverrideList</code> parameter, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-about-aws-runpatchbaseline.html">About the
        /// SSM document AWS-RunPatchBaseline</a> in the <i>AWS Systems Manager User Guide</i>.</p>
        pub fn install_override_list(mut self, input: impl Into<std::string::String>) -> Self {
            self.install_override_list = Some(input.into());
            self
        }
        pub fn set_install_override_list(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.install_override_list = input;
            self
        }
        /// <p>Placeholder information. This field will always be empty in the current release of the
        /// service.</p>
        pub fn owner_information(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_information = Some(input.into());
            self
        }
        pub fn set_owner_information(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.owner_information = input;
            self
        }
        /// <p>The number of patches from the patch baseline that are installed on the instance.</p>
        pub fn installed_count(mut self, input: i32) -> Self {
            self.installed_count = Some(input);
            self
        }
        pub fn set_installed_count(mut self, input: std::option::Option<i32>) -> Self {
            self.installed_count = input;
            self
        }
        /// <p>The number of patches not specified in the patch baseline that are installed on the
        /// instance.</p>
        pub fn installed_other_count(mut self, input: i32) -> Self {
            self.installed_other_count = Some(input);
            self
        }
        pub fn set_installed_other_count(mut self, input: std::option::Option<i32>) -> Self {
            self.installed_other_count = input;
            self
        }
        /// <p>The number of patches installed by Patch Manager since the last time the instance was
        /// rebooted.</p>
        pub fn installed_pending_reboot_count(mut self, input: i32) -> Self {
            self.installed_pending_reboot_count = Some(input);
            self
        }
        pub fn set_installed_pending_reboot_count(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.installed_pending_reboot_count = input;
            self
        }
        /// <p>The number of patches installed on an instance that are specified in a
        /// <code>RejectedPatches</code> list. Patches with a status of
        /// <i>InstalledRejected</i> were typically installed before they were added to a
        /// <code>RejectedPatches</code> list.</p>
        /// <note>
        /// <p>If <code>ALLOW_AS_DEPENDENCY</code> is the specified option for
        /// <code>RejectedPatchesAction</code>, the value of <code>InstalledRejectedCount</code> will
        /// always be <code>0</code> (zero).</p>
        /// </note>
        pub fn installed_rejected_count(mut self, input: i32) -> Self {
            self.installed_rejected_count = Some(input);
            self
        }
        pub fn set_installed_rejected_count(mut self, input: std::option::Option<i32>) -> Self {
            self.installed_rejected_count = input;
            self
        }
        /// <p>The number of patches from the patch baseline that are applicable for the instance but
        /// aren't currently installed.</p>
        pub fn missing_count(mut self, input: i32) -> Self {
            self.missing_count = Some(input);
            self
        }
        pub fn set_missing_count(mut self, input: std::option::Option<i32>) -> Self {
            self.missing_count = input;
            self
        }
        /// <p>The number of patches from the patch baseline that were attempted to be installed during the
        /// last patching operation, but failed to install.</p>
        pub fn failed_count(mut self, input: i32) -> Self {
            self.failed_count = Some(input);
            self
        }
        pub fn set_failed_count(mut self, input: std::option::Option<i32>) -> Self {
            self.failed_count = input;
            self
        }
        /// <p>The number of patches beyond the supported limit of <code>NotApplicableCount</code> that are
        /// not reported by name to Systems Manager Inventory.</p>
        pub fn unreported_not_applicable_count(mut self, input: i32) -> Self {
            self.unreported_not_applicable_count = Some(input);
            self
        }
        pub fn set_unreported_not_applicable_count(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.unreported_not_applicable_count = input;
            self
        }
        /// <p>The number of patches from the patch baseline that aren't applicable for the instance and
        /// therefore aren't installed on the instance. This number may be truncated if the list of patch
        /// names is very large. The number of patches beyond this limit are reported in
        /// <code>UnreportedNotApplicableCount</code>.</p>
        pub fn not_applicable_count(mut self, input: i32) -> Self {
            self.not_applicable_count = Some(input);
            self
        }
        pub fn set_not_applicable_count(mut self, input: std::option::Option<i32>) -> Self {
            self.not_applicable_count = input;
            self
        }
        /// <p>The time the most recent patching operation was started on the instance.</p>
        pub fn operation_start_time(mut self, input: smithy_types::Instant) -> Self {
            self.operation_start_time = Some(input);
            self
        }
        pub fn set_operation_start_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.operation_start_time = input;
            self
        }
        /// <p>The time the most recent patching operation completed on the instance.</p>
        pub fn operation_end_time(mut self, input: smithy_types::Instant) -> Self {
            self.operation_end_time = Some(input);
            self
        }
        pub fn set_operation_end_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.operation_end_time = input;
            self
        }
        /// <p>The type of patching operation that was performed: <code>SCAN</code> (assess patch
        /// compliance state) or <code>INSTALL</code> (install missing patches).</p>
        pub fn operation(mut self, input: crate::model::PatchOperationType) -> Self {
            self.operation = Some(input);
            self
        }
        pub fn set_operation(
            mut self,
            input: std::option::Option<crate::model::PatchOperationType>,
        ) -> Self {
            self.operation = input;
            self
        }
        /// <p>The time of the last attempt to patch the instance with <code>NoReboot</code> specified as
        /// the reboot option.</p>
        pub fn last_no_reboot_install_operation_time(
            mut self,
            input: smithy_types::Instant,
        ) -> Self {
            self.last_no_reboot_install_operation_time = Some(input);
            self
        }
        pub fn set_last_no_reboot_install_operation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_no_reboot_install_operation_time = input;
            self
        }
        /// <p>Indicates the reboot option specified in the patch baseline.</p>
        /// <note>
        /// <p>Reboot options apply to <code>Install</code> operations only. Reboots are not attempted for
        /// Patch Manager <code>Scan</code> operations.</p>
        /// </note>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>RebootIfNeeded</b>: Patch Manager tries to reboot the
        /// instance if it installed any patches, or if any patches are detected with a status of
        /// <code>InstalledPendingReboot</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>NoReboot</b>: Patch Manager attempts to install missing
        /// packages without trying to reboot the system. Patches installed with this option are assigned a
        /// status of <code>InstalledPendingReboot</code>. These patches might not be in effect until a
        /// reboot is performed.</p>
        /// </li>
        /// </ul>
        pub fn reboot_option(mut self, input: crate::model::RebootOption) -> Self {
            self.reboot_option = Some(input);
            self
        }
        pub fn set_reboot_option(
            mut self,
            input: std::option::Option<crate::model::RebootOption>,
        ) -> Self {
            self.reboot_option = input;
            self
        }
        /// <p>The number of instances where patches that are specified as "Critical" for compliance
        /// reporting in the patch baseline are not installed. These patches might be missing, have failed
        /// installation, were rejected, or were installed but awaiting a required instance reboot. The
        /// status of these instances is <code>NON_COMPLIANT</code>.</p>
        pub fn critical_non_compliant_count(mut self, input: i32) -> Self {
            self.critical_non_compliant_count = Some(input);
            self
        }
        pub fn set_critical_non_compliant_count(mut self, input: std::option::Option<i32>) -> Self {
            self.critical_non_compliant_count = input;
            self
        }
        /// <p>The number of instances where patches that are specified as "Security" in a patch advisory
        /// are not installed. These patches might be missing, have failed installation, were rejected, or
        /// were installed but awaiting a required instance reboot. The status of these instances is
        /// <code>NON_COMPLIANT</code>.</p>
        pub fn security_non_compliant_count(mut self, input: i32) -> Self {
            self.security_non_compliant_count = Some(input);
            self
        }
        pub fn set_security_non_compliant_count(mut self, input: std::option::Option<i32>) -> Self {
            self.security_non_compliant_count = input;
            self
        }
        /// <p>The number of instances with patches installed that are specified as other than "Critical"
        /// or "Security" but are not compliant with the patch baseline. The status of these instances is
        /// NON_COMPLIANT.</p>
        pub fn other_non_compliant_count(mut self, input: i32) -> Self {
            self.other_non_compliant_count = Some(input);
            self
        }
        pub fn set_other_non_compliant_count(mut self, input: std::option::Option<i32>) -> Self {
            self.other_non_compliant_count = input;
            self
        }
        /// Consumes the builder and constructs a [`InstancePatchState`](crate::model::InstancePatchState)
        pub fn build(self) -> crate::model::InstancePatchState {
            crate::model::InstancePatchState {
                instance_id: self.instance_id,
                patch_group: self.patch_group,
                baseline_id: self.baseline_id,
                snapshot_id: self.snapshot_id,
                install_override_list: self.install_override_list,
                owner_information: self.owner_information,
                installed_count: self.installed_count.unwrap_or_default(),
                installed_other_count: self.installed_other_count.unwrap_or_default(),
                installed_pending_reboot_count: self.installed_pending_reboot_count,
                installed_rejected_count: self.installed_rejected_count,
                missing_count: self.missing_count.unwrap_or_default(),
                failed_count: self.failed_count.unwrap_or_default(),
                unreported_not_applicable_count: self.unreported_not_applicable_count,
                not_applicable_count: self.not_applicable_count.unwrap_or_default(),
                operation_start_time: self.operation_start_time,
                operation_end_time: self.operation_end_time,
                operation: self.operation,
                last_no_reboot_install_operation_time: self.last_no_reboot_install_operation_time,
                reboot_option: self.reboot_option,
                critical_non_compliant_count: self.critical_non_compliant_count,
                security_non_compliant_count: self.security_non_compliant_count,
                other_non_compliant_count: self.other_non_compliant_count,
            }
        }
    }
}
impl InstancePatchState {
    /// Creates a new builder-style object to manufacture [`InstancePatchState`](crate::model::InstancePatchState)
    pub fn builder() -> crate::model::instance_patch_state::Builder {
        crate::model::instance_patch_state::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RebootOption {
    NoReboot,
    RebootIfNeeded,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RebootOption {
    fn from(s: &str) -> Self {
        match s {
            "NoReboot" => RebootOption::NoReboot,
            "RebootIfNeeded" => RebootOption::RebootIfNeeded,
            other => RebootOption::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RebootOption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(RebootOption::from(s))
    }
}
impl RebootOption {
    pub fn as_str(&self) -> &str {
        match self {
            RebootOption::NoReboot => "NoReboot",
            RebootOption::RebootIfNeeded => "RebootIfNeeded",
            RebootOption::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for RebootOption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for RebootOption {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PatchOperationType {
    Install,
    Scan,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PatchOperationType {
    fn from(s: &str) -> Self {
        match s {
            "Install" => PatchOperationType::Install,
            "Scan" => PatchOperationType::Scan,
            other => PatchOperationType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PatchOperationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(PatchOperationType::from(s))
    }
}
impl PatchOperationType {
    pub fn as_str(&self) -> &str {
        match self {
            PatchOperationType::Install => "Install",
            PatchOperationType::Scan => "Scan",
            PatchOperationType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for PatchOperationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for PatchOperationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Defines a filter used in <a>DescribeInstancePatchStatesForPatchGroup</a> used to
/// scope down the information returned by the API.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InstancePatchStateFilter {
    /// <p>The key for the filter. Supported values are FailedCount, InstalledCount,
    /// InstalledOtherCount, MissingCount and NotApplicableCount.</p>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The value for the filter, must be an integer greater than or equal to 0.</p>
    #[serde(rename = "Values")]
    #[serde(default)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The type of comparison that should be performed for the value: Equal, NotEqual, LessThan or
    /// GreaterThan.</p>
    #[serde(rename = "Type")]
    #[serde(default)]
    pub r#type: std::option::Option<crate::model::InstancePatchStateOperatorType>,
}
impl std::fmt::Debug for InstancePatchStateFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstancePatchStateFilter");
        formatter.field("key", &self.key);
        formatter.field("values", &self.values);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`InstancePatchStateFilter`](crate::model::InstancePatchStateFilter)
pub mod instance_patch_state_filter {
    /// A builder for [`InstancePatchStateFilter`](crate::model::InstancePatchStateFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) r#type: std::option::Option<crate::model::InstancePatchStateOperatorType>,
    }
    impl Builder {
        /// <p>The key for the filter. Supported values are FailedCount, InstalledCount,
        /// InstalledOtherCount, MissingCount and NotApplicableCount.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// <p>The type of comparison that should be performed for the value: Equal, NotEqual, LessThan or
        /// GreaterThan.</p>
        pub fn r#type(mut self, input: crate::model::InstancePatchStateOperatorType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::InstancePatchStateOperatorType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`InstancePatchStateFilter`](crate::model::InstancePatchStateFilter)
        pub fn build(self) -> crate::model::InstancePatchStateFilter {
            crate::model::InstancePatchStateFilter {
                key: self.key,
                values: self.values,
                r#type: self.r#type,
            }
        }
    }
}
impl InstancePatchStateFilter {
    /// Creates a new builder-style object to manufacture [`InstancePatchStateFilter`](crate::model::InstancePatchStateFilter)
    pub fn builder() -> crate::model::instance_patch_state_filter::Builder {
        crate::model::instance_patch_state_filter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstancePatchStateOperatorType {
    Equal,
    GreaterThan,
    LessThan,
    NotEqual,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InstancePatchStateOperatorType {
    fn from(s: &str) -> Self {
        match s {
            "Equal" => InstancePatchStateOperatorType::Equal,
            "GreaterThan" => InstancePatchStateOperatorType::GreaterThan,
            "LessThan" => InstancePatchStateOperatorType::LessThan,
            "NotEqual" => InstancePatchStateOperatorType::NotEqual,
            other => InstancePatchStateOperatorType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InstancePatchStateOperatorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(InstancePatchStateOperatorType::from(s))
    }
}
impl InstancePatchStateOperatorType {
    pub fn as_str(&self) -> &str {
        match self {
            InstancePatchStateOperatorType::Equal => "Equal",
            InstancePatchStateOperatorType::GreaterThan => "GreaterThan",
            InstancePatchStateOperatorType::LessThan => "LessThan",
            InstancePatchStateOperatorType::NotEqual => "NotEqual",
            InstancePatchStateOperatorType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for InstancePatchStateOperatorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for InstancePatchStateOperatorType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Information about the state of a patch on a particular instance as it relates to the patch
/// baseline used to patch the instance.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PatchComplianceData {
    /// <p>The title of the patch.</p>
    #[serde(rename = "Title")]
    #[serde(default)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The operating system-specific ID of the patch.</p>
    #[serde(rename = "KBId")]
    #[serde(default)]
    pub kb_id: std::option::Option<std::string::String>,
    /// <p>The classification of the patch (for example, SecurityUpdates, Updates,
    /// CriticalUpdates).</p>
    #[serde(rename = "Classification")]
    #[serde(default)]
    pub classification: std::option::Option<std::string::String>,
    /// <p>The severity of the patch (for example, Critical, Important, Moderate).</p>
    #[serde(rename = "Severity")]
    #[serde(default)]
    pub severity: std::option::Option<std::string::String>,
    /// <p>The state of the patch on the instance, such as INSTALLED or FAILED.</p>
    /// <p>For descriptions of each patch state, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-compliance-about.html#sysman-compliance-monitor-patch">About patch compliance</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    #[serde(rename = "State")]
    #[serde(default)]
    pub state: std::option::Option<crate::model::PatchComplianceDataState>,
    /// <p>The date/time the patch was installed on the instance. Note that not all operating systems
    /// provide this level of information.</p>
    #[serde(rename = "InstalledTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub installed_time: std::option::Option<smithy_types::Instant>,
    /// <p>The IDs of one or more Common Vulnerabilities and Exposure (CVE) issues that are resolved by
    /// the patch.</p>
    #[serde(rename = "CVEIds")]
    #[serde(default)]
    pub cve_ids: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PatchComplianceData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PatchComplianceData");
        formatter.field("title", &self.title);
        formatter.field("kb_id", &self.kb_id);
        formatter.field("classification", &self.classification);
        formatter.field("severity", &self.severity);
        formatter.field("state", &self.state);
        formatter.field("installed_time", &self.installed_time);
        formatter.field("cve_ids", &self.cve_ids);
        formatter.finish()
    }
}
/// See [`PatchComplianceData`](crate::model::PatchComplianceData)
pub mod patch_compliance_data {
    /// A builder for [`PatchComplianceData`](crate::model::PatchComplianceData)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) kb_id: std::option::Option<std::string::String>,
        pub(crate) classification: std::option::Option<std::string::String>,
        pub(crate) severity: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::PatchComplianceDataState>,
        pub(crate) installed_time: std::option::Option<smithy_types::Instant>,
        pub(crate) cve_ids: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The title of the patch.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The operating system-specific ID of the patch.</p>
        pub fn kb_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kb_id = Some(input.into());
            self
        }
        pub fn set_kb_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kb_id = input;
            self
        }
        /// <p>The classification of the patch (for example, SecurityUpdates, Updates,
        /// CriticalUpdates).</p>
        pub fn classification(mut self, input: impl Into<std::string::String>) -> Self {
            self.classification = Some(input.into());
            self
        }
        pub fn set_classification(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.classification = input;
            self
        }
        /// <p>The severity of the patch (for example, Critical, Important, Moderate).</p>
        pub fn severity(mut self, input: impl Into<std::string::String>) -> Self {
            self.severity = Some(input.into());
            self
        }
        pub fn set_severity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.severity = input;
            self
        }
        /// <p>The state of the patch on the instance, such as INSTALLED or FAILED.</p>
        /// <p>For descriptions of each patch state, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-compliance-about.html#sysman-compliance-monitor-patch">About patch compliance</a> in the <i>AWS Systems Manager User Guide</i>.</p>
        pub fn state(mut self, input: crate::model::PatchComplianceDataState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::PatchComplianceDataState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The date/time the patch was installed on the instance. Note that not all operating systems
        /// provide this level of information.</p>
        pub fn installed_time(mut self, input: smithy_types::Instant) -> Self {
            self.installed_time = Some(input);
            self
        }
        pub fn set_installed_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.installed_time = input;
            self
        }
        /// <p>The IDs of one or more Common Vulnerabilities and Exposure (CVE) issues that are resolved by
        /// the patch.</p>
        pub fn cve_ids(mut self, input: impl Into<std::string::String>) -> Self {
            self.cve_ids = Some(input.into());
            self
        }
        pub fn set_cve_ids(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cve_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`PatchComplianceData`](crate::model::PatchComplianceData)
        pub fn build(self) -> crate::model::PatchComplianceData {
            crate::model::PatchComplianceData {
                title: self.title,
                kb_id: self.kb_id,
                classification: self.classification,
                severity: self.severity,
                state: self.state,
                installed_time: self.installed_time,
                cve_ids: self.cve_ids,
            }
        }
    }
}
impl PatchComplianceData {
    /// Creates a new builder-style object to manufacture [`PatchComplianceData`](crate::model::PatchComplianceData)
    pub fn builder() -> crate::model::patch_compliance_data::Builder {
        crate::model::patch_compliance_data::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PatchComplianceDataState {
    Failed,
    Installed,
    InstalledOther,
    InstalledPendingReboot,
    InstalledRejected,
    Missing,
    NotApplicable,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PatchComplianceDataState {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => PatchComplianceDataState::Failed,
            "INSTALLED" => PatchComplianceDataState::Installed,
            "INSTALLED_OTHER" => PatchComplianceDataState::InstalledOther,
            "INSTALLED_PENDING_REBOOT" => PatchComplianceDataState::InstalledPendingReboot,
            "INSTALLED_REJECTED" => PatchComplianceDataState::InstalledRejected,
            "MISSING" => PatchComplianceDataState::Missing,
            "NOT_APPLICABLE" => PatchComplianceDataState::NotApplicable,
            other => PatchComplianceDataState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PatchComplianceDataState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(PatchComplianceDataState::from(s))
    }
}
impl PatchComplianceDataState {
    pub fn as_str(&self) -> &str {
        match self {
            PatchComplianceDataState::Failed => "FAILED",
            PatchComplianceDataState::Installed => "INSTALLED",
            PatchComplianceDataState::InstalledOther => "INSTALLED_OTHER",
            PatchComplianceDataState::InstalledPendingReboot => "INSTALLED_PENDING_REBOOT",
            PatchComplianceDataState::InstalledRejected => "INSTALLED_REJECTED",
            PatchComplianceDataState::Missing => "MISSING",
            PatchComplianceDataState::NotApplicable => "NOT_APPLICABLE",
            PatchComplianceDataState::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for PatchComplianceDataState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for PatchComplianceDataState {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Describes a filter for a specific list of instances. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceInformation {
    /// <p>The instance ID. </p>
    #[serde(rename = "InstanceId")]
    #[serde(default)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>Connection status of SSM Agent. </p>
    /// <note>
    /// <p>The status <code>Inactive</code> has been deprecated and is no longer in use.</p>
    /// </note>
    #[serde(rename = "PingStatus")]
    #[serde(default)]
    pub ping_status: std::option::Option<crate::model::PingStatus>,
    /// <p>The date and time when the agent last pinged the Systems Manager service. </p>
    #[serde(rename = "LastPingDateTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_ping_date_time: std::option::Option<smithy_types::Instant>,
    /// <p>The version of SSM Agent running on your Linux instance. </p>
    #[serde(rename = "AgentVersion")]
    #[serde(default)]
    pub agent_version: std::option::Option<std::string::String>,
    /// <p>Indicates whether the latest version of SSM Agent is running on your Linux Managed Instance.
    /// This field does not indicate whether or not the latest version is installed on Windows managed
    /// instances, because some older versions of Windows Server use the EC2Config service to process SSM
    /// requests.</p>
    #[serde(rename = "IsLatestVersion")]
    #[serde(default)]
    pub is_latest_version: std::option::Option<bool>,
    /// <p>The operating system platform type. </p>
    #[serde(rename = "PlatformType")]
    #[serde(default)]
    pub platform_type: std::option::Option<crate::model::PlatformType>,
    /// <p>The name of the operating system platform running on your instance. </p>
    #[serde(rename = "PlatformName")]
    #[serde(default)]
    pub platform_name: std::option::Option<std::string::String>,
    /// <p>The version of the OS platform running on your instance. </p>
    #[serde(rename = "PlatformVersion")]
    #[serde(default)]
    pub platform_version: std::option::Option<std::string::String>,
    /// <p>The activation ID created by Systems Manager when the server or VM was registered.</p>
    #[serde(rename = "ActivationId")]
    #[serde(default)]
    pub activation_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Identity and Access Management (IAM) role assigned to the on-premises Systems Manager
    /// managed instance. This call does not return the IAM role for EC2 instances. To retrieve the IAM
    /// role for an EC2 instance, use the Amazon EC2 <code>DescribeInstances</code> action. For information,
    /// see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html">DescribeInstances</a> in the
    /// <i>Amazon EC2 API Reference</i> or <a href="https://docs.aws.amazon.com/cli/latest/ec2/describe-instances.html">describe-instances</a> in the <i>AWS CLI Command Reference</i>.</p>
    #[serde(rename = "IamRole")]
    #[serde(default)]
    pub iam_role: std::option::Option<std::string::String>,
    /// <p>The date the server or VM was registered with AWS as a managed instance.</p>
    #[serde(rename = "RegistrationDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub registration_date: std::option::Option<smithy_types::Instant>,
    /// <p>The type of instance. Instances are either EC2 instances or managed instances. </p>
    #[serde(rename = "ResourceType")]
    #[serde(default)]
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>The name assigned to an on-premises server or virtual machine (VM) when it is activated as a
    /// Systems Manager managed instance. The name is specified as the <code>DefaultInstanceName</code> property
    /// using the <a>CreateActivation</a> command. It is applied to the managed instance by
    /// specifying the Activation Code and Activation ID when you install SSM Agent on the instance, as
    /// explained in <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-install-managed-linux.html">Install SSM Agent for a
    /// hybrid environment (Linux)</a> and <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-install-managed-win.html">Install SSM Agent for a hybrid environment
    /// (Windows)</a>. To retrieve the Name tag of an EC2 instance, use the Amazon EC2
    /// <code>DescribeInstances</code> action. For information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html">DescribeInstances</a> in the
    /// <i>Amazon EC2 API Reference</i> or <a href="https://docs.aws.amazon.com/cli/latest/ec2/describe-instances.html">describe-instances</a> in the <i>AWS CLI Command Reference</i>.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The IP address of the managed instance.</p>
    #[serde(rename = "IPAddress")]
    #[serde(default)]
    pub ip_address: std::option::Option<std::string::String>,
    /// <p>The fully qualified host name of the managed instance.</p>
    #[serde(rename = "ComputerName")]
    #[serde(default)]
    pub computer_name: std::option::Option<std::string::String>,
    /// <p>The status of the association.</p>
    #[serde(rename = "AssociationStatus")]
    #[serde(default)]
    pub association_status: std::option::Option<std::string::String>,
    /// <p>The date the association was last run.</p>
    #[serde(rename = "LastAssociationExecutionDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_association_execution_date: std::option::Option<smithy_types::Instant>,
    /// <p>The last date the association was successfully run.</p>
    #[serde(rename = "LastSuccessfulAssociationExecutionDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_successful_association_execution_date: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the association.</p>
    #[serde(rename = "AssociationOverview")]
    #[serde(default)]
    pub association_overview:
        std::option::Option<crate::model::InstanceAggregatedAssociationOverview>,
}
impl std::fmt::Debug for InstanceInformation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceInformation");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("ping_status", &self.ping_status);
        formatter.field("last_ping_date_time", &self.last_ping_date_time);
        formatter.field("agent_version", &self.agent_version);
        formatter.field("is_latest_version", &self.is_latest_version);
        formatter.field("platform_type", &self.platform_type);
        formatter.field("platform_name", &self.platform_name);
        formatter.field("platform_version", &self.platform_version);
        formatter.field("activation_id", &self.activation_id);
        formatter.field("iam_role", &self.iam_role);
        formatter.field("registration_date", &self.registration_date);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("name", &self.name);
        formatter.field("ip_address", &self.ip_address);
        formatter.field("computer_name", &self.computer_name);
        formatter.field("association_status", &self.association_status);
        formatter.field(
            "last_association_execution_date",
            &self.last_association_execution_date,
        );
        formatter.field(
            "last_successful_association_execution_date",
            &self.last_successful_association_execution_date,
        );
        formatter.field("association_overview", &self.association_overview);
        formatter.finish()
    }
}
/// See [`InstanceInformation`](crate::model::InstanceInformation)
pub mod instance_information {
    /// A builder for [`InstanceInformation`](crate::model::InstanceInformation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) ping_status: std::option::Option<crate::model::PingStatus>,
        pub(crate) last_ping_date_time: std::option::Option<smithy_types::Instant>,
        pub(crate) agent_version: std::option::Option<std::string::String>,
        pub(crate) is_latest_version: std::option::Option<bool>,
        pub(crate) platform_type: std::option::Option<crate::model::PlatformType>,
        pub(crate) platform_name: std::option::Option<std::string::String>,
        pub(crate) platform_version: std::option::Option<std::string::String>,
        pub(crate) activation_id: std::option::Option<std::string::String>,
        pub(crate) iam_role: std::option::Option<std::string::String>,
        pub(crate) registration_date: std::option::Option<smithy_types::Instant>,
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) ip_address: std::option::Option<std::string::String>,
        pub(crate) computer_name: std::option::Option<std::string::String>,
        pub(crate) association_status: std::option::Option<std::string::String>,
        pub(crate) last_association_execution_date: std::option::Option<smithy_types::Instant>,
        pub(crate) last_successful_association_execution_date:
            std::option::Option<smithy_types::Instant>,
        pub(crate) association_overview:
            std::option::Option<crate::model::InstanceAggregatedAssociationOverview>,
    }
    impl Builder {
        /// <p>The instance ID. </p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>Connection status of SSM Agent. </p>
        /// <note>
        /// <p>The status <code>Inactive</code> has been deprecated and is no longer in use.</p>
        /// </note>
        pub fn ping_status(mut self, input: crate::model::PingStatus) -> Self {
            self.ping_status = Some(input);
            self
        }
        pub fn set_ping_status(
            mut self,
            input: std::option::Option<crate::model::PingStatus>,
        ) -> Self {
            self.ping_status = input;
            self
        }
        /// <p>The date and time when the agent last pinged the Systems Manager service. </p>
        pub fn last_ping_date_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_ping_date_time = Some(input);
            self
        }
        pub fn set_last_ping_date_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_ping_date_time = input;
            self
        }
        /// <p>The version of SSM Agent running on your Linux instance. </p>
        pub fn agent_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.agent_version = Some(input.into());
            self
        }
        pub fn set_agent_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.agent_version = input;
            self
        }
        /// <p>Indicates whether the latest version of SSM Agent is running on your Linux Managed Instance.
        /// This field does not indicate whether or not the latest version is installed on Windows managed
        /// instances, because some older versions of Windows Server use the EC2Config service to process SSM
        /// requests.</p>
        pub fn is_latest_version(mut self, input: bool) -> Self {
            self.is_latest_version = Some(input);
            self
        }
        pub fn set_is_latest_version(mut self, input: std::option::Option<bool>) -> Self {
            self.is_latest_version = input;
            self
        }
        /// <p>The operating system platform type. </p>
        pub fn platform_type(mut self, input: crate::model::PlatformType) -> Self {
            self.platform_type = Some(input);
            self
        }
        pub fn set_platform_type(
            mut self,
            input: std::option::Option<crate::model::PlatformType>,
        ) -> Self {
            self.platform_type = input;
            self
        }
        /// <p>The name of the operating system platform running on your instance. </p>
        pub fn platform_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform_name = Some(input.into());
            self
        }
        pub fn set_platform_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.platform_name = input;
            self
        }
        /// <p>The version of the OS platform running on your instance. </p>
        pub fn platform_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform_version = Some(input.into());
            self
        }
        pub fn set_platform_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.platform_version = input;
            self
        }
        /// <p>The activation ID created by Systems Manager when the server or VM was registered.</p>
        pub fn activation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.activation_id = Some(input.into());
            self
        }
        pub fn set_activation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.activation_id = input;
            self
        }
        /// <p>The Amazon Identity and Access Management (IAM) role assigned to the on-premises Systems Manager
        /// managed instance. This call does not return the IAM role for EC2 instances. To retrieve the IAM
        /// role for an EC2 instance, use the Amazon EC2 <code>DescribeInstances</code> action. For information,
        /// see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html">DescribeInstances</a> in the
        /// <i>Amazon EC2 API Reference</i> or <a href="https://docs.aws.amazon.com/cli/latest/ec2/describe-instances.html">describe-instances</a> in the <i>AWS CLI Command Reference</i>.</p>
        pub fn iam_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.iam_role = Some(input.into());
            self
        }
        pub fn set_iam_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.iam_role = input;
            self
        }
        /// <p>The date the server or VM was registered with AWS as a managed instance.</p>
        pub fn registration_date(mut self, input: smithy_types::Instant) -> Self {
            self.registration_date = Some(input);
            self
        }
        pub fn set_registration_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.registration_date = input;
            self
        }
        /// <p>The type of instance. Instances are either EC2 instances or managed instances. </p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The name assigned to an on-premises server or virtual machine (VM) when it is activated as a
        /// Systems Manager managed instance. The name is specified as the <code>DefaultInstanceName</code> property
        /// using the <a>CreateActivation</a> command. It is applied to the managed instance by
        /// specifying the Activation Code and Activation ID when you install SSM Agent on the instance, as
        /// explained in <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-install-managed-linux.html">Install SSM Agent for a
        /// hybrid environment (Linux)</a> and <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-install-managed-win.html">Install SSM Agent for a hybrid environment
        /// (Windows)</a>. To retrieve the Name tag of an EC2 instance, use the Amazon EC2
        /// <code>DescribeInstances</code> action. For information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html">DescribeInstances</a> in the
        /// <i>Amazon EC2 API Reference</i> or <a href="https://docs.aws.amazon.com/cli/latest/ec2/describe-instances.html">describe-instances</a> in the <i>AWS CLI Command Reference</i>.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The IP address of the managed instance.</p>
        pub fn ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.ip_address = Some(input.into());
            self
        }
        pub fn set_ip_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ip_address = input;
            self
        }
        /// <p>The fully qualified host name of the managed instance.</p>
        pub fn computer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.computer_name = Some(input.into());
            self
        }
        pub fn set_computer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.computer_name = input;
            self
        }
        /// <p>The status of the association.</p>
        pub fn association_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_status = Some(input.into());
            self
        }
        pub fn set_association_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_status = input;
            self
        }
        /// <p>The date the association was last run.</p>
        pub fn last_association_execution_date(mut self, input: smithy_types::Instant) -> Self {
            self.last_association_execution_date = Some(input);
            self
        }
        pub fn set_last_association_execution_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_association_execution_date = input;
            self
        }
        /// <p>The last date the association was successfully run.</p>
        pub fn last_successful_association_execution_date(
            mut self,
            input: smithy_types::Instant,
        ) -> Self {
            self.last_successful_association_execution_date = Some(input);
            self
        }
        pub fn set_last_successful_association_execution_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_successful_association_execution_date = input;
            self
        }
        /// <p>Information about the association.</p>
        pub fn association_overview(
            mut self,
            input: crate::model::InstanceAggregatedAssociationOverview,
        ) -> Self {
            self.association_overview = Some(input);
            self
        }
        pub fn set_association_overview(
            mut self,
            input: std::option::Option<crate::model::InstanceAggregatedAssociationOverview>,
        ) -> Self {
            self.association_overview = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceInformation`](crate::model::InstanceInformation)
        pub fn build(self) -> crate::model::InstanceInformation {
            crate::model::InstanceInformation {
                instance_id: self.instance_id,
                ping_status: self.ping_status,
                last_ping_date_time: self.last_ping_date_time,
                agent_version: self.agent_version,
                is_latest_version: self.is_latest_version,
                platform_type: self.platform_type,
                platform_name: self.platform_name,
                platform_version: self.platform_version,
                activation_id: self.activation_id,
                iam_role: self.iam_role,
                registration_date: self.registration_date,
                resource_type: self.resource_type,
                name: self.name,
                ip_address: self.ip_address,
                computer_name: self.computer_name,
                association_status: self.association_status,
                last_association_execution_date: self.last_association_execution_date,
                last_successful_association_execution_date: self
                    .last_successful_association_execution_date,
                association_overview: self.association_overview,
            }
        }
    }
}
impl InstanceInformation {
    /// Creates a new builder-style object to manufacture [`InstanceInformation`](crate::model::InstanceInformation)
    pub fn builder() -> crate::model::instance_information::Builder {
        crate::model::instance_information::Builder::default()
    }
}

/// <p>Status information about the aggregated associations.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceAggregatedAssociationOverview {
    /// <p>Detailed status information about the aggregated associations.</p>
    #[serde(rename = "DetailedStatus")]
    #[serde(default)]
    pub detailed_status: std::option::Option<std::string::String>,
    /// <p>The number of associations for the instance(s).</p>
    #[serde(rename = "InstanceAssociationStatusAggregatedCount")]
    #[serde(default)]
    pub instance_association_status_aggregated_count:
        std::option::Option<std::collections::HashMap<std::string::String, i32>>,
}
impl std::fmt::Debug for InstanceAggregatedAssociationOverview {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceAggregatedAssociationOverview");
        formatter.field("detailed_status", &self.detailed_status);
        formatter.field(
            "instance_association_status_aggregated_count",
            &self.instance_association_status_aggregated_count,
        );
        formatter.finish()
    }
}
/// See [`InstanceAggregatedAssociationOverview`](crate::model::InstanceAggregatedAssociationOverview)
pub mod instance_aggregated_association_overview {
    /// A builder for [`InstanceAggregatedAssociationOverview`](crate::model::InstanceAggregatedAssociationOverview)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) detailed_status: std::option::Option<std::string::String>,
        pub(crate) instance_association_status_aggregated_count:
            std::option::Option<std::collections::HashMap<std::string::String, i32>>,
    }
    impl Builder {
        /// <p>Detailed status information about the aggregated associations.</p>
        pub fn detailed_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.detailed_status = Some(input.into());
            self
        }
        pub fn set_detailed_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.detailed_status = input;
            self
        }
        pub fn instance_association_status_aggregated_count(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<i32>,
        ) -> Self {
            let mut hash_map = self
                .instance_association_status_aggregated_count
                .unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.instance_association_status_aggregated_count = Some(hash_map);
            self
        }
        pub fn set_instance_association_status_aggregated_count(
            mut self,
            input: std::option::Option<std::collections::HashMap<std::string::String, i32>>,
        ) -> Self {
            self.instance_association_status_aggregated_count = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceAggregatedAssociationOverview`](crate::model::InstanceAggregatedAssociationOverview)
        pub fn build(self) -> crate::model::InstanceAggregatedAssociationOverview {
            crate::model::InstanceAggregatedAssociationOverview {
                detailed_status: self.detailed_status,
                instance_association_status_aggregated_count: self
                    .instance_association_status_aggregated_count,
            }
        }
    }
}
impl InstanceAggregatedAssociationOverview {
    /// Creates a new builder-style object to manufacture [`InstanceAggregatedAssociationOverview`](crate::model::InstanceAggregatedAssociationOverview)
    pub fn builder() -> crate::model::instance_aggregated_association_overview::Builder {
        crate::model::instance_aggregated_association_overview::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceType {
    Document,
    Ec2Instance,
    ManagedInstance,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ResourceType {
    fn from(s: &str) -> Self {
        match s {
            "Document" => ResourceType::Document,
            "EC2Instance" => ResourceType::Ec2Instance,
            "ManagedInstance" => ResourceType::ManagedInstance,
            other => ResourceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ResourceType::from(s))
    }
}
impl ResourceType {
    pub fn as_str(&self) -> &str {
        match self {
            ResourceType::Document => "Document",
            ResourceType::Ec2Instance => "EC2Instance",
            ResourceType::ManagedInstance => "ManagedInstance",
            ResourceType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ResourceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PingStatus {
    ConnectionLost,
    Inactive,
    Online,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PingStatus {
    fn from(s: &str) -> Self {
        match s {
            "ConnectionLost" => PingStatus::ConnectionLost,
            "Inactive" => PingStatus::Inactive,
            "Online" => PingStatus::Online,
            other => PingStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PingStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(PingStatus::from(s))
    }
}
impl PingStatus {
    pub fn as_str(&self) -> &str {
        match self {
            PingStatus::ConnectionLost => "ConnectionLost",
            PingStatus::Inactive => "Inactive",
            PingStatus::Online => "Online",
            PingStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for PingStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for PingStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>The filters to describe or get information about your managed instances.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceInformationStringFilter {
    /// <p>The filter key name to describe your instances. For example:</p>
    /// <p>"InstanceIds"|"AgentVersion"|"PingStatus"|"PlatformTypes"|"ActivationIds"|"IamRole"|"ResourceType"|"AssociationStatus"|"Tag
    /// Key"</p>
    /// <important>
    /// <p>
    /// <code>Tag key</code> is not a valid filter. You must specify either <code>tag-key</code> or
    /// <code>tag:keyname</code> and a string. Here are some valid examples: tag-key, tag:123, tag:al!,
    /// tag:Windows. Here are some <i>invalid</i> examples: tag-keys, Tag Key, tag:,
    /// tagKey, abc:keyname.</p>
    /// </important>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The filter values.</p>
    #[serde(rename = "Values")]
    #[serde(default)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for InstanceInformationStringFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceInformationStringFilter");
        formatter.field("key", &self.key);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`InstanceInformationStringFilter`](crate::model::InstanceInformationStringFilter)
pub mod instance_information_string_filter {
    /// A builder for [`InstanceInformationStringFilter`](crate::model::InstanceInformationStringFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The filter key name to describe your instances. For example:</p>
        /// <p>"InstanceIds"|"AgentVersion"|"PingStatus"|"PlatformTypes"|"ActivationIds"|"IamRole"|"ResourceType"|"AssociationStatus"|"Tag
        /// Key"</p>
        /// <important>
        /// <p>
        /// <code>Tag key</code> is not a valid filter. You must specify either <code>tag-key</code> or
        /// <code>tag:keyname</code> and a string. Here are some valid examples: tag-key, tag:123, tag:al!,
        /// tag:Windows. Here are some <i>invalid</i> examples: tag-keys, Tag Key, tag:,
        /// tagKey, abc:keyname.</p>
        /// </important>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceInformationStringFilter`](crate::model::InstanceInformationStringFilter)
        pub fn build(self) -> crate::model::InstanceInformationStringFilter {
            crate::model::InstanceInformationStringFilter {
                key: self.key,
                values: self.values,
            }
        }
    }
}
impl InstanceInformationStringFilter {
    /// Creates a new builder-style object to manufacture [`InstanceInformationStringFilter`](crate::model::InstanceInformationStringFilter)
    pub fn builder() -> crate::model::instance_information_string_filter::Builder {
        crate::model::instance_information_string_filter::Builder::default()
    }
}

/// <p>Describes a filter for a specific list of instances. You can filter instances information by
/// using tags. You specify tags by using a key-value mapping.</p>
/// <p>Use this action instead of the <a>DescribeInstanceInformationRequest$InstanceInformationFilterList</a> method. The
/// <code>InstanceInformationFilterList</code> method is a legacy method and does not support tags.
/// </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceInformationFilter {
    /// <p>The name of the filter. </p>
    #[serde(rename = "key")]
    #[serde(default)]
    pub key: std::option::Option<crate::model::InstanceInformationFilterKey>,
    /// <p>The filter values.</p>
    #[serde(rename = "valueSet")]
    #[serde(default)]
    pub value_set: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for InstanceInformationFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceInformationFilter");
        formatter.field("key", &self.key);
        formatter.field("value_set", &self.value_set);
        formatter.finish()
    }
}
/// See [`InstanceInformationFilter`](crate::model::InstanceInformationFilter)
pub mod instance_information_filter {
    /// A builder for [`InstanceInformationFilter`](crate::model::InstanceInformationFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<crate::model::InstanceInformationFilterKey>,
        pub(crate) value_set: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the filter. </p>
        pub fn key(mut self, input: crate::model::InstanceInformationFilterKey) -> Self {
            self.key = Some(input);
            self
        }
        pub fn set_key(
            mut self,
            input: std::option::Option<crate::model::InstanceInformationFilterKey>,
        ) -> Self {
            self.key = input;
            self
        }
        pub fn value_set(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.value_set.unwrap_or_default();
            v.push(input.into());
            self.value_set = Some(v);
            self
        }
        pub fn set_value_set(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.value_set = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceInformationFilter`](crate::model::InstanceInformationFilter)
        pub fn build(self) -> crate::model::InstanceInformationFilter {
            crate::model::InstanceInformationFilter {
                key: self.key,
                value_set: self.value_set,
            }
        }
    }
}
impl InstanceInformationFilter {
    /// Creates a new builder-style object to manufacture [`InstanceInformationFilter`](crate::model::InstanceInformationFilter)
    pub fn builder() -> crate::model::instance_information_filter::Builder {
        crate::model::instance_information_filter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceInformationFilterKey {
    ActivationIds,
    AgentVersion,
    AssociationStatus,
    IamRole,
    InstanceIds,
    PingStatus,
    PlatformTypes,
    ResourceType,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InstanceInformationFilterKey {
    fn from(s: &str) -> Self {
        match s {
            "ActivationIds" => InstanceInformationFilterKey::ActivationIds,
            "AgentVersion" => InstanceInformationFilterKey::AgentVersion,
            "AssociationStatus" => InstanceInformationFilterKey::AssociationStatus,
            "IamRole" => InstanceInformationFilterKey::IamRole,
            "InstanceIds" => InstanceInformationFilterKey::InstanceIds,
            "PingStatus" => InstanceInformationFilterKey::PingStatus,
            "PlatformTypes" => InstanceInformationFilterKey::PlatformTypes,
            "ResourceType" => InstanceInformationFilterKey::ResourceType,
            other => InstanceInformationFilterKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InstanceInformationFilterKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(InstanceInformationFilterKey::from(s))
    }
}
impl InstanceInformationFilterKey {
    pub fn as_str(&self) -> &str {
        match self {
            InstanceInformationFilterKey::ActivationIds => "ActivationIds",
            InstanceInformationFilterKey::AgentVersion => "AgentVersion",
            InstanceInformationFilterKey::AssociationStatus => "AssociationStatus",
            InstanceInformationFilterKey::IamRole => "IamRole",
            InstanceInformationFilterKey::InstanceIds => "InstanceIds",
            InstanceInformationFilterKey::PingStatus => "PingStatus",
            InstanceInformationFilterKey::PlatformTypes => "PlatformTypes",
            InstanceInformationFilterKey::ResourceType => "ResourceType",
            InstanceInformationFilterKey::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for InstanceInformationFilterKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for InstanceInformationFilterKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Status information about the instance association.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceAssociationStatusInfo {
    /// <p>The association ID.</p>
    #[serde(rename = "AssociationId")]
    #[serde(default)]
    pub association_id: std::option::Option<std::string::String>,
    /// <p>The name of the association.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The association document versions.</p>
    #[serde(rename = "DocumentVersion")]
    #[serde(default)]
    pub document_version: std::option::Option<std::string::String>,
    /// <p>The version of the association applied to the instance.</p>
    #[serde(rename = "AssociationVersion")]
    #[serde(default)]
    pub association_version: std::option::Option<std::string::String>,
    /// <p>The instance ID where the association was created.</p>
    #[serde(rename = "InstanceId")]
    #[serde(default)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The date the instance association ran. </p>
    #[serde(rename = "ExecutionDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub execution_date: std::option::Option<smithy_types::Instant>,
    /// <p>Status information about the instance association.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<std::string::String>,
    /// <p>Detailed status information about the instance association.</p>
    #[serde(rename = "DetailedStatus")]
    #[serde(default)]
    pub detailed_status: std::option::Option<std::string::String>,
    /// <p>Summary information about association execution.</p>
    #[serde(rename = "ExecutionSummary")]
    #[serde(default)]
    pub execution_summary: std::option::Option<std::string::String>,
    /// <p>An error code returned by the request to create the association.</p>
    #[serde(rename = "ErrorCode")]
    #[serde(default)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>A URL for an S3 bucket where you want to store the results of this request.</p>
    #[serde(rename = "OutputUrl")]
    #[serde(default)]
    pub output_url: std::option::Option<crate::model::InstanceAssociationOutputUrl>,
    /// <p>The name of the association applied to the instance.</p>
    #[serde(rename = "AssociationName")]
    #[serde(default)]
    pub association_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InstanceAssociationStatusInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceAssociationStatusInfo");
        formatter.field("association_id", &self.association_id);
        formatter.field("name", &self.name);
        formatter.field("document_version", &self.document_version);
        formatter.field("association_version", &self.association_version);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("execution_date", &self.execution_date);
        formatter.field("status", &self.status);
        formatter.field("detailed_status", &self.detailed_status);
        formatter.field("execution_summary", &self.execution_summary);
        formatter.field("error_code", &self.error_code);
        formatter.field("output_url", &self.output_url);
        formatter.field("association_name", &self.association_name);
        formatter.finish()
    }
}
/// See [`InstanceAssociationStatusInfo`](crate::model::InstanceAssociationStatusInfo)
pub mod instance_association_status_info {
    /// A builder for [`InstanceAssociationStatusInfo`](crate::model::InstanceAssociationStatusInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) document_version: std::option::Option<std::string::String>,
        pub(crate) association_version: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) execution_date: std::option::Option<smithy_types::Instant>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) detailed_status: std::option::Option<std::string::String>,
        pub(crate) execution_summary: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) output_url: std::option::Option<crate::model::InstanceAssociationOutputUrl>,
        pub(crate) association_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The association ID.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>The name of the association.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The association document versions.</p>
        pub fn document_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_version = Some(input.into());
            self
        }
        pub fn set_document_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_version = input;
            self
        }
        /// <p>The version of the association applied to the instance.</p>
        pub fn association_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_version = Some(input.into());
            self
        }
        pub fn set_association_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_version = input;
            self
        }
        /// <p>The instance ID where the association was created.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The date the instance association ran. </p>
        pub fn execution_date(mut self, input: smithy_types::Instant) -> Self {
            self.execution_date = Some(input);
            self
        }
        pub fn set_execution_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.execution_date = input;
            self
        }
        /// <p>Status information about the instance association.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>Detailed status information about the instance association.</p>
        pub fn detailed_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.detailed_status = Some(input.into());
            self
        }
        pub fn set_detailed_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.detailed_status = input;
            self
        }
        /// <p>Summary information about association execution.</p>
        pub fn execution_summary(mut self, input: impl Into<std::string::String>) -> Self {
            self.execution_summary = Some(input.into());
            self
        }
        pub fn set_execution_summary(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.execution_summary = input;
            self
        }
        /// <p>An error code returned by the request to create the association.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>A URL for an S3 bucket where you want to store the results of this request.</p>
        pub fn output_url(mut self, input: crate::model::InstanceAssociationOutputUrl) -> Self {
            self.output_url = Some(input);
            self
        }
        pub fn set_output_url(
            mut self,
            input: std::option::Option<crate::model::InstanceAssociationOutputUrl>,
        ) -> Self {
            self.output_url = input;
            self
        }
        /// <p>The name of the association applied to the instance.</p>
        pub fn association_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_name = Some(input.into());
            self
        }
        pub fn set_association_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_name = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceAssociationStatusInfo`](crate::model::InstanceAssociationStatusInfo)
        pub fn build(self) -> crate::model::InstanceAssociationStatusInfo {
            crate::model::InstanceAssociationStatusInfo {
                association_id: self.association_id,
                name: self.name,
                document_version: self.document_version,
                association_version: self.association_version,
                instance_id: self.instance_id,
                execution_date: self.execution_date,
                status: self.status,
                detailed_status: self.detailed_status,
                execution_summary: self.execution_summary,
                error_code: self.error_code,
                output_url: self.output_url,
                association_name: self.association_name,
            }
        }
    }
}
impl InstanceAssociationStatusInfo {
    /// Creates a new builder-style object to manufacture [`InstanceAssociationStatusInfo`](crate::model::InstanceAssociationStatusInfo)
    pub fn builder() -> crate::model::instance_association_status_info::Builder {
        crate::model::instance_association_status_info::Builder::default()
    }
}

/// <p>The URL of S3 bucket where you want to store the results of this request.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceAssociationOutputUrl {
    /// <p>The URL of S3 bucket where you want to store the results of this request.</p>
    #[serde(rename = "S3OutputUrl")]
    #[serde(default)]
    pub s3_output_url: std::option::Option<crate::model::S3OutputUrl>,
}
impl std::fmt::Debug for InstanceAssociationOutputUrl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceAssociationOutputUrl");
        formatter.field("s3_output_url", &self.s3_output_url);
        formatter.finish()
    }
}
/// See [`InstanceAssociationOutputUrl`](crate::model::InstanceAssociationOutputUrl)
pub mod instance_association_output_url {
    /// A builder for [`InstanceAssociationOutputUrl`](crate::model::InstanceAssociationOutputUrl)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_output_url: std::option::Option<crate::model::S3OutputUrl>,
    }
    impl Builder {
        /// <p>The URL of S3 bucket where you want to store the results of this request.</p>
        pub fn s3_output_url(mut self, input: crate::model::S3OutputUrl) -> Self {
            self.s3_output_url = Some(input);
            self
        }
        pub fn set_s3_output_url(
            mut self,
            input: std::option::Option<crate::model::S3OutputUrl>,
        ) -> Self {
            self.s3_output_url = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceAssociationOutputUrl`](crate::model::InstanceAssociationOutputUrl)
        pub fn build(self) -> crate::model::InstanceAssociationOutputUrl {
            crate::model::InstanceAssociationOutputUrl {
                s3_output_url: self.s3_output_url,
            }
        }
    }
}
impl InstanceAssociationOutputUrl {
    /// Creates a new builder-style object to manufacture [`InstanceAssociationOutputUrl`](crate::model::InstanceAssociationOutputUrl)
    pub fn builder() -> crate::model::instance_association_output_url::Builder {
        crate::model::instance_association_output_url::Builder::default()
    }
}

/// <p>A URL for the S3 bucket where you want to store the results of this request.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct S3OutputUrl {
    /// <p>A URL for an S3 bucket where you want to store the results of this request.</p>
    #[serde(rename = "OutputUrl")]
    #[serde(default)]
    pub output_url: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for S3OutputUrl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3OutputUrl");
        formatter.field("output_url", &self.output_url);
        formatter.finish()
    }
}
/// See [`S3OutputUrl`](crate::model::S3OutputUrl)
pub mod s3_output_url {
    /// A builder for [`S3OutputUrl`](crate::model::S3OutputUrl)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) output_url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A URL for an S3 bucket where you want to store the results of this request.</p>
        pub fn output_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_url = Some(input.into());
            self
        }
        pub fn set_output_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.output_url = input;
            self
        }
        /// Consumes the builder and constructs a [`S3OutputUrl`](crate::model::S3OutputUrl)
        pub fn build(self) -> crate::model::S3OutputUrl {
            crate::model::S3OutputUrl {
                output_url: self.output_url,
            }
        }
    }
}
impl S3OutputUrl {
    /// Creates a new builder-style object to manufacture [`S3OutputUrl`](crate::model::S3OutputUrl)
    pub fn builder() -> crate::model::s3_output_url::Builder {
        crate::model::s3_output_url::Builder::default()
    }
}

/// <p>The EffectivePatch structure defines metadata about a patch along with the approval state of
/// the patch in a particular patch baseline. The approval state includes information about whether
/// the patch is currently approved, due to be approved by a rule, explicitly approved, or explicitly
/// rejected and the date the patch was or will be approved.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct EffectivePatch {
    /// <p>Provides metadata for a patch, including information such as the KB ID, severity,
    /// classification and a URL for where more information can be obtained about the patch.</p>
    #[serde(rename = "Patch")]
    #[serde(default)]
    pub patch: std::option::Option<crate::model::Patch>,
    /// <p>The status of the patch in a patch baseline. This includes information about whether the
    /// patch is currently approved, due to be approved by a rule, explicitly approved, or explicitly
    /// rejected and the date the patch was or will be approved.</p>
    #[serde(rename = "PatchStatus")]
    #[serde(default)]
    pub patch_status: std::option::Option<crate::model::PatchStatus>,
}
impl std::fmt::Debug for EffectivePatch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EffectivePatch");
        formatter.field("patch", &self.patch);
        formatter.field("patch_status", &self.patch_status);
        formatter.finish()
    }
}
/// See [`EffectivePatch`](crate::model::EffectivePatch)
pub mod effective_patch {
    /// A builder for [`EffectivePatch`](crate::model::EffectivePatch)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) patch: std::option::Option<crate::model::Patch>,
        pub(crate) patch_status: std::option::Option<crate::model::PatchStatus>,
    }
    impl Builder {
        /// <p>Provides metadata for a patch, including information such as the KB ID, severity,
        /// classification and a URL for where more information can be obtained about the patch.</p>
        pub fn patch(mut self, input: crate::model::Patch) -> Self {
            self.patch = Some(input);
            self
        }
        pub fn set_patch(mut self, input: std::option::Option<crate::model::Patch>) -> Self {
            self.patch = input;
            self
        }
        /// <p>The status of the patch in a patch baseline. This includes information about whether the
        /// patch is currently approved, due to be approved by a rule, explicitly approved, or explicitly
        /// rejected and the date the patch was or will be approved.</p>
        pub fn patch_status(mut self, input: crate::model::PatchStatus) -> Self {
            self.patch_status = Some(input);
            self
        }
        pub fn set_patch_status(
            mut self,
            input: std::option::Option<crate::model::PatchStatus>,
        ) -> Self {
            self.patch_status = input;
            self
        }
        /// Consumes the builder and constructs a [`EffectivePatch`](crate::model::EffectivePatch)
        pub fn build(self) -> crate::model::EffectivePatch {
            crate::model::EffectivePatch {
                patch: self.patch,
                patch_status: self.patch_status,
            }
        }
    }
}
impl EffectivePatch {
    /// Creates a new builder-style object to manufacture [`EffectivePatch`](crate::model::EffectivePatch)
    pub fn builder() -> crate::model::effective_patch::Builder {
        crate::model::effective_patch::Builder::default()
    }
}

/// <p>Information about the approval status of a patch.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PatchStatus {
    /// <p>The approval status of a patch (APPROVED, PENDING_APPROVAL, EXPLICIT_APPROVED,
    /// EXPLICIT_REJECTED).</p>
    #[serde(rename = "DeploymentStatus")]
    #[serde(default)]
    pub deployment_status: std::option::Option<crate::model::PatchDeploymentStatus>,
    /// <p>The compliance severity level for a patch.</p>
    #[serde(rename = "ComplianceLevel")]
    #[serde(default)]
    pub compliance_level: std::option::Option<crate::model::PatchComplianceLevel>,
    /// <p>The date the patch was approved (or will be approved if the status is
    /// PENDING_APPROVAL).</p>
    #[serde(rename = "ApprovalDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub approval_date: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for PatchStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PatchStatus");
        formatter.field("deployment_status", &self.deployment_status);
        formatter.field("compliance_level", &self.compliance_level);
        formatter.field("approval_date", &self.approval_date);
        formatter.finish()
    }
}
/// See [`PatchStatus`](crate::model::PatchStatus)
pub mod patch_status {
    /// A builder for [`PatchStatus`](crate::model::PatchStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) deployment_status: std::option::Option<crate::model::PatchDeploymentStatus>,
        pub(crate) compliance_level: std::option::Option<crate::model::PatchComplianceLevel>,
        pub(crate) approval_date: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The approval status of a patch (APPROVED, PENDING_APPROVAL, EXPLICIT_APPROVED,
        /// EXPLICIT_REJECTED).</p>
        pub fn deployment_status(mut self, input: crate::model::PatchDeploymentStatus) -> Self {
            self.deployment_status = Some(input);
            self
        }
        pub fn set_deployment_status(
            mut self,
            input: std::option::Option<crate::model::PatchDeploymentStatus>,
        ) -> Self {
            self.deployment_status = input;
            self
        }
        /// <p>The compliance severity level for a patch.</p>
        pub fn compliance_level(mut self, input: crate::model::PatchComplianceLevel) -> Self {
            self.compliance_level = Some(input);
            self
        }
        pub fn set_compliance_level(
            mut self,
            input: std::option::Option<crate::model::PatchComplianceLevel>,
        ) -> Self {
            self.compliance_level = input;
            self
        }
        /// <p>The date the patch was approved (or will be approved if the status is
        /// PENDING_APPROVAL).</p>
        pub fn approval_date(mut self, input: smithy_types::Instant) -> Self {
            self.approval_date = Some(input);
            self
        }
        pub fn set_approval_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.approval_date = input;
            self
        }
        /// Consumes the builder and constructs a [`PatchStatus`](crate::model::PatchStatus)
        pub fn build(self) -> crate::model::PatchStatus {
            crate::model::PatchStatus {
                deployment_status: self.deployment_status,
                compliance_level: self.compliance_level,
                approval_date: self.approval_date,
            }
        }
    }
}
impl PatchStatus {
    /// Creates a new builder-style object to manufacture [`PatchStatus`](crate::model::PatchStatus)
    pub fn builder() -> crate::model::patch_status::Builder {
        crate::model::patch_status::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PatchDeploymentStatus {
    Approved,
    ExplicitApproved,
    ExplicitRejected,
    PendingApproval,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PatchDeploymentStatus {
    fn from(s: &str) -> Self {
        match s {
            "APPROVED" => PatchDeploymentStatus::Approved,
            "EXPLICIT_APPROVED" => PatchDeploymentStatus::ExplicitApproved,
            "EXPLICIT_REJECTED" => PatchDeploymentStatus::ExplicitRejected,
            "PENDING_APPROVAL" => PatchDeploymentStatus::PendingApproval,
            other => PatchDeploymentStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PatchDeploymentStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(PatchDeploymentStatus::from(s))
    }
}
impl PatchDeploymentStatus {
    pub fn as_str(&self) -> &str {
        match self {
            PatchDeploymentStatus::Approved => "APPROVED",
            PatchDeploymentStatus::ExplicitApproved => "EXPLICIT_APPROVED",
            PatchDeploymentStatus::ExplicitRejected => "EXPLICIT_REJECTED",
            PatchDeploymentStatus::PendingApproval => "PENDING_APPROVAL",
            PatchDeploymentStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for PatchDeploymentStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for PatchDeploymentStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Represents metadata about a patch.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct Patch {
    /// <p>The ID of the patch. Applies to Windows patches only.</p>
    /// <note>
    /// <p>This ID is not the same as the Microsoft Knowledge Base ID.</p>
    /// </note>
    #[serde(rename = "Id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The date the patch was released.</p>
    #[serde(rename = "ReleaseDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub release_date: std::option::Option<smithy_types::Instant>,
    /// <p>The title of the patch.</p>
    #[serde(rename = "Title")]
    #[serde(default)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The description of the patch.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The URL where more information can be obtained about the patch.</p>
    #[serde(rename = "ContentUrl")]
    #[serde(default)]
    pub content_url: std::option::Option<std::string::String>,
    /// <p>The name of the vendor providing the patch.</p>
    #[serde(rename = "Vendor")]
    #[serde(default)]
    pub vendor: std::option::Option<std::string::String>,
    /// <p>The product family the patch is applicable for. For example, <code>Windows</code> or
    /// <code>Amazon Linux 2</code>.</p>
    #[serde(rename = "ProductFamily")]
    #[serde(default)]
    pub product_family: std::option::Option<std::string::String>,
    /// <p>The specific product the patch is applicable for. For example,
    /// <code>WindowsServer2016</code> or <code>AmazonLinux2018.03</code>.</p>
    #[serde(rename = "Product")]
    #[serde(default)]
    pub product: std::option::Option<std::string::String>,
    /// <p>The classification of the patch. For example, <code>SecurityUpdates</code>,
    /// <code>Updates</code>, or <code>CriticalUpdates</code>.</p>
    #[serde(rename = "Classification")]
    #[serde(default)]
    pub classification: std::option::Option<std::string::String>,
    /// <p>The severity of the patch, such as <code>Critical</code>, <code>Important</code>, or
    /// <code>Moderate</code>. Applies to Windows patches only.</p>
    #[serde(rename = "MsrcSeverity")]
    #[serde(default)]
    pub msrc_severity: std::option::Option<std::string::String>,
    /// <p>The Microsoft Knowledge Base ID of the patch. Applies to Windows patches only.</p>
    #[serde(rename = "KbNumber")]
    #[serde(default)]
    pub kb_number: std::option::Option<std::string::String>,
    /// <p>The ID of the Microsoft Security Response Center (MSRC) bulletin the patch is related to.
    /// For example, <code>MS14-045</code>. Applies to Windows patches only.</p>
    #[serde(rename = "MsrcNumber")]
    #[serde(default)]
    pub msrc_number: std::option::Option<std::string::String>,
    /// <p>The language of the patch if it's language-specific.</p>
    #[serde(rename = "Language")]
    #[serde(default)]
    pub language: std::option::Option<std::string::String>,
    /// <p>The Advisory ID of the patch. For example, <code>RHSA-2020:3779</code>. Applies to
    /// Linux-based instances only.</p>
    #[serde(rename = "AdvisoryIds")]
    #[serde(default)]
    pub advisory_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The Bugzilla ID of the patch. For example, <code>1600646</code>. Applies to Linux-based
    /// instances only.</p>
    #[serde(rename = "BugzillaIds")]
    #[serde(default)]
    pub bugzilla_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The Common Vulnerabilities and Exposures (CVE) ID of the patch. For example,
    /// <code>CVE-2011-3192</code>. Applies to Linux-based instances only.</p>
    #[serde(rename = "CVEIds")]
    #[serde(default)]
    pub cve_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name of the patch. Applies to Linux-based instances only.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The epoch of the patch. For example in
    /// <code>pkg-example-EE-20180914-2.2.amzn1.noarch</code>, the epoch value is
    /// <code>20180914-2</code>. Applies to Linux-based instances only.</p>
    #[serde(rename = "Epoch")]
    #[serde(default)]
    pub epoch: i32,
    /// <p>The version number of the patch. For example, in
    /// <code>example-pkg-1.710.10-2.7.abcd.x86_64</code>, the version number is indicated by
    /// <code>-1</code>. Applies to Linux-based instances only.</p>
    #[serde(rename = "Version")]
    #[serde(default)]
    pub version: std::option::Option<std::string::String>,
    /// <p>The particular release of a patch. For example, in
    /// <code>pkg-example-EE-20180914-2.2.amzn1.noarch</code>, the release is <code>2.amaz1</code>.
    /// Applies to Linux-based instances only.</p>
    #[serde(rename = "Release")]
    #[serde(default)]
    pub release: std::option::Option<std::string::String>,
    /// <p>The architecture of the patch. For example, in
    /// <code>example-pkg-0.710.10-2.7.abcd.x86_64</code>, the architecture is indicated by
    /// <code>x86_64</code>. Applies to Linux-based instances only.</p>
    #[serde(rename = "Arch")]
    #[serde(default)]
    pub arch: std::option::Option<std::string::String>,
    /// <p>The severity level of the patch. For example, <code>CRITICAL</code> or
    /// <code>MODERATE</code>.</p>
    #[serde(rename = "Severity")]
    #[serde(default)]
    pub severity: std::option::Option<std::string::String>,
    /// <p>The source patch repository for the operating system and version, such as
    /// <code>trusty-security</code> for Ubuntu Server 14.04 LTE and <code>focal-security</code> for
    /// Ubuntu Server 20.04 LTE. Applies to Linux-based instances only.</p>
    #[serde(rename = "Repository")]
    #[serde(default)]
    pub repository: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Patch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Patch");
        formatter.field("id", &self.id);
        formatter.field("release_date", &self.release_date);
        formatter.field("title", &self.title);
        formatter.field("description", &self.description);
        formatter.field("content_url", &self.content_url);
        formatter.field("vendor", &self.vendor);
        formatter.field("product_family", &self.product_family);
        formatter.field("product", &self.product);
        formatter.field("classification", &self.classification);
        formatter.field("msrc_severity", &self.msrc_severity);
        formatter.field("kb_number", &self.kb_number);
        formatter.field("msrc_number", &self.msrc_number);
        formatter.field("language", &self.language);
        formatter.field("advisory_ids", &self.advisory_ids);
        formatter.field("bugzilla_ids", &self.bugzilla_ids);
        formatter.field("cve_ids", &self.cve_ids);
        formatter.field("name", &self.name);
        formatter.field("epoch", &self.epoch);
        formatter.field("version", &self.version);
        formatter.field("release", &self.release);
        formatter.field("arch", &self.arch);
        formatter.field("severity", &self.severity);
        formatter.field("repository", &self.repository);
        formatter.finish()
    }
}
/// See [`Patch`](crate::model::Patch)
pub mod patch {
    /// A builder for [`Patch`](crate::model::Patch)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) release_date: std::option::Option<smithy_types::Instant>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) content_url: std::option::Option<std::string::String>,
        pub(crate) vendor: std::option::Option<std::string::String>,
        pub(crate) product_family: std::option::Option<std::string::String>,
        pub(crate) product: std::option::Option<std::string::String>,
        pub(crate) classification: std::option::Option<std::string::String>,
        pub(crate) msrc_severity: std::option::Option<std::string::String>,
        pub(crate) kb_number: std::option::Option<std::string::String>,
        pub(crate) msrc_number: std::option::Option<std::string::String>,
        pub(crate) language: std::option::Option<std::string::String>,
        pub(crate) advisory_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) bugzilla_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) cve_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) epoch: std::option::Option<i32>,
        pub(crate) version: std::option::Option<std::string::String>,
        pub(crate) release: std::option::Option<std::string::String>,
        pub(crate) arch: std::option::Option<std::string::String>,
        pub(crate) severity: std::option::Option<std::string::String>,
        pub(crate) repository: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the patch. Applies to Windows patches only.</p>
        /// <note>
        /// <p>This ID is not the same as the Microsoft Knowledge Base ID.</p>
        /// </note>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The date the patch was released.</p>
        pub fn release_date(mut self, input: smithy_types::Instant) -> Self {
            self.release_date = Some(input);
            self
        }
        pub fn set_release_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.release_date = input;
            self
        }
        /// <p>The title of the patch.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The description of the patch.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The URL where more information can be obtained about the patch.</p>
        pub fn content_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_url = Some(input.into());
            self
        }
        pub fn set_content_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_url = input;
            self
        }
        /// <p>The name of the vendor providing the patch.</p>
        pub fn vendor(mut self, input: impl Into<std::string::String>) -> Self {
            self.vendor = Some(input.into());
            self
        }
        pub fn set_vendor(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vendor = input;
            self
        }
        /// <p>The product family the patch is applicable for. For example, <code>Windows</code> or
        /// <code>Amazon Linux 2</code>.</p>
        pub fn product_family(mut self, input: impl Into<std::string::String>) -> Self {
            self.product_family = Some(input.into());
            self
        }
        pub fn set_product_family(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.product_family = input;
            self
        }
        /// <p>The specific product the patch is applicable for. For example,
        /// <code>WindowsServer2016</code> or <code>AmazonLinux2018.03</code>.</p>
        pub fn product(mut self, input: impl Into<std::string::String>) -> Self {
            self.product = Some(input.into());
            self
        }
        pub fn set_product(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product = input;
            self
        }
        /// <p>The classification of the patch. For example, <code>SecurityUpdates</code>,
        /// <code>Updates</code>, or <code>CriticalUpdates</code>.</p>
        pub fn classification(mut self, input: impl Into<std::string::String>) -> Self {
            self.classification = Some(input.into());
            self
        }
        pub fn set_classification(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.classification = input;
            self
        }
        /// <p>The severity of the patch, such as <code>Critical</code>, <code>Important</code>, or
        /// <code>Moderate</code>. Applies to Windows patches only.</p>
        pub fn msrc_severity(mut self, input: impl Into<std::string::String>) -> Self {
            self.msrc_severity = Some(input.into());
            self
        }
        pub fn set_msrc_severity(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.msrc_severity = input;
            self
        }
        /// <p>The Microsoft Knowledge Base ID of the patch. Applies to Windows patches only.</p>
        pub fn kb_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.kb_number = Some(input.into());
            self
        }
        pub fn set_kb_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kb_number = input;
            self
        }
        /// <p>The ID of the Microsoft Security Response Center (MSRC) bulletin the patch is related to.
        /// For example, <code>MS14-045</code>. Applies to Windows patches only.</p>
        pub fn msrc_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.msrc_number = Some(input.into());
            self
        }
        pub fn set_msrc_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.msrc_number = input;
            self
        }
        /// <p>The language of the patch if it's language-specific.</p>
        pub fn language(mut self, input: impl Into<std::string::String>) -> Self {
            self.language = Some(input.into());
            self
        }
        pub fn set_language(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.language = input;
            self
        }
        pub fn advisory_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.advisory_ids.unwrap_or_default();
            v.push(input.into());
            self.advisory_ids = Some(v);
            self
        }
        pub fn set_advisory_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.advisory_ids = input;
            self
        }
        pub fn bugzilla_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.bugzilla_ids.unwrap_or_default();
            v.push(input.into());
            self.bugzilla_ids = Some(v);
            self
        }
        pub fn set_bugzilla_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.bugzilla_ids = input;
            self
        }
        pub fn cve_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.cve_ids.unwrap_or_default();
            v.push(input.into());
            self.cve_ids = Some(v);
            self
        }
        pub fn set_cve_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.cve_ids = input;
            self
        }
        /// <p>The name of the patch. Applies to Linux-based instances only.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The epoch of the patch. For example in
        /// <code>pkg-example-EE-20180914-2.2.amzn1.noarch</code>, the epoch value is
        /// <code>20180914-2</code>. Applies to Linux-based instances only.</p>
        pub fn epoch(mut self, input: i32) -> Self {
            self.epoch = Some(input);
            self
        }
        pub fn set_epoch(mut self, input: std::option::Option<i32>) -> Self {
            self.epoch = input;
            self
        }
        /// <p>The version number of the patch. For example, in
        /// <code>example-pkg-1.710.10-2.7.abcd.x86_64</code>, the version number is indicated by
        /// <code>-1</code>. Applies to Linux-based instances only.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// <p>The particular release of a patch. For example, in
        /// <code>pkg-example-EE-20180914-2.2.amzn1.noarch</code>, the release is <code>2.amaz1</code>.
        /// Applies to Linux-based instances only.</p>
        pub fn release(mut self, input: impl Into<std::string::String>) -> Self {
            self.release = Some(input.into());
            self
        }
        pub fn set_release(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.release = input;
            self
        }
        /// <p>The architecture of the patch. For example, in
        /// <code>example-pkg-0.710.10-2.7.abcd.x86_64</code>, the architecture is indicated by
        /// <code>x86_64</code>. Applies to Linux-based instances only.</p>
        pub fn arch(mut self, input: impl Into<std::string::String>) -> Self {
            self.arch = Some(input.into());
            self
        }
        pub fn set_arch(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arch = input;
            self
        }
        /// <p>The severity level of the patch. For example, <code>CRITICAL</code> or
        /// <code>MODERATE</code>.</p>
        pub fn severity(mut self, input: impl Into<std::string::String>) -> Self {
            self.severity = Some(input.into());
            self
        }
        pub fn set_severity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.severity = input;
            self
        }
        /// <p>The source patch repository for the operating system and version, such as
        /// <code>trusty-security</code> for Ubuntu Server 14.04 LTE and <code>focal-security</code> for
        /// Ubuntu Server 20.04 LTE. Applies to Linux-based instances only.</p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// Consumes the builder and constructs a [`Patch`](crate::model::Patch)
        pub fn build(self) -> crate::model::Patch {
            crate::model::Patch {
                id: self.id,
                release_date: self.release_date,
                title: self.title,
                description: self.description,
                content_url: self.content_url,
                vendor: self.vendor,
                product_family: self.product_family,
                product: self.product,
                classification: self.classification,
                msrc_severity: self.msrc_severity,
                kb_number: self.kb_number,
                msrc_number: self.msrc_number,
                language: self.language,
                advisory_ids: self.advisory_ids,
                bugzilla_ids: self.bugzilla_ids,
                cve_ids: self.cve_ids,
                name: self.name,
                epoch: self.epoch.unwrap_or_default(),
                version: self.version,
                release: self.release,
                arch: self.arch,
                severity: self.severity,
                repository: self.repository,
            }
        }
    }
}
impl Patch {
    /// Creates a new builder-style object to manufacture [`Patch`](crate::model::Patch)
    pub fn builder() -> crate::model::patch::Builder {
        crate::model::patch::Builder::default()
    }
}

/// <p>One or more association documents on the instance. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceAssociation {
    /// <p>The association ID.</p>
    #[serde(rename = "AssociationId")]
    #[serde(default)]
    pub association_id: std::option::Option<std::string::String>,
    /// <p>The instance ID.</p>
    #[serde(rename = "InstanceId")]
    #[serde(default)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The content of the association document for the instance(s).</p>
    #[serde(rename = "Content")]
    #[serde(default)]
    pub content: std::option::Option<std::string::String>,
    /// <p>Version information for the association on the instance.</p>
    #[serde(rename = "AssociationVersion")]
    #[serde(default)]
    pub association_version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InstanceAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceAssociation");
        formatter.field("association_id", &self.association_id);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("content", &self.content);
        formatter.field("association_version", &self.association_version);
        formatter.finish()
    }
}
/// See [`InstanceAssociation`](crate::model::InstanceAssociation)
pub mod instance_association {
    /// A builder for [`InstanceAssociation`](crate::model::InstanceAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) association_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The association ID.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>The instance ID.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The content of the association document for the instance(s).</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// <p>Version information for the association on the instance.</p>
        pub fn association_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_version = Some(input.into());
            self
        }
        pub fn set_association_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_version = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceAssociation`](crate::model::InstanceAssociation)
        pub fn build(self) -> crate::model::InstanceAssociation {
            crate::model::InstanceAssociation {
                association_id: self.association_id,
                instance_id: self.instance_id,
                content: self.content,
                association_version: self.association_version,
            }
        }
    }
}
impl InstanceAssociation {
    /// Creates a new builder-style object to manufacture [`InstanceAssociation`](crate::model::InstanceAssociation)
    pub fn builder() -> crate::model::instance_association::Builder {
        crate::model::instance_association::Builder::default()
    }
}

/// <p>Information includes the AWS account ID where the current document is shared and the version
/// shared with that account.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AccountSharingInfo {
    /// <p>The AWS account ID where the current document is shared.</p>
    #[serde(rename = "AccountId")]
    #[serde(default)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The version of the current document shared with the account.</p>
    #[serde(rename = "SharedDocumentVersion")]
    #[serde(default)]
    pub shared_document_version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AccountSharingInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccountSharingInfo");
        formatter.field("account_id", &self.account_id);
        formatter.field("shared_document_version", &self.shared_document_version);
        formatter.finish()
    }
}
/// See [`AccountSharingInfo`](crate::model::AccountSharingInfo)
pub mod account_sharing_info {
    /// A builder for [`AccountSharingInfo`](crate::model::AccountSharingInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) shared_document_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The AWS account ID where the current document is shared.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The version of the current document shared with the account.</p>
        pub fn shared_document_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.shared_document_version = Some(input.into());
            self
        }
        pub fn set_shared_document_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.shared_document_version = input;
            self
        }
        /// Consumes the builder and constructs a [`AccountSharingInfo`](crate::model::AccountSharingInfo)
        pub fn build(self) -> crate::model::AccountSharingInfo {
            crate::model::AccountSharingInfo {
                account_id: self.account_id,
                shared_document_version: self.shared_document_version,
            }
        }
    }
}
impl AccountSharingInfo {
    /// Creates a new builder-style object to manufacture [`AccountSharingInfo`](crate::model::AccountSharingInfo)
    pub fn builder() -> crate::model::account_sharing_info::Builder {
        crate::model::account_sharing_info::Builder::default()
    }
}

/// <p>A filter to limit the amount of step execution information returned by the call.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct StepExecutionFilter {
    /// <p>One or more keys to limit the results. Valid filter keys include the following: StepName,
    /// Action, StepExecutionId, StepExecutionStatus, StartTimeBefore, StartTimeAfter.</p>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<crate::model::StepExecutionFilterKey>,
    /// <p>The values of the filter key.</p>
    #[serde(rename = "Values")]
    #[serde(default)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for StepExecutionFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StepExecutionFilter");
        formatter.field("key", &self.key);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`StepExecutionFilter`](crate::model::StepExecutionFilter)
pub mod step_execution_filter {
    /// A builder for [`StepExecutionFilter`](crate::model::StepExecutionFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<crate::model::StepExecutionFilterKey>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>One or more keys to limit the results. Valid filter keys include the following: StepName,
        /// Action, StepExecutionId, StepExecutionStatus, StartTimeBefore, StartTimeAfter.</p>
        pub fn key(mut self, input: crate::model::StepExecutionFilterKey) -> Self {
            self.key = Some(input);
            self
        }
        pub fn set_key(
            mut self,
            input: std::option::Option<crate::model::StepExecutionFilterKey>,
        ) -> Self {
            self.key = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`StepExecutionFilter`](crate::model::StepExecutionFilter)
        pub fn build(self) -> crate::model::StepExecutionFilter {
            crate::model::StepExecutionFilter {
                key: self.key,
                values: self.values,
            }
        }
    }
}
impl StepExecutionFilter {
    /// Creates a new builder-style object to manufacture [`StepExecutionFilter`](crate::model::StepExecutionFilter)
    pub fn builder() -> crate::model::step_execution_filter::Builder {
        crate::model::step_execution_filter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StepExecutionFilterKey {
    Action,
    StartTimeAfter,
    StartTimeBefore,
    StepExecutionId,
    StepExecutionStatus,
    StepName,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StepExecutionFilterKey {
    fn from(s: &str) -> Self {
        match s {
            "Action" => StepExecutionFilterKey::Action,
            "StartTimeAfter" => StepExecutionFilterKey::StartTimeAfter,
            "StartTimeBefore" => StepExecutionFilterKey::StartTimeBefore,
            "StepExecutionId" => StepExecutionFilterKey::StepExecutionId,
            "StepExecutionStatus" => StepExecutionFilterKey::StepExecutionStatus,
            "StepName" => StepExecutionFilterKey::StepName,
            other => StepExecutionFilterKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StepExecutionFilterKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(StepExecutionFilterKey::from(s))
    }
}
impl StepExecutionFilterKey {
    pub fn as_str(&self) -> &str {
        match self {
            StepExecutionFilterKey::Action => "Action",
            StepExecutionFilterKey::StartTimeAfter => "StartTimeAfter",
            StepExecutionFilterKey::StartTimeBefore => "StartTimeBefore",
            StepExecutionFilterKey::StepExecutionId => "StepExecutionId",
            StepExecutionFilterKey::StepExecutionStatus => "StepExecutionStatus",
            StepExecutionFilterKey::StepName => "StepName",
            StepExecutionFilterKey::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for StepExecutionFilterKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for StepExecutionFilterKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Details about a specific Automation execution.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AutomationExecutionMetadata {
    /// <p>The execution ID.</p>
    #[serde(rename = "AutomationExecutionId")]
    #[serde(default)]
    pub automation_execution_id: std::option::Option<std::string::String>,
    /// <p>The name of the Automation document used during execution.</p>
    #[serde(rename = "DocumentName")]
    #[serde(default)]
    pub document_name: std::option::Option<std::string::String>,
    /// <p>The document version used during the execution.</p>
    #[serde(rename = "DocumentVersion")]
    #[serde(default)]
    pub document_version: std::option::Option<std::string::String>,
    /// <p>The status of the execution.</p>
    #[serde(rename = "AutomationExecutionStatus")]
    #[serde(default)]
    pub automation_execution_status: std::option::Option<crate::model::AutomationExecutionStatus>,
    /// <p>The time the execution started.</p>
    #[serde(rename = "ExecutionStartTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub execution_start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time the execution finished. This is not populated if the execution is still in
    /// progress.</p>
    #[serde(rename = "ExecutionEndTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub execution_end_time: std::option::Option<smithy_types::Instant>,
    /// <p>The IAM role ARN of the user who ran the Automation.</p>
    #[serde(rename = "ExecutedBy")]
    #[serde(default)]
    pub executed_by: std::option::Option<std::string::String>,
    /// <p>An S3 bucket where execution information is stored.</p>
    #[serde(rename = "LogFile")]
    #[serde(default)]
    pub log_file: std::option::Option<std::string::String>,
    /// <p>The list of execution outputs as defined in the Automation document.</p>
    #[serde(rename = "Outputs")]
    #[serde(default)]
    pub outputs: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The Automation execution mode.</p>
    #[serde(rename = "Mode")]
    #[serde(default)]
    pub mode: std::option::Option<crate::model::ExecutionMode>,
    /// <p>The ExecutionId of the parent Automation.</p>
    #[serde(rename = "ParentAutomationExecutionId")]
    #[serde(default)]
    pub parent_automation_execution_id: std::option::Option<std::string::String>,
    /// <p>The name of the step that is currently running.</p>
    #[serde(rename = "CurrentStepName")]
    #[serde(default)]
    pub current_step_name: std::option::Option<std::string::String>,
    /// <p>The action of the step that is currently running.</p>
    #[serde(rename = "CurrentAction")]
    #[serde(default)]
    pub current_action: std::option::Option<std::string::String>,
    /// <p>The list of execution outputs as defined in the Automation document.</p>
    #[serde(rename = "FailureMessage")]
    #[serde(default)]
    pub failure_message: std::option::Option<std::string::String>,
    /// <p>The list of execution outputs as defined in the Automation document.</p>
    #[serde(rename = "TargetParameterName")]
    #[serde(default)]
    pub target_parameter_name: std::option::Option<std::string::String>,
    /// <p>The targets defined by the user when starting the Automation.</p>
    #[serde(rename = "Targets")]
    #[serde(default)]
    pub targets: std::option::Option<std::vec::Vec<crate::model::Target>>,
    /// <p>The specified key-value mapping of document parameters to target resources.</p>
    #[serde(rename = "TargetMaps")]
    #[serde(default)]
    pub target_maps: std::option::Option<
        std::vec::Vec<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
    >,
    /// <p>A list of targets that resolved during the execution.</p>
    #[serde(rename = "ResolvedTargets")]
    #[serde(default)]
    pub resolved_targets: std::option::Option<crate::model::ResolvedTargets>,
    /// <p>The MaxConcurrency value specified by the user when starting the Automation.</p>
    #[serde(rename = "MaxConcurrency")]
    #[serde(default)]
    pub max_concurrency: std::option::Option<std::string::String>,
    /// <p>The MaxErrors value specified by the user when starting the Automation.</p>
    #[serde(rename = "MaxErrors")]
    #[serde(default)]
    pub max_errors: std::option::Option<std::string::String>,
    /// <p>The list of execution outputs as defined in the Automation document.</p>
    #[serde(rename = "Target")]
    #[serde(default)]
    pub target: std::option::Option<std::string::String>,
    /// <p>Use this filter with <a>DescribeAutomationExecutions</a>. Specify either Local or
    /// CrossAccount. CrossAccount is an Automation that runs in multiple AWS Regions and accounts. For
    /// more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-automation-multiple-accounts-and-regions.html">Running Automation workflows in multiple AWS Regions and accounts</a> in the
    /// <i>AWS Systems Manager User Guide</i>. </p>
    #[serde(rename = "AutomationType")]
    #[serde(default)]
    pub automation_type: std::option::Option<crate::model::AutomationType>,
    /// <p>The subtype of the Automation operation. Currently, the only supported value is
    /// <code>ChangeRequest</code>.</p>
    #[serde(rename = "AutomationSubtype")]
    #[serde(default)]
    pub automation_subtype: std::option::Option<crate::model::AutomationSubtype>,
    /// <p>The date and time the Automation operation is scheduled to start.</p>
    #[serde(rename = "ScheduledTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub scheduled_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the Automation runbooks (Automation documents) that are run during a
    /// runbook workflow in Change Manager.</p>
    /// <note>
    /// <p>The Automation runbooks specified for the runbook workflow can't run until all required
    /// approvals for the change request have been received.</p>
    /// </note>
    #[serde(rename = "Runbooks")]
    #[serde(default)]
    pub runbooks: std::option::Option<std::vec::Vec<crate::model::Runbook>>,
    /// <p>The ID of an OpsItem that is created to represent a Change Manager change request.</p>
    #[serde(rename = "OpsItemId")]
    #[serde(default)]
    pub ops_item_id: std::option::Option<std::string::String>,
    /// <p>The ID of a State Manager association used in the Automation operation.</p>
    #[serde(rename = "AssociationId")]
    #[serde(default)]
    pub association_id: std::option::Option<std::string::String>,
    /// <p>The name of the Change Manager change request.</p>
    #[serde(rename = "ChangeRequestName")]
    #[serde(default)]
    pub change_request_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AutomationExecutionMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutomationExecutionMetadata");
        formatter.field("automation_execution_id", &self.automation_execution_id);
        formatter.field("document_name", &self.document_name);
        formatter.field("document_version", &self.document_version);
        formatter.field(
            "automation_execution_status",
            &self.automation_execution_status,
        );
        formatter.field("execution_start_time", &self.execution_start_time);
        formatter.field("execution_end_time", &self.execution_end_time);
        formatter.field("executed_by", &self.executed_by);
        formatter.field("log_file", &self.log_file);
        formatter.field("outputs", &self.outputs);
        formatter.field("mode", &self.mode);
        formatter.field(
            "parent_automation_execution_id",
            &self.parent_automation_execution_id,
        );
        formatter.field("current_step_name", &self.current_step_name);
        formatter.field("current_action", &self.current_action);
        formatter.field("failure_message", &self.failure_message);
        formatter.field("target_parameter_name", &self.target_parameter_name);
        formatter.field("targets", &self.targets);
        formatter.field("target_maps", &self.target_maps);
        formatter.field("resolved_targets", &self.resolved_targets);
        formatter.field("max_concurrency", &self.max_concurrency);
        formatter.field("max_errors", &self.max_errors);
        formatter.field("target", &self.target);
        formatter.field("automation_type", &self.automation_type);
        formatter.field("automation_subtype", &self.automation_subtype);
        formatter.field("scheduled_time", &self.scheduled_time);
        formatter.field("runbooks", &self.runbooks);
        formatter.field("ops_item_id", &self.ops_item_id);
        formatter.field("association_id", &self.association_id);
        formatter.field("change_request_name", &self.change_request_name);
        formatter.finish()
    }
}
/// See [`AutomationExecutionMetadata`](crate::model::AutomationExecutionMetadata)
pub mod automation_execution_metadata {
    /// A builder for [`AutomationExecutionMetadata`](crate::model::AutomationExecutionMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) automation_execution_id: std::option::Option<std::string::String>,
        pub(crate) document_name: std::option::Option<std::string::String>,
        pub(crate) document_version: std::option::Option<std::string::String>,
        pub(crate) automation_execution_status:
            std::option::Option<crate::model::AutomationExecutionStatus>,
        pub(crate) execution_start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) execution_end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) executed_by: std::option::Option<std::string::String>,
        pub(crate) log_file: std::option::Option<std::string::String>,
        pub(crate) outputs: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) mode: std::option::Option<crate::model::ExecutionMode>,
        pub(crate) parent_automation_execution_id: std::option::Option<std::string::String>,
        pub(crate) current_step_name: std::option::Option<std::string::String>,
        pub(crate) current_action: std::option::Option<std::string::String>,
        pub(crate) failure_message: std::option::Option<std::string::String>,
        pub(crate) target_parameter_name: std::option::Option<std::string::String>,
        pub(crate) targets: std::option::Option<std::vec::Vec<crate::model::Target>>,
        pub(crate) target_maps: std::option::Option<
            std::vec::Vec<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        >,
        pub(crate) resolved_targets: std::option::Option<crate::model::ResolvedTargets>,
        pub(crate) max_concurrency: std::option::Option<std::string::String>,
        pub(crate) max_errors: std::option::Option<std::string::String>,
        pub(crate) target: std::option::Option<std::string::String>,
        pub(crate) automation_type: std::option::Option<crate::model::AutomationType>,
        pub(crate) automation_subtype: std::option::Option<crate::model::AutomationSubtype>,
        pub(crate) scheduled_time: std::option::Option<smithy_types::Instant>,
        pub(crate) runbooks: std::option::Option<std::vec::Vec<crate::model::Runbook>>,
        pub(crate) ops_item_id: std::option::Option<std::string::String>,
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) change_request_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The execution ID.</p>
        pub fn automation_execution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.automation_execution_id = Some(input.into());
            self
        }
        pub fn set_automation_execution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.automation_execution_id = input;
            self
        }
        /// <p>The name of the Automation document used during execution.</p>
        pub fn document_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_name = Some(input.into());
            self
        }
        pub fn set_document_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_name = input;
            self
        }
        /// <p>The document version used during the execution.</p>
        pub fn document_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_version = Some(input.into());
            self
        }
        pub fn set_document_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_version = input;
            self
        }
        /// <p>The status of the execution.</p>
        pub fn automation_execution_status(
            mut self,
            input: crate::model::AutomationExecutionStatus,
        ) -> Self {
            self.automation_execution_status = Some(input);
            self
        }
        pub fn set_automation_execution_status(
            mut self,
            input: std::option::Option<crate::model::AutomationExecutionStatus>,
        ) -> Self {
            self.automation_execution_status = input;
            self
        }
        /// <p>The time the execution started.</p>
        pub fn execution_start_time(mut self, input: smithy_types::Instant) -> Self {
            self.execution_start_time = Some(input);
            self
        }
        pub fn set_execution_start_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.execution_start_time = input;
            self
        }
        /// <p>The time the execution finished. This is not populated if the execution is still in
        /// progress.</p>
        pub fn execution_end_time(mut self, input: smithy_types::Instant) -> Self {
            self.execution_end_time = Some(input);
            self
        }
        pub fn set_execution_end_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.execution_end_time = input;
            self
        }
        /// <p>The IAM role ARN of the user who ran the Automation.</p>
        pub fn executed_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.executed_by = Some(input.into());
            self
        }
        pub fn set_executed_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.executed_by = input;
            self
        }
        /// <p>An S3 bucket where execution information is stored.</p>
        pub fn log_file(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_file = Some(input.into());
            self
        }
        pub fn set_log_file(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.log_file = input;
            self
        }
        pub fn outputs(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.outputs.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.outputs = Some(hash_map);
            self
        }
        pub fn set_outputs(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.outputs = input;
            self
        }
        /// <p>The Automation execution mode.</p>
        pub fn mode(mut self, input: crate::model::ExecutionMode) -> Self {
            self.mode = Some(input);
            self
        }
        pub fn set_mode(mut self, input: std::option::Option<crate::model::ExecutionMode>) -> Self {
            self.mode = input;
            self
        }
        /// <p>The ExecutionId of the parent Automation.</p>
        pub fn parent_automation_execution_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.parent_automation_execution_id = Some(input.into());
            self
        }
        pub fn set_parent_automation_execution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parent_automation_execution_id = input;
            self
        }
        /// <p>The name of the step that is currently running.</p>
        pub fn current_step_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.current_step_name = Some(input.into());
            self
        }
        pub fn set_current_step_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.current_step_name = input;
            self
        }
        /// <p>The action of the step that is currently running.</p>
        pub fn current_action(mut self, input: impl Into<std::string::String>) -> Self {
            self.current_action = Some(input.into());
            self
        }
        pub fn set_current_action(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.current_action = input;
            self
        }
        /// <p>The list of execution outputs as defined in the Automation document.</p>
        pub fn failure_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_message = Some(input.into());
            self
        }
        pub fn set_failure_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_message = input;
            self
        }
        /// <p>The list of execution outputs as defined in the Automation document.</p>
        pub fn target_parameter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_parameter_name = Some(input.into());
            self
        }
        pub fn set_target_parameter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_parameter_name = input;
            self
        }
        pub fn targets(mut self, input: impl Into<crate::model::Target>) -> Self {
            let mut v = self.targets.unwrap_or_default();
            v.push(input.into());
            self.targets = Some(v);
            self
        }
        pub fn set_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Target>>,
        ) -> Self {
            self.targets = input;
            self
        }
        pub fn target_maps(
            mut self,
            input: impl Into<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            let mut v = self.target_maps.unwrap_or_default();
            v.push(input.into());
            self.target_maps = Some(v);
            self
        }
        pub fn set_target_maps(
            mut self,
            input: std::option::Option<
                std::vec::Vec<
                    std::collections::HashMap<
                        std::string::String,
                        std::vec::Vec<std::string::String>,
                    >,
                >,
            >,
        ) -> Self {
            self.target_maps = input;
            self
        }
        /// <p>A list of targets that resolved during the execution.</p>
        pub fn resolved_targets(mut self, input: crate::model::ResolvedTargets) -> Self {
            self.resolved_targets = Some(input);
            self
        }
        pub fn set_resolved_targets(
            mut self,
            input: std::option::Option<crate::model::ResolvedTargets>,
        ) -> Self {
            self.resolved_targets = input;
            self
        }
        /// <p>The MaxConcurrency value specified by the user when starting the Automation.</p>
        pub fn max_concurrency(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_concurrency = Some(input.into());
            self
        }
        pub fn set_max_concurrency(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.max_concurrency = input;
            self
        }
        /// <p>The MaxErrors value specified by the user when starting the Automation.</p>
        pub fn max_errors(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_errors = Some(input.into());
            self
        }
        pub fn set_max_errors(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_errors = input;
            self
        }
        /// <p>The list of execution outputs as defined in the Automation document.</p>
        pub fn target(mut self, input: impl Into<std::string::String>) -> Self {
            self.target = Some(input.into());
            self
        }
        pub fn set_target(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target = input;
            self
        }
        /// <p>Use this filter with <a>DescribeAutomationExecutions</a>. Specify either Local or
        /// CrossAccount. CrossAccount is an Automation that runs in multiple AWS Regions and accounts. For
        /// more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-automation-multiple-accounts-and-regions.html">Running Automation workflows in multiple AWS Regions and accounts</a> in the
        /// <i>AWS Systems Manager User Guide</i>. </p>
        pub fn automation_type(mut self, input: crate::model::AutomationType) -> Self {
            self.automation_type = Some(input);
            self
        }
        pub fn set_automation_type(
            mut self,
            input: std::option::Option<crate::model::AutomationType>,
        ) -> Self {
            self.automation_type = input;
            self
        }
        /// <p>The subtype of the Automation operation. Currently, the only supported value is
        /// <code>ChangeRequest</code>.</p>
        pub fn automation_subtype(mut self, input: crate::model::AutomationSubtype) -> Self {
            self.automation_subtype = Some(input);
            self
        }
        pub fn set_automation_subtype(
            mut self,
            input: std::option::Option<crate::model::AutomationSubtype>,
        ) -> Self {
            self.automation_subtype = input;
            self
        }
        /// <p>The date and time the Automation operation is scheduled to start.</p>
        pub fn scheduled_time(mut self, input: smithy_types::Instant) -> Self {
            self.scheduled_time = Some(input);
            self
        }
        pub fn set_scheduled_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.scheduled_time = input;
            self
        }
        pub fn runbooks(mut self, input: impl Into<crate::model::Runbook>) -> Self {
            let mut v = self.runbooks.unwrap_or_default();
            v.push(input.into());
            self.runbooks = Some(v);
            self
        }
        pub fn set_runbooks(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Runbook>>,
        ) -> Self {
            self.runbooks = input;
            self
        }
        /// <p>The ID of an OpsItem that is created to represent a Change Manager change request.</p>
        pub fn ops_item_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ops_item_id = Some(input.into());
            self
        }
        pub fn set_ops_item_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ops_item_id = input;
            self
        }
        /// <p>The ID of a State Manager association used in the Automation operation.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>The name of the Change Manager change request.</p>
        pub fn change_request_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.change_request_name = Some(input.into());
            self
        }
        pub fn set_change_request_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.change_request_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AutomationExecutionMetadata`](crate::model::AutomationExecutionMetadata)
        pub fn build(self) -> crate::model::AutomationExecutionMetadata {
            crate::model::AutomationExecutionMetadata {
                automation_execution_id: self.automation_execution_id,
                document_name: self.document_name,
                document_version: self.document_version,
                automation_execution_status: self.automation_execution_status,
                execution_start_time: self.execution_start_time,
                execution_end_time: self.execution_end_time,
                executed_by: self.executed_by,
                log_file: self.log_file,
                outputs: self.outputs,
                mode: self.mode,
                parent_automation_execution_id: self.parent_automation_execution_id,
                current_step_name: self.current_step_name,
                current_action: self.current_action,
                failure_message: self.failure_message,
                target_parameter_name: self.target_parameter_name,
                targets: self.targets,
                target_maps: self.target_maps,
                resolved_targets: self.resolved_targets,
                max_concurrency: self.max_concurrency,
                max_errors: self.max_errors,
                target: self.target,
                automation_type: self.automation_type,
                automation_subtype: self.automation_subtype,
                scheduled_time: self.scheduled_time,
                runbooks: self.runbooks,
                ops_item_id: self.ops_item_id,
                association_id: self.association_id,
                change_request_name: self.change_request_name,
            }
        }
    }
}
impl AutomationExecutionMetadata {
    /// Creates a new builder-style object to manufacture [`AutomationExecutionMetadata`](crate::model::AutomationExecutionMetadata)
    pub fn builder() -> crate::model::automation_execution_metadata::Builder {
        crate::model::automation_execution_metadata::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutomationType {
    CrossAccount,
    Local,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutomationType {
    fn from(s: &str) -> Self {
        match s {
            "CrossAccount" => AutomationType::CrossAccount,
            "Local" => AutomationType::Local,
            other => AutomationType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutomationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(AutomationType::from(s))
    }
}
impl AutomationType {
    pub fn as_str(&self) -> &str {
        match self {
            AutomationType::CrossAccount => "CrossAccount",
            AutomationType::Local => "Local",
            AutomationType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for AutomationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for AutomationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>A filter used to match specific automation executions. This is used to limit the scope of
/// Automation execution information returned.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AutomationExecutionFilter {
    /// <p>One or more keys to limit the results.</p>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<crate::model::AutomationExecutionFilterKey>,
    /// <p>The values used to limit the execution information associated with the filter's key.</p>
    #[serde(rename = "Values")]
    #[serde(default)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for AutomationExecutionFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutomationExecutionFilter");
        formatter.field("key", &self.key);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`AutomationExecutionFilter`](crate::model::AutomationExecutionFilter)
pub mod automation_execution_filter {
    /// A builder for [`AutomationExecutionFilter`](crate::model::AutomationExecutionFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<crate::model::AutomationExecutionFilterKey>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>One or more keys to limit the results.</p>
        pub fn key(mut self, input: crate::model::AutomationExecutionFilterKey) -> Self {
            self.key = Some(input);
            self
        }
        pub fn set_key(
            mut self,
            input: std::option::Option<crate::model::AutomationExecutionFilterKey>,
        ) -> Self {
            self.key = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`AutomationExecutionFilter`](crate::model::AutomationExecutionFilter)
        pub fn build(self) -> crate::model::AutomationExecutionFilter {
            crate::model::AutomationExecutionFilter {
                key: self.key,
                values: self.values,
            }
        }
    }
}
impl AutomationExecutionFilter {
    /// Creates a new builder-style object to manufacture [`AutomationExecutionFilter`](crate::model::AutomationExecutionFilter)
    pub fn builder() -> crate::model::automation_execution_filter::Builder {
        crate::model::automation_execution_filter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutomationExecutionFilterKey {
    AutomationSubtype,
    AutomationType,
    CurrentAction,
    DocumentNamePrefix,
    ExecutionId,
    ExecutionStatus,
    OpsItemId,
    ParentExecutionId,
    StartTimeAfter,
    StartTimeBefore,
    TagKey,
    TargetResourceGroup,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutomationExecutionFilterKey {
    fn from(s: &str) -> Self {
        match s {
            "AutomationSubtype" => AutomationExecutionFilterKey::AutomationSubtype,
            "AutomationType" => AutomationExecutionFilterKey::AutomationType,
            "CurrentAction" => AutomationExecutionFilterKey::CurrentAction,
            "DocumentNamePrefix" => AutomationExecutionFilterKey::DocumentNamePrefix,
            "ExecutionId" => AutomationExecutionFilterKey::ExecutionId,
            "ExecutionStatus" => AutomationExecutionFilterKey::ExecutionStatus,
            "OpsItemId" => AutomationExecutionFilterKey::OpsItemId,
            "ParentExecutionId" => AutomationExecutionFilterKey::ParentExecutionId,
            "StartTimeAfter" => AutomationExecutionFilterKey::StartTimeAfter,
            "StartTimeBefore" => AutomationExecutionFilterKey::StartTimeBefore,
            "TagKey" => AutomationExecutionFilterKey::TagKey,
            "TargetResourceGroup" => AutomationExecutionFilterKey::TargetResourceGroup,
            other => AutomationExecutionFilterKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutomationExecutionFilterKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(AutomationExecutionFilterKey::from(s))
    }
}
impl AutomationExecutionFilterKey {
    pub fn as_str(&self) -> &str {
        match self {
            AutomationExecutionFilterKey::AutomationSubtype => "AutomationSubtype",
            AutomationExecutionFilterKey::AutomationType => "AutomationType",
            AutomationExecutionFilterKey::CurrentAction => "CurrentAction",
            AutomationExecutionFilterKey::DocumentNamePrefix => "DocumentNamePrefix",
            AutomationExecutionFilterKey::ExecutionId => "ExecutionId",
            AutomationExecutionFilterKey::ExecutionStatus => "ExecutionStatus",
            AutomationExecutionFilterKey::OpsItemId => "OpsItemId",
            AutomationExecutionFilterKey::ParentExecutionId => "ParentExecutionId",
            AutomationExecutionFilterKey::StartTimeAfter => "StartTimeAfter",
            AutomationExecutionFilterKey::StartTimeBefore => "StartTimeBefore",
            AutomationExecutionFilterKey::TagKey => "TagKey",
            AutomationExecutionFilterKey::TargetResourceGroup => "TargetResourceGroup",
            AutomationExecutionFilterKey::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for AutomationExecutionFilterKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for AutomationExecutionFilterKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Includes information about the specified association execution.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociationExecutionTarget {
    /// <p>The association ID.</p>
    #[serde(rename = "AssociationId")]
    #[serde(default)]
    pub association_id: std::option::Option<std::string::String>,
    /// <p>The association version.</p>
    #[serde(rename = "AssociationVersion")]
    #[serde(default)]
    pub association_version: std::option::Option<std::string::String>,
    /// <p>The execution ID.</p>
    #[serde(rename = "ExecutionId")]
    #[serde(default)]
    pub execution_id: std::option::Option<std::string::String>,
    /// <p>The resource ID, for example, the instance ID where the association ran.</p>
    #[serde(rename = "ResourceId")]
    #[serde(default)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The resource type, for example, instance.</p>
    #[serde(rename = "ResourceType")]
    #[serde(default)]
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The association execution status.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<std::string::String>,
    /// <p>Detailed information about the execution status.</p>
    #[serde(rename = "DetailedStatus")]
    #[serde(default)]
    pub detailed_status: std::option::Option<std::string::String>,
    /// <p>The date of the last execution.</p>
    #[serde(rename = "LastExecutionDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_execution_date: std::option::Option<smithy_types::Instant>,
    /// <p>The location where the association details are saved.</p>
    #[serde(rename = "OutputSource")]
    #[serde(default)]
    pub output_source: std::option::Option<crate::model::OutputSource>,
}
impl std::fmt::Debug for AssociationExecutionTarget {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociationExecutionTarget");
        formatter.field("association_id", &self.association_id);
        formatter.field("association_version", &self.association_version);
        formatter.field("execution_id", &self.execution_id);
        formatter.field("resource_id", &self.resource_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("status", &self.status);
        formatter.field("detailed_status", &self.detailed_status);
        formatter.field("last_execution_date", &self.last_execution_date);
        formatter.field("output_source", &self.output_source);
        formatter.finish()
    }
}
/// See [`AssociationExecutionTarget`](crate::model::AssociationExecutionTarget)
pub mod association_execution_target {
    /// A builder for [`AssociationExecutionTarget`](crate::model::AssociationExecutionTarget)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) association_version: std::option::Option<std::string::String>,
        pub(crate) execution_id: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) detailed_status: std::option::Option<std::string::String>,
        pub(crate) last_execution_date: std::option::Option<smithy_types::Instant>,
        pub(crate) output_source: std::option::Option<crate::model::OutputSource>,
    }
    impl Builder {
        /// <p>The association ID.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>The association version.</p>
        pub fn association_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_version = Some(input.into());
            self
        }
        pub fn set_association_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_version = input;
            self
        }
        /// <p>The execution ID.</p>
        pub fn execution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.execution_id = Some(input.into());
            self
        }
        pub fn set_execution_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.execution_id = input;
            self
        }
        /// <p>The resource ID, for example, the instance ID where the association ran.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The resource type, for example, instance.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The association execution status.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>Detailed information about the execution status.</p>
        pub fn detailed_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.detailed_status = Some(input.into());
            self
        }
        pub fn set_detailed_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.detailed_status = input;
            self
        }
        /// <p>The date of the last execution.</p>
        pub fn last_execution_date(mut self, input: smithy_types::Instant) -> Self {
            self.last_execution_date = Some(input);
            self
        }
        pub fn set_last_execution_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_execution_date = input;
            self
        }
        /// <p>The location where the association details are saved.</p>
        pub fn output_source(mut self, input: crate::model::OutputSource) -> Self {
            self.output_source = Some(input);
            self
        }
        pub fn set_output_source(
            mut self,
            input: std::option::Option<crate::model::OutputSource>,
        ) -> Self {
            self.output_source = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociationExecutionTarget`](crate::model::AssociationExecutionTarget)
        pub fn build(self) -> crate::model::AssociationExecutionTarget {
            crate::model::AssociationExecutionTarget {
                association_id: self.association_id,
                association_version: self.association_version,
                execution_id: self.execution_id,
                resource_id: self.resource_id,
                resource_type: self.resource_type,
                status: self.status,
                detailed_status: self.detailed_status,
                last_execution_date: self.last_execution_date,
                output_source: self.output_source,
            }
        }
    }
}
impl AssociationExecutionTarget {
    /// Creates a new builder-style object to manufacture [`AssociationExecutionTarget`](crate::model::AssociationExecutionTarget)
    pub fn builder() -> crate::model::association_execution_target::Builder {
        crate::model::association_execution_target::Builder::default()
    }
}

/// <p>Information about the source where the association execution details are stored.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OutputSource {
    /// <p>The ID of the output source, for example the URL of an S3 bucket.</p>
    #[serde(rename = "OutputSourceId")]
    #[serde(default)]
    pub output_source_id: std::option::Option<std::string::String>,
    /// <p>The type of source where the association execution details are stored, for example,
    /// Amazon S3.</p>
    #[serde(rename = "OutputSourceType")]
    #[serde(default)]
    pub output_source_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OutputSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OutputSource");
        formatter.field("output_source_id", &self.output_source_id);
        formatter.field("output_source_type", &self.output_source_type);
        formatter.finish()
    }
}
/// See [`OutputSource`](crate::model::OutputSource)
pub mod output_source {
    /// A builder for [`OutputSource`](crate::model::OutputSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) output_source_id: std::option::Option<std::string::String>,
        pub(crate) output_source_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the output source, for example the URL of an S3 bucket.</p>
        pub fn output_source_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_source_id = Some(input.into());
            self
        }
        pub fn set_output_source_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_source_id = input;
            self
        }
        /// <p>The type of source where the association execution details are stored, for example,
        /// Amazon S3.</p>
        pub fn output_source_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_source_type = Some(input.into());
            self
        }
        pub fn set_output_source_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_source_type = input;
            self
        }
        /// Consumes the builder and constructs a [`OutputSource`](crate::model::OutputSource)
        pub fn build(self) -> crate::model::OutputSource {
            crate::model::OutputSource {
                output_source_id: self.output_source_id,
                output_source_type: self.output_source_type,
            }
        }
    }
}
impl OutputSource {
    /// Creates a new builder-style object to manufacture [`OutputSource`](crate::model::OutputSource)
    pub fn builder() -> crate::model::output_source::Builder {
        crate::model::output_source::Builder::default()
    }
}

/// <p>Filters for the association execution.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociationExecutionTargetsFilter {
    /// <p>The key value used in the request.</p>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<crate::model::AssociationExecutionTargetsFilterKey>,
    /// <p>The value specified for the key.</p>
    #[serde(rename = "Value")]
    #[serde(default)]
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AssociationExecutionTargetsFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociationExecutionTargetsFilter");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`AssociationExecutionTargetsFilter`](crate::model::AssociationExecutionTargetsFilter)
pub mod association_execution_targets_filter {
    /// A builder for [`AssociationExecutionTargetsFilter`](crate::model::AssociationExecutionTargetsFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<crate::model::AssociationExecutionTargetsFilterKey>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The key value used in the request.</p>
        pub fn key(mut self, input: crate::model::AssociationExecutionTargetsFilterKey) -> Self {
            self.key = Some(input);
            self
        }
        pub fn set_key(
            mut self,
            input: std::option::Option<crate::model::AssociationExecutionTargetsFilterKey>,
        ) -> Self {
            self.key = input;
            self
        }
        /// <p>The value specified for the key.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociationExecutionTargetsFilter`](crate::model::AssociationExecutionTargetsFilter)
        pub fn build(self) -> crate::model::AssociationExecutionTargetsFilter {
            crate::model::AssociationExecutionTargetsFilter {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl AssociationExecutionTargetsFilter {
    /// Creates a new builder-style object to manufacture [`AssociationExecutionTargetsFilter`](crate::model::AssociationExecutionTargetsFilter)
    pub fn builder() -> crate::model::association_execution_targets_filter::Builder {
        crate::model::association_execution_targets_filter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssociationExecutionTargetsFilterKey {
    ResourceId,
    ResourceType,
    Status,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AssociationExecutionTargetsFilterKey {
    fn from(s: &str) -> Self {
        match s {
            "ResourceId" => AssociationExecutionTargetsFilterKey::ResourceId,
            "ResourceType" => AssociationExecutionTargetsFilterKey::ResourceType,
            "Status" => AssociationExecutionTargetsFilterKey::Status,
            other => AssociationExecutionTargetsFilterKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AssociationExecutionTargetsFilterKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(AssociationExecutionTargetsFilterKey::from(s))
    }
}
impl AssociationExecutionTargetsFilterKey {
    pub fn as_str(&self) -> &str {
        match self {
            AssociationExecutionTargetsFilterKey::ResourceId => "ResourceId",
            AssociationExecutionTargetsFilterKey::ResourceType => "ResourceType",
            AssociationExecutionTargetsFilterKey::Status => "Status",
            AssociationExecutionTargetsFilterKey::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for AssociationExecutionTargetsFilterKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for AssociationExecutionTargetsFilterKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Includes information about the specified association.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociationExecution {
    /// <p>The association ID.</p>
    #[serde(rename = "AssociationId")]
    #[serde(default)]
    pub association_id: std::option::Option<std::string::String>,
    /// <p>The association version.</p>
    #[serde(rename = "AssociationVersion")]
    #[serde(default)]
    pub association_version: std::option::Option<std::string::String>,
    /// <p>The execution ID for the association.</p>
    #[serde(rename = "ExecutionId")]
    #[serde(default)]
    pub execution_id: std::option::Option<std::string::String>,
    /// <p>The status of the association execution.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<std::string::String>,
    /// <p>Detailed status information about the execution.</p>
    #[serde(rename = "DetailedStatus")]
    #[serde(default)]
    pub detailed_status: std::option::Option<std::string::String>,
    /// <p>The time the execution started.</p>
    #[serde(rename = "CreatedTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub created_time: std::option::Option<smithy_types::Instant>,
    /// <p>The date of the last execution.</p>
    #[serde(rename = "LastExecutionDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_execution_date: std::option::Option<smithy_types::Instant>,
    /// <p>An aggregate status of the resources in the execution based on the status type.</p>
    #[serde(rename = "ResourceCountByStatus")]
    #[serde(default)]
    pub resource_count_by_status: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AssociationExecution {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociationExecution");
        formatter.field("association_id", &self.association_id);
        formatter.field("association_version", &self.association_version);
        formatter.field("execution_id", &self.execution_id);
        formatter.field("status", &self.status);
        formatter.field("detailed_status", &self.detailed_status);
        formatter.field("created_time", &self.created_time);
        formatter.field("last_execution_date", &self.last_execution_date);
        formatter.field("resource_count_by_status", &self.resource_count_by_status);
        formatter.finish()
    }
}
/// See [`AssociationExecution`](crate::model::AssociationExecution)
pub mod association_execution {
    /// A builder for [`AssociationExecution`](crate::model::AssociationExecution)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) association_version: std::option::Option<std::string::String>,
        pub(crate) execution_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) detailed_status: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_execution_date: std::option::Option<smithy_types::Instant>,
        pub(crate) resource_count_by_status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The association ID.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>The association version.</p>
        pub fn association_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_version = Some(input.into());
            self
        }
        pub fn set_association_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_version = input;
            self
        }
        /// <p>The execution ID for the association.</p>
        pub fn execution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.execution_id = Some(input.into());
            self
        }
        pub fn set_execution_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.execution_id = input;
            self
        }
        /// <p>The status of the association execution.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>Detailed status information about the execution.</p>
        pub fn detailed_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.detailed_status = Some(input.into());
            self
        }
        pub fn set_detailed_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.detailed_status = input;
            self
        }
        /// <p>The time the execution started.</p>
        pub fn created_time(mut self, input: smithy_types::Instant) -> Self {
            self.created_time = Some(input);
            self
        }
        pub fn set_created_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The date of the last execution.</p>
        pub fn last_execution_date(mut self, input: smithy_types::Instant) -> Self {
            self.last_execution_date = Some(input);
            self
        }
        pub fn set_last_execution_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_execution_date = input;
            self
        }
        /// <p>An aggregate status of the resources in the execution based on the status type.</p>
        pub fn resource_count_by_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_count_by_status = Some(input.into());
            self
        }
        pub fn set_resource_count_by_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_count_by_status = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociationExecution`](crate::model::AssociationExecution)
        pub fn build(self) -> crate::model::AssociationExecution {
            crate::model::AssociationExecution {
                association_id: self.association_id,
                association_version: self.association_version,
                execution_id: self.execution_id,
                status: self.status,
                detailed_status: self.detailed_status,
                created_time: self.created_time,
                last_execution_date: self.last_execution_date,
                resource_count_by_status: self.resource_count_by_status,
            }
        }
    }
}
impl AssociationExecution {
    /// Creates a new builder-style object to manufacture [`AssociationExecution`](crate::model::AssociationExecution)
    pub fn builder() -> crate::model::association_execution::Builder {
        crate::model::association_execution::Builder::default()
    }
}

/// <p>Filters used in the request.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociationExecutionFilter {
    /// <p>The key value used in the request.</p>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<crate::model::AssociationExecutionFilterKey>,
    /// <p>The value specified for the key.</p>
    #[serde(rename = "Value")]
    #[serde(default)]
    pub value: std::option::Option<std::string::String>,
    /// <p>The filter type specified in the request.</p>
    #[serde(rename = "Type")]
    #[serde(default)]
    pub r#type: std::option::Option<crate::model::AssociationFilterOperatorType>,
}
impl std::fmt::Debug for AssociationExecutionFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociationExecutionFilter");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`AssociationExecutionFilter`](crate::model::AssociationExecutionFilter)
pub mod association_execution_filter {
    /// A builder for [`AssociationExecutionFilter`](crate::model::AssociationExecutionFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<crate::model::AssociationExecutionFilterKey>,
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::AssociationFilterOperatorType>,
    }
    impl Builder {
        /// <p>The key value used in the request.</p>
        pub fn key(mut self, input: crate::model::AssociationExecutionFilterKey) -> Self {
            self.key = Some(input);
            self
        }
        pub fn set_key(
            mut self,
            input: std::option::Option<crate::model::AssociationExecutionFilterKey>,
        ) -> Self {
            self.key = input;
            self
        }
        /// <p>The value specified for the key.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>The filter type specified in the request.</p>
        pub fn r#type(mut self, input: crate::model::AssociationFilterOperatorType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::AssociationFilterOperatorType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociationExecutionFilter`](crate::model::AssociationExecutionFilter)
        pub fn build(self) -> crate::model::AssociationExecutionFilter {
            crate::model::AssociationExecutionFilter {
                key: self.key,
                value: self.value,
                r#type: self.r#type,
            }
        }
    }
}
impl AssociationExecutionFilter {
    /// Creates a new builder-style object to manufacture [`AssociationExecutionFilter`](crate::model::AssociationExecutionFilter)
    pub fn builder() -> crate::model::association_execution_filter::Builder {
        crate::model::association_execution_filter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssociationFilterOperatorType {
    Equal,
    GreaterThan,
    LessThan,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AssociationFilterOperatorType {
    fn from(s: &str) -> Self {
        match s {
            "EQUAL" => AssociationFilterOperatorType::Equal,
            "GREATER_THAN" => AssociationFilterOperatorType::GreaterThan,
            "LESS_THAN" => AssociationFilterOperatorType::LessThan,
            other => AssociationFilterOperatorType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AssociationFilterOperatorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(AssociationFilterOperatorType::from(s))
    }
}
impl AssociationFilterOperatorType {
    pub fn as_str(&self) -> &str {
        match self {
            AssociationFilterOperatorType::Equal => "EQUAL",
            AssociationFilterOperatorType::GreaterThan => "GREATER_THAN",
            AssociationFilterOperatorType::LessThan => "LESS_THAN",
            AssociationFilterOperatorType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for AssociationFilterOperatorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for AssociationFilterOperatorType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssociationExecutionFilterKey {
    CreatedTime,
    ExecutionId,
    Status,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AssociationExecutionFilterKey {
    fn from(s: &str) -> Self {
        match s {
            "CreatedTime" => AssociationExecutionFilterKey::CreatedTime,
            "ExecutionId" => AssociationExecutionFilterKey::ExecutionId,
            "Status" => AssociationExecutionFilterKey::Status,
            other => AssociationExecutionFilterKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AssociationExecutionFilterKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(AssociationExecutionFilterKey::from(s))
    }
}
impl AssociationExecutionFilterKey {
    pub fn as_str(&self) -> &str {
        match self {
            AssociationExecutionFilterKey::CreatedTime => "CreatedTime",
            AssociationExecutionFilterKey::ExecutionId => "ExecutionId",
            AssociationExecutionFilterKey::Status => "Status",
            AssociationExecutionFilterKey::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for AssociationExecutionFilterKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for AssociationExecutionFilterKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>An activation registers one or more on-premises servers or virtual machines (VMs) with AWS
/// so that you can configure those servers or VMs using Run Command. A server or VM that has been
/// registered with AWS is called a managed instance.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct Activation {
    /// <p>The ID created by Systems Manager when you submitted the activation.</p>
    #[serde(rename = "ActivationId")]
    #[serde(default)]
    pub activation_id: std::option::Option<std::string::String>,
    /// <p>A user defined description of the activation.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>A name for the managed instance when it is created.</p>
    #[serde(rename = "DefaultInstanceName")]
    #[serde(default)]
    pub default_instance_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Identity and Access Management (IAM) role to assign to the managed
    /// instance.</p>
    #[serde(rename = "IamRole")]
    #[serde(default)]
    pub iam_role: std::option::Option<std::string::String>,
    /// <p>The maximum number of managed instances that can be registered using this activation.</p>
    #[serde(rename = "RegistrationLimit")]
    #[serde(default)]
    pub registration_limit: i32,
    /// <p>The number of managed instances already registered with this activation.</p>
    #[serde(rename = "RegistrationsCount")]
    #[serde(default)]
    pub registrations_count: i32,
    /// <p>The date when this activation can no longer be used to register managed instances.</p>
    #[serde(rename = "ExpirationDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub expiration_date: std::option::Option<smithy_types::Instant>,
    /// <p>Whether or not the activation is expired.</p>
    #[serde(rename = "Expired")]
    #[serde(default)]
    pub expired: bool,
    /// <p>The date the activation was created.</p>
    #[serde(rename = "CreatedDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub created_date: std::option::Option<smithy_types::Instant>,
    /// <p>Tags assigned to the activation.</p>
    #[serde(rename = "Tags")]
    #[serde(default)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for Activation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Activation");
        formatter.field("activation_id", &self.activation_id);
        formatter.field("description", &self.description);
        formatter.field("default_instance_name", &self.default_instance_name);
        formatter.field("iam_role", &self.iam_role);
        formatter.field("registration_limit", &self.registration_limit);
        formatter.field("registrations_count", &self.registrations_count);
        formatter.field("expiration_date", &self.expiration_date);
        formatter.field("expired", &self.expired);
        formatter.field("created_date", &self.created_date);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`Activation`](crate::model::Activation)
pub mod activation {
    /// A builder for [`Activation`](crate::model::Activation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) activation_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) default_instance_name: std::option::Option<std::string::String>,
        pub(crate) iam_role: std::option::Option<std::string::String>,
        pub(crate) registration_limit: std::option::Option<i32>,
        pub(crate) registrations_count: std::option::Option<i32>,
        pub(crate) expiration_date: std::option::Option<smithy_types::Instant>,
        pub(crate) expired: std::option::Option<bool>,
        pub(crate) created_date: std::option::Option<smithy_types::Instant>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID created by Systems Manager when you submitted the activation.</p>
        pub fn activation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.activation_id = Some(input.into());
            self
        }
        pub fn set_activation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.activation_id = input;
            self
        }
        /// <p>A user defined description of the activation.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>A name for the managed instance when it is created.</p>
        pub fn default_instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_instance_name = Some(input.into());
            self
        }
        pub fn set_default_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_instance_name = input;
            self
        }
        /// <p>The Amazon Identity and Access Management (IAM) role to assign to the managed
        /// instance.</p>
        pub fn iam_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.iam_role = Some(input.into());
            self
        }
        pub fn set_iam_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.iam_role = input;
            self
        }
        /// <p>The maximum number of managed instances that can be registered using this activation.</p>
        pub fn registration_limit(mut self, input: i32) -> Self {
            self.registration_limit = Some(input);
            self
        }
        pub fn set_registration_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.registration_limit = input;
            self
        }
        /// <p>The number of managed instances already registered with this activation.</p>
        pub fn registrations_count(mut self, input: i32) -> Self {
            self.registrations_count = Some(input);
            self
        }
        pub fn set_registrations_count(mut self, input: std::option::Option<i32>) -> Self {
            self.registrations_count = input;
            self
        }
        /// <p>The date when this activation can no longer be used to register managed instances.</p>
        pub fn expiration_date(mut self, input: smithy_types::Instant) -> Self {
            self.expiration_date = Some(input);
            self
        }
        pub fn set_expiration_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.expiration_date = input;
            self
        }
        /// <p>Whether or not the activation is expired.</p>
        pub fn expired(mut self, input: bool) -> Self {
            self.expired = Some(input);
            self
        }
        pub fn set_expired(mut self, input: std::option::Option<bool>) -> Self {
            self.expired = input;
            self
        }
        /// <p>The date the activation was created.</p>
        pub fn created_date(mut self, input: smithy_types::Instant) -> Self {
            self.created_date = Some(input);
            self
        }
        pub fn set_created_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.created_date = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`Activation`](crate::model::Activation)
        pub fn build(self) -> crate::model::Activation {
            crate::model::Activation {
                activation_id: self.activation_id,
                description: self.description,
                default_instance_name: self.default_instance_name,
                iam_role: self.iam_role,
                registration_limit: self.registration_limit.unwrap_or_default(),
                registrations_count: self.registrations_count.unwrap_or_default(),
                expiration_date: self.expiration_date,
                expired: self.expired.unwrap_or_default(),
                created_date: self.created_date,
                tags: self.tags,
            }
        }
    }
}
impl Activation {
    /// Creates a new builder-style object to manufacture [`Activation`](crate::model::Activation)
    pub fn builder() -> crate::model::activation::Builder {
        crate::model::activation::Builder::default()
    }
}

/// <p>Filter for the DescribeActivation API.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeActivationsFilter {
    /// <p>The name of the filter.</p>
    #[serde(rename = "FilterKey")]
    #[serde(default)]
    pub filter_key: std::option::Option<crate::model::DescribeActivationsFilterKeys>,
    /// <p>The filter values.</p>
    #[serde(rename = "FilterValues")]
    #[serde(default)]
    pub filter_values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for DescribeActivationsFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeActivationsFilter");
        formatter.field("filter_key", &self.filter_key);
        formatter.field("filter_values", &self.filter_values);
        formatter.finish()
    }
}
/// See [`DescribeActivationsFilter`](crate::model::DescribeActivationsFilter)
pub mod describe_activations_filter {
    /// A builder for [`DescribeActivationsFilter`](crate::model::DescribeActivationsFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter_key: std::option::Option<crate::model::DescribeActivationsFilterKeys>,
        pub(crate) filter_values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the filter.</p>
        pub fn filter_key(mut self, input: crate::model::DescribeActivationsFilterKeys) -> Self {
            self.filter_key = Some(input);
            self
        }
        pub fn set_filter_key(
            mut self,
            input: std::option::Option<crate::model::DescribeActivationsFilterKeys>,
        ) -> Self {
            self.filter_key = input;
            self
        }
        pub fn filter_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.filter_values.unwrap_or_default();
            v.push(input.into());
            self.filter_values = Some(v);
            self
        }
        pub fn set_filter_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.filter_values = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeActivationsFilter`](crate::model::DescribeActivationsFilter)
        pub fn build(self) -> crate::model::DescribeActivationsFilter {
            crate::model::DescribeActivationsFilter {
                filter_key: self.filter_key,
                filter_values: self.filter_values,
            }
        }
    }
}
impl DescribeActivationsFilter {
    /// Creates a new builder-style object to manufacture [`DescribeActivationsFilter`](crate::model::DescribeActivationsFilter)
    pub fn builder() -> crate::model::describe_activations_filter::Builder {
        crate::model::describe_activations_filter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DescribeActivationsFilterKeys {
    ActivationIds,
    DefaultInstanceName,
    IamRole,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DescribeActivationsFilterKeys {
    fn from(s: &str) -> Self {
        match s {
            "ActivationIds" => DescribeActivationsFilterKeys::ActivationIds,
            "DefaultInstanceName" => DescribeActivationsFilterKeys::DefaultInstanceName,
            "IamRole" => DescribeActivationsFilterKeys::IamRole,
            other => DescribeActivationsFilterKeys::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DescribeActivationsFilterKeys {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(DescribeActivationsFilterKeys::from(s))
    }
}
impl DescribeActivationsFilterKeys {
    pub fn as_str(&self) -> &str {
        match self {
            DescribeActivationsFilterKeys::ActivationIds => "ActivationIds",
            DescribeActivationsFilterKeys::DefaultInstanceName => "DefaultInstanceName",
            DescribeActivationsFilterKeys::IamRole => "IamRole",
            DescribeActivationsFilterKeys::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for DescribeActivationsFilterKeys {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for DescribeActivationsFilterKeys {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InventorySchemaDeleteOption {
    DeleteSchema,
    DisableSchema,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InventorySchemaDeleteOption {
    fn from(s: &str) -> Self {
        match s {
            "DeleteSchema" => InventorySchemaDeleteOption::DeleteSchema,
            "DisableSchema" => InventorySchemaDeleteOption::DisableSchema,
            other => InventorySchemaDeleteOption::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InventorySchemaDeleteOption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(InventorySchemaDeleteOption::from(s))
    }
}
impl InventorySchemaDeleteOption {
    pub fn as_str(&self) -> &str {
        match self {
            InventorySchemaDeleteOption::DeleteSchema => "DeleteSchema",
            InventorySchemaDeleteOption::DisableSchema => "DisableSchema",
            InventorySchemaDeleteOption::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for InventorySchemaDeleteOption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for InventorySchemaDeleteOption {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Describes a failed association.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct FailedCreateAssociation {
    /// <p>The association.</p>
    #[serde(rename = "Entry")]
    #[serde(default)]
    pub entry: std::option::Option<crate::model::CreateAssociationBatchRequestEntry>,
    /// <p>A description of the failure.</p>
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The source of the failure.</p>
    #[serde(rename = "Fault")]
    #[serde(default)]
    pub fault: std::option::Option<crate::model::Fault>,
}
impl std::fmt::Debug for FailedCreateAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FailedCreateAssociation");
        formatter.field("entry", &self.entry);
        formatter.field("message", &self.message);
        formatter.field("fault", &self.fault);
        formatter.finish()
    }
}
/// See [`FailedCreateAssociation`](crate::model::FailedCreateAssociation)
pub mod failed_create_association {
    /// A builder for [`FailedCreateAssociation`](crate::model::FailedCreateAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entry: std::option::Option<crate::model::CreateAssociationBatchRequestEntry>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) fault: std::option::Option<crate::model::Fault>,
    }
    impl Builder {
        /// <p>The association.</p>
        pub fn entry(mut self, input: crate::model::CreateAssociationBatchRequestEntry) -> Self {
            self.entry = Some(input);
            self
        }
        pub fn set_entry(
            mut self,
            input: std::option::Option<crate::model::CreateAssociationBatchRequestEntry>,
        ) -> Self {
            self.entry = input;
            self
        }
        /// <p>A description of the failure.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The source of the failure.</p>
        pub fn fault(mut self, input: crate::model::Fault) -> Self {
            self.fault = Some(input);
            self
        }
        pub fn set_fault(mut self, input: std::option::Option<crate::model::Fault>) -> Self {
            self.fault = input;
            self
        }
        /// Consumes the builder and constructs a [`FailedCreateAssociation`](crate::model::FailedCreateAssociation)
        pub fn build(self) -> crate::model::FailedCreateAssociation {
            crate::model::FailedCreateAssociation {
                entry: self.entry,
                message: self.message,
                fault: self.fault,
            }
        }
    }
}
impl FailedCreateAssociation {
    /// Creates a new builder-style object to manufacture [`FailedCreateAssociation`](crate::model::FailedCreateAssociation)
    pub fn builder() -> crate::model::failed_create_association::Builder {
        crate::model::failed_create_association::Builder::default()
    }
}

/// **NOTE:** `Fault::Unknown` has been renamed to `::UnknownValue`.
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Fault {
    Client,
    Server,
    /// **NOTE:** `::Unknown` has been renamed to `::UnknownValue`.
    UnknownValue,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Fault {
    fn from(s: &str) -> Self {
        match s {
            "Client" => Fault::Client,
            "Server" => Fault::Server,
            "Unknown" => Fault::UnknownValue,
            other => Fault::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Fault {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(Fault::from(s))
    }
}
impl Fault {
    pub fn as_str(&self) -> &str {
        match self {
            Fault::Client => "Client",
            Fault::Server => "Server",
            Fault::UnknownValue => "Unknown",
            Fault::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for Fault {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for Fault {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Describes the association of a Systems Manager SSM document and an instance.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateAssociationBatchRequestEntry {
    /// <p>The name of the SSM document that contains the configuration information for the instance.
    /// You can specify Command or Automation documents.</p>
    /// <p>You can specify AWS-predefined documents, documents you created, or a document that is
    /// shared with you from another account.</p>
    /// <p>For SSM documents that are shared with you from other AWS accounts, you must specify the
    /// complete SSM document ARN, in the following format:</p>
    /// <p>
    /// <code>arn:aws:ssm:<i>region</i>:<i>account-id</i>:document/<i>document-name</i>
    /// </code>
    /// </p>
    /// <p>For example:</p>
    /// <p>
    /// <code>arn:aws:ssm:us-east-2:12345678912:document/My-Shared-Document</code>
    /// </p>
    /// <p>For AWS-predefined documents and SSM documents you created in your account, you only need to
    /// specify the document name. For example, <code>AWS-ApplyPatchBaseline</code> or
    /// <code>My-Document</code>.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The ID of the instance. </p>
    #[serde(rename = "InstanceId")]
    #[serde(default)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>A description of the parameters for a document. </p>
    #[serde(rename = "Parameters")]
    #[serde(default)]
    pub parameters: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>Specify the target for the association. This target is required for associations that use an
    /// Automation document and target resources by using rate controls.</p>
    #[serde(rename = "AutomationTargetParameterName")]
    #[serde(default)]
    pub automation_target_parameter_name: std::option::Option<std::string::String>,
    /// <p>The document version.</p>
    #[serde(rename = "DocumentVersion")]
    #[serde(default)]
    pub document_version: std::option::Option<std::string::String>,
    /// <p>The instances targeted by the request.</p>
    #[serde(rename = "Targets")]
    #[serde(default)]
    pub targets: std::option::Option<std::vec::Vec<crate::model::Target>>,
    /// <p>A cron expression that specifies a schedule when the association runs.</p>
    #[serde(rename = "ScheduleExpression")]
    #[serde(default)]
    pub schedule_expression: std::option::Option<std::string::String>,
    /// <p>An S3 bucket where you want to store the results of this request.</p>
    #[serde(rename = "OutputLocation")]
    #[serde(default)]
    pub output_location: std::option::Option<crate::model::InstanceAssociationOutputLocation>,
    /// <p>Specify a descriptive name for the association.</p>
    #[serde(rename = "AssociationName")]
    #[serde(default)]
    pub association_name: std::option::Option<std::string::String>,
    /// <p>The number of errors that are allowed before the system stops sending requests to run the
    /// association on additional targets. You can specify either an absolute number of errors, for
    /// example 10, or a percentage of the target set, for example 10%. If you specify 3, for example,
    /// the system stops sending requests when the fourth error is received. If you specify 0, then the
    /// system stops sending requests after the first error is returned. If you run an association on 50
    /// instances and set MaxError to 10%, then the system stops sending the request when the sixth error
    /// is received.</p>
    /// <p>Executions that are already running an association when MaxErrors is reached are allowed to
    /// complete, but some of these executions may fail as well. If you need to ensure that there won't
    /// be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one
    /// at a time.</p>
    #[serde(rename = "MaxErrors")]
    #[serde(default)]
    pub max_errors: std::option::Option<std::string::String>,
    /// <p>The maximum number of targets allowed to run the association at the same time. You can
    /// specify a number, for example 10, or a percentage of the target set, for example 10%. The default
    /// value is 100%, which means all targets run the association at the same time.</p>
    /// <p>If a new instance starts and attempts to run an association while Systems Manager is running
    /// MaxConcurrency associations, the association is allowed to run. During the next association
    /// interval, the new instance will process its association within the limit specified for
    /// MaxConcurrency.</p>
    #[serde(rename = "MaxConcurrency")]
    #[serde(default)]
    pub max_concurrency: std::option::Option<std::string::String>,
    /// <p>The severity level to assign to the association.</p>
    #[serde(rename = "ComplianceSeverity")]
    #[serde(default)]
    pub compliance_severity: std::option::Option<crate::model::AssociationComplianceSeverity>,
    /// <p>The mode for generating association compliance. You can specify <code>AUTO</code> or
    /// <code>MANUAL</code>. In <code>AUTO</code> mode, the system uses the status of the association
    /// execution to determine the compliance status. If the association execution runs successfully,
    /// then the association is <code>COMPLIANT</code>. If the association execution doesn't run
    /// successfully, the association is <code>NON-COMPLIANT</code>. </p>
    /// <p>In <code>MANUAL</code> mode, you must specify the <code>AssociationId</code> as a parameter
    /// for the <a>PutComplianceItems</a> API action. In this case, compliance data is not
    /// managed by State Manager. It is managed by your direct call to the <a>PutComplianceItems</a> API action.</p>
    /// <p>By default, all associations use <code>AUTO</code> mode.</p>
    #[serde(rename = "SyncCompliance")]
    #[serde(default)]
    pub sync_compliance: std::option::Option<crate::model::AssociationSyncCompliance>,
    /// <p>By default, when you create a new associations, the system runs it immediately after it is
    /// created and then according to the schedule you specified. Specify this option if you don't want
    /// an association to run immediately after you create it. This parameter is not supported for rate
    /// expressions.</p>
    #[serde(rename = "ApplyOnlyAtCronInterval")]
    #[serde(default)]
    pub apply_only_at_cron_interval: bool,
    /// <p>The names or Amazon Resource Names (ARNs) of the Systems Manager Change Calendar type
    /// documents your associations are gated under. The associations only run when that Change
    /// Calendar is open.  For more information, see
    /// <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar">AWS Systems Manager Change Calendar</a>.</p>
    #[serde(rename = "CalendarNames")]
    #[serde(default)]
    pub calendar_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Use this action to create an association in multiple Regions and multiple accounts.</p>
    #[serde(rename = "TargetLocations")]
    #[serde(default)]
    pub target_locations: std::option::Option<std::vec::Vec<crate::model::TargetLocation>>,
}
impl std::fmt::Debug for CreateAssociationBatchRequestEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateAssociationBatchRequestEntry");
        formatter.field("name", &self.name);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("parameters", &self.parameters);
        formatter.field(
            "automation_target_parameter_name",
            &self.automation_target_parameter_name,
        );
        formatter.field("document_version", &self.document_version);
        formatter.field("targets", &self.targets);
        formatter.field("schedule_expression", &self.schedule_expression);
        formatter.field("output_location", &self.output_location);
        formatter.field("association_name", &self.association_name);
        formatter.field("max_errors", &self.max_errors);
        formatter.field("max_concurrency", &self.max_concurrency);
        formatter.field("compliance_severity", &self.compliance_severity);
        formatter.field("sync_compliance", &self.sync_compliance);
        formatter.field(
            "apply_only_at_cron_interval",
            &self.apply_only_at_cron_interval,
        );
        formatter.field("calendar_names", &self.calendar_names);
        formatter.field("target_locations", &self.target_locations);
        formatter.finish()
    }
}
/// See [`CreateAssociationBatchRequestEntry`](crate::model::CreateAssociationBatchRequestEntry)
pub mod create_association_batch_request_entry {
    /// A builder for [`CreateAssociationBatchRequestEntry`](crate::model::CreateAssociationBatchRequestEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) automation_target_parameter_name: std::option::Option<std::string::String>,
        pub(crate) document_version: std::option::Option<std::string::String>,
        pub(crate) targets: std::option::Option<std::vec::Vec<crate::model::Target>>,
        pub(crate) schedule_expression: std::option::Option<std::string::String>,
        pub(crate) output_location:
            std::option::Option<crate::model::InstanceAssociationOutputLocation>,
        pub(crate) association_name: std::option::Option<std::string::String>,
        pub(crate) max_errors: std::option::Option<std::string::String>,
        pub(crate) max_concurrency: std::option::Option<std::string::String>,
        pub(crate) compliance_severity:
            std::option::Option<crate::model::AssociationComplianceSeverity>,
        pub(crate) sync_compliance: std::option::Option<crate::model::AssociationSyncCompliance>,
        pub(crate) apply_only_at_cron_interval: std::option::Option<bool>,
        pub(crate) calendar_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) target_locations:
            std::option::Option<std::vec::Vec<crate::model::TargetLocation>>,
    }
    impl Builder {
        /// <p>The name of the SSM document that contains the configuration information for the instance.
        /// You can specify Command or Automation documents.</p>
        /// <p>You can specify AWS-predefined documents, documents you created, or a document that is
        /// shared with you from another account.</p>
        /// <p>For SSM documents that are shared with you from other AWS accounts, you must specify the
        /// complete SSM document ARN, in the following format:</p>
        /// <p>
        /// <code>arn:aws:ssm:<i>region</i>:<i>account-id</i>:document/<i>document-name</i>
        /// </code>
        /// </p>
        /// <p>For example:</p>
        /// <p>
        /// <code>arn:aws:ssm:us-east-2:12345678912:document/My-Shared-Document</code>
        /// </p>
        /// <p>For AWS-predefined documents and SSM documents you created in your account, you only need to
        /// specify the document name. For example, <code>AWS-ApplyPatchBaseline</code> or
        /// <code>My-Document</code>.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ID of the instance. </p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// <p>Specify the target for the association. This target is required for associations that use an
        /// Automation document and target resources by using rate controls.</p>
        pub fn automation_target_parameter_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.automation_target_parameter_name = Some(input.into());
            self
        }
        pub fn set_automation_target_parameter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.automation_target_parameter_name = input;
            self
        }
        /// <p>The document version.</p>
        pub fn document_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_version = Some(input.into());
            self
        }
        pub fn set_document_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_version = input;
            self
        }
        pub fn targets(mut self, input: impl Into<crate::model::Target>) -> Self {
            let mut v = self.targets.unwrap_or_default();
            v.push(input.into());
            self.targets = Some(v);
            self
        }
        pub fn set_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Target>>,
        ) -> Self {
            self.targets = input;
            self
        }
        /// <p>A cron expression that specifies a schedule when the association runs.</p>
        pub fn schedule_expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.schedule_expression = Some(input.into());
            self
        }
        pub fn set_schedule_expression(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.schedule_expression = input;
            self
        }
        /// <p>An S3 bucket where you want to store the results of this request.</p>
        pub fn output_location(
            mut self,
            input: crate::model::InstanceAssociationOutputLocation,
        ) -> Self {
            self.output_location = Some(input);
            self
        }
        pub fn set_output_location(
            mut self,
            input: std::option::Option<crate::model::InstanceAssociationOutputLocation>,
        ) -> Self {
            self.output_location = input;
            self
        }
        /// <p>Specify a descriptive name for the association.</p>
        pub fn association_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_name = Some(input.into());
            self
        }
        pub fn set_association_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_name = input;
            self
        }
        /// <p>The number of errors that are allowed before the system stops sending requests to run the
        /// association on additional targets. You can specify either an absolute number of errors, for
        /// example 10, or a percentage of the target set, for example 10%. If you specify 3, for example,
        /// the system stops sending requests when the fourth error is received. If you specify 0, then the
        /// system stops sending requests after the first error is returned. If you run an association on 50
        /// instances and set MaxError to 10%, then the system stops sending the request when the sixth error
        /// is received.</p>
        /// <p>Executions that are already running an association when MaxErrors is reached are allowed to
        /// complete, but some of these executions may fail as well. If you need to ensure that there won't
        /// be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one
        /// at a time.</p>
        pub fn max_errors(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_errors = Some(input.into());
            self
        }
        pub fn set_max_errors(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_errors = input;
            self
        }
        /// <p>The maximum number of targets allowed to run the association at the same time. You can
        /// specify a number, for example 10, or a percentage of the target set, for example 10%. The default
        /// value is 100%, which means all targets run the association at the same time.</p>
        /// <p>If a new instance starts and attempts to run an association while Systems Manager is running
        /// MaxConcurrency associations, the association is allowed to run. During the next association
        /// interval, the new instance will process its association within the limit specified for
        /// MaxConcurrency.</p>
        pub fn max_concurrency(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_concurrency = Some(input.into());
            self
        }
        pub fn set_max_concurrency(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.max_concurrency = input;
            self
        }
        /// <p>The severity level to assign to the association.</p>
        pub fn compliance_severity(
            mut self,
            input: crate::model::AssociationComplianceSeverity,
        ) -> Self {
            self.compliance_severity = Some(input);
            self
        }
        pub fn set_compliance_severity(
            mut self,
            input: std::option::Option<crate::model::AssociationComplianceSeverity>,
        ) -> Self {
            self.compliance_severity = input;
            self
        }
        /// <p>The mode for generating association compliance. You can specify <code>AUTO</code> or
        /// <code>MANUAL</code>. In <code>AUTO</code> mode, the system uses the status of the association
        /// execution to determine the compliance status. If the association execution runs successfully,
        /// then the association is <code>COMPLIANT</code>. If the association execution doesn't run
        /// successfully, the association is <code>NON-COMPLIANT</code>. </p>
        /// <p>In <code>MANUAL</code> mode, you must specify the <code>AssociationId</code> as a parameter
        /// for the <a>PutComplianceItems</a> API action. In this case, compliance data is not
        /// managed by State Manager. It is managed by your direct call to the <a>PutComplianceItems</a> API action.</p>
        /// <p>By default, all associations use <code>AUTO</code> mode.</p>
        pub fn sync_compliance(mut self, input: crate::model::AssociationSyncCompliance) -> Self {
            self.sync_compliance = Some(input);
            self
        }
        pub fn set_sync_compliance(
            mut self,
            input: std::option::Option<crate::model::AssociationSyncCompliance>,
        ) -> Self {
            self.sync_compliance = input;
            self
        }
        /// <p>By default, when you create a new associations, the system runs it immediately after it is
        /// created and then according to the schedule you specified. Specify this option if you don't want
        /// an association to run immediately after you create it. This parameter is not supported for rate
        /// expressions.</p>
        pub fn apply_only_at_cron_interval(mut self, input: bool) -> Self {
            self.apply_only_at_cron_interval = Some(input);
            self
        }
        pub fn set_apply_only_at_cron_interval(mut self, input: std::option::Option<bool>) -> Self {
            self.apply_only_at_cron_interval = input;
            self
        }
        pub fn calendar_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.calendar_names.unwrap_or_default();
            v.push(input.into());
            self.calendar_names = Some(v);
            self
        }
        pub fn set_calendar_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.calendar_names = input;
            self
        }
        pub fn target_locations(mut self, input: impl Into<crate::model::TargetLocation>) -> Self {
            let mut v = self.target_locations.unwrap_or_default();
            v.push(input.into());
            self.target_locations = Some(v);
            self
        }
        pub fn set_target_locations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TargetLocation>>,
        ) -> Self {
            self.target_locations = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateAssociationBatchRequestEntry`](crate::model::CreateAssociationBatchRequestEntry)
        pub fn build(self) -> crate::model::CreateAssociationBatchRequestEntry {
            crate::model::CreateAssociationBatchRequestEntry {
                name: self.name,
                instance_id: self.instance_id,
                parameters: self.parameters,
                automation_target_parameter_name: self.automation_target_parameter_name,
                document_version: self.document_version,
                targets: self.targets,
                schedule_expression: self.schedule_expression,
                output_location: self.output_location,
                association_name: self.association_name,
                max_errors: self.max_errors,
                max_concurrency: self.max_concurrency,
                compliance_severity: self.compliance_severity,
                sync_compliance: self.sync_compliance,
                apply_only_at_cron_interval: self.apply_only_at_cron_interval.unwrap_or_default(),
                calendar_names: self.calendar_names,
                target_locations: self.target_locations,
            }
        }
    }
}
impl CreateAssociationBatchRequestEntry {
    /// Creates a new builder-style object to manufacture [`CreateAssociationBatchRequestEntry`](crate::model::CreateAssociationBatchRequestEntry)
    pub fn builder() -> crate::model::create_association_batch_request_entry::Builder {
        crate::model::create_association_batch_request_entry::Builder::default()
    }
}
