// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_tags_to_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddTagsToResourceOutput, crate::error::AddTagsToResourceError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AddTagsToResourceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AddTagsToResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::AddTagsToResourceError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::AddTagsToResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidResourceId" => {
            crate::error::AddTagsToResourceError::InvalidResourceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::AddTagsToResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidResourceType" => {
            crate::error::AddTagsToResourceError::InvalidResourceType({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_type_json_err(response.body().as_ref(), output).map_err(crate::error::AddTagsToResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyTagsError" => {
            crate::error::AddTagsToResourceError::TooManyTagsError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_tags_error_json_err(response.body().as_ref(), output).map_err(crate::error::AddTagsToResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyUpdates" => crate::error::AddTagsToResourceError::TooManyUpdates({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_updates::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddTagsToResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::AddTagsToResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_tags_to_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddTagsToResourceOutput, crate::error::AddTagsToResourceError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_tags_to_resource_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_ops_item_related_item_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateOpsItemRelatedItemOutput,
    crate::error::AssociateOpsItemRelatedItemError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AssociateOpsItemRelatedItemError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AssociateOpsItemRelatedItemError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::AssociateOpsItemRelatedItemError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateOpsItemRelatedItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsItemInvalidParameterException" => {
            crate::error::AssociateOpsItemRelatedItemError::OpsItemInvalidParameterException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_item_invalid_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateOpsItemRelatedItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsItemLimitExceededException" => {
            crate::error::AssociateOpsItemRelatedItemError::OpsItemLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_item_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateOpsItemRelatedItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsItemNotFoundException" => {
            crate::error::AssociateOpsItemRelatedItemError::OpsItemNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateOpsItemRelatedItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsItemRelatedItemAlreadyExistsException" => {
            crate::error::AssociateOpsItemRelatedItemError::OpsItemRelatedItemAlreadyExistsException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_related_item_already_exists_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_ops_item_related_item_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateOpsItemRelatedItemError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        _ => crate::error::AssociateOpsItemRelatedItemError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_ops_item_related_item_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateOpsItemRelatedItemOutput,
    crate::error::AssociateOpsItemRelatedItemError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_ops_item_related_item_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_associate_ops_item_related_item(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::AssociateOpsItemRelatedItemError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_command_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CancelCommandOutput, crate::error::CancelCommandError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CancelCommandError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CancelCommandError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DuplicateInstanceId" => {
            crate::error::CancelCommandError::DuplicateInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::duplicate_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_duplicate_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::CancelCommandError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::CancelCommandError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CancelCommandError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidCommandId" => crate::error::CancelCommandError::InvalidCommandId({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_command_id::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_command_id_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CancelCommandError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidInstanceId" => {
            crate::error::CancelCommandError::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::CancelCommandError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CancelCommandError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_command_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CancelCommandOutput, crate::error::CancelCommandError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_command_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_maintenance_window_execution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CancelMaintenanceWindowExecutionOutput,
    crate::error::CancelMaintenanceWindowExecutionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CancelMaintenanceWindowExecutionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CancelMaintenanceWindowExecutionError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => {
            crate::error::CancelMaintenanceWindowExecutionError::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CancelMaintenanceWindowExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::CancelMaintenanceWindowExecutionError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CancelMaintenanceWindowExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CancelMaintenanceWindowExecutionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_maintenance_window_execution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CancelMaintenanceWindowExecutionOutput,
    crate::error::CancelMaintenanceWindowExecutionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::cancel_maintenance_window_execution_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_cancel_maintenance_window_execution(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CancelMaintenanceWindowExecutionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_activation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateActivationOutput, crate::error::CreateActivationError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateActivationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateActivationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::CreateActivationError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateActivationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidParameters" => crate::error::CreateActivationError::InvalidParameters({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameters::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_parameters_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateActivationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateActivationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_activation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateActivationOutput, crate::error::CreateActivationError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_activation_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_activation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateActivationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_association_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateAssociationOutput, crate::error::CreateAssociationError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateAssociationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateAssociationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AssociationAlreadyExists" => {
            crate::error::CreateAssociationError::AssociationAlreadyExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_already_exists::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_already_exists_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "AssociationLimitExceeded" => {
            crate::error::CreateAssociationError::AssociationLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::CreateAssociationError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDocument" => crate::error::CreateAssociationError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateAssociationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidDocumentVersion" => crate::error::CreateAssociationError::InvalidDocumentVersion({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document_version::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidInstanceId" => {
            crate::error::CreateAssociationError::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidOutputLocation" => crate::error::CreateAssociationError::InvalidOutputLocation({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_output_location::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_output_location_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidParameters" => crate::error::CreateAssociationError::InvalidParameters({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameters::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_parameters_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateAssociationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidSchedule" => crate::error::CreateAssociationError::InvalidSchedule({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_schedule::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_schedule_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateAssociationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidTag" => crate::error::CreateAssociationError::InvalidTag({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_tag::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_tag_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateAssociationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidTarget" => crate::error::CreateAssociationError::InvalidTarget({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_target::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_target_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateAssociationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidTargetMaps" => {
            crate::error::CreateAssociationError::InvalidTargetMaps({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_target_maps::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_target_maps_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "UnsupportedPlatformType" => {
            crate::error::CreateAssociationError::UnsupportedPlatformType({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_platform_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_platform_type_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateAssociationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_association_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateAssociationOutput, crate::error::CreateAssociationError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_association_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_association(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateAssociationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_association_batch_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateAssociationBatchOutput,
    crate::error::CreateAssociationBatchError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateAssociationBatchError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateAssociationBatchError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AssociationLimitExceeded" => {
            crate::error::CreateAssociationBatchError::AssociationLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DuplicateInstanceId" => {
            crate::error::CreateAssociationBatchError::DuplicateInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::duplicate_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_duplicate_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::CreateAssociationBatchError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDocument" => crate::error::CreateAssociationBatchError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidDocumentVersion" => {
            crate::error::CreateAssociationBatchError::InvalidDocumentVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidInstanceId" => {
            crate::error::CreateAssociationBatchError::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidOutputLocation" => {
            crate::error::CreateAssociationBatchError::InvalidOutputLocation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_output_location::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_output_location_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidParameters" => crate::error::CreateAssociationBatchError::InvalidParameters({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameters::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_parameters_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidSchedule" => crate::error::CreateAssociationBatchError::InvalidSchedule({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_schedule::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_schedule_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidTarget" => crate::error::CreateAssociationBatchError::InvalidTarget({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_target::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_target_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidTargetMaps" => {
            crate::error::CreateAssociationBatchError::InvalidTargetMaps({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_target_maps::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_target_maps_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "UnsupportedPlatformType" => {
            crate::error::CreateAssociationBatchError::UnsupportedPlatformType({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_platform_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_platform_type_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateAssociationBatchError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_association_batch_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateAssociationBatchOutput,
    crate::error::CreateAssociationBatchError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_association_batch_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_association_batch(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateAssociationBatchError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_document_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDocumentOutput, crate::error::CreateDocumentError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateDocumentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDocumentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DocumentAlreadyExists" => crate::error::CreateDocumentError::DocumentAlreadyExists({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::document_already_exists::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_document_already_exists_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDocumentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "DocumentLimitExceeded" => crate::error::CreateDocumentError::DocumentLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::document_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_document_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDocumentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InternalServerError" => {
            crate::error::CreateDocumentError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDocumentContent" => crate::error::CreateDocumentError::InvalidDocumentContent({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document_content::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_content_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDocumentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidDocumentSchemaVersion" => {
            crate::error::CreateDocumentError::InvalidDocumentSchemaVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_document_schema_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_schema_version_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "MaxDocumentSizeExceeded" => crate::error::CreateDocumentError::MaxDocumentSizeExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::max_document_size_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_max_document_size_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDocumentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateDocumentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_document_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDocumentOutput, crate::error::CreateDocumentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_document_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_document(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDocumentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_maintenance_window_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateMaintenanceWindowOutput,
    crate::error::CreateMaintenanceWindowError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateMaintenanceWindowError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateMaintenanceWindowError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "IdempotentParameterMismatch" => {
            crate::error::CreateMaintenanceWindowError::IdempotentParameterMismatch({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::idempotent_parameter_mismatch::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotent_parameter_mismatch_json_err(response.body().as_ref(), output).map_err(crate::error::CreateMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::CreateMaintenanceWindowError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourceLimitExceededException" => {
            crate::error::CreateMaintenanceWindowError::ResourceLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateMaintenanceWindowError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_maintenance_window_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateMaintenanceWindowOutput,
    crate::error::CreateMaintenanceWindowError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_maintenance_window_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_maintenance_window(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateMaintenanceWindowError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_ops_item_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateOpsItemOutput, crate::error::CreateOpsItemError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateOpsItemError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateOpsItemError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::CreateOpsItemError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsItemAccessDeniedException" => {
            crate::error::CreateOpsItemError::OpsItemAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_item_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsItemAlreadyExistsException" => {
            crate::error::CreateOpsItemError::OpsItemAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_item_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsItemInvalidParameterException" => {
            crate::error::CreateOpsItemError::OpsItemInvalidParameterException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_item_invalid_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsItemLimitExceededException" => {
            crate::error::CreateOpsItemError::OpsItemLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_item_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateOpsItemError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_ops_item_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateOpsItemOutput, crate::error::CreateOpsItemError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_ops_item_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_ops_item(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateOpsItemError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_ops_metadata_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateOpsMetadataOutput, crate::error::CreateOpsMetadataError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateOpsMetadataError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateOpsMetadataError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::CreateOpsMetadataError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsMetadataAlreadyExistsException" => {
            crate::error::CreateOpsMetadataError::OpsMetadataAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_metadata_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsMetadataInvalidArgumentException" => {
            crate::error::CreateOpsMetadataError::OpsMetadataInvalidArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_metadata_invalid_argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_invalid_argument_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsMetadataLimitExceededException" => {
            crate::error::CreateOpsMetadataError::OpsMetadataLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_metadata_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsMetadataTooManyUpdatesException" => {
            crate::error::CreateOpsMetadataError::OpsMetadataTooManyUpdatesException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_metadata_too_many_updates_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_too_many_updates_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateOpsMetadataError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_ops_metadata_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateOpsMetadataOutput, crate::error::CreateOpsMetadataError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_ops_metadata_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_ops_metadata(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateOpsMetadataError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_patch_baseline_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreatePatchBaselineOutput,
    crate::error::CreatePatchBaselineError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreatePatchBaselineError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreatePatchBaselineError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "IdempotentParameterMismatch" => {
            crate::error::CreatePatchBaselineError::IdempotentParameterMismatch({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::idempotent_parameter_mismatch::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotent_parameter_mismatch_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::CreatePatchBaselineError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourceLimitExceededException" => {
            crate::error::CreatePatchBaselineError::ResourceLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreatePatchBaselineError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_patch_baseline_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreatePatchBaselineOutput,
    crate::error::CreatePatchBaselineError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_patch_baseline_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_patch_baseline(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreatePatchBaselineError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_resource_data_sync_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateResourceDataSyncOutput,
    crate::error::CreateResourceDataSyncError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateResourceDataSyncError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateResourceDataSyncError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::CreateResourceDataSyncError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateResourceDataSyncError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourceDataSyncAlreadyExistsException" => {
            crate::error::CreateResourceDataSyncError::ResourceDataSyncAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_data_sync_already_exists_exception::Builder::default(
                        );
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_data_sync_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateResourceDataSyncError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourceDataSyncCountExceededException" => {
            crate::error::CreateResourceDataSyncError::ResourceDataSyncCountExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_data_sync_count_exceeded_exception::Builder::default(
                        );
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_data_sync_count_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateResourceDataSyncError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourceDataSyncInvalidConfigurationException" => {
            crate::error::CreateResourceDataSyncError::ResourceDataSyncInvalidConfigurationException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                    let mut output = crate::error::resource_data_sync_invalid_configuration_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_resource_data_sync_invalid_configuration_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateResourceDataSyncError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        _ => crate::error::CreateResourceDataSyncError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_resource_data_sync_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateResourceDataSyncOutput,
    crate::error::CreateResourceDataSyncError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_resource_data_sync_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_activation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteActivationOutput, crate::error::DeleteActivationError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteActivationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteActivationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DeleteActivationError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteActivationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidActivation" => crate::error::DeleteActivationError::InvalidActivation({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_activation::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_activation_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteActivationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidActivationId" => {
            crate::error::DeleteActivationError::InvalidActivationId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_activation_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_activation_id_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteActivationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyUpdates" => crate::error::DeleteActivationError::TooManyUpdates({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_updates::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteActivationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteActivationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_activation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteActivationOutput, crate::error::DeleteActivationError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_activation_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_association_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteAssociationOutput, crate::error::DeleteAssociationError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteAssociationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteAssociationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AssociationDoesNotExist" => {
            crate::error::DeleteAssociationError::AssociationDoesNotExist({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::DeleteAssociationError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDocument" => crate::error::DeleteAssociationError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteAssociationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidInstanceId" => {
            crate::error::DeleteAssociationError::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyUpdates" => crate::error::DeleteAssociationError::TooManyUpdates({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_updates::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteAssociationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteAssociationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_association_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteAssociationOutput, crate::error::DeleteAssociationError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_association_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_document_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDocumentOutput, crate::error::DeleteDocumentError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteDocumentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDocumentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AssociatedInstances" => {
            crate::error::DeleteDocumentError::AssociatedInstances({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::associated_instances::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_associated_instances_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::DeleteDocumentError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDocument" => crate::error::DeleteDocumentError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteDocumentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidDocumentOperation" => {
            crate::error::DeleteDocumentError::InvalidDocumentOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_operation::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_operation_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteDocumentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_document_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDocumentOutput, crate::error::DeleteDocumentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_document_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_inventory_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteInventoryOutput, crate::error::DeleteInventoryError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteInventoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteInventoryError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DeleteInventoryError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDeleteInventoryParametersException" => {
            crate::error::DeleteInventoryError::InvalidDeleteInventoryParametersException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_delete_inventory_parameters_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_delete_inventory_parameters_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidInventoryRequestException" => {
            crate::error::DeleteInventoryError::InvalidInventoryRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_inventory_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_inventory_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidOptionException" => crate::error::DeleteInventoryError::InvalidOptionException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_option_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_option_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteInventoryError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidTypeNameException" => {
            crate::error::DeleteInventoryError::InvalidTypeNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_type_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_type_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteInventoryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_inventory_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteInventoryOutput, crate::error::DeleteInventoryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_inventory_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_inventory(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteInventoryError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_maintenance_window_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteMaintenanceWindowOutput,
    crate::error::DeleteMaintenanceWindowError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteMaintenanceWindowError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteMaintenanceWindowError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DeleteMaintenanceWindowError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteMaintenanceWindowError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_maintenance_window_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteMaintenanceWindowOutput,
    crate::error::DeleteMaintenanceWindowError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_maintenance_window_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_maintenance_window(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteMaintenanceWindowError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_ops_metadata_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteOpsMetadataOutput, crate::error::DeleteOpsMetadataError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteOpsMetadataError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteOpsMetadataError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DeleteOpsMetadataError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsMetadataInvalidArgumentException" => {
            crate::error::DeleteOpsMetadataError::OpsMetadataInvalidArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_metadata_invalid_argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_invalid_argument_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsMetadataNotFoundException" => {
            crate::error::DeleteOpsMetadataError::OpsMetadataNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_metadata_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteOpsMetadataError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_ops_metadata_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteOpsMetadataOutput, crate::error::DeleteOpsMetadataError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_ops_metadata_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_parameter_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteParameterOutput, crate::error::DeleteParameterError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteParameterError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteParameterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DeleteParameterError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ParameterNotFound" => {
            crate::error::DeleteParameterError::ParameterNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteParameterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_parameter_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteParameterOutput, crate::error::DeleteParameterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_parameter_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_parameters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteParametersOutput, crate::error::DeleteParametersError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteParametersError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteParametersError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DeleteParametersError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteParametersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteParametersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_parameters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteParametersOutput, crate::error::DeleteParametersError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_parameters_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_parameters(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteParametersError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_patch_baseline_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeletePatchBaselineOutput,
    crate::error::DeletePatchBaselineError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeletePatchBaselineError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeletePatchBaselineError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DeletePatchBaselineError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourceInUseException" => {
            crate::error::DeletePatchBaselineError::ResourceInUseException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_in_use_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_in_use_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeletePatchBaselineError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_patch_baseline_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeletePatchBaselineOutput,
    crate::error::DeletePatchBaselineError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_patch_baseline_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_patch_baseline(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeletePatchBaselineError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_resource_data_sync_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteResourceDataSyncOutput,
    crate::error::DeleteResourceDataSyncError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteResourceDataSyncError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteResourceDataSyncError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DeleteResourceDataSyncError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteResourceDataSyncError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourceDataSyncInvalidConfigurationException" => {
            crate::error::DeleteResourceDataSyncError::ResourceDataSyncInvalidConfigurationException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                    let mut output = crate::error::resource_data_sync_invalid_configuration_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_resource_data_sync_invalid_configuration_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteResourceDataSyncError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        "ResourceDataSyncNotFoundException" => {
            crate::error::DeleteResourceDataSyncError::ResourceDataSyncNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_data_sync_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_data_sync_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteResourceDataSyncError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteResourceDataSyncError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_resource_data_sync_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteResourceDataSyncOutput,
    crate::error::DeleteResourceDataSyncError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_resource_data_sync_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_resource_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteResourcePolicyOutput,
    crate::error::DeleteResourcePolicyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteResourcePolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteResourcePolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DeleteResourcePolicyError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteResourcePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourcePolicyConflictException" => {
            crate::error::DeleteResourcePolicyError::ResourcePolicyConflictException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_policy_conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_policy_conflict_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteResourcePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourcePolicyInvalidParameterException" => {
            crate::error::DeleteResourcePolicyError::ResourcePolicyInvalidParameterException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_policy_invalid_parameter_exception::Builder::default(
                        );
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_policy_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteResourcePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteResourcePolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_resource_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteResourcePolicyOutput,
    crate::error::DeleteResourcePolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_resource_policy_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_managed_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeregisterManagedInstanceOutput,
    crate::error::DeregisterManagedInstanceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeregisterManagedInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeregisterManagedInstanceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DeregisterManagedInstanceError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterManagedInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidInstanceId" => {
            crate::error::DeregisterManagedInstanceError::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterManagedInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeregisterManagedInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_managed_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeregisterManagedInstanceOutput,
    crate::error::DeregisterManagedInstanceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deregister_managed_instance_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_patch_baseline_for_patch_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeregisterPatchBaselineForPatchGroupOutput,
    crate::error::DeregisterPatchBaselineForPatchGroupError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeregisterPatchBaselineForPatchGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeregisterPatchBaselineForPatchGroupError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DeregisterPatchBaselineForPatchGroupError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterPatchBaselineForPatchGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidResourceId" => {
            crate::error::DeregisterPatchBaselineForPatchGroupError::InvalidResourceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterPatchBaselineForPatchGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeregisterPatchBaselineForPatchGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_patch_baseline_for_patch_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeregisterPatchBaselineForPatchGroupOutput,
    crate::error::DeregisterPatchBaselineForPatchGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::deregister_patch_baseline_for_patch_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_deregister_patch_baseline_for_patch_group(response.body().as_ref(), output).map_err(crate::error::DeregisterPatchBaselineForPatchGroupError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_target_from_maintenance_window_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeregisterTargetFromMaintenanceWindowOutput,
    crate::error::DeregisterTargetFromMaintenanceWindowError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeregisterTargetFromMaintenanceWindowError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DeregisterTargetFromMaintenanceWindowError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => {
            crate::error::DeregisterTargetFromMaintenanceWindowError::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterTargetFromMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::DeregisterTargetFromMaintenanceWindowError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterTargetFromMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TargetInUseException" => {
            crate::error::DeregisterTargetFromMaintenanceWindowError::TargetInUseException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::target_in_use_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_target_in_use_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterTargetFromMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeregisterTargetFromMaintenanceWindowError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_target_from_maintenance_window_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeregisterTargetFromMaintenanceWindowOutput,
    crate::error::DeregisterTargetFromMaintenanceWindowError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::deregister_target_from_maintenance_window_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_deregister_target_from_maintenance_window(response.body().as_ref(), output).map_err(crate::error::DeregisterTargetFromMaintenanceWindowError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_task_from_maintenance_window_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeregisterTaskFromMaintenanceWindowOutput,
    crate::error::DeregisterTaskFromMaintenanceWindowError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeregisterTaskFromMaintenanceWindowError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeregisterTaskFromMaintenanceWindowError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => {
            crate::error::DeregisterTaskFromMaintenanceWindowError::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterTaskFromMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::DeregisterTaskFromMaintenanceWindowError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterTaskFromMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeregisterTaskFromMaintenanceWindowError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_task_from_maintenance_window_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeregisterTaskFromMaintenanceWindowOutput,
    crate::error::DeregisterTaskFromMaintenanceWindowError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::deregister_task_from_maintenance_window_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_deregister_task_from_maintenance_window(response.body().as_ref(), output).map_err(crate::error::DeregisterTaskFromMaintenanceWindowError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_activations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeActivationsOutput,
    crate::error::DescribeActivationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeActivationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeActivationsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DescribeActivationsError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeActivationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidFilter" => crate::error::DescribeActivationsError::InvalidFilter({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_filter::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DescribeActivationsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidNextToken" => crate::error::DescribeActivationsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeActivationsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeActivationsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_activations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeActivationsOutput,
    crate::error::DescribeActivationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_activations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_activations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeActivationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_association_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAssociationOutput,
    crate::error::DescribeAssociationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeAssociationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeAssociationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AssociationDoesNotExist" => {
            crate::error::DescribeAssociationError::AssociationDoesNotExist({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::DescribeAssociationError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidAssociationVersion" => {
            crate::error::DescribeAssociationError::InvalidAssociationVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_association_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_association_version_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDocument" => crate::error::DescribeAssociationError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DescribeAssociationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidInstanceId" => {
            crate::error::DescribeAssociationError::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeAssociationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_association_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAssociationOutput,
    crate::error::DescribeAssociationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_association_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_association(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeAssociationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_association_executions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAssociationExecutionsOutput,
    crate::error::DescribeAssociationExecutionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeAssociationExecutionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeAssociationExecutionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AssociationDoesNotExist" => {
            crate::error::DescribeAssociationExecutionsError::AssociationDoesNotExist({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationExecutionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::DescribeAssociationExecutionsError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationExecutionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidNextToken" => crate::error::DescribeAssociationExecutionsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeAssociationExecutionsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeAssociationExecutionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_association_executions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAssociationExecutionsOutput,
    crate::error::DescribeAssociationExecutionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_association_executions_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_describe_association_executions(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeAssociationExecutionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_association_execution_targets_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAssociationExecutionTargetsOutput,
    crate::error::DescribeAssociationExecutionTargetsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeAssociationExecutionTargetsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeAssociationExecutionTargetsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AssociationDoesNotExist" => {
            crate::error::DescribeAssociationExecutionTargetsError::AssociationDoesNotExist({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationExecutionTargetsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "AssociationExecutionDoesNotExist" => {
            crate::error::DescribeAssociationExecutionTargetsError::AssociationExecutionDoesNotExist(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::association_execution_does_not_exist::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_association_execution_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationExecutionTargetsError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        "InternalServerError" => {
            crate::error::DescribeAssociationExecutionTargetsError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationExecutionTargetsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidNextToken" => {
            crate::error::DescribeAssociationExecutionTargetsError::InvalidNextToken({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::DescribeAssociationExecutionTargetsError::unhandled,
                        )?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeAssociationExecutionTargetsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_association_execution_targets_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAssociationExecutionTargetsOutput,
    crate::error::DescribeAssociationExecutionTargetsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_association_execution_targets_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_association_execution_targets(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationExecutionTargetsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_automation_executions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAutomationExecutionsOutput,
    crate::error::DescribeAutomationExecutionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeAutomationExecutionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeAutomationExecutionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DescribeAutomationExecutionsError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationExecutionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidFilterKey" => crate::error::DescribeAutomationExecutionsError::InvalidFilterKey({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_filter_key::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeAutomationExecutionsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidFilterValue" => {
            crate::error::DescribeAutomationExecutionsError::InvalidFilterValue({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_value::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_value_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationExecutionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidNextToken" => crate::error::DescribeAutomationExecutionsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeAutomationExecutionsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeAutomationExecutionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_automation_executions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAutomationExecutionsOutput,
    crate::error::DescribeAutomationExecutionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_automation_executions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_automation_executions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeAutomationExecutionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_automation_step_executions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAutomationStepExecutionsOutput,
    crate::error::DescribeAutomationStepExecutionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeAutomationStepExecutionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeAutomationStepExecutionsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AutomationExecutionNotFoundException" => crate::error::DescribeAutomationStepExecutionsError::AutomationExecutionNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::automation_execution_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_execution_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationStepExecutionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::DescribeAutomationStepExecutionsError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationStepExecutionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilterKey" => crate::error::DescribeAutomationStepExecutionsError::InvalidFilterKey({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_key::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationStepExecutionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilterValue" => crate::error::DescribeAutomationStepExecutionsError::InvalidFilterValue({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_value::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_value_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationStepExecutionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::DescribeAutomationStepExecutionsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationStepExecutionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeAutomationStepExecutionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_automation_step_executions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAutomationStepExecutionsOutput,
    crate::error::DescribeAutomationStepExecutionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_automation_step_executions_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_describe_automation_step_executions(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeAutomationStepExecutionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_available_patches_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAvailablePatchesOutput,
    crate::error::DescribeAvailablePatchesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeAvailablePatchesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeAvailablePatchesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DescribeAvailablePatchesError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAvailablePatchesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeAvailablePatchesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_available_patches_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAvailablePatchesOutput,
    crate::error::DescribeAvailablePatchesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_available_patches_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_available_patches(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeAvailablePatchesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_document_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeDocumentOutput, crate::error::DescribeDocumentError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeDocumentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeDocumentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DescribeDocumentError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDocument" => crate::error::DescribeDocumentError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DescribeDocumentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidDocumentVersion" => crate::error::DescribeDocumentError::InvalidDocumentVersion({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document_version::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDocumentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeDocumentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_document_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeDocumentOutput, crate::error::DescribeDocumentError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_document_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_document(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDocumentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_document_permission_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDocumentPermissionOutput,
    crate::error::DescribeDocumentPermissionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeDocumentPermissionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDocumentPermissionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DescribeDocumentPermissionError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDocumentPermissionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDocument" => crate::error::DescribeDocumentPermissionError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DescribeDocumentPermissionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidDocumentOperation" => {
            crate::error::DescribeDocumentPermissionError::InvalidDocumentOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_operation::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_operation_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDocumentPermissionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidNextToken" => crate::error::DescribeDocumentPermissionError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeDocumentPermissionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidPermissionType" => {
            crate::error::DescribeDocumentPermissionError::InvalidPermissionType({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_permission_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_permission_type_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDocumentPermissionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeDocumentPermissionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_document_permission_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDocumentPermissionOutput,
    crate::error::DescribeDocumentPermissionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_document_permission_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_document_permission(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDocumentPermissionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_effective_instance_associations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEffectiveInstanceAssociationsOutput,
    crate::error::DescribeEffectiveInstanceAssociationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeEffectiveInstanceAssociationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DescribeEffectiveInstanceAssociationsError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DescribeEffectiveInstanceAssociationsError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeEffectiveInstanceAssociationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidInstanceId" => {
            crate::error::DescribeEffectiveInstanceAssociationsError::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeEffectiveInstanceAssociationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidNextToken" => {
            crate::error::DescribeEffectiveInstanceAssociationsError::InvalidNextToken({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::DescribeEffectiveInstanceAssociationsError::unhandled,
                        )?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeEffectiveInstanceAssociationsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_effective_instance_associations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEffectiveInstanceAssociationsOutput,
    crate::error::DescribeEffectiveInstanceAssociationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_effective_instance_associations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_effective_instance_associations(response.body().as_ref(), output).map_err(crate::error::DescribeEffectiveInstanceAssociationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_effective_patches_for_patch_baseline_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEffectivePatchesForPatchBaselineOutput,
    crate::error::DescribeEffectivePatchesForPatchBaselineError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => {
            crate::error::DescribeEffectivePatchesForPatchBaselineError::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::DescribeEffectivePatchesForPatchBaselineError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidResourceId" => {
            crate::error::DescribeEffectivePatchesForPatchBaselineError::InvalidResourceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "UnsupportedOperatingSystem" => {
            crate::error::DescribeEffectivePatchesForPatchBaselineError::UnsupportedOperatingSystem(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::unsupported_operating_system::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_unsupported_operating_system_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        _ => crate::error::DescribeEffectivePatchesForPatchBaselineError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_effective_patches_for_patch_baseline_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEffectivePatchesForPatchBaselineOutput,
    crate::error::DescribeEffectivePatchesForPatchBaselineError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_effective_patches_for_patch_baseline_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_effective_patches_for_patch_baseline(response.body().as_ref(), output).map_err(crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_associations_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstanceAssociationsStatusOutput,
    crate::error::DescribeInstanceAssociationsStatusError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeInstanceAssociationsStatusError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeInstanceAssociationsStatusError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DescribeInstanceAssociationsStatusError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceAssociationsStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidInstanceId" => {
            crate::error::DescribeInstanceAssociationsStatusError::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceAssociationsStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidNextToken" => {
            crate::error::DescribeInstanceAssociationsStatusError::InvalidNextToken({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::DescribeInstanceAssociationsStatusError::unhandled,
                        )?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeInstanceAssociationsStatusError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_associations_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstanceAssociationsStatusOutput,
    crate::error::DescribeInstanceAssociationsStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_instance_associations_status_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_instance_associations_status(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceAssociationsStatusError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_information_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstanceInformationOutput,
    crate::error::DescribeInstanceInformationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeInstanceInformationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeInstanceInformationError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DescribeInstanceInformationError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceInformationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidFilterKey" => crate::error::DescribeInstanceInformationError::InvalidFilterKey({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_filter_key::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeInstanceInformationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidInstanceId" => {
            crate::error::DescribeInstanceInformationError::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceInformationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidInstanceInformationFilterValue" => {
            crate::error::DescribeInstanceInformationError::InvalidInstanceInformationFilterValue({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_instance_information_filter_value::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_information_filter_value_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceInformationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidNextToken" => crate::error::DescribeInstanceInformationError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeInstanceInformationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeInstanceInformationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_information_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstanceInformationOutput,
    crate::error::DescribeInstanceInformationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instance_information_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_instance_information(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeInstanceInformationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_patches_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstancePatchesOutput,
    crate::error::DescribeInstancePatchesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeInstancePatchesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeInstancePatchesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DescribeInstancePatchesError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancePatchesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidFilter" => crate::error::DescribeInstancePatchesError::InvalidFilter({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_filter::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DescribeInstancePatchesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidInstanceId" => {
            crate::error::DescribeInstancePatchesError::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancePatchesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidNextToken" => crate::error::DescribeInstancePatchesError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeInstancePatchesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeInstancePatchesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_patches_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstancePatchesOutput,
    crate::error::DescribeInstancePatchesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instance_patches_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_instance_patches(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeInstancePatchesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_patch_states_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstancePatchStatesOutput,
    crate::error::DescribeInstancePatchStatesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeInstancePatchStatesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeInstancePatchStatesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DescribeInstancePatchStatesError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancePatchStatesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidNextToken" => crate::error::DescribeInstancePatchStatesError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeInstancePatchStatesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeInstancePatchStatesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_patch_states_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstancePatchStatesOutput,
    crate::error::DescribeInstancePatchStatesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instance_patch_states_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_instance_patch_states(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeInstancePatchStatesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_patch_states_for_patch_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstancePatchStatesForPatchGroupOutput,
    crate::error::DescribeInstancePatchStatesForPatchGroupError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeInstancePatchStatesForPatchGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DescribeInstancePatchStatesForPatchGroupError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DescribeInstancePatchStatesForPatchGroupError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancePatchStatesForPatchGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidFilter" => {
            crate::error::DescribeInstancePatchStatesForPatchGroupError::InvalidFilter({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::DescribeInstancePatchStatesForPatchGroupError::unhandled,
                        )?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidNextToken" => {
            crate::error::DescribeInstancePatchStatesForPatchGroupError::InvalidNextToken({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::DescribeInstancePatchStatesForPatchGroupError::unhandled,
                        )?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeInstancePatchStatesForPatchGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_patch_states_for_patch_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstancePatchStatesForPatchGroupOutput,
    crate::error::DescribeInstancePatchStatesForPatchGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_instance_patch_states_for_patch_group_output::Builder::default(
            );
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_instance_patch_states_for_patch_group(response.body().as_ref(), output).map_err(crate::error::DescribeInstancePatchStatesForPatchGroupError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_inventory_deletions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInventoryDeletionsOutput,
    crate::error::DescribeInventoryDeletionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeInventoryDeletionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeInventoryDeletionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DescribeInventoryDeletionsError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInventoryDeletionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDeletionIdException" => {
            crate::error::DescribeInventoryDeletionsError::InvalidDeletionIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_deletion_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_deletion_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInventoryDeletionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidNextToken" => crate::error::DescribeInventoryDeletionsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeInventoryDeletionsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeInventoryDeletionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_inventory_deletions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInventoryDeletionsOutput,
    crate::error::DescribeInventoryDeletionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_inventory_deletions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_inventory_deletions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeInventoryDeletionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_executions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowExecutionsOutput,
    crate::error::DescribeMaintenanceWindowExecutionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeMaintenanceWindowExecutionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeMaintenanceWindowExecutionsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DescribeMaintenanceWindowExecutionsError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowExecutionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeMaintenanceWindowExecutionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_executions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowExecutionsOutput,
    crate::error::DescribeMaintenanceWindowExecutionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_maintenance_window_executions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_maintenance_window_executions(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowExecutionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_execution_task_invocations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowExecutionTaskInvocationsOutput,
    crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::unhandled(
                    generic,
                ),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_execution_task_invocations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowExecutionTaskInvocationsOutput,
    crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_maintenance_window_execution_task_invocations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_maintenance_window_execution_task_invocations(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_execution_tasks_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowExecutionTasksOutput,
    crate::error::DescribeMaintenanceWindowExecutionTasksError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeMaintenanceWindowExecutionTasksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DescribeMaintenanceWindowExecutionTasksError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => {
            crate::error::DescribeMaintenanceWindowExecutionTasksError::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowExecutionTasksError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::DescribeMaintenanceWindowExecutionTasksError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowExecutionTasksError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeMaintenanceWindowExecutionTasksError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_execution_tasks_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowExecutionTasksOutput,
    crate::error::DescribeMaintenanceWindowExecutionTasksError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_maintenance_window_execution_tasks_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_maintenance_window_execution_tasks(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowExecutionTasksError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_windows_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowsOutput,
    crate::error::DescribeMaintenanceWindowsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeMaintenanceWindowsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeMaintenanceWindowsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DescribeMaintenanceWindowsError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeMaintenanceWindowsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_windows_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowsOutput,
    crate::error::DescribeMaintenanceWindowsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_maintenance_windows_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_maintenance_windows(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeMaintenanceWindowsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_schedule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowScheduleOutput,
    crate::error::DescribeMaintenanceWindowScheduleError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeMaintenanceWindowScheduleError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeMaintenanceWindowScheduleError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => {
            crate::error::DescribeMaintenanceWindowScheduleError::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowScheduleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::DescribeMaintenanceWindowScheduleError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowScheduleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeMaintenanceWindowScheduleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_schedule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowScheduleOutput,
    crate::error::DescribeMaintenanceWindowScheduleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_maintenance_window_schedule_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_maintenance_window_schedule(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowScheduleError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_windows_for_target_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowsForTargetOutput,
    crate::error::DescribeMaintenanceWindowsForTargetError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeMaintenanceWindowsForTargetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeMaintenanceWindowsForTargetError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DescribeMaintenanceWindowsForTargetError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowsForTargetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeMaintenanceWindowsForTargetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_windows_for_target_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowsForTargetOutput,
    crate::error::DescribeMaintenanceWindowsForTargetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_maintenance_windows_for_target_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_maintenance_windows_for_target(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowsForTargetError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_targets_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowTargetsOutput,
    crate::error::DescribeMaintenanceWindowTargetsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeMaintenanceWindowTargetsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeMaintenanceWindowTargetsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => {
            crate::error::DescribeMaintenanceWindowTargetsError::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowTargetsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::DescribeMaintenanceWindowTargetsError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowTargetsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeMaintenanceWindowTargetsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_targets_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowTargetsOutput,
    crate::error::DescribeMaintenanceWindowTargetsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_maintenance_window_targets_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_describe_maintenance_window_targets(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeMaintenanceWindowTargetsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_tasks_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowTasksOutput,
    crate::error::DescribeMaintenanceWindowTasksError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeMaintenanceWindowTasksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeMaintenanceWindowTasksError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => {
            crate::error::DescribeMaintenanceWindowTasksError::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowTasksError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::DescribeMaintenanceWindowTasksError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowTasksError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeMaintenanceWindowTasksError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_tasks_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowTasksOutput,
    crate::error::DescribeMaintenanceWindowTasksError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_maintenance_window_tasks_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_describe_maintenance_window_tasks(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeMaintenanceWindowTasksError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_ops_items_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeOpsItemsOutput, crate::error::DescribeOpsItemsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeOpsItemsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeOpsItemsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DescribeOpsItemsError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeOpsItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeOpsItemsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_ops_items_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeOpsItemsOutput, crate::error::DescribeOpsItemsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_ops_items_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_ops_items(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeOpsItemsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_parameters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeParametersOutput,
    crate::error::DescribeParametersError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeParametersError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeParametersError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DescribeParametersError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeParametersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidFilterKey" => crate::error::DescribeParametersError::InvalidFilterKey({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_filter_key::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeParametersError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidFilterOption" => {
            crate::error::DescribeParametersError::InvalidFilterOption({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_option::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_option_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeParametersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidFilterValue" => {
            crate::error::DescribeParametersError::InvalidFilterValue({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_value::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_value_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeParametersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidNextToken" => crate::error::DescribeParametersError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeParametersError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeParametersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_parameters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeParametersOutput,
    crate::error::DescribeParametersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_parameters_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_parameters(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeParametersError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_patch_baselines_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePatchBaselinesOutput,
    crate::error::DescribePatchBaselinesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribePatchBaselinesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribePatchBaselinesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DescribePatchBaselinesError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePatchBaselinesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribePatchBaselinesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_patch_baselines_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePatchBaselinesOutput,
    crate::error::DescribePatchBaselinesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_patch_baselines_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_patch_baselines(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribePatchBaselinesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_patch_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePatchGroupsOutput,
    crate::error::DescribePatchGroupsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribePatchGroupsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribePatchGroupsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DescribePatchGroupsError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePatchGroupsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribePatchGroupsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_patch_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePatchGroupsOutput,
    crate::error::DescribePatchGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_patch_groups_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_patch_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribePatchGroupsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_patch_group_state_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePatchGroupStateOutput,
    crate::error::DescribePatchGroupStateError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribePatchGroupStateError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribePatchGroupStateError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DescribePatchGroupStateError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePatchGroupStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidNextToken" => crate::error::DescribePatchGroupStateError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribePatchGroupStateError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribePatchGroupStateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_patch_group_state_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePatchGroupStateOutput,
    crate::error::DescribePatchGroupStateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_patch_group_state_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_patch_group_state(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribePatchGroupStateError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_patch_properties_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePatchPropertiesOutput,
    crate::error::DescribePatchPropertiesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribePatchPropertiesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribePatchPropertiesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DescribePatchPropertiesError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePatchPropertiesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribePatchPropertiesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_patch_properties_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePatchPropertiesOutput,
    crate::error::DescribePatchPropertiesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_patch_properties_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_patch_properties(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribePatchPropertiesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_sessions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeSessionsOutput, crate::error::DescribeSessionsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeSessionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeSessionsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::DescribeSessionsError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeSessionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidFilterKey" => crate::error::DescribeSessionsError::InvalidFilterKey({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_filter_key::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeSessionsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidNextToken" => crate::error::DescribeSessionsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeSessionsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeSessionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_sessions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeSessionsOutput, crate::error::DescribeSessionsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_sessions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_sessions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeSessionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_ops_item_related_item_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateOpsItemRelatedItemOutput,
    crate::error::DisassociateOpsItemRelatedItemError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisassociateOpsItemRelatedItemError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DisassociateOpsItemRelatedItemError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DisassociateOpsItemRelatedItemError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateOpsItemRelatedItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsItemInvalidParameterException" => crate::error::DisassociateOpsItemRelatedItemError::OpsItemInvalidParameterException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_invalid_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateOpsItemRelatedItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsItemNotFoundException" => crate::error::DisassociateOpsItemRelatedItemError::OpsItemNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateOpsItemRelatedItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsItemRelatedItemAssociationNotFoundException" => crate::error::DisassociateOpsItemRelatedItemError::OpsItemRelatedItemAssociationNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_related_item_association_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_related_item_association_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateOpsItemRelatedItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DisassociateOpsItemRelatedItemError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_ops_item_related_item_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateOpsItemRelatedItemOutput,
    crate::error::DisassociateOpsItemRelatedItemError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::disassociate_ops_item_related_item_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_automation_execution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAutomationExecutionOutput,
    crate::error::GetAutomationExecutionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetAutomationExecutionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetAutomationExecutionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AutomationExecutionNotFoundException" => {
            crate::error::GetAutomationExecutionError::AutomationExecutionNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::automation_execution_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_execution_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetAutomationExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::GetAutomationExecutionError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetAutomationExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetAutomationExecutionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_automation_execution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAutomationExecutionOutput,
    crate::error::GetAutomationExecutionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_automation_execution_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_automation_execution(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetAutomationExecutionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_calendar_state_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetCalendarStateOutput, crate::error::GetCalendarStateError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetCalendarStateError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetCalendarStateError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::GetCalendarStateError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetCalendarStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDocument" => crate::error::GetCalendarStateError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetCalendarStateError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidDocumentType" => {
            crate::error::GetCalendarStateError::InvalidDocumentType({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_type_json_err(response.body().as_ref(), output).map_err(crate::error::GetCalendarStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "UnsupportedCalendarException" => {
            crate::error::GetCalendarStateError::UnsupportedCalendarException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unsupported_calendar_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_calendar_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCalendarStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetCalendarStateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_calendar_state_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetCalendarStateOutput, crate::error::GetCalendarStateError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_calendar_state_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_calendar_state(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetCalendarStateError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_command_invocation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCommandInvocationOutput,
    crate::error::GetCommandInvocationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetCommandInvocationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetCommandInvocationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::GetCommandInvocationError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommandInvocationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidCommandId" => crate::error::GetCommandInvocationError::InvalidCommandId({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_command_id::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_command_id_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetCommandInvocationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidInstanceId" => {
            crate::error::GetCommandInvocationError::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommandInvocationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidPluginName" => {
            crate::error::GetCommandInvocationError::InvalidPluginName({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_plugin_name::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_plugin_name_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommandInvocationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvocationDoesNotExist" => {
            crate::error::GetCommandInvocationError::InvocationDoesNotExist({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invocation_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invocation_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommandInvocationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetCommandInvocationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_command_invocation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCommandInvocationOutput,
    crate::error::GetCommandInvocationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_command_invocation_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_command_invocation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetCommandInvocationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_connection_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetConnectionStatusOutput,
    crate::error::GetConnectionStatusError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetConnectionStatusError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetConnectionStatusError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::GetConnectionStatusError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetConnectionStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetConnectionStatusError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_connection_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetConnectionStatusOutput,
    crate::error::GetConnectionStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_connection_status_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_connection_status(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetConnectionStatusError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_default_patch_baseline_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDefaultPatchBaselineOutput,
    crate::error::GetDefaultPatchBaselineError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetDefaultPatchBaselineError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetDefaultPatchBaselineError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::GetDefaultPatchBaselineError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetDefaultPatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetDefaultPatchBaselineError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_default_patch_baseline_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDefaultPatchBaselineOutput,
    crate::error::GetDefaultPatchBaselineError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_default_patch_baseline_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_default_patch_baseline(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetDefaultPatchBaselineError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_deployable_patch_snapshot_for_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDeployablePatchSnapshotForInstanceOutput,
    crate::error::GetDeployablePatchSnapshotForInstanceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetDeployablePatchSnapshotForInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::GetDeployablePatchSnapshotForInstanceError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetDeployablePatchSnapshotForInstanceError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetDeployablePatchSnapshotForInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "UnsupportedFeatureRequiredException" => crate::error::GetDeployablePatchSnapshotForInstanceError::UnsupportedFeatureRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_feature_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_feature_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDeployablePatchSnapshotForInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "UnsupportedOperatingSystem" => crate::error::GetDeployablePatchSnapshotForInstanceError::UnsupportedOperatingSystem({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_operating_system::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_operating_system_json_err(response.body().as_ref(), output).map_err(crate::error::GetDeployablePatchSnapshotForInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetDeployablePatchSnapshotForInstanceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_deployable_patch_snapshot_for_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDeployablePatchSnapshotForInstanceOutput,
    crate::error::GetDeployablePatchSnapshotForInstanceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_deployable_patch_snapshot_for_instance_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_deployable_patch_snapshot_for_instance(response.body().as_ref(), output).map_err(crate::error::GetDeployablePatchSnapshotForInstanceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_document_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDocumentOutput, crate::error::GetDocumentError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetDocumentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDocumentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::GetDocumentError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDocument" => crate::error::GetDocumentError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetDocumentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidDocumentVersion" => crate::error::GetDocumentError::InvalidDocumentVersion({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document_version::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::GetDocumentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetDocumentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_document_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDocumentOutput, crate::error::GetDocumentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_document_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_document(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetDocumentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_inventory_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetInventoryOutput, crate::error::GetInventoryError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetInventoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetInventoryError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::GetInventoryError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidAggregatorException" => {
            crate::error::GetInventoryError::InvalidAggregatorException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_aggregator_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_aggregator_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidFilter" => crate::error::GetInventoryError::InvalidFilter({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_filter::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetInventoryError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidInventoryGroupException" => {
            crate::error::GetInventoryError::InvalidInventoryGroupException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_inventory_group_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_inventory_group_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidNextToken" => crate::error::GetInventoryError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetInventoryError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidResultAttributeException" => {
            crate::error::GetInventoryError::InvalidResultAttributeException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_result_attribute_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_result_attribute_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidTypeNameException" => crate::error::GetInventoryError::InvalidTypeNameException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_type_name_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_type_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInventoryError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetInventoryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_inventory_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetInventoryOutput, crate::error::GetInventoryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_inventory_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_inventory(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetInventoryError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_inventory_schema_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetInventorySchemaOutput,
    crate::error::GetInventorySchemaError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetInventorySchemaError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetInventorySchemaError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::GetInventorySchemaError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetInventorySchemaError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidNextToken" => crate::error::GetInventorySchemaError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetInventorySchemaError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidTypeNameException" => {
            crate::error::GetInventorySchemaError::InvalidTypeNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_type_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_type_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInventorySchemaError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetInventorySchemaError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_inventory_schema_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetInventorySchemaOutput,
    crate::error::GetInventorySchemaError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_inventory_schema_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_inventory_schema(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetInventorySchemaError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetMaintenanceWindowOutput,
    crate::error::GetMaintenanceWindowError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetMaintenanceWindowError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetMaintenanceWindowError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => {
            crate::error::GetMaintenanceWindowError::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::GetMaintenanceWindowError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetMaintenanceWindowError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetMaintenanceWindowOutput,
    crate::error::GetMaintenanceWindowError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_maintenance_window_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_maintenance_window(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetMaintenanceWindowError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_execution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetMaintenanceWindowExecutionOutput,
    crate::error::GetMaintenanceWindowExecutionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetMaintenanceWindowExecutionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetMaintenanceWindowExecutionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => {
            crate::error::GetMaintenanceWindowExecutionError::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::GetMaintenanceWindowExecutionError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetMaintenanceWindowExecutionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_execution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetMaintenanceWindowExecutionOutput,
    crate::error::GetMaintenanceWindowExecutionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_maintenance_window_execution_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_get_maintenance_window_execution(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::GetMaintenanceWindowExecutionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_execution_task_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetMaintenanceWindowExecutionTaskOutput,
    crate::error::GetMaintenanceWindowExecutionTaskError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetMaintenanceWindowExecutionTaskError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetMaintenanceWindowExecutionTaskError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => {
            crate::error::GetMaintenanceWindowExecutionTaskError::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowExecutionTaskError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::GetMaintenanceWindowExecutionTaskError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowExecutionTaskError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetMaintenanceWindowExecutionTaskError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_execution_task_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetMaintenanceWindowExecutionTaskOutput,
    crate::error::GetMaintenanceWindowExecutionTaskError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_maintenance_window_execution_task_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_maintenance_window_execution_task(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowExecutionTaskError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_execution_task_invocation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetMaintenanceWindowExecutionTaskInvocationOutput,
    crate::error::GetMaintenanceWindowExecutionTaskInvocationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetMaintenanceWindowExecutionTaskInvocationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::GetMaintenanceWindowExecutionTaskInvocationError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => {
            crate::error::GetMaintenanceWindowExecutionTaskInvocationError::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowExecutionTaskInvocationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::GetMaintenanceWindowExecutionTaskInvocationError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowExecutionTaskInvocationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetMaintenanceWindowExecutionTaskInvocationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_execution_task_invocation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetMaintenanceWindowExecutionTaskInvocationOutput,
    crate::error::GetMaintenanceWindowExecutionTaskInvocationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_maintenance_window_execution_task_invocation_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_maintenance_window_execution_task_invocation(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowExecutionTaskInvocationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_task_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetMaintenanceWindowTaskOutput,
    crate::error::GetMaintenanceWindowTaskError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetMaintenanceWindowTaskError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetMaintenanceWindowTaskError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => {
            crate::error::GetMaintenanceWindowTaskError::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowTaskError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::GetMaintenanceWindowTaskError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowTaskError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetMaintenanceWindowTaskError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_task_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetMaintenanceWindowTaskOutput,
    crate::error::GetMaintenanceWindowTaskError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_maintenance_window_task_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_maintenance_window_task(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetMaintenanceWindowTaskError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ops_item_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetOpsItemOutput, crate::error::GetOpsItemError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetOpsItemError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetOpsItemError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::GetOpsItemError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsItemAccessDeniedException" => {
            crate::error::GetOpsItemError::OpsItemAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_item_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsItemNotFoundException" => crate::error::GetOpsItemError::OpsItemNotFoundException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::ops_item_not_found_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_ops_item_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsItemError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetOpsItemError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ops_item_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetOpsItemOutput, crate::error::GetOpsItemError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_ops_item_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_ops_item(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetOpsItemError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ops_metadata_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetOpsMetadataOutput, crate::error::GetOpsMetadataError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetOpsMetadataError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetOpsMetadataError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::GetOpsMetadataError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsMetadataInvalidArgumentException" => {
            crate::error::GetOpsMetadataError::OpsMetadataInvalidArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_metadata_invalid_argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_invalid_argument_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsMetadataNotFoundException" => {
            crate::error::GetOpsMetadataError::OpsMetadataNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_metadata_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetOpsMetadataError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ops_metadata_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetOpsMetadataOutput, crate::error::GetOpsMetadataError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_ops_metadata_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_ops_metadata(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetOpsMetadataError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ops_summary_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetOpsSummaryOutput, crate::error::GetOpsSummaryError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetOpsSummaryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetOpsSummaryError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::GetOpsSummaryError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsSummaryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidAggregatorException" => {
            crate::error::GetOpsSummaryError::InvalidAggregatorException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_aggregator_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_aggregator_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsSummaryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidFilter" => crate::error::GetOpsSummaryError::InvalidFilter({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_filter::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetOpsSummaryError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidNextToken" => crate::error::GetOpsSummaryError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetOpsSummaryError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidTypeNameException" => crate::error::GetOpsSummaryError::InvalidTypeNameException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_type_name_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_type_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsSummaryError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceDataSyncNotFoundException" => {
            crate::error::GetOpsSummaryError::ResourceDataSyncNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_data_sync_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_data_sync_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsSummaryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetOpsSummaryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ops_summary_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetOpsSummaryOutput, crate::error::GetOpsSummaryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_ops_summary_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_ops_summary(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetOpsSummaryError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_parameter_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetParameterOutput, crate::error::GetParameterError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetParameterError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetParameterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::GetParameterError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidKeyId" => crate::error::GetParameterError::InvalidKeyId({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_key_id::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_key_id_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetParameterError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ParameterNotFound" => {
            crate::error::GetParameterError::ParameterNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::GetParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ParameterVersionNotFound" => crate::error::GetParameterError::ParameterVersionNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::parameter_version_not_found::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_parameter_version_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::GetParameterError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetParameterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_parameter_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetParameterOutput, crate::error::GetParameterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_parameter_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_parameter(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetParameterError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_parameter_history_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetParameterHistoryOutput,
    crate::error::GetParameterHistoryError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetParameterHistoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetParameterHistoryError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::GetParameterHistoryError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetParameterHistoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidKeyId" => crate::error::GetParameterHistoryError::InvalidKeyId({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_key_id::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_key_id_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetParameterHistoryError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidNextToken" => crate::error::GetParameterHistoryError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetParameterHistoryError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ParameterNotFound" => {
            crate::error::GetParameterHistoryError::ParameterNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::GetParameterHistoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetParameterHistoryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_parameter_history_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetParameterHistoryOutput,
    crate::error::GetParameterHistoryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_parameter_history_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_parameter_history(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetParameterHistoryError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_parameters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetParametersOutput, crate::error::GetParametersError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetParametersError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetParametersError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::GetParametersError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetParametersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidKeyId" => crate::error::GetParametersError::InvalidKeyId({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_key_id::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_key_id_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetParametersError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetParametersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_parameters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetParametersOutput, crate::error::GetParametersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_parameters_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_parameters(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetParametersError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_parameters_by_path_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetParametersByPathOutput,
    crate::error::GetParametersByPathError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetParametersByPathError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetParametersByPathError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::GetParametersByPathError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetParametersByPathError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidFilterKey" => crate::error::GetParametersByPathError::InvalidFilterKey({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_filter_key::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetParametersByPathError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidFilterOption" => {
            crate::error::GetParametersByPathError::InvalidFilterOption({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_option::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_option_json_err(response.body().as_ref(), output).map_err(crate::error::GetParametersByPathError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidFilterValue" => {
            crate::error::GetParametersByPathError::InvalidFilterValue({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_value::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_value_json_err(response.body().as_ref(), output).map_err(crate::error::GetParametersByPathError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidKeyId" => crate::error::GetParametersByPathError::InvalidKeyId({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_key_id::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_key_id_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetParametersByPathError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidNextToken" => crate::error::GetParametersByPathError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetParametersByPathError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetParametersByPathError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_parameters_by_path_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetParametersByPathOutput,
    crate::error::GetParametersByPathError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_parameters_by_path_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_parameters_by_path(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetParametersByPathError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_patch_baseline_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetPatchBaselineOutput, crate::error::GetPatchBaselineError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetPatchBaselineError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetPatchBaselineError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::GetPatchBaselineError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::does_not_exist_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPatchBaselineError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InternalServerError" => {
            crate::error::GetPatchBaselineError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetPatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidResourceId" => {
            crate::error::GetPatchBaselineError::InvalidResourceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::GetPatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetPatchBaselineError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_patch_baseline_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetPatchBaselineOutput, crate::error::GetPatchBaselineError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_patch_baseline_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_patch_baseline(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetPatchBaselineError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_patch_baseline_for_patch_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetPatchBaselineForPatchGroupOutput,
    crate::error::GetPatchBaselineForPatchGroupError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetPatchBaselineForPatchGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetPatchBaselineForPatchGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::GetPatchBaselineForPatchGroupError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetPatchBaselineForPatchGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetPatchBaselineForPatchGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_patch_baseline_for_patch_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetPatchBaselineForPatchGroupOutput,
    crate::error::GetPatchBaselineForPatchGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_patch_baseline_for_patch_group_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_get_patch_baseline_for_patch_group(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::GetPatchBaselineForPatchGroupError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_resource_policies_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetResourcePoliciesOutput,
    crate::error::GetResourcePoliciesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetResourcePoliciesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetResourcePoliciesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::GetResourcePoliciesError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetResourcePoliciesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourcePolicyInvalidParameterException" => {
            crate::error::GetResourcePoliciesError::ResourcePolicyInvalidParameterException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_policy_invalid_parameter_exception::Builder::default(
                        );
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_policy_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetResourcePoliciesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetResourcePoliciesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_resource_policies_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetResourcePoliciesOutput,
    crate::error::GetResourcePoliciesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_resource_policies_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_resource_policies(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetResourcePoliciesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_service_setting_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetServiceSettingOutput, crate::error::GetServiceSettingError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetServiceSettingError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetServiceSettingError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::GetServiceSettingError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetServiceSettingError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceSettingNotFound" => crate::error::GetServiceSettingError::ServiceSettingNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_setting_not_found::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_setting_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::GetServiceSettingError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetServiceSettingError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_service_setting_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetServiceSettingOutput, crate::error::GetServiceSettingError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_service_setting_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_service_setting(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetServiceSettingError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_label_parameter_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::LabelParameterVersionOutput,
    crate::error::LabelParameterVersionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::LabelParameterVersionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::LabelParameterVersionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::LabelParameterVersionError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::LabelParameterVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ParameterNotFound" => {
            crate::error::LabelParameterVersionError::ParameterNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::LabelParameterVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ParameterVersionLabelLimitExceeded" => {
            crate::error::LabelParameterVersionError::ParameterVersionLabelLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::parameter_version_label_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_version_label_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::LabelParameterVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ParameterVersionNotFound" => {
            crate::error::LabelParameterVersionError::ParameterVersionNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_version_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_version_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::LabelParameterVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyUpdates" => crate::error::LabelParameterVersionError::TooManyUpdates({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_updates::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::LabelParameterVersionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::LabelParameterVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_label_parameter_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::LabelParameterVersionOutput,
    crate::error::LabelParameterVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::label_parameter_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_label_parameter_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::LabelParameterVersionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_associations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListAssociationsOutput, crate::error::ListAssociationsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListAssociationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListAssociationsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::ListAssociationsError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidNextToken" => crate::error::ListAssociationsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListAssociationsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListAssociationsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_associations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListAssociationsOutput, crate::error::ListAssociationsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_associations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_associations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListAssociationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_association_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListAssociationVersionsOutput,
    crate::error::ListAssociationVersionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListAssociationVersionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListAssociationVersionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AssociationDoesNotExist" => {
            crate::error::ListAssociationVersionsError::AssociationDoesNotExist({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociationVersionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::ListAssociationVersionsError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociationVersionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidNextToken" => crate::error::ListAssociationVersionsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListAssociationVersionsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListAssociationVersionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_association_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListAssociationVersionsOutput,
    crate::error::ListAssociationVersionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_association_versions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_association_versions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListAssociationVersionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_command_invocations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListCommandInvocationsOutput,
    crate::error::ListCommandInvocationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListCommandInvocationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListCommandInvocationsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::ListCommandInvocationsError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListCommandInvocationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidCommandId" => crate::error::ListCommandInvocationsError::InvalidCommandId({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_command_id::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_command_id_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListCommandInvocationsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidFilterKey" => crate::error::ListCommandInvocationsError::InvalidFilterKey({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_filter_key::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListCommandInvocationsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidInstanceId" => {
            crate::error::ListCommandInvocationsError::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::ListCommandInvocationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidNextToken" => crate::error::ListCommandInvocationsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListCommandInvocationsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListCommandInvocationsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_command_invocations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListCommandInvocationsOutput,
    crate::error::ListCommandInvocationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_command_invocations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_command_invocations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListCommandInvocationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_commands_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListCommandsOutput, crate::error::ListCommandsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListCommandsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListCommandsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::ListCommandsError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListCommandsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidCommandId" => crate::error::ListCommandsError::InvalidCommandId({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_command_id::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_command_id_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListCommandsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidFilterKey" => crate::error::ListCommandsError::InvalidFilterKey({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_filter_key::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListCommandsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidInstanceId" => {
            crate::error::ListCommandsError::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::ListCommandsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidNextToken" => crate::error::ListCommandsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListCommandsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListCommandsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_commands_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListCommandsOutput, crate::error::ListCommandsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_commands_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_commands(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListCommandsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_compliance_items_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListComplianceItemsOutput,
    crate::error::ListComplianceItemsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListComplianceItemsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListComplianceItemsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::ListComplianceItemsError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListComplianceItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidFilter" => crate::error::ListComplianceItemsError::InvalidFilter({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_filter::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListComplianceItemsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidNextToken" => crate::error::ListComplianceItemsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListComplianceItemsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidResourceId" => {
            crate::error::ListComplianceItemsError::InvalidResourceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::ListComplianceItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidResourceType" => {
            crate::error::ListComplianceItemsError::InvalidResourceType({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_type_json_err(response.body().as_ref(), output).map_err(crate::error::ListComplianceItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListComplianceItemsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_compliance_items_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListComplianceItemsOutput,
    crate::error::ListComplianceItemsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_compliance_items_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_compliance_items(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListComplianceItemsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_compliance_summaries_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListComplianceSummariesOutput,
    crate::error::ListComplianceSummariesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListComplianceSummariesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListComplianceSummariesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::ListComplianceSummariesError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListComplianceSummariesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidFilter" => crate::error::ListComplianceSummariesError::InvalidFilter({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_filter::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListComplianceSummariesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidNextToken" => crate::error::ListComplianceSummariesError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListComplianceSummariesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListComplianceSummariesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_compliance_summaries_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListComplianceSummariesOutput,
    crate::error::ListComplianceSummariesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_compliance_summaries_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_compliance_summaries(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListComplianceSummariesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_document_metadata_history_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDocumentMetadataHistoryOutput,
    crate::error::ListDocumentMetadataHistoryError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListDocumentMetadataHistoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListDocumentMetadataHistoryError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::ListDocumentMetadataHistoryError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListDocumentMetadataHistoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDocument" => crate::error::ListDocumentMetadataHistoryError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListDocumentMetadataHistoryError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidDocumentVersion" => {
            crate::error::ListDocumentMetadataHistoryError::InvalidDocumentVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::ListDocumentMetadataHistoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidNextToken" => crate::error::ListDocumentMetadataHistoryError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListDocumentMetadataHistoryError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListDocumentMetadataHistoryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_document_metadata_history_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDocumentMetadataHistoryOutput,
    crate::error::ListDocumentMetadataHistoryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_document_metadata_history_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_document_metadata_history(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListDocumentMetadataHistoryError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_documents_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListDocumentsOutput, crate::error::ListDocumentsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListDocumentsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListDocumentsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::ListDocumentsError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListDocumentsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidFilterKey" => crate::error::ListDocumentsError::InvalidFilterKey({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_filter_key::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListDocumentsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidNextToken" => crate::error::ListDocumentsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListDocumentsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListDocumentsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_documents_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListDocumentsOutput, crate::error::ListDocumentsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_documents_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_documents(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListDocumentsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_document_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDocumentVersionsOutput,
    crate::error::ListDocumentVersionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListDocumentVersionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListDocumentVersionsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::ListDocumentVersionsError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListDocumentVersionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDocument" => crate::error::ListDocumentVersionsError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListDocumentVersionsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidNextToken" => crate::error::ListDocumentVersionsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListDocumentVersionsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListDocumentVersionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_document_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDocumentVersionsOutput,
    crate::error::ListDocumentVersionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_document_versions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_document_versions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListDocumentVersionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_inventory_entries_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListInventoryEntriesOutput,
    crate::error::ListInventoryEntriesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListInventoryEntriesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListInventoryEntriesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::ListInventoryEntriesError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListInventoryEntriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidFilter" => crate::error::ListInventoryEntriesError::InvalidFilter({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_filter::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListInventoryEntriesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidInstanceId" => {
            crate::error::ListInventoryEntriesError::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::ListInventoryEntriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidNextToken" => crate::error::ListInventoryEntriesError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListInventoryEntriesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidTypeNameException" => {
            crate::error::ListInventoryEntriesError::InvalidTypeNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_type_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_type_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListInventoryEntriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListInventoryEntriesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_inventory_entries_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListInventoryEntriesOutput,
    crate::error::ListInventoryEntriesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_inventory_entries_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_inventory_entries(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListInventoryEntriesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_ops_item_events_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListOpsItemEventsOutput, crate::error::ListOpsItemEventsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListOpsItemEventsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListOpsItemEventsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::ListOpsItemEventsError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListOpsItemEventsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsItemInvalidParameterException" => {
            crate::error::ListOpsItemEventsError::OpsItemInvalidParameterException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_item_invalid_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOpsItemEventsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsItemLimitExceededException" => {
            crate::error::ListOpsItemEventsError::OpsItemLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_item_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOpsItemEventsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsItemNotFoundException" => {
            crate::error::ListOpsItemEventsError::OpsItemNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOpsItemEventsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListOpsItemEventsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_ops_item_events_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListOpsItemEventsOutput, crate::error::ListOpsItemEventsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_ops_item_events_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_ops_item_events(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListOpsItemEventsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_ops_item_related_items_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListOpsItemRelatedItemsOutput,
    crate::error::ListOpsItemRelatedItemsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListOpsItemRelatedItemsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListOpsItemRelatedItemsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::ListOpsItemRelatedItemsError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListOpsItemRelatedItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsItemInvalidParameterException" => {
            crate::error::ListOpsItemRelatedItemsError::OpsItemInvalidParameterException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_item_invalid_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOpsItemRelatedItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListOpsItemRelatedItemsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_ops_item_related_items_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListOpsItemRelatedItemsOutput,
    crate::error::ListOpsItemRelatedItemsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_ops_item_related_items_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_ops_item_related_items(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListOpsItemRelatedItemsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_ops_metadata_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListOpsMetadataOutput, crate::error::ListOpsMetadataError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListOpsMetadataError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListOpsMetadataError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::ListOpsMetadataError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsMetadataInvalidArgumentException" => {
            crate::error::ListOpsMetadataError::OpsMetadataInvalidArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_metadata_invalid_argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_invalid_argument_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListOpsMetadataError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_ops_metadata_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListOpsMetadataOutput, crate::error::ListOpsMetadataError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_ops_metadata_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_ops_metadata(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListOpsMetadataError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_resource_compliance_summaries_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListResourceComplianceSummariesOutput,
    crate::error::ListResourceComplianceSummariesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListResourceComplianceSummariesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListResourceComplianceSummariesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::ListResourceComplianceSummariesError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListResourceComplianceSummariesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidFilter" => crate::error::ListResourceComplianceSummariesError::InvalidFilter({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_filter::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListResourceComplianceSummariesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidNextToken" => {
            crate::error::ListResourceComplianceSummariesError::InvalidNextToken({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::ListResourceComplianceSummariesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListResourceComplianceSummariesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_resource_compliance_summaries_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListResourceComplianceSummariesOutput,
    crate::error::ListResourceComplianceSummariesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_resource_compliance_summaries_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_list_resource_compliance_summaries(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ListResourceComplianceSummariesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_resource_data_sync_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListResourceDataSyncOutput,
    crate::error::ListResourceDataSyncError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListResourceDataSyncError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListResourceDataSyncError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::ListResourceDataSyncError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListResourceDataSyncError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidNextToken" => crate::error::ListResourceDataSyncError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListResourceDataSyncError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceDataSyncInvalidConfigurationException" => {
            crate::error::ListResourceDataSyncError::ResourceDataSyncInvalidConfigurationException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                    let mut output = crate::error::resource_data_sync_invalid_configuration_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_resource_data_sync_invalid_configuration_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListResourceDataSyncError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        _ => crate::error::ListResourceDataSyncError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_resource_data_sync_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListResourceDataSyncOutput,
    crate::error::ListResourceDataSyncError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_resource_data_sync_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_resource_data_sync(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListResourceDataSyncError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTagsForResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::ListTagsForResourceError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidResourceId" => {
            crate::error::ListTagsForResourceError::InvalidResourceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidResourceType" => {
            crate::error::ListTagsForResourceError::InvalidResourceType({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_type_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListTagsForResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_tags_for_resource_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_tags_for_resource(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_document_permission_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDocumentPermissionOutput,
    crate::error::ModifyDocumentPermissionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyDocumentPermissionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyDocumentPermissionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DocumentLimitExceeded" => {
            crate::error::ModifyDocumentPermissionError::DocumentLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::document_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_document_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::ModifyDocumentPermissionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DocumentPermissionLimit" => {
            crate::error::ModifyDocumentPermissionError::DocumentPermissionLimit({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::document_permission_limit::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_document_permission_limit_json_err(response.body().as_ref(), output).map_err(crate::error::ModifyDocumentPermissionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::ModifyDocumentPermissionError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ModifyDocumentPermissionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDocument" => crate::error::ModifyDocumentPermissionError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ModifyDocumentPermissionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidPermissionType" => {
            crate::error::ModifyDocumentPermissionError::InvalidPermissionType({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_permission_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_permission_type_json_err(response.body().as_ref(), output).map_err(crate::error::ModifyDocumentPermissionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ModifyDocumentPermissionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_document_permission_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDocumentPermissionOutput,
    crate::error::ModifyDocumentPermissionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_document_permission_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_compliance_items_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutComplianceItemsOutput,
    crate::error::PutComplianceItemsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::PutComplianceItemsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutComplianceItemsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ComplianceTypeCountLimitExceededException" => {
            crate::error::PutComplianceItemsError::ComplianceTypeCountLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::compliance_type_count_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_compliance_type_count_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutComplianceItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::PutComplianceItemsError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::PutComplianceItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidItemContentException" => {
            crate::error::PutComplianceItemsError::InvalidItemContentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_item_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_item_content_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutComplianceItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidResourceId" => {
            crate::error::PutComplianceItemsError::InvalidResourceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::PutComplianceItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidResourceType" => {
            crate::error::PutComplianceItemsError::InvalidResourceType({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_type_json_err(response.body().as_ref(), output).map_err(crate::error::PutComplianceItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ItemSizeLimitExceededException" => {
            crate::error::PutComplianceItemsError::ItemSizeLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::item_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_item_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutComplianceItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TotalSizeLimitExceededException" => {
            crate::error::PutComplianceItemsError::TotalSizeLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::total_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_total_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutComplianceItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::PutComplianceItemsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_compliance_items_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutComplianceItemsOutput,
    crate::error::PutComplianceItemsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_compliance_items_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_inventory_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutInventoryOutput, crate::error::PutInventoryError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::PutInventoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutInventoryError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CustomSchemaCountLimitExceededException" => {
            crate::error::PutInventoryError::CustomSchemaCountLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::custom_schema_count_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_custom_schema_count_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::PutInventoryError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidInstanceId" => {
            crate::error::PutInventoryError::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidInventoryItemContextException" => {
            crate::error::PutInventoryError::InvalidInventoryItemContextException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_inventory_item_context_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_inventory_item_context_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidItemContentException" => {
            crate::error::PutInventoryError::InvalidItemContentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_item_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_item_content_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidTypeNameException" => crate::error::PutInventoryError::InvalidTypeNameException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_type_name_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_type_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ItemContentMismatchException" => {
            crate::error::PutInventoryError::ItemContentMismatchException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::item_content_mismatch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_item_content_mismatch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ItemSizeLimitExceededException" => {
            crate::error::PutInventoryError::ItemSizeLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::item_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_item_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "SubTypeCountLimitExceededException" => {
            crate::error::PutInventoryError::SubTypeCountLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::sub_type_count_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_sub_type_count_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TotalSizeLimitExceededException" => {
            crate::error::PutInventoryError::TotalSizeLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::total_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_total_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "UnsupportedInventoryItemContextException" => {
            crate::error::PutInventoryError::UnsupportedInventoryItemContextException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_inventory_item_context_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_inventory_item_context_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "UnsupportedInventorySchemaVersionException" => {
            crate::error::PutInventoryError::UnsupportedInventorySchemaVersionException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_inventory_schema_version_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_inventory_schema_version_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::PutInventoryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_inventory_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutInventoryOutput, crate::error::PutInventoryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_inventory_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_inventory(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutInventoryError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_parameter_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutParameterOutput, crate::error::PutParameterError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::PutParameterError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutParameterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "HierarchyLevelLimitExceededException" => {
            crate::error::PutParameterError::HierarchyLevelLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::hierarchy_level_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_hierarchy_level_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "HierarchyTypeMismatchException" => {
            crate::error::PutParameterError::HierarchyTypeMismatchException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::hierarchy_type_mismatch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_hierarchy_type_mismatch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "IncompatiblePolicyException" => {
            crate::error::PutParameterError::IncompatiblePolicyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::incompatible_policy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_incompatible_policy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::PutParameterError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidAllowedPatternException" => {
            crate::error::PutParameterError::InvalidAllowedPatternException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_allowed_pattern_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_allowed_pattern_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidKeyId" => crate::error::PutParameterError::InvalidKeyId({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_key_id::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_key_id_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutParameterError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidPolicyAttributeException" => {
            crate::error::PutParameterError::InvalidPolicyAttributeException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_policy_attribute_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_policy_attribute_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidPolicyTypeException" => {
            crate::error::PutParameterError::InvalidPolicyTypeException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_policy_type_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_policy_type_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ParameterAlreadyExists" => crate::error::PutParameterError::ParameterAlreadyExists({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::parameter_already_exists::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_parameter_already_exists_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ParameterLimitExceeded" => crate::error::PutParameterError::ParameterLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::parameter_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_parameter_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ParameterMaxVersionLimitExceeded" => {
            crate::error::PutParameterError::ParameterMaxVersionLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::parameter_max_version_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_max_version_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ParameterPatternMismatchException" => {
            crate::error::PutParameterError::ParameterPatternMismatchException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::parameter_pattern_mismatch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_pattern_mismatch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PoliciesLimitExceededException" => {
            crate::error::PutParameterError::PoliciesLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::policies_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_policies_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyUpdates" => crate::error::PutParameterError::TooManyUpdates({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_updates::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutParameterError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "UnsupportedParameterType" => crate::error::PutParameterError::UnsupportedParameterType({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::unsupported_parameter_type::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_unsupported_parameter_type_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::PutParameterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_parameter_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutParameterOutput, crate::error::PutParameterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_parameter_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_parameter(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutParameterError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_resource_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutResourcePolicyOutput, crate::error::PutResourcePolicyError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::PutResourcePolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutResourcePolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::PutResourcePolicyError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::PutResourcePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourcePolicyConflictException" => {
            crate::error::PutResourcePolicyError::ResourcePolicyConflictException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_policy_conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_policy_conflict_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutResourcePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourcePolicyInvalidParameterException" => {
            crate::error::PutResourcePolicyError::ResourcePolicyInvalidParameterException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_policy_invalid_parameter_exception::Builder::default(
                        );
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_policy_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutResourcePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourcePolicyLimitExceededException" => {
            crate::error::PutResourcePolicyError::ResourcePolicyLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_policy_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_policy_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutResourcePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::PutResourcePolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_resource_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutResourcePolicyOutput, crate::error::PutResourcePolicyError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_resource_policy_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_resource_policy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutResourcePolicyError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_default_patch_baseline_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RegisterDefaultPatchBaselineOutput,
    crate::error::RegisterDefaultPatchBaselineError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RegisterDefaultPatchBaselineError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RegisterDefaultPatchBaselineError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => {
            crate::error::RegisterDefaultPatchBaselineError::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterDefaultPatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::RegisterDefaultPatchBaselineError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterDefaultPatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidResourceId" => {
            crate::error::RegisterDefaultPatchBaselineError::InvalidResourceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterDefaultPatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::RegisterDefaultPatchBaselineError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_default_patch_baseline_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RegisterDefaultPatchBaselineOutput,
    crate::error::RegisterDefaultPatchBaselineError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::register_default_patch_baseline_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_register_default_patch_baseline(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::RegisterDefaultPatchBaselineError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_patch_baseline_for_patch_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RegisterPatchBaselineForPatchGroupOutput,
    crate::error::RegisterPatchBaselineForPatchGroupError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RegisterPatchBaselineForPatchGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RegisterPatchBaselineForPatchGroupError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AlreadyExistsException" => {
            crate::error::RegisterPatchBaselineForPatchGroupError::AlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterPatchBaselineForPatchGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DoesNotExistException" => {
            crate::error::RegisterPatchBaselineForPatchGroupError::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterPatchBaselineForPatchGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::RegisterPatchBaselineForPatchGroupError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterPatchBaselineForPatchGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidResourceId" => {
            crate::error::RegisterPatchBaselineForPatchGroupError::InvalidResourceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterPatchBaselineForPatchGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourceLimitExceededException" => {
            crate::error::RegisterPatchBaselineForPatchGroupError::ResourceLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterPatchBaselineForPatchGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::RegisterPatchBaselineForPatchGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_patch_baseline_for_patch_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RegisterPatchBaselineForPatchGroupOutput,
    crate::error::RegisterPatchBaselineForPatchGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::register_patch_baseline_for_patch_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_register_patch_baseline_for_patch_group(response.body().as_ref(), output).map_err(crate::error::RegisterPatchBaselineForPatchGroupError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_target_with_maintenance_window_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RegisterTargetWithMaintenanceWindowOutput,
    crate::error::RegisterTargetWithMaintenanceWindowError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RegisterTargetWithMaintenanceWindowError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RegisterTargetWithMaintenanceWindowError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => {
            crate::error::RegisterTargetWithMaintenanceWindowError::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTargetWithMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "IdempotentParameterMismatch" => {
            crate::error::RegisterTargetWithMaintenanceWindowError::IdempotentParameterMismatch({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::idempotent_parameter_mismatch::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotent_parameter_mismatch_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTargetWithMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::RegisterTargetWithMaintenanceWindowError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTargetWithMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourceLimitExceededException" => {
            crate::error::RegisterTargetWithMaintenanceWindowError::ResourceLimitExceededException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_limit_exceeded_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTargetWithMaintenanceWindowError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        _ => crate::error::RegisterTargetWithMaintenanceWindowError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_target_with_maintenance_window_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RegisterTargetWithMaintenanceWindowOutput,
    crate::error::RegisterTargetWithMaintenanceWindowError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::register_target_with_maintenance_window_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_register_target_with_maintenance_window(response.body().as_ref(), output).map_err(crate::error::RegisterTargetWithMaintenanceWindowError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_task_with_maintenance_window_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RegisterTaskWithMaintenanceWindowOutput,
    crate::error::RegisterTaskWithMaintenanceWindowError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RegisterTaskWithMaintenanceWindowError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RegisterTaskWithMaintenanceWindowError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => {
            crate::error::RegisterTaskWithMaintenanceWindowError::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTaskWithMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "FeatureNotAvailableException" => {
            crate::error::RegisterTaskWithMaintenanceWindowError::FeatureNotAvailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::feature_not_available_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_feature_not_available_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTaskWithMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "IdempotentParameterMismatch" => {
            crate::error::RegisterTaskWithMaintenanceWindowError::IdempotentParameterMismatch({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::idempotent_parameter_mismatch::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotent_parameter_mismatch_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTaskWithMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::RegisterTaskWithMaintenanceWindowError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTaskWithMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourceLimitExceededException" => {
            crate::error::RegisterTaskWithMaintenanceWindowError::ResourceLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTaskWithMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::RegisterTaskWithMaintenanceWindowError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_task_with_maintenance_window_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RegisterTaskWithMaintenanceWindowOutput,
    crate::error::RegisterTaskWithMaintenanceWindowError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::register_task_with_maintenance_window_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_register_task_with_maintenance_window(response.body().as_ref(), output).map_err(crate::error::RegisterTaskWithMaintenanceWindowError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_tags_from_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveTagsFromResourceOutput,
    crate::error::RemoveTagsFromResourceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RemoveTagsFromResourceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::RemoveTagsFromResourceError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidResourceId" => {
            crate::error::RemoveTagsFromResourceError::InvalidResourceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidResourceType" => {
            crate::error::RemoveTagsFromResourceError::InvalidResourceType({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_type_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyUpdates" => crate::error::RemoveTagsFromResourceError::TooManyUpdates({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_updates::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::RemoveTagsFromResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_tags_from_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveTagsFromResourceOutput,
    crate::error::RemoveTagsFromResourceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_tags_from_resource_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_service_setting_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetServiceSettingOutput,
    crate::error::ResetServiceSettingError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ResetServiceSettingError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ResetServiceSettingError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::ResetServiceSettingError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ResetServiceSettingError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceSettingNotFound" => {
            crate::error::ResetServiceSettingError::ServiceSettingNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_setting_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_setting_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::ResetServiceSettingError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyUpdates" => crate::error::ResetServiceSettingError::TooManyUpdates({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_updates::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ResetServiceSettingError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ResetServiceSettingError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_service_setting_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetServiceSettingOutput,
    crate::error::ResetServiceSettingError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reset_service_setting_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_reset_service_setting(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ResetServiceSettingError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_resume_session_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ResumeSessionOutput, crate::error::ResumeSessionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ResumeSessionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ResumeSessionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::ResumeSessionError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::does_not_exist_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ResumeSessionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InternalServerError" => {
            crate::error::ResumeSessionError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ResumeSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ResumeSessionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_resume_session_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ResumeSessionOutput, crate::error::ResumeSessionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::resume_session_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_resume_session(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ResumeSessionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_automation_signal_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SendAutomationSignalOutput,
    crate::error::SendAutomationSignalError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::SendAutomationSignalError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::SendAutomationSignalError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AutomationExecutionNotFoundException" => {
            crate::error::SendAutomationSignalError::AutomationExecutionNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::automation_execution_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_execution_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SendAutomationSignalError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "AutomationStepNotFoundException" => {
            crate::error::SendAutomationSignalError::AutomationStepNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::automation_step_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_step_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SendAutomationSignalError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::SendAutomationSignalError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::SendAutomationSignalError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidAutomationSignalException" => {
            crate::error::SendAutomationSignalError::InvalidAutomationSignalException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_automation_signal_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_automation_signal_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SendAutomationSignalError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::SendAutomationSignalError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_automation_signal_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SendAutomationSignalOutput,
    crate::error::SendAutomationSignalError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::send_automation_signal_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_command_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SendCommandOutput, crate::error::SendCommandError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::SendCommandError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::SendCommandError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DuplicateInstanceId" => {
            crate::error::SendCommandError::DuplicateInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::duplicate_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_duplicate_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::SendCommandError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDocument" => crate::error::SendCommandError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::SendCommandError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidDocumentVersion" => crate::error::SendCommandError::InvalidDocumentVersion({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document_version::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidInstanceId" => {
            crate::error::SendCommandError::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidNotificationConfig" => crate::error::SendCommandError::InvalidNotificationConfig({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_notification_config::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_notification_config_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidOutputFolder" => {
            crate::error::SendCommandError::InvalidOutputFolder({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_output_folder::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_output_folder_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidParameters" => crate::error::SendCommandError::InvalidParameters({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameters::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_parameters_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::SendCommandError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidRole" => crate::error::SendCommandError::InvalidRole({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_role::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_role_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::SendCommandError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "MaxDocumentSizeExceeded" => crate::error::SendCommandError::MaxDocumentSizeExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::max_document_size_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_max_document_size_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "UnsupportedPlatformType" => crate::error::SendCommandError::UnsupportedPlatformType({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::unsupported_platform_type::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_unsupported_platform_type_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::SendCommandError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_command_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SendCommandOutput, crate::error::SendCommandError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::send_command_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_send_command(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::SendCommandError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_associations_once_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartAssociationsOnceOutput,
    crate::error::StartAssociationsOnceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StartAssociationsOnceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StartAssociationsOnceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AssociationDoesNotExist" => {
            crate::error::StartAssociationsOnceError::AssociationDoesNotExist({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::StartAssociationsOnceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidAssociation" => {
            crate::error::StartAssociationsOnceError::InvalidAssociation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_association::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_association_json_err(response.body().as_ref(), output).map_err(crate::error::StartAssociationsOnceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::StartAssociationsOnceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_associations_once_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartAssociationsOnceOutput,
    crate::error::StartAssociationsOnceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_associations_once_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_automation_execution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartAutomationExecutionOutput,
    crate::error::StartAutomationExecutionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StartAutomationExecutionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::StartAutomationExecutionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AutomationDefinitionNotFoundException" => crate::error::StartAutomationExecutionError::AutomationDefinitionNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::automation_definition_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_definition_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartAutomationExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "AutomationDefinitionVersionNotFoundException" => crate::error::StartAutomationExecutionError::AutomationDefinitionVersionNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::automation_definition_version_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_definition_version_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartAutomationExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "AutomationExecutionLimitExceededException" => crate::error::StartAutomationExecutionError::AutomationExecutionLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::automation_execution_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_execution_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartAutomationExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "IdempotentParameterMismatch" => crate::error::StartAutomationExecutionError::IdempotentParameterMismatch({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::idempotent_parameter_mismatch::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotent_parameter_mismatch_json_err(response.body().as_ref(), output).map_err(crate::error::StartAutomationExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::StartAutomationExecutionError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::StartAutomationExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidAutomationExecutionParametersException" => crate::error::StartAutomationExecutionError::InvalidAutomationExecutionParametersException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_automation_execution_parameters_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_automation_execution_parameters_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartAutomationExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidTarget" => crate::error::StartAutomationExecutionError::InvalidTarget({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_target::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_target_json_err(response.body().as_ref(), output).map_err(crate::error::StartAutomationExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::StartAutomationExecutionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_automation_execution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartAutomationExecutionOutput,
    crate::error::StartAutomationExecutionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_automation_execution_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_start_automation_execution(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StartAutomationExecutionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_change_request_execution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartChangeRequestExecutionOutput,
    crate::error::StartChangeRequestExecutionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::StartChangeRequestExecutionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AutomationDefinitionNotApprovedException" => crate::error::StartChangeRequestExecutionError::AutomationDefinitionNotApprovedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::automation_definition_not_approved_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_definition_not_approved_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "AutomationDefinitionNotFoundException" => crate::error::StartChangeRequestExecutionError::AutomationDefinitionNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::automation_definition_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_definition_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "AutomationDefinitionVersionNotFoundException" => crate::error::StartChangeRequestExecutionError::AutomationDefinitionVersionNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::automation_definition_version_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_definition_version_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "AutomationExecutionLimitExceededException" => crate::error::StartChangeRequestExecutionError::AutomationExecutionLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::automation_execution_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_execution_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "IdempotentParameterMismatch" => crate::error::StartChangeRequestExecutionError::IdempotentParameterMismatch({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::idempotent_parameter_mismatch::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotent_parameter_mismatch_json_err(response.body().as_ref(), output).map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::StartChangeRequestExecutionError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidAutomationExecutionParametersException" => crate::error::StartChangeRequestExecutionError::InvalidAutomationExecutionParametersException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_automation_execution_parameters_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_automation_execution_parameters_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::StartChangeRequestExecutionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_change_request_execution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartChangeRequestExecutionOutput,
    crate::error::StartChangeRequestExecutionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_change_request_execution_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_start_change_request_execution(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_session_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StartSessionOutput, crate::error::StartSessionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StartSessionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StartSessionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::StartSessionError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::StartSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDocument" => crate::error::StartSessionError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::StartSessionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "TargetNotConnected" => {
            crate::error::StartSessionError::TargetNotConnected({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::target_not_connected::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_target_not_connected_json_err(response.body().as_ref(), output).map_err(crate::error::StartSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::StartSessionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_session_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StartSessionOutput, crate::error::StartSessionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_session_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_start_session(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StartSessionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_automation_execution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopAutomationExecutionOutput,
    crate::error::StopAutomationExecutionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StopAutomationExecutionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::StopAutomationExecutionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AutomationExecutionNotFoundException" => {
            crate::error::StopAutomationExecutionError::AutomationExecutionNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::automation_execution_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_execution_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopAutomationExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::StopAutomationExecutionError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::StopAutomationExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidAutomationStatusUpdateException" => {
            crate::error::StopAutomationExecutionError::InvalidAutomationStatusUpdateException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_automation_status_update_exception::Builder::default(
                        );
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_automation_status_update_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopAutomationExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::StopAutomationExecutionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_automation_execution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopAutomationExecutionOutput,
    crate::error::StopAutomationExecutionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_automation_execution_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_terminate_session_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TerminateSessionOutput, crate::error::TerminateSessionError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::TerminateSessionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TerminateSessionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::TerminateSessionError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::TerminateSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::TerminateSessionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_terminate_session_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TerminateSessionOutput, crate::error::TerminateSessionError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::terminate_session_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_terminate_session(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::TerminateSessionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_unlabel_parameter_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UnlabelParameterVersionOutput,
    crate::error::UnlabelParameterVersionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UnlabelParameterVersionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UnlabelParameterVersionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::UnlabelParameterVersionError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UnlabelParameterVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ParameterNotFound" => {
            crate::error::UnlabelParameterVersionError::ParameterNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::UnlabelParameterVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ParameterVersionNotFound" => {
            crate::error::UnlabelParameterVersionError::ParameterVersionNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_version_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_version_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::UnlabelParameterVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyUpdates" => crate::error::UnlabelParameterVersionError::TooManyUpdates({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_updates::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UnlabelParameterVersionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UnlabelParameterVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_unlabel_parameter_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UnlabelParameterVersionOutput,
    crate::error::UnlabelParameterVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::unlabel_parameter_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_unlabel_parameter_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UnlabelParameterVersionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_association_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateAssociationOutput, crate::error::UpdateAssociationError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateAssociationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateAssociationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AssociationDoesNotExist" => {
            crate::error::UpdateAssociationError::AssociationDoesNotExist({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "AssociationVersionLimitExceeded" => {
            crate::error::UpdateAssociationError::AssociationVersionLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::association_version_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_version_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::UpdateAssociationError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidAssociationVersion" => {
            crate::error::UpdateAssociationError::InvalidAssociationVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_association_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_association_version_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDocument" => crate::error::UpdateAssociationError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateAssociationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidDocumentVersion" => crate::error::UpdateAssociationError::InvalidDocumentVersion({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document_version::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidOutputLocation" => crate::error::UpdateAssociationError::InvalidOutputLocation({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_output_location::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_output_location_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidParameters" => crate::error::UpdateAssociationError::InvalidParameters({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameters::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_invalid_parameters_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateAssociationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidSchedule" => crate::error::UpdateAssociationError::InvalidSchedule({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_schedule::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_schedule_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateAssociationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidTarget" => crate::error::UpdateAssociationError::InvalidTarget({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_target::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_target_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateAssociationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidTargetMaps" => {
            crate::error::UpdateAssociationError::InvalidTargetMaps({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_target_maps::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_target_maps_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidUpdate" => crate::error::UpdateAssociationError::InvalidUpdate({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_update::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_update_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateAssociationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "TooManyUpdates" => crate::error::UpdateAssociationError::TooManyUpdates({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_updates::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateAssociationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateAssociationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_association_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateAssociationOutput, crate::error::UpdateAssociationError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_association_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_association(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateAssociationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_association_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateAssociationStatusOutput,
    crate::error::UpdateAssociationStatusError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateAssociationStatusError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateAssociationStatusError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AssociationDoesNotExist" => {
            crate::error::UpdateAssociationStatusError::AssociationDoesNotExist({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::UpdateAssociationStatusError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDocument" => crate::error::UpdateAssociationStatusError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateAssociationStatusError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidInstanceId" => {
            crate::error::UpdateAssociationStatusError::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "StatusUnchanged" => crate::error::UpdateAssociationStatusError::StatusUnchanged({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::status_unchanged::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_status_unchanged_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateAssociationStatusError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "TooManyUpdates" => crate::error::UpdateAssociationStatusError::TooManyUpdates({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_updates::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateAssociationStatusError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateAssociationStatusError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_association_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateAssociationStatusOutput,
    crate::error::UpdateAssociationStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_association_status_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_association_status(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateAssociationStatusError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_document_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateDocumentOutput, crate::error::UpdateDocumentError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateDocumentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateDocumentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DocumentVersionLimitExceeded" => {
            crate::error::UpdateDocumentError::DocumentVersionLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::document_version_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_document_version_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DuplicateDocumentContent" => {
            crate::error::UpdateDocumentError::DuplicateDocumentContent({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::duplicate_document_content::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_duplicate_document_content_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DuplicateDocumentVersionName" => {
            crate::error::UpdateDocumentError::DuplicateDocumentVersionName({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::duplicate_document_version_name::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_duplicate_document_version_name_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::UpdateDocumentError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDocument" => crate::error::UpdateDocumentError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateDocumentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidDocumentContent" => crate::error::UpdateDocumentError::InvalidDocumentContent({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document_content::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_content_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidDocumentOperation" => {
            crate::error::UpdateDocumentError::InvalidDocumentOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_operation::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_operation_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDocumentSchemaVersion" => {
            crate::error::UpdateDocumentError::InvalidDocumentSchemaVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_document_schema_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_schema_version_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDocumentVersion" => crate::error::UpdateDocumentError::InvalidDocumentVersion({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document_version::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "MaxDocumentSizeExceeded" => crate::error::UpdateDocumentError::MaxDocumentSizeExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::max_document_size_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_max_document_size_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateDocumentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_document_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateDocumentOutput, crate::error::UpdateDocumentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_document_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_document(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateDocumentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_document_default_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDocumentDefaultVersionOutput,
    crate::error::UpdateDocumentDefaultVersionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateDocumentDefaultVersionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateDocumentDefaultVersionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::UpdateDocumentDefaultVersionError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentDefaultVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDocument" => crate::error::UpdateDocumentDefaultVersionError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateDocumentDefaultVersionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidDocumentSchemaVersion" => {
            crate::error::UpdateDocumentDefaultVersionError::InvalidDocumentSchemaVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_document_schema_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_schema_version_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentDefaultVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDocumentVersion" => {
            crate::error::UpdateDocumentDefaultVersionError::InvalidDocumentVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentDefaultVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateDocumentDefaultVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_document_default_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDocumentDefaultVersionOutput,
    crate::error::UpdateDocumentDefaultVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_document_default_version_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_update_document_default_version(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::UpdateDocumentDefaultVersionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_document_metadata_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDocumentMetadataOutput,
    crate::error::UpdateDocumentMetadataError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateDocumentMetadataError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateDocumentMetadataError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::UpdateDocumentMetadataError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDocument" => crate::error::UpdateDocumentMetadataError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_document::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateDocumentMetadataError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidDocumentOperation" => {
            crate::error::UpdateDocumentMetadataError::InvalidDocumentOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_operation::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_operation_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDocumentVersion" => {
            crate::error::UpdateDocumentMetadataError::InvalidDocumentVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateDocumentMetadataError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_document_metadata_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDocumentMetadataOutput,
    crate::error::UpdateDocumentMetadataError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_document_metadata_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_maintenance_window_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateMaintenanceWindowOutput,
    crate::error::UpdateMaintenanceWindowError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateMaintenanceWindowError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateMaintenanceWindowError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => {
            crate::error::UpdateMaintenanceWindowError::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::UpdateMaintenanceWindowError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateMaintenanceWindowError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_maintenance_window_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateMaintenanceWindowOutput,
    crate::error::UpdateMaintenanceWindowError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_maintenance_window_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_maintenance_window(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateMaintenanceWindowError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_maintenance_window_target_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateMaintenanceWindowTargetOutput,
    crate::error::UpdateMaintenanceWindowTargetError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateMaintenanceWindowTargetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateMaintenanceWindowTargetError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => {
            crate::error::UpdateMaintenanceWindowTargetError::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateMaintenanceWindowTargetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::UpdateMaintenanceWindowTargetError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateMaintenanceWindowTargetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateMaintenanceWindowTargetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_maintenance_window_target_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateMaintenanceWindowTargetOutput,
    crate::error::UpdateMaintenanceWindowTargetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_maintenance_window_target_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_update_maintenance_window_target(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::UpdateMaintenanceWindowTargetError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_maintenance_window_task_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateMaintenanceWindowTaskOutput,
    crate::error::UpdateMaintenanceWindowTaskError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateMaintenanceWindowTaskError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateMaintenanceWindowTaskError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => {
            crate::error::UpdateMaintenanceWindowTaskError::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateMaintenanceWindowTaskError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServerError" => {
            crate::error::UpdateMaintenanceWindowTaskError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateMaintenanceWindowTaskError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateMaintenanceWindowTaskError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_maintenance_window_task_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateMaintenanceWindowTaskOutput,
    crate::error::UpdateMaintenanceWindowTaskError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_maintenance_window_task_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_maintenance_window_task(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateMaintenanceWindowTaskError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_managed_instance_role_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateManagedInstanceRoleOutput,
    crate::error::UpdateManagedInstanceRoleError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateManagedInstanceRoleError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateManagedInstanceRoleError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::UpdateManagedInstanceRoleError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateManagedInstanceRoleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidInstanceId" => {
            crate::error::UpdateManagedInstanceRoleError::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateManagedInstanceRoleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateManagedInstanceRoleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_managed_instance_role_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateManagedInstanceRoleOutput,
    crate::error::UpdateManagedInstanceRoleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_managed_instance_role_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_ops_item_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateOpsItemOutput, crate::error::UpdateOpsItemError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateOpsItemError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateOpsItemError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::UpdateOpsItemError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsItemAccessDeniedException" => {
            crate::error::UpdateOpsItemError::OpsItemAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_item_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsItemAlreadyExistsException" => {
            crate::error::UpdateOpsItemError::OpsItemAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_item_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsItemInvalidParameterException" => {
            crate::error::UpdateOpsItemError::OpsItemInvalidParameterException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_item_invalid_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsItemLimitExceededException" => {
            crate::error::UpdateOpsItemError::OpsItemLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_item_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsItemNotFoundException" => crate::error::UpdateOpsItemError::OpsItemNotFoundException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::ops_item_not_found_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_ops_item_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsItemError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateOpsItemError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_ops_item_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateOpsItemOutput, crate::error::UpdateOpsItemError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_ops_item_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_ops_metadata_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateOpsMetadataOutput, crate::error::UpdateOpsMetadataError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateOpsMetadataError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateOpsMetadataError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::UpdateOpsMetadataError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsMetadataInvalidArgumentException" => {
            crate::error::UpdateOpsMetadataError::OpsMetadataInvalidArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_metadata_invalid_argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_invalid_argument_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsMetadataKeyLimitExceededException" => {
            crate::error::UpdateOpsMetadataError::OpsMetadataKeyLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_metadata_key_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_key_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsMetadataNotFoundException" => {
            crate::error::UpdateOpsMetadataError::OpsMetadataNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_metadata_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OpsMetadataTooManyUpdatesException" => {
            crate::error::UpdateOpsMetadataError::OpsMetadataTooManyUpdatesException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_metadata_too_many_updates_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_too_many_updates_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateOpsMetadataError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_ops_metadata_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateOpsMetadataOutput, crate::error::UpdateOpsMetadataError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_ops_metadata_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_ops_metadata(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateOpsMetadataError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_patch_baseline_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePatchBaselineOutput,
    crate::error::UpdatePatchBaselineError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdatePatchBaselineError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdatePatchBaselineError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::UpdatePatchBaselineError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::does_not_exist_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePatchBaselineError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InternalServerError" => {
            crate::error::UpdatePatchBaselineError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdatePatchBaselineError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_patch_baseline_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePatchBaselineOutput,
    crate::error::UpdatePatchBaselineError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_patch_baseline_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_patch_baseline(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdatePatchBaselineError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_resource_data_sync_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateResourceDataSyncOutput,
    crate::error::UpdateResourceDataSyncError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateResourceDataSyncError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateResourceDataSyncError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::UpdateResourceDataSyncError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateResourceDataSyncError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourceDataSyncConflictException" => {
            crate::error::UpdateResourceDataSyncError::ResourceDataSyncConflictException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_data_sync_conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_data_sync_conflict_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateResourceDataSyncError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourceDataSyncInvalidConfigurationException" => {
            crate::error::UpdateResourceDataSyncError::ResourceDataSyncInvalidConfigurationException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                    let mut output = crate::error::resource_data_sync_invalid_configuration_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_resource_data_sync_invalid_configuration_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateResourceDataSyncError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        "ResourceDataSyncNotFoundException" => {
            crate::error::UpdateResourceDataSyncError::ResourceDataSyncNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_data_sync_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_data_sync_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateResourceDataSyncError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateResourceDataSyncError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_resource_data_sync_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateResourceDataSyncOutput,
    crate::error::UpdateResourceDataSyncError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_resource_data_sync_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_service_setting_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateServiceSettingOutput,
    crate::error::UpdateServiceSettingError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateServiceSettingError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateServiceSettingError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => {
            crate::error::UpdateServiceSettingError::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateServiceSettingError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceSettingNotFound" => {
            crate::error::UpdateServiceSettingError::ServiceSettingNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_setting_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_setting_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateServiceSettingError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyUpdates" => crate::error::UpdateServiceSettingError::TooManyUpdates({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_updates::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateServiceSettingError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateServiceSettingError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_service_setting_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateServiceSettingOutput,
    crate::error::UpdateServiceSettingError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_service_setting_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}
