// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_tags_to_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddTagsToResourceOutput, crate::error::AddTagsToResourceError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::AddTagsToResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AddTagsToResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::AddTagsToResourceError {
            meta: generic,
            kind: crate::error::AddTagsToResourceErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::AddTagsToResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidResourceId" => crate::error::AddTagsToResourceError {
            meta: generic,
            kind: crate::error::AddTagsToResourceErrorKind::InvalidResourceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::AddTagsToResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidResourceType" => crate::error::AddTagsToResourceError {
            meta: generic,
            kind: crate::error::AddTagsToResourceErrorKind::InvalidResourceType({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_type_json_err(response.body().as_ref(), output).map_err(crate::error::AddTagsToResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TooManyTagsError" => crate::error::AddTagsToResourceError {
            meta: generic,
            kind: crate::error::AddTagsToResourceErrorKind::TooManyTagsError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_tags_error_json_err(response.body().as_ref(), output).map_err(crate::error::AddTagsToResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TooManyUpdates" => {
            crate::error::AddTagsToResourceError {
                meta: generic,
                kind: crate::error::AddTagsToResourceErrorKind::TooManyUpdates({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_updates::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(response.body().as_ref(), output).map_err(crate::error::AddTagsToResourceError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::AddTagsToResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_tags_to_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddTagsToResourceOutput, crate::error::AddTagsToResourceError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_tags_to_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_ops_item_related_item_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateOpsItemRelatedItemOutput,
    crate::error::AssociateOpsItemRelatedItemError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::AssociateOpsItemRelatedItemError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AssociateOpsItemRelatedItemError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::AssociateOpsItemRelatedItemError { meta: generic, kind: crate::error::AssociateOpsItemRelatedItemErrorKind::InternalServerError({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateOpsItemRelatedItemError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OpsItemInvalidParameterException" => crate::error::AssociateOpsItemRelatedItemError { meta: generic, kind: crate::error::AssociateOpsItemRelatedItemErrorKind::OpsItemInvalidParameterException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::ops_item_invalid_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateOpsItemRelatedItemError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OpsItemLimitExceededException" => crate::error::AssociateOpsItemRelatedItemError { meta: generic, kind: crate::error::AssociateOpsItemRelatedItemErrorKind::OpsItemLimitExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::ops_item_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateOpsItemRelatedItemError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OpsItemNotFoundException" => crate::error::AssociateOpsItemRelatedItemError { meta: generic, kind: crate::error::AssociateOpsItemRelatedItemErrorKind::OpsItemNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::ops_item_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateOpsItemRelatedItemError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OpsItemRelatedItemAlreadyExistsException" => crate::error::AssociateOpsItemRelatedItemError { meta: generic, kind: crate::error::AssociateOpsItemRelatedItemErrorKind::OpsItemRelatedItemAlreadyExistsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::ops_item_related_item_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_related_item_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateOpsItemRelatedItemError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::AssociateOpsItemRelatedItemError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_ops_item_related_item_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateOpsItemRelatedItemOutput,
    crate::error::AssociateOpsItemRelatedItemError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_ops_item_related_item_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_associate_ops_item_related_item(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::AssociateOpsItemRelatedItemError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_command_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CancelCommandOutput, crate::error::CancelCommandError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CancelCommandError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CancelCommandError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DuplicateInstanceId" => crate::error::CancelCommandError {
            meta: generic,
            kind: crate::error::CancelCommandErrorKind::DuplicateInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::duplicate_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_duplicate_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::CancelCommandError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::CancelCommandError {
            meta: generic,
            kind: crate::error::CancelCommandErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CancelCommandError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidCommandId" => {
            crate::error::CancelCommandError {
                meta: generic,
                kind: crate::error::CancelCommandErrorKind::InvalidCommandId({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_command_id::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_command_id_json_err(response.body().as_ref(), output).map_err(crate::error::CancelCommandError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidInstanceId" => crate::error::CancelCommandError {
            meta: generic,
            kind: crate::error::CancelCommandErrorKind::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::CancelCommandError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CancelCommandError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_command_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CancelCommandOutput, crate::error::CancelCommandError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_command_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_maintenance_window_execution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CancelMaintenanceWindowExecutionOutput,
    crate::error::CancelMaintenanceWindowExecutionError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CancelMaintenanceWindowExecutionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CancelMaintenanceWindowExecutionError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::CancelMaintenanceWindowExecutionError {
            meta: generic,
            kind: crate::error::CancelMaintenanceWindowExecutionErrorKind::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CancelMaintenanceWindowExecutionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::CancelMaintenanceWindowExecutionError {
            meta: generic,
            kind: crate::error::CancelMaintenanceWindowExecutionErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CancelMaintenanceWindowExecutionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CancelMaintenanceWindowExecutionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_maintenance_window_execution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CancelMaintenanceWindowExecutionOutput,
    crate::error::CancelMaintenanceWindowExecutionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::cancel_maintenance_window_execution_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_cancel_maintenance_window_execution(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CancelMaintenanceWindowExecutionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_activation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateActivationOutput, crate::error::CreateActivationError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateActivationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateActivationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::CreateActivationError {
            meta: generic,
            kind: crate::error::CreateActivationErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateActivationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidParameters" => {
            crate::error::CreateActivationError {
                meta: generic,
                kind: crate::error::CreateActivationErrorKind::InvalidParameters({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_parameters::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_parameters_json_err(response.body().as_ref(), output).map_err(crate::error::CreateActivationError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::CreateActivationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_activation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateActivationOutput, crate::error::CreateActivationError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_activation_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_activation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateActivationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_association_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateAssociationOutput, crate::error::CreateAssociationError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateAssociationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateAssociationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AssociationAlreadyExists" => crate::error::CreateAssociationError {
            meta: generic,
            kind: crate::error::CreateAssociationErrorKind::AssociationAlreadyExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_already_exists::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_already_exists_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "AssociationLimitExceeded" => crate::error::CreateAssociationError {
            meta: generic,
            kind: crate::error::CreateAssociationErrorKind::AssociationLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::CreateAssociationError {
            meta: generic,
            kind: crate::error::CreateAssociationErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDocument" => {
            crate::error::CreateAssociationError {
                meta: generic,
                kind: crate::error::CreateAssociationErrorKind::InvalidDocument({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_document::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidDocumentVersion" => crate::error::CreateAssociationError {
            meta: generic,
            kind: crate::error::CreateAssociationErrorKind::InvalidDocumentVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInstanceId" => crate::error::CreateAssociationError {
            meta: generic,
            kind: crate::error::CreateAssociationErrorKind::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidOutputLocation" => crate::error::CreateAssociationError {
            meta: generic,
            kind: crate::error::CreateAssociationErrorKind::InvalidOutputLocation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_output_location::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_output_location_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidParameters" => {
            crate::error::CreateAssociationError {
                meta: generic,
                kind: crate::error::CreateAssociationErrorKind::InvalidParameters({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_parameters::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_parameters_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidSchedule" => {
            crate::error::CreateAssociationError {
                meta: generic,
                kind: crate::error::CreateAssociationErrorKind::InvalidSchedule({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_schedule::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_schedule_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidTarget" => crate::error::CreateAssociationError {
            meta: generic,
            kind: crate::error::CreateAssociationErrorKind::InvalidTarget({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_target::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_invalid_target_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::CreateAssociationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidTargetMaps" => crate::error::CreateAssociationError {
            meta: generic,
            kind: crate::error::CreateAssociationErrorKind::InvalidTargetMaps({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_target_maps::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_target_maps_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnsupportedPlatformType" => crate::error::CreateAssociationError {
            meta: generic,
            kind: crate::error::CreateAssociationErrorKind::UnsupportedPlatformType({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_platform_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_platform_type_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateAssociationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_association_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateAssociationOutput, crate::error::CreateAssociationError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_association_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_association(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateAssociationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_association_batch_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateAssociationBatchOutput,
    crate::error::CreateAssociationBatchError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateAssociationBatchError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateAssociationBatchError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AssociationLimitExceeded" => crate::error::CreateAssociationBatchError {
            meta: generic,
            kind: crate::error::CreateAssociationBatchErrorKind::AssociationLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DuplicateInstanceId" => crate::error::CreateAssociationBatchError {
            meta: generic,
            kind: crate::error::CreateAssociationBatchErrorKind::DuplicateInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::duplicate_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_duplicate_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::CreateAssociationBatchError {
            meta: generic,
            kind: crate::error::CreateAssociationBatchErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDocument" => {
            crate::error::CreateAssociationBatchError {
                meta: generic,
                kind: crate::error::CreateAssociationBatchErrorKind::InvalidDocument({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_document::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidDocumentVersion" => crate::error::CreateAssociationBatchError {
            meta: generic,
            kind: crate::error::CreateAssociationBatchErrorKind::InvalidDocumentVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInstanceId" => crate::error::CreateAssociationBatchError {
            meta: generic,
            kind: crate::error::CreateAssociationBatchErrorKind::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidOutputLocation" => crate::error::CreateAssociationBatchError {
            meta: generic,
            kind: crate::error::CreateAssociationBatchErrorKind::InvalidOutputLocation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_output_location::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_output_location_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidParameters" => {
            crate::error::CreateAssociationBatchError {
                meta: generic,
                kind: crate::error::CreateAssociationBatchErrorKind::InvalidParameters({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_parameters::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_parameters_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidSchedule" => {
            crate::error::CreateAssociationBatchError {
                meta: generic,
                kind: crate::error::CreateAssociationBatchErrorKind::InvalidSchedule({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_schedule::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_schedule_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidTarget" => crate::error::CreateAssociationBatchError {
            meta: generic,
            kind: crate::error::CreateAssociationBatchErrorKind::InvalidTarget({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_target::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_invalid_target_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidTargetMaps" => crate::error::CreateAssociationBatchError {
            meta: generic,
            kind: crate::error::CreateAssociationBatchErrorKind::InvalidTargetMaps({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_target_maps::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_target_maps_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnsupportedPlatformType" => crate::error::CreateAssociationBatchError {
            meta: generic,
            kind: crate::error::CreateAssociationBatchErrorKind::UnsupportedPlatformType({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_platform_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_platform_type_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateAssociationBatchError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_association_batch_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateAssociationBatchOutput,
    crate::error::CreateAssociationBatchError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_association_batch_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_association_batch(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateAssociationBatchError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_document_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDocumentOutput, crate::error::CreateDocumentError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateDocumentError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDocumentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DocumentAlreadyExists" => crate::error::CreateDocumentError {
            meta: generic,
            kind: crate::error::CreateDocumentErrorKind::DocumentAlreadyExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::document_already_exists::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_document_already_exists_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DocumentLimitExceeded" => crate::error::CreateDocumentError {
            meta: generic,
            kind: crate::error::CreateDocumentErrorKind::DocumentLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::document_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_document_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::CreateDocumentError {
            meta: generic,
            kind: crate::error::CreateDocumentErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDocumentContent" => crate::error::CreateDocumentError {
            meta: generic,
            kind: crate::error::CreateDocumentErrorKind::InvalidDocumentContent({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_content::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_content_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDocumentSchemaVersion" => crate::error::CreateDocumentError {
            meta: generic,
            kind: crate::error::CreateDocumentErrorKind::InvalidDocumentSchemaVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_document_schema_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_schema_version_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "MaxDocumentSizeExceeded" => crate::error::CreateDocumentError {
            meta: generic,
            kind: crate::error::CreateDocumentErrorKind::MaxDocumentSizeExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::max_document_size_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_max_document_size_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateDocumentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_document_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDocumentOutput, crate::error::CreateDocumentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_document_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_document(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDocumentError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_maintenance_window_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateMaintenanceWindowOutput,
    crate::error::CreateMaintenanceWindowError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateMaintenanceWindowError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateMaintenanceWindowError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "IdempotentParameterMismatch" => crate::error::CreateMaintenanceWindowError {
            meta: generic,
            kind: crate::error::CreateMaintenanceWindowErrorKind::IdempotentParameterMismatch({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::idempotent_parameter_mismatch::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotent_parameter_mismatch_json_err(response.body().as_ref(), output).map_err(crate::error::CreateMaintenanceWindowError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::CreateMaintenanceWindowError {
            meta: generic,
            kind: crate::error::CreateMaintenanceWindowErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateMaintenanceWindowError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceLimitExceededException" => crate::error::CreateMaintenanceWindowError {
            meta: generic,
            kind: crate::error::CreateMaintenanceWindowErrorKind::ResourceLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateMaintenanceWindowError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateMaintenanceWindowError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_maintenance_window_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateMaintenanceWindowOutput,
    crate::error::CreateMaintenanceWindowError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_maintenance_window_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_maintenance_window(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateMaintenanceWindowError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_ops_item_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateOpsItemOutput, crate::error::CreateOpsItemError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateOpsItemError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateOpsItemError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::CreateOpsItemError {
            meta: generic,
            kind: crate::error::CreateOpsItemErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsItemError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OpsItemAlreadyExistsException" => crate::error::CreateOpsItemError {
            meta: generic,
            kind: crate::error::CreateOpsItemErrorKind::OpsItemAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_item_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsItemError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OpsItemInvalidParameterException" => crate::error::CreateOpsItemError {
            meta: generic,
            kind: crate::error::CreateOpsItemErrorKind::OpsItemInvalidParameterException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_item_invalid_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsItemError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OpsItemLimitExceededException" => crate::error::CreateOpsItemError {
            meta: generic,
            kind: crate::error::CreateOpsItemErrorKind::OpsItemLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_item_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsItemError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateOpsItemError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_ops_item_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateOpsItemOutput, crate::error::CreateOpsItemError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_ops_item_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_ops_item(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateOpsItemError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_ops_metadata_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateOpsMetadataOutput, crate::error::CreateOpsMetadataError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateOpsMetadataError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateOpsMetadataError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::CreateOpsMetadataError {
            meta: generic,
            kind: crate::error::CreateOpsMetadataErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OpsMetadataAlreadyExistsException" => crate::error::CreateOpsMetadataError {
            meta: generic,
            kind: crate::error::CreateOpsMetadataErrorKind::OpsMetadataAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_metadata_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OpsMetadataInvalidArgumentException" => crate::error::CreateOpsMetadataError {
            meta: generic,
            kind: crate::error::CreateOpsMetadataErrorKind::OpsMetadataInvalidArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_metadata_invalid_argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_invalid_argument_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OpsMetadataLimitExceededException" => crate::error::CreateOpsMetadataError {
            meta: generic,
            kind: crate::error::CreateOpsMetadataErrorKind::OpsMetadataLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_metadata_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OpsMetadataTooManyUpdatesException" => crate::error::CreateOpsMetadataError {
            meta: generic,
            kind: crate::error::CreateOpsMetadataErrorKind::OpsMetadataTooManyUpdatesException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_metadata_too_many_updates_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_too_many_updates_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateOpsMetadataError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_ops_metadata_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateOpsMetadataOutput, crate::error::CreateOpsMetadataError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_ops_metadata_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_ops_metadata(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateOpsMetadataError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_patch_baseline_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreatePatchBaselineOutput,
    crate::error::CreatePatchBaselineError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreatePatchBaselineError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreatePatchBaselineError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "IdempotentParameterMismatch" => crate::error::CreatePatchBaselineError {
            meta: generic,
            kind: crate::error::CreatePatchBaselineErrorKind::IdempotentParameterMismatch({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::idempotent_parameter_mismatch::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotent_parameter_mismatch_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePatchBaselineError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::CreatePatchBaselineError {
            meta: generic,
            kind: crate::error::CreatePatchBaselineErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePatchBaselineError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceLimitExceededException" => crate::error::CreatePatchBaselineError {
            meta: generic,
            kind: crate::error::CreatePatchBaselineErrorKind::ResourceLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePatchBaselineError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreatePatchBaselineError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_patch_baseline_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreatePatchBaselineOutput,
    crate::error::CreatePatchBaselineError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_patch_baseline_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_patch_baseline(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreatePatchBaselineError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_resource_data_sync_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateResourceDataSyncOutput,
    crate::error::CreateResourceDataSyncError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateResourceDataSyncError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateResourceDataSyncError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::CreateResourceDataSyncError { meta: generic, kind: crate::error::CreateResourceDataSyncErrorKind::InternalServerError({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateResourceDataSyncError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceDataSyncAlreadyExistsException" => crate::error::CreateResourceDataSyncError { meta: generic, kind: crate::error::CreateResourceDataSyncErrorKind::ResourceDataSyncAlreadyExistsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::resource_data_sync_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_data_sync_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateResourceDataSyncError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceDataSyncCountExceededException" => crate::error::CreateResourceDataSyncError { meta: generic, kind: crate::error::CreateResourceDataSyncErrorKind::ResourceDataSyncCountExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::resource_data_sync_count_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_data_sync_count_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateResourceDataSyncError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceDataSyncInvalidConfigurationException" => crate::error::CreateResourceDataSyncError { meta: generic, kind: crate::error::CreateResourceDataSyncErrorKind::ResourceDataSyncInvalidConfigurationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::resource_data_sync_invalid_configuration_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_data_sync_invalid_configuration_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateResourceDataSyncError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateResourceDataSyncError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_resource_data_sync_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateResourceDataSyncOutput,
    crate::error::CreateResourceDataSyncError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_resource_data_sync_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_activation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteActivationOutput, crate::error::DeleteActivationError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteActivationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteActivationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DeleteActivationError {
            meta: generic,
            kind: crate::error::DeleteActivationErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteActivationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidActivation" => {
            crate::error::DeleteActivationError {
                meta: generic,
                kind: crate::error::DeleteActivationErrorKind::InvalidActivation({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_activation::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_activation_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteActivationError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidActivationId" => crate::error::DeleteActivationError {
            meta: generic,
            kind: crate::error::DeleteActivationErrorKind::InvalidActivationId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_activation_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_activation_id_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteActivationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TooManyUpdates" => {
            crate::error::DeleteActivationError {
                meta: generic,
                kind: crate::error::DeleteActivationErrorKind::TooManyUpdates({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_updates::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteActivationError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DeleteActivationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_activation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteActivationOutput, crate::error::DeleteActivationError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_activation_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_association_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteAssociationOutput, crate::error::DeleteAssociationError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteAssociationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteAssociationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AssociationDoesNotExist" => crate::error::DeleteAssociationError {
            meta: generic,
            kind: crate::error::DeleteAssociationErrorKind::AssociationDoesNotExist({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteAssociationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::DeleteAssociationError {
            meta: generic,
            kind: crate::error::DeleteAssociationErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteAssociationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDocument" => {
            crate::error::DeleteAssociationError {
                meta: generic,
                kind: crate::error::DeleteAssociationErrorKind::InvalidDocument({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_document::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteAssociationError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidInstanceId" => crate::error::DeleteAssociationError {
            meta: generic,
            kind: crate::error::DeleteAssociationErrorKind::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteAssociationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TooManyUpdates" => {
            crate::error::DeleteAssociationError {
                meta: generic,
                kind: crate::error::DeleteAssociationErrorKind::TooManyUpdates({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_updates::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteAssociationError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DeleteAssociationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_association_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteAssociationOutput, crate::error::DeleteAssociationError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_association_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_document_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDocumentOutput, crate::error::DeleteDocumentError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteDocumentError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDocumentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AssociatedInstances" => crate::error::DeleteDocumentError {
            meta: generic,
            kind: crate::error::DeleteDocumentErrorKind::AssociatedInstances({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::associated_instances::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_associated_instances_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::DeleteDocumentError {
            meta: generic,
            kind: crate::error::DeleteDocumentErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDocument" => {
            crate::error::DeleteDocumentError {
                meta: generic,
                kind: crate::error::DeleteDocumentErrorKind::InvalidDocument({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_document::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteDocumentError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidDocumentOperation" => crate::error::DeleteDocumentError {
            meta: generic,
            kind: crate::error::DeleteDocumentErrorKind::InvalidDocumentOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_operation::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_operation_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteDocumentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_document_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDocumentOutput, crate::error::DeleteDocumentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_document_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_inventory_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteInventoryOutput, crate::error::DeleteInventoryError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteInventoryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteInventoryError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DeleteInventoryError {
            meta: generic,
            kind: crate::error::DeleteInventoryErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteInventoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDeleteInventoryParametersException" => crate::error::DeleteInventoryError {
            meta: generic,
            kind: crate::error::DeleteInventoryErrorKind::InvalidDeleteInventoryParametersException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::invalid_delete_inventory_parameters_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_delete_inventory_parameters_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteInventoryError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "InvalidInventoryRequestException" => crate::error::DeleteInventoryError {
            meta: generic,
            kind: crate::error::DeleteInventoryErrorKind::InvalidInventoryRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_inventory_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_inventory_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteInventoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidOptionException" => crate::error::DeleteInventoryError {
            meta: generic,
            kind: crate::error::DeleteInventoryErrorKind::InvalidOptionException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_option_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_option_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteInventoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidTypeNameException" => crate::error::DeleteInventoryError {
            meta: generic,
            kind: crate::error::DeleteInventoryErrorKind::InvalidTypeNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_type_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_type_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteInventoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteInventoryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_inventory_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteInventoryOutput, crate::error::DeleteInventoryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_inventory_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_inventory(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteInventoryError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_maintenance_window_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteMaintenanceWindowOutput,
    crate::error::DeleteMaintenanceWindowError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteMaintenanceWindowError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteMaintenanceWindowError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DeleteMaintenanceWindowError {
            meta: generic,
            kind: crate::error::DeleteMaintenanceWindowErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteMaintenanceWindowError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteMaintenanceWindowError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_maintenance_window_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteMaintenanceWindowOutput,
    crate::error::DeleteMaintenanceWindowError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_maintenance_window_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_maintenance_window(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteMaintenanceWindowError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_ops_metadata_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteOpsMetadataOutput, crate::error::DeleteOpsMetadataError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteOpsMetadataError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteOpsMetadataError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DeleteOpsMetadataError {
            meta: generic,
            kind: crate::error::DeleteOpsMetadataErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteOpsMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OpsMetadataInvalidArgumentException" => crate::error::DeleteOpsMetadataError {
            meta: generic,
            kind: crate::error::DeleteOpsMetadataErrorKind::OpsMetadataInvalidArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_metadata_invalid_argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_invalid_argument_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteOpsMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OpsMetadataNotFoundException" => crate::error::DeleteOpsMetadataError {
            meta: generic,
            kind: crate::error::DeleteOpsMetadataErrorKind::OpsMetadataNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_metadata_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteOpsMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteOpsMetadataError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_ops_metadata_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteOpsMetadataOutput, crate::error::DeleteOpsMetadataError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_ops_metadata_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_parameter_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteParameterOutput, crate::error::DeleteParameterError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteParameterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteParameterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DeleteParameterError {
            meta: generic,
            kind: crate::error::DeleteParameterErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteParameterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ParameterNotFound" => crate::error::DeleteParameterError {
            meta: generic,
            kind: crate::error::DeleteParameterErrorKind::ParameterNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteParameterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteParameterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_parameter_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteParameterOutput, crate::error::DeleteParameterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_parameter_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_parameters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteParametersOutput, crate::error::DeleteParametersError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteParametersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteParametersError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DeleteParametersError {
            meta: generic,
            kind: crate::error::DeleteParametersErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteParametersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteParametersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_parameters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteParametersOutput, crate::error::DeleteParametersError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_parameters_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_parameters(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteParametersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_patch_baseline_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeletePatchBaselineOutput,
    crate::error::DeletePatchBaselineError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeletePatchBaselineError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeletePatchBaselineError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DeletePatchBaselineError {
            meta: generic,
            kind: crate::error::DeletePatchBaselineErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePatchBaselineError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceInUseException" => crate::error::DeletePatchBaselineError {
            meta: generic,
            kind: crate::error::DeletePatchBaselineErrorKind::ResourceInUseException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_in_use_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_in_use_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePatchBaselineError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeletePatchBaselineError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_patch_baseline_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeletePatchBaselineOutput,
    crate::error::DeletePatchBaselineError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_patch_baseline_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_patch_baseline(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeletePatchBaselineError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_resource_data_sync_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteResourceDataSyncOutput,
    crate::error::DeleteResourceDataSyncError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteResourceDataSyncError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteResourceDataSyncError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DeleteResourceDataSyncError { meta: generic, kind: crate::error::DeleteResourceDataSyncErrorKind::InternalServerError({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteResourceDataSyncError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceDataSyncInvalidConfigurationException" => crate::error::DeleteResourceDataSyncError { meta: generic, kind: crate::error::DeleteResourceDataSyncErrorKind::ResourceDataSyncInvalidConfigurationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::resource_data_sync_invalid_configuration_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_data_sync_invalid_configuration_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteResourceDataSyncError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceDataSyncNotFoundException" => crate::error::DeleteResourceDataSyncError { meta: generic, kind: crate::error::DeleteResourceDataSyncErrorKind::ResourceDataSyncNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::resource_data_sync_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_data_sync_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteResourceDataSyncError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteResourceDataSyncError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_resource_data_sync_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteResourceDataSyncOutput,
    crate::error::DeleteResourceDataSyncError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_resource_data_sync_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_managed_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeregisterManagedInstanceOutput,
    crate::error::DeregisterManagedInstanceError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeregisterManagedInstanceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeregisterManagedInstanceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DeregisterManagedInstanceError {
            meta: generic,
            kind: crate::error::DeregisterManagedInstanceErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterManagedInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInstanceId" => crate::error::DeregisterManagedInstanceError {
            meta: generic,
            kind: crate::error::DeregisterManagedInstanceErrorKind::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterManagedInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeregisterManagedInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_managed_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeregisterManagedInstanceOutput,
    crate::error::DeregisterManagedInstanceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deregister_managed_instance_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_patch_baseline_for_patch_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeregisterPatchBaselineForPatchGroupOutput,
    crate::error::DeregisterPatchBaselineForPatchGroupError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeregisterPatchBaselineForPatchGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeregisterPatchBaselineForPatchGroupError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DeregisterPatchBaselineForPatchGroupError {
            meta: generic,
            kind: crate::error::DeregisterPatchBaselineForPatchGroupErrorKind::InternalServerError(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::internal_server_error::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterPatchBaselineForPatchGroupError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "InvalidResourceId" => crate::error::DeregisterPatchBaselineForPatchGroupError {
            meta: generic,
            kind: crate::error::DeregisterPatchBaselineForPatchGroupErrorKind::InvalidResourceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterPatchBaselineForPatchGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeregisterPatchBaselineForPatchGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_patch_baseline_for_patch_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeregisterPatchBaselineForPatchGroupOutput,
    crate::error::DeregisterPatchBaselineForPatchGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::deregister_patch_baseline_for_patch_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_deregister_patch_baseline_for_patch_group(response.body().as_ref(), output).map_err(crate::error::DeregisterPatchBaselineForPatchGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_target_from_maintenance_window_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeregisterTargetFromMaintenanceWindowOutput,
    crate::error::DeregisterTargetFromMaintenanceWindowError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeregisterTargetFromMaintenanceWindowError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DeregisterTargetFromMaintenanceWindowError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::DeregisterTargetFromMaintenanceWindowError {
            meta: generic,
            kind:
                crate::error::DeregisterTargetFromMaintenanceWindowErrorKind::DoesNotExistException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::does_not_exist_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterTargetFromMaintenanceWindowError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InternalServerError" => crate::error::DeregisterTargetFromMaintenanceWindowError {
            meta: generic,
            kind: crate::error::DeregisterTargetFromMaintenanceWindowErrorKind::InternalServerError(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::internal_server_error::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterTargetFromMaintenanceWindowError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "TargetInUseException" => crate::error::DeregisterTargetFromMaintenanceWindowError {
            meta: generic,
            kind:
                crate::error::DeregisterTargetFromMaintenanceWindowErrorKind::TargetInUseException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::target_in_use_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_crate_error_target_in_use_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterTargetFromMaintenanceWindowError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::DeregisterTargetFromMaintenanceWindowError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_target_from_maintenance_window_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeregisterTargetFromMaintenanceWindowOutput,
    crate::error::DeregisterTargetFromMaintenanceWindowError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::deregister_target_from_maintenance_window_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_deregister_target_from_maintenance_window(response.body().as_ref(), output).map_err(crate::error::DeregisterTargetFromMaintenanceWindowError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_task_from_maintenance_window_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeregisterTaskFromMaintenanceWindowOutput,
    crate::error::DeregisterTaskFromMaintenanceWindowError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeregisterTaskFromMaintenanceWindowError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeregisterTaskFromMaintenanceWindowError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::DeregisterTaskFromMaintenanceWindowError {
            meta: generic,
            kind: crate::error::DeregisterTaskFromMaintenanceWindowErrorKind::DoesNotExistException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::does_not_exist_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterTaskFromMaintenanceWindowError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "InternalServerError" => crate::error::DeregisterTaskFromMaintenanceWindowError {
            meta: generic,
            kind: crate::error::DeregisterTaskFromMaintenanceWindowErrorKind::InternalServerError(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::internal_server_error::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterTaskFromMaintenanceWindowError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::DeregisterTaskFromMaintenanceWindowError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_task_from_maintenance_window_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeregisterTaskFromMaintenanceWindowOutput,
    crate::error::DeregisterTaskFromMaintenanceWindowError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::deregister_task_from_maintenance_window_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_deregister_task_from_maintenance_window(response.body().as_ref(), output).map_err(crate::error::DeregisterTaskFromMaintenanceWindowError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_activations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeActivationsOutput,
    crate::error::DescribeActivationsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeActivationsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeActivationsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeActivationsError {
            meta: generic,
            kind: crate::error::DescribeActivationsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeActivationsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidFilter" => crate::error::DescribeActivationsError {
            meta: generic,
            kind: crate::error::DescribeActivationsErrorKind::InvalidFilter({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DescribeActivationsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextToken" => {
            crate::error::DescribeActivationsError {
                meta: generic,
                kind: crate::error::DescribeActivationsErrorKind::InvalidNextToken({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeActivationsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DescribeActivationsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_activations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeActivationsOutput,
    crate::error::DescribeActivationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_activations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_activations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeActivationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_association_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAssociationOutput,
    crate::error::DescribeAssociationError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeAssociationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeAssociationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AssociationDoesNotExist" => crate::error::DescribeAssociationError {
            meta: generic,
            kind: crate::error::DescribeAssociationErrorKind::AssociationDoesNotExist({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::DescribeAssociationError {
            meta: generic,
            kind: crate::error::DescribeAssociationErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidAssociationVersion" => crate::error::DescribeAssociationError {
            meta: generic,
            kind: crate::error::DescribeAssociationErrorKind::InvalidAssociationVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_association_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_association_version_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDocument" => {
            crate::error::DescribeAssociationError {
                meta: generic,
                kind: crate::error::DescribeAssociationErrorKind::InvalidDocument({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_document::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidInstanceId" => crate::error::DescribeAssociationError {
            meta: generic,
            kind: crate::error::DescribeAssociationErrorKind::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeAssociationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_association_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAssociationOutput,
    crate::error::DescribeAssociationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_association_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_association(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeAssociationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_association_executions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAssociationExecutionsOutput,
    crate::error::DescribeAssociationExecutionsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeAssociationExecutionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeAssociationExecutionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AssociationDoesNotExist" => crate::error::DescribeAssociationExecutionsError {
            meta: generic,
            kind: crate::error::DescribeAssociationExecutionsErrorKind::AssociationDoesNotExist({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationExecutionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::DescribeAssociationExecutionsError {
            meta: generic,
            kind: crate::error::DescribeAssociationExecutionsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationExecutionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextToken" => {
            crate::error::DescribeAssociationExecutionsError {
                meta: generic,
                kind: crate::error::DescribeAssociationExecutionsErrorKind::InvalidNextToken({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationExecutionsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DescribeAssociationExecutionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_association_executions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAssociationExecutionsOutput,
    crate::error::DescribeAssociationExecutionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_association_executions_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_describe_association_executions(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeAssociationExecutionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_association_execution_targets_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAssociationExecutionTargetsOutput,
    crate::error::DescribeAssociationExecutionTargetsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeAssociationExecutionTargetsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeAssociationExecutionTargetsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AssociationDoesNotExist" => crate::error::DescribeAssociationExecutionTargetsError { meta: generic, kind: crate::error::DescribeAssociationExecutionTargetsErrorKind::AssociationDoesNotExist({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::association_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationExecutionTargetsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "AssociationExecutionDoesNotExist" => crate::error::DescribeAssociationExecutionTargetsError { meta: generic, kind: crate::error::DescribeAssociationExecutionTargetsErrorKind::AssociationExecutionDoesNotExist({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::association_execution_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_execution_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationExecutionTargetsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServerError" => crate::error::DescribeAssociationExecutionTargetsError { meta: generic, kind: crate::error::DescribeAssociationExecutionTargetsErrorKind::InternalServerError({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationExecutionTargetsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextToken" => crate::error::DescribeAssociationExecutionTargetsError { meta: generic, kind: crate::error::DescribeAssociationExecutionTargetsErrorKind::InvalidNextToken({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationExecutionTargetsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeAssociationExecutionTargetsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_association_execution_targets_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAssociationExecutionTargetsOutput,
    crate::error::DescribeAssociationExecutionTargetsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_association_execution_targets_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_association_execution_targets(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationExecutionTargetsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_automation_executions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAutomationExecutionsOutput,
    crate::error::DescribeAutomationExecutionsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeAutomationExecutionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeAutomationExecutionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeAutomationExecutionsError {
            meta: generic,
            kind: crate::error::DescribeAutomationExecutionsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationExecutionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidFilterKey" => {
            crate::error::DescribeAutomationExecutionsError {
                meta: generic,
                kind: crate::error::DescribeAutomationExecutionsErrorKind::InvalidFilterKey({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_filter_key::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationExecutionsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidFilterValue" => crate::error::DescribeAutomationExecutionsError {
            meta: generic,
            kind: crate::error::DescribeAutomationExecutionsErrorKind::InvalidFilterValue({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_value::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_value_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationExecutionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextToken" => {
            crate::error::DescribeAutomationExecutionsError {
                meta: generic,
                kind: crate::error::DescribeAutomationExecutionsErrorKind::InvalidNextToken({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationExecutionsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DescribeAutomationExecutionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_automation_executions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAutomationExecutionsOutput,
    crate::error::DescribeAutomationExecutionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_automation_executions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_automation_executions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeAutomationExecutionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_automation_step_executions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAutomationStepExecutionsOutput,
    crate::error::DescribeAutomationStepExecutionsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeAutomationStepExecutionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeAutomationStepExecutionsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AutomationExecutionNotFoundException" => crate::error::DescribeAutomationStepExecutionsError { meta: generic, kind: crate::error::DescribeAutomationStepExecutionsErrorKind::AutomationExecutionNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::automation_execution_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_execution_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationStepExecutionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServerError" => crate::error::DescribeAutomationStepExecutionsError { meta: generic, kind: crate::error::DescribeAutomationStepExecutionsErrorKind::InternalServerError({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationStepExecutionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFilterKey" => crate::error::DescribeAutomationStepExecutionsError { meta: generic, kind: crate::error::DescribeAutomationStepExecutionsErrorKind::InvalidFilterKey({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_filter_key::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationStepExecutionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFilterValue" => crate::error::DescribeAutomationStepExecutionsError { meta: generic, kind: crate::error::DescribeAutomationStepExecutionsErrorKind::InvalidFilterValue({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_filter_value::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_value_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationStepExecutionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextToken" => crate::error::DescribeAutomationStepExecutionsError { meta: generic, kind: crate::error::DescribeAutomationStepExecutionsErrorKind::InvalidNextToken({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationStepExecutionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeAutomationStepExecutionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_automation_step_executions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAutomationStepExecutionsOutput,
    crate::error::DescribeAutomationStepExecutionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_automation_step_executions_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_describe_automation_step_executions(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeAutomationStepExecutionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_available_patches_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAvailablePatchesOutput,
    crate::error::DescribeAvailablePatchesError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeAvailablePatchesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeAvailablePatchesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeAvailablePatchesError {
            meta: generic,
            kind: crate::error::DescribeAvailablePatchesErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAvailablePatchesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeAvailablePatchesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_available_patches_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAvailablePatchesOutput,
    crate::error::DescribeAvailablePatchesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_available_patches_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_available_patches(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeAvailablePatchesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_document_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeDocumentOutput, crate::error::DescribeDocumentError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDocumentError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeDocumentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeDocumentError {
            meta: generic,
            kind: crate::error::DescribeDocumentErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDocument" => {
            crate::error::DescribeDocumentError {
                meta: generic,
                kind: crate::error::DescribeDocumentErrorKind::InvalidDocument({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_document::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDocumentError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidDocumentVersion" => crate::error::DescribeDocumentError {
            meta: generic,
            kind: crate::error::DescribeDocumentErrorKind::InvalidDocumentVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeDocumentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_document_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeDocumentOutput, crate::error::DescribeDocumentError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_document_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_document(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDocumentError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_document_permission_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDocumentPermissionOutput,
    crate::error::DescribeDocumentPermissionError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDocumentPermissionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDocumentPermissionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeDocumentPermissionError {
            meta: generic,
            kind: crate::error::DescribeDocumentPermissionErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDocumentPermissionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDocument" => {
            crate::error::DescribeDocumentPermissionError {
                meta: generic,
                kind: crate::error::DescribeDocumentPermissionErrorKind::InvalidDocument({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_document::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDocumentPermissionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidDocumentOperation" => crate::error::DescribeDocumentPermissionError {
            meta: generic,
            kind: crate::error::DescribeDocumentPermissionErrorKind::InvalidDocumentOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_operation::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_operation_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDocumentPermissionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextToken" => {
            crate::error::DescribeDocumentPermissionError {
                meta: generic,
                kind: crate::error::DescribeDocumentPermissionErrorKind::InvalidNextToken({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDocumentPermissionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidPermissionType" => crate::error::DescribeDocumentPermissionError {
            meta: generic,
            kind: crate::error::DescribeDocumentPermissionErrorKind::InvalidPermissionType({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_permission_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_permission_type_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDocumentPermissionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeDocumentPermissionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_document_permission_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDocumentPermissionOutput,
    crate::error::DescribeDocumentPermissionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_document_permission_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_document_permission(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDocumentPermissionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_effective_instance_associations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEffectiveInstanceAssociationsOutput,
    crate::error::DescribeEffectiveInstanceAssociationsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeEffectiveInstanceAssociationsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DescribeEffectiveInstanceAssociationsError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeEffectiveInstanceAssociationsError {
            meta: generic,
            kind: crate::error::DescribeEffectiveInstanceAssociationsErrorKind::InternalServerError(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::internal_server_error::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeEffectiveInstanceAssociationsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "InvalidInstanceId" => crate::error::DescribeEffectiveInstanceAssociationsError {
            meta: generic,
            kind: crate::error::DescribeEffectiveInstanceAssociationsErrorKind::InvalidInstanceId(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_instance_id::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeEffectiveInstanceAssociationsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "InvalidNextToken" => {
            crate::error::DescribeEffectiveInstanceAssociationsError {
                meta: generic,
                kind:
                    crate::error::DescribeEffectiveInstanceAssociationsErrorKind::InvalidNextToken(
                        {
                            #[allow(unused_mut)]
                            let mut tmp = {
                                #[allow(unused_mut)]
                                let mut output =
                                    crate::error::invalid_next_token::Builder::default();
                                let _ = response;
                                output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeEffectiveInstanceAssociationsError::unhandled)?;
                                output.build()
                            };
                            if (&tmp.message).is_none() {
                                tmp.message = _error_message;
                            }
                            tmp
                        },
                    ),
            }
        }
        _ => crate::error::DescribeEffectiveInstanceAssociationsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_effective_instance_associations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEffectiveInstanceAssociationsOutput,
    crate::error::DescribeEffectiveInstanceAssociationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_effective_instance_associations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_effective_instance_associations(response.body().as_ref(), output).map_err(crate::error::DescribeEffectiveInstanceAssociationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_effective_patches_for_patch_baseline_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEffectivePatchesForPatchBaselineOutput,
    crate::error::DescribeEffectivePatchesForPatchBaselineError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::DescribeEffectivePatchesForPatchBaselineError { meta: generic, kind: crate::error::DescribeEffectivePatchesForPatchBaselineErrorKind::DoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServerError" => crate::error::DescribeEffectivePatchesForPatchBaselineError { meta: generic, kind: crate::error::DescribeEffectivePatchesForPatchBaselineErrorKind::InternalServerError({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidResourceId" => crate::error::DescribeEffectivePatchesForPatchBaselineError { meta: generic, kind: crate::error::DescribeEffectivePatchesForPatchBaselineErrorKind::InvalidResourceId({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedOperatingSystem" => crate::error::DescribeEffectivePatchesForPatchBaselineError { meta: generic, kind: crate::error::DescribeEffectivePatchesForPatchBaselineErrorKind::UnsupportedOperatingSystem({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::unsupported_operating_system::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_operating_system_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeEffectivePatchesForPatchBaselineError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_effective_patches_for_patch_baseline_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEffectivePatchesForPatchBaselineOutput,
    crate::error::DescribeEffectivePatchesForPatchBaselineError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_effective_patches_for_patch_baseline_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_effective_patches_for_patch_baseline(response.body().as_ref(), output).map_err(crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_associations_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstanceAssociationsStatusOutput,
    crate::error::DescribeInstanceAssociationsStatusError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeInstanceAssociationsStatusError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeInstanceAssociationsStatusError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeInstanceAssociationsStatusError {
            meta: generic,
            kind: crate::error::DescribeInstanceAssociationsStatusErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceAssociationsStatusError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInstanceId" => crate::error::DescribeInstanceAssociationsStatusError {
            meta: generic,
            kind: crate::error::DescribeInstanceAssociationsStatusErrorKind::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceAssociationsStatusError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextToken" => {
            crate::error::DescribeInstanceAssociationsStatusError {
                meta: generic,
                kind: crate::error::DescribeInstanceAssociationsStatusErrorKind::InvalidNextToken(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output = crate::error::invalid_next_token::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceAssociationsStatusError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
            }
        }
        _ => crate::error::DescribeInstanceAssociationsStatusError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_associations_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstanceAssociationsStatusOutput,
    crate::error::DescribeInstanceAssociationsStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_instance_associations_status_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_instance_associations_status(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceAssociationsStatusError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_information_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstanceInformationOutput,
    crate::error::DescribeInstanceInformationError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeInstanceInformationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeInstanceInformationError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeInstanceInformationError { meta: generic, kind: crate::error::DescribeInstanceInformationErrorKind::InternalServerError({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceInformationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFilterKey" => crate::error::DescribeInstanceInformationError { meta: generic, kind: crate::error::DescribeInstanceInformationErrorKind::InvalidFilterKey({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_filter_key::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceInformationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidInstanceId" => crate::error::DescribeInstanceInformationError { meta: generic, kind: crate::error::DescribeInstanceInformationErrorKind::InvalidInstanceId({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceInformationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidInstanceInformationFilterValue" => crate::error::DescribeInstanceInformationError { meta: generic, kind: crate::error::DescribeInstanceInformationErrorKind::InvalidInstanceInformationFilterValue({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_instance_information_filter_value::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_information_filter_value_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceInformationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextToken" => crate::error::DescribeInstanceInformationError { meta: generic, kind: crate::error::DescribeInstanceInformationErrorKind::InvalidNextToken({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceInformationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeInstanceInformationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_information_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstanceInformationOutput,
    crate::error::DescribeInstanceInformationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instance_information_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_instance_information(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeInstanceInformationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_patches_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstancePatchesOutput,
    crate::error::DescribeInstancePatchesError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeInstancePatchesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeInstancePatchesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeInstancePatchesError {
            meta: generic,
            kind: crate::error::DescribeInstancePatchesErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancePatchesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidFilter" => crate::error::DescribeInstancePatchesError {
            meta: generic,
            kind: crate::error::DescribeInstancePatchesErrorKind::InvalidFilter({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DescribeInstancePatchesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInstanceId" => crate::error::DescribeInstancePatchesError {
            meta: generic,
            kind: crate::error::DescribeInstancePatchesErrorKind::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancePatchesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextToken" => {
            crate::error::DescribeInstancePatchesError {
                meta: generic,
                kind: crate::error::DescribeInstancePatchesErrorKind::InvalidNextToken({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancePatchesError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DescribeInstancePatchesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_patches_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstancePatchesOutput,
    crate::error::DescribeInstancePatchesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instance_patches_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_instance_patches(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeInstancePatchesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_patch_states_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstancePatchStatesOutput,
    crate::error::DescribeInstancePatchStatesError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeInstancePatchStatesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeInstancePatchStatesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeInstancePatchStatesError {
            meta: generic,
            kind: crate::error::DescribeInstancePatchStatesErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancePatchStatesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextToken" => {
            crate::error::DescribeInstancePatchStatesError {
                meta: generic,
                kind: crate::error::DescribeInstancePatchStatesErrorKind::InvalidNextToken({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancePatchStatesError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DescribeInstancePatchStatesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_patch_states_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstancePatchStatesOutput,
    crate::error::DescribeInstancePatchStatesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instance_patch_states_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_instance_patch_states(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeInstancePatchStatesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_patch_states_for_patch_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstancePatchStatesForPatchGroupOutput,
    crate::error::DescribeInstancePatchStatesForPatchGroupError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeInstancePatchStatesForPatchGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DescribeInstancePatchStatesForPatchGroupError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeInstancePatchStatesForPatchGroupError {
            meta: generic,
            kind:
                crate::error::DescribeInstancePatchStatesForPatchGroupErrorKind::InternalServerError(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::internal_server_error::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancePatchStatesForPatchGroupError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InvalidFilter" => {
            crate::error::DescribeInstancePatchStatesForPatchGroupError {
                meta: generic,
                kind:
                    crate::error::DescribeInstancePatchStatesForPatchGroupErrorKind::InvalidFilter(
                        {
                            #[allow(unused_mut)]
                            let mut tmp = {
                                #[allow(unused_mut)]
                                let mut output = crate::error::invalid_filter::Builder::default();
                                let _ = response;
                                output = crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancePatchStatesForPatchGroupError::unhandled)?;
                                output.build()
                            };
                            if (&tmp.message).is_none() {
                                tmp.message = _error_message;
                            }
                            tmp
                        },
                    ),
            }
        }
        "InvalidNextToken" => crate::error::DescribeInstancePatchStatesForPatchGroupError {
            meta: generic,
            kind: crate::error::DescribeInstancePatchStatesForPatchGroupErrorKind::InvalidNextToken(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancePatchStatesForPatchGroupError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::DescribeInstancePatchStatesForPatchGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_patch_states_for_patch_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstancePatchStatesForPatchGroupOutput,
    crate::error::DescribeInstancePatchStatesForPatchGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_instance_patch_states_for_patch_group_output::Builder::default(
            );
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_instance_patch_states_for_patch_group(response.body().as_ref(), output).map_err(crate::error::DescribeInstancePatchStatesForPatchGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_inventory_deletions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInventoryDeletionsOutput,
    crate::error::DescribeInventoryDeletionsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeInventoryDeletionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeInventoryDeletionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeInventoryDeletionsError {
            meta: generic,
            kind: crate::error::DescribeInventoryDeletionsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInventoryDeletionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDeletionIdException" => crate::error::DescribeInventoryDeletionsError {
            meta: generic,
            kind: crate::error::DescribeInventoryDeletionsErrorKind::InvalidDeletionIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_deletion_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_deletion_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInventoryDeletionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextToken" => {
            crate::error::DescribeInventoryDeletionsError {
                meta: generic,
                kind: crate::error::DescribeInventoryDeletionsErrorKind::InvalidNextToken({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInventoryDeletionsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DescribeInventoryDeletionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_inventory_deletions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInventoryDeletionsOutput,
    crate::error::DescribeInventoryDeletionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_inventory_deletions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_inventory_deletions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeInventoryDeletionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_executions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowExecutionsOutput,
    crate::error::DescribeMaintenanceWindowExecutionsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeMaintenanceWindowExecutionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeMaintenanceWindowExecutionsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeMaintenanceWindowExecutionsError {
            meta: generic,
            kind: crate::error::DescribeMaintenanceWindowExecutionsErrorKind::InternalServerError(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::internal_server_error::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowExecutionsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::DescribeMaintenanceWindowExecutionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_executions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowExecutionsOutput,
    crate::error::DescribeMaintenanceWindowExecutionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_maintenance_window_executions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_maintenance_window_executions(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowExecutionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_execution_task_invocations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowExecutionTaskInvocationsOutput,
    crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::unhandled(
                    generic,
                ),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError { meta: generic, kind: crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsErrorKind::DoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServerError" => crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError { meta: generic, kind: crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsErrorKind::InternalServerError({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_execution_task_invocations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowExecutionTaskInvocationsOutput,
    crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError,
> {
    Ok({
        #[allow(unused_mut)]let mut output = crate::output::describe_maintenance_window_execution_task_invocations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_maintenance_window_execution_task_invocations(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_execution_tasks_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowExecutionTasksOutput,
    crate::error::DescribeMaintenanceWindowExecutionTasksError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeMaintenanceWindowExecutionTasksError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DescribeMaintenanceWindowExecutionTasksError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::DescribeMaintenanceWindowExecutionTasksError { meta: generic, kind: crate::error::DescribeMaintenanceWindowExecutionTasksErrorKind::DoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowExecutionTasksError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServerError" => crate::error::DescribeMaintenanceWindowExecutionTasksError { meta: generic, kind: crate::error::DescribeMaintenanceWindowExecutionTasksErrorKind::InternalServerError({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowExecutionTasksError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeMaintenanceWindowExecutionTasksError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_execution_tasks_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowExecutionTasksOutput,
    crate::error::DescribeMaintenanceWindowExecutionTasksError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_maintenance_window_execution_tasks_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_maintenance_window_execution_tasks(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowExecutionTasksError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_windows_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowsOutput,
    crate::error::DescribeMaintenanceWindowsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeMaintenanceWindowsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeMaintenanceWindowsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeMaintenanceWindowsError {
            meta: generic,
            kind: crate::error::DescribeMaintenanceWindowsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeMaintenanceWindowsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_windows_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowsOutput,
    crate::error::DescribeMaintenanceWindowsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_maintenance_windows_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_maintenance_windows(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeMaintenanceWindowsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_schedule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowScheduleOutput,
    crate::error::DescribeMaintenanceWindowScheduleError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeMaintenanceWindowScheduleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeMaintenanceWindowScheduleError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::DescribeMaintenanceWindowScheduleError {
            meta: generic,
            kind: crate::error::DescribeMaintenanceWindowScheduleErrorKind::DoesNotExistException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::does_not_exist_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowScheduleError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "InternalServerError" => crate::error::DescribeMaintenanceWindowScheduleError {
            meta: generic,
            kind: crate::error::DescribeMaintenanceWindowScheduleErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowScheduleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeMaintenanceWindowScheduleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_schedule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowScheduleOutput,
    crate::error::DescribeMaintenanceWindowScheduleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_maintenance_window_schedule_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_maintenance_window_schedule(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowScheduleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_windows_for_target_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowsForTargetOutput,
    crate::error::DescribeMaintenanceWindowsForTargetError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeMaintenanceWindowsForTargetError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeMaintenanceWindowsForTargetError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeMaintenanceWindowsForTargetError {
            meta: generic,
            kind: crate::error::DescribeMaintenanceWindowsForTargetErrorKind::InternalServerError(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::internal_server_error::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowsForTargetError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::DescribeMaintenanceWindowsForTargetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_windows_for_target_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowsForTargetOutput,
    crate::error::DescribeMaintenanceWindowsForTargetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_maintenance_windows_for_target_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_maintenance_windows_for_target(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowsForTargetError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_targets_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowTargetsOutput,
    crate::error::DescribeMaintenanceWindowTargetsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeMaintenanceWindowTargetsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeMaintenanceWindowTargetsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::DescribeMaintenanceWindowTargetsError {
            meta: generic,
            kind: crate::error::DescribeMaintenanceWindowTargetsErrorKind::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowTargetsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::DescribeMaintenanceWindowTargetsError {
            meta: generic,
            kind: crate::error::DescribeMaintenanceWindowTargetsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowTargetsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeMaintenanceWindowTargetsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_targets_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowTargetsOutput,
    crate::error::DescribeMaintenanceWindowTargetsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_maintenance_window_targets_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_describe_maintenance_window_targets(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeMaintenanceWindowTargetsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_tasks_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowTasksOutput,
    crate::error::DescribeMaintenanceWindowTasksError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeMaintenanceWindowTasksError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeMaintenanceWindowTasksError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::DescribeMaintenanceWindowTasksError {
            meta: generic,
            kind: crate::error::DescribeMaintenanceWindowTasksErrorKind::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowTasksError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::DescribeMaintenanceWindowTasksError {
            meta: generic,
            kind: crate::error::DescribeMaintenanceWindowTasksErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowTasksError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeMaintenanceWindowTasksError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_tasks_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMaintenanceWindowTasksOutput,
    crate::error::DescribeMaintenanceWindowTasksError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_maintenance_window_tasks_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_describe_maintenance_window_tasks(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeMaintenanceWindowTasksError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_ops_items_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeOpsItemsOutput, crate::error::DescribeOpsItemsError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeOpsItemsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeOpsItemsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeOpsItemsError {
            meta: generic,
            kind: crate::error::DescribeOpsItemsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeOpsItemsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeOpsItemsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_ops_items_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeOpsItemsOutput, crate::error::DescribeOpsItemsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_ops_items_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_ops_items(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeOpsItemsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_parameters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeParametersOutput,
    crate::error::DescribeParametersError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeParametersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeParametersError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeParametersError {
            meta: generic,
            kind: crate::error::DescribeParametersErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeParametersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidFilterKey" => {
            crate::error::DescribeParametersError {
                meta: generic,
                kind: crate::error::DescribeParametersErrorKind::InvalidFilterKey({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_filter_key::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeParametersError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidFilterOption" => crate::error::DescribeParametersError {
            meta: generic,
            kind: crate::error::DescribeParametersErrorKind::InvalidFilterOption({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_option::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_option_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeParametersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidFilterValue" => crate::error::DescribeParametersError {
            meta: generic,
            kind: crate::error::DescribeParametersErrorKind::InvalidFilterValue({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_value::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_value_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeParametersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextToken" => {
            crate::error::DescribeParametersError {
                meta: generic,
                kind: crate::error::DescribeParametersErrorKind::InvalidNextToken({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeParametersError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DescribeParametersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_parameters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeParametersOutput,
    crate::error::DescribeParametersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_parameters_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_parameters(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeParametersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_patch_baselines_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePatchBaselinesOutput,
    crate::error::DescribePatchBaselinesError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribePatchBaselinesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribePatchBaselinesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribePatchBaselinesError {
            meta: generic,
            kind: crate::error::DescribePatchBaselinesErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePatchBaselinesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribePatchBaselinesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_patch_baselines_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePatchBaselinesOutput,
    crate::error::DescribePatchBaselinesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_patch_baselines_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_patch_baselines(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribePatchBaselinesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_patch_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePatchGroupsOutput,
    crate::error::DescribePatchGroupsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribePatchGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribePatchGroupsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribePatchGroupsError {
            meta: generic,
            kind: crate::error::DescribePatchGroupsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePatchGroupsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribePatchGroupsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_patch_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePatchGroupsOutput,
    crate::error::DescribePatchGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_patch_groups_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_patch_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribePatchGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_patch_group_state_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePatchGroupStateOutput,
    crate::error::DescribePatchGroupStateError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribePatchGroupStateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribePatchGroupStateError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribePatchGroupStateError {
            meta: generic,
            kind: crate::error::DescribePatchGroupStateErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePatchGroupStateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextToken" => {
            crate::error::DescribePatchGroupStateError {
                meta: generic,
                kind: crate::error::DescribePatchGroupStateErrorKind::InvalidNextToken({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePatchGroupStateError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DescribePatchGroupStateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_patch_group_state_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePatchGroupStateOutput,
    crate::error::DescribePatchGroupStateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_patch_group_state_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_patch_group_state(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribePatchGroupStateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_patch_properties_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePatchPropertiesOutput,
    crate::error::DescribePatchPropertiesError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribePatchPropertiesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribePatchPropertiesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribePatchPropertiesError {
            meta: generic,
            kind: crate::error::DescribePatchPropertiesErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePatchPropertiesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribePatchPropertiesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_patch_properties_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePatchPropertiesOutput,
    crate::error::DescribePatchPropertiesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_patch_properties_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_patch_properties(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribePatchPropertiesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_sessions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeSessionsOutput, crate::error::DescribeSessionsError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeSessionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeSessionsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeSessionsError {
            meta: generic,
            kind: crate::error::DescribeSessionsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeSessionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidFilterKey" => {
            crate::error::DescribeSessionsError {
                meta: generic,
                kind: crate::error::DescribeSessionsErrorKind::InvalidFilterKey({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_filter_key::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeSessionsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidNextToken" => {
            crate::error::DescribeSessionsError {
                meta: generic,
                kind: crate::error::DescribeSessionsErrorKind::InvalidNextToken({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeSessionsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DescribeSessionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_sessions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeSessionsOutput, crate::error::DescribeSessionsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_sessions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_sessions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeSessionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_ops_item_related_item_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateOpsItemRelatedItemOutput,
    crate::error::DisassociateOpsItemRelatedItemError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DisassociateOpsItemRelatedItemError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DisassociateOpsItemRelatedItemError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DisassociateOpsItemRelatedItemError { meta: generic, kind: crate::error::DisassociateOpsItemRelatedItemErrorKind::InternalServerError({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateOpsItemRelatedItemError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OpsItemInvalidParameterException" => crate::error::DisassociateOpsItemRelatedItemError { meta: generic, kind: crate::error::DisassociateOpsItemRelatedItemErrorKind::OpsItemInvalidParameterException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::ops_item_invalid_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateOpsItemRelatedItemError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OpsItemNotFoundException" => crate::error::DisassociateOpsItemRelatedItemError { meta: generic, kind: crate::error::DisassociateOpsItemRelatedItemErrorKind::OpsItemNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::ops_item_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateOpsItemRelatedItemError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OpsItemRelatedItemAssociationNotFoundException" => crate::error::DisassociateOpsItemRelatedItemError { meta: generic, kind: crate::error::DisassociateOpsItemRelatedItemErrorKind::OpsItemRelatedItemAssociationNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::ops_item_related_item_association_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_related_item_association_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateOpsItemRelatedItemError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DisassociateOpsItemRelatedItemError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_ops_item_related_item_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateOpsItemRelatedItemOutput,
    crate::error::DisassociateOpsItemRelatedItemError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::disassociate_ops_item_related_item_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_automation_execution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAutomationExecutionOutput,
    crate::error::GetAutomationExecutionError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetAutomationExecutionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetAutomationExecutionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AutomationExecutionNotFoundException" => crate::error::GetAutomationExecutionError {
            meta: generic,
            kind:
                crate::error::GetAutomationExecutionErrorKind::AutomationExecutionNotFoundException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::automation_execution_not_found_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_crate_error_automation_execution_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetAutomationExecutionError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InternalServerError" => crate::error::GetAutomationExecutionError {
            meta: generic,
            kind: crate::error::GetAutomationExecutionErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetAutomationExecutionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetAutomationExecutionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_automation_execution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAutomationExecutionOutput,
    crate::error::GetAutomationExecutionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_automation_execution_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_automation_execution(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetAutomationExecutionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_calendar_state_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetCalendarStateOutput, crate::error::GetCalendarStateError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetCalendarStateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetCalendarStateError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetCalendarStateError {
            meta: generic,
            kind: crate::error::GetCalendarStateErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetCalendarStateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDocument" => {
            crate::error::GetCalendarStateError {
                meta: generic,
                kind: crate::error::GetCalendarStateErrorKind::InvalidDocument({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_document::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::GetCalendarStateError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidDocumentType" => crate::error::GetCalendarStateError {
            meta: generic,
            kind: crate::error::GetCalendarStateErrorKind::InvalidDocumentType({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_type_json_err(response.body().as_ref(), output).map_err(crate::error::GetCalendarStateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnsupportedCalendarException" => crate::error::GetCalendarStateError {
            meta: generic,
            kind: crate::error::GetCalendarStateErrorKind::UnsupportedCalendarException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unsupported_calendar_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_calendar_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCalendarStateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetCalendarStateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_calendar_state_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetCalendarStateOutput, crate::error::GetCalendarStateError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_calendar_state_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_calendar_state(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetCalendarStateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_command_invocation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCommandInvocationOutput,
    crate::error::GetCommandInvocationError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetCommandInvocationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetCommandInvocationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetCommandInvocationError {
            meta: generic,
            kind: crate::error::GetCommandInvocationErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommandInvocationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidCommandId" => {
            crate::error::GetCommandInvocationError {
                meta: generic,
                kind: crate::error::GetCommandInvocationErrorKind::InvalidCommandId({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_command_id::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_command_id_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommandInvocationError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidInstanceId" => crate::error::GetCommandInvocationError {
            meta: generic,
            kind: crate::error::GetCommandInvocationErrorKind::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommandInvocationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidPluginName" => crate::error::GetCommandInvocationError {
            meta: generic,
            kind: crate::error::GetCommandInvocationErrorKind::InvalidPluginName({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_plugin_name::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_plugin_name_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommandInvocationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvocationDoesNotExist" => crate::error::GetCommandInvocationError {
            meta: generic,
            kind: crate::error::GetCommandInvocationErrorKind::InvocationDoesNotExist({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invocation_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invocation_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommandInvocationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetCommandInvocationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_command_invocation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCommandInvocationOutput,
    crate::error::GetCommandInvocationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_command_invocation_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_command_invocation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetCommandInvocationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_connection_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetConnectionStatusOutput,
    crate::error::GetConnectionStatusError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetConnectionStatusError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetConnectionStatusError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetConnectionStatusError {
            meta: generic,
            kind: crate::error::GetConnectionStatusErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetConnectionStatusError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetConnectionStatusError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_connection_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetConnectionStatusOutput,
    crate::error::GetConnectionStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_connection_status_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_connection_status(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetConnectionStatusError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_default_patch_baseline_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDefaultPatchBaselineOutput,
    crate::error::GetDefaultPatchBaselineError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetDefaultPatchBaselineError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetDefaultPatchBaselineError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetDefaultPatchBaselineError {
            meta: generic,
            kind: crate::error::GetDefaultPatchBaselineErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetDefaultPatchBaselineError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetDefaultPatchBaselineError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_default_patch_baseline_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDefaultPatchBaselineOutput,
    crate::error::GetDefaultPatchBaselineError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_default_patch_baseline_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_default_patch_baseline(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetDefaultPatchBaselineError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_deployable_patch_snapshot_for_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDeployablePatchSnapshotForInstanceOutput,
    crate::error::GetDeployablePatchSnapshotForInstanceError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetDeployablePatchSnapshotForInstanceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::GetDeployablePatchSnapshotForInstanceError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetDeployablePatchSnapshotForInstanceError { meta: generic, kind: crate::error::GetDeployablePatchSnapshotForInstanceErrorKind::InternalServerError({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetDeployablePatchSnapshotForInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedFeatureRequiredException" => crate::error::GetDeployablePatchSnapshotForInstanceError { meta: generic, kind: crate::error::GetDeployablePatchSnapshotForInstanceErrorKind::UnsupportedFeatureRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::unsupported_feature_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_feature_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDeployablePatchSnapshotForInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedOperatingSystem" => crate::error::GetDeployablePatchSnapshotForInstanceError { meta: generic, kind: crate::error::GetDeployablePatchSnapshotForInstanceErrorKind::UnsupportedOperatingSystem({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::unsupported_operating_system::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_operating_system_json_err(response.body().as_ref(), output).map_err(crate::error::GetDeployablePatchSnapshotForInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetDeployablePatchSnapshotForInstanceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_deployable_patch_snapshot_for_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDeployablePatchSnapshotForInstanceOutput,
    crate::error::GetDeployablePatchSnapshotForInstanceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_deployable_patch_snapshot_for_instance_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_deployable_patch_snapshot_for_instance(response.body().as_ref(), output).map_err(crate::error::GetDeployablePatchSnapshotForInstanceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_document_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDocumentOutput, crate::error::GetDocumentError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetDocumentError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDocumentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetDocumentError {
            meta: generic,
            kind: crate::error::GetDocumentErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDocument" => {
            crate::error::GetDocumentError {
                meta: generic,
                kind: crate::error::GetDocumentErrorKind::InvalidDocument({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_document::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::GetDocumentError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidDocumentVersion" => crate::error::GetDocumentError {
            meta: generic,
            kind: crate::error::GetDocumentErrorKind::InvalidDocumentVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::GetDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetDocumentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_document_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDocumentOutput, crate::error::GetDocumentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_document_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_document(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetDocumentError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_inventory_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetInventoryOutput, crate::error::GetInventoryError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetInventoryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetInventoryError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetInventoryError {
            meta: generic,
            kind: crate::error::GetInventoryErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetInventoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidAggregatorException" => crate::error::GetInventoryError {
            meta: generic,
            kind: crate::error::GetInventoryErrorKind::InvalidAggregatorException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_aggregator_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_aggregator_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInventoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidFilter" => crate::error::GetInventoryError {
            meta: generic,
            kind: crate::error::GetInventoryErrorKind::InvalidFilter({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::GetInventoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInventoryGroupException" => crate::error::GetInventoryError {
            meta: generic,
            kind: crate::error::GetInventoryErrorKind::InvalidInventoryGroupException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_inventory_group_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_inventory_group_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInventoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextToken" => {
            crate::error::GetInventoryError {
                meta: generic,
                kind: crate::error::GetInventoryErrorKind::InvalidNextToken({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::GetInventoryError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidResultAttributeException" => crate::error::GetInventoryError {
            meta: generic,
            kind: crate::error::GetInventoryErrorKind::InvalidResultAttributeException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_result_attribute_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_result_attribute_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInventoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidTypeNameException" => crate::error::GetInventoryError {
            meta: generic,
            kind: crate::error::GetInventoryErrorKind::InvalidTypeNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_type_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_type_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInventoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetInventoryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_inventory_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetInventoryOutput, crate::error::GetInventoryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_inventory_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_inventory(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetInventoryError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_inventory_schema_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetInventorySchemaOutput,
    crate::error::GetInventorySchemaError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetInventorySchemaError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetInventorySchemaError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetInventorySchemaError {
            meta: generic,
            kind: crate::error::GetInventorySchemaErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetInventorySchemaError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextToken" => {
            crate::error::GetInventorySchemaError {
                meta: generic,
                kind: crate::error::GetInventorySchemaErrorKind::InvalidNextToken({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::GetInventorySchemaError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidTypeNameException" => crate::error::GetInventorySchemaError {
            meta: generic,
            kind: crate::error::GetInventorySchemaErrorKind::InvalidTypeNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_type_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_type_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInventorySchemaError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetInventorySchemaError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_inventory_schema_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetInventorySchemaOutput,
    crate::error::GetInventorySchemaError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_inventory_schema_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_inventory_schema(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetInventorySchemaError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetMaintenanceWindowOutput,
    crate::error::GetMaintenanceWindowError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetMaintenanceWindowError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetMaintenanceWindowError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::GetMaintenanceWindowError {
            meta: generic,
            kind: crate::error::GetMaintenanceWindowErrorKind::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::GetMaintenanceWindowError {
            meta: generic,
            kind: crate::error::GetMaintenanceWindowErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetMaintenanceWindowError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetMaintenanceWindowOutput,
    crate::error::GetMaintenanceWindowError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_maintenance_window_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_maintenance_window(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetMaintenanceWindowError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_execution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetMaintenanceWindowExecutionOutput,
    crate::error::GetMaintenanceWindowExecutionError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetMaintenanceWindowExecutionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetMaintenanceWindowExecutionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::GetMaintenanceWindowExecutionError {
            meta: generic,
            kind: crate::error::GetMaintenanceWindowExecutionErrorKind::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowExecutionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::GetMaintenanceWindowExecutionError {
            meta: generic,
            kind: crate::error::GetMaintenanceWindowExecutionErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowExecutionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetMaintenanceWindowExecutionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_execution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetMaintenanceWindowExecutionOutput,
    crate::error::GetMaintenanceWindowExecutionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_maintenance_window_execution_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_get_maintenance_window_execution(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::GetMaintenanceWindowExecutionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_execution_task_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetMaintenanceWindowExecutionTaskOutput,
    crate::error::GetMaintenanceWindowExecutionTaskError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetMaintenanceWindowExecutionTaskError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetMaintenanceWindowExecutionTaskError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::GetMaintenanceWindowExecutionTaskError {
            meta: generic,
            kind: crate::error::GetMaintenanceWindowExecutionTaskErrorKind::DoesNotExistException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::does_not_exist_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowExecutionTaskError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "InternalServerError" => crate::error::GetMaintenanceWindowExecutionTaskError {
            meta: generic,
            kind: crate::error::GetMaintenanceWindowExecutionTaskErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowExecutionTaskError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetMaintenanceWindowExecutionTaskError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_execution_task_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetMaintenanceWindowExecutionTaskOutput,
    crate::error::GetMaintenanceWindowExecutionTaskError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_maintenance_window_execution_task_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_maintenance_window_execution_task(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowExecutionTaskError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_execution_task_invocation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetMaintenanceWindowExecutionTaskInvocationOutput,
    crate::error::GetMaintenanceWindowExecutionTaskInvocationError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetMaintenanceWindowExecutionTaskInvocationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::GetMaintenanceWindowExecutionTaskInvocationError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::GetMaintenanceWindowExecutionTaskInvocationError { meta: generic, kind: crate::error::GetMaintenanceWindowExecutionTaskInvocationErrorKind::DoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowExecutionTaskInvocationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServerError" => crate::error::GetMaintenanceWindowExecutionTaskInvocationError { meta: generic, kind: crate::error::GetMaintenanceWindowExecutionTaskInvocationErrorKind::InternalServerError({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowExecutionTaskInvocationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetMaintenanceWindowExecutionTaskInvocationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_execution_task_invocation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetMaintenanceWindowExecutionTaskInvocationOutput,
    crate::error::GetMaintenanceWindowExecutionTaskInvocationError,
> {
    Ok({
        #[allow(unused_mut)]let mut output = crate::output::get_maintenance_window_execution_task_invocation_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_maintenance_window_execution_task_invocation(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowExecutionTaskInvocationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_task_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetMaintenanceWindowTaskOutput,
    crate::error::GetMaintenanceWindowTaskError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetMaintenanceWindowTaskError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetMaintenanceWindowTaskError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::GetMaintenanceWindowTaskError {
            meta: generic,
            kind: crate::error::GetMaintenanceWindowTaskErrorKind::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowTaskError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::GetMaintenanceWindowTaskError {
            meta: generic,
            kind: crate::error::GetMaintenanceWindowTaskErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowTaskError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetMaintenanceWindowTaskError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_task_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetMaintenanceWindowTaskOutput,
    crate::error::GetMaintenanceWindowTaskError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_maintenance_window_task_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_maintenance_window_task(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetMaintenanceWindowTaskError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ops_item_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetOpsItemOutput, crate::error::GetOpsItemError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetOpsItemError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetOpsItemError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetOpsItemError {
            meta: generic,
            kind: crate::error::GetOpsItemErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsItemError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OpsItemNotFoundException" => crate::error::GetOpsItemError {
            meta: generic,
            kind: crate::error::GetOpsItemErrorKind::OpsItemNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsItemError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetOpsItemError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ops_item_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetOpsItemOutput, crate::error::GetOpsItemError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_ops_item_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_ops_item(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetOpsItemError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ops_metadata_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetOpsMetadataOutput, crate::error::GetOpsMetadataError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetOpsMetadataError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetOpsMetadataError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetOpsMetadataError {
            meta: generic,
            kind: crate::error::GetOpsMetadataErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OpsMetadataInvalidArgumentException" => crate::error::GetOpsMetadataError {
            meta: generic,
            kind: crate::error::GetOpsMetadataErrorKind::OpsMetadataInvalidArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_metadata_invalid_argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_invalid_argument_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OpsMetadataNotFoundException" => crate::error::GetOpsMetadataError {
            meta: generic,
            kind: crate::error::GetOpsMetadataErrorKind::OpsMetadataNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_metadata_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetOpsMetadataError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ops_metadata_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetOpsMetadataOutput, crate::error::GetOpsMetadataError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_ops_metadata_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_ops_metadata(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetOpsMetadataError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ops_summary_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetOpsSummaryOutput, crate::error::GetOpsSummaryError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetOpsSummaryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetOpsSummaryError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetOpsSummaryError {
            meta: generic,
            kind: crate::error::GetOpsSummaryErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsSummaryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidAggregatorException" => crate::error::GetOpsSummaryError {
            meta: generic,
            kind: crate::error::GetOpsSummaryErrorKind::InvalidAggregatorException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_aggregator_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_aggregator_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsSummaryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidFilter" => crate::error::GetOpsSummaryError {
            meta: generic,
            kind: crate::error::GetOpsSummaryErrorKind::InvalidFilter({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::GetOpsSummaryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextToken" => {
            crate::error::GetOpsSummaryError {
                meta: generic,
                kind: crate::error::GetOpsSummaryErrorKind::InvalidNextToken({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsSummaryError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidTypeNameException" => crate::error::GetOpsSummaryError {
            meta: generic,
            kind: crate::error::GetOpsSummaryErrorKind::InvalidTypeNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_type_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_type_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsSummaryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceDataSyncNotFoundException" => crate::error::GetOpsSummaryError {
            meta: generic,
            kind: crate::error::GetOpsSummaryErrorKind::ResourceDataSyncNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_data_sync_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_data_sync_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsSummaryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetOpsSummaryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ops_summary_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetOpsSummaryOutput, crate::error::GetOpsSummaryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_ops_summary_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_ops_summary(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetOpsSummaryError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_parameter_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetParameterOutput, crate::error::GetParameterError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetParameterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetParameterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetParameterError {
            meta: generic,
            kind: crate::error::GetParameterErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetParameterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidKeyId" => crate::error::GetParameterError {
            meta: generic,
            kind: crate::error::GetParameterErrorKind::InvalidKeyId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_key_id::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_invalid_key_id_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::GetParameterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ParameterNotFound" => crate::error::GetParameterError {
            meta: generic,
            kind: crate::error::GetParameterErrorKind::ParameterNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::GetParameterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ParameterVersionNotFound" => crate::error::GetParameterError {
            meta: generic,
            kind: crate::error::GetParameterErrorKind::ParameterVersionNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_version_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_version_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::GetParameterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetParameterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_parameter_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetParameterOutput, crate::error::GetParameterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_parameter_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_parameter(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetParameterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_parameter_history_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetParameterHistoryOutput,
    crate::error::GetParameterHistoryError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetParameterHistoryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetParameterHistoryError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetParameterHistoryError {
            meta: generic,
            kind: crate::error::GetParameterHistoryErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetParameterHistoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidKeyId" => crate::error::GetParameterHistoryError {
            meta: generic,
            kind: crate::error::GetParameterHistoryErrorKind::InvalidKeyId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_key_id::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_invalid_key_id_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::GetParameterHistoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextToken" => {
            crate::error::GetParameterHistoryError {
                meta: generic,
                kind: crate::error::GetParameterHistoryErrorKind::InvalidNextToken({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::GetParameterHistoryError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "ParameterNotFound" => crate::error::GetParameterHistoryError {
            meta: generic,
            kind: crate::error::GetParameterHistoryErrorKind::ParameterNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::GetParameterHistoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetParameterHistoryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_parameter_history_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetParameterHistoryOutput,
    crate::error::GetParameterHistoryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_parameter_history_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_parameter_history(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetParameterHistoryError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_parameters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetParametersOutput, crate::error::GetParametersError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetParametersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetParametersError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetParametersError {
            meta: generic,
            kind: crate::error::GetParametersErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetParametersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidKeyId" => crate::error::GetParametersError {
            meta: generic,
            kind: crate::error::GetParametersErrorKind::InvalidKeyId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_key_id::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_invalid_key_id_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::GetParametersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetParametersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_parameters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetParametersOutput, crate::error::GetParametersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_parameters_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_parameters(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetParametersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_parameters_by_path_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetParametersByPathOutput,
    crate::error::GetParametersByPathError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetParametersByPathError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetParametersByPathError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetParametersByPathError {
            meta: generic,
            kind: crate::error::GetParametersByPathErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetParametersByPathError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidFilterKey" => {
            crate::error::GetParametersByPathError {
                meta: generic,
                kind: crate::error::GetParametersByPathErrorKind::InvalidFilterKey({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_filter_key::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(response.body().as_ref(), output).map_err(crate::error::GetParametersByPathError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidFilterOption" => crate::error::GetParametersByPathError {
            meta: generic,
            kind: crate::error::GetParametersByPathErrorKind::InvalidFilterOption({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_option::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_option_json_err(response.body().as_ref(), output).map_err(crate::error::GetParametersByPathError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidFilterValue" => crate::error::GetParametersByPathError {
            meta: generic,
            kind: crate::error::GetParametersByPathErrorKind::InvalidFilterValue({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_value::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_value_json_err(response.body().as_ref(), output).map_err(crate::error::GetParametersByPathError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidKeyId" => crate::error::GetParametersByPathError {
            meta: generic,
            kind: crate::error::GetParametersByPathErrorKind::InvalidKeyId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_key_id::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_invalid_key_id_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::GetParametersByPathError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextToken" => {
            crate::error::GetParametersByPathError {
                meta: generic,
                kind: crate::error::GetParametersByPathErrorKind::InvalidNextToken({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::GetParametersByPathError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::GetParametersByPathError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_parameters_by_path_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetParametersByPathOutput,
    crate::error::GetParametersByPathError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_parameters_by_path_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_parameters_by_path(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetParametersByPathError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_patch_baseline_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetPatchBaselineOutput, crate::error::GetPatchBaselineError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetPatchBaselineError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetPatchBaselineError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::GetPatchBaselineError {
            meta: generic,
            kind: crate::error::GetPatchBaselineErrorKind::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPatchBaselineError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::GetPatchBaselineError {
            meta: generic,
            kind: crate::error::GetPatchBaselineErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetPatchBaselineError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidResourceId" => crate::error::GetPatchBaselineError {
            meta: generic,
            kind: crate::error::GetPatchBaselineErrorKind::InvalidResourceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::GetPatchBaselineError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetPatchBaselineError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_patch_baseline_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetPatchBaselineOutput, crate::error::GetPatchBaselineError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_patch_baseline_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_patch_baseline(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetPatchBaselineError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_patch_baseline_for_patch_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetPatchBaselineForPatchGroupOutput,
    crate::error::GetPatchBaselineForPatchGroupError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetPatchBaselineForPatchGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetPatchBaselineForPatchGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetPatchBaselineForPatchGroupError {
            meta: generic,
            kind: crate::error::GetPatchBaselineForPatchGroupErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetPatchBaselineForPatchGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetPatchBaselineForPatchGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_patch_baseline_for_patch_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetPatchBaselineForPatchGroupOutput,
    crate::error::GetPatchBaselineForPatchGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_patch_baseline_for_patch_group_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_get_patch_baseline_for_patch_group(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::GetPatchBaselineForPatchGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_service_setting_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetServiceSettingOutput, crate::error::GetServiceSettingError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetServiceSettingError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetServiceSettingError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetServiceSettingError {
            meta: generic,
            kind: crate::error::GetServiceSettingErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetServiceSettingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceSettingNotFound" => crate::error::GetServiceSettingError {
            meta: generic,
            kind: crate::error::GetServiceSettingErrorKind::ServiceSettingNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_setting_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_setting_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::GetServiceSettingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetServiceSettingError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_service_setting_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetServiceSettingOutput, crate::error::GetServiceSettingError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_service_setting_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_service_setting(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetServiceSettingError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_label_parameter_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::LabelParameterVersionOutput,
    crate::error::LabelParameterVersionError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::LabelParameterVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::LabelParameterVersionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::LabelParameterVersionError {
            meta: generic,
            kind: crate::error::LabelParameterVersionErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::LabelParameterVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ParameterNotFound" => crate::error::LabelParameterVersionError {
            meta: generic,
            kind: crate::error::LabelParameterVersionErrorKind::ParameterNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::LabelParameterVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ParameterVersionLabelLimitExceeded" => {
            crate::error::LabelParameterVersionError {
                meta: generic,
                kind:
                    crate::error::LabelParameterVersionErrorKind::ParameterVersionLabelLimitExceeded(
                        {
                            #[allow(unused_mut)]
                            let mut tmp = {
                                #[allow(unused_mut)]let mut output = crate::error::parameter_version_label_limit_exceeded::Builder::default();
                                let _ = response;
                                output = crate::json_deser::deser_structure_crate_error_parameter_version_label_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::LabelParameterVersionError::unhandled)?;
                                output.build()
                            };
                            if (&tmp.message).is_none() {
                                tmp.message = _error_message;
                            }
                            tmp
                        },
                    ),
            }
        }
        "ParameterVersionNotFound" => crate::error::LabelParameterVersionError {
            meta: generic,
            kind: crate::error::LabelParameterVersionErrorKind::ParameterVersionNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_version_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_version_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::LabelParameterVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TooManyUpdates" => {
            crate::error::LabelParameterVersionError {
                meta: generic,
                kind: crate::error::LabelParameterVersionErrorKind::TooManyUpdates({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_updates::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(response.body().as_ref(), output).map_err(crate::error::LabelParameterVersionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::LabelParameterVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_label_parameter_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::LabelParameterVersionOutput,
    crate::error::LabelParameterVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::label_parameter_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_label_parameter_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::LabelParameterVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_associations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListAssociationsOutput, crate::error::ListAssociationsError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListAssociationsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListAssociationsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListAssociationsError {
            meta: generic,
            kind: crate::error::ListAssociationsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociationsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextToken" => {
            crate::error::ListAssociationsError {
                meta: generic,
                kind: crate::error::ListAssociationsErrorKind::InvalidNextToken({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociationsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::ListAssociationsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_associations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListAssociationsOutput, crate::error::ListAssociationsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_associations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_associations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListAssociationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_association_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListAssociationVersionsOutput,
    crate::error::ListAssociationVersionsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListAssociationVersionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListAssociationVersionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AssociationDoesNotExist" => crate::error::ListAssociationVersionsError {
            meta: generic,
            kind: crate::error::ListAssociationVersionsErrorKind::AssociationDoesNotExist({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociationVersionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::ListAssociationVersionsError {
            meta: generic,
            kind: crate::error::ListAssociationVersionsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociationVersionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextToken" => {
            crate::error::ListAssociationVersionsError {
                meta: generic,
                kind: crate::error::ListAssociationVersionsErrorKind::InvalidNextToken({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociationVersionsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::ListAssociationVersionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_association_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListAssociationVersionsOutput,
    crate::error::ListAssociationVersionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_association_versions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_association_versions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListAssociationVersionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_command_invocations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListCommandInvocationsOutput,
    crate::error::ListCommandInvocationsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListCommandInvocationsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListCommandInvocationsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListCommandInvocationsError {
            meta: generic,
            kind: crate::error::ListCommandInvocationsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListCommandInvocationsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidCommandId" => {
            crate::error::ListCommandInvocationsError {
                meta: generic,
                kind: crate::error::ListCommandInvocationsErrorKind::InvalidCommandId({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_command_id::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_command_id_json_err(response.body().as_ref(), output).map_err(crate::error::ListCommandInvocationsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidFilterKey" => {
            crate::error::ListCommandInvocationsError {
                meta: generic,
                kind: crate::error::ListCommandInvocationsErrorKind::InvalidFilterKey({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_filter_key::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(response.body().as_ref(), output).map_err(crate::error::ListCommandInvocationsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidInstanceId" => crate::error::ListCommandInvocationsError {
            meta: generic,
            kind: crate::error::ListCommandInvocationsErrorKind::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::ListCommandInvocationsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextToken" => {
            crate::error::ListCommandInvocationsError {
                meta: generic,
                kind: crate::error::ListCommandInvocationsErrorKind::InvalidNextToken({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::ListCommandInvocationsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::ListCommandInvocationsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_command_invocations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListCommandInvocationsOutput,
    crate::error::ListCommandInvocationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_command_invocations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_command_invocations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListCommandInvocationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_commands_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListCommandsOutput, crate::error::ListCommandsError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListCommandsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListCommandsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListCommandsError {
            meta: generic,
            kind: crate::error::ListCommandsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListCommandsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidCommandId" => {
            crate::error::ListCommandsError {
                meta: generic,
                kind: crate::error::ListCommandsErrorKind::InvalidCommandId({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_command_id::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_command_id_json_err(response.body().as_ref(), output).map_err(crate::error::ListCommandsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidFilterKey" => {
            crate::error::ListCommandsError {
                meta: generic,
                kind: crate::error::ListCommandsErrorKind::InvalidFilterKey({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_filter_key::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(response.body().as_ref(), output).map_err(crate::error::ListCommandsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidInstanceId" => crate::error::ListCommandsError {
            meta: generic,
            kind: crate::error::ListCommandsErrorKind::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::ListCommandsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextToken" => {
            crate::error::ListCommandsError {
                meta: generic,
                kind: crate::error::ListCommandsErrorKind::InvalidNextToken({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::ListCommandsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::ListCommandsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_commands_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListCommandsOutput, crate::error::ListCommandsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_commands_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_commands(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListCommandsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_compliance_items_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListComplianceItemsOutput,
    crate::error::ListComplianceItemsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListComplianceItemsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListComplianceItemsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListComplianceItemsError {
            meta: generic,
            kind: crate::error::ListComplianceItemsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListComplianceItemsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidFilter" => crate::error::ListComplianceItemsError {
            meta: generic,
            kind: crate::error::ListComplianceItemsErrorKind::InvalidFilter({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::ListComplianceItemsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextToken" => {
            crate::error::ListComplianceItemsError {
                meta: generic,
                kind: crate::error::ListComplianceItemsErrorKind::InvalidNextToken({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::ListComplianceItemsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidResourceId" => crate::error::ListComplianceItemsError {
            meta: generic,
            kind: crate::error::ListComplianceItemsErrorKind::InvalidResourceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::ListComplianceItemsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidResourceType" => crate::error::ListComplianceItemsError {
            meta: generic,
            kind: crate::error::ListComplianceItemsErrorKind::InvalidResourceType({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_type_json_err(response.body().as_ref(), output).map_err(crate::error::ListComplianceItemsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListComplianceItemsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_compliance_items_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListComplianceItemsOutput,
    crate::error::ListComplianceItemsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_compliance_items_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_compliance_items(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListComplianceItemsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_compliance_summaries_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListComplianceSummariesOutput,
    crate::error::ListComplianceSummariesError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListComplianceSummariesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListComplianceSummariesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListComplianceSummariesError {
            meta: generic,
            kind: crate::error::ListComplianceSummariesErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListComplianceSummariesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidFilter" => crate::error::ListComplianceSummariesError {
            meta: generic,
            kind: crate::error::ListComplianceSummariesErrorKind::InvalidFilter({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::ListComplianceSummariesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextToken" => {
            crate::error::ListComplianceSummariesError {
                meta: generic,
                kind: crate::error::ListComplianceSummariesErrorKind::InvalidNextToken({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::ListComplianceSummariesError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::ListComplianceSummariesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_compliance_summaries_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListComplianceSummariesOutput,
    crate::error::ListComplianceSummariesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_compliance_summaries_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_compliance_summaries(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListComplianceSummariesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_document_metadata_history_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDocumentMetadataHistoryOutput,
    crate::error::ListDocumentMetadataHistoryError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListDocumentMetadataHistoryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListDocumentMetadataHistoryError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListDocumentMetadataHistoryError {
            meta: generic,
            kind: crate::error::ListDocumentMetadataHistoryErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListDocumentMetadataHistoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDocument" => {
            crate::error::ListDocumentMetadataHistoryError {
                meta: generic,
                kind: crate::error::ListDocumentMetadataHistoryErrorKind::InvalidDocument({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_document::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::ListDocumentMetadataHistoryError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidDocumentVersion" => crate::error::ListDocumentMetadataHistoryError {
            meta: generic,
            kind: crate::error::ListDocumentMetadataHistoryErrorKind::InvalidDocumentVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::ListDocumentMetadataHistoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextToken" => {
            crate::error::ListDocumentMetadataHistoryError {
                meta: generic,
                kind: crate::error::ListDocumentMetadataHistoryErrorKind::InvalidNextToken({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::ListDocumentMetadataHistoryError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::ListDocumentMetadataHistoryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_document_metadata_history_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDocumentMetadataHistoryOutput,
    crate::error::ListDocumentMetadataHistoryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_document_metadata_history_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_document_metadata_history(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListDocumentMetadataHistoryError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_documents_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListDocumentsOutput, crate::error::ListDocumentsError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListDocumentsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListDocumentsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListDocumentsError {
            meta: generic,
            kind: crate::error::ListDocumentsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListDocumentsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidFilterKey" => {
            crate::error::ListDocumentsError {
                meta: generic,
                kind: crate::error::ListDocumentsErrorKind::InvalidFilterKey({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_filter_key::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(response.body().as_ref(), output).map_err(crate::error::ListDocumentsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidNextToken" => {
            crate::error::ListDocumentsError {
                meta: generic,
                kind: crate::error::ListDocumentsErrorKind::InvalidNextToken({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::ListDocumentsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::ListDocumentsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_documents_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListDocumentsOutput, crate::error::ListDocumentsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_documents_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_documents(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListDocumentsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_document_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDocumentVersionsOutput,
    crate::error::ListDocumentVersionsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListDocumentVersionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListDocumentVersionsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListDocumentVersionsError {
            meta: generic,
            kind: crate::error::ListDocumentVersionsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListDocumentVersionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDocument" => {
            crate::error::ListDocumentVersionsError {
                meta: generic,
                kind: crate::error::ListDocumentVersionsErrorKind::InvalidDocument({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_document::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::ListDocumentVersionsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidNextToken" => {
            crate::error::ListDocumentVersionsError {
                meta: generic,
                kind: crate::error::ListDocumentVersionsErrorKind::InvalidNextToken({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::ListDocumentVersionsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::ListDocumentVersionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_document_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDocumentVersionsOutput,
    crate::error::ListDocumentVersionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_document_versions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_document_versions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListDocumentVersionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_inventory_entries_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListInventoryEntriesOutput,
    crate::error::ListInventoryEntriesError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListInventoryEntriesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListInventoryEntriesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListInventoryEntriesError {
            meta: generic,
            kind: crate::error::ListInventoryEntriesErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListInventoryEntriesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidFilter" => crate::error::ListInventoryEntriesError {
            meta: generic,
            kind: crate::error::ListInventoryEntriesErrorKind::InvalidFilter({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::ListInventoryEntriesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInstanceId" => crate::error::ListInventoryEntriesError {
            meta: generic,
            kind: crate::error::ListInventoryEntriesErrorKind::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::ListInventoryEntriesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextToken" => {
            crate::error::ListInventoryEntriesError {
                meta: generic,
                kind: crate::error::ListInventoryEntriesErrorKind::InvalidNextToken({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::ListInventoryEntriesError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidTypeNameException" => crate::error::ListInventoryEntriesError {
            meta: generic,
            kind: crate::error::ListInventoryEntriesErrorKind::InvalidTypeNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_type_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_type_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListInventoryEntriesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListInventoryEntriesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_inventory_entries_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListInventoryEntriesOutput,
    crate::error::ListInventoryEntriesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_inventory_entries_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_inventory_entries(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListInventoryEntriesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_ops_item_events_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListOpsItemEventsOutput, crate::error::ListOpsItemEventsError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListOpsItemEventsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListOpsItemEventsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListOpsItemEventsError {
            meta: generic,
            kind: crate::error::ListOpsItemEventsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListOpsItemEventsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OpsItemInvalidParameterException" => crate::error::ListOpsItemEventsError {
            meta: generic,
            kind: crate::error::ListOpsItemEventsErrorKind::OpsItemInvalidParameterException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_item_invalid_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOpsItemEventsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OpsItemLimitExceededException" => crate::error::ListOpsItemEventsError {
            meta: generic,
            kind: crate::error::ListOpsItemEventsErrorKind::OpsItemLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_item_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOpsItemEventsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OpsItemNotFoundException" => crate::error::ListOpsItemEventsError {
            meta: generic,
            kind: crate::error::ListOpsItemEventsErrorKind::OpsItemNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOpsItemEventsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListOpsItemEventsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_ops_item_events_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListOpsItemEventsOutput, crate::error::ListOpsItemEventsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_ops_item_events_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_ops_item_events(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListOpsItemEventsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_ops_item_related_items_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListOpsItemRelatedItemsOutput,
    crate::error::ListOpsItemRelatedItemsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListOpsItemRelatedItemsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListOpsItemRelatedItemsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListOpsItemRelatedItemsError {
            meta: generic,
            kind: crate::error::ListOpsItemRelatedItemsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListOpsItemRelatedItemsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OpsItemInvalidParameterException" => crate::error::ListOpsItemRelatedItemsError {
            meta: generic,
            kind: crate::error::ListOpsItemRelatedItemsErrorKind::OpsItemInvalidParameterException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::ops_item_invalid_parameter_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_ops_item_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOpsItemRelatedItemsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::ListOpsItemRelatedItemsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_ops_item_related_items_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListOpsItemRelatedItemsOutput,
    crate::error::ListOpsItemRelatedItemsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_ops_item_related_items_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_ops_item_related_items(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListOpsItemRelatedItemsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_ops_metadata_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListOpsMetadataOutput, crate::error::ListOpsMetadataError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListOpsMetadataError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListOpsMetadataError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListOpsMetadataError {
            meta: generic,
            kind: crate::error::ListOpsMetadataErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListOpsMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OpsMetadataInvalidArgumentException" => crate::error::ListOpsMetadataError {
            meta: generic,
            kind: crate::error::ListOpsMetadataErrorKind::OpsMetadataInvalidArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_metadata_invalid_argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_invalid_argument_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOpsMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListOpsMetadataError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_ops_metadata_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListOpsMetadataOutput, crate::error::ListOpsMetadataError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_ops_metadata_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_ops_metadata(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListOpsMetadataError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_resource_compliance_summaries_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListResourceComplianceSummariesOutput,
    crate::error::ListResourceComplianceSummariesError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListResourceComplianceSummariesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListResourceComplianceSummariesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListResourceComplianceSummariesError {
            meta: generic,
            kind: crate::error::ListResourceComplianceSummariesErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListResourceComplianceSummariesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidFilter" => crate::error::ListResourceComplianceSummariesError {
            meta: generic,
            kind: crate::error::ListResourceComplianceSummariesErrorKind::InvalidFilter({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::ListResourceComplianceSummariesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextToken" => {
            crate::error::ListResourceComplianceSummariesError {
                meta: generic,
                kind: crate::error::ListResourceComplianceSummariesErrorKind::InvalidNextToken({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_next_token::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::ListResourceComplianceSummariesError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::ListResourceComplianceSummariesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_resource_compliance_summaries_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListResourceComplianceSummariesOutput,
    crate::error::ListResourceComplianceSummariesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_resource_compliance_summaries_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_list_resource_compliance_summaries(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ListResourceComplianceSummariesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_resource_data_sync_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListResourceDataSyncOutput,
    crate::error::ListResourceDataSyncError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListResourceDataSyncError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListResourceDataSyncError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListResourceDataSyncError { meta: generic, kind: crate::error::ListResourceDataSyncErrorKind::InternalServerError({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListResourceDataSyncError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextToken" => crate::error::ListResourceDataSyncError { meta: generic, kind: crate::error::ListResourceDataSyncErrorKind::InvalidNextToken({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::ListResourceDataSyncError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceDataSyncInvalidConfigurationException" => crate::error::ListResourceDataSyncError { meta: generic, kind: crate::error::ListResourceDataSyncErrorKind::ResourceDataSyncInvalidConfigurationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::resource_data_sync_invalid_configuration_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_data_sync_invalid_configuration_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListResourceDataSyncError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListResourceDataSyncError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_resource_data_sync_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListResourceDataSyncOutput,
    crate::error::ListResourceDataSyncError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_resource_data_sync_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_resource_data_sync(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListResourceDataSyncError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTagsForResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidResourceId" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::InvalidResourceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidResourceType" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::InvalidResourceType({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_type_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListTagsForResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_tags_for_resource_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_tags_for_resource(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_document_permission_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDocumentPermissionOutput,
    crate::error::ModifyDocumentPermissionError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyDocumentPermissionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyDocumentPermissionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DocumentLimitExceeded" => crate::error::ModifyDocumentPermissionError {
            meta: generic,
            kind: crate::error::ModifyDocumentPermissionErrorKind::DocumentLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::document_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_document_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::ModifyDocumentPermissionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DocumentPermissionLimit" => crate::error::ModifyDocumentPermissionError {
            meta: generic,
            kind: crate::error::ModifyDocumentPermissionErrorKind::DocumentPermissionLimit({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::document_permission_limit::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_document_permission_limit_json_err(response.body().as_ref(), output).map_err(crate::error::ModifyDocumentPermissionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::ModifyDocumentPermissionError {
            meta: generic,
            kind: crate::error::ModifyDocumentPermissionErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ModifyDocumentPermissionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDocument" => {
            crate::error::ModifyDocumentPermissionError {
                meta: generic,
                kind: crate::error::ModifyDocumentPermissionErrorKind::InvalidDocument({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_document::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::ModifyDocumentPermissionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidPermissionType" => crate::error::ModifyDocumentPermissionError {
            meta: generic,
            kind: crate::error::ModifyDocumentPermissionErrorKind::InvalidPermissionType({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_permission_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_permission_type_json_err(response.body().as_ref(), output).map_err(crate::error::ModifyDocumentPermissionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyDocumentPermissionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_document_permission_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDocumentPermissionOutput,
    crate::error::ModifyDocumentPermissionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_document_permission_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_compliance_items_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutComplianceItemsOutput,
    crate::error::PutComplianceItemsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutComplianceItemsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutComplianceItemsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ComplianceTypeCountLimitExceededException" => crate::error::PutComplianceItemsError {
            meta: generic,
            kind:
                crate::error::PutComplianceItemsErrorKind::ComplianceTypeCountLimitExceededException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::compliance_type_count_limit_exceeded_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_crate_error_compliance_type_count_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutComplianceItemsError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InternalServerError" => crate::error::PutComplianceItemsError {
            meta: generic,
            kind: crate::error::PutComplianceItemsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::PutComplianceItemsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidItemContentException" => crate::error::PutComplianceItemsError {
            meta: generic,
            kind: crate::error::PutComplianceItemsErrorKind::InvalidItemContentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_item_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_item_content_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutComplianceItemsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidResourceId" => crate::error::PutComplianceItemsError {
            meta: generic,
            kind: crate::error::PutComplianceItemsErrorKind::InvalidResourceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::PutComplianceItemsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidResourceType" => crate::error::PutComplianceItemsError {
            meta: generic,
            kind: crate::error::PutComplianceItemsErrorKind::InvalidResourceType({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_type_json_err(response.body().as_ref(), output).map_err(crate::error::PutComplianceItemsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ItemSizeLimitExceededException" => crate::error::PutComplianceItemsError {
            meta: generic,
            kind: crate::error::PutComplianceItemsErrorKind::ItemSizeLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::item_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_item_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutComplianceItemsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TotalSizeLimitExceededException" => crate::error::PutComplianceItemsError {
            meta: generic,
            kind: crate::error::PutComplianceItemsErrorKind::TotalSizeLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::total_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_total_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutComplianceItemsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::PutComplianceItemsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_compliance_items_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutComplianceItemsOutput,
    crate::error::PutComplianceItemsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_compliance_items_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_inventory_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutInventoryOutput, crate::error::PutInventoryError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutInventoryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutInventoryError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CustomSchemaCountLimitExceededException" => crate::error::PutInventoryError {
            meta: generic,
            kind: crate::error::PutInventoryErrorKind::CustomSchemaCountLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]let mut output = crate::error::custom_schema_count_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_custom_schema_count_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::PutInventoryError {
            meta: generic,
            kind: crate::error::PutInventoryErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInstanceId" => crate::error::PutInventoryError {
            meta: generic,
            kind: crate::error::PutInventoryErrorKind::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInventoryItemContextException" => {
            crate::error::PutInventoryError {
                meta: generic,
                kind: crate::error::PutInventoryErrorKind::InvalidInventoryItemContextException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::invalid_inventory_item_context_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_inventory_item_context_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidItemContentException" => crate::error::PutInventoryError {
            meta: generic,
            kind: crate::error::PutInventoryErrorKind::InvalidItemContentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_item_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_item_content_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidTypeNameException" => crate::error::PutInventoryError {
            meta: generic,
            kind: crate::error::PutInventoryErrorKind::InvalidTypeNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_type_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_type_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ItemContentMismatchException" => crate::error::PutInventoryError {
            meta: generic,
            kind: crate::error::PutInventoryErrorKind::ItemContentMismatchException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::item_content_mismatch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_item_content_mismatch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ItemSizeLimitExceededException" => crate::error::PutInventoryError {
            meta: generic,
            kind: crate::error::PutInventoryErrorKind::ItemSizeLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::item_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_item_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SubTypeCountLimitExceededException" => crate::error::PutInventoryError {
            meta: generic,
            kind: crate::error::PutInventoryErrorKind::SubTypeCountLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::sub_type_count_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_sub_type_count_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TotalSizeLimitExceededException" => crate::error::PutInventoryError {
            meta: generic,
            kind: crate::error::PutInventoryErrorKind::TotalSizeLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::total_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_total_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnsupportedInventoryItemContextException" => crate::error::PutInventoryError {
            meta: generic,
            kind: crate::error::PutInventoryErrorKind::UnsupportedInventoryItemContextException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]let mut output = crate::error::unsupported_inventory_item_context_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_inventory_item_context_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnsupportedInventorySchemaVersionException" => crate::error::PutInventoryError {
            meta: generic,
            kind: crate::error::PutInventoryErrorKind::UnsupportedInventorySchemaVersionException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::unsupported_inventory_schema_version_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_unsupported_inventory_schema_version_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::PutInventoryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_inventory_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutInventoryOutput, crate::error::PutInventoryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_inventory_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_inventory(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutInventoryError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_parameter_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutParameterOutput, crate::error::PutParameterError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutParameterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutParameterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "HierarchyLevelLimitExceededException" => {
            crate::error::PutParameterError {
                meta: generic,
                kind: crate::error::PutParameterErrorKind::HierarchyLevelLimitExceededException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::hierarchy_level_limit_exceeded_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_hierarchy_level_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "HierarchyTypeMismatchException" => crate::error::PutParameterError {
            meta: generic,
            kind: crate::error::PutParameterErrorKind::HierarchyTypeMismatchException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::hierarchy_type_mismatch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_hierarchy_type_mismatch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "IncompatiblePolicyException" => crate::error::PutParameterError {
            meta: generic,
            kind: crate::error::PutParameterErrorKind::IncompatiblePolicyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::incompatible_policy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_incompatible_policy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::PutParameterError {
            meta: generic,
            kind: crate::error::PutParameterErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidAllowedPatternException" => crate::error::PutParameterError {
            meta: generic,
            kind: crate::error::PutParameterErrorKind::InvalidAllowedPatternException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_allowed_pattern_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_allowed_pattern_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidKeyId" => crate::error::PutParameterError {
            meta: generic,
            kind: crate::error::PutParameterErrorKind::InvalidKeyId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_key_id::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_invalid_key_id_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::PutParameterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidPolicyAttributeException" => crate::error::PutParameterError {
            meta: generic,
            kind: crate::error::PutParameterErrorKind::InvalidPolicyAttributeException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_policy_attribute_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_policy_attribute_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidPolicyTypeException" => crate::error::PutParameterError {
            meta: generic,
            kind: crate::error::PutParameterErrorKind::InvalidPolicyTypeException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_policy_type_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_policy_type_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ParameterAlreadyExists" => crate::error::PutParameterError {
            meta: generic,
            kind: crate::error::PutParameterErrorKind::ParameterAlreadyExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_already_exists::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_already_exists_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ParameterLimitExceeded" => crate::error::PutParameterError {
            meta: generic,
            kind: crate::error::PutParameterErrorKind::ParameterLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ParameterMaxVersionLimitExceeded" => crate::error::PutParameterError {
            meta: generic,
            kind: crate::error::PutParameterErrorKind::ParameterMaxVersionLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::parameter_max_version_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_max_version_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ParameterPatternMismatchException" => crate::error::PutParameterError {
            meta: generic,
            kind: crate::error::PutParameterErrorKind::ParameterPatternMismatchException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::parameter_pattern_mismatch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_pattern_mismatch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "PoliciesLimitExceededException" => crate::error::PutParameterError {
            meta: generic,
            kind: crate::error::PutParameterErrorKind::PoliciesLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::policies_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_policies_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TooManyUpdates" => {
            crate::error::PutParameterError {
                meta: generic,
                kind: crate::error::PutParameterErrorKind::TooManyUpdates({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_updates::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnsupportedParameterType" => crate::error::PutParameterError {
            meta: generic,
            kind: crate::error::PutParameterErrorKind::UnsupportedParameterType({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_parameter_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_parameter_type_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::PutParameterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_parameter_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutParameterOutput, crate::error::PutParameterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_parameter_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_parameter(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutParameterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_default_patch_baseline_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RegisterDefaultPatchBaselineOutput,
    crate::error::RegisterDefaultPatchBaselineError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::RegisterDefaultPatchBaselineError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RegisterDefaultPatchBaselineError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::RegisterDefaultPatchBaselineError {
            meta: generic,
            kind: crate::error::RegisterDefaultPatchBaselineErrorKind::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterDefaultPatchBaselineError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::RegisterDefaultPatchBaselineError {
            meta: generic,
            kind: crate::error::RegisterDefaultPatchBaselineErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterDefaultPatchBaselineError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidResourceId" => crate::error::RegisterDefaultPatchBaselineError {
            meta: generic,
            kind: crate::error::RegisterDefaultPatchBaselineErrorKind::InvalidResourceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterDefaultPatchBaselineError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::RegisterDefaultPatchBaselineError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_default_patch_baseline_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RegisterDefaultPatchBaselineOutput,
    crate::error::RegisterDefaultPatchBaselineError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::register_default_patch_baseline_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_register_default_patch_baseline(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::RegisterDefaultPatchBaselineError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_patch_baseline_for_patch_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RegisterPatchBaselineForPatchGroupOutput,
    crate::error::RegisterPatchBaselineForPatchGroupError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::RegisterPatchBaselineForPatchGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RegisterPatchBaselineForPatchGroupError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AlreadyExistsException" => crate::error::RegisterPatchBaselineForPatchGroupError { meta: generic, kind: crate::error::RegisterPatchBaselineForPatchGroupErrorKind::AlreadyExistsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterPatchBaselineForPatchGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DoesNotExistException" => crate::error::RegisterPatchBaselineForPatchGroupError { meta: generic, kind: crate::error::RegisterPatchBaselineForPatchGroupErrorKind::DoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterPatchBaselineForPatchGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServerError" => crate::error::RegisterPatchBaselineForPatchGroupError { meta: generic, kind: crate::error::RegisterPatchBaselineForPatchGroupErrorKind::InternalServerError({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterPatchBaselineForPatchGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidResourceId" => crate::error::RegisterPatchBaselineForPatchGroupError { meta: generic, kind: crate::error::RegisterPatchBaselineForPatchGroupErrorKind::InvalidResourceId({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterPatchBaselineForPatchGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceLimitExceededException" => crate::error::RegisterPatchBaselineForPatchGroupError { meta: generic, kind: crate::error::RegisterPatchBaselineForPatchGroupErrorKind::ResourceLimitExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::resource_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterPatchBaselineForPatchGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RegisterPatchBaselineForPatchGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_patch_baseline_for_patch_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RegisterPatchBaselineForPatchGroupOutput,
    crate::error::RegisterPatchBaselineForPatchGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::register_patch_baseline_for_patch_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_register_patch_baseline_for_patch_group(response.body().as_ref(), output).map_err(crate::error::RegisterPatchBaselineForPatchGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_target_with_maintenance_window_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RegisterTargetWithMaintenanceWindowOutput,
    crate::error::RegisterTargetWithMaintenanceWindowError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::RegisterTargetWithMaintenanceWindowError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RegisterTargetWithMaintenanceWindowError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::RegisterTargetWithMaintenanceWindowError { meta: generic, kind: crate::error::RegisterTargetWithMaintenanceWindowErrorKind::DoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTargetWithMaintenanceWindowError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "IdempotentParameterMismatch" => crate::error::RegisterTargetWithMaintenanceWindowError { meta: generic, kind: crate::error::RegisterTargetWithMaintenanceWindowErrorKind::IdempotentParameterMismatch({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::idempotent_parameter_mismatch::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotent_parameter_mismatch_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTargetWithMaintenanceWindowError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServerError" => crate::error::RegisterTargetWithMaintenanceWindowError { meta: generic, kind: crate::error::RegisterTargetWithMaintenanceWindowErrorKind::InternalServerError({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTargetWithMaintenanceWindowError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceLimitExceededException" => crate::error::RegisterTargetWithMaintenanceWindowError { meta: generic, kind: crate::error::RegisterTargetWithMaintenanceWindowErrorKind::ResourceLimitExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::resource_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTargetWithMaintenanceWindowError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RegisterTargetWithMaintenanceWindowError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_target_with_maintenance_window_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RegisterTargetWithMaintenanceWindowOutput,
    crate::error::RegisterTargetWithMaintenanceWindowError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::register_target_with_maintenance_window_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_register_target_with_maintenance_window(response.body().as_ref(), output).map_err(crate::error::RegisterTargetWithMaintenanceWindowError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_task_with_maintenance_window_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RegisterTaskWithMaintenanceWindowOutput,
    crate::error::RegisterTaskWithMaintenanceWindowError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::RegisterTaskWithMaintenanceWindowError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RegisterTaskWithMaintenanceWindowError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::RegisterTaskWithMaintenanceWindowError { meta: generic, kind: crate::error::RegisterTaskWithMaintenanceWindowErrorKind::DoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTaskWithMaintenanceWindowError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FeatureNotAvailableException" => crate::error::RegisterTaskWithMaintenanceWindowError { meta: generic, kind: crate::error::RegisterTaskWithMaintenanceWindowErrorKind::FeatureNotAvailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::feature_not_available_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_feature_not_available_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTaskWithMaintenanceWindowError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "IdempotentParameterMismatch" => crate::error::RegisterTaskWithMaintenanceWindowError { meta: generic, kind: crate::error::RegisterTaskWithMaintenanceWindowErrorKind::IdempotentParameterMismatch({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::idempotent_parameter_mismatch::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotent_parameter_mismatch_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTaskWithMaintenanceWindowError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServerError" => crate::error::RegisterTaskWithMaintenanceWindowError { meta: generic, kind: crate::error::RegisterTaskWithMaintenanceWindowErrorKind::InternalServerError({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTaskWithMaintenanceWindowError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceLimitExceededException" => crate::error::RegisterTaskWithMaintenanceWindowError { meta: generic, kind: crate::error::RegisterTaskWithMaintenanceWindowErrorKind::ResourceLimitExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::resource_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTaskWithMaintenanceWindowError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RegisterTaskWithMaintenanceWindowError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_task_with_maintenance_window_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RegisterTaskWithMaintenanceWindowOutput,
    crate::error::RegisterTaskWithMaintenanceWindowError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::register_task_with_maintenance_window_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_register_task_with_maintenance_window(response.body().as_ref(), output).map_err(crate::error::RegisterTaskWithMaintenanceWindowError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_tags_from_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveTagsFromResourceOutput,
    crate::error::RemoveTagsFromResourceError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RemoveTagsFromResourceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::RemoveTagsFromResourceError {
            meta: generic,
            kind: crate::error::RemoveTagsFromResourceErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidResourceId" => crate::error::RemoveTagsFromResourceError {
            meta: generic,
            kind: crate::error::RemoveTagsFromResourceErrorKind::InvalidResourceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidResourceType" => crate::error::RemoveTagsFromResourceError {
            meta: generic,
            kind: crate::error::RemoveTagsFromResourceErrorKind::InvalidResourceType({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_type_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TooManyUpdates" => {
            crate::error::RemoveTagsFromResourceError {
                meta: generic,
                kind: crate::error::RemoveTagsFromResourceErrorKind::TooManyUpdates({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_updates::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::RemoveTagsFromResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_tags_from_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveTagsFromResourceOutput,
    crate::error::RemoveTagsFromResourceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_tags_from_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_service_setting_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetServiceSettingOutput,
    crate::error::ResetServiceSettingError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ResetServiceSettingError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ResetServiceSettingError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ResetServiceSettingError {
            meta: generic,
            kind: crate::error::ResetServiceSettingErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ResetServiceSettingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceSettingNotFound" => crate::error::ResetServiceSettingError {
            meta: generic,
            kind: crate::error::ResetServiceSettingErrorKind::ServiceSettingNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_setting_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_setting_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::ResetServiceSettingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TooManyUpdates" => {
            crate::error::ResetServiceSettingError {
                meta: generic,
                kind: crate::error::ResetServiceSettingErrorKind::TooManyUpdates({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_updates::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(response.body().as_ref(), output).map_err(crate::error::ResetServiceSettingError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::ResetServiceSettingError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_service_setting_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetServiceSettingOutput,
    crate::error::ResetServiceSettingError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reset_service_setting_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_reset_service_setting(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ResetServiceSettingError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_resume_session_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ResumeSessionOutput, crate::error::ResumeSessionError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ResumeSessionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ResumeSessionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::ResumeSessionError {
            meta: generic,
            kind: crate::error::ResumeSessionErrorKind::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ResumeSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::ResumeSessionError {
            meta: generic,
            kind: crate::error::ResumeSessionErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ResumeSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ResumeSessionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_resume_session_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ResumeSessionOutput, crate::error::ResumeSessionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::resume_session_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_resume_session(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ResumeSessionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_automation_signal_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SendAutomationSignalOutput,
    crate::error::SendAutomationSignalError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::SendAutomationSignalError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::SendAutomationSignalError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AutomationExecutionNotFoundException" => crate::error::SendAutomationSignalError {
            meta: generic,
            kind: crate::error::SendAutomationSignalErrorKind::AutomationExecutionNotFoundException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::automation_execution_not_found_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_automation_execution_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SendAutomationSignalError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "AutomationStepNotFoundException" => crate::error::SendAutomationSignalError {
            meta: generic,
            kind: crate::error::SendAutomationSignalErrorKind::AutomationStepNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::automation_step_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_step_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SendAutomationSignalError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::SendAutomationSignalError {
            meta: generic,
            kind: crate::error::SendAutomationSignalErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::SendAutomationSignalError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidAutomationSignalException" => crate::error::SendAutomationSignalError {
            meta: generic,
            kind: crate::error::SendAutomationSignalErrorKind::InvalidAutomationSignalException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_automation_signal_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_automation_signal_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SendAutomationSignalError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::SendAutomationSignalError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_automation_signal_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SendAutomationSignalOutput,
    crate::error::SendAutomationSignalError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::send_automation_signal_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_command_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SendCommandOutput, crate::error::SendCommandError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::SendCommandError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::SendCommandError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DuplicateInstanceId" => crate::error::SendCommandError {
            meta: generic,
            kind: crate::error::SendCommandErrorKind::DuplicateInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::duplicate_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_duplicate_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::SendCommandError {
            meta: generic,
            kind: crate::error::SendCommandErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDocument" => {
            crate::error::SendCommandError {
                meta: generic,
                kind: crate::error::SendCommandErrorKind::InvalidDocument({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_document::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidDocumentVersion" => crate::error::SendCommandError {
            meta: generic,
            kind: crate::error::SendCommandErrorKind::InvalidDocumentVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInstanceId" => crate::error::SendCommandError {
            meta: generic,
            kind: crate::error::SendCommandErrorKind::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNotificationConfig" => crate::error::SendCommandError {
            meta: generic,
            kind: crate::error::SendCommandErrorKind::InvalidNotificationConfig({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_notification_config::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_notification_config_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidOutputFolder" => crate::error::SendCommandError {
            meta: generic,
            kind: crate::error::SendCommandErrorKind::InvalidOutputFolder({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_output_folder::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_output_folder_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidParameters" => {
            crate::error::SendCommandError {
                meta: generic,
                kind: crate::error::SendCommandErrorKind::InvalidParameters({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_parameters::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_parameters_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidRole" => crate::error::SendCommandError {
            meta: generic,
            kind: crate::error::SendCommandErrorKind::InvalidRole({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_role::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_role_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::SendCommandError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "MaxDocumentSizeExceeded" => crate::error::SendCommandError {
            meta: generic,
            kind: crate::error::SendCommandErrorKind::MaxDocumentSizeExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::max_document_size_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_max_document_size_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnsupportedPlatformType" => crate::error::SendCommandError {
            meta: generic,
            kind: crate::error::SendCommandErrorKind::UnsupportedPlatformType({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_platform_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_platform_type_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::SendCommandError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_command_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SendCommandOutput, crate::error::SendCommandError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::send_command_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_send_command(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::SendCommandError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_associations_once_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartAssociationsOnceOutput,
    crate::error::StartAssociationsOnceError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::StartAssociationsOnceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StartAssociationsOnceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AssociationDoesNotExist" => crate::error::StartAssociationsOnceError {
            meta: generic,
            kind: crate::error::StartAssociationsOnceErrorKind::AssociationDoesNotExist({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::StartAssociationsOnceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidAssociation" => crate::error::StartAssociationsOnceError {
            meta: generic,
            kind: crate::error::StartAssociationsOnceErrorKind::InvalidAssociation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_association::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_association_json_err(response.body().as_ref(), output).map_err(crate::error::StartAssociationsOnceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::StartAssociationsOnceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_associations_once_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartAssociationsOnceOutput,
    crate::error::StartAssociationsOnceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_associations_once_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_automation_execution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartAutomationExecutionOutput,
    crate::error::StartAutomationExecutionError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::StartAutomationExecutionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::StartAutomationExecutionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AutomationDefinitionNotFoundException" => crate::error::StartAutomationExecutionError { meta: generic, kind: crate::error::StartAutomationExecutionErrorKind::AutomationDefinitionNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::automation_definition_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_definition_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartAutomationExecutionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "AutomationDefinitionVersionNotFoundException" => crate::error::StartAutomationExecutionError { meta: generic, kind: crate::error::StartAutomationExecutionErrorKind::AutomationDefinitionVersionNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::automation_definition_version_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_definition_version_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartAutomationExecutionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "AutomationExecutionLimitExceededException" => crate::error::StartAutomationExecutionError { meta: generic, kind: crate::error::StartAutomationExecutionErrorKind::AutomationExecutionLimitExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::automation_execution_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_execution_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartAutomationExecutionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "IdempotentParameterMismatch" => crate::error::StartAutomationExecutionError { meta: generic, kind: crate::error::StartAutomationExecutionErrorKind::IdempotentParameterMismatch({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::idempotent_parameter_mismatch::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotent_parameter_mismatch_json_err(response.body().as_ref(), output).map_err(crate::error::StartAutomationExecutionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServerError" => crate::error::StartAutomationExecutionError { meta: generic, kind: crate::error::StartAutomationExecutionErrorKind::InternalServerError({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::StartAutomationExecutionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidAutomationExecutionParametersException" => crate::error::StartAutomationExecutionError { meta: generic, kind: crate::error::StartAutomationExecutionErrorKind::InvalidAutomationExecutionParametersException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_automation_execution_parameters_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_automation_execution_parameters_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartAutomationExecutionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTarget" => crate::error::StartAutomationExecutionError { meta: generic, kind: crate::error::StartAutomationExecutionErrorKind::InvalidTarget({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_target::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_target_json_err(response.body().as_ref(), output).map_err(crate::error::StartAutomationExecutionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::StartAutomationExecutionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_automation_execution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartAutomationExecutionOutput,
    crate::error::StartAutomationExecutionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_automation_execution_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_start_automation_execution(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StartAutomationExecutionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_change_request_execution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartChangeRequestExecutionOutput,
    crate::error::StartChangeRequestExecutionError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::StartChangeRequestExecutionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AutomationDefinitionNotApprovedException" => crate::error::StartChangeRequestExecutionError { meta: generic, kind: crate::error::StartChangeRequestExecutionErrorKind::AutomationDefinitionNotApprovedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::automation_definition_not_approved_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_definition_not_approved_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "AutomationDefinitionNotFoundException" => crate::error::StartChangeRequestExecutionError { meta: generic, kind: crate::error::StartChangeRequestExecutionErrorKind::AutomationDefinitionNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::automation_definition_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_definition_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "AutomationDefinitionVersionNotFoundException" => crate::error::StartChangeRequestExecutionError { meta: generic, kind: crate::error::StartChangeRequestExecutionErrorKind::AutomationDefinitionVersionNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::automation_definition_version_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_definition_version_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "AutomationExecutionLimitExceededException" => crate::error::StartChangeRequestExecutionError { meta: generic, kind: crate::error::StartChangeRequestExecutionErrorKind::AutomationExecutionLimitExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::automation_execution_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_execution_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "IdempotentParameterMismatch" => crate::error::StartChangeRequestExecutionError { meta: generic, kind: crate::error::StartChangeRequestExecutionErrorKind::IdempotentParameterMismatch({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::idempotent_parameter_mismatch::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotent_parameter_mismatch_json_err(response.body().as_ref(), output).map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServerError" => crate::error::StartChangeRequestExecutionError { meta: generic, kind: crate::error::StartChangeRequestExecutionErrorKind::InternalServerError({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidAutomationExecutionParametersException" => crate::error::StartChangeRequestExecutionError { meta: generic, kind: crate::error::StartChangeRequestExecutionErrorKind::InvalidAutomationExecutionParametersException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_automation_execution_parameters_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_automation_execution_parameters_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::StartChangeRequestExecutionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_change_request_execution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartChangeRequestExecutionOutput,
    crate::error::StartChangeRequestExecutionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_change_request_execution_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_start_change_request_execution(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_session_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StartSessionOutput, crate::error::StartSessionError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::StartSessionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StartSessionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::StartSessionError {
            meta: generic,
            kind: crate::error::StartSessionErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::StartSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDocument" => {
            crate::error::StartSessionError {
                meta: generic,
                kind: crate::error::StartSessionErrorKind::InvalidDocument({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_document::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::StartSessionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "TargetNotConnected" => crate::error::StartSessionError {
            meta: generic,
            kind: crate::error::StartSessionErrorKind::TargetNotConnected({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::target_not_connected::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_target_not_connected_json_err(response.body().as_ref(), output).map_err(crate::error::StartSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::StartSessionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_session_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StartSessionOutput, crate::error::StartSessionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_session_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_start_session(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StartSessionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_automation_execution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopAutomationExecutionOutput,
    crate::error::StopAutomationExecutionError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::StopAutomationExecutionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::StopAutomationExecutionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AutomationExecutionNotFoundException" => crate::error::StopAutomationExecutionError { meta: generic, kind: crate::error::StopAutomationExecutionErrorKind::AutomationExecutionNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::automation_execution_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_execution_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopAutomationExecutionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServerError" => crate::error::StopAutomationExecutionError { meta: generic, kind: crate::error::StopAutomationExecutionErrorKind::InternalServerError({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::StopAutomationExecutionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidAutomationStatusUpdateException" => crate::error::StopAutomationExecutionError { meta: generic, kind: crate::error::StopAutomationExecutionErrorKind::InvalidAutomationStatusUpdateException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_automation_status_update_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_automation_status_update_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopAutomationExecutionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::StopAutomationExecutionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_automation_execution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopAutomationExecutionOutput,
    crate::error::StopAutomationExecutionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_automation_execution_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_terminate_session_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TerminateSessionOutput, crate::error::TerminateSessionError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::TerminateSessionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TerminateSessionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::TerminateSessionError {
            meta: generic,
            kind: crate::error::TerminateSessionErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::TerminateSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::TerminateSessionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_terminate_session_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TerminateSessionOutput, crate::error::TerminateSessionError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::terminate_session_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_terminate_session(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::TerminateSessionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_unlabel_parameter_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UnlabelParameterVersionOutput,
    crate::error::UnlabelParameterVersionError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UnlabelParameterVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UnlabelParameterVersionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::UnlabelParameterVersionError {
            meta: generic,
            kind: crate::error::UnlabelParameterVersionErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UnlabelParameterVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ParameterNotFound" => crate::error::UnlabelParameterVersionError {
            meta: generic,
            kind: crate::error::UnlabelParameterVersionErrorKind::ParameterNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::UnlabelParameterVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ParameterVersionNotFound" => crate::error::UnlabelParameterVersionError {
            meta: generic,
            kind: crate::error::UnlabelParameterVersionErrorKind::ParameterVersionNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_version_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_version_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::UnlabelParameterVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TooManyUpdates" => {
            crate::error::UnlabelParameterVersionError {
                meta: generic,
                kind: crate::error::UnlabelParameterVersionErrorKind::TooManyUpdates({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_updates::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(response.body().as_ref(), output).map_err(crate::error::UnlabelParameterVersionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::UnlabelParameterVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_unlabel_parameter_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UnlabelParameterVersionOutput,
    crate::error::UnlabelParameterVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::unlabel_parameter_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_unlabel_parameter_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UnlabelParameterVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_association_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateAssociationOutput, crate::error::UpdateAssociationError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateAssociationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateAssociationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AssociationDoesNotExist" => crate::error::UpdateAssociationError {
            meta: generic,
            kind: crate::error::UpdateAssociationErrorKind::AssociationDoesNotExist({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "AssociationVersionLimitExceeded" => crate::error::UpdateAssociationError {
            meta: generic,
            kind: crate::error::UpdateAssociationErrorKind::AssociationVersionLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::association_version_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_version_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::UpdateAssociationError {
            meta: generic,
            kind: crate::error::UpdateAssociationErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidAssociationVersion" => crate::error::UpdateAssociationError {
            meta: generic,
            kind: crate::error::UpdateAssociationErrorKind::InvalidAssociationVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_association_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_association_version_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDocument" => {
            crate::error::UpdateAssociationError {
                meta: generic,
                kind: crate::error::UpdateAssociationErrorKind::InvalidDocument({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_document::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidDocumentVersion" => crate::error::UpdateAssociationError {
            meta: generic,
            kind: crate::error::UpdateAssociationErrorKind::InvalidDocumentVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidOutputLocation" => crate::error::UpdateAssociationError {
            meta: generic,
            kind: crate::error::UpdateAssociationErrorKind::InvalidOutputLocation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_output_location::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_output_location_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidParameters" => {
            crate::error::UpdateAssociationError {
                meta: generic,
                kind: crate::error::UpdateAssociationErrorKind::InvalidParameters({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_parameters::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_parameters_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidSchedule" => {
            crate::error::UpdateAssociationError {
                meta: generic,
                kind: crate::error::UpdateAssociationErrorKind::InvalidSchedule({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_schedule::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_schedule_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidTarget" => crate::error::UpdateAssociationError {
            meta: generic,
            kind: crate::error::UpdateAssociationErrorKind::InvalidTarget({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_target::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_invalid_target_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::UpdateAssociationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidTargetMaps" => crate::error::UpdateAssociationError {
            meta: generic,
            kind: crate::error::UpdateAssociationErrorKind::InvalidTargetMaps({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_target_maps::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_target_maps_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidUpdate" => crate::error::UpdateAssociationError {
            meta: generic,
            kind: crate::error::UpdateAssociationErrorKind::InvalidUpdate({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_update::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_invalid_update_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::UpdateAssociationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TooManyUpdates" => {
            crate::error::UpdateAssociationError {
                meta: generic,
                kind: crate::error::UpdateAssociationErrorKind::TooManyUpdates({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_updates::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::UpdateAssociationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_association_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateAssociationOutput, crate::error::UpdateAssociationError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_association_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_association(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateAssociationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_association_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateAssociationStatusOutput,
    crate::error::UpdateAssociationStatusError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateAssociationStatusError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateAssociationStatusError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AssociationDoesNotExist" => crate::error::UpdateAssociationStatusError {
            meta: generic,
            kind: crate::error::UpdateAssociationStatusErrorKind::AssociationDoesNotExist({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationStatusError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::UpdateAssociationStatusError {
            meta: generic,
            kind: crate::error::UpdateAssociationStatusErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationStatusError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDocument" => {
            crate::error::UpdateAssociationStatusError {
                meta: generic,
                kind: crate::error::UpdateAssociationStatusErrorKind::InvalidDocument({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_document::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationStatusError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidInstanceId" => crate::error::UpdateAssociationStatusError {
            meta: generic,
            kind: crate::error::UpdateAssociationStatusErrorKind::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationStatusError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "StatusUnchanged" => {
            crate::error::UpdateAssociationStatusError {
                meta: generic,
                kind: crate::error::UpdateAssociationStatusErrorKind::StatusUnchanged({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::status_unchanged::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_status_unchanged_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationStatusError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "TooManyUpdates" => {
            crate::error::UpdateAssociationStatusError {
                meta: generic,
                kind: crate::error::UpdateAssociationStatusErrorKind::TooManyUpdates({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_updates::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationStatusError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::UpdateAssociationStatusError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_association_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateAssociationStatusOutput,
    crate::error::UpdateAssociationStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_association_status_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_association_status(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateAssociationStatusError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_document_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateDocumentOutput, crate::error::UpdateDocumentError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateDocumentError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateDocumentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DocumentVersionLimitExceeded" => crate::error::UpdateDocumentError {
            meta: generic,
            kind: crate::error::UpdateDocumentErrorKind::DocumentVersionLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::document_version_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_document_version_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DuplicateDocumentContent" => crate::error::UpdateDocumentError {
            meta: generic,
            kind: crate::error::UpdateDocumentErrorKind::DuplicateDocumentContent({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::duplicate_document_content::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_duplicate_document_content_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DuplicateDocumentVersionName" => crate::error::UpdateDocumentError {
            meta: generic,
            kind: crate::error::UpdateDocumentErrorKind::DuplicateDocumentVersionName({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::duplicate_document_version_name::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_duplicate_document_version_name_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::UpdateDocumentError {
            meta: generic,
            kind: crate::error::UpdateDocumentErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDocument" => {
            crate::error::UpdateDocumentError {
                meta: generic,
                kind: crate::error::UpdateDocumentErrorKind::InvalidDocument({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_document::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidDocumentContent" => crate::error::UpdateDocumentError {
            meta: generic,
            kind: crate::error::UpdateDocumentErrorKind::InvalidDocumentContent({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_content::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_content_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDocumentOperation" => crate::error::UpdateDocumentError {
            meta: generic,
            kind: crate::error::UpdateDocumentErrorKind::InvalidDocumentOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_operation::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_operation_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDocumentSchemaVersion" => crate::error::UpdateDocumentError {
            meta: generic,
            kind: crate::error::UpdateDocumentErrorKind::InvalidDocumentSchemaVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_document_schema_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_schema_version_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDocumentVersion" => crate::error::UpdateDocumentError {
            meta: generic,
            kind: crate::error::UpdateDocumentErrorKind::InvalidDocumentVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "MaxDocumentSizeExceeded" => crate::error::UpdateDocumentError {
            meta: generic,
            kind: crate::error::UpdateDocumentErrorKind::MaxDocumentSizeExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::max_document_size_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_max_document_size_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateDocumentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_document_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateDocumentOutput, crate::error::UpdateDocumentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_document_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_document(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateDocumentError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_document_default_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDocumentDefaultVersionOutput,
    crate::error::UpdateDocumentDefaultVersionError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateDocumentDefaultVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateDocumentDefaultVersionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::UpdateDocumentDefaultVersionError {
            meta: generic,
            kind: crate::error::UpdateDocumentDefaultVersionErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentDefaultVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDocument" => {
            crate::error::UpdateDocumentDefaultVersionError {
                meta: generic,
                kind: crate::error::UpdateDocumentDefaultVersionErrorKind::InvalidDocument({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_document::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentDefaultVersionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidDocumentSchemaVersion" => crate::error::UpdateDocumentDefaultVersionError {
            meta: generic,
            kind: crate::error::UpdateDocumentDefaultVersionErrorKind::InvalidDocumentSchemaVersion(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_document_schema_version::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_document_schema_version_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentDefaultVersionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "InvalidDocumentVersion" => crate::error::UpdateDocumentDefaultVersionError {
            meta: generic,
            kind: crate::error::UpdateDocumentDefaultVersionErrorKind::InvalidDocumentVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentDefaultVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateDocumentDefaultVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_document_default_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDocumentDefaultVersionOutput,
    crate::error::UpdateDocumentDefaultVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_document_default_version_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_update_document_default_version(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::UpdateDocumentDefaultVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_document_metadata_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDocumentMetadataOutput,
    crate::error::UpdateDocumentMetadataError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateDocumentMetadataError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateDocumentMetadataError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::UpdateDocumentMetadataError {
            meta: generic,
            kind: crate::error::UpdateDocumentMetadataErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDocument" => {
            crate::error::UpdateDocumentMetadataError {
                meta: generic,
                kind: crate::error::UpdateDocumentMetadataErrorKind::InvalidDocument({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_document::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentMetadataError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidDocumentOperation" => crate::error::UpdateDocumentMetadataError {
            meta: generic,
            kind: crate::error::UpdateDocumentMetadataErrorKind::InvalidDocumentOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_operation::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_operation_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDocumentVersion" => crate::error::UpdateDocumentMetadataError {
            meta: generic,
            kind: crate::error::UpdateDocumentMetadataErrorKind::InvalidDocumentVersion({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateDocumentMetadataError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_document_metadata_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDocumentMetadataOutput,
    crate::error::UpdateDocumentMetadataError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_document_metadata_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_maintenance_window_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateMaintenanceWindowOutput,
    crate::error::UpdateMaintenanceWindowError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateMaintenanceWindowError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateMaintenanceWindowError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::UpdateMaintenanceWindowError {
            meta: generic,
            kind: crate::error::UpdateMaintenanceWindowErrorKind::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateMaintenanceWindowError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::UpdateMaintenanceWindowError {
            meta: generic,
            kind: crate::error::UpdateMaintenanceWindowErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateMaintenanceWindowError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateMaintenanceWindowError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_maintenance_window_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateMaintenanceWindowOutput,
    crate::error::UpdateMaintenanceWindowError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_maintenance_window_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_maintenance_window(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateMaintenanceWindowError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_maintenance_window_target_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateMaintenanceWindowTargetOutput,
    crate::error::UpdateMaintenanceWindowTargetError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateMaintenanceWindowTargetError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateMaintenanceWindowTargetError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::UpdateMaintenanceWindowTargetError {
            meta: generic,
            kind: crate::error::UpdateMaintenanceWindowTargetErrorKind::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateMaintenanceWindowTargetError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::UpdateMaintenanceWindowTargetError {
            meta: generic,
            kind: crate::error::UpdateMaintenanceWindowTargetErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateMaintenanceWindowTargetError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateMaintenanceWindowTargetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_maintenance_window_target_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateMaintenanceWindowTargetOutput,
    crate::error::UpdateMaintenanceWindowTargetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_maintenance_window_target_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_update_maintenance_window_target(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::UpdateMaintenanceWindowTargetError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_maintenance_window_task_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateMaintenanceWindowTaskOutput,
    crate::error::UpdateMaintenanceWindowTaskError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateMaintenanceWindowTaskError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateMaintenanceWindowTaskError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::UpdateMaintenanceWindowTaskError {
            meta: generic,
            kind: crate::error::UpdateMaintenanceWindowTaskErrorKind::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateMaintenanceWindowTaskError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::UpdateMaintenanceWindowTaskError {
            meta: generic,
            kind: crate::error::UpdateMaintenanceWindowTaskErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateMaintenanceWindowTaskError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateMaintenanceWindowTaskError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_maintenance_window_task_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateMaintenanceWindowTaskOutput,
    crate::error::UpdateMaintenanceWindowTaskError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_maintenance_window_task_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_maintenance_window_task(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateMaintenanceWindowTaskError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_managed_instance_role_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateManagedInstanceRoleOutput,
    crate::error::UpdateManagedInstanceRoleError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateManagedInstanceRoleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateManagedInstanceRoleError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::UpdateManagedInstanceRoleError {
            meta: generic,
            kind: crate::error::UpdateManagedInstanceRoleErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateManagedInstanceRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInstanceId" => crate::error::UpdateManagedInstanceRoleError {
            meta: generic,
            kind: crate::error::UpdateManagedInstanceRoleErrorKind::InvalidInstanceId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateManagedInstanceRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateManagedInstanceRoleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_managed_instance_role_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateManagedInstanceRoleOutput,
    crate::error::UpdateManagedInstanceRoleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_managed_instance_role_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_ops_item_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateOpsItemOutput, crate::error::UpdateOpsItemError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateOpsItemError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateOpsItemError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::UpdateOpsItemError {
            meta: generic,
            kind: crate::error::UpdateOpsItemErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsItemError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OpsItemAlreadyExistsException" => crate::error::UpdateOpsItemError {
            meta: generic,
            kind: crate::error::UpdateOpsItemErrorKind::OpsItemAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_item_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsItemError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OpsItemInvalidParameterException" => crate::error::UpdateOpsItemError {
            meta: generic,
            kind: crate::error::UpdateOpsItemErrorKind::OpsItemInvalidParameterException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_item_invalid_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsItemError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OpsItemLimitExceededException" => crate::error::UpdateOpsItemError {
            meta: generic,
            kind: crate::error::UpdateOpsItemErrorKind::OpsItemLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_item_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsItemError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OpsItemNotFoundException" => crate::error::UpdateOpsItemError {
            meta: generic,
            kind: crate::error::UpdateOpsItemErrorKind::OpsItemNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsItemError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateOpsItemError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_ops_item_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateOpsItemOutput, crate::error::UpdateOpsItemError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_ops_item_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_ops_metadata_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateOpsMetadataOutput, crate::error::UpdateOpsMetadataError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateOpsMetadataError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateOpsMetadataError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::UpdateOpsMetadataError {
            meta: generic,
            kind: crate::error::UpdateOpsMetadataErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OpsMetadataInvalidArgumentException" => crate::error::UpdateOpsMetadataError {
            meta: generic,
            kind: crate::error::UpdateOpsMetadataErrorKind::OpsMetadataInvalidArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_metadata_invalid_argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_invalid_argument_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OpsMetadataKeyLimitExceededException" => crate::error::UpdateOpsMetadataError {
            meta: generic,
            kind: crate::error::UpdateOpsMetadataErrorKind::OpsMetadataKeyLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_metadata_key_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_key_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OpsMetadataNotFoundException" => crate::error::UpdateOpsMetadataError {
            meta: generic,
            kind: crate::error::UpdateOpsMetadataErrorKind::OpsMetadataNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_metadata_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OpsMetadataTooManyUpdatesException" => crate::error::UpdateOpsMetadataError {
            meta: generic,
            kind: crate::error::UpdateOpsMetadataErrorKind::OpsMetadataTooManyUpdatesException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::ops_metadata_too_many_updates_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_too_many_updates_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateOpsMetadataError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_ops_metadata_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateOpsMetadataOutput, crate::error::UpdateOpsMetadataError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_ops_metadata_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_ops_metadata(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateOpsMetadataError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_patch_baseline_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePatchBaselineOutput,
    crate::error::UpdatePatchBaselineError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdatePatchBaselineError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdatePatchBaselineError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::UpdatePatchBaselineError {
            meta: generic,
            kind: crate::error::UpdatePatchBaselineErrorKind::DoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePatchBaselineError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerError" => crate::error::UpdatePatchBaselineError {
            meta: generic,
            kind: crate::error::UpdatePatchBaselineErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePatchBaselineError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdatePatchBaselineError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_patch_baseline_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePatchBaselineOutput,
    crate::error::UpdatePatchBaselineError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_patch_baseline_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_patch_baseline(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdatePatchBaselineError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_resource_data_sync_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateResourceDataSyncOutput,
    crate::error::UpdateResourceDataSyncError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateResourceDataSyncError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateResourceDataSyncError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::UpdateResourceDataSyncError { meta: generic, kind: crate::error::UpdateResourceDataSyncErrorKind::InternalServerError({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateResourceDataSyncError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceDataSyncConflictException" => crate::error::UpdateResourceDataSyncError { meta: generic, kind: crate::error::UpdateResourceDataSyncErrorKind::ResourceDataSyncConflictException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::resource_data_sync_conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_data_sync_conflict_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateResourceDataSyncError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceDataSyncInvalidConfigurationException" => crate::error::UpdateResourceDataSyncError { meta: generic, kind: crate::error::UpdateResourceDataSyncErrorKind::ResourceDataSyncInvalidConfigurationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::resource_data_sync_invalid_configuration_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_data_sync_invalid_configuration_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateResourceDataSyncError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceDataSyncNotFoundException" => crate::error::UpdateResourceDataSyncError { meta: generic, kind: crate::error::UpdateResourceDataSyncErrorKind::ResourceDataSyncNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::resource_data_sync_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_data_sync_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateResourceDataSyncError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateResourceDataSyncError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_resource_data_sync_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateResourceDataSyncOutput,
    crate::error::UpdateResourceDataSyncError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_resource_data_sync_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_service_setting_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateServiceSettingOutput,
    crate::error::UpdateServiceSettingError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateServiceSettingError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateServiceSettingError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::UpdateServiceSettingError {
            meta: generic,
            kind: crate::error::UpdateServiceSettingErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateServiceSettingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceSettingNotFound" => crate::error::UpdateServiceSettingError {
            meta: generic,
            kind: crate::error::UpdateServiceSettingErrorKind::ServiceSettingNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_setting_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_setting_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateServiceSettingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TooManyUpdates" => {
            crate::error::UpdateServiceSettingError {
                meta: generic,
                kind: crate::error::UpdateServiceSettingErrorKind::TooManyUpdates({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_updates::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateServiceSettingError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::UpdateServiceSettingError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_service_setting_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateServiceSettingOutput,
    crate::error::UpdateServiceSettingError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_service_setting_output::Builder::default();
        let _ = response;
        output.build()
    })
}
