// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_tags_to_resource_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AddTagsToResourceOutput, crate::error::AddTagsToResourceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::AddTagsToResourceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::AddTagsToResourceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::AddTagsToResourceError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::AddTagsToResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidResourceId" => crate::error::AddTagsToResourceError::InvalidResourceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::AddTagsToResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidResourceType" => crate::error::AddTagsToResourceError::InvalidResourceType({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_type_json_err(response.body().as_ref(), output).map_err(crate::error::AddTagsToResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyTagsError" => crate::error::AddTagsToResourceError::TooManyTagsError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_tags_error_json_err(response.body().as_ref(), output).map_err(crate::error::AddTagsToResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyUpdates" => crate::error::AddTagsToResourceError::TooManyUpdates({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_updates::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(response.body().as_ref(), output).map_err(crate::error::AddTagsToResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::AddTagsToResourceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_tags_to_resource_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AddTagsToResourceOutput, crate::error::AddTagsToResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_tags_to_resource_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_ops_item_related_item_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateOpsItemRelatedItemOutput, crate::error::AssociateOpsItemRelatedItemError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::AssociateOpsItemRelatedItemError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::AssociateOpsItemRelatedItemError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::AssociateOpsItemRelatedItemError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateOpsItemRelatedItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsItemInvalidParameterException" => crate::error::AssociateOpsItemRelatedItemError::OpsItemInvalidParameterException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_invalid_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateOpsItemRelatedItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsItemLimitExceededException" => crate::error::AssociateOpsItemRelatedItemError::OpsItemLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateOpsItemRelatedItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsItemNotFoundException" => crate::error::AssociateOpsItemRelatedItemError::OpsItemNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateOpsItemRelatedItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsItemRelatedItemAlreadyExistsException" => crate::error::AssociateOpsItemRelatedItemError::OpsItemRelatedItemAlreadyExistsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_related_item_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_related_item_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateOpsItemRelatedItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::AssociateOpsItemRelatedItemError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_ops_item_related_item_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateOpsItemRelatedItemOutput, crate::error::AssociateOpsItemRelatedItemError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_ops_item_related_item_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_associate_ops_item_related_item(response.body().as_ref(), output).map_err(crate::error::AssociateOpsItemRelatedItemError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_command_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CancelCommandOutput, crate::error::CancelCommandError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::CancelCommandError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CancelCommandError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DuplicateInstanceId" => crate::error::CancelCommandError::DuplicateInstanceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::duplicate_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_duplicate_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::CancelCommandError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::CancelCommandError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CancelCommandError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidCommandId" => crate::error::CancelCommandError::InvalidCommandId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_command_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_command_id_json_err(response.body().as_ref(), output).map_err(crate::error::CancelCommandError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidInstanceId" => crate::error::CancelCommandError::InvalidInstanceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::CancelCommandError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::CancelCommandError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_command_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CancelCommandOutput, crate::error::CancelCommandError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_command_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_maintenance_window_execution_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CancelMaintenanceWindowExecutionOutput, crate::error::CancelMaintenanceWindowExecutionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::CancelMaintenanceWindowExecutionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CancelMaintenanceWindowExecutionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::CancelMaintenanceWindowExecutionError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CancelMaintenanceWindowExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::CancelMaintenanceWindowExecutionError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CancelMaintenanceWindowExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::CancelMaintenanceWindowExecutionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_maintenance_window_execution_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CancelMaintenanceWindowExecutionOutput, crate::error::CancelMaintenanceWindowExecutionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_maintenance_window_execution_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_cancel_maintenance_window_execution(response.body().as_ref(), output).map_err(crate::error::CancelMaintenanceWindowExecutionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_activation_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateActivationOutput, crate::error::CreateActivationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::CreateActivationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateActivationError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::CreateActivationError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateActivationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidParameters" => crate::error::CreateActivationError::InvalidParameters({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_parameters::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameters_json_err(response.body().as_ref(), output).map_err(crate::error::CreateActivationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::CreateActivationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_activation_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateActivationOutput, crate::error::CreateActivationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_activation_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_activation(response.body().as_ref(), output).map_err(crate::error::CreateActivationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_association_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateAssociationOutput, crate::error::CreateAssociationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::CreateAssociationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateAssociationError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "AssociationAlreadyExists" => crate::error::CreateAssociationError::AssociationAlreadyExists({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_already_exists::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_already_exists_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "AssociationLimitExceeded" => crate::error::CreateAssociationError::AssociationLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::CreateAssociationError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocument" => crate::error::CreateAssociationError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocumentVersion" => crate::error::CreateAssociationError::InvalidDocumentVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidInstanceId" => crate::error::CreateAssociationError::InvalidInstanceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOutputLocation" => crate::error::CreateAssociationError::InvalidOutputLocation({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_output_location::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_output_location_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidParameters" => crate::error::CreateAssociationError::InvalidParameters({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_parameters::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameters_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidSchedule" => crate::error::CreateAssociationError::InvalidSchedule({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_schedule::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_schedule_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidTag" => crate::error::CreateAssociationError::InvalidTag({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_tag::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_tag_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidTarget" => crate::error::CreateAssociationError::InvalidTarget({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_target::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_target_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidTargetMaps" => crate::error::CreateAssociationError::InvalidTargetMaps({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_target_maps::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_target_maps_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "UnsupportedPlatformType" => crate::error::CreateAssociationError::UnsupportedPlatformType({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_platform_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_platform_type_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::CreateAssociationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_association_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateAssociationOutput, crate::error::CreateAssociationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_association_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_association(response.body().as_ref(), output).map_err(crate::error::CreateAssociationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_association_batch_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateAssociationBatchOutput, crate::error::CreateAssociationBatchError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateAssociationBatchError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "AssociationLimitExceeded" => crate::error::CreateAssociationBatchError::AssociationLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "DuplicateInstanceId" => crate::error::CreateAssociationBatchError::DuplicateInstanceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::duplicate_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_duplicate_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::CreateAssociationBatchError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocument" => crate::error::CreateAssociationBatchError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocumentVersion" => crate::error::CreateAssociationBatchError::InvalidDocumentVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidInstanceId" => crate::error::CreateAssociationBatchError::InvalidInstanceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOutputLocation" => crate::error::CreateAssociationBatchError::InvalidOutputLocation({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_output_location::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_output_location_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidParameters" => crate::error::CreateAssociationBatchError::InvalidParameters({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_parameters::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameters_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidSchedule" => crate::error::CreateAssociationBatchError::InvalidSchedule({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_schedule::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_schedule_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidTarget" => crate::error::CreateAssociationBatchError::InvalidTarget({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_target::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_target_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidTargetMaps" => crate::error::CreateAssociationBatchError::InvalidTargetMaps({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_target_maps::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_target_maps_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "UnsupportedPlatformType" => crate::error::CreateAssociationBatchError::UnsupportedPlatformType({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_platform_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_platform_type_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::CreateAssociationBatchError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_association_batch_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateAssociationBatchOutput, crate::error::CreateAssociationBatchError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_association_batch_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_association_batch(response.body().as_ref(), output).map_err(crate::error::CreateAssociationBatchError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_document_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateDocumentOutput, crate::error::CreateDocumentError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::CreateDocumentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateDocumentError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DocumentAlreadyExists" => crate::error::CreateDocumentError::DocumentAlreadyExists({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::document_already_exists::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_document_already_exists_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "DocumentLimitExceeded" => crate::error::CreateDocumentError::DocumentLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::document_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_document_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::CreateDocumentError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocumentContent" => crate::error::CreateDocumentError::InvalidDocumentContent({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_content::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_content_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocumentSchemaVersion" => crate::error::CreateDocumentError::InvalidDocumentSchemaVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_schema_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_schema_version_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaxDocumentSizeExceeded" => crate::error::CreateDocumentError::MaxDocumentSizeExceeded({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::max_document_size_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_max_document_size_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::CreateDocumentError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_document_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateDocumentOutput, crate::error::CreateDocumentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_document_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_document(response.body().as_ref(), output).map_err(crate::error::CreateDocumentError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_maintenance_window_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateMaintenanceWindowOutput, crate::error::CreateMaintenanceWindowError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::CreateMaintenanceWindowError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateMaintenanceWindowError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "IdempotentParameterMismatch" => crate::error::CreateMaintenanceWindowError::IdempotentParameterMismatch({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::idempotent_parameter_mismatch::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotent_parameter_mismatch_json_err(response.body().as_ref(), output).map_err(crate::error::CreateMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::CreateMaintenanceWindowError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ResourceLimitExceededException" => crate::error::CreateMaintenanceWindowError::ResourceLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::CreateMaintenanceWindowError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_maintenance_window_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateMaintenanceWindowOutput, crate::error::CreateMaintenanceWindowError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_maintenance_window_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_maintenance_window(response.body().as_ref(), output).map_err(crate::error::CreateMaintenanceWindowError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_ops_item_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateOpsItemOutput, crate::error::CreateOpsItemError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::CreateOpsItemError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateOpsItemError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::CreateOpsItemError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsItemAccessDeniedException" => crate::error::CreateOpsItemError::OpsItemAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsItemAlreadyExistsException" => crate::error::CreateOpsItemError::OpsItemAlreadyExistsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsItemInvalidParameterException" => crate::error::CreateOpsItemError::OpsItemInvalidParameterException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_invalid_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsItemLimitExceededException" => crate::error::CreateOpsItemError::OpsItemLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::CreateOpsItemError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_ops_item_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateOpsItemOutput, crate::error::CreateOpsItemError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_ops_item_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_ops_item(response.body().as_ref(), output).map_err(crate::error::CreateOpsItemError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_ops_metadata_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateOpsMetadataOutput, crate::error::CreateOpsMetadataError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::CreateOpsMetadataError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateOpsMetadataError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::CreateOpsMetadataError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsMetadataAlreadyExistsException" => crate::error::CreateOpsMetadataError::OpsMetadataAlreadyExistsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_metadata_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsMetadataInvalidArgumentException" => crate::error::CreateOpsMetadataError::OpsMetadataInvalidArgumentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_metadata_invalid_argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_invalid_argument_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsMetadataLimitExceededException" => crate::error::CreateOpsMetadataError::OpsMetadataLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_metadata_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsMetadataTooManyUpdatesException" => crate::error::CreateOpsMetadataError::OpsMetadataTooManyUpdatesException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_metadata_too_many_updates_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_too_many_updates_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::CreateOpsMetadataError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_ops_metadata_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateOpsMetadataOutput, crate::error::CreateOpsMetadataError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_ops_metadata_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_ops_metadata(response.body().as_ref(), output).map_err(crate::error::CreateOpsMetadataError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_patch_baseline_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreatePatchBaselineOutput, crate::error::CreatePatchBaselineError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::CreatePatchBaselineError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreatePatchBaselineError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "IdempotentParameterMismatch" => crate::error::CreatePatchBaselineError::IdempotentParameterMismatch({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::idempotent_parameter_mismatch::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotent_parameter_mismatch_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::CreatePatchBaselineError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ResourceLimitExceededException" => crate::error::CreatePatchBaselineError::ResourceLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::CreatePatchBaselineError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_patch_baseline_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreatePatchBaselineOutput, crate::error::CreatePatchBaselineError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_patch_baseline_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_patch_baseline(response.body().as_ref(), output).map_err(crate::error::CreatePatchBaselineError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_resource_data_sync_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateResourceDataSyncOutput, crate::error::CreateResourceDataSyncError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::CreateResourceDataSyncError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateResourceDataSyncError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::CreateResourceDataSyncError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateResourceDataSyncError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ResourceDataSyncAlreadyExistsException" => crate::error::CreateResourceDataSyncError::ResourceDataSyncAlreadyExistsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_data_sync_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_data_sync_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateResourceDataSyncError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ResourceDataSyncCountExceededException" => crate::error::CreateResourceDataSyncError::ResourceDataSyncCountExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_data_sync_count_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_data_sync_count_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateResourceDataSyncError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ResourceDataSyncInvalidConfigurationException" => crate::error::CreateResourceDataSyncError::ResourceDataSyncInvalidConfigurationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_data_sync_invalid_configuration_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_data_sync_invalid_configuration_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateResourceDataSyncError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::CreateResourceDataSyncError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_resource_data_sync_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateResourceDataSyncOutput, crate::error::CreateResourceDataSyncError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_resource_data_sync_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_activation_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteActivationOutput, crate::error::DeleteActivationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteActivationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteActivationError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DeleteActivationError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteActivationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidActivation" => crate::error::DeleteActivationError::InvalidActivation({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_activation::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_activation_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteActivationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidActivationId" => crate::error::DeleteActivationError::InvalidActivationId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_activation_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_activation_id_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteActivationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyUpdates" => crate::error::DeleteActivationError::TooManyUpdates({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_updates::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteActivationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DeleteActivationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_activation_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteActivationOutput, crate::error::DeleteActivationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_activation_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_association_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteAssociationOutput, crate::error::DeleteAssociationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteAssociationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteAssociationError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "AssociationDoesNotExist" => crate::error::DeleteAssociationError::AssociationDoesNotExist({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::DeleteAssociationError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocument" => crate::error::DeleteAssociationError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidInstanceId" => crate::error::DeleteAssociationError::InvalidInstanceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyUpdates" => crate::error::DeleteAssociationError::TooManyUpdates({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_updates::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DeleteAssociationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_association_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteAssociationOutput, crate::error::DeleteAssociationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_association_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_document_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteDocumentOutput, crate::error::DeleteDocumentError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteDocumentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteDocumentError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "AssociatedInstances" => crate::error::DeleteDocumentError::AssociatedInstances({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::associated_instances::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_associated_instances_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::DeleteDocumentError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocument" => crate::error::DeleteDocumentError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocumentOperation" => crate::error::DeleteDocumentError::InvalidDocumentOperation({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_operation::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_operation_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DeleteDocumentError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_document_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteDocumentOutput, crate::error::DeleteDocumentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_document_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_inventory_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteInventoryOutput, crate::error::DeleteInventoryError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteInventoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteInventoryError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DeleteInventoryError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDeleteInventoryParametersException" => crate::error::DeleteInventoryError::InvalidDeleteInventoryParametersException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_delete_inventory_parameters_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_delete_inventory_parameters_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidInventoryRequestException" => crate::error::DeleteInventoryError::InvalidInventoryRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_inventory_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_inventory_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOptionException" => crate::error::DeleteInventoryError::InvalidOptionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_option_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_option_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidTypeNameException" => crate::error::DeleteInventoryError::InvalidTypeNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_type_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_type_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DeleteInventoryError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_inventory_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteInventoryOutput, crate::error::DeleteInventoryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_inventory_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_inventory(response.body().as_ref(), output).map_err(crate::error::DeleteInventoryError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_maintenance_window_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteMaintenanceWindowOutput, crate::error::DeleteMaintenanceWindowError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteMaintenanceWindowError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteMaintenanceWindowError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DeleteMaintenanceWindowError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DeleteMaintenanceWindowError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_maintenance_window_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteMaintenanceWindowOutput, crate::error::DeleteMaintenanceWindowError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_maintenance_window_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_maintenance_window(response.body().as_ref(), output).map_err(crate::error::DeleteMaintenanceWindowError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_ops_metadata_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteOpsMetadataOutput, crate::error::DeleteOpsMetadataError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteOpsMetadataError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteOpsMetadataError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DeleteOpsMetadataError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsMetadataInvalidArgumentException" => crate::error::DeleteOpsMetadataError::OpsMetadataInvalidArgumentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_metadata_invalid_argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_invalid_argument_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsMetadataNotFoundException" => crate::error::DeleteOpsMetadataError::OpsMetadataNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_metadata_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DeleteOpsMetadataError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_ops_metadata_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteOpsMetadataOutput, crate::error::DeleteOpsMetadataError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_ops_metadata_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_parameter_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteParameterOutput, crate::error::DeleteParameterError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteParameterError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteParameterError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DeleteParameterError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ParameterNotFound" => crate::error::DeleteParameterError::ParameterNotFound({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DeleteParameterError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_parameter_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteParameterOutput, crate::error::DeleteParameterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_parameter_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_parameters_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteParametersOutput, crate::error::DeleteParametersError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteParametersError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteParametersError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DeleteParametersError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteParametersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DeleteParametersError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_parameters_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteParametersOutput, crate::error::DeleteParametersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_parameters_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_parameters(response.body().as_ref(), output).map_err(crate::error::DeleteParametersError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_patch_baseline_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeletePatchBaselineOutput, crate::error::DeletePatchBaselineError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DeletePatchBaselineError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeletePatchBaselineError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DeletePatchBaselineError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ResourceInUseException" => crate::error::DeletePatchBaselineError::ResourceInUseException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_in_use_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_in_use_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DeletePatchBaselineError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_patch_baseline_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeletePatchBaselineOutput, crate::error::DeletePatchBaselineError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_patch_baseline_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_patch_baseline(response.body().as_ref(), output).map_err(crate::error::DeletePatchBaselineError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_resource_data_sync_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteResourceDataSyncOutput, crate::error::DeleteResourceDataSyncError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteResourceDataSyncError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteResourceDataSyncError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DeleteResourceDataSyncError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteResourceDataSyncError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ResourceDataSyncInvalidConfigurationException" => crate::error::DeleteResourceDataSyncError::ResourceDataSyncInvalidConfigurationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_data_sync_invalid_configuration_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_data_sync_invalid_configuration_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteResourceDataSyncError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ResourceDataSyncNotFoundException" => crate::error::DeleteResourceDataSyncError::ResourceDataSyncNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_data_sync_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_data_sync_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteResourceDataSyncError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DeleteResourceDataSyncError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_resource_data_sync_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteResourceDataSyncOutput, crate::error::DeleteResourceDataSyncError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_resource_data_sync_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_resource_policy_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteResourcePolicyOutput, crate::error::DeleteResourcePolicyError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteResourcePolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteResourcePolicyError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DeleteResourcePolicyError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteResourcePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ResourcePolicyConflictException" => crate::error::DeleteResourcePolicyError::ResourcePolicyConflictException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_policy_conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_policy_conflict_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteResourcePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ResourcePolicyInvalidParameterException" => crate::error::DeleteResourcePolicyError::ResourcePolicyInvalidParameterException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_policy_invalid_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_policy_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteResourcePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DeleteResourcePolicyError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_resource_policy_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteResourcePolicyOutput, crate::error::DeleteResourcePolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_resource_policy_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_managed_instance_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterManagedInstanceOutput, crate::error::DeregisterManagedInstanceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DeregisterManagedInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeregisterManagedInstanceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DeregisterManagedInstanceError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterManagedInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidInstanceId" => crate::error::DeregisterManagedInstanceError::InvalidInstanceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterManagedInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DeregisterManagedInstanceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_managed_instance_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterManagedInstanceOutput, crate::error::DeregisterManagedInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deregister_managed_instance_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_patch_baseline_for_patch_group_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterPatchBaselineForPatchGroupOutput, crate::error::DeregisterPatchBaselineForPatchGroupError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DeregisterPatchBaselineForPatchGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeregisterPatchBaselineForPatchGroupError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DeregisterPatchBaselineForPatchGroupError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterPatchBaselineForPatchGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidResourceId" => crate::error::DeregisterPatchBaselineForPatchGroupError::InvalidResourceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterPatchBaselineForPatchGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DeregisterPatchBaselineForPatchGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_patch_baseline_for_patch_group_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterPatchBaselineForPatchGroupOutput, crate::error::DeregisterPatchBaselineForPatchGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deregister_patch_baseline_for_patch_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_deregister_patch_baseline_for_patch_group(response.body().as_ref(), output).map_err(crate::error::DeregisterPatchBaselineForPatchGroupError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_target_from_maintenance_window_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterTargetFromMaintenanceWindowOutput, crate::error::DeregisterTargetFromMaintenanceWindowError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DeregisterTargetFromMaintenanceWindowError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeregisterTargetFromMaintenanceWindowError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::DeregisterTargetFromMaintenanceWindowError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterTargetFromMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::DeregisterTargetFromMaintenanceWindowError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterTargetFromMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TargetInUseException" => crate::error::DeregisterTargetFromMaintenanceWindowError::TargetInUseException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::target_in_use_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_target_in_use_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterTargetFromMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DeregisterTargetFromMaintenanceWindowError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_target_from_maintenance_window_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterTargetFromMaintenanceWindowOutput, crate::error::DeregisterTargetFromMaintenanceWindowError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deregister_target_from_maintenance_window_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_deregister_target_from_maintenance_window(response.body().as_ref(), output).map_err(crate::error::DeregisterTargetFromMaintenanceWindowError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_task_from_maintenance_window_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterTaskFromMaintenanceWindowOutput, crate::error::DeregisterTaskFromMaintenanceWindowError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DeregisterTaskFromMaintenanceWindowError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeregisterTaskFromMaintenanceWindowError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::DeregisterTaskFromMaintenanceWindowError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterTaskFromMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::DeregisterTaskFromMaintenanceWindowError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterTaskFromMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DeregisterTaskFromMaintenanceWindowError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_task_from_maintenance_window_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterTaskFromMaintenanceWindowOutput, crate::error::DeregisterTaskFromMaintenanceWindowError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deregister_task_from_maintenance_window_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_deregister_task_from_maintenance_window(response.body().as_ref(), output).map_err(crate::error::DeregisterTaskFromMaintenanceWindowError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_activations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeActivationsOutput, crate::error::DescribeActivationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeActivationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeActivationsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeActivationsError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeActivationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilter" => crate::error::DescribeActivationsError::InvalidFilter({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeActivationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::DescribeActivationsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeActivationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeActivationsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_activations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeActivationsOutput, crate::error::DescribeActivationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_activations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_activations(response.body().as_ref(), output).map_err(crate::error::DescribeActivationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_association_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAssociationOutput, crate::error::DescribeAssociationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeAssociationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeAssociationError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "AssociationDoesNotExist" => crate::error::DescribeAssociationError::AssociationDoesNotExist({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::DescribeAssociationError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidAssociationVersion" => crate::error::DescribeAssociationError::InvalidAssociationVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_association_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_association_version_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocument" => crate::error::DescribeAssociationError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidInstanceId" => crate::error::DescribeAssociationError::InvalidInstanceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeAssociationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_association_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAssociationOutput, crate::error::DescribeAssociationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_association_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_association(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_association_executions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAssociationExecutionsOutput, crate::error::DescribeAssociationExecutionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeAssociationExecutionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeAssociationExecutionsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "AssociationDoesNotExist" => crate::error::DescribeAssociationExecutionsError::AssociationDoesNotExist({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationExecutionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::DescribeAssociationExecutionsError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationExecutionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::DescribeAssociationExecutionsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationExecutionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeAssociationExecutionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_association_executions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAssociationExecutionsOutput, crate::error::DescribeAssociationExecutionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_association_executions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_association_executions(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationExecutionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_association_execution_targets_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAssociationExecutionTargetsOutput, crate::error::DescribeAssociationExecutionTargetsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeAssociationExecutionTargetsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeAssociationExecutionTargetsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "AssociationDoesNotExist" => crate::error::DescribeAssociationExecutionTargetsError::AssociationDoesNotExist({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationExecutionTargetsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "AssociationExecutionDoesNotExist" => crate::error::DescribeAssociationExecutionTargetsError::AssociationExecutionDoesNotExist({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_execution_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_execution_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationExecutionTargetsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::DescribeAssociationExecutionTargetsError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationExecutionTargetsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::DescribeAssociationExecutionTargetsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationExecutionTargetsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeAssociationExecutionTargetsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_association_execution_targets_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAssociationExecutionTargetsOutput, crate::error::DescribeAssociationExecutionTargetsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_association_execution_targets_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_association_execution_targets(response.body().as_ref(), output).map_err(crate::error::DescribeAssociationExecutionTargetsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_automation_executions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAutomationExecutionsOutput, crate::error::DescribeAutomationExecutionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeAutomationExecutionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeAutomationExecutionsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeAutomationExecutionsError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationExecutionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilterKey" => crate::error::DescribeAutomationExecutionsError::InvalidFilterKey({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_key::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationExecutionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilterValue" => crate::error::DescribeAutomationExecutionsError::InvalidFilterValue({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_value::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_value_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationExecutionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::DescribeAutomationExecutionsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationExecutionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeAutomationExecutionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_automation_executions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAutomationExecutionsOutput, crate::error::DescribeAutomationExecutionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_automation_executions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_automation_executions(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationExecutionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_automation_step_executions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAutomationStepExecutionsOutput, crate::error::DescribeAutomationStepExecutionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeAutomationStepExecutionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeAutomationStepExecutionsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "AutomationExecutionNotFoundException" => crate::error::DescribeAutomationStepExecutionsError::AutomationExecutionNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::automation_execution_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_execution_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationStepExecutionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::DescribeAutomationStepExecutionsError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationStepExecutionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilterKey" => crate::error::DescribeAutomationStepExecutionsError::InvalidFilterKey({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_key::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationStepExecutionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilterValue" => crate::error::DescribeAutomationStepExecutionsError::InvalidFilterValue({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_value::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_value_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationStepExecutionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::DescribeAutomationStepExecutionsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationStepExecutionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeAutomationStepExecutionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_automation_step_executions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAutomationStepExecutionsOutput, crate::error::DescribeAutomationStepExecutionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_automation_step_executions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_automation_step_executions(response.body().as_ref(), output).map_err(crate::error::DescribeAutomationStepExecutionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_available_patches_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAvailablePatchesOutput, crate::error::DescribeAvailablePatchesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeAvailablePatchesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeAvailablePatchesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeAvailablePatchesError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAvailablePatchesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeAvailablePatchesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_available_patches_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAvailablePatchesOutput, crate::error::DescribeAvailablePatchesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_available_patches_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_available_patches(response.body().as_ref(), output).map_err(crate::error::DescribeAvailablePatchesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_document_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeDocumentOutput, crate::error::DescribeDocumentError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeDocumentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeDocumentError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeDocumentError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocument" => crate::error::DescribeDocumentError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocumentVersion" => crate::error::DescribeDocumentError::InvalidDocumentVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeDocumentError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_document_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeDocumentOutput, crate::error::DescribeDocumentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_document_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_document(response.body().as_ref(), output).map_err(crate::error::DescribeDocumentError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_document_permission_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeDocumentPermissionOutput, crate::error::DescribeDocumentPermissionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeDocumentPermissionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeDocumentPermissionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeDocumentPermissionError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDocumentPermissionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocument" => crate::error::DescribeDocumentPermissionError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDocumentPermissionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocumentOperation" => crate::error::DescribeDocumentPermissionError::InvalidDocumentOperation({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_operation::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_operation_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDocumentPermissionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::DescribeDocumentPermissionError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDocumentPermissionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidPermissionType" => crate::error::DescribeDocumentPermissionError::InvalidPermissionType({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_permission_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_permission_type_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDocumentPermissionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeDocumentPermissionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_document_permission_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeDocumentPermissionOutput, crate::error::DescribeDocumentPermissionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_document_permission_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_document_permission(response.body().as_ref(), output).map_err(crate::error::DescribeDocumentPermissionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_effective_instance_associations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeEffectiveInstanceAssociationsOutput, crate::error::DescribeEffectiveInstanceAssociationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeEffectiveInstanceAssociationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeEffectiveInstanceAssociationsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeEffectiveInstanceAssociationsError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeEffectiveInstanceAssociationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidInstanceId" => crate::error::DescribeEffectiveInstanceAssociationsError::InvalidInstanceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeEffectiveInstanceAssociationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::DescribeEffectiveInstanceAssociationsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeEffectiveInstanceAssociationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeEffectiveInstanceAssociationsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_effective_instance_associations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeEffectiveInstanceAssociationsOutput, crate::error::DescribeEffectiveInstanceAssociationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_effective_instance_associations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_effective_instance_associations(response.body().as_ref(), output).map_err(crate::error::DescribeEffectiveInstanceAssociationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_effective_patches_for_patch_baseline_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeEffectivePatchesForPatchBaselineOutput, crate::error::DescribeEffectivePatchesForPatchBaselineError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::DescribeEffectivePatchesForPatchBaselineError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::DescribeEffectivePatchesForPatchBaselineError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidResourceId" => crate::error::DescribeEffectivePatchesForPatchBaselineError::InvalidResourceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "UnsupportedOperatingSystem" => crate::error::DescribeEffectivePatchesForPatchBaselineError::UnsupportedOperatingSystem({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_operating_system::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_operating_system_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeEffectivePatchesForPatchBaselineError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_effective_patches_for_patch_baseline_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeEffectivePatchesForPatchBaselineOutput, crate::error::DescribeEffectivePatchesForPatchBaselineError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_effective_patches_for_patch_baseline_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_effective_patches_for_patch_baseline(response.body().as_ref(), output).map_err(crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_associations_status_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstanceAssociationsStatusOutput, crate::error::DescribeInstanceAssociationsStatusError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeInstanceAssociationsStatusError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeInstanceAssociationsStatusError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeInstanceAssociationsStatusError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceAssociationsStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidInstanceId" => crate::error::DescribeInstanceAssociationsStatusError::InvalidInstanceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceAssociationsStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::DescribeInstanceAssociationsStatusError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceAssociationsStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeInstanceAssociationsStatusError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_associations_status_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstanceAssociationsStatusOutput, crate::error::DescribeInstanceAssociationsStatusError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instance_associations_status_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_instance_associations_status(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceAssociationsStatusError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_information_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstanceInformationOutput, crate::error::DescribeInstanceInformationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeInstanceInformationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeInstanceInformationError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeInstanceInformationError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceInformationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilterKey" => crate::error::DescribeInstanceInformationError::InvalidFilterKey({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_key::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceInformationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidInstanceId" => crate::error::DescribeInstanceInformationError::InvalidInstanceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceInformationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidInstanceInformationFilterValue" => crate::error::DescribeInstanceInformationError::InvalidInstanceInformationFilterValue({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_information_filter_value::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_information_filter_value_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceInformationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::DescribeInstanceInformationError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceInformationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeInstanceInformationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_information_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstanceInformationOutput, crate::error::DescribeInstanceInformationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instance_information_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_instance_information(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceInformationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_patches_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstancePatchesOutput, crate::error::DescribeInstancePatchesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeInstancePatchesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeInstancePatchesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeInstancePatchesError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancePatchesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilter" => crate::error::DescribeInstancePatchesError::InvalidFilter({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancePatchesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidInstanceId" => crate::error::DescribeInstancePatchesError::InvalidInstanceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancePatchesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::DescribeInstancePatchesError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancePatchesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeInstancePatchesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_patches_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstancePatchesOutput, crate::error::DescribeInstancePatchesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instance_patches_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_instance_patches(response.body().as_ref(), output).map_err(crate::error::DescribeInstancePatchesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_patch_states_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstancePatchStatesOutput, crate::error::DescribeInstancePatchStatesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeInstancePatchStatesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeInstancePatchStatesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeInstancePatchStatesError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancePatchStatesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::DescribeInstancePatchStatesError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancePatchStatesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeInstancePatchStatesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_patch_states_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstancePatchStatesOutput, crate::error::DescribeInstancePatchStatesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instance_patch_states_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_instance_patch_states(response.body().as_ref(), output).map_err(crate::error::DescribeInstancePatchStatesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_patch_states_for_patch_group_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstancePatchStatesForPatchGroupOutput, crate::error::DescribeInstancePatchStatesForPatchGroupError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeInstancePatchStatesForPatchGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeInstancePatchStatesForPatchGroupError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeInstancePatchStatesForPatchGroupError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancePatchStatesForPatchGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilter" => crate::error::DescribeInstancePatchStatesForPatchGroupError::InvalidFilter({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancePatchStatesForPatchGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::DescribeInstancePatchStatesForPatchGroupError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancePatchStatesForPatchGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeInstancePatchStatesForPatchGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_patch_states_for_patch_group_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstancePatchStatesForPatchGroupOutput, crate::error::DescribeInstancePatchStatesForPatchGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instance_patch_states_for_patch_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_instance_patch_states_for_patch_group(response.body().as_ref(), output).map_err(crate::error::DescribeInstancePatchStatesForPatchGroupError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_inventory_deletions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInventoryDeletionsOutput, crate::error::DescribeInventoryDeletionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeInventoryDeletionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeInventoryDeletionsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeInventoryDeletionsError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInventoryDeletionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDeletionIdException" => crate::error::DescribeInventoryDeletionsError::InvalidDeletionIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_deletion_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_deletion_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInventoryDeletionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::DescribeInventoryDeletionsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInventoryDeletionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeInventoryDeletionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_inventory_deletions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInventoryDeletionsOutput, crate::error::DescribeInventoryDeletionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_inventory_deletions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_inventory_deletions(response.body().as_ref(), output).map_err(crate::error::DescribeInventoryDeletionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_executions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMaintenanceWindowExecutionsOutput, crate::error::DescribeMaintenanceWindowExecutionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeMaintenanceWindowExecutionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeMaintenanceWindowExecutionsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeMaintenanceWindowExecutionsError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowExecutionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeMaintenanceWindowExecutionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_executions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMaintenanceWindowExecutionsOutput, crate::error::DescribeMaintenanceWindowExecutionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_maintenance_window_executions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_maintenance_window_executions(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowExecutionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_execution_task_invocations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMaintenanceWindowExecutionTaskInvocationsOutput, crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_execution_task_invocations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMaintenanceWindowExecutionTaskInvocationsOutput, crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_maintenance_window_execution_task_invocations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_maintenance_window_execution_task_invocations(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_execution_tasks_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMaintenanceWindowExecutionTasksOutput, crate::error::DescribeMaintenanceWindowExecutionTasksError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeMaintenanceWindowExecutionTasksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeMaintenanceWindowExecutionTasksError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::DescribeMaintenanceWindowExecutionTasksError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowExecutionTasksError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::DescribeMaintenanceWindowExecutionTasksError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowExecutionTasksError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeMaintenanceWindowExecutionTasksError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_execution_tasks_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMaintenanceWindowExecutionTasksOutput, crate::error::DescribeMaintenanceWindowExecutionTasksError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_maintenance_window_execution_tasks_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_maintenance_window_execution_tasks(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowExecutionTasksError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_windows_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMaintenanceWindowsOutput, crate::error::DescribeMaintenanceWindowsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeMaintenanceWindowsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeMaintenanceWindowsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeMaintenanceWindowsError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeMaintenanceWindowsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_windows_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMaintenanceWindowsOutput, crate::error::DescribeMaintenanceWindowsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_maintenance_windows_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_maintenance_windows(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_schedule_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMaintenanceWindowScheduleOutput, crate::error::DescribeMaintenanceWindowScheduleError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeMaintenanceWindowScheduleError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeMaintenanceWindowScheduleError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::DescribeMaintenanceWindowScheduleError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowScheduleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::DescribeMaintenanceWindowScheduleError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowScheduleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeMaintenanceWindowScheduleError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_schedule_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMaintenanceWindowScheduleOutput, crate::error::DescribeMaintenanceWindowScheduleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_maintenance_window_schedule_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_maintenance_window_schedule(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowScheduleError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_windows_for_target_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMaintenanceWindowsForTargetOutput, crate::error::DescribeMaintenanceWindowsForTargetError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeMaintenanceWindowsForTargetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeMaintenanceWindowsForTargetError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeMaintenanceWindowsForTargetError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowsForTargetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeMaintenanceWindowsForTargetError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_windows_for_target_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMaintenanceWindowsForTargetOutput, crate::error::DescribeMaintenanceWindowsForTargetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_maintenance_windows_for_target_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_maintenance_windows_for_target(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowsForTargetError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_targets_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMaintenanceWindowTargetsOutput, crate::error::DescribeMaintenanceWindowTargetsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeMaintenanceWindowTargetsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeMaintenanceWindowTargetsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::DescribeMaintenanceWindowTargetsError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowTargetsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::DescribeMaintenanceWindowTargetsError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowTargetsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeMaintenanceWindowTargetsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_targets_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMaintenanceWindowTargetsOutput, crate::error::DescribeMaintenanceWindowTargetsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_maintenance_window_targets_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_maintenance_window_targets(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowTargetsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_tasks_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMaintenanceWindowTasksOutput, crate::error::DescribeMaintenanceWindowTasksError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeMaintenanceWindowTasksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeMaintenanceWindowTasksError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::DescribeMaintenanceWindowTasksError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowTasksError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::DescribeMaintenanceWindowTasksError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowTasksError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeMaintenanceWindowTasksError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_maintenance_window_tasks_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMaintenanceWindowTasksOutput, crate::error::DescribeMaintenanceWindowTasksError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_maintenance_window_tasks_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_maintenance_window_tasks(response.body().as_ref(), output).map_err(crate::error::DescribeMaintenanceWindowTasksError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_ops_items_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeOpsItemsOutput, crate::error::DescribeOpsItemsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeOpsItemsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeOpsItemsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeOpsItemsError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeOpsItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeOpsItemsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_ops_items_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeOpsItemsOutput, crate::error::DescribeOpsItemsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_ops_items_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_ops_items(response.body().as_ref(), output).map_err(crate::error::DescribeOpsItemsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_parameters_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeParametersOutput, crate::error::DescribeParametersError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeParametersError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeParametersError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeParametersError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeParametersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilterKey" => crate::error::DescribeParametersError::InvalidFilterKey({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_key::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeParametersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilterOption" => crate::error::DescribeParametersError::InvalidFilterOption({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_option::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_option_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeParametersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilterValue" => crate::error::DescribeParametersError::InvalidFilterValue({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_value::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_value_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeParametersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::DescribeParametersError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeParametersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeParametersError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_parameters_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeParametersOutput, crate::error::DescribeParametersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_parameters_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_parameters(response.body().as_ref(), output).map_err(crate::error::DescribeParametersError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_patch_baselines_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribePatchBaselinesOutput, crate::error::DescribePatchBaselinesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribePatchBaselinesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribePatchBaselinesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribePatchBaselinesError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePatchBaselinesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribePatchBaselinesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_patch_baselines_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribePatchBaselinesOutput, crate::error::DescribePatchBaselinesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_patch_baselines_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_patch_baselines(response.body().as_ref(), output).map_err(crate::error::DescribePatchBaselinesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_patch_groups_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribePatchGroupsOutput, crate::error::DescribePatchGroupsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribePatchGroupsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribePatchGroupsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribePatchGroupsError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePatchGroupsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribePatchGroupsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_patch_groups_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribePatchGroupsOutput, crate::error::DescribePatchGroupsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_patch_groups_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_patch_groups(response.body().as_ref(), output).map_err(crate::error::DescribePatchGroupsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_patch_group_state_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribePatchGroupStateOutput, crate::error::DescribePatchGroupStateError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribePatchGroupStateError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribePatchGroupStateError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribePatchGroupStateError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePatchGroupStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::DescribePatchGroupStateError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePatchGroupStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribePatchGroupStateError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_patch_group_state_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribePatchGroupStateOutput, crate::error::DescribePatchGroupStateError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_patch_group_state_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_patch_group_state(response.body().as_ref(), output).map_err(crate::error::DescribePatchGroupStateError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_patch_properties_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribePatchPropertiesOutput, crate::error::DescribePatchPropertiesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribePatchPropertiesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribePatchPropertiesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribePatchPropertiesError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePatchPropertiesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribePatchPropertiesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_patch_properties_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribePatchPropertiesOutput, crate::error::DescribePatchPropertiesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_patch_properties_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_patch_properties(response.body().as_ref(), output).map_err(crate::error::DescribePatchPropertiesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_sessions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSessionsOutput, crate::error::DescribeSessionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeSessionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeSessionsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeSessionsError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeSessionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilterKey" => crate::error::DescribeSessionsError::InvalidFilterKey({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_key::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeSessionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::DescribeSessionsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeSessionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeSessionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_sessions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSessionsOutput, crate::error::DescribeSessionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_sessions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_sessions(response.body().as_ref(), output).map_err(crate::error::DescribeSessionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_ops_item_related_item_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateOpsItemRelatedItemOutput, crate::error::DisassociateOpsItemRelatedItemError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::DisassociateOpsItemRelatedItemError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DisassociateOpsItemRelatedItemError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DisassociateOpsItemRelatedItemError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateOpsItemRelatedItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsItemInvalidParameterException" => crate::error::DisassociateOpsItemRelatedItemError::OpsItemInvalidParameterException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_invalid_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateOpsItemRelatedItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsItemNotFoundException" => crate::error::DisassociateOpsItemRelatedItemError::OpsItemNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateOpsItemRelatedItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsItemRelatedItemAssociationNotFoundException" => crate::error::DisassociateOpsItemRelatedItemError::OpsItemRelatedItemAssociationNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_related_item_association_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_related_item_association_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateOpsItemRelatedItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DisassociateOpsItemRelatedItemError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_ops_item_related_item_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateOpsItemRelatedItemOutput, crate::error::DisassociateOpsItemRelatedItemError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_ops_item_related_item_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_automation_execution_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetAutomationExecutionOutput, crate::error::GetAutomationExecutionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::GetAutomationExecutionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetAutomationExecutionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "AutomationExecutionNotFoundException" => crate::error::GetAutomationExecutionError::AutomationExecutionNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::automation_execution_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_execution_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetAutomationExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::GetAutomationExecutionError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetAutomationExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetAutomationExecutionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_automation_execution_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetAutomationExecutionOutput, crate::error::GetAutomationExecutionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_automation_execution_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_automation_execution(response.body().as_ref(), output).map_err(crate::error::GetAutomationExecutionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_calendar_state_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetCalendarStateOutput, crate::error::GetCalendarStateError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::GetCalendarStateError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetCalendarStateError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetCalendarStateError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetCalendarStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocument" => crate::error::GetCalendarStateError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::GetCalendarStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocumentType" => crate::error::GetCalendarStateError::InvalidDocumentType({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_type_json_err(response.body().as_ref(), output).map_err(crate::error::GetCalendarStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "UnsupportedCalendarException" => crate::error::GetCalendarStateError::UnsupportedCalendarException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_calendar_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_calendar_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCalendarStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetCalendarStateError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_calendar_state_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetCalendarStateOutput, crate::error::GetCalendarStateError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_calendar_state_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_calendar_state(response.body().as_ref(), output).map_err(crate::error::GetCalendarStateError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_command_invocation_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetCommandInvocationOutput, crate::error::GetCommandInvocationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::GetCommandInvocationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetCommandInvocationError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetCommandInvocationError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommandInvocationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidCommandId" => crate::error::GetCommandInvocationError::InvalidCommandId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_command_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_command_id_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommandInvocationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidInstanceId" => crate::error::GetCommandInvocationError::InvalidInstanceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommandInvocationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidPluginName" => crate::error::GetCommandInvocationError::InvalidPluginName({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_plugin_name::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_plugin_name_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommandInvocationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvocationDoesNotExist" => crate::error::GetCommandInvocationError::InvocationDoesNotExist({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invocation_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invocation_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommandInvocationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetCommandInvocationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_command_invocation_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetCommandInvocationOutput, crate::error::GetCommandInvocationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_command_invocation_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_command_invocation(response.body().as_ref(), output).map_err(crate::error::GetCommandInvocationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_connection_status_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetConnectionStatusOutput, crate::error::GetConnectionStatusError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::GetConnectionStatusError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetConnectionStatusError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetConnectionStatusError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetConnectionStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetConnectionStatusError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_connection_status_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetConnectionStatusOutput, crate::error::GetConnectionStatusError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_connection_status_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_connection_status(response.body().as_ref(), output).map_err(crate::error::GetConnectionStatusError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_default_patch_baseline_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetDefaultPatchBaselineOutput, crate::error::GetDefaultPatchBaselineError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::GetDefaultPatchBaselineError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetDefaultPatchBaselineError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetDefaultPatchBaselineError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetDefaultPatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetDefaultPatchBaselineError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_default_patch_baseline_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetDefaultPatchBaselineOutput, crate::error::GetDefaultPatchBaselineError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_default_patch_baseline_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_default_patch_baseline(response.body().as_ref(), output).map_err(crate::error::GetDefaultPatchBaselineError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_deployable_patch_snapshot_for_instance_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetDeployablePatchSnapshotForInstanceOutput, crate::error::GetDeployablePatchSnapshotForInstanceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::GetDeployablePatchSnapshotForInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetDeployablePatchSnapshotForInstanceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetDeployablePatchSnapshotForInstanceError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetDeployablePatchSnapshotForInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "UnsupportedFeatureRequiredException" => crate::error::GetDeployablePatchSnapshotForInstanceError::UnsupportedFeatureRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_feature_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_feature_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDeployablePatchSnapshotForInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "UnsupportedOperatingSystem" => crate::error::GetDeployablePatchSnapshotForInstanceError::UnsupportedOperatingSystem({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_operating_system::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_operating_system_json_err(response.body().as_ref(), output).map_err(crate::error::GetDeployablePatchSnapshotForInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetDeployablePatchSnapshotForInstanceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_deployable_patch_snapshot_for_instance_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetDeployablePatchSnapshotForInstanceOutput, crate::error::GetDeployablePatchSnapshotForInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_deployable_patch_snapshot_for_instance_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_deployable_patch_snapshot_for_instance(response.body().as_ref(), output).map_err(crate::error::GetDeployablePatchSnapshotForInstanceError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_document_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetDocumentOutput, crate::error::GetDocumentError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::GetDocumentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetDocumentError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetDocumentError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocument" => crate::error::GetDocumentError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::GetDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocumentVersion" => crate::error::GetDocumentError::InvalidDocumentVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::GetDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetDocumentError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_document_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetDocumentOutput, crate::error::GetDocumentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_document_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_document(response.body().as_ref(), output).map_err(crate::error::GetDocumentError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_inventory_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetInventoryOutput, crate::error::GetInventoryError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::GetInventoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetInventoryError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetInventoryError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidAggregatorException" => crate::error::GetInventoryError::InvalidAggregatorException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_aggregator_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_aggregator_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilter" => crate::error::GetInventoryError::InvalidFilter({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(response.body().as_ref(), output).map_err(crate::error::GetInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidInventoryGroupException" => crate::error::GetInventoryError::InvalidInventoryGroupException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_inventory_group_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_inventory_group_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::GetInventoryError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::GetInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidResultAttributeException" => crate::error::GetInventoryError::InvalidResultAttributeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_result_attribute_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_result_attribute_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidTypeNameException" => crate::error::GetInventoryError::InvalidTypeNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_type_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_type_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetInventoryError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_inventory_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetInventoryOutput, crate::error::GetInventoryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_inventory_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_inventory(response.body().as_ref(), output).map_err(crate::error::GetInventoryError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_inventory_schema_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetInventorySchemaOutput, crate::error::GetInventorySchemaError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::GetInventorySchemaError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetInventorySchemaError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetInventorySchemaError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetInventorySchemaError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::GetInventorySchemaError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::GetInventorySchemaError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidTypeNameException" => crate::error::GetInventorySchemaError::InvalidTypeNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_type_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_type_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInventorySchemaError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetInventorySchemaError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_inventory_schema_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetInventorySchemaOutput, crate::error::GetInventorySchemaError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_inventory_schema_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_inventory_schema(response.body().as_ref(), output).map_err(crate::error::GetInventorySchemaError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetMaintenanceWindowOutput, crate::error::GetMaintenanceWindowError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::GetMaintenanceWindowError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetMaintenanceWindowError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::GetMaintenanceWindowError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::GetMaintenanceWindowError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetMaintenanceWindowError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetMaintenanceWindowOutput, crate::error::GetMaintenanceWindowError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_maintenance_window_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_maintenance_window(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_execution_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetMaintenanceWindowExecutionOutput, crate::error::GetMaintenanceWindowExecutionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::GetMaintenanceWindowExecutionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetMaintenanceWindowExecutionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::GetMaintenanceWindowExecutionError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::GetMaintenanceWindowExecutionError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetMaintenanceWindowExecutionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_execution_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetMaintenanceWindowExecutionOutput, crate::error::GetMaintenanceWindowExecutionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_maintenance_window_execution_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_maintenance_window_execution(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowExecutionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_execution_task_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetMaintenanceWindowExecutionTaskOutput, crate::error::GetMaintenanceWindowExecutionTaskError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::GetMaintenanceWindowExecutionTaskError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetMaintenanceWindowExecutionTaskError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::GetMaintenanceWindowExecutionTaskError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowExecutionTaskError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::GetMaintenanceWindowExecutionTaskError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowExecutionTaskError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetMaintenanceWindowExecutionTaskError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_execution_task_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetMaintenanceWindowExecutionTaskOutput, crate::error::GetMaintenanceWindowExecutionTaskError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_maintenance_window_execution_task_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_maintenance_window_execution_task(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowExecutionTaskError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_execution_task_invocation_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetMaintenanceWindowExecutionTaskInvocationOutput, crate::error::GetMaintenanceWindowExecutionTaskInvocationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::GetMaintenanceWindowExecutionTaskInvocationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetMaintenanceWindowExecutionTaskInvocationError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::GetMaintenanceWindowExecutionTaskInvocationError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowExecutionTaskInvocationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::GetMaintenanceWindowExecutionTaskInvocationError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowExecutionTaskInvocationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetMaintenanceWindowExecutionTaskInvocationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_execution_task_invocation_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetMaintenanceWindowExecutionTaskInvocationOutput, crate::error::GetMaintenanceWindowExecutionTaskInvocationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_maintenance_window_execution_task_invocation_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_maintenance_window_execution_task_invocation(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowExecutionTaskInvocationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_task_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetMaintenanceWindowTaskOutput, crate::error::GetMaintenanceWindowTaskError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::GetMaintenanceWindowTaskError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetMaintenanceWindowTaskError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::GetMaintenanceWindowTaskError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowTaskError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::GetMaintenanceWindowTaskError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowTaskError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetMaintenanceWindowTaskError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_maintenance_window_task_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetMaintenanceWindowTaskOutput, crate::error::GetMaintenanceWindowTaskError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_maintenance_window_task_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_maintenance_window_task(response.body().as_ref(), output).map_err(crate::error::GetMaintenanceWindowTaskError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ops_item_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetOpsItemOutput, crate::error::GetOpsItemError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::GetOpsItemError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetOpsItemError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetOpsItemError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsItemAccessDeniedException" => crate::error::GetOpsItemError::OpsItemAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsItemNotFoundException" => crate::error::GetOpsItemError::OpsItemNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetOpsItemError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ops_item_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetOpsItemOutput, crate::error::GetOpsItemError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_ops_item_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_ops_item(response.body().as_ref(), output).map_err(crate::error::GetOpsItemError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ops_metadata_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetOpsMetadataOutput, crate::error::GetOpsMetadataError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::GetOpsMetadataError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetOpsMetadataError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetOpsMetadataError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsMetadataInvalidArgumentException" => crate::error::GetOpsMetadataError::OpsMetadataInvalidArgumentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_metadata_invalid_argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_invalid_argument_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsMetadataNotFoundException" => crate::error::GetOpsMetadataError::OpsMetadataNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_metadata_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetOpsMetadataError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ops_metadata_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetOpsMetadataOutput, crate::error::GetOpsMetadataError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_ops_metadata_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_ops_metadata(response.body().as_ref(), output).map_err(crate::error::GetOpsMetadataError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ops_summary_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetOpsSummaryOutput, crate::error::GetOpsSummaryError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::GetOpsSummaryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetOpsSummaryError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetOpsSummaryError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsSummaryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidAggregatorException" => crate::error::GetOpsSummaryError::InvalidAggregatorException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_aggregator_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_aggregator_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsSummaryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilter" => crate::error::GetOpsSummaryError::InvalidFilter({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsSummaryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::GetOpsSummaryError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsSummaryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidTypeNameException" => crate::error::GetOpsSummaryError::InvalidTypeNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_type_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_type_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsSummaryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ResourceDataSyncNotFoundException" => crate::error::GetOpsSummaryError::ResourceDataSyncNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_data_sync_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_data_sync_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOpsSummaryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetOpsSummaryError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ops_summary_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetOpsSummaryOutput, crate::error::GetOpsSummaryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_ops_summary_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_ops_summary(response.body().as_ref(), output).map_err(crate::error::GetOpsSummaryError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_parameter_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetParameterOutput, crate::error::GetParameterError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::GetParameterError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetParameterError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetParameterError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidKeyId" => crate::error::GetParameterError::InvalidKeyId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_key_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_key_id_json_err(response.body().as_ref(), output).map_err(crate::error::GetParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ParameterNotFound" => crate::error::GetParameterError::ParameterNotFound({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::GetParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ParameterVersionNotFound" => crate::error::GetParameterError::ParameterVersionNotFound({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_version_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_version_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::GetParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetParameterError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_parameter_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetParameterOutput, crate::error::GetParameterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_parameter_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_parameter(response.body().as_ref(), output).map_err(crate::error::GetParameterError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_parameter_history_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetParameterHistoryOutput, crate::error::GetParameterHistoryError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::GetParameterHistoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetParameterHistoryError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetParameterHistoryError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetParameterHistoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidKeyId" => crate::error::GetParameterHistoryError::InvalidKeyId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_key_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_key_id_json_err(response.body().as_ref(), output).map_err(crate::error::GetParameterHistoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::GetParameterHistoryError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::GetParameterHistoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ParameterNotFound" => crate::error::GetParameterHistoryError::ParameterNotFound({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::GetParameterHistoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetParameterHistoryError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_parameter_history_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetParameterHistoryOutput, crate::error::GetParameterHistoryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_parameter_history_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_parameter_history(response.body().as_ref(), output).map_err(crate::error::GetParameterHistoryError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_parameters_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetParametersOutput, crate::error::GetParametersError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::GetParametersError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetParametersError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetParametersError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetParametersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidKeyId" => crate::error::GetParametersError::InvalidKeyId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_key_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_key_id_json_err(response.body().as_ref(), output).map_err(crate::error::GetParametersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetParametersError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_parameters_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetParametersOutput, crate::error::GetParametersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_parameters_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_parameters(response.body().as_ref(), output).map_err(crate::error::GetParametersError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_parameters_by_path_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetParametersByPathOutput, crate::error::GetParametersByPathError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::GetParametersByPathError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetParametersByPathError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetParametersByPathError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetParametersByPathError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilterKey" => crate::error::GetParametersByPathError::InvalidFilterKey({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_key::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(response.body().as_ref(), output).map_err(crate::error::GetParametersByPathError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilterOption" => crate::error::GetParametersByPathError::InvalidFilterOption({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_option::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_option_json_err(response.body().as_ref(), output).map_err(crate::error::GetParametersByPathError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilterValue" => crate::error::GetParametersByPathError::InvalidFilterValue({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_value::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_value_json_err(response.body().as_ref(), output).map_err(crate::error::GetParametersByPathError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidKeyId" => crate::error::GetParametersByPathError::InvalidKeyId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_key_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_key_id_json_err(response.body().as_ref(), output).map_err(crate::error::GetParametersByPathError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::GetParametersByPathError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::GetParametersByPathError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetParametersByPathError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_parameters_by_path_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetParametersByPathOutput, crate::error::GetParametersByPathError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_parameters_by_path_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_parameters_by_path(response.body().as_ref(), output).map_err(crate::error::GetParametersByPathError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_patch_baseline_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetPatchBaselineOutput, crate::error::GetPatchBaselineError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::GetPatchBaselineError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetPatchBaselineError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::GetPatchBaselineError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::GetPatchBaselineError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetPatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidResourceId" => crate::error::GetPatchBaselineError::InvalidResourceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::GetPatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetPatchBaselineError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_patch_baseline_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetPatchBaselineOutput, crate::error::GetPatchBaselineError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_patch_baseline_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_patch_baseline(response.body().as_ref(), output).map_err(crate::error::GetPatchBaselineError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_patch_baseline_for_patch_group_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetPatchBaselineForPatchGroupOutput, crate::error::GetPatchBaselineForPatchGroupError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::GetPatchBaselineForPatchGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetPatchBaselineForPatchGroupError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetPatchBaselineForPatchGroupError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetPatchBaselineForPatchGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetPatchBaselineForPatchGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_patch_baseline_for_patch_group_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetPatchBaselineForPatchGroupOutput, crate::error::GetPatchBaselineForPatchGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_patch_baseline_for_patch_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_patch_baseline_for_patch_group(response.body().as_ref(), output).map_err(crate::error::GetPatchBaselineForPatchGroupError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_resource_policies_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetResourcePoliciesOutput, crate::error::GetResourcePoliciesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::GetResourcePoliciesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetResourcePoliciesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetResourcePoliciesError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetResourcePoliciesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ResourcePolicyInvalidParameterException" => crate::error::GetResourcePoliciesError::ResourcePolicyInvalidParameterException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_policy_invalid_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_policy_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetResourcePoliciesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetResourcePoliciesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_resource_policies_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetResourcePoliciesOutput, crate::error::GetResourcePoliciesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_resource_policies_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_resource_policies(response.body().as_ref(), output).map_err(crate::error::GetResourcePoliciesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_service_setting_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetServiceSettingOutput, crate::error::GetServiceSettingError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::GetServiceSettingError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetServiceSettingError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetServiceSettingError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetServiceSettingError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ServiceSettingNotFound" => crate::error::GetServiceSettingError::ServiceSettingNotFound({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_setting_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_setting_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::GetServiceSettingError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetServiceSettingError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_service_setting_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetServiceSettingOutput, crate::error::GetServiceSettingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_service_setting_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_service_setting(response.body().as_ref(), output).map_err(crate::error::GetServiceSettingError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_label_parameter_version_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::LabelParameterVersionOutput, crate::error::LabelParameterVersionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::LabelParameterVersionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::LabelParameterVersionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::LabelParameterVersionError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::LabelParameterVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ParameterNotFound" => crate::error::LabelParameterVersionError::ParameterNotFound({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::LabelParameterVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ParameterVersionLabelLimitExceeded" => crate::error::LabelParameterVersionError::ParameterVersionLabelLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_version_label_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_version_label_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::LabelParameterVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ParameterVersionNotFound" => crate::error::LabelParameterVersionError::ParameterVersionNotFound({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_version_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_version_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::LabelParameterVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyUpdates" => crate::error::LabelParameterVersionError::TooManyUpdates({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_updates::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(response.body().as_ref(), output).map_err(crate::error::LabelParameterVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::LabelParameterVersionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_label_parameter_version_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::LabelParameterVersionOutput, crate::error::LabelParameterVersionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::label_parameter_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_label_parameter_version(response.body().as_ref(), output).map_err(crate::error::LabelParameterVersionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_associations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListAssociationsOutput, crate::error::ListAssociationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::ListAssociationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListAssociationsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListAssociationsError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::ListAssociationsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::ListAssociationsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_associations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListAssociationsOutput, crate::error::ListAssociationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_associations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_associations(response.body().as_ref(), output).map_err(crate::error::ListAssociationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_association_versions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListAssociationVersionsOutput, crate::error::ListAssociationVersionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::ListAssociationVersionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListAssociationVersionsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "AssociationDoesNotExist" => crate::error::ListAssociationVersionsError::AssociationDoesNotExist({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociationVersionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::ListAssociationVersionsError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociationVersionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::ListAssociationVersionsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociationVersionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::ListAssociationVersionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_association_versions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListAssociationVersionsOutput, crate::error::ListAssociationVersionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_association_versions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_association_versions(response.body().as_ref(), output).map_err(crate::error::ListAssociationVersionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_command_invocations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListCommandInvocationsOutput, crate::error::ListCommandInvocationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::ListCommandInvocationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListCommandInvocationsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListCommandInvocationsError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListCommandInvocationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidCommandId" => crate::error::ListCommandInvocationsError::InvalidCommandId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_command_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_command_id_json_err(response.body().as_ref(), output).map_err(crate::error::ListCommandInvocationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilterKey" => crate::error::ListCommandInvocationsError::InvalidFilterKey({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_key::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(response.body().as_ref(), output).map_err(crate::error::ListCommandInvocationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidInstanceId" => crate::error::ListCommandInvocationsError::InvalidInstanceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::ListCommandInvocationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::ListCommandInvocationsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::ListCommandInvocationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::ListCommandInvocationsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_command_invocations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListCommandInvocationsOutput, crate::error::ListCommandInvocationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_command_invocations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_command_invocations(response.body().as_ref(), output).map_err(crate::error::ListCommandInvocationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_commands_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListCommandsOutput, crate::error::ListCommandsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::ListCommandsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListCommandsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListCommandsError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListCommandsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidCommandId" => crate::error::ListCommandsError::InvalidCommandId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_command_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_command_id_json_err(response.body().as_ref(), output).map_err(crate::error::ListCommandsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilterKey" => crate::error::ListCommandsError::InvalidFilterKey({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_key::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(response.body().as_ref(), output).map_err(crate::error::ListCommandsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidInstanceId" => crate::error::ListCommandsError::InvalidInstanceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::ListCommandsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::ListCommandsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::ListCommandsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::ListCommandsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_commands_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListCommandsOutput, crate::error::ListCommandsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_commands_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_commands(response.body().as_ref(), output).map_err(crate::error::ListCommandsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_compliance_items_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListComplianceItemsOutput, crate::error::ListComplianceItemsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::ListComplianceItemsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListComplianceItemsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListComplianceItemsError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListComplianceItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilter" => crate::error::ListComplianceItemsError::InvalidFilter({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(response.body().as_ref(), output).map_err(crate::error::ListComplianceItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::ListComplianceItemsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::ListComplianceItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidResourceId" => crate::error::ListComplianceItemsError::InvalidResourceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::ListComplianceItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidResourceType" => crate::error::ListComplianceItemsError::InvalidResourceType({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_type_json_err(response.body().as_ref(), output).map_err(crate::error::ListComplianceItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::ListComplianceItemsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_compliance_items_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListComplianceItemsOutput, crate::error::ListComplianceItemsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_compliance_items_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_compliance_items(response.body().as_ref(), output).map_err(crate::error::ListComplianceItemsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_compliance_summaries_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListComplianceSummariesOutput, crate::error::ListComplianceSummariesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::ListComplianceSummariesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListComplianceSummariesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListComplianceSummariesError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListComplianceSummariesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilter" => crate::error::ListComplianceSummariesError::InvalidFilter({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(response.body().as_ref(), output).map_err(crate::error::ListComplianceSummariesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::ListComplianceSummariesError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::ListComplianceSummariesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::ListComplianceSummariesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_compliance_summaries_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListComplianceSummariesOutput, crate::error::ListComplianceSummariesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_compliance_summaries_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_compliance_summaries(response.body().as_ref(), output).map_err(crate::error::ListComplianceSummariesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_document_metadata_history_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListDocumentMetadataHistoryOutput, crate::error::ListDocumentMetadataHistoryError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::ListDocumentMetadataHistoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListDocumentMetadataHistoryError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListDocumentMetadataHistoryError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListDocumentMetadataHistoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocument" => crate::error::ListDocumentMetadataHistoryError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::ListDocumentMetadataHistoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocumentVersion" => crate::error::ListDocumentMetadataHistoryError::InvalidDocumentVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::ListDocumentMetadataHistoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::ListDocumentMetadataHistoryError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::ListDocumentMetadataHistoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::ListDocumentMetadataHistoryError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_document_metadata_history_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListDocumentMetadataHistoryOutput, crate::error::ListDocumentMetadataHistoryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_document_metadata_history_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_document_metadata_history(response.body().as_ref(), output).map_err(crate::error::ListDocumentMetadataHistoryError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_documents_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListDocumentsOutput, crate::error::ListDocumentsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::ListDocumentsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListDocumentsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListDocumentsError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListDocumentsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilterKey" => crate::error::ListDocumentsError::InvalidFilterKey({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter_key::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_key_json_err(response.body().as_ref(), output).map_err(crate::error::ListDocumentsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::ListDocumentsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::ListDocumentsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::ListDocumentsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_documents_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListDocumentsOutput, crate::error::ListDocumentsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_documents_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_documents(response.body().as_ref(), output).map_err(crate::error::ListDocumentsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_document_versions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListDocumentVersionsOutput, crate::error::ListDocumentVersionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::ListDocumentVersionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListDocumentVersionsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListDocumentVersionsError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListDocumentVersionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocument" => crate::error::ListDocumentVersionsError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::ListDocumentVersionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::ListDocumentVersionsError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::ListDocumentVersionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::ListDocumentVersionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_document_versions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListDocumentVersionsOutput, crate::error::ListDocumentVersionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_document_versions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_document_versions(response.body().as_ref(), output).map_err(crate::error::ListDocumentVersionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_inventory_entries_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListInventoryEntriesOutput, crate::error::ListInventoryEntriesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::ListInventoryEntriesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListInventoryEntriesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListInventoryEntriesError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListInventoryEntriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilter" => crate::error::ListInventoryEntriesError::InvalidFilter({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(response.body().as_ref(), output).map_err(crate::error::ListInventoryEntriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidInstanceId" => crate::error::ListInventoryEntriesError::InvalidInstanceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::ListInventoryEntriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::ListInventoryEntriesError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::ListInventoryEntriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidTypeNameException" => crate::error::ListInventoryEntriesError::InvalidTypeNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_type_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_type_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListInventoryEntriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::ListInventoryEntriesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_inventory_entries_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListInventoryEntriesOutput, crate::error::ListInventoryEntriesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_inventory_entries_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_inventory_entries(response.body().as_ref(), output).map_err(crate::error::ListInventoryEntriesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_ops_item_events_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListOpsItemEventsOutput, crate::error::ListOpsItemEventsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::ListOpsItemEventsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListOpsItemEventsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListOpsItemEventsError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListOpsItemEventsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsItemInvalidParameterException" => crate::error::ListOpsItemEventsError::OpsItemInvalidParameterException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_invalid_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOpsItemEventsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsItemLimitExceededException" => crate::error::ListOpsItemEventsError::OpsItemLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOpsItemEventsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsItemNotFoundException" => crate::error::ListOpsItemEventsError::OpsItemNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOpsItemEventsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::ListOpsItemEventsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_ops_item_events_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListOpsItemEventsOutput, crate::error::ListOpsItemEventsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_ops_item_events_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_ops_item_events(response.body().as_ref(), output).map_err(crate::error::ListOpsItemEventsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_ops_item_related_items_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListOpsItemRelatedItemsOutput, crate::error::ListOpsItemRelatedItemsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::ListOpsItemRelatedItemsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListOpsItemRelatedItemsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListOpsItemRelatedItemsError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListOpsItemRelatedItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsItemInvalidParameterException" => crate::error::ListOpsItemRelatedItemsError::OpsItemInvalidParameterException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_invalid_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOpsItemRelatedItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::ListOpsItemRelatedItemsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_ops_item_related_items_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListOpsItemRelatedItemsOutput, crate::error::ListOpsItemRelatedItemsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_ops_item_related_items_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_ops_item_related_items(response.body().as_ref(), output).map_err(crate::error::ListOpsItemRelatedItemsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_ops_metadata_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListOpsMetadataOutput, crate::error::ListOpsMetadataError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::ListOpsMetadataError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListOpsMetadataError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListOpsMetadataError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsMetadataInvalidArgumentException" => crate::error::ListOpsMetadataError::OpsMetadataInvalidArgumentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_metadata_invalid_argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_invalid_argument_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::ListOpsMetadataError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_ops_metadata_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListOpsMetadataOutput, crate::error::ListOpsMetadataError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_ops_metadata_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_ops_metadata(response.body().as_ref(), output).map_err(crate::error::ListOpsMetadataError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_resource_compliance_summaries_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListResourceComplianceSummariesOutput, crate::error::ListResourceComplianceSummariesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::ListResourceComplianceSummariesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListResourceComplianceSummariesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListResourceComplianceSummariesError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListResourceComplianceSummariesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilter" => crate::error::ListResourceComplianceSummariesError::InvalidFilter({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_filter::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_filter_json_err(response.body().as_ref(), output).map_err(crate::error::ListResourceComplianceSummariesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::ListResourceComplianceSummariesError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::ListResourceComplianceSummariesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::ListResourceComplianceSummariesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_resource_compliance_summaries_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListResourceComplianceSummariesOutput, crate::error::ListResourceComplianceSummariesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_resource_compliance_summaries_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_resource_compliance_summaries(response.body().as_ref(), output).map_err(crate::error::ListResourceComplianceSummariesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_resource_data_sync_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListResourceDataSyncOutput, crate::error::ListResourceDataSyncError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::ListResourceDataSyncError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListResourceDataSyncError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListResourceDataSyncError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListResourceDataSyncError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNextToken" => crate::error::ListResourceDataSyncError::InvalidNextToken({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_json_err(response.body().as_ref(), output).map_err(crate::error::ListResourceDataSyncError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ResourceDataSyncInvalidConfigurationException" => crate::error::ListResourceDataSyncError::ResourceDataSyncInvalidConfigurationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_data_sync_invalid_configuration_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_data_sync_invalid_configuration_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListResourceDataSyncError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::ListResourceDataSyncError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_resource_data_sync_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListResourceDataSyncOutput, crate::error::ListResourceDataSyncError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_resource_data_sync_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_resource_data_sync(response.body().as_ref(), output).map_err(crate::error::ListResourceDataSyncError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListTagsForResourceOutput, crate::error::ListTagsForResourceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::ListTagsForResourceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListTagsForResourceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListTagsForResourceError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidResourceId" => crate::error::ListTagsForResourceError::InvalidResourceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidResourceType" => crate::error::ListTagsForResourceError::InvalidResourceType({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_type_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::ListTagsForResourceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListTagsForResourceOutput, crate::error::ListTagsForResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_tags_for_resource_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_tags_for_resource(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_document_permission_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyDocumentPermissionOutput, crate::error::ModifyDocumentPermissionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyDocumentPermissionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ModifyDocumentPermissionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DocumentLimitExceeded" => crate::error::ModifyDocumentPermissionError::DocumentLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::document_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_document_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::ModifyDocumentPermissionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "DocumentPermissionLimit" => crate::error::ModifyDocumentPermissionError::DocumentPermissionLimit({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::document_permission_limit::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_document_permission_limit_json_err(response.body().as_ref(), output).map_err(crate::error::ModifyDocumentPermissionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::ModifyDocumentPermissionError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ModifyDocumentPermissionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocument" => crate::error::ModifyDocumentPermissionError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::ModifyDocumentPermissionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidPermissionType" => crate::error::ModifyDocumentPermissionError::InvalidPermissionType({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_permission_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_permission_type_json_err(response.body().as_ref(), output).map_err(crate::error::ModifyDocumentPermissionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::ModifyDocumentPermissionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_document_permission_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyDocumentPermissionOutput, crate::error::ModifyDocumentPermissionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_document_permission_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_compliance_items_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutComplianceItemsOutput, crate::error::PutComplianceItemsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::PutComplianceItemsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::PutComplianceItemsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ComplianceTypeCountLimitExceededException" => crate::error::PutComplianceItemsError::ComplianceTypeCountLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::compliance_type_count_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_compliance_type_count_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutComplianceItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::PutComplianceItemsError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::PutComplianceItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidItemContentException" => crate::error::PutComplianceItemsError::InvalidItemContentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_item_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_item_content_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutComplianceItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidResourceId" => crate::error::PutComplianceItemsError::InvalidResourceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::PutComplianceItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidResourceType" => crate::error::PutComplianceItemsError::InvalidResourceType({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_type_json_err(response.body().as_ref(), output).map_err(crate::error::PutComplianceItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ItemSizeLimitExceededException" => crate::error::PutComplianceItemsError::ItemSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::item_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_item_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutComplianceItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TotalSizeLimitExceededException" => crate::error::PutComplianceItemsError::TotalSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::total_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_total_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutComplianceItemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::PutComplianceItemsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_compliance_items_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutComplianceItemsOutput, crate::error::PutComplianceItemsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_compliance_items_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_inventory_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutInventoryOutput, crate::error::PutInventoryError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::PutInventoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::PutInventoryError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "CustomSchemaCountLimitExceededException" => crate::error::PutInventoryError::CustomSchemaCountLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::custom_schema_count_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_custom_schema_count_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::PutInventoryError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidInstanceId" => crate::error::PutInventoryError::InvalidInstanceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidInventoryItemContextException" => crate::error::PutInventoryError::InvalidInventoryItemContextException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_inventory_item_context_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_inventory_item_context_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidItemContentException" => crate::error::PutInventoryError::InvalidItemContentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_item_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_item_content_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidTypeNameException" => crate::error::PutInventoryError::InvalidTypeNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_type_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_type_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ItemContentMismatchException" => crate::error::PutInventoryError::ItemContentMismatchException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::item_content_mismatch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_item_content_mismatch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ItemSizeLimitExceededException" => crate::error::PutInventoryError::ItemSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::item_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_item_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "SubTypeCountLimitExceededException" => crate::error::PutInventoryError::SubTypeCountLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::sub_type_count_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_sub_type_count_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TotalSizeLimitExceededException" => crate::error::PutInventoryError::TotalSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::total_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_total_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "UnsupportedInventoryItemContextException" => crate::error::PutInventoryError::UnsupportedInventoryItemContextException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_inventory_item_context_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_inventory_item_context_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "UnsupportedInventorySchemaVersionException" => crate::error::PutInventoryError::UnsupportedInventorySchemaVersionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_inventory_schema_version_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_inventory_schema_version_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::PutInventoryError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_inventory_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutInventoryOutput, crate::error::PutInventoryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_inventory_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_inventory(response.body().as_ref(), output).map_err(crate::error::PutInventoryError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_parameter_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutParameterOutput, crate::error::PutParameterError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::PutParameterError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::PutParameterError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "HierarchyLevelLimitExceededException" => crate::error::PutParameterError::HierarchyLevelLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::hierarchy_level_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_hierarchy_level_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "HierarchyTypeMismatchException" => crate::error::PutParameterError::HierarchyTypeMismatchException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::hierarchy_type_mismatch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_hierarchy_type_mismatch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "IncompatiblePolicyException" => crate::error::PutParameterError::IncompatiblePolicyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::incompatible_policy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_incompatible_policy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::PutParameterError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidAllowedPatternException" => crate::error::PutParameterError::InvalidAllowedPatternException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_allowed_pattern_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_allowed_pattern_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidKeyId" => crate::error::PutParameterError::InvalidKeyId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_key_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_key_id_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidPolicyAttributeException" => crate::error::PutParameterError::InvalidPolicyAttributeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_policy_attribute_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_policy_attribute_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidPolicyTypeException" => crate::error::PutParameterError::InvalidPolicyTypeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_policy_type_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_policy_type_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ParameterAlreadyExists" => crate::error::PutParameterError::ParameterAlreadyExists({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_already_exists::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_already_exists_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ParameterLimitExceeded" => crate::error::PutParameterError::ParameterLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ParameterMaxVersionLimitExceeded" => crate::error::PutParameterError::ParameterMaxVersionLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_max_version_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_max_version_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ParameterPatternMismatchException" => crate::error::PutParameterError::ParameterPatternMismatchException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_pattern_mismatch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_pattern_mismatch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PoliciesLimitExceededException" => crate::error::PutParameterError::PoliciesLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::policies_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_policies_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyUpdates" => crate::error::PutParameterError::TooManyUpdates({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_updates::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "UnsupportedParameterType" => crate::error::PutParameterError::UnsupportedParameterType({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_parameter_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_parameter_type_json_err(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::PutParameterError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_parameter_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutParameterOutput, crate::error::PutParameterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_parameter_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_parameter(response.body().as_ref(), output).map_err(crate::error::PutParameterError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_resource_policy_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutResourcePolicyOutput, crate::error::PutResourcePolicyError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::PutResourcePolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::PutResourcePolicyError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::PutResourcePolicyError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::PutResourcePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ResourcePolicyConflictException" => crate::error::PutResourcePolicyError::ResourcePolicyConflictException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_policy_conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_policy_conflict_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutResourcePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ResourcePolicyInvalidParameterException" => crate::error::PutResourcePolicyError::ResourcePolicyInvalidParameterException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_policy_invalid_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_policy_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutResourcePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ResourcePolicyLimitExceededException" => crate::error::PutResourcePolicyError::ResourcePolicyLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_policy_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_policy_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutResourcePolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::PutResourcePolicyError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_resource_policy_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutResourcePolicyOutput, crate::error::PutResourcePolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_resource_policy_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_resource_policy(response.body().as_ref(), output).map_err(crate::error::PutResourcePolicyError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_default_patch_baseline_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterDefaultPatchBaselineOutput, crate::error::RegisterDefaultPatchBaselineError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::RegisterDefaultPatchBaselineError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::RegisterDefaultPatchBaselineError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::RegisterDefaultPatchBaselineError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterDefaultPatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::RegisterDefaultPatchBaselineError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterDefaultPatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidResourceId" => crate::error::RegisterDefaultPatchBaselineError::InvalidResourceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterDefaultPatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::RegisterDefaultPatchBaselineError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_default_patch_baseline_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterDefaultPatchBaselineOutput, crate::error::RegisterDefaultPatchBaselineError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::register_default_patch_baseline_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_register_default_patch_baseline(response.body().as_ref(), output).map_err(crate::error::RegisterDefaultPatchBaselineError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_patch_baseline_for_patch_group_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterPatchBaselineForPatchGroupOutput, crate::error::RegisterPatchBaselineForPatchGroupError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::RegisterPatchBaselineForPatchGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::RegisterPatchBaselineForPatchGroupError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "AlreadyExistsException" => crate::error::RegisterPatchBaselineForPatchGroupError::AlreadyExistsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterPatchBaselineForPatchGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "DoesNotExistException" => crate::error::RegisterPatchBaselineForPatchGroupError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterPatchBaselineForPatchGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::RegisterPatchBaselineForPatchGroupError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterPatchBaselineForPatchGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidResourceId" => crate::error::RegisterPatchBaselineForPatchGroupError::InvalidResourceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterPatchBaselineForPatchGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ResourceLimitExceededException" => crate::error::RegisterPatchBaselineForPatchGroupError::ResourceLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterPatchBaselineForPatchGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::RegisterPatchBaselineForPatchGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_patch_baseline_for_patch_group_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterPatchBaselineForPatchGroupOutput, crate::error::RegisterPatchBaselineForPatchGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::register_patch_baseline_for_patch_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_register_patch_baseline_for_patch_group(response.body().as_ref(), output).map_err(crate::error::RegisterPatchBaselineForPatchGroupError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_target_with_maintenance_window_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterTargetWithMaintenanceWindowOutput, crate::error::RegisterTargetWithMaintenanceWindowError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::RegisterTargetWithMaintenanceWindowError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::RegisterTargetWithMaintenanceWindowError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::RegisterTargetWithMaintenanceWindowError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTargetWithMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "IdempotentParameterMismatch" => crate::error::RegisterTargetWithMaintenanceWindowError::IdempotentParameterMismatch({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::idempotent_parameter_mismatch::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotent_parameter_mismatch_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTargetWithMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::RegisterTargetWithMaintenanceWindowError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTargetWithMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ResourceLimitExceededException" => crate::error::RegisterTargetWithMaintenanceWindowError::ResourceLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTargetWithMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::RegisterTargetWithMaintenanceWindowError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_target_with_maintenance_window_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterTargetWithMaintenanceWindowOutput, crate::error::RegisterTargetWithMaintenanceWindowError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::register_target_with_maintenance_window_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_register_target_with_maintenance_window(response.body().as_ref(), output).map_err(crate::error::RegisterTargetWithMaintenanceWindowError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_task_with_maintenance_window_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterTaskWithMaintenanceWindowOutput, crate::error::RegisterTaskWithMaintenanceWindowError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::RegisterTaskWithMaintenanceWindowError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::RegisterTaskWithMaintenanceWindowError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::RegisterTaskWithMaintenanceWindowError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTaskWithMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "FeatureNotAvailableException" => crate::error::RegisterTaskWithMaintenanceWindowError::FeatureNotAvailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::feature_not_available_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_feature_not_available_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTaskWithMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "IdempotentParameterMismatch" => crate::error::RegisterTaskWithMaintenanceWindowError::IdempotentParameterMismatch({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::idempotent_parameter_mismatch::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotent_parameter_mismatch_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTaskWithMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::RegisterTaskWithMaintenanceWindowError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTaskWithMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ResourceLimitExceededException" => crate::error::RegisterTaskWithMaintenanceWindowError::ResourceLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterTaskWithMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::RegisterTaskWithMaintenanceWindowError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_task_with_maintenance_window_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterTaskWithMaintenanceWindowOutput, crate::error::RegisterTaskWithMaintenanceWindowError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::register_task_with_maintenance_window_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_register_task_with_maintenance_window(response.body().as_ref(), output).map_err(crate::error::RegisterTaskWithMaintenanceWindowError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_tags_from_resource_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RemoveTagsFromResourceOutput, crate::error::RemoveTagsFromResourceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::RemoveTagsFromResourceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::RemoveTagsFromResourceError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidResourceId" => crate::error::RemoveTagsFromResourceError::InvalidResourceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_id_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidResourceType" => crate::error::RemoveTagsFromResourceError::InvalidResourceType({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_type_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyUpdates" => crate::error::RemoveTagsFromResourceError::TooManyUpdates({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_updates::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::RemoveTagsFromResourceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_tags_from_resource_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RemoveTagsFromResourceOutput, crate::error::RemoveTagsFromResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_tags_from_resource_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_service_setting_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ResetServiceSettingOutput, crate::error::ResetServiceSettingError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::ResetServiceSettingError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ResetServiceSettingError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ResetServiceSettingError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ResetServiceSettingError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ServiceSettingNotFound" => crate::error::ResetServiceSettingError::ServiceSettingNotFound({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_setting_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_setting_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::ResetServiceSettingError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyUpdates" => crate::error::ResetServiceSettingError::TooManyUpdates({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_updates::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(response.body().as_ref(), output).map_err(crate::error::ResetServiceSettingError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::ResetServiceSettingError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_service_setting_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ResetServiceSettingOutput, crate::error::ResetServiceSettingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reset_service_setting_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_reset_service_setting(response.body().as_ref(), output).map_err(crate::error::ResetServiceSettingError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_resume_session_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ResumeSessionOutput, crate::error::ResumeSessionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::ResumeSessionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ResumeSessionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::ResumeSessionError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ResumeSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::ResumeSessionError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ResumeSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::ResumeSessionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_resume_session_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ResumeSessionOutput, crate::error::ResumeSessionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::resume_session_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_resume_session(response.body().as_ref(), output).map_err(crate::error::ResumeSessionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_automation_signal_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::SendAutomationSignalOutput, crate::error::SendAutomationSignalError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::SendAutomationSignalError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::SendAutomationSignalError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "AutomationExecutionNotFoundException" => crate::error::SendAutomationSignalError::AutomationExecutionNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::automation_execution_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_execution_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SendAutomationSignalError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "AutomationStepNotFoundException" => crate::error::SendAutomationSignalError::AutomationStepNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::automation_step_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_step_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SendAutomationSignalError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::SendAutomationSignalError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::SendAutomationSignalError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidAutomationSignalException" => crate::error::SendAutomationSignalError::InvalidAutomationSignalException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_automation_signal_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_automation_signal_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SendAutomationSignalError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::SendAutomationSignalError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_automation_signal_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::SendAutomationSignalOutput, crate::error::SendAutomationSignalError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::send_automation_signal_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_command_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::SendCommandOutput, crate::error::SendCommandError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::SendCommandError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::SendCommandError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DuplicateInstanceId" => crate::error::SendCommandError::DuplicateInstanceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::duplicate_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_duplicate_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::SendCommandError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocument" => crate::error::SendCommandError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocumentVersion" => crate::error::SendCommandError::InvalidDocumentVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidInstanceId" => crate::error::SendCommandError::InvalidInstanceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidNotificationConfig" => crate::error::SendCommandError::InvalidNotificationConfig({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_notification_config::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_notification_config_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOutputFolder" => crate::error::SendCommandError::InvalidOutputFolder({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_output_folder::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_output_folder_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidParameters" => crate::error::SendCommandError::InvalidParameters({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_parameters::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameters_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRole" => crate::error::SendCommandError::InvalidRole({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_role::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_role_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaxDocumentSizeExceeded" => crate::error::SendCommandError::MaxDocumentSizeExceeded({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::max_document_size_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_max_document_size_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "UnsupportedPlatformType" => crate::error::SendCommandError::UnsupportedPlatformType({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_platform_type::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_platform_type_json_err(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::SendCommandError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_command_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::SendCommandOutput, crate::error::SendCommandError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::send_command_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_send_command(response.body().as_ref(), output).map_err(crate::error::SendCommandError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_associations_once_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartAssociationsOnceOutput, crate::error::StartAssociationsOnceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::StartAssociationsOnceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::StartAssociationsOnceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "AssociationDoesNotExist" => crate::error::StartAssociationsOnceError::AssociationDoesNotExist({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::StartAssociationsOnceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidAssociation" => crate::error::StartAssociationsOnceError::InvalidAssociation({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_association::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_association_json_err(response.body().as_ref(), output).map_err(crate::error::StartAssociationsOnceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::StartAssociationsOnceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_associations_once_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartAssociationsOnceOutput, crate::error::StartAssociationsOnceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_associations_once_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_automation_execution_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartAutomationExecutionOutput, crate::error::StartAutomationExecutionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::StartAutomationExecutionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::StartAutomationExecutionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "AutomationDefinitionNotFoundException" => crate::error::StartAutomationExecutionError::AutomationDefinitionNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::automation_definition_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_definition_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartAutomationExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "AutomationDefinitionVersionNotFoundException" => crate::error::StartAutomationExecutionError::AutomationDefinitionVersionNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::automation_definition_version_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_definition_version_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartAutomationExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "AutomationExecutionLimitExceededException" => crate::error::StartAutomationExecutionError::AutomationExecutionLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::automation_execution_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_execution_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartAutomationExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "IdempotentParameterMismatch" => crate::error::StartAutomationExecutionError::IdempotentParameterMismatch({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::idempotent_parameter_mismatch::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotent_parameter_mismatch_json_err(response.body().as_ref(), output).map_err(crate::error::StartAutomationExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::StartAutomationExecutionError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::StartAutomationExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidAutomationExecutionParametersException" => crate::error::StartAutomationExecutionError::InvalidAutomationExecutionParametersException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_automation_execution_parameters_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_automation_execution_parameters_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartAutomationExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidTarget" => crate::error::StartAutomationExecutionError::InvalidTarget({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_target::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_target_json_err(response.body().as_ref(), output).map_err(crate::error::StartAutomationExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::StartAutomationExecutionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_automation_execution_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartAutomationExecutionOutput, crate::error::StartAutomationExecutionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_automation_execution_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_start_automation_execution(response.body().as_ref(), output).map_err(crate::error::StartAutomationExecutionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_change_request_execution_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartChangeRequestExecutionOutput, crate::error::StartChangeRequestExecutionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::StartChangeRequestExecutionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "AutomationDefinitionNotApprovedException" => crate::error::StartChangeRequestExecutionError::AutomationDefinitionNotApprovedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::automation_definition_not_approved_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_definition_not_approved_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "AutomationDefinitionNotFoundException" => crate::error::StartChangeRequestExecutionError::AutomationDefinitionNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::automation_definition_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_definition_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "AutomationDefinitionVersionNotFoundException" => crate::error::StartChangeRequestExecutionError::AutomationDefinitionVersionNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::automation_definition_version_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_definition_version_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "AutomationExecutionLimitExceededException" => crate::error::StartChangeRequestExecutionError::AutomationExecutionLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::automation_execution_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_execution_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "IdempotentParameterMismatch" => crate::error::StartChangeRequestExecutionError::IdempotentParameterMismatch({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::idempotent_parameter_mismatch::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotent_parameter_mismatch_json_err(response.body().as_ref(), output).map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::StartChangeRequestExecutionError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidAutomationExecutionParametersException" => crate::error::StartChangeRequestExecutionError::InvalidAutomationExecutionParametersException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_automation_execution_parameters_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_automation_execution_parameters_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::StartChangeRequestExecutionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_change_request_execution_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartChangeRequestExecutionOutput, crate::error::StartChangeRequestExecutionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_change_request_execution_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_start_change_request_execution(response.body().as_ref(), output).map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_session_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartSessionOutput, crate::error::StartSessionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::StartSessionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::StartSessionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::StartSessionError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::StartSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocument" => crate::error::StartSessionError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::StartSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TargetNotConnected" => crate::error::StartSessionError::TargetNotConnected({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::target_not_connected::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_target_not_connected_json_err(response.body().as_ref(), output).map_err(crate::error::StartSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::StartSessionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_session_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartSessionOutput, crate::error::StartSessionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_session_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_start_session(response.body().as_ref(), output).map_err(crate::error::StartSessionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_automation_execution_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StopAutomationExecutionOutput, crate::error::StopAutomationExecutionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::StopAutomationExecutionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::StopAutomationExecutionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "AutomationExecutionNotFoundException" => crate::error::StopAutomationExecutionError::AutomationExecutionNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::automation_execution_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_automation_execution_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopAutomationExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::StopAutomationExecutionError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::StopAutomationExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidAutomationStatusUpdateException" => crate::error::StopAutomationExecutionError::InvalidAutomationStatusUpdateException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_automation_status_update_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_automation_status_update_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopAutomationExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::StopAutomationExecutionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_automation_execution_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StopAutomationExecutionOutput, crate::error::StopAutomationExecutionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_automation_execution_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_terminate_session_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::TerminateSessionOutput, crate::error::TerminateSessionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::TerminateSessionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::TerminateSessionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::TerminateSessionError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::TerminateSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::TerminateSessionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_terminate_session_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::TerminateSessionOutput, crate::error::TerminateSessionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::terminate_session_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_terminate_session(response.body().as_ref(), output).map_err(crate::error::TerminateSessionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_unlabel_parameter_version_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UnlabelParameterVersionOutput, crate::error::UnlabelParameterVersionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::UnlabelParameterVersionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UnlabelParameterVersionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::UnlabelParameterVersionError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UnlabelParameterVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ParameterNotFound" => crate::error::UnlabelParameterVersionError::ParameterNotFound({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::UnlabelParameterVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ParameterVersionNotFound" => crate::error::UnlabelParameterVersionError::ParameterVersionNotFound({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parameter_version_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parameter_version_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::UnlabelParameterVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyUpdates" => crate::error::UnlabelParameterVersionError::TooManyUpdates({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_updates::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(response.body().as_ref(), output).map_err(crate::error::UnlabelParameterVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::UnlabelParameterVersionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_unlabel_parameter_version_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UnlabelParameterVersionOutput, crate::error::UnlabelParameterVersionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::unlabel_parameter_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_unlabel_parameter_version(response.body().as_ref(), output).map_err(crate::error::UnlabelParameterVersionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_association_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateAssociationOutput, crate::error::UpdateAssociationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::UpdateAssociationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateAssociationError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "AssociationDoesNotExist" => crate::error::UpdateAssociationError::AssociationDoesNotExist({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "AssociationVersionLimitExceeded" => crate::error::UpdateAssociationError::AssociationVersionLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_version_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_version_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::UpdateAssociationError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidAssociationVersion" => crate::error::UpdateAssociationError::InvalidAssociationVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_association_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_association_version_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocument" => crate::error::UpdateAssociationError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocumentVersion" => crate::error::UpdateAssociationError::InvalidDocumentVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOutputLocation" => crate::error::UpdateAssociationError::InvalidOutputLocation({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_output_location::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_output_location_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidParameters" => crate::error::UpdateAssociationError::InvalidParameters({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_parameters::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameters_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidSchedule" => crate::error::UpdateAssociationError::InvalidSchedule({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_schedule::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_schedule_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidTarget" => crate::error::UpdateAssociationError::InvalidTarget({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_target::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_target_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidTargetMaps" => crate::error::UpdateAssociationError::InvalidTargetMaps({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_target_maps::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_target_maps_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidUpdate" => crate::error::UpdateAssociationError::InvalidUpdate({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_update::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_update_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyUpdates" => crate::error::UpdateAssociationError::TooManyUpdates({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_updates::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::UpdateAssociationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_association_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateAssociationOutput, crate::error::UpdateAssociationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_association_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_association(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_association_status_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateAssociationStatusOutput, crate::error::UpdateAssociationStatusError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::UpdateAssociationStatusError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateAssociationStatusError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "AssociationDoesNotExist" => crate::error::UpdateAssociationStatusError::AssociationDoesNotExist({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::association_does_not_exist::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_association_does_not_exist_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::UpdateAssociationStatusError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocument" => crate::error::UpdateAssociationStatusError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidInstanceId" => crate::error::UpdateAssociationStatusError::InvalidInstanceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "StatusUnchanged" => crate::error::UpdateAssociationStatusError::StatusUnchanged({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::status_unchanged::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_status_unchanged_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyUpdates" => crate::error::UpdateAssociationStatusError::TooManyUpdates({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_updates::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::UpdateAssociationStatusError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_association_status_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateAssociationStatusOutput, crate::error::UpdateAssociationStatusError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_association_status_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_association_status(response.body().as_ref(), output).map_err(crate::error::UpdateAssociationStatusError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_document_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateDocumentOutput, crate::error::UpdateDocumentError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::UpdateDocumentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateDocumentError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DocumentVersionLimitExceeded" => crate::error::UpdateDocumentError::DocumentVersionLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::document_version_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_document_version_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "DuplicateDocumentContent" => crate::error::UpdateDocumentError::DuplicateDocumentContent({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::duplicate_document_content::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_duplicate_document_content_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "DuplicateDocumentVersionName" => crate::error::UpdateDocumentError::DuplicateDocumentVersionName({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::duplicate_document_version_name::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_duplicate_document_version_name_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::UpdateDocumentError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocument" => crate::error::UpdateDocumentError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocumentContent" => crate::error::UpdateDocumentError::InvalidDocumentContent({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_content::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_content_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocumentOperation" => crate::error::UpdateDocumentError::InvalidDocumentOperation({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_operation::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_operation_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocumentSchemaVersion" => crate::error::UpdateDocumentError::InvalidDocumentSchemaVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_schema_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_schema_version_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocumentVersion" => crate::error::UpdateDocumentError::InvalidDocumentVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaxDocumentSizeExceeded" => crate::error::UpdateDocumentError::MaxDocumentSizeExceeded({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::max_document_size_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_max_document_size_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::UpdateDocumentError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_document_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateDocumentOutput, crate::error::UpdateDocumentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_document_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_document(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_document_default_version_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateDocumentDefaultVersionOutput, crate::error::UpdateDocumentDefaultVersionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::UpdateDocumentDefaultVersionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateDocumentDefaultVersionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::UpdateDocumentDefaultVersionError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentDefaultVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocument" => crate::error::UpdateDocumentDefaultVersionError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentDefaultVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocumentSchemaVersion" => crate::error::UpdateDocumentDefaultVersionError::InvalidDocumentSchemaVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_schema_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_schema_version_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentDefaultVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocumentVersion" => crate::error::UpdateDocumentDefaultVersionError::InvalidDocumentVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentDefaultVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::UpdateDocumentDefaultVersionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_document_default_version_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateDocumentDefaultVersionOutput, crate::error::UpdateDocumentDefaultVersionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_document_default_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_document_default_version(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentDefaultVersionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_document_metadata_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateDocumentMetadataOutput, crate::error::UpdateDocumentMetadataError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::UpdateDocumentMetadataError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateDocumentMetadataError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::UpdateDocumentMetadataError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocument" => crate::error::UpdateDocumentMetadataError::InvalidDocument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocumentOperation" => crate::error::UpdateDocumentMetadataError::InvalidDocumentOperation({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_operation::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_operation_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidDocumentVersion" => crate::error::UpdateDocumentMetadataError::InvalidDocumentVersion({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_document_version::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_document_version_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::UpdateDocumentMetadataError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_document_metadata_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateDocumentMetadataOutput, crate::error::UpdateDocumentMetadataError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_document_metadata_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_maintenance_window_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateMaintenanceWindowOutput, crate::error::UpdateMaintenanceWindowError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::UpdateMaintenanceWindowError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateMaintenanceWindowError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::UpdateMaintenanceWindowError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::UpdateMaintenanceWindowError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateMaintenanceWindowError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::UpdateMaintenanceWindowError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_maintenance_window_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateMaintenanceWindowOutput, crate::error::UpdateMaintenanceWindowError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_maintenance_window_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_maintenance_window(response.body().as_ref(), output).map_err(crate::error::UpdateMaintenanceWindowError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_maintenance_window_target_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateMaintenanceWindowTargetOutput, crate::error::UpdateMaintenanceWindowTargetError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::UpdateMaintenanceWindowTargetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateMaintenanceWindowTargetError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::UpdateMaintenanceWindowTargetError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateMaintenanceWindowTargetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::UpdateMaintenanceWindowTargetError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateMaintenanceWindowTargetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::UpdateMaintenanceWindowTargetError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_maintenance_window_target_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateMaintenanceWindowTargetOutput, crate::error::UpdateMaintenanceWindowTargetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_maintenance_window_target_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_maintenance_window_target(response.body().as_ref(), output).map_err(crate::error::UpdateMaintenanceWindowTargetError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_maintenance_window_task_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateMaintenanceWindowTaskOutput, crate::error::UpdateMaintenanceWindowTaskError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::UpdateMaintenanceWindowTaskError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateMaintenanceWindowTaskError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::UpdateMaintenanceWindowTaskError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateMaintenanceWindowTaskError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::UpdateMaintenanceWindowTaskError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateMaintenanceWindowTaskError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::UpdateMaintenanceWindowTaskError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_maintenance_window_task_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateMaintenanceWindowTaskOutput, crate::error::UpdateMaintenanceWindowTaskError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_maintenance_window_task_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_maintenance_window_task(response.body().as_ref(), output).map_err(crate::error::UpdateMaintenanceWindowTaskError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_managed_instance_role_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateManagedInstanceRoleOutput, crate::error::UpdateManagedInstanceRoleError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::UpdateManagedInstanceRoleError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateManagedInstanceRoleError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::UpdateManagedInstanceRoleError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateManagedInstanceRoleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidInstanceId" => crate::error::UpdateManagedInstanceRoleError::InvalidInstanceId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_instance_id::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_instance_id_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateManagedInstanceRoleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::UpdateManagedInstanceRoleError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_managed_instance_role_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateManagedInstanceRoleOutput, crate::error::UpdateManagedInstanceRoleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_managed_instance_role_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_ops_item_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateOpsItemOutput, crate::error::UpdateOpsItemError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::UpdateOpsItemError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateOpsItemError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::UpdateOpsItemError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsItemAccessDeniedException" => crate::error::UpdateOpsItemError::OpsItemAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsItemAlreadyExistsException" => crate::error::UpdateOpsItemError::OpsItemAlreadyExistsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsItemInvalidParameterException" => crate::error::UpdateOpsItemError::OpsItemInvalidParameterException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_invalid_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsItemLimitExceededException" => crate::error::UpdateOpsItemError::OpsItemLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsItemNotFoundException" => crate::error::UpdateOpsItemError::OpsItemNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_item_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_item_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsItemError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::UpdateOpsItemError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_ops_item_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateOpsItemOutput, crate::error::UpdateOpsItemError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_ops_item_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_ops_metadata_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateOpsMetadataOutput, crate::error::UpdateOpsMetadataError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::UpdateOpsMetadataError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateOpsMetadataError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::UpdateOpsMetadataError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsMetadataInvalidArgumentException" => crate::error::UpdateOpsMetadataError::OpsMetadataInvalidArgumentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_metadata_invalid_argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_invalid_argument_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsMetadataKeyLimitExceededException" => crate::error::UpdateOpsMetadataError::OpsMetadataKeyLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_metadata_key_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_key_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsMetadataNotFoundException" => crate::error::UpdateOpsMetadataError::OpsMetadataNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_metadata_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OpsMetadataTooManyUpdatesException" => crate::error::UpdateOpsMetadataError::OpsMetadataTooManyUpdatesException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::ops_metadata_too_many_updates_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_ops_metadata_too_many_updates_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpsMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::UpdateOpsMetadataError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_ops_metadata_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateOpsMetadataOutput, crate::error::UpdateOpsMetadataError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_ops_metadata_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_ops_metadata(response.body().as_ref(), output).map_err(crate::error::UpdateOpsMetadataError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_patch_baseline_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdatePatchBaselineOutput, crate::error::UpdatePatchBaselineError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::UpdatePatchBaselineError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdatePatchBaselineError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "DoesNotExistException" => crate::error::UpdatePatchBaselineError::DoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InternalServerError" => crate::error::UpdatePatchBaselineError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePatchBaselineError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::UpdatePatchBaselineError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_patch_baseline_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdatePatchBaselineOutput, crate::error::UpdatePatchBaselineError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_patch_baseline_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_patch_baseline(response.body().as_ref(), output).map_err(crate::error::UpdatePatchBaselineError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_resource_data_sync_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateResourceDataSyncOutput, crate::error::UpdateResourceDataSyncError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::UpdateResourceDataSyncError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateResourceDataSyncError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::UpdateResourceDataSyncError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateResourceDataSyncError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ResourceDataSyncConflictException" => crate::error::UpdateResourceDataSyncError::ResourceDataSyncConflictException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_data_sync_conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_data_sync_conflict_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateResourceDataSyncError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ResourceDataSyncInvalidConfigurationException" => crate::error::UpdateResourceDataSyncError::ResourceDataSyncInvalidConfigurationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_data_sync_invalid_configuration_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_data_sync_invalid_configuration_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateResourceDataSyncError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ResourceDataSyncNotFoundException" => crate::error::UpdateResourceDataSyncError::ResourceDataSyncNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_data_sync_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_data_sync_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateResourceDataSyncError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::UpdateResourceDataSyncError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_resource_data_sync_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateResourceDataSyncOutput, crate::error::UpdateResourceDataSyncError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_resource_data_sync_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_service_setting_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateServiceSettingOutput, crate::error::UpdateServiceSettingError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(crate::error::UpdateServiceSettingError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateServiceSettingError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::UpdateServiceSettingError::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateServiceSettingError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ServiceSettingNotFound" => crate::error::UpdateServiceSettingError::ServiceSettingNotFound({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_setting_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_setting_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateServiceSettingError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyUpdates" => crate::error::UpdateServiceSettingError::TooManyUpdates({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_updates::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_updates_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateServiceSettingError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::UpdateServiceSettingError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_service_setting_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateServiceSettingOutput, crate::error::UpdateServiceSettingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_service_setting_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

