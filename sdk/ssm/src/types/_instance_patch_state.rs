// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Defines the high-level patch compliance state for a managed node, providing information about the number of installed, missing, not applicable, and failed patches along with metadata about the operation when this information was gathered for the managed node.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstancePatchState {
    /// <p>The ID of the managed node the high-level patch compliance information was collected for.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The name of the patch group the managed node belongs to.</p>
    #[doc(hidden)]
    pub patch_group: std::option::Option<std::string::String>,
    /// <p>The ID of the patch baseline used to patch the managed node.</p>
    #[doc(hidden)]
    pub baseline_id: std::option::Option<std::string::String>,
    /// <p>The ID of the patch baseline snapshot used during the patching operation when this compliance data was collected.</p>
    #[doc(hidden)]
    pub snapshot_id: std::option::Option<std::string::String>,
    /// <p>An https URL or an Amazon Simple Storage Service (Amazon S3) path-style URL to a list of patches to be installed. This patch installation list, which you maintain in an S3 bucket in YAML format and specify in the SSM document <code>AWS-RunPatchBaseline</code>, overrides the patches specified by the default patch baseline.</p>
    /// <p>For more information about the <code>InstallOverrideList</code> parameter, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-about-aws-runpatchbaseline.html">About the <code>AWS-RunPatchBaseline</code> </a> SSM document in the <i>Amazon Web Services Systems Manager User Guide</i>.</p>
    #[doc(hidden)]
    pub install_override_list: std::option::Option<std::string::String>,
    /// <p>Placeholder information. This field will always be empty in the current release of the service.</p>
    #[doc(hidden)]
    pub owner_information: std::option::Option<std::string::String>,
    /// <p>The number of patches from the patch baseline that are installed on the managed node.</p>
    #[doc(hidden)]
    pub installed_count: i32,
    /// <p>The number of patches not specified in the patch baseline that are installed on the managed node.</p>
    #[doc(hidden)]
    pub installed_other_count: i32,
    /// <p>The number of patches installed by Patch Manager since the last time the managed node was rebooted.</p>
    #[doc(hidden)]
    pub installed_pending_reboot_count: std::option::Option<i32>,
    /// <p>The number of patches installed on a managed node that are specified in a <code>RejectedPatches</code> list. Patches with a status of <code>InstalledRejected</code> were typically installed before they were added to a <code>RejectedPatches</code> list.</p> <note>
    /// <p>If <code>ALLOW_AS_DEPENDENCY</code> is the specified option for <code>RejectedPatchesAction</code>, the value of <code>InstalledRejectedCount</code> will always be <code>0</code> (zero).</p>
    /// </note>
    #[doc(hidden)]
    pub installed_rejected_count: std::option::Option<i32>,
    /// <p>The number of patches from the patch baseline that are applicable for the managed node but aren't currently installed.</p>
    #[doc(hidden)]
    pub missing_count: i32,
    /// <p>The number of patches from the patch baseline that were attempted to be installed during the last patching operation, but failed to install.</p>
    #[doc(hidden)]
    pub failed_count: i32,
    /// <p>The number of patches beyond the supported limit of <code>NotApplicableCount</code> that aren't reported by name to Inventory. Inventory is a capability of Amazon Web Services Systems Manager.</p>
    #[doc(hidden)]
    pub unreported_not_applicable_count: std::option::Option<i32>,
    /// <p>The number of patches from the patch baseline that aren't applicable for the managed node and therefore aren't installed on the node. This number may be truncated if the list of patch names is very large. The number of patches beyond this limit are reported in <code>UnreportedNotApplicableCount</code>.</p>
    #[doc(hidden)]
    pub not_applicable_count: i32,
    /// <p>The time the most recent patching operation was started on the managed node.</p>
    #[doc(hidden)]
    pub operation_start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time the most recent patching operation completed on the managed node.</p>
    #[doc(hidden)]
    pub operation_end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The type of patching operation that was performed: or </p>
    /// <ul>
    /// <li> <p> <code>SCAN</code> assesses the patch compliance state.</p> </li>
    /// <li> <p> <code>INSTALL</code> installs missing patches.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub operation: std::option::Option<crate::types::PatchOperationType>,
    /// <p>The time of the last attempt to patch the managed node with <code>NoReboot</code> specified as the reboot option.</p>
    #[doc(hidden)]
    pub last_no_reboot_install_operation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Indicates the reboot option specified in the patch baseline.</p> <note>
    /// <p>Reboot options apply to <code>Install</code> operations only. Reboots aren't attempted for Patch Manager <code>Scan</code> operations.</p>
    /// </note>
    /// <ul>
    /// <li> <p> <code>RebootIfNeeded</code>: Patch Manager tries to reboot the managed node if it installed any patches, or if any patches are detected with a status of <code>InstalledPendingReboot</code>.</p> </li>
    /// <li> <p> <code>NoReboot</code>: Patch Manager attempts to install missing packages without trying to reboot the system. Patches installed with this option are assigned a status of <code>InstalledPendingReboot</code>. These patches might not be in effect until a reboot is performed.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub reboot_option: std::option::Option<crate::types::RebootOption>,
    /// <p>The number of patches per node that are specified as <code>Critical</code> for compliance reporting in the patch baseline aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    #[doc(hidden)]
    pub critical_non_compliant_count: std::option::Option<i32>,
    /// <p>The number of patches per node that are specified as <code>Security</code> in a patch advisory aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    #[doc(hidden)]
    pub security_non_compliant_count: std::option::Option<i32>,
    /// <p>The number of patches per node that are specified as other than <code>Critical</code> or <code>Security</code> but aren't compliant with the patch baseline. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    #[doc(hidden)]
    pub other_non_compliant_count: std::option::Option<i32>,
}
impl InstancePatchState {
    /// <p>The ID of the managed node the high-level patch compliance information was collected for.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>The name of the patch group the managed node belongs to.</p>
    pub fn patch_group(&self) -> std::option::Option<&str> {
        self.patch_group.as_deref()
    }
    /// <p>The ID of the patch baseline used to patch the managed node.</p>
    pub fn baseline_id(&self) -> std::option::Option<&str> {
        self.baseline_id.as_deref()
    }
    /// <p>The ID of the patch baseline snapshot used during the patching operation when this compliance data was collected.</p>
    pub fn snapshot_id(&self) -> std::option::Option<&str> {
        self.snapshot_id.as_deref()
    }
    /// <p>An https URL or an Amazon Simple Storage Service (Amazon S3) path-style URL to a list of patches to be installed. This patch installation list, which you maintain in an S3 bucket in YAML format and specify in the SSM document <code>AWS-RunPatchBaseline</code>, overrides the patches specified by the default patch baseline.</p>
    /// <p>For more information about the <code>InstallOverrideList</code> parameter, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-about-aws-runpatchbaseline.html">About the <code>AWS-RunPatchBaseline</code> </a> SSM document in the <i>Amazon Web Services Systems Manager User Guide</i>.</p>
    pub fn install_override_list(&self) -> std::option::Option<&str> {
        self.install_override_list.as_deref()
    }
    /// <p>Placeholder information. This field will always be empty in the current release of the service.</p>
    pub fn owner_information(&self) -> std::option::Option<&str> {
        self.owner_information.as_deref()
    }
    /// <p>The number of patches from the patch baseline that are installed on the managed node.</p>
    pub fn installed_count(&self) -> i32 {
        self.installed_count
    }
    /// <p>The number of patches not specified in the patch baseline that are installed on the managed node.</p>
    pub fn installed_other_count(&self) -> i32 {
        self.installed_other_count
    }
    /// <p>The number of patches installed by Patch Manager since the last time the managed node was rebooted.</p>
    pub fn installed_pending_reboot_count(&self) -> std::option::Option<i32> {
        self.installed_pending_reboot_count
    }
    /// <p>The number of patches installed on a managed node that are specified in a <code>RejectedPatches</code> list. Patches with a status of <code>InstalledRejected</code> were typically installed before they were added to a <code>RejectedPatches</code> list.</p> <note>
    /// <p>If <code>ALLOW_AS_DEPENDENCY</code> is the specified option for <code>RejectedPatchesAction</code>, the value of <code>InstalledRejectedCount</code> will always be <code>0</code> (zero).</p>
    /// </note>
    pub fn installed_rejected_count(&self) -> std::option::Option<i32> {
        self.installed_rejected_count
    }
    /// <p>The number of patches from the patch baseline that are applicable for the managed node but aren't currently installed.</p>
    pub fn missing_count(&self) -> i32 {
        self.missing_count
    }
    /// <p>The number of patches from the patch baseline that were attempted to be installed during the last patching operation, but failed to install.</p>
    pub fn failed_count(&self) -> i32 {
        self.failed_count
    }
    /// <p>The number of patches beyond the supported limit of <code>NotApplicableCount</code> that aren't reported by name to Inventory. Inventory is a capability of Amazon Web Services Systems Manager.</p>
    pub fn unreported_not_applicable_count(&self) -> std::option::Option<i32> {
        self.unreported_not_applicable_count
    }
    /// <p>The number of patches from the patch baseline that aren't applicable for the managed node and therefore aren't installed on the node. This number may be truncated if the list of patch names is very large. The number of patches beyond this limit are reported in <code>UnreportedNotApplicableCount</code>.</p>
    pub fn not_applicable_count(&self) -> i32 {
        self.not_applicable_count
    }
    /// <p>The time the most recent patching operation was started on the managed node.</p>
    pub fn operation_start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.operation_start_time.as_ref()
    }
    /// <p>The time the most recent patching operation completed on the managed node.</p>
    pub fn operation_end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.operation_end_time.as_ref()
    }
    /// <p>The type of patching operation that was performed: or </p>
    /// <ul>
    /// <li> <p> <code>SCAN</code> assesses the patch compliance state.</p> </li>
    /// <li> <p> <code>INSTALL</code> installs missing patches.</p> </li>
    /// </ul>
    pub fn operation(&self) -> std::option::Option<&crate::types::PatchOperationType> {
        self.operation.as_ref()
    }
    /// <p>The time of the last attempt to patch the managed node with <code>NoReboot</code> specified as the reboot option.</p>
    pub fn last_no_reboot_install_operation_time(
        &self,
    ) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_no_reboot_install_operation_time.as_ref()
    }
    /// <p>Indicates the reboot option specified in the patch baseline.</p> <note>
    /// <p>Reboot options apply to <code>Install</code> operations only. Reboots aren't attempted for Patch Manager <code>Scan</code> operations.</p>
    /// </note>
    /// <ul>
    /// <li> <p> <code>RebootIfNeeded</code>: Patch Manager tries to reboot the managed node if it installed any patches, or if any patches are detected with a status of <code>InstalledPendingReboot</code>.</p> </li>
    /// <li> <p> <code>NoReboot</code>: Patch Manager attempts to install missing packages without trying to reboot the system. Patches installed with this option are assigned a status of <code>InstalledPendingReboot</code>. These patches might not be in effect until a reboot is performed.</p> </li>
    /// </ul>
    pub fn reboot_option(&self) -> std::option::Option<&crate::types::RebootOption> {
        self.reboot_option.as_ref()
    }
    /// <p>The number of patches per node that are specified as <code>Critical</code> for compliance reporting in the patch baseline aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub fn critical_non_compliant_count(&self) -> std::option::Option<i32> {
        self.critical_non_compliant_count
    }
    /// <p>The number of patches per node that are specified as <code>Security</code> in a patch advisory aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub fn security_non_compliant_count(&self) -> std::option::Option<i32> {
        self.security_non_compliant_count
    }
    /// <p>The number of patches per node that are specified as other than <code>Critical</code> or <code>Security</code> but aren't compliant with the patch baseline. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub fn other_non_compliant_count(&self) -> std::option::Option<i32> {
        self.other_non_compliant_count
    }
}
impl std::fmt::Debug for InstancePatchState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstancePatchState");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("patch_group", &self.patch_group);
        formatter.field("baseline_id", &self.baseline_id);
        formatter.field("snapshot_id", &self.snapshot_id);
        formatter.field("install_override_list", &self.install_override_list);
        formatter.field("owner_information", &"*** Sensitive Data Redacted ***");
        formatter.field("installed_count", &self.installed_count);
        formatter.field("installed_other_count", &self.installed_other_count);
        formatter.field(
            "installed_pending_reboot_count",
            &self.installed_pending_reboot_count,
        );
        formatter.field("installed_rejected_count", &self.installed_rejected_count);
        formatter.field("missing_count", &self.missing_count);
        formatter.field("failed_count", &self.failed_count);
        formatter.field(
            "unreported_not_applicable_count",
            &self.unreported_not_applicable_count,
        );
        formatter.field("not_applicable_count", &self.not_applicable_count);
        formatter.field("operation_start_time", &self.operation_start_time);
        formatter.field("operation_end_time", &self.operation_end_time);
        formatter.field("operation", &self.operation);
        formatter.field(
            "last_no_reboot_install_operation_time",
            &self.last_no_reboot_install_operation_time,
        );
        formatter.field("reboot_option", &self.reboot_option);
        formatter.field(
            "critical_non_compliant_count",
            &self.critical_non_compliant_count,
        );
        formatter.field(
            "security_non_compliant_count",
            &self.security_non_compliant_count,
        );
        formatter.field("other_non_compliant_count", &self.other_non_compliant_count);
        formatter.finish()
    }
}
impl InstancePatchState {
    /// Creates a new builder-style object to manufacture [`InstancePatchState`](crate::types::InstancePatchState).
    pub fn builder() -> crate::types::builders::InstancePatchStateBuilder {
        crate::types::builders::InstancePatchStateBuilder::default()
    }
}

/// A builder for [`InstancePatchState`](crate::types::InstancePatchState).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
pub struct InstancePatchStateBuilder {
    pub(crate) instance_id: std::option::Option<std::string::String>,
    pub(crate) patch_group: std::option::Option<std::string::String>,
    pub(crate) baseline_id: std::option::Option<std::string::String>,
    pub(crate) snapshot_id: std::option::Option<std::string::String>,
    pub(crate) install_override_list: std::option::Option<std::string::String>,
    pub(crate) owner_information: std::option::Option<std::string::String>,
    pub(crate) installed_count: std::option::Option<i32>,
    pub(crate) installed_other_count: std::option::Option<i32>,
    pub(crate) installed_pending_reboot_count: std::option::Option<i32>,
    pub(crate) installed_rejected_count: std::option::Option<i32>,
    pub(crate) missing_count: std::option::Option<i32>,
    pub(crate) failed_count: std::option::Option<i32>,
    pub(crate) unreported_not_applicable_count: std::option::Option<i32>,
    pub(crate) not_applicable_count: std::option::Option<i32>,
    pub(crate) operation_start_time: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) operation_end_time: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) operation: std::option::Option<crate::types::PatchOperationType>,
    pub(crate) last_no_reboot_install_operation_time:
        std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) reboot_option: std::option::Option<crate::types::RebootOption>,
    pub(crate) critical_non_compliant_count: std::option::Option<i32>,
    pub(crate) security_non_compliant_count: std::option::Option<i32>,
    pub(crate) other_non_compliant_count: std::option::Option<i32>,
}
impl InstancePatchStateBuilder {
    /// <p>The ID of the managed node the high-level patch compliance information was collected for.</p>
    pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.instance_id = Some(input.into());
        self
    }
    /// <p>The ID of the managed node the high-level patch compliance information was collected for.</p>
    pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.instance_id = input;
        self
    }
    /// <p>The name of the patch group the managed node belongs to.</p>
    pub fn patch_group(mut self, input: impl Into<std::string::String>) -> Self {
        self.patch_group = Some(input.into());
        self
    }
    /// <p>The name of the patch group the managed node belongs to.</p>
    pub fn set_patch_group(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.patch_group = input;
        self
    }
    /// <p>The ID of the patch baseline used to patch the managed node.</p>
    pub fn baseline_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.baseline_id = Some(input.into());
        self
    }
    /// <p>The ID of the patch baseline used to patch the managed node.</p>
    pub fn set_baseline_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.baseline_id = input;
        self
    }
    /// <p>The ID of the patch baseline snapshot used during the patching operation when this compliance data was collected.</p>
    pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.snapshot_id = Some(input.into());
        self
    }
    /// <p>The ID of the patch baseline snapshot used during the patching operation when this compliance data was collected.</p>
    pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.snapshot_id = input;
        self
    }
    /// <p>An https URL or an Amazon Simple Storage Service (Amazon S3) path-style URL to a list of patches to be installed. This patch installation list, which you maintain in an S3 bucket in YAML format and specify in the SSM document <code>AWS-RunPatchBaseline</code>, overrides the patches specified by the default patch baseline.</p>
    /// <p>For more information about the <code>InstallOverrideList</code> parameter, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-about-aws-runpatchbaseline.html">About the <code>AWS-RunPatchBaseline</code> </a> SSM document in the <i>Amazon Web Services Systems Manager User Guide</i>.</p>
    pub fn install_override_list(mut self, input: impl Into<std::string::String>) -> Self {
        self.install_override_list = Some(input.into());
        self
    }
    /// <p>An https URL or an Amazon Simple Storage Service (Amazon S3) path-style URL to a list of patches to be installed. This patch installation list, which you maintain in an S3 bucket in YAML format and specify in the SSM document <code>AWS-RunPatchBaseline</code>, overrides the patches specified by the default patch baseline.</p>
    /// <p>For more information about the <code>InstallOverrideList</code> parameter, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-about-aws-runpatchbaseline.html">About the <code>AWS-RunPatchBaseline</code> </a> SSM document in the <i>Amazon Web Services Systems Manager User Guide</i>.</p>
    pub fn set_install_override_list(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.install_override_list = input;
        self
    }
    /// <p>Placeholder information. This field will always be empty in the current release of the service.</p>
    pub fn owner_information(mut self, input: impl Into<std::string::String>) -> Self {
        self.owner_information = Some(input.into());
        self
    }
    /// <p>Placeholder information. This field will always be empty in the current release of the service.</p>
    pub fn set_owner_information(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.owner_information = input;
        self
    }
    /// <p>The number of patches from the patch baseline that are installed on the managed node.</p>
    pub fn installed_count(mut self, input: i32) -> Self {
        self.installed_count = Some(input);
        self
    }
    /// <p>The number of patches from the patch baseline that are installed on the managed node.</p>
    pub fn set_installed_count(mut self, input: std::option::Option<i32>) -> Self {
        self.installed_count = input;
        self
    }
    /// <p>The number of patches not specified in the patch baseline that are installed on the managed node.</p>
    pub fn installed_other_count(mut self, input: i32) -> Self {
        self.installed_other_count = Some(input);
        self
    }
    /// <p>The number of patches not specified in the patch baseline that are installed on the managed node.</p>
    pub fn set_installed_other_count(mut self, input: std::option::Option<i32>) -> Self {
        self.installed_other_count = input;
        self
    }
    /// <p>The number of patches installed by Patch Manager since the last time the managed node was rebooted.</p>
    pub fn installed_pending_reboot_count(mut self, input: i32) -> Self {
        self.installed_pending_reboot_count = Some(input);
        self
    }
    /// <p>The number of patches installed by Patch Manager since the last time the managed node was rebooted.</p>
    pub fn set_installed_pending_reboot_count(mut self, input: std::option::Option<i32>) -> Self {
        self.installed_pending_reboot_count = input;
        self
    }
    /// <p>The number of patches installed on a managed node that are specified in a <code>RejectedPatches</code> list. Patches with a status of <code>InstalledRejected</code> were typically installed before they were added to a <code>RejectedPatches</code> list.</p> <note>
    /// <p>If <code>ALLOW_AS_DEPENDENCY</code> is the specified option for <code>RejectedPatchesAction</code>, the value of <code>InstalledRejectedCount</code> will always be <code>0</code> (zero).</p>
    /// </note>
    pub fn installed_rejected_count(mut self, input: i32) -> Self {
        self.installed_rejected_count = Some(input);
        self
    }
    /// <p>The number of patches installed on a managed node that are specified in a <code>RejectedPatches</code> list. Patches with a status of <code>InstalledRejected</code> were typically installed before they were added to a <code>RejectedPatches</code> list.</p> <note>
    /// <p>If <code>ALLOW_AS_DEPENDENCY</code> is the specified option for <code>RejectedPatchesAction</code>, the value of <code>InstalledRejectedCount</code> will always be <code>0</code> (zero).</p>
    /// </note>
    pub fn set_installed_rejected_count(mut self, input: std::option::Option<i32>) -> Self {
        self.installed_rejected_count = input;
        self
    }
    /// <p>The number of patches from the patch baseline that are applicable for the managed node but aren't currently installed.</p>
    pub fn missing_count(mut self, input: i32) -> Self {
        self.missing_count = Some(input);
        self
    }
    /// <p>The number of patches from the patch baseline that are applicable for the managed node but aren't currently installed.</p>
    pub fn set_missing_count(mut self, input: std::option::Option<i32>) -> Self {
        self.missing_count = input;
        self
    }
    /// <p>The number of patches from the patch baseline that were attempted to be installed during the last patching operation, but failed to install.</p>
    pub fn failed_count(mut self, input: i32) -> Self {
        self.failed_count = Some(input);
        self
    }
    /// <p>The number of patches from the patch baseline that were attempted to be installed during the last patching operation, but failed to install.</p>
    pub fn set_failed_count(mut self, input: std::option::Option<i32>) -> Self {
        self.failed_count = input;
        self
    }
    /// <p>The number of patches beyond the supported limit of <code>NotApplicableCount</code> that aren't reported by name to Inventory. Inventory is a capability of Amazon Web Services Systems Manager.</p>
    pub fn unreported_not_applicable_count(mut self, input: i32) -> Self {
        self.unreported_not_applicable_count = Some(input);
        self
    }
    /// <p>The number of patches beyond the supported limit of <code>NotApplicableCount</code> that aren't reported by name to Inventory. Inventory is a capability of Amazon Web Services Systems Manager.</p>
    pub fn set_unreported_not_applicable_count(mut self, input: std::option::Option<i32>) -> Self {
        self.unreported_not_applicable_count = input;
        self
    }
    /// <p>The number of patches from the patch baseline that aren't applicable for the managed node and therefore aren't installed on the node. This number may be truncated if the list of patch names is very large. The number of patches beyond this limit are reported in <code>UnreportedNotApplicableCount</code>.</p>
    pub fn not_applicable_count(mut self, input: i32) -> Self {
        self.not_applicable_count = Some(input);
        self
    }
    /// <p>The number of patches from the patch baseline that aren't applicable for the managed node and therefore aren't installed on the node. This number may be truncated if the list of patch names is very large. The number of patches beyond this limit are reported in <code>UnreportedNotApplicableCount</code>.</p>
    pub fn set_not_applicable_count(mut self, input: std::option::Option<i32>) -> Self {
        self.not_applicable_count = input;
        self
    }
    /// <p>The time the most recent patching operation was started on the managed node.</p>
    pub fn operation_start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.operation_start_time = Some(input);
        self
    }
    /// <p>The time the most recent patching operation was started on the managed node.</p>
    pub fn set_operation_start_time(
        mut self,
        input: std::option::Option<aws_smithy_types::DateTime>,
    ) -> Self {
        self.operation_start_time = input;
        self
    }
    /// <p>The time the most recent patching operation completed on the managed node.</p>
    pub fn operation_end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.operation_end_time = Some(input);
        self
    }
    /// <p>The time the most recent patching operation completed on the managed node.</p>
    pub fn set_operation_end_time(
        mut self,
        input: std::option::Option<aws_smithy_types::DateTime>,
    ) -> Self {
        self.operation_end_time = input;
        self
    }
    /// <p>The type of patching operation that was performed: or </p>
    /// <ul>
    /// <li> <p> <code>SCAN</code> assesses the patch compliance state.</p> </li>
    /// <li> <p> <code>INSTALL</code> installs missing patches.</p> </li>
    /// </ul>
    pub fn operation(mut self, input: crate::types::PatchOperationType) -> Self {
        self.operation = Some(input);
        self
    }
    /// <p>The type of patching operation that was performed: or </p>
    /// <ul>
    /// <li> <p> <code>SCAN</code> assesses the patch compliance state.</p> </li>
    /// <li> <p> <code>INSTALL</code> installs missing patches.</p> </li>
    /// </ul>
    pub fn set_operation(
        mut self,
        input: std::option::Option<crate::types::PatchOperationType>,
    ) -> Self {
        self.operation = input;
        self
    }
    /// <p>The time of the last attempt to patch the managed node with <code>NoReboot</code> specified as the reboot option.</p>
    pub fn last_no_reboot_install_operation_time(
        mut self,
        input: aws_smithy_types::DateTime,
    ) -> Self {
        self.last_no_reboot_install_operation_time = Some(input);
        self
    }
    /// <p>The time of the last attempt to patch the managed node with <code>NoReboot</code> specified as the reboot option.</p>
    pub fn set_last_no_reboot_install_operation_time(
        mut self,
        input: std::option::Option<aws_smithy_types::DateTime>,
    ) -> Self {
        self.last_no_reboot_install_operation_time = input;
        self
    }
    /// <p>Indicates the reboot option specified in the patch baseline.</p> <note>
    /// <p>Reboot options apply to <code>Install</code> operations only. Reboots aren't attempted for Patch Manager <code>Scan</code> operations.</p>
    /// </note>
    /// <ul>
    /// <li> <p> <code>RebootIfNeeded</code>: Patch Manager tries to reboot the managed node if it installed any patches, or if any patches are detected with a status of <code>InstalledPendingReboot</code>.</p> </li>
    /// <li> <p> <code>NoReboot</code>: Patch Manager attempts to install missing packages without trying to reboot the system. Patches installed with this option are assigned a status of <code>InstalledPendingReboot</code>. These patches might not be in effect until a reboot is performed.</p> </li>
    /// </ul>
    pub fn reboot_option(mut self, input: crate::types::RebootOption) -> Self {
        self.reboot_option = Some(input);
        self
    }
    /// <p>Indicates the reboot option specified in the patch baseline.</p> <note>
    /// <p>Reboot options apply to <code>Install</code> operations only. Reboots aren't attempted for Patch Manager <code>Scan</code> operations.</p>
    /// </note>
    /// <ul>
    /// <li> <p> <code>RebootIfNeeded</code>: Patch Manager tries to reboot the managed node if it installed any patches, or if any patches are detected with a status of <code>InstalledPendingReboot</code>.</p> </li>
    /// <li> <p> <code>NoReboot</code>: Patch Manager attempts to install missing packages without trying to reboot the system. Patches installed with this option are assigned a status of <code>InstalledPendingReboot</code>. These patches might not be in effect until a reboot is performed.</p> </li>
    /// </ul>
    pub fn set_reboot_option(
        mut self,
        input: std::option::Option<crate::types::RebootOption>,
    ) -> Self {
        self.reboot_option = input;
        self
    }
    /// <p>The number of patches per node that are specified as <code>Critical</code> for compliance reporting in the patch baseline aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub fn critical_non_compliant_count(mut self, input: i32) -> Self {
        self.critical_non_compliant_count = Some(input);
        self
    }
    /// <p>The number of patches per node that are specified as <code>Critical</code> for compliance reporting in the patch baseline aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub fn set_critical_non_compliant_count(mut self, input: std::option::Option<i32>) -> Self {
        self.critical_non_compliant_count = input;
        self
    }
    /// <p>The number of patches per node that are specified as <code>Security</code> in a patch advisory aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub fn security_non_compliant_count(mut self, input: i32) -> Self {
        self.security_non_compliant_count = Some(input);
        self
    }
    /// <p>The number of patches per node that are specified as <code>Security</code> in a patch advisory aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub fn set_security_non_compliant_count(mut self, input: std::option::Option<i32>) -> Self {
        self.security_non_compliant_count = input;
        self
    }
    /// <p>The number of patches per node that are specified as other than <code>Critical</code> or <code>Security</code> but aren't compliant with the patch baseline. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub fn other_non_compliant_count(mut self, input: i32) -> Self {
        self.other_non_compliant_count = Some(input);
        self
    }
    /// <p>The number of patches per node that are specified as other than <code>Critical</code> or <code>Security</code> but aren't compliant with the patch baseline. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub fn set_other_non_compliant_count(mut self, input: std::option::Option<i32>) -> Self {
        self.other_non_compliant_count = input;
        self
    }
    /// Consumes the builder and constructs a [`InstancePatchState`](crate::types::InstancePatchState).
    pub fn build(self) -> crate::types::InstancePatchState {
        crate::types::InstancePatchState {
            instance_id: self.instance_id,
            patch_group: self.patch_group,
            baseline_id: self.baseline_id,
            snapshot_id: self.snapshot_id,
            install_override_list: self.install_override_list,
            owner_information: self.owner_information,
            installed_count: self.installed_count.unwrap_or_default(),
            installed_other_count: self.installed_other_count.unwrap_or_default(),
            installed_pending_reboot_count: self.installed_pending_reboot_count,
            installed_rejected_count: self.installed_rejected_count,
            missing_count: self.missing_count.unwrap_or_default(),
            failed_count: self.failed_count.unwrap_or_default(),
            unreported_not_applicable_count: self.unreported_not_applicable_count,
            not_applicable_count: self.not_applicable_count.unwrap_or_default(),
            operation_start_time: self.operation_start_time,
            operation_end_time: self.operation_end_time,
            operation: self.operation,
            last_no_reboot_install_operation_time: self.last_no_reboot_install_operation_time,
            reboot_option: self.reboot_option,
            critical_non_compliant_count: self.critical_non_compliant_count,
            security_non_compliant_count: self.security_non_compliant_count,
            other_non_compliant_count: self.other_non_compliant_count,
        }
    }
}
impl std::fmt::Debug for InstancePatchStateBuilder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstancePatchStateBuilder");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("patch_group", &self.patch_group);
        formatter.field("baseline_id", &self.baseline_id);
        formatter.field("snapshot_id", &self.snapshot_id);
        formatter.field("install_override_list", &self.install_override_list);
        formatter.field("owner_information", &"*** Sensitive Data Redacted ***");
        formatter.field("installed_count", &self.installed_count);
        formatter.field("installed_other_count", &self.installed_other_count);
        formatter.field(
            "installed_pending_reboot_count",
            &self.installed_pending_reboot_count,
        );
        formatter.field("installed_rejected_count", &self.installed_rejected_count);
        formatter.field("missing_count", &self.missing_count);
        formatter.field("failed_count", &self.failed_count);
        formatter.field(
            "unreported_not_applicable_count",
            &self.unreported_not_applicable_count,
        );
        formatter.field("not_applicable_count", &self.not_applicable_count);
        formatter.field("operation_start_time", &self.operation_start_time);
        formatter.field("operation_end_time", &self.operation_end_time);
        formatter.field("operation", &self.operation);
        formatter.field(
            "last_no_reboot_install_operation_time",
            &self.last_no_reboot_install_operation_time,
        );
        formatter.field("reboot_option", &self.reboot_option);
        formatter.field(
            "critical_non_compliant_count",
            &self.critical_non_compliant_count,
        );
        formatter.field(
            "security_non_compliant_count",
            &self.security_non_compliant_count,
        );
        formatter.field("other_non_compliant_count", &self.other_non_compliant_count);
        formatter.finish()
    }
}
