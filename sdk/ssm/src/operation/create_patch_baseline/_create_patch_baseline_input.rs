// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct CreatePatchBaselineInput {
    /// <p>Defines the operating system the patch baseline applies to. The default value is <code>WINDOWS</code>.</p>
    pub operating_system: ::std::option::Option<crate::types::OperatingSystem>,
    /// <p>The name of the patch baseline.</p>
    pub name: ::std::option::Option<::std::string::String>,
    /// <p>A set of global filters used to include patches in the baseline.</p><important>
    /// <p>The <code>GlobalFilters</code> parameter can be configured only by using the CLI or an Amazon Web Services SDK. It can't be configured from the Patch Manager console, and its value isn't displayed in the console.</p>
    /// </important>
    pub global_filters: ::std::option::Option<crate::types::PatchFilterGroup>,
    /// <p>A set of rules used to include patches in the baseline.</p>
    pub approval_rules: ::std::option::Option<crate::types::PatchRuleGroup>,
    /// <p>A list of explicitly approved patches for the baseline.</p>
    /// <p>For information about accepted formats for lists of approved patches and rejected patches, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">Package name formats for approved and rejected patch lists</a> in the <i>Amazon Web Services Systems Manager User Guide</i>.</p>
    pub approved_patches: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>Defines the compliance level for approved patches. When an approved patch is reported as missing, this value describes the severity of the compliance violation. The default value is <code>UNSPECIFIED</code>.</p>
    pub approved_patches_compliance_level: ::std::option::Option<crate::types::PatchComplianceLevel>,
    /// <p>Indicates whether the list of approved patches includes non-security updates that should be applied to the managed nodes. The default value is <code>false</code>. Applies to Linux managed nodes only.</p>
    pub approved_patches_enable_non_security: ::std::option::Option<bool>,
    /// <p>A list of explicitly rejected patches for the baseline.</p>
    /// <p>For information about accepted formats for lists of approved patches and rejected patches, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">Package name formats for approved and rejected patch lists</a> in the <i>Amazon Web Services Systems Manager User Guide</i>.</p>
    pub rejected_patches: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The action for Patch Manager to take on patches included in the <code>RejectedPackages</code> list.</p>
    /// <dl>
    /// <dt>
    /// ALLOW_AS_DEPENDENCY
    /// </dt>
    /// <dd>
    /// <p><b>Linux and macOS</b>: A package in the rejected patches list is installed only if it is a dependency of another package. It is considered compliant with the patch baseline, and its status is reported as <code>INSTALLED_OTHER</code>. This is the default action if no option is specified.</p>
    /// <p><b>Windows Server</b>: Windows Server doesn't support the concept of package dependencies. If a package in the rejected patches list and already installed on the node, its status is reported as <code>INSTALLED_OTHER</code>. Any package not already installed on the node is skipped. This is the default action if no option is specified.</p>
    /// </dd>
    /// <dt>
    /// BLOCK
    /// </dt>
    /// <dd>
    /// <p><b>All OSs</b>: Packages in the rejected patches list, and packages that include them as dependencies, aren't installed by Patch Manager under any circumstances.</p>
    /// <p>State value assignment for patch compliance:</p>
    /// <ul>
    /// <li>
    /// <p>If a package was installed before it was added to the rejected patches list, or is installed outside of Patch Manager afterward, it's considered noncompliant with the patch baseline and its status is reported as <code>INSTALLED_REJECTED</code>.</p></li>
    /// <li>
    /// <p>If an update attempts to install a dependency package that is now rejected by the baseline, when previous versions of the package were not rejected, the package being updated is reported as <code>MISSING</code> for <code>SCAN</code> operations and as <code>FAILED</code> for <code>INSTALL</code> operations.</p></li>
    /// </ul>
    /// </dd>
    /// </dl>
    pub rejected_patches_action: ::std::option::Option<crate::types::PatchAction>,
    /// <p>A description of the patch baseline.</p>
    pub description: ::std::option::Option<::std::string::String>,
    /// <p>Information about the patches to use to update the managed nodes, including target operating systems and source repositories. Applies to Linux managed nodes only.</p>
    pub sources: ::std::option::Option<::std::vec::Vec<crate::types::PatchSource>>,
    /// <p>Indicates the status you want to assign to security patches that are available but not approved because they don't meet the installation criteria specified in the patch baseline.</p>
    /// <p>Example scenario: Security patches that you might want installed can be skipped if you have specified a long period to wait after a patch is released before installation. If an update to the patch is released during your specified waiting period, the waiting period for installing the patch starts over. If the waiting period is too long, multiple versions of the patch could be released but never installed.</p>
    /// <p>Supported for Windows Server managed nodes only.</p>
    pub available_security_updates_compliance_status: ::std::option::Option<crate::types::PatchComplianceStatus>,
    /// <p>User-provided idempotency token.</p>
    pub client_token: ::std::option::Option<::std::string::String>,
    /// <p>Optional metadata that you assign to a resource. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag a patch baseline to identify the severity level of patches it specifies and the operating system family it applies to. In this case, you could specify the following key-value pairs:</p>
    /// <ul>
    /// <li>
    /// <p><code>Key=PatchSeverity,Value=Critical</code></p></li>
    /// <li>
    /// <p><code>Key=OS,Value=Windows</code></p></li>
    /// </ul><note>
    /// <p>To add tags to an existing patch baseline, use the <code>AddTagsToResource</code> operation.</p>
    /// </note>
    pub tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
}
impl CreatePatchBaselineInput {
    /// <p>Defines the operating system the patch baseline applies to. The default value is <code>WINDOWS</code>.</p>
    pub fn operating_system(&self) -> ::std::option::Option<&crate::types::OperatingSystem> {
        self.operating_system.as_ref()
    }
    /// <p>The name of the patch baseline.</p>
    pub fn name(&self) -> ::std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A set of global filters used to include patches in the baseline.</p><important>
    /// <p>The <code>GlobalFilters</code> parameter can be configured only by using the CLI or an Amazon Web Services SDK. It can't be configured from the Patch Manager console, and its value isn't displayed in the console.</p>
    /// </important>
    pub fn global_filters(&self) -> ::std::option::Option<&crate::types::PatchFilterGroup> {
        self.global_filters.as_ref()
    }
    /// <p>A set of rules used to include patches in the baseline.</p>
    pub fn approval_rules(&self) -> ::std::option::Option<&crate::types::PatchRuleGroup> {
        self.approval_rules.as_ref()
    }
    /// <p>A list of explicitly approved patches for the baseline.</p>
    /// <p>For information about accepted formats for lists of approved patches and rejected patches, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">Package name formats for approved and rejected patch lists</a> in the <i>Amazon Web Services Systems Manager User Guide</i>.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.approved_patches.is_none()`.
    pub fn approved_patches(&self) -> &[::std::string::String] {
        self.approved_patches.as_deref().unwrap_or_default()
    }
    /// <p>Defines the compliance level for approved patches. When an approved patch is reported as missing, this value describes the severity of the compliance violation. The default value is <code>UNSPECIFIED</code>.</p>
    pub fn approved_patches_compliance_level(&self) -> ::std::option::Option<&crate::types::PatchComplianceLevel> {
        self.approved_patches_compliance_level.as_ref()
    }
    /// <p>Indicates whether the list of approved patches includes non-security updates that should be applied to the managed nodes. The default value is <code>false</code>. Applies to Linux managed nodes only.</p>
    pub fn approved_patches_enable_non_security(&self) -> ::std::option::Option<bool> {
        self.approved_patches_enable_non_security
    }
    /// <p>A list of explicitly rejected patches for the baseline.</p>
    /// <p>For information about accepted formats for lists of approved patches and rejected patches, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">Package name formats for approved and rejected patch lists</a> in the <i>Amazon Web Services Systems Manager User Guide</i>.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.rejected_patches.is_none()`.
    pub fn rejected_patches(&self) -> &[::std::string::String] {
        self.rejected_patches.as_deref().unwrap_or_default()
    }
    /// <p>The action for Patch Manager to take on patches included in the <code>RejectedPackages</code> list.</p>
    /// <dl>
    /// <dt>
    /// ALLOW_AS_DEPENDENCY
    /// </dt>
    /// <dd>
    /// <p><b>Linux and macOS</b>: A package in the rejected patches list is installed only if it is a dependency of another package. It is considered compliant with the patch baseline, and its status is reported as <code>INSTALLED_OTHER</code>. This is the default action if no option is specified.</p>
    /// <p><b>Windows Server</b>: Windows Server doesn't support the concept of package dependencies. If a package in the rejected patches list and already installed on the node, its status is reported as <code>INSTALLED_OTHER</code>. Any package not already installed on the node is skipped. This is the default action if no option is specified.</p>
    /// </dd>
    /// <dt>
    /// BLOCK
    /// </dt>
    /// <dd>
    /// <p><b>All OSs</b>: Packages in the rejected patches list, and packages that include them as dependencies, aren't installed by Patch Manager under any circumstances.</p>
    /// <p>State value assignment for patch compliance:</p>
    /// <ul>
    /// <li>
    /// <p>If a package was installed before it was added to the rejected patches list, or is installed outside of Patch Manager afterward, it's considered noncompliant with the patch baseline and its status is reported as <code>INSTALLED_REJECTED</code>.</p></li>
    /// <li>
    /// <p>If an update attempts to install a dependency package that is now rejected by the baseline, when previous versions of the package were not rejected, the package being updated is reported as <code>MISSING</code> for <code>SCAN</code> operations and as <code>FAILED</code> for <code>INSTALL</code> operations.</p></li>
    /// </ul>
    /// </dd>
    /// </dl>
    pub fn rejected_patches_action(&self) -> ::std::option::Option<&crate::types::PatchAction> {
        self.rejected_patches_action.as_ref()
    }
    /// <p>A description of the patch baseline.</p>
    pub fn description(&self) -> ::std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Information about the patches to use to update the managed nodes, including target operating systems and source repositories. Applies to Linux managed nodes only.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.sources.is_none()`.
    pub fn sources(&self) -> &[crate::types::PatchSource] {
        self.sources.as_deref().unwrap_or_default()
    }
    /// <p>Indicates the status you want to assign to security patches that are available but not approved because they don't meet the installation criteria specified in the patch baseline.</p>
    /// <p>Example scenario: Security patches that you might want installed can be skipped if you have specified a long period to wait after a patch is released before installation. If an update to the patch is released during your specified waiting period, the waiting period for installing the patch starts over. If the waiting period is too long, multiple versions of the patch could be released but never installed.</p>
    /// <p>Supported for Windows Server managed nodes only.</p>
    pub fn available_security_updates_compliance_status(&self) -> ::std::option::Option<&crate::types::PatchComplianceStatus> {
        self.available_security_updates_compliance_status.as_ref()
    }
    /// <p>User-provided idempotency token.</p>
    pub fn client_token(&self) -> ::std::option::Option<&str> {
        self.client_token.as_deref()
    }
    /// <p>Optional metadata that you assign to a resource. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag a patch baseline to identify the severity level of patches it specifies and the operating system family it applies to. In this case, you could specify the following key-value pairs:</p>
    /// <ul>
    /// <li>
    /// <p><code>Key=PatchSeverity,Value=Critical</code></p></li>
    /// <li>
    /// <p><code>Key=OS,Value=Windows</code></p></li>
    /// </ul><note>
    /// <p>To add tags to an existing patch baseline, use the <code>AddTagsToResource</code> operation.</p>
    /// </note>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.tags.is_none()`.
    pub fn tags(&self) -> &[crate::types::Tag] {
        self.tags.as_deref().unwrap_or_default()
    }
}
impl CreatePatchBaselineInput {
    /// Creates a new builder-style object to manufacture [`CreatePatchBaselineInput`](crate::operation::create_patch_baseline::CreatePatchBaselineInput).
    pub fn builder() -> crate::operation::create_patch_baseline::builders::CreatePatchBaselineInputBuilder {
        crate::operation::create_patch_baseline::builders::CreatePatchBaselineInputBuilder::default()
    }
}

/// A builder for [`CreatePatchBaselineInput`](crate::operation::create_patch_baseline::CreatePatchBaselineInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct CreatePatchBaselineInputBuilder {
    pub(crate) operating_system: ::std::option::Option<crate::types::OperatingSystem>,
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) global_filters: ::std::option::Option<crate::types::PatchFilterGroup>,
    pub(crate) approval_rules: ::std::option::Option<crate::types::PatchRuleGroup>,
    pub(crate) approved_patches: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) approved_patches_compliance_level: ::std::option::Option<crate::types::PatchComplianceLevel>,
    pub(crate) approved_patches_enable_non_security: ::std::option::Option<bool>,
    pub(crate) rejected_patches: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) rejected_patches_action: ::std::option::Option<crate::types::PatchAction>,
    pub(crate) description: ::std::option::Option<::std::string::String>,
    pub(crate) sources: ::std::option::Option<::std::vec::Vec<crate::types::PatchSource>>,
    pub(crate) available_security_updates_compliance_status: ::std::option::Option<crate::types::PatchComplianceStatus>,
    pub(crate) client_token: ::std::option::Option<::std::string::String>,
    pub(crate) tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
}
impl CreatePatchBaselineInputBuilder {
    /// <p>Defines the operating system the patch baseline applies to. The default value is <code>WINDOWS</code>.</p>
    pub fn operating_system(mut self, input: crate::types::OperatingSystem) -> Self {
        self.operating_system = ::std::option::Option::Some(input);
        self
    }
    /// <p>Defines the operating system the patch baseline applies to. The default value is <code>WINDOWS</code>.</p>
    pub fn set_operating_system(mut self, input: ::std::option::Option<crate::types::OperatingSystem>) -> Self {
        self.operating_system = input;
        self
    }
    /// <p>Defines the operating system the patch baseline applies to. The default value is <code>WINDOWS</code>.</p>
    pub fn get_operating_system(&self) -> &::std::option::Option<crate::types::OperatingSystem> {
        &self.operating_system
    }
    /// <p>The name of the patch baseline.</p>
    /// This field is required.
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the patch baseline.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The name of the patch baseline.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>A set of global filters used to include patches in the baseline.</p><important>
    /// <p>The <code>GlobalFilters</code> parameter can be configured only by using the CLI or an Amazon Web Services SDK. It can't be configured from the Patch Manager console, and its value isn't displayed in the console.</p>
    /// </important>
    pub fn global_filters(mut self, input: crate::types::PatchFilterGroup) -> Self {
        self.global_filters = ::std::option::Option::Some(input);
        self
    }
    /// <p>A set of global filters used to include patches in the baseline.</p><important>
    /// <p>The <code>GlobalFilters</code> parameter can be configured only by using the CLI or an Amazon Web Services SDK. It can't be configured from the Patch Manager console, and its value isn't displayed in the console.</p>
    /// </important>
    pub fn set_global_filters(mut self, input: ::std::option::Option<crate::types::PatchFilterGroup>) -> Self {
        self.global_filters = input;
        self
    }
    /// <p>A set of global filters used to include patches in the baseline.</p><important>
    /// <p>The <code>GlobalFilters</code> parameter can be configured only by using the CLI or an Amazon Web Services SDK. It can't be configured from the Patch Manager console, and its value isn't displayed in the console.</p>
    /// </important>
    pub fn get_global_filters(&self) -> &::std::option::Option<crate::types::PatchFilterGroup> {
        &self.global_filters
    }
    /// <p>A set of rules used to include patches in the baseline.</p>
    pub fn approval_rules(mut self, input: crate::types::PatchRuleGroup) -> Self {
        self.approval_rules = ::std::option::Option::Some(input);
        self
    }
    /// <p>A set of rules used to include patches in the baseline.</p>
    pub fn set_approval_rules(mut self, input: ::std::option::Option<crate::types::PatchRuleGroup>) -> Self {
        self.approval_rules = input;
        self
    }
    /// <p>A set of rules used to include patches in the baseline.</p>
    pub fn get_approval_rules(&self) -> &::std::option::Option<crate::types::PatchRuleGroup> {
        &self.approval_rules
    }
    /// Appends an item to `approved_patches`.
    ///
    /// To override the contents of this collection use [`set_approved_patches`](Self::set_approved_patches).
    ///
    /// <p>A list of explicitly approved patches for the baseline.</p>
    /// <p>For information about accepted formats for lists of approved patches and rejected patches, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">Package name formats for approved and rejected patch lists</a> in the <i>Amazon Web Services Systems Manager User Guide</i>.</p>
    pub fn approved_patches(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.approved_patches.unwrap_or_default();
        v.push(input.into());
        self.approved_patches = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of explicitly approved patches for the baseline.</p>
    /// <p>For information about accepted formats for lists of approved patches and rejected patches, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">Package name formats for approved and rejected patch lists</a> in the <i>Amazon Web Services Systems Manager User Guide</i>.</p>
    pub fn set_approved_patches(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.approved_patches = input;
        self
    }
    /// <p>A list of explicitly approved patches for the baseline.</p>
    /// <p>For information about accepted formats for lists of approved patches and rejected patches, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">Package name formats for approved and rejected patch lists</a> in the <i>Amazon Web Services Systems Manager User Guide</i>.</p>
    pub fn get_approved_patches(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.approved_patches
    }
    /// <p>Defines the compliance level for approved patches. When an approved patch is reported as missing, this value describes the severity of the compliance violation. The default value is <code>UNSPECIFIED</code>.</p>
    pub fn approved_patches_compliance_level(mut self, input: crate::types::PatchComplianceLevel) -> Self {
        self.approved_patches_compliance_level = ::std::option::Option::Some(input);
        self
    }
    /// <p>Defines the compliance level for approved patches. When an approved patch is reported as missing, this value describes the severity of the compliance violation. The default value is <code>UNSPECIFIED</code>.</p>
    pub fn set_approved_patches_compliance_level(mut self, input: ::std::option::Option<crate::types::PatchComplianceLevel>) -> Self {
        self.approved_patches_compliance_level = input;
        self
    }
    /// <p>Defines the compliance level for approved patches. When an approved patch is reported as missing, this value describes the severity of the compliance violation. The default value is <code>UNSPECIFIED</code>.</p>
    pub fn get_approved_patches_compliance_level(&self) -> &::std::option::Option<crate::types::PatchComplianceLevel> {
        &self.approved_patches_compliance_level
    }
    /// <p>Indicates whether the list of approved patches includes non-security updates that should be applied to the managed nodes. The default value is <code>false</code>. Applies to Linux managed nodes only.</p>
    pub fn approved_patches_enable_non_security(mut self, input: bool) -> Self {
        self.approved_patches_enable_non_security = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether the list of approved patches includes non-security updates that should be applied to the managed nodes. The default value is <code>false</code>. Applies to Linux managed nodes only.</p>
    pub fn set_approved_patches_enable_non_security(mut self, input: ::std::option::Option<bool>) -> Self {
        self.approved_patches_enable_non_security = input;
        self
    }
    /// <p>Indicates whether the list of approved patches includes non-security updates that should be applied to the managed nodes. The default value is <code>false</code>. Applies to Linux managed nodes only.</p>
    pub fn get_approved_patches_enable_non_security(&self) -> &::std::option::Option<bool> {
        &self.approved_patches_enable_non_security
    }
    /// Appends an item to `rejected_patches`.
    ///
    /// To override the contents of this collection use [`set_rejected_patches`](Self::set_rejected_patches).
    ///
    /// <p>A list of explicitly rejected patches for the baseline.</p>
    /// <p>For information about accepted formats for lists of approved patches and rejected patches, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">Package name formats for approved and rejected patch lists</a> in the <i>Amazon Web Services Systems Manager User Guide</i>.</p>
    pub fn rejected_patches(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.rejected_patches.unwrap_or_default();
        v.push(input.into());
        self.rejected_patches = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of explicitly rejected patches for the baseline.</p>
    /// <p>For information about accepted formats for lists of approved patches and rejected patches, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">Package name formats for approved and rejected patch lists</a> in the <i>Amazon Web Services Systems Manager User Guide</i>.</p>
    pub fn set_rejected_patches(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.rejected_patches = input;
        self
    }
    /// <p>A list of explicitly rejected patches for the baseline.</p>
    /// <p>For information about accepted formats for lists of approved patches and rejected patches, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">Package name formats for approved and rejected patch lists</a> in the <i>Amazon Web Services Systems Manager User Guide</i>.</p>
    pub fn get_rejected_patches(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.rejected_patches
    }
    /// <p>The action for Patch Manager to take on patches included in the <code>RejectedPackages</code> list.</p>
    /// <dl>
    /// <dt>
    /// ALLOW_AS_DEPENDENCY
    /// </dt>
    /// <dd>
    /// <p><b>Linux and macOS</b>: A package in the rejected patches list is installed only if it is a dependency of another package. It is considered compliant with the patch baseline, and its status is reported as <code>INSTALLED_OTHER</code>. This is the default action if no option is specified.</p>
    /// <p><b>Windows Server</b>: Windows Server doesn't support the concept of package dependencies. If a package in the rejected patches list and already installed on the node, its status is reported as <code>INSTALLED_OTHER</code>. Any package not already installed on the node is skipped. This is the default action if no option is specified.</p>
    /// </dd>
    /// <dt>
    /// BLOCK
    /// </dt>
    /// <dd>
    /// <p><b>All OSs</b>: Packages in the rejected patches list, and packages that include them as dependencies, aren't installed by Patch Manager under any circumstances.</p>
    /// <p>State value assignment for patch compliance:</p>
    /// <ul>
    /// <li>
    /// <p>If a package was installed before it was added to the rejected patches list, or is installed outside of Patch Manager afterward, it's considered noncompliant with the patch baseline and its status is reported as <code>INSTALLED_REJECTED</code>.</p></li>
    /// <li>
    /// <p>If an update attempts to install a dependency package that is now rejected by the baseline, when previous versions of the package were not rejected, the package being updated is reported as <code>MISSING</code> for <code>SCAN</code> operations and as <code>FAILED</code> for <code>INSTALL</code> operations.</p></li>
    /// </ul>
    /// </dd>
    /// </dl>
    pub fn rejected_patches_action(mut self, input: crate::types::PatchAction) -> Self {
        self.rejected_patches_action = ::std::option::Option::Some(input);
        self
    }
    /// <p>The action for Patch Manager to take on patches included in the <code>RejectedPackages</code> list.</p>
    /// <dl>
    /// <dt>
    /// ALLOW_AS_DEPENDENCY
    /// </dt>
    /// <dd>
    /// <p><b>Linux and macOS</b>: A package in the rejected patches list is installed only if it is a dependency of another package. It is considered compliant with the patch baseline, and its status is reported as <code>INSTALLED_OTHER</code>. This is the default action if no option is specified.</p>
    /// <p><b>Windows Server</b>: Windows Server doesn't support the concept of package dependencies. If a package in the rejected patches list and already installed on the node, its status is reported as <code>INSTALLED_OTHER</code>. Any package not already installed on the node is skipped. This is the default action if no option is specified.</p>
    /// </dd>
    /// <dt>
    /// BLOCK
    /// </dt>
    /// <dd>
    /// <p><b>All OSs</b>: Packages in the rejected patches list, and packages that include them as dependencies, aren't installed by Patch Manager under any circumstances.</p>
    /// <p>State value assignment for patch compliance:</p>
    /// <ul>
    /// <li>
    /// <p>If a package was installed before it was added to the rejected patches list, or is installed outside of Patch Manager afterward, it's considered noncompliant with the patch baseline and its status is reported as <code>INSTALLED_REJECTED</code>.</p></li>
    /// <li>
    /// <p>If an update attempts to install a dependency package that is now rejected by the baseline, when previous versions of the package were not rejected, the package being updated is reported as <code>MISSING</code> for <code>SCAN</code> operations and as <code>FAILED</code> for <code>INSTALL</code> operations.</p></li>
    /// </ul>
    /// </dd>
    /// </dl>
    pub fn set_rejected_patches_action(mut self, input: ::std::option::Option<crate::types::PatchAction>) -> Self {
        self.rejected_patches_action = input;
        self
    }
    /// <p>The action for Patch Manager to take on patches included in the <code>RejectedPackages</code> list.</p>
    /// <dl>
    /// <dt>
    /// ALLOW_AS_DEPENDENCY
    /// </dt>
    /// <dd>
    /// <p><b>Linux and macOS</b>: A package in the rejected patches list is installed only if it is a dependency of another package. It is considered compliant with the patch baseline, and its status is reported as <code>INSTALLED_OTHER</code>. This is the default action if no option is specified.</p>
    /// <p><b>Windows Server</b>: Windows Server doesn't support the concept of package dependencies. If a package in the rejected patches list and already installed on the node, its status is reported as <code>INSTALLED_OTHER</code>. Any package not already installed on the node is skipped. This is the default action if no option is specified.</p>
    /// </dd>
    /// <dt>
    /// BLOCK
    /// </dt>
    /// <dd>
    /// <p><b>All OSs</b>: Packages in the rejected patches list, and packages that include them as dependencies, aren't installed by Patch Manager under any circumstances.</p>
    /// <p>State value assignment for patch compliance:</p>
    /// <ul>
    /// <li>
    /// <p>If a package was installed before it was added to the rejected patches list, or is installed outside of Patch Manager afterward, it's considered noncompliant with the patch baseline and its status is reported as <code>INSTALLED_REJECTED</code>.</p></li>
    /// <li>
    /// <p>If an update attempts to install a dependency package that is now rejected by the baseline, when previous versions of the package were not rejected, the package being updated is reported as <code>MISSING</code> for <code>SCAN</code> operations and as <code>FAILED</code> for <code>INSTALL</code> operations.</p></li>
    /// </ul>
    /// </dd>
    /// </dl>
    pub fn get_rejected_patches_action(&self) -> &::std::option::Option<crate::types::PatchAction> {
        &self.rejected_patches_action
    }
    /// <p>A description of the patch baseline.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A description of the patch baseline.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>A description of the patch baseline.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.description
    }
    /// Appends an item to `sources`.
    ///
    /// To override the contents of this collection use [`set_sources`](Self::set_sources).
    ///
    /// <p>Information about the patches to use to update the managed nodes, including target operating systems and source repositories. Applies to Linux managed nodes only.</p>
    pub fn sources(mut self, input: crate::types::PatchSource) -> Self {
        let mut v = self.sources.unwrap_or_default();
        v.push(input);
        self.sources = ::std::option::Option::Some(v);
        self
    }
    /// <p>Information about the patches to use to update the managed nodes, including target operating systems and source repositories. Applies to Linux managed nodes only.</p>
    pub fn set_sources(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::PatchSource>>) -> Self {
        self.sources = input;
        self
    }
    /// <p>Information about the patches to use to update the managed nodes, including target operating systems and source repositories. Applies to Linux managed nodes only.</p>
    pub fn get_sources(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::PatchSource>> {
        &self.sources
    }
    /// <p>Indicates the status you want to assign to security patches that are available but not approved because they don't meet the installation criteria specified in the patch baseline.</p>
    /// <p>Example scenario: Security patches that you might want installed can be skipped if you have specified a long period to wait after a patch is released before installation. If an update to the patch is released during your specified waiting period, the waiting period for installing the patch starts over. If the waiting period is too long, multiple versions of the patch could be released but never installed.</p>
    /// <p>Supported for Windows Server managed nodes only.</p>
    pub fn available_security_updates_compliance_status(mut self, input: crate::types::PatchComplianceStatus) -> Self {
        self.available_security_updates_compliance_status = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates the status you want to assign to security patches that are available but not approved because they don't meet the installation criteria specified in the patch baseline.</p>
    /// <p>Example scenario: Security patches that you might want installed can be skipped if you have specified a long period to wait after a patch is released before installation. If an update to the patch is released during your specified waiting period, the waiting period for installing the patch starts over. If the waiting period is too long, multiple versions of the patch could be released but never installed.</p>
    /// <p>Supported for Windows Server managed nodes only.</p>
    pub fn set_available_security_updates_compliance_status(mut self, input: ::std::option::Option<crate::types::PatchComplianceStatus>) -> Self {
        self.available_security_updates_compliance_status = input;
        self
    }
    /// <p>Indicates the status you want to assign to security patches that are available but not approved because they don't meet the installation criteria specified in the patch baseline.</p>
    /// <p>Example scenario: Security patches that you might want installed can be skipped if you have specified a long period to wait after a patch is released before installation. If an update to the patch is released during your specified waiting period, the waiting period for installing the patch starts over. If the waiting period is too long, multiple versions of the patch could be released but never installed.</p>
    /// <p>Supported for Windows Server managed nodes only.</p>
    pub fn get_available_security_updates_compliance_status(&self) -> &::std::option::Option<crate::types::PatchComplianceStatus> {
        &self.available_security_updates_compliance_status
    }
    /// <p>User-provided idempotency token.</p>
    pub fn client_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.client_token = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>User-provided idempotency token.</p>
    pub fn set_client_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.client_token = input;
        self
    }
    /// <p>User-provided idempotency token.</p>
    pub fn get_client_token(&self) -> &::std::option::Option<::std::string::String> {
        &self.client_token
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>Optional metadata that you assign to a resource. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag a patch baseline to identify the severity level of patches it specifies and the operating system family it applies to. In this case, you could specify the following key-value pairs:</p>
    /// <ul>
    /// <li>
    /// <p><code>Key=PatchSeverity,Value=Critical</code></p></li>
    /// <li>
    /// <p><code>Key=OS,Value=Windows</code></p></li>
    /// </ul><note>
    /// <p>To add tags to an existing patch baseline, use the <code>AddTagsToResource</code> operation.</p>
    /// </note>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        let mut v = self.tags.unwrap_or_default();
        v.push(input);
        self.tags = ::std::option::Option::Some(v);
        self
    }
    /// <p>Optional metadata that you assign to a resource. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag a patch baseline to identify the severity level of patches it specifies and the operating system family it applies to. In this case, you could specify the following key-value pairs:</p>
    /// <ul>
    /// <li>
    /// <p><code>Key=PatchSeverity,Value=Critical</code></p></li>
    /// <li>
    /// <p><code>Key=OS,Value=Windows</code></p></li>
    /// </ul><note>
    /// <p>To add tags to an existing patch baseline, use the <code>AddTagsToResource</code> operation.</p>
    /// </note>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>Optional metadata that you assign to a resource. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag a patch baseline to identify the severity level of patches it specifies and the operating system family it applies to. In this case, you could specify the following key-value pairs:</p>
    /// <ul>
    /// <li>
    /// <p><code>Key=PatchSeverity,Value=Critical</code></p></li>
    /// <li>
    /// <p><code>Key=OS,Value=Windows</code></p></li>
    /// </ul><note>
    /// <p>To add tags to an existing patch baseline, use the <code>AddTagsToResource</code> operation.</p>
    /// </note>
    pub fn get_tags(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Tag>> {
        &self.tags
    }
    /// Consumes the builder and constructs a [`CreatePatchBaselineInput`](crate::operation::create_patch_baseline::CreatePatchBaselineInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::create_patch_baseline::CreatePatchBaselineInput, ::aws_smithy_types::error::operation::BuildError>
    {
        ::std::result::Result::Ok(crate::operation::create_patch_baseline::CreatePatchBaselineInput {
            operating_system: self.operating_system,
            name: self.name,
            global_filters: self.global_filters,
            approval_rules: self.approval_rules,
            approved_patches: self.approved_patches,
            approved_patches_compliance_level: self.approved_patches_compliance_level,
            approved_patches_enable_non_security: self.approved_patches_enable_non_security,
            rejected_patches: self.rejected_patches,
            rejected_patches_action: self.rejected_patches_action,
            description: self.description,
            sources: self.sources,
            available_security_updates_compliance_status: self.available_security_updates_compliance_status,
            client_token: self.client_token,
            tags: self.tags,
        })
    }
}
