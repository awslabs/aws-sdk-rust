// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct DescribePatchGroupStateOutput {
    /// <p>The number of managed nodes in the patch group.</p>
    pub instances: i32,
    /// <p>The number of managed nodes with installed patches.</p>
    pub instances_with_installed_patches: i32,
    /// <p>The number of managed nodes with patches installed that aren't defined in the patch baseline.</p>
    pub instances_with_installed_other_patches: i32,
    /// <p>The number of managed nodes with patches installed by Patch Manager that haven't been rebooted after the patch installation. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub instances_with_installed_pending_reboot_patches: ::std::option::Option<i32>,
    /// <p>The number of managed nodes with patches installed that are specified in a <code>RejectedPatches</code> list. Patches with a status of <code>INSTALLED_REJECTED</code> were typically installed before they were added to a <code>RejectedPatches</code> list.</p><note>
    /// <p>If <code>ALLOW_AS_DEPENDENCY</code> is the specified option for <code>RejectedPatchesAction</code>, the value of <code>InstancesWithInstalledRejectedPatches</code> will always be <code>0</code> (zero).</p>
    /// </note>
    pub instances_with_installed_rejected_patches: ::std::option::Option<i32>,
    /// <p>The number of managed nodes with missing patches from the patch baseline.</p>
    pub instances_with_missing_patches: i32,
    /// <p>The number of managed nodes with patches from the patch baseline that failed to install.</p>
    pub instances_with_failed_patches: i32,
    /// <p>The number of managed nodes with patches that aren't applicable.</p>
    pub instances_with_not_applicable_patches: i32,
    /// <p>The number of managed nodes with <code>NotApplicable</code> patches beyond the supported limit, which aren't reported by name to Inventory. Inventory is a tool in Amazon Web Services Systems Manager.</p>
    pub instances_with_unreported_not_applicable_patches: ::std::option::Option<i32>,
    /// <p>The number of managed nodes where patches that are specified as <code>Critical</code> for compliance reporting in the patch baseline aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub instances_with_critical_non_compliant_patches: ::std::option::Option<i32>,
    /// <p>The number of managed nodes where patches that are specified as <code>Security</code> in a patch advisory aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub instances_with_security_non_compliant_patches: ::std::option::Option<i32>,
    /// <p>The number of managed nodes with patches installed that are specified as other than <code>Critical</code> or <code>Security</code> but aren't compliant with the patch baseline. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub instances_with_other_non_compliant_patches: ::std::option::Option<i32>,
    /// <p>The number of managed nodes for which security-related patches are available but not approved because because they didn't meet the patch baseline requirements. For example, an updated version of a patch might have been released before the specified auto-approval period was over.</p>
    /// <p>Applies to Windows Server managed nodes only.</p>
    pub instances_with_available_security_updates: ::std::option::Option<i32>,
    _request_id: Option<String>,
}
impl DescribePatchGroupStateOutput {
    /// <p>The number of managed nodes in the patch group.</p>
    pub fn instances(&self) -> i32 {
        self.instances
    }
    /// <p>The number of managed nodes with installed patches.</p>
    pub fn instances_with_installed_patches(&self) -> i32 {
        self.instances_with_installed_patches
    }
    /// <p>The number of managed nodes with patches installed that aren't defined in the patch baseline.</p>
    pub fn instances_with_installed_other_patches(&self) -> i32 {
        self.instances_with_installed_other_patches
    }
    /// <p>The number of managed nodes with patches installed by Patch Manager that haven't been rebooted after the patch installation. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub fn instances_with_installed_pending_reboot_patches(&self) -> ::std::option::Option<i32> {
        self.instances_with_installed_pending_reboot_patches
    }
    /// <p>The number of managed nodes with patches installed that are specified in a <code>RejectedPatches</code> list. Patches with a status of <code>INSTALLED_REJECTED</code> were typically installed before they were added to a <code>RejectedPatches</code> list.</p><note>
    /// <p>If <code>ALLOW_AS_DEPENDENCY</code> is the specified option for <code>RejectedPatchesAction</code>, the value of <code>InstancesWithInstalledRejectedPatches</code> will always be <code>0</code> (zero).</p>
    /// </note>
    pub fn instances_with_installed_rejected_patches(&self) -> ::std::option::Option<i32> {
        self.instances_with_installed_rejected_patches
    }
    /// <p>The number of managed nodes with missing patches from the patch baseline.</p>
    pub fn instances_with_missing_patches(&self) -> i32 {
        self.instances_with_missing_patches
    }
    /// <p>The number of managed nodes with patches from the patch baseline that failed to install.</p>
    pub fn instances_with_failed_patches(&self) -> i32 {
        self.instances_with_failed_patches
    }
    /// <p>The number of managed nodes with patches that aren't applicable.</p>
    pub fn instances_with_not_applicable_patches(&self) -> i32 {
        self.instances_with_not_applicable_patches
    }
    /// <p>The number of managed nodes with <code>NotApplicable</code> patches beyond the supported limit, which aren't reported by name to Inventory. Inventory is a tool in Amazon Web Services Systems Manager.</p>
    pub fn instances_with_unreported_not_applicable_patches(&self) -> ::std::option::Option<i32> {
        self.instances_with_unreported_not_applicable_patches
    }
    /// <p>The number of managed nodes where patches that are specified as <code>Critical</code> for compliance reporting in the patch baseline aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub fn instances_with_critical_non_compliant_patches(&self) -> ::std::option::Option<i32> {
        self.instances_with_critical_non_compliant_patches
    }
    /// <p>The number of managed nodes where patches that are specified as <code>Security</code> in a patch advisory aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub fn instances_with_security_non_compliant_patches(&self) -> ::std::option::Option<i32> {
        self.instances_with_security_non_compliant_patches
    }
    /// <p>The number of managed nodes with patches installed that are specified as other than <code>Critical</code> or <code>Security</code> but aren't compliant with the patch baseline. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub fn instances_with_other_non_compliant_patches(&self) -> ::std::option::Option<i32> {
        self.instances_with_other_non_compliant_patches
    }
    /// <p>The number of managed nodes for which security-related patches are available but not approved because because they didn't meet the patch baseline requirements. For example, an updated version of a patch might have been released before the specified auto-approval period was over.</p>
    /// <p>Applies to Windows Server managed nodes only.</p>
    pub fn instances_with_available_security_updates(&self) -> ::std::option::Option<i32> {
        self.instances_with_available_security_updates
    }
}
impl ::aws_types::request_id::RequestId for DescribePatchGroupStateOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl DescribePatchGroupStateOutput {
    /// Creates a new builder-style object to manufacture [`DescribePatchGroupStateOutput`](crate::operation::describe_patch_group_state::DescribePatchGroupStateOutput).
    pub fn builder() -> crate::operation::describe_patch_group_state::builders::DescribePatchGroupStateOutputBuilder {
        crate::operation::describe_patch_group_state::builders::DescribePatchGroupStateOutputBuilder::default()
    }
}

/// A builder for [`DescribePatchGroupStateOutput`](crate::operation::describe_patch_group_state::DescribePatchGroupStateOutput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct DescribePatchGroupStateOutputBuilder {
    pub(crate) instances: ::std::option::Option<i32>,
    pub(crate) instances_with_installed_patches: ::std::option::Option<i32>,
    pub(crate) instances_with_installed_other_patches: ::std::option::Option<i32>,
    pub(crate) instances_with_installed_pending_reboot_patches: ::std::option::Option<i32>,
    pub(crate) instances_with_installed_rejected_patches: ::std::option::Option<i32>,
    pub(crate) instances_with_missing_patches: ::std::option::Option<i32>,
    pub(crate) instances_with_failed_patches: ::std::option::Option<i32>,
    pub(crate) instances_with_not_applicable_patches: ::std::option::Option<i32>,
    pub(crate) instances_with_unreported_not_applicable_patches: ::std::option::Option<i32>,
    pub(crate) instances_with_critical_non_compliant_patches: ::std::option::Option<i32>,
    pub(crate) instances_with_security_non_compliant_patches: ::std::option::Option<i32>,
    pub(crate) instances_with_other_non_compliant_patches: ::std::option::Option<i32>,
    pub(crate) instances_with_available_security_updates: ::std::option::Option<i32>,
    _request_id: Option<String>,
}
impl DescribePatchGroupStateOutputBuilder {
    /// <p>The number of managed nodes in the patch group.</p>
    pub fn instances(mut self, input: i32) -> Self {
        self.instances = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of managed nodes in the patch group.</p>
    pub fn set_instances(mut self, input: ::std::option::Option<i32>) -> Self {
        self.instances = input;
        self
    }
    /// <p>The number of managed nodes in the patch group.</p>
    pub fn get_instances(&self) -> &::std::option::Option<i32> {
        &self.instances
    }
    /// <p>The number of managed nodes with installed patches.</p>
    pub fn instances_with_installed_patches(mut self, input: i32) -> Self {
        self.instances_with_installed_patches = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of managed nodes with installed patches.</p>
    pub fn set_instances_with_installed_patches(mut self, input: ::std::option::Option<i32>) -> Self {
        self.instances_with_installed_patches = input;
        self
    }
    /// <p>The number of managed nodes with installed patches.</p>
    pub fn get_instances_with_installed_patches(&self) -> &::std::option::Option<i32> {
        &self.instances_with_installed_patches
    }
    /// <p>The number of managed nodes with patches installed that aren't defined in the patch baseline.</p>
    pub fn instances_with_installed_other_patches(mut self, input: i32) -> Self {
        self.instances_with_installed_other_patches = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of managed nodes with patches installed that aren't defined in the patch baseline.</p>
    pub fn set_instances_with_installed_other_patches(mut self, input: ::std::option::Option<i32>) -> Self {
        self.instances_with_installed_other_patches = input;
        self
    }
    /// <p>The number of managed nodes with patches installed that aren't defined in the patch baseline.</p>
    pub fn get_instances_with_installed_other_patches(&self) -> &::std::option::Option<i32> {
        &self.instances_with_installed_other_patches
    }
    /// <p>The number of managed nodes with patches installed by Patch Manager that haven't been rebooted after the patch installation. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub fn instances_with_installed_pending_reboot_patches(mut self, input: i32) -> Self {
        self.instances_with_installed_pending_reboot_patches = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of managed nodes with patches installed by Patch Manager that haven't been rebooted after the patch installation. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub fn set_instances_with_installed_pending_reboot_patches(mut self, input: ::std::option::Option<i32>) -> Self {
        self.instances_with_installed_pending_reboot_patches = input;
        self
    }
    /// <p>The number of managed nodes with patches installed by Patch Manager that haven't been rebooted after the patch installation. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub fn get_instances_with_installed_pending_reboot_patches(&self) -> &::std::option::Option<i32> {
        &self.instances_with_installed_pending_reboot_patches
    }
    /// <p>The number of managed nodes with patches installed that are specified in a <code>RejectedPatches</code> list. Patches with a status of <code>INSTALLED_REJECTED</code> were typically installed before they were added to a <code>RejectedPatches</code> list.</p><note>
    /// <p>If <code>ALLOW_AS_DEPENDENCY</code> is the specified option for <code>RejectedPatchesAction</code>, the value of <code>InstancesWithInstalledRejectedPatches</code> will always be <code>0</code> (zero).</p>
    /// </note>
    pub fn instances_with_installed_rejected_patches(mut self, input: i32) -> Self {
        self.instances_with_installed_rejected_patches = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of managed nodes with patches installed that are specified in a <code>RejectedPatches</code> list. Patches with a status of <code>INSTALLED_REJECTED</code> were typically installed before they were added to a <code>RejectedPatches</code> list.</p><note>
    /// <p>If <code>ALLOW_AS_DEPENDENCY</code> is the specified option for <code>RejectedPatchesAction</code>, the value of <code>InstancesWithInstalledRejectedPatches</code> will always be <code>0</code> (zero).</p>
    /// </note>
    pub fn set_instances_with_installed_rejected_patches(mut self, input: ::std::option::Option<i32>) -> Self {
        self.instances_with_installed_rejected_patches = input;
        self
    }
    /// <p>The number of managed nodes with patches installed that are specified in a <code>RejectedPatches</code> list. Patches with a status of <code>INSTALLED_REJECTED</code> were typically installed before they were added to a <code>RejectedPatches</code> list.</p><note>
    /// <p>If <code>ALLOW_AS_DEPENDENCY</code> is the specified option for <code>RejectedPatchesAction</code>, the value of <code>InstancesWithInstalledRejectedPatches</code> will always be <code>0</code> (zero).</p>
    /// </note>
    pub fn get_instances_with_installed_rejected_patches(&self) -> &::std::option::Option<i32> {
        &self.instances_with_installed_rejected_patches
    }
    /// <p>The number of managed nodes with missing patches from the patch baseline.</p>
    pub fn instances_with_missing_patches(mut self, input: i32) -> Self {
        self.instances_with_missing_patches = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of managed nodes with missing patches from the patch baseline.</p>
    pub fn set_instances_with_missing_patches(mut self, input: ::std::option::Option<i32>) -> Self {
        self.instances_with_missing_patches = input;
        self
    }
    /// <p>The number of managed nodes with missing patches from the patch baseline.</p>
    pub fn get_instances_with_missing_patches(&self) -> &::std::option::Option<i32> {
        &self.instances_with_missing_patches
    }
    /// <p>The number of managed nodes with patches from the patch baseline that failed to install.</p>
    pub fn instances_with_failed_patches(mut self, input: i32) -> Self {
        self.instances_with_failed_patches = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of managed nodes with patches from the patch baseline that failed to install.</p>
    pub fn set_instances_with_failed_patches(mut self, input: ::std::option::Option<i32>) -> Self {
        self.instances_with_failed_patches = input;
        self
    }
    /// <p>The number of managed nodes with patches from the patch baseline that failed to install.</p>
    pub fn get_instances_with_failed_patches(&self) -> &::std::option::Option<i32> {
        &self.instances_with_failed_patches
    }
    /// <p>The number of managed nodes with patches that aren't applicable.</p>
    pub fn instances_with_not_applicable_patches(mut self, input: i32) -> Self {
        self.instances_with_not_applicable_patches = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of managed nodes with patches that aren't applicable.</p>
    pub fn set_instances_with_not_applicable_patches(mut self, input: ::std::option::Option<i32>) -> Self {
        self.instances_with_not_applicable_patches = input;
        self
    }
    /// <p>The number of managed nodes with patches that aren't applicable.</p>
    pub fn get_instances_with_not_applicable_patches(&self) -> &::std::option::Option<i32> {
        &self.instances_with_not_applicable_patches
    }
    /// <p>The number of managed nodes with <code>NotApplicable</code> patches beyond the supported limit, which aren't reported by name to Inventory. Inventory is a tool in Amazon Web Services Systems Manager.</p>
    pub fn instances_with_unreported_not_applicable_patches(mut self, input: i32) -> Self {
        self.instances_with_unreported_not_applicable_patches = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of managed nodes with <code>NotApplicable</code> patches beyond the supported limit, which aren't reported by name to Inventory. Inventory is a tool in Amazon Web Services Systems Manager.</p>
    pub fn set_instances_with_unreported_not_applicable_patches(mut self, input: ::std::option::Option<i32>) -> Self {
        self.instances_with_unreported_not_applicable_patches = input;
        self
    }
    /// <p>The number of managed nodes with <code>NotApplicable</code> patches beyond the supported limit, which aren't reported by name to Inventory. Inventory is a tool in Amazon Web Services Systems Manager.</p>
    pub fn get_instances_with_unreported_not_applicable_patches(&self) -> &::std::option::Option<i32> {
        &self.instances_with_unreported_not_applicable_patches
    }
    /// <p>The number of managed nodes where patches that are specified as <code>Critical</code> for compliance reporting in the patch baseline aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub fn instances_with_critical_non_compliant_patches(mut self, input: i32) -> Self {
        self.instances_with_critical_non_compliant_patches = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of managed nodes where patches that are specified as <code>Critical</code> for compliance reporting in the patch baseline aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub fn set_instances_with_critical_non_compliant_patches(mut self, input: ::std::option::Option<i32>) -> Self {
        self.instances_with_critical_non_compliant_patches = input;
        self
    }
    /// <p>The number of managed nodes where patches that are specified as <code>Critical</code> for compliance reporting in the patch baseline aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub fn get_instances_with_critical_non_compliant_patches(&self) -> &::std::option::Option<i32> {
        &self.instances_with_critical_non_compliant_patches
    }
    /// <p>The number of managed nodes where patches that are specified as <code>Security</code> in a patch advisory aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub fn instances_with_security_non_compliant_patches(mut self, input: i32) -> Self {
        self.instances_with_security_non_compliant_patches = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of managed nodes where patches that are specified as <code>Security</code> in a patch advisory aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub fn set_instances_with_security_non_compliant_patches(mut self, input: ::std::option::Option<i32>) -> Self {
        self.instances_with_security_non_compliant_patches = input;
        self
    }
    /// <p>The number of managed nodes where patches that are specified as <code>Security</code> in a patch advisory aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub fn get_instances_with_security_non_compliant_patches(&self) -> &::std::option::Option<i32> {
        &self.instances_with_security_non_compliant_patches
    }
    /// <p>The number of managed nodes with patches installed that are specified as other than <code>Critical</code> or <code>Security</code> but aren't compliant with the patch baseline. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub fn instances_with_other_non_compliant_patches(mut self, input: i32) -> Self {
        self.instances_with_other_non_compliant_patches = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of managed nodes with patches installed that are specified as other than <code>Critical</code> or <code>Security</code> but aren't compliant with the patch baseline. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub fn set_instances_with_other_non_compliant_patches(mut self, input: ::std::option::Option<i32>) -> Self {
        self.instances_with_other_non_compliant_patches = input;
        self
    }
    /// <p>The number of managed nodes with patches installed that are specified as other than <code>Critical</code> or <code>Security</code> but aren't compliant with the patch baseline. The status of these managed nodes is <code>NON_COMPLIANT</code>.</p>
    pub fn get_instances_with_other_non_compliant_patches(&self) -> &::std::option::Option<i32> {
        &self.instances_with_other_non_compliant_patches
    }
    /// <p>The number of managed nodes for which security-related patches are available but not approved because because they didn't meet the patch baseline requirements. For example, an updated version of a patch might have been released before the specified auto-approval period was over.</p>
    /// <p>Applies to Windows Server managed nodes only.</p>
    pub fn instances_with_available_security_updates(mut self, input: i32) -> Self {
        self.instances_with_available_security_updates = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of managed nodes for which security-related patches are available but not approved because because they didn't meet the patch baseline requirements. For example, an updated version of a patch might have been released before the specified auto-approval period was over.</p>
    /// <p>Applies to Windows Server managed nodes only.</p>
    pub fn set_instances_with_available_security_updates(mut self, input: ::std::option::Option<i32>) -> Self {
        self.instances_with_available_security_updates = input;
        self
    }
    /// <p>The number of managed nodes for which security-related patches are available but not approved because because they didn't meet the patch baseline requirements. For example, an updated version of a patch might have been released before the specified auto-approval period was over.</p>
    /// <p>Applies to Windows Server managed nodes only.</p>
    pub fn get_instances_with_available_security_updates(&self) -> &::std::option::Option<i32> {
        &self.instances_with_available_security_updates
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
        self._request_id = Some(request_id.into());
        self
    }

    pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
        self._request_id = request_id;
        self
    }
    /// Consumes the builder and constructs a [`DescribePatchGroupStateOutput`](crate::operation::describe_patch_group_state::DescribePatchGroupStateOutput).
    pub fn build(self) -> crate::operation::describe_patch_group_state::DescribePatchGroupStateOutput {
        crate::operation::describe_patch_group_state::DescribePatchGroupStateOutput {
            instances: self.instances.unwrap_or_default(),
            instances_with_installed_patches: self.instances_with_installed_patches.unwrap_or_default(),
            instances_with_installed_other_patches: self.instances_with_installed_other_patches.unwrap_or_default(),
            instances_with_installed_pending_reboot_patches: self.instances_with_installed_pending_reboot_patches,
            instances_with_installed_rejected_patches: self.instances_with_installed_rejected_patches,
            instances_with_missing_patches: self.instances_with_missing_patches.unwrap_or_default(),
            instances_with_failed_patches: self.instances_with_failed_patches.unwrap_or_default(),
            instances_with_not_applicable_patches: self.instances_with_not_applicable_patches.unwrap_or_default(),
            instances_with_unreported_not_applicable_patches: self.instances_with_unreported_not_applicable_patches,
            instances_with_critical_non_compliant_patches: self.instances_with_critical_non_compliant_patches,
            instances_with_security_non_compliant_patches: self.instances_with_security_non_compliant_patches,
            instances_with_other_non_compliant_patches: self.instances_with_other_non_compliant_patches,
            instances_with_available_security_updates: self.instances_with_available_security_updates,
            _request_id: self._request_id,
        }
    }
}
