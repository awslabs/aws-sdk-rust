// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct GetMaintenanceWindowTaskOutput {
    /// <p>The retrieved maintenance window ID.</p>
    pub window_id: ::std::option::Option<::std::string::String>,
    /// <p>The retrieved maintenance window task ID.</p>
    pub window_task_id: ::std::option::Option<::std::string::String>,
    /// <p>The targets where the task should run.</p>
    pub targets: ::std::option::Option<::std::vec::Vec<crate::types::Target>>,
    /// <p>The resource that the task used during execution. For <code>RUN_COMMAND</code> and <code>AUTOMATION</code> task types, the value of <code>TaskArn</code> is the SSM document name/ARN. For <code>LAMBDA</code> tasks, the value is the function name/ARN. For <code>STEP_FUNCTIONS</code> tasks, the value is the state machine ARN.</p>
    pub task_arn: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for maintenance window Run Command tasks.</p>
    pub service_role_arn: ::std::option::Option<::std::string::String>,
    /// <p>The type of task to run.</p>
    pub task_type: ::std::option::Option<crate::types::MaintenanceWindowTaskType>,
    /// <p>The parameters to pass to the task when it runs.</p> <note>
    /// <p> <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs, instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see <code>MaintenanceWindowTaskInvocationParameters</code>.</p>
    /// </note>
    pub task_parameters:
        ::std::option::Option<::std::collections::HashMap<::std::string::String, crate::types::MaintenanceWindowTaskParameterValueExpression>>,
    /// <p>The parameters to pass to the task when it runs.</p>
    pub task_invocation_parameters: ::std::option::Option<crate::types::MaintenanceWindowTaskInvocationParameters>,
    /// <p>The priority of the task when it runs. The lower the number, the higher the priority. Tasks that have the same priority are scheduled in parallel.</p>
    pub priority: i32,
    /// <p>The maximum number of targets allowed to run this task in parallel.</p> <note>
    /// <p>For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of <code>1</code>, which may be reported in the response to this command. This value doesn't affect the running of your task and can be ignored.</p>
    /// </note>
    pub max_concurrency: ::std::option::Option<::std::string::String>,
    /// <p>The maximum number of errors allowed before the task stops being scheduled.</p> <note>
    /// <p>For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of <code>1</code>, which may be reported in the response to this command. This value doesn't affect the running of your task and can be ignored.</p>
    /// </note>
    pub max_errors: ::std::option::Option<::std::string::String>,
    /// <p>The location in Amazon Simple Storage Service (Amazon S3) where the task results are logged.</p> <note>
    /// <p> <code>LoggingInfo</code> has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see <code>MaintenanceWindowTaskInvocationParameters</code>.</p>
    /// </note>
    pub logging_info: ::std::option::Option<crate::types::LoggingInfo>,
    /// <p>The retrieved task name.</p>
    pub name: ::std::option::Option<::std::string::String>,
    /// <p>The retrieved task description.</p>
    pub description: ::std::option::Option<::std::string::String>,
    /// <p>The action to take on tasks when the maintenance window cutoff time is reached. <code>CONTINUE_TASK</code> means that tasks continue to run. For Automation, Lambda, Step Functions tasks, <code>CANCEL_TASK</code> means that currently running task invocations continue, but no new task invocations are started. For Run Command tasks, <code>CANCEL_TASK</code> means the system attempts to stop the task by sending a <code>CancelCommand</code> operation.</p>
    pub cutoff_behavior: ::std::option::Option<crate::types::MaintenanceWindowTaskCutoffBehavior>,
    /// <p>The details for the CloudWatch alarm you applied to your maintenance window task.</p>
    pub alarm_configuration: ::std::option::Option<crate::types::AlarmConfiguration>,
    _request_id: Option<String>,
}
impl GetMaintenanceWindowTaskOutput {
    /// <p>The retrieved maintenance window ID.</p>
    pub fn window_id(&self) -> ::std::option::Option<&str> {
        self.window_id.as_deref()
    }
    /// <p>The retrieved maintenance window task ID.</p>
    pub fn window_task_id(&self) -> ::std::option::Option<&str> {
        self.window_task_id.as_deref()
    }
    /// <p>The targets where the task should run.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.targets.is_none()`.
    pub fn targets(&self) -> &[crate::types::Target] {
        self.targets.as_deref().unwrap_or_default()
    }
    /// <p>The resource that the task used during execution. For <code>RUN_COMMAND</code> and <code>AUTOMATION</code> task types, the value of <code>TaskArn</code> is the SSM document name/ARN. For <code>LAMBDA</code> tasks, the value is the function name/ARN. For <code>STEP_FUNCTIONS</code> tasks, the value is the state machine ARN.</p>
    pub fn task_arn(&self) -> ::std::option::Option<&str> {
        self.task_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for maintenance window Run Command tasks.</p>
    pub fn service_role_arn(&self) -> ::std::option::Option<&str> {
        self.service_role_arn.as_deref()
    }
    /// <p>The type of task to run.</p>
    pub fn task_type(&self) -> ::std::option::Option<&crate::types::MaintenanceWindowTaskType> {
        self.task_type.as_ref()
    }
    /// <p>The parameters to pass to the task when it runs.</p> <note>
    /// <p> <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs, instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see <code>MaintenanceWindowTaskInvocationParameters</code>.</p>
    /// </note>
    pub fn task_parameters(
        &self,
    ) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, crate::types::MaintenanceWindowTaskParameterValueExpression>> {
        self.task_parameters.as_ref()
    }
    /// <p>The parameters to pass to the task when it runs.</p>
    pub fn task_invocation_parameters(&self) -> ::std::option::Option<&crate::types::MaintenanceWindowTaskInvocationParameters> {
        self.task_invocation_parameters.as_ref()
    }
    /// <p>The priority of the task when it runs. The lower the number, the higher the priority. Tasks that have the same priority are scheduled in parallel.</p>
    pub fn priority(&self) -> i32 {
        self.priority
    }
    /// <p>The maximum number of targets allowed to run this task in parallel.</p> <note>
    /// <p>For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of <code>1</code>, which may be reported in the response to this command. This value doesn't affect the running of your task and can be ignored.</p>
    /// </note>
    pub fn max_concurrency(&self) -> ::std::option::Option<&str> {
        self.max_concurrency.as_deref()
    }
    /// <p>The maximum number of errors allowed before the task stops being scheduled.</p> <note>
    /// <p>For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of <code>1</code>, which may be reported in the response to this command. This value doesn't affect the running of your task and can be ignored.</p>
    /// </note>
    pub fn max_errors(&self) -> ::std::option::Option<&str> {
        self.max_errors.as_deref()
    }
    /// <p>The location in Amazon Simple Storage Service (Amazon S3) where the task results are logged.</p> <note>
    /// <p> <code>LoggingInfo</code> has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see <code>MaintenanceWindowTaskInvocationParameters</code>.</p>
    /// </note>
    pub fn logging_info(&self) -> ::std::option::Option<&crate::types::LoggingInfo> {
        self.logging_info.as_ref()
    }
    /// <p>The retrieved task name.</p>
    pub fn name(&self) -> ::std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The retrieved task description.</p>
    pub fn description(&self) -> ::std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The action to take on tasks when the maintenance window cutoff time is reached. <code>CONTINUE_TASK</code> means that tasks continue to run. For Automation, Lambda, Step Functions tasks, <code>CANCEL_TASK</code> means that currently running task invocations continue, but no new task invocations are started. For Run Command tasks, <code>CANCEL_TASK</code> means the system attempts to stop the task by sending a <code>CancelCommand</code> operation.</p>
    pub fn cutoff_behavior(&self) -> ::std::option::Option<&crate::types::MaintenanceWindowTaskCutoffBehavior> {
        self.cutoff_behavior.as_ref()
    }
    /// <p>The details for the CloudWatch alarm you applied to your maintenance window task.</p>
    pub fn alarm_configuration(&self) -> ::std::option::Option<&crate::types::AlarmConfiguration> {
        self.alarm_configuration.as_ref()
    }
}
impl ::std::fmt::Debug for GetMaintenanceWindowTaskOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("GetMaintenanceWindowTaskOutput");
        formatter.field("window_id", &self.window_id);
        formatter.field("window_task_id", &self.window_task_id);
        formatter.field("targets", &self.targets);
        formatter.field("task_arn", &self.task_arn);
        formatter.field("service_role_arn", &self.service_role_arn);
        formatter.field("task_type", &self.task_type);
        formatter.field("task_parameters", &"*** Sensitive Data Redacted ***");
        formatter.field("task_invocation_parameters", &self.task_invocation_parameters);
        formatter.field("priority", &self.priority);
        formatter.field("max_concurrency", &self.max_concurrency);
        formatter.field("max_errors", &self.max_errors);
        formatter.field("logging_info", &self.logging_info);
        formatter.field("name", &self.name);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("cutoff_behavior", &self.cutoff_behavior);
        formatter.field("alarm_configuration", &self.alarm_configuration);
        formatter.field("_request_id", &self._request_id);
        formatter.finish()
    }
}
impl ::aws_http::request_id::RequestId for GetMaintenanceWindowTaskOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl GetMaintenanceWindowTaskOutput {
    /// Creates a new builder-style object to manufacture [`GetMaintenanceWindowTaskOutput`](crate::operation::get_maintenance_window_task::GetMaintenanceWindowTaskOutput).
    pub fn builder() -> crate::operation::get_maintenance_window_task::builders::GetMaintenanceWindowTaskOutputBuilder {
        crate::operation::get_maintenance_window_task::builders::GetMaintenanceWindowTaskOutputBuilder::default()
    }
}

/// A builder for [`GetMaintenanceWindowTaskOutput`](crate::operation::get_maintenance_window_task::GetMaintenanceWindowTaskOutput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
pub struct GetMaintenanceWindowTaskOutputBuilder {
    pub(crate) window_id: ::std::option::Option<::std::string::String>,
    pub(crate) window_task_id: ::std::option::Option<::std::string::String>,
    pub(crate) targets: ::std::option::Option<::std::vec::Vec<crate::types::Target>>,
    pub(crate) task_arn: ::std::option::Option<::std::string::String>,
    pub(crate) service_role_arn: ::std::option::Option<::std::string::String>,
    pub(crate) task_type: ::std::option::Option<crate::types::MaintenanceWindowTaskType>,
    pub(crate) task_parameters:
        ::std::option::Option<::std::collections::HashMap<::std::string::String, crate::types::MaintenanceWindowTaskParameterValueExpression>>,
    pub(crate) task_invocation_parameters: ::std::option::Option<crate::types::MaintenanceWindowTaskInvocationParameters>,
    pub(crate) priority: ::std::option::Option<i32>,
    pub(crate) max_concurrency: ::std::option::Option<::std::string::String>,
    pub(crate) max_errors: ::std::option::Option<::std::string::String>,
    pub(crate) logging_info: ::std::option::Option<crate::types::LoggingInfo>,
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) description: ::std::option::Option<::std::string::String>,
    pub(crate) cutoff_behavior: ::std::option::Option<crate::types::MaintenanceWindowTaskCutoffBehavior>,
    pub(crate) alarm_configuration: ::std::option::Option<crate::types::AlarmConfiguration>,
    _request_id: Option<String>,
}
impl GetMaintenanceWindowTaskOutputBuilder {
    /// <p>The retrieved maintenance window ID.</p>
    pub fn window_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.window_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The retrieved maintenance window ID.</p>
    pub fn set_window_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.window_id = input;
        self
    }
    /// <p>The retrieved maintenance window ID.</p>
    pub fn get_window_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.window_id
    }
    /// <p>The retrieved maintenance window task ID.</p>
    pub fn window_task_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.window_task_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The retrieved maintenance window task ID.</p>
    pub fn set_window_task_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.window_task_id = input;
        self
    }
    /// <p>The retrieved maintenance window task ID.</p>
    pub fn get_window_task_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.window_task_id
    }
    /// Appends an item to `targets`.
    ///
    /// To override the contents of this collection use [`set_targets`](Self::set_targets).
    ///
    /// <p>The targets where the task should run.</p>
    pub fn targets(mut self, input: crate::types::Target) -> Self {
        let mut v = self.targets.unwrap_or_default();
        v.push(input);
        self.targets = ::std::option::Option::Some(v);
        self
    }
    /// <p>The targets where the task should run.</p>
    pub fn set_targets(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Target>>) -> Self {
        self.targets = input;
        self
    }
    /// <p>The targets where the task should run.</p>
    pub fn get_targets(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Target>> {
        &self.targets
    }
    /// <p>The resource that the task used during execution. For <code>RUN_COMMAND</code> and <code>AUTOMATION</code> task types, the value of <code>TaskArn</code> is the SSM document name/ARN. For <code>LAMBDA</code> tasks, the value is the function name/ARN. For <code>STEP_FUNCTIONS</code> tasks, the value is the state machine ARN.</p>
    pub fn task_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.task_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The resource that the task used during execution. For <code>RUN_COMMAND</code> and <code>AUTOMATION</code> task types, the value of <code>TaskArn</code> is the SSM document name/ARN. For <code>LAMBDA</code> tasks, the value is the function name/ARN. For <code>STEP_FUNCTIONS</code> tasks, the value is the state machine ARN.</p>
    pub fn set_task_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.task_arn = input;
        self
    }
    /// <p>The resource that the task used during execution. For <code>RUN_COMMAND</code> and <code>AUTOMATION</code> task types, the value of <code>TaskArn</code> is the SSM document name/ARN. For <code>LAMBDA</code> tasks, the value is the function name/ARN. For <code>STEP_FUNCTIONS</code> tasks, the value is the state machine ARN.</p>
    pub fn get_task_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.task_arn
    }
    /// <p>The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for maintenance window Run Command tasks.</p>
    pub fn service_role_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.service_role_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for maintenance window Run Command tasks.</p>
    pub fn set_service_role_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.service_role_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for maintenance window Run Command tasks.</p>
    pub fn get_service_role_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.service_role_arn
    }
    /// <p>The type of task to run.</p>
    pub fn task_type(mut self, input: crate::types::MaintenanceWindowTaskType) -> Self {
        self.task_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The type of task to run.</p>
    pub fn set_task_type(mut self, input: ::std::option::Option<crate::types::MaintenanceWindowTaskType>) -> Self {
        self.task_type = input;
        self
    }
    /// <p>The type of task to run.</p>
    pub fn get_task_type(&self) -> &::std::option::Option<crate::types::MaintenanceWindowTaskType> {
        &self.task_type
    }
    /// Adds a key-value pair to `task_parameters`.
    ///
    /// To override the contents of this collection use [`set_task_parameters`](Self::set_task_parameters).
    ///
    /// <p>The parameters to pass to the task when it runs.</p> <note>
    /// <p> <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs, instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see <code>MaintenanceWindowTaskInvocationParameters</code>.</p>
    /// </note>
    pub fn task_parameters(
        mut self,
        k: impl ::std::convert::Into<::std::string::String>,
        v: crate::types::MaintenanceWindowTaskParameterValueExpression,
    ) -> Self {
        let mut hash_map = self.task_parameters.unwrap_or_default();
        hash_map.insert(k.into(), v);
        self.task_parameters = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>The parameters to pass to the task when it runs.</p> <note>
    /// <p> <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs, instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see <code>MaintenanceWindowTaskInvocationParameters</code>.</p>
    /// </note>
    pub fn set_task_parameters(
        mut self,
        input: ::std::option::Option<::std::collections::HashMap<::std::string::String, crate::types::MaintenanceWindowTaskParameterValueExpression>>,
    ) -> Self {
        self.task_parameters = input;
        self
    }
    /// <p>The parameters to pass to the task when it runs.</p> <note>
    /// <p> <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs, instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see <code>MaintenanceWindowTaskInvocationParameters</code>.</p>
    /// </note>
    pub fn get_task_parameters(
        &self,
    ) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, crate::types::MaintenanceWindowTaskParameterValueExpression>> {
        &self.task_parameters
    }
    /// <p>The parameters to pass to the task when it runs.</p>
    pub fn task_invocation_parameters(mut self, input: crate::types::MaintenanceWindowTaskInvocationParameters) -> Self {
        self.task_invocation_parameters = ::std::option::Option::Some(input);
        self
    }
    /// <p>The parameters to pass to the task when it runs.</p>
    pub fn set_task_invocation_parameters(mut self, input: ::std::option::Option<crate::types::MaintenanceWindowTaskInvocationParameters>) -> Self {
        self.task_invocation_parameters = input;
        self
    }
    /// <p>The parameters to pass to the task when it runs.</p>
    pub fn get_task_invocation_parameters(&self) -> &::std::option::Option<crate::types::MaintenanceWindowTaskInvocationParameters> {
        &self.task_invocation_parameters
    }
    /// <p>The priority of the task when it runs. The lower the number, the higher the priority. Tasks that have the same priority are scheduled in parallel.</p>
    pub fn priority(mut self, input: i32) -> Self {
        self.priority = ::std::option::Option::Some(input);
        self
    }
    /// <p>The priority of the task when it runs. The lower the number, the higher the priority. Tasks that have the same priority are scheduled in parallel.</p>
    pub fn set_priority(mut self, input: ::std::option::Option<i32>) -> Self {
        self.priority = input;
        self
    }
    /// <p>The priority of the task when it runs. The lower the number, the higher the priority. Tasks that have the same priority are scheduled in parallel.</p>
    pub fn get_priority(&self) -> &::std::option::Option<i32> {
        &self.priority
    }
    /// <p>The maximum number of targets allowed to run this task in parallel.</p> <note>
    /// <p>For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of <code>1</code>, which may be reported in the response to this command. This value doesn't affect the running of your task and can be ignored.</p>
    /// </note>
    pub fn max_concurrency(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.max_concurrency = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The maximum number of targets allowed to run this task in parallel.</p> <note>
    /// <p>For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of <code>1</code>, which may be reported in the response to this command. This value doesn't affect the running of your task and can be ignored.</p>
    /// </note>
    pub fn set_max_concurrency(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.max_concurrency = input;
        self
    }
    /// <p>The maximum number of targets allowed to run this task in parallel.</p> <note>
    /// <p>For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of <code>1</code>, which may be reported in the response to this command. This value doesn't affect the running of your task and can be ignored.</p>
    /// </note>
    pub fn get_max_concurrency(&self) -> &::std::option::Option<::std::string::String> {
        &self.max_concurrency
    }
    /// <p>The maximum number of errors allowed before the task stops being scheduled.</p> <note>
    /// <p>For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of <code>1</code>, which may be reported in the response to this command. This value doesn't affect the running of your task and can be ignored.</p>
    /// </note>
    pub fn max_errors(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.max_errors = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The maximum number of errors allowed before the task stops being scheduled.</p> <note>
    /// <p>For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of <code>1</code>, which may be reported in the response to this command. This value doesn't affect the running of your task and can be ignored.</p>
    /// </note>
    pub fn set_max_errors(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.max_errors = input;
        self
    }
    /// <p>The maximum number of errors allowed before the task stops being scheduled.</p> <note>
    /// <p>For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of <code>1</code>, which may be reported in the response to this command. This value doesn't affect the running of your task and can be ignored.</p>
    /// </note>
    pub fn get_max_errors(&self) -> &::std::option::Option<::std::string::String> {
        &self.max_errors
    }
    /// <p>The location in Amazon Simple Storage Service (Amazon S3) where the task results are logged.</p> <note>
    /// <p> <code>LoggingInfo</code> has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see <code>MaintenanceWindowTaskInvocationParameters</code>.</p>
    /// </note>
    pub fn logging_info(mut self, input: crate::types::LoggingInfo) -> Self {
        self.logging_info = ::std::option::Option::Some(input);
        self
    }
    /// <p>The location in Amazon Simple Storage Service (Amazon S3) where the task results are logged.</p> <note>
    /// <p> <code>LoggingInfo</code> has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see <code>MaintenanceWindowTaskInvocationParameters</code>.</p>
    /// </note>
    pub fn set_logging_info(mut self, input: ::std::option::Option<crate::types::LoggingInfo>) -> Self {
        self.logging_info = input;
        self
    }
    /// <p>The location in Amazon Simple Storage Service (Amazon S3) where the task results are logged.</p> <note>
    /// <p> <code>LoggingInfo</code> has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see <code>MaintenanceWindowTaskInvocationParameters</code>.</p>
    /// </note>
    pub fn get_logging_info(&self) -> &::std::option::Option<crate::types::LoggingInfo> {
        &self.logging_info
    }
    /// <p>The retrieved task name.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The retrieved task name.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The retrieved task name.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>The retrieved task description.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The retrieved task description.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>The retrieved task description.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.description
    }
    /// <p>The action to take on tasks when the maintenance window cutoff time is reached. <code>CONTINUE_TASK</code> means that tasks continue to run. For Automation, Lambda, Step Functions tasks, <code>CANCEL_TASK</code> means that currently running task invocations continue, but no new task invocations are started. For Run Command tasks, <code>CANCEL_TASK</code> means the system attempts to stop the task by sending a <code>CancelCommand</code> operation.</p>
    pub fn cutoff_behavior(mut self, input: crate::types::MaintenanceWindowTaskCutoffBehavior) -> Self {
        self.cutoff_behavior = ::std::option::Option::Some(input);
        self
    }
    /// <p>The action to take on tasks when the maintenance window cutoff time is reached. <code>CONTINUE_TASK</code> means that tasks continue to run. For Automation, Lambda, Step Functions tasks, <code>CANCEL_TASK</code> means that currently running task invocations continue, but no new task invocations are started. For Run Command tasks, <code>CANCEL_TASK</code> means the system attempts to stop the task by sending a <code>CancelCommand</code> operation.</p>
    pub fn set_cutoff_behavior(mut self, input: ::std::option::Option<crate::types::MaintenanceWindowTaskCutoffBehavior>) -> Self {
        self.cutoff_behavior = input;
        self
    }
    /// <p>The action to take on tasks when the maintenance window cutoff time is reached. <code>CONTINUE_TASK</code> means that tasks continue to run. For Automation, Lambda, Step Functions tasks, <code>CANCEL_TASK</code> means that currently running task invocations continue, but no new task invocations are started. For Run Command tasks, <code>CANCEL_TASK</code> means the system attempts to stop the task by sending a <code>CancelCommand</code> operation.</p>
    pub fn get_cutoff_behavior(&self) -> &::std::option::Option<crate::types::MaintenanceWindowTaskCutoffBehavior> {
        &self.cutoff_behavior
    }
    /// <p>The details for the CloudWatch alarm you applied to your maintenance window task.</p>
    pub fn alarm_configuration(mut self, input: crate::types::AlarmConfiguration) -> Self {
        self.alarm_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The details for the CloudWatch alarm you applied to your maintenance window task.</p>
    pub fn set_alarm_configuration(mut self, input: ::std::option::Option<crate::types::AlarmConfiguration>) -> Self {
        self.alarm_configuration = input;
        self
    }
    /// <p>The details for the CloudWatch alarm you applied to your maintenance window task.</p>
    pub fn get_alarm_configuration(&self) -> &::std::option::Option<crate::types::AlarmConfiguration> {
        &self.alarm_configuration
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
        self._request_id = Some(request_id.into());
        self
    }

    pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
        self._request_id = request_id;
        self
    }
    /// Consumes the builder and constructs a [`GetMaintenanceWindowTaskOutput`](crate::operation::get_maintenance_window_task::GetMaintenanceWindowTaskOutput).
    pub fn build(self) -> crate::operation::get_maintenance_window_task::GetMaintenanceWindowTaskOutput {
        crate::operation::get_maintenance_window_task::GetMaintenanceWindowTaskOutput {
            window_id: self.window_id,
            window_task_id: self.window_task_id,
            targets: self.targets,
            task_arn: self.task_arn,
            service_role_arn: self.service_role_arn,
            task_type: self.task_type,
            task_parameters: self.task_parameters,
            task_invocation_parameters: self.task_invocation_parameters,
            priority: self.priority.unwrap_or_default(),
            max_concurrency: self.max_concurrency,
            max_errors: self.max_errors,
            logging_info: self.logging_info,
            name: self.name,
            description: self.description,
            cutoff_behavior: self.cutoff_behavior,
            alarm_configuration: self.alarm_configuration,
            _request_id: self._request_id,
        }
    }
}
impl ::std::fmt::Debug for GetMaintenanceWindowTaskOutputBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("GetMaintenanceWindowTaskOutputBuilder");
        formatter.field("window_id", &self.window_id);
        formatter.field("window_task_id", &self.window_task_id);
        formatter.field("targets", &self.targets);
        formatter.field("task_arn", &self.task_arn);
        formatter.field("service_role_arn", &self.service_role_arn);
        formatter.field("task_type", &self.task_type);
        formatter.field("task_parameters", &"*** Sensitive Data Redacted ***");
        formatter.field("task_invocation_parameters", &self.task_invocation_parameters);
        formatter.field("priority", &self.priority);
        formatter.field("max_concurrency", &self.max_concurrency);
        formatter.field("max_errors", &self.max_errors);
        formatter.field("logging_info", &self.logging_info);
        formatter.field("name", &self.name);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("cutoff_behavior", &self.cutoff_behavior);
        formatter.field("alarm_configuration", &self.alarm_configuration);
        formatter.field("_request_id", &self._request_id);
        formatter.finish()
    }
}
