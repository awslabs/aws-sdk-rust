// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Adds or overwrites one or more tags for the specified resource. Tags are metadata that you
/// can assign to your documents, managed instances, maintenance windows, Parameter Store parameters,
/// and patch baselines. Tags enable you to categorize your resources in different ways, for example,
/// by purpose, owner, or environment. Each tag consists of a key and an optional value, both of
/// which you define. For example, you could define a set of tags for your account's managed
/// instances that helps you track each instance's owner and stack level. For example: Key=Owner and
/// Value=DbAdmin, SysAdmin, or Dev. Or Key=Stack and Value=Production, Pre-Production, or
/// Test.</p>
/// <p>Each resource can have a maximum of 50 tags. </p>
/// <p>We recommend that you devise a set of tag keys that meets your needs for each resource type.
/// Using a consistent set of tag keys makes it easier for you to manage your resources. You can
/// search and filter the resources based on the tags you add. Tags don't have any semantic meaning
/// to and are interpreted strictly as a string of characters. </p>
/// <p>For more information about using tags with EC2 instances, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html">Tagging your Amazon EC2 resources</a> in the
/// <i>Amazon EC2 User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct AddTagsToResource {
    _private: (),
}
impl AddTagsToResource {
    /// Creates a new builder-style object to manufacture [`AddTagsToResourceInput`](crate::input::AddTagsToResourceInput)
    pub fn builder() -> crate::input::add_tags_to_resource_input::Builder {
        crate::input::add_tags_to_resource_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::AddTagsToResourceOutput, crate::error::AddTagsToResourceError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::AddTagsToResourceError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::AddTagsToResourceError {
                        kind: crate::error::AddTagsToResourceErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::AddTagsToResourceError::unhandled(e),
                },
                "InvalidResourceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::AddTagsToResourceError {
                        kind: crate::error::AddTagsToResourceErrorKind::InvalidResourceId(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::AddTagsToResourceError::unhandled(e),
                },
                "InvalidResourceType" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::AddTagsToResourceError {
                        kind: crate::error::AddTagsToResourceErrorKind::InvalidResourceType(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::AddTagsToResourceError::unhandled(e),
                },
                "TooManyTagsError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::AddTagsToResourceError {
                        kind: crate::error::AddTagsToResourceErrorKind::TooManyTagsError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::AddTagsToResourceError::unhandled(e),
                },
                "TooManyUpdates" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::AddTagsToResourceError {
                        kind: crate::error::AddTagsToResourceErrorKind::TooManyUpdates(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::AddTagsToResourceError::unhandled(e),
                },
                _ => crate::error::AddTagsToResourceError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::add_tags_to_resource_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for AddTagsToResource {
    type Output =
        Result<crate::output::AddTagsToResourceOutput, crate::error::AddTagsToResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Associates a related resource to a Systems Manager OpsCenter OpsItem. For example, you can
/// associate an Incident Manager incident or analysis with an OpsItem. Incident Manager is a
/// capability of AWS Systems Manager.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct AssociateOpsItemRelatedItem {
    _private: (),
}
impl AssociateOpsItemRelatedItem {
    /// Creates a new builder-style object to manufacture [`AssociateOpsItemRelatedItemInput`](crate::input::AssociateOpsItemRelatedItemInput)
    pub fn builder() -> crate::input::associate_ops_item_related_item_input::Builder {
        crate::input::associate_ops_item_related_item_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::AssociateOpsItemRelatedItemOutput,
        crate::error::AssociateOpsItemRelatedItemError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::AssociateOpsItemRelatedItemError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::AssociateOpsItemRelatedItemError { kind: crate::error::AssociateOpsItemRelatedItemErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::AssociateOpsItemRelatedItemError::unhandled(e)
                }
                "OpsItemInvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::AssociateOpsItemRelatedItemError { kind: crate::error::AssociateOpsItemRelatedItemErrorKind::OpsItemInvalidParameterError(body), meta: generic },
                    Err(e) => crate::error::AssociateOpsItemRelatedItemError::unhandled(e)
                }
                "OpsItemLimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::AssociateOpsItemRelatedItemError { kind: crate::error::AssociateOpsItemRelatedItemErrorKind::OpsItemLimitExceededError(body), meta: generic },
                    Err(e) => crate::error::AssociateOpsItemRelatedItemError::unhandled(e)
                }
                "OpsItemNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::AssociateOpsItemRelatedItemError { kind: crate::error::AssociateOpsItemRelatedItemErrorKind::OpsItemNotFoundError(body), meta: generic },
                    Err(e) => crate::error::AssociateOpsItemRelatedItemError::unhandled(e)
                }
                "OpsItemRelatedItemAlreadyExistsException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::AssociateOpsItemRelatedItemError { kind: crate::error::AssociateOpsItemRelatedItemErrorKind::OpsItemRelatedItemAlreadyExistsError(body), meta: generic },
                    Err(e) => crate::error::AssociateOpsItemRelatedItemError::unhandled(e)
                }
                _ => crate::error::AssociateOpsItemRelatedItemError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::associate_ops_item_related_item_output::Builder::default();
        builder = crate::json_deser::associate_ops_item_related_item_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::AssociateOpsItemRelatedItemError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for AssociateOpsItemRelatedItem {
    type Output = Result<
        crate::output::AssociateOpsItemRelatedItemOutput,
        crate::error::AssociateOpsItemRelatedItemError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Attempts to cancel the command specified by the Command ID. There is no guarantee that the
/// command will be terminated and the underlying process stopped.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct CancelCommand {
    _private: (),
}
impl CancelCommand {
    /// Creates a new builder-style object to manufacture [`CancelCommandInput`](crate::input::CancelCommandInput)
    pub fn builder() -> crate::input::cancel_command_input::Builder {
        crate::input::cancel_command_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::CancelCommandOutput, crate::error::CancelCommandError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CancelCommandError::unhandled(generic)),
            };
            return Err(match error_code {
                "DuplicateInstanceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CancelCommandError {
                        kind: crate::error::CancelCommandErrorKind::DuplicateInstanceId(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CancelCommandError::unhandled(e),
                },
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CancelCommandError {
                        kind: crate::error::CancelCommandErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CancelCommandError::unhandled(e),
                },
                "InvalidCommandId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CancelCommandError {
                        kind: crate::error::CancelCommandErrorKind::InvalidCommandId(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CancelCommandError::unhandled(e),
                },
                "InvalidInstanceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CancelCommandError {
                        kind: crate::error::CancelCommandErrorKind::InvalidInstanceId(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CancelCommandError::unhandled(e),
                },
                _ => crate::error::CancelCommandError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::cancel_command_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CancelCommand {
    type Output = Result<crate::output::CancelCommandOutput, crate::error::CancelCommandError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Stops a maintenance window execution that is already in progress and cancels any tasks in
/// the window that have not already starting running. (Tasks already in progress will continue to
/// completion.)</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct CancelMaintenanceWindowExecution {
    _private: (),
}
impl CancelMaintenanceWindowExecution {
    /// Creates a new builder-style object to manufacture [`CancelMaintenanceWindowExecutionInput`](crate::input::CancelMaintenanceWindowExecutionInput)
    pub fn builder() -> crate::input::cancel_maintenance_window_execution_input::Builder {
        crate::input::cancel_maintenance_window_execution_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::CancelMaintenanceWindowExecutionOutput,
        crate::error::CancelMaintenanceWindowExecutionError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(
                        crate::error::CancelMaintenanceWindowExecutionError::unhandled(generic),
                    )
                }
            };
            return Err(match error_code {
                "DoesNotExistException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CancelMaintenanceWindowExecutionError { kind: crate::error::CancelMaintenanceWindowExecutionErrorKind::DoesNotExistError(body), meta: generic },
                    Err(e) => crate::error::CancelMaintenanceWindowExecutionError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CancelMaintenanceWindowExecutionError { kind: crate::error::CancelMaintenanceWindowExecutionErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::CancelMaintenanceWindowExecutionError::unhandled(e)
                }
                _ => crate::error::CancelMaintenanceWindowExecutionError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::cancel_maintenance_window_execution_output::Builder::default();
        builder = crate::json_deser::cancel_maintenance_window_execution_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::CancelMaintenanceWindowExecutionError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CancelMaintenanceWindowExecution {
    type Output = Result<
        crate::output::CancelMaintenanceWindowExecutionOutput,
        crate::error::CancelMaintenanceWindowExecutionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Generates an activation code and activation ID you can use to register your on-premises
/// server or virtual machine (VM) with Systems Manager. Registering these machines with Systems Manager makes it
/// possible to manage them using Systems Manager capabilities. You use the activation code and ID when
/// installing SSM Agent on machines in your hybrid environment. For more information about
/// requirements for managing on-premises instances and VMs using Systems Manager, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-managedinstances.html">Setting up
/// AWS Systems Manager for hybrid environments</a> in the <i>AWS Systems Manager User Guide</i>. </p>
/// <note>
/// <p>On-premises servers or VMs that are registered with Systems Manager and EC2 instances that you manage
/// with Systems Manager are all called <i>managed instances</i>.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone)]
pub struct CreateActivation {
    _private: (),
}
impl CreateActivation {
    /// Creates a new builder-style object to manufacture [`CreateActivationInput`](crate::input::CreateActivationInput)
    pub fn builder() -> crate::input::create_activation_input::Builder {
        crate::input::create_activation_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::CreateActivationOutput, crate::error::CreateActivationError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CreateActivationError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateActivationError {
                        kind: crate::error::CreateActivationErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateActivationError::unhandled(e),
                },
                _ => crate::error::CreateActivationError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::create_activation_output::Builder::default();
        builder =
            crate::json_deser::create_activation_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::CreateActivationError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CreateActivation {
    type Output =
        Result<crate::output::CreateActivationOutput, crate::error::CreateActivationError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>A State Manager association defines the state that you want to maintain on your instances.
/// For example, an association can specify that anti-virus software must be installed and running on
/// your instances, or that certain ports must be closed. For static targets, the association
/// specifies a schedule for when the configuration is reapplied. For dynamic targets, such as an AWS
/// Resource Group or an AWS Autoscaling Group, State Manager applies the configuration when new
/// instances are added to the group. The association also specifies actions to take when applying
/// the configuration. For example, an association for anti-virus software might run once a day. If
/// the software is not installed, then State Manager installs it. If the software is installed, but
/// the service is not running, then the association might instruct State Manager to start the
/// service. </p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct CreateAssociation {
    _private: (),
}
impl CreateAssociation {
    /// Creates a new builder-style object to manufacture [`CreateAssociationInput`](crate::input::CreateAssociationInput)
    pub fn builder() -> crate::input::create_association_input::Builder {
        crate::input::create_association_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::CreateAssociationOutput, crate::error::CreateAssociationError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CreateAssociationError::unhandled(generic)),
            };
            return Err(match error_code {
                "AssociationAlreadyExists" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateAssociationError {
                        kind: crate::error::CreateAssociationErrorKind::AssociationAlreadyExists(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateAssociationError::unhandled(e),
                },
                "AssociationLimitExceeded" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateAssociationError {
                        kind: crate::error::CreateAssociationErrorKind::AssociationLimitExceeded(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateAssociationError::unhandled(e),
                },
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateAssociationError {
                        kind: crate::error::CreateAssociationErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateAssociationError::unhandled(e),
                },
                "InvalidDocument" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateAssociationError {
                        kind: crate::error::CreateAssociationErrorKind::InvalidDocument(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateAssociationError::unhandled(e),
                },
                "InvalidDocumentVersion" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateAssociationError {
                        kind: crate::error::CreateAssociationErrorKind::InvalidDocumentVersion(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateAssociationError::unhandled(e),
                },
                "InvalidInstanceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateAssociationError {
                        kind: crate::error::CreateAssociationErrorKind::InvalidInstanceId(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateAssociationError::unhandled(e),
                },
                "InvalidOutputLocation" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateAssociationError {
                        kind: crate::error::CreateAssociationErrorKind::InvalidOutputLocation(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateAssociationError::unhandled(e),
                },
                "InvalidParameters" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateAssociationError {
                        kind: crate::error::CreateAssociationErrorKind::InvalidParameters(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateAssociationError::unhandled(e),
                },
                "InvalidSchedule" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateAssociationError {
                        kind: crate::error::CreateAssociationErrorKind::InvalidSchedule(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateAssociationError::unhandled(e),
                },
                "InvalidTarget" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateAssociationError {
                        kind: crate::error::CreateAssociationErrorKind::InvalidTarget(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateAssociationError::unhandled(e),
                },
                "UnsupportedPlatformType" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateAssociationError {
                        kind: crate::error::CreateAssociationErrorKind::UnsupportedPlatformType(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateAssociationError::unhandled(e),
                },
                _ => crate::error::CreateAssociationError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::create_association_output::Builder::default();
        builder = crate::json_deser::create_association_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::CreateAssociationError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CreateAssociation {
    type Output =
        Result<crate::output::CreateAssociationOutput, crate::error::CreateAssociationError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Associates the specified Systems Manager document with the specified instances or targets.</p>
/// <p>When you associate a document with one or more instances using instance IDs or tags,
/// SSM Agent running on the instance processes the document and configures the instance as
/// specified.</p>
/// <p>If you associate a document with an instance that already has an associated document, the
/// system returns the AssociationAlreadyExists exception.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct CreateAssociationBatch {
    _private: (),
}
impl CreateAssociationBatch {
    /// Creates a new builder-style object to manufacture [`CreateAssociationBatchInput`](crate::input::CreateAssociationBatchInput)
    pub fn builder() -> crate::input::create_association_batch_input::Builder {
        crate::input::create_association_batch_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::CreateAssociationBatchOutput,
        crate::error::CreateAssociationBatchError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::CreateAssociationBatchError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "AssociationLimitExceeded" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateAssociationBatchError {
                        kind:
                            crate::error::CreateAssociationBatchErrorKind::AssociationLimitExceeded(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateAssociationBatchError::unhandled(e),
                },
                "DuplicateInstanceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateAssociationBatchError {
                        kind: crate::error::CreateAssociationBatchErrorKind::DuplicateInstanceId(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateAssociationBatchError::unhandled(e),
                },
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateAssociationBatchError {
                        kind: crate::error::CreateAssociationBatchErrorKind::InternalServerError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateAssociationBatchError::unhandled(e),
                },
                "InvalidDocument" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateAssociationBatchError {
                        kind: crate::error::CreateAssociationBatchErrorKind::InvalidDocument(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateAssociationBatchError::unhandled(e),
                },
                "InvalidDocumentVersion" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateAssociationBatchError {
                        kind: crate::error::CreateAssociationBatchErrorKind::InvalidDocumentVersion(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateAssociationBatchError::unhandled(e),
                },
                "InvalidInstanceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateAssociationBatchError {
                        kind: crate::error::CreateAssociationBatchErrorKind::InvalidInstanceId(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateAssociationBatchError::unhandled(e),
                },
                "InvalidOutputLocation" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateAssociationBatchError {
                        kind: crate::error::CreateAssociationBatchErrorKind::InvalidOutputLocation(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateAssociationBatchError::unhandled(e),
                },
                "InvalidParameters" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateAssociationBatchError {
                        kind: crate::error::CreateAssociationBatchErrorKind::InvalidParameters(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateAssociationBatchError::unhandled(e),
                },
                "InvalidSchedule" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateAssociationBatchError {
                        kind: crate::error::CreateAssociationBatchErrorKind::InvalidSchedule(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateAssociationBatchError::unhandled(e),
                },
                "InvalidTarget" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateAssociationBatchError {
                        kind: crate::error::CreateAssociationBatchErrorKind::InvalidTarget(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateAssociationBatchError::unhandled(e),
                },
                "UnsupportedPlatformType" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateAssociationBatchError {
                        kind:
                            crate::error::CreateAssociationBatchErrorKind::UnsupportedPlatformType(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateAssociationBatchError::unhandled(e),
                },
                _ => crate::error::CreateAssociationBatchError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::create_association_batch_output::Builder::default();
        builder = crate::json_deser::create_association_batch_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::CreateAssociationBatchError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CreateAssociationBatch {
    type Output = Result<
        crate::output::CreateAssociationBatchOutput,
        crate::error::CreateAssociationBatchError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates a Systems Manager (SSM) document. An SSM document defines the actions that Systems Manager performs on
/// your managed instances. For more information about SSM documents, including information about
/// supported schemas, features, and syntax, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-ssm-docs.html">AWS Systems Manager Documents</a> in the
/// <i>AWS Systems Manager User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct CreateDocument {
    _private: (),
}
impl CreateDocument {
    /// Creates a new builder-style object to manufacture [`CreateDocumentInput`](crate::input::CreateDocumentInput)
    pub fn builder() -> crate::input::create_document_input::Builder {
        crate::input::create_document_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::CreateDocumentOutput, crate::error::CreateDocumentError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CreateDocumentError::unhandled(generic)),
            };
            return Err(match error_code {
                "DocumentAlreadyExists" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateDocumentError {
                        kind: crate::error::CreateDocumentErrorKind::DocumentAlreadyExists(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateDocumentError::unhandled(e),
                },
                "DocumentLimitExceeded" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateDocumentError {
                        kind: crate::error::CreateDocumentErrorKind::DocumentLimitExceeded(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateDocumentError::unhandled(e),
                },
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateDocumentError {
                        kind: crate::error::CreateDocumentErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateDocumentError::unhandled(e),
                },
                "InvalidDocumentContent" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateDocumentError {
                        kind: crate::error::CreateDocumentErrorKind::InvalidDocumentContent(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateDocumentError::unhandled(e),
                },
                "InvalidDocumentSchemaVersion" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateDocumentError {
                        kind: crate::error::CreateDocumentErrorKind::InvalidDocumentSchemaVersion(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateDocumentError::unhandled(e),
                },
                "MaxDocumentSizeExceeded" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateDocumentError {
                        kind: crate::error::CreateDocumentErrorKind::MaxDocumentSizeExceeded(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateDocumentError::unhandled(e),
                },
                _ => crate::error::CreateDocumentError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::create_document_output::Builder::default();
        builder =
            crate::json_deser::create_document_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::CreateDocumentError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CreateDocument {
    type Output = Result<crate::output::CreateDocumentOutput, crate::error::CreateDocumentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates a new maintenance window.</p>
/// <note>
/// <p>The value you specify for <code>Duration</code> determines the specific end time for the
/// maintenance window based on the time it begins. No maintenance window tasks are permitted to
/// start after the resulting endtime minus the number of hours you specify for <code>Cutoff</code>.
/// For example, if the maintenance window starts at 3 PM, the duration is three hours, and the
/// value you specify for <code>Cutoff</code> is one hour, no maintenance window tasks can start
/// after 5 PM.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone)]
pub struct CreateMaintenanceWindow {
    _private: (),
}
impl CreateMaintenanceWindow {
    /// Creates a new builder-style object to manufacture [`CreateMaintenanceWindowInput`](crate::input::CreateMaintenanceWindowInput)
    pub fn builder() -> crate::input::create_maintenance_window_input::Builder {
        crate::input::create_maintenance_window_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::CreateMaintenanceWindowOutput,
        crate::error::CreateMaintenanceWindowError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::CreateMaintenanceWindowError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "IdempotentParameterMismatch" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateMaintenanceWindowError { kind: crate::error::CreateMaintenanceWindowErrorKind::IdempotentParameterMismatch(body), meta: generic },
                    Err(e) => crate::error::CreateMaintenanceWindowError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateMaintenanceWindowError { kind: crate::error::CreateMaintenanceWindowErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::CreateMaintenanceWindowError::unhandled(e)
                }
                "ResourceLimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateMaintenanceWindowError { kind: crate::error::CreateMaintenanceWindowErrorKind::ResourceLimitExceededError(body), meta: generic },
                    Err(e) => crate::error::CreateMaintenanceWindowError::unhandled(e)
                }
                _ => crate::error::CreateMaintenanceWindowError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::create_maintenance_window_output::Builder::default();
        builder = crate::json_deser::create_maintenance_window_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::CreateMaintenanceWindowError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CreateMaintenanceWindow {
    type Output = Result<
        crate::output::CreateMaintenanceWindowOutput,
        crate::error::CreateMaintenanceWindowError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates a new OpsItem. You must have permission in AWS Identity and Access Management (IAM)
/// to create a new OpsItem. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-getting-started.html">Getting started with
/// OpsCenter</a> in the <i>AWS Systems Manager User Guide</i>.</p>
/// <p>Operations engineers and IT professionals use OpsCenter to view, investigate, and remediate
/// operational issues impacting the performance and health of their AWS resources. For more
/// information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter.html">AWS Systems Manager OpsCenter</a> in the
/// <i>AWS Systems Manager User Guide</i>. </p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct CreateOpsItem {
    _private: (),
}
impl CreateOpsItem {
    /// Creates a new builder-style object to manufacture [`CreateOpsItemInput`](crate::input::CreateOpsItemInput)
    pub fn builder() -> crate::input::create_ops_item_input::Builder {
        crate::input::create_ops_item_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::CreateOpsItemOutput, crate::error::CreateOpsItemError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CreateOpsItemError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateOpsItemError {
                        kind: crate::error::CreateOpsItemErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateOpsItemError::unhandled(e),
                },
                "OpsItemAlreadyExistsException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateOpsItemError {
                        kind: crate::error::CreateOpsItemErrorKind::OpsItemAlreadyExistsError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateOpsItemError::unhandled(e),
                },
                "OpsItemInvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateOpsItemError {
                        kind: crate::error::CreateOpsItemErrorKind::OpsItemInvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateOpsItemError::unhandled(e),
                },
                "OpsItemLimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateOpsItemError {
                        kind: crate::error::CreateOpsItemErrorKind::OpsItemLimitExceededError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateOpsItemError::unhandled(e),
                },
                _ => crate::error::CreateOpsItemError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::create_ops_item_output::Builder::default();
        builder =
            crate::json_deser::create_ops_item_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::CreateOpsItemError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CreateOpsItem {
    type Output = Result<crate::output::CreateOpsItemOutput, crate::error::CreateOpsItemError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>If you create a new application in Application Manager, Systems Manager calls this API action to specify
/// information about the new application, including the application type.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct CreateOpsMetadata {
    _private: (),
}
impl CreateOpsMetadata {
    /// Creates a new builder-style object to manufacture [`CreateOpsMetadataInput`](crate::input::CreateOpsMetadataInput)
    pub fn builder() -> crate::input::create_ops_metadata_input::Builder {
        crate::input::create_ops_metadata_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::CreateOpsMetadataOutput, crate::error::CreateOpsMetadataError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CreateOpsMetadataError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateOpsMetadataError { kind: crate::error::CreateOpsMetadataErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::CreateOpsMetadataError::unhandled(e)
                }
                "OpsMetadataAlreadyExistsException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateOpsMetadataError { kind: crate::error::CreateOpsMetadataErrorKind::OpsMetadataAlreadyExistsError(body), meta: generic },
                    Err(e) => crate::error::CreateOpsMetadataError::unhandled(e)
                }
                "OpsMetadataInvalidArgumentException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateOpsMetadataError { kind: crate::error::CreateOpsMetadataErrorKind::OpsMetadataInvalidArgumentError(body), meta: generic },
                    Err(e) => crate::error::CreateOpsMetadataError::unhandled(e)
                }
                "OpsMetadataLimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateOpsMetadataError { kind: crate::error::CreateOpsMetadataErrorKind::OpsMetadataLimitExceededError(body), meta: generic },
                    Err(e) => crate::error::CreateOpsMetadataError::unhandled(e)
                }
                "OpsMetadataTooManyUpdatesException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateOpsMetadataError { kind: crate::error::CreateOpsMetadataErrorKind::OpsMetadataTooManyUpdatesError(body), meta: generic },
                    Err(e) => crate::error::CreateOpsMetadataError::unhandled(e)
                }
                _ => crate::error::CreateOpsMetadataError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::create_ops_metadata_output::Builder::default();
        builder = crate::json_deser::create_ops_metadata_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::CreateOpsMetadataError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CreateOpsMetadata {
    type Output =
        Result<crate::output::CreateOpsMetadataOutput, crate::error::CreateOpsMetadataError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates a patch baseline.</p>
/// <note>
/// <p>For information about valid key and value pairs in <code>PatchFilters</code> for each
/// supported operating system type, see <a href="http://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html">PatchFilter</a>.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone)]
pub struct CreatePatchBaseline {
    _private: (),
}
impl CreatePatchBaseline {
    /// Creates a new builder-style object to manufacture [`CreatePatchBaselineInput`](crate::input::CreatePatchBaselineInput)
    pub fn builder() -> crate::input::create_patch_baseline_input::Builder {
        crate::input::create_patch_baseline_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::CreatePatchBaselineOutput, crate::error::CreatePatchBaselineError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CreatePatchBaselineError::unhandled(generic)),
            };
            return Err(match error_code {
                "IdempotentParameterMismatch" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreatePatchBaselineError {
                        kind:
                            crate::error::CreatePatchBaselineErrorKind::IdempotentParameterMismatch(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreatePatchBaselineError::unhandled(e),
                },
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreatePatchBaselineError {
                        kind: crate::error::CreatePatchBaselineErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreatePatchBaselineError::unhandled(e),
                },
                "ResourceLimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreatePatchBaselineError {
                        kind:
                            crate::error::CreatePatchBaselineErrorKind::ResourceLimitExceededError(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreatePatchBaselineError::unhandled(e),
                },
                _ => crate::error::CreatePatchBaselineError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::create_patch_baseline_output::Builder::default();
        builder = crate::json_deser::create_patch_baseline_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::CreatePatchBaselineError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CreatePatchBaseline {
    type Output =
        Result<crate::output::CreatePatchBaselineOutput, crate::error::CreatePatchBaselineError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>A resource data sync helps you view data from multiple sources in a single location. Systems
/// Manager offers two types of resource data sync: <code>SyncToDestination</code> and
/// <code>SyncFromSource</code>.</p>
/// <p>You can configure Systems Manager Inventory to use the <code>SyncToDestination</code> type to
/// synchronize Inventory data from multiple AWS Regions to a single S3 bucket. For more information,
/// see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-inventory-datasync.html">Configuring Resource Data
/// Sync for Inventory</a> in the <i>AWS Systems Manager User Guide</i>.</p>
/// <p>You can configure Systems Manager Explorer to use the <code>SyncFromSource</code> type to synchronize
/// operational work items (OpsItems) and operational data (OpsData) from multiple AWS Regions to a
/// single S3 bucket. This type can synchronize OpsItems and OpsData from multiple AWS accounts and
/// Regions or <code>EntireOrganization</code> by using AWS Organizations. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/Explorer-resource-data-sync.html">Setting up Systems Manager Explorer to display data from multiple accounts and Regions</a> in the
/// <i>AWS Systems Manager User Guide</i>.</p>
/// <p>A resource data sync is an asynchronous operation that returns immediately. After a
/// successful initial sync is completed, the system continuously syncs data. To check the status of
/// a sync, use the <a>ListResourceDataSync</a>.</p>
/// <note>
/// <p>By default, data is not encrypted in Amazon S3. We strongly recommend that you enable encryption
/// in Amazon S3 to ensure secure data storage. We also recommend that you secure access to the Amazon S3
/// bucket by creating a restrictive bucket policy. </p>
/// </note>
#[derive(std::default::Default, std::clone::Clone)]
pub struct CreateResourceDataSync {
    _private: (),
}
impl CreateResourceDataSync {
    /// Creates a new builder-style object to manufacture [`CreateResourceDataSyncInput`](crate::input::CreateResourceDataSyncInput)
    pub fn builder() -> crate::input::create_resource_data_sync_input::Builder {
        crate::input::create_resource_data_sync_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::CreateResourceDataSyncOutput,
        crate::error::CreateResourceDataSyncError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::CreateResourceDataSyncError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateResourceDataSyncError { kind: crate::error::CreateResourceDataSyncErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::CreateResourceDataSyncError::unhandled(e)
                }
                "ResourceDataSyncAlreadyExistsException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateResourceDataSyncError { kind: crate::error::CreateResourceDataSyncErrorKind::ResourceDataSyncAlreadyExistsError(body), meta: generic },
                    Err(e) => crate::error::CreateResourceDataSyncError::unhandled(e)
                }
                "ResourceDataSyncCountExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateResourceDataSyncError { kind: crate::error::CreateResourceDataSyncErrorKind::ResourceDataSyncCountExceededError(body), meta: generic },
                    Err(e) => crate::error::CreateResourceDataSyncError::unhandled(e)
                }
                "ResourceDataSyncInvalidConfigurationException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateResourceDataSyncError { kind: crate::error::CreateResourceDataSyncErrorKind::ResourceDataSyncInvalidConfigurationError(body), meta: generic },
                    Err(e) => crate::error::CreateResourceDataSyncError::unhandled(e)
                }
                _ => crate::error::CreateResourceDataSyncError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::create_resource_data_sync_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CreateResourceDataSync {
    type Output = Result<
        crate::output::CreateResourceDataSyncOutput,
        crate::error::CreateResourceDataSyncError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes an activation. You are not required to delete an activation. If you delete an
/// activation, you can no longer use it to register additional managed instances. Deleting an
/// activation does not de-register managed instances. You must manually de-register managed
/// instances.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DeleteActivation {
    _private: (),
}
impl DeleteActivation {
    /// Creates a new builder-style object to manufacture [`DeleteActivationInput`](crate::input::DeleteActivationInput)
    pub fn builder() -> crate::input::delete_activation_input::Builder {
        crate::input::delete_activation_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::DeleteActivationOutput, crate::error::DeleteActivationError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteActivationError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteActivationError {
                        kind: crate::error::DeleteActivationErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteActivationError::unhandled(e),
                },
                "InvalidActivation" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteActivationError {
                        kind: crate::error::DeleteActivationErrorKind::InvalidActivation(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteActivationError::unhandled(e),
                },
                "InvalidActivationId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteActivationError {
                        kind: crate::error::DeleteActivationErrorKind::InvalidActivationId(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteActivationError::unhandled(e),
                },
                "TooManyUpdates" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteActivationError {
                        kind: crate::error::DeleteActivationErrorKind::TooManyUpdates(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteActivationError::unhandled(e),
                },
                _ => crate::error::DeleteActivationError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::delete_activation_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteActivation {
    type Output =
        Result<crate::output::DeleteActivationOutput, crate::error::DeleteActivationError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Disassociates the specified Systems Manager document from the specified instance.</p>
/// <p>When you disassociate a document from an instance, it does not change the configuration of
/// the instance. To change the configuration state of an instance after you disassociate a document,
/// you must create a new document with the desired configuration and associate it with the
/// instance.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DeleteAssociation {
    _private: (),
}
impl DeleteAssociation {
    /// Creates a new builder-style object to manufacture [`DeleteAssociationInput`](crate::input::DeleteAssociationInput)
    pub fn builder() -> crate::input::delete_association_input::Builder {
        crate::input::delete_association_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::DeleteAssociationOutput, crate::error::DeleteAssociationError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteAssociationError::unhandled(generic)),
            };
            return Err(match error_code {
                "AssociationDoesNotExist" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteAssociationError {
                        kind: crate::error::DeleteAssociationErrorKind::AssociationDoesNotExist(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteAssociationError::unhandled(e),
                },
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteAssociationError {
                        kind: crate::error::DeleteAssociationErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteAssociationError::unhandled(e),
                },
                "InvalidDocument" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteAssociationError {
                        kind: crate::error::DeleteAssociationErrorKind::InvalidDocument(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteAssociationError::unhandled(e),
                },
                "InvalidInstanceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteAssociationError {
                        kind: crate::error::DeleteAssociationErrorKind::InvalidInstanceId(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteAssociationError::unhandled(e),
                },
                "TooManyUpdates" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteAssociationError {
                        kind: crate::error::DeleteAssociationErrorKind::TooManyUpdates(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteAssociationError::unhandled(e),
                },
                _ => crate::error::DeleteAssociationError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::delete_association_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteAssociation {
    type Output =
        Result<crate::output::DeleteAssociationOutput, crate::error::DeleteAssociationError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes the Systems Manager document and all instance associations to the document.</p>
/// <p>Before you delete the document, we recommend that you use <a>DeleteAssociation</a> to disassociate all instances that are associated with the document.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DeleteDocument {
    _private: (),
}
impl DeleteDocument {
    /// Creates a new builder-style object to manufacture [`DeleteDocumentInput`](crate::input::DeleteDocumentInput)
    pub fn builder() -> crate::input::delete_document_input::Builder {
        crate::input::delete_document_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::DeleteDocumentOutput, crate::error::DeleteDocumentError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteDocumentError::unhandled(generic)),
            };
            return Err(match error_code {
                "AssociatedInstances" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteDocumentError {
                        kind: crate::error::DeleteDocumentErrorKind::AssociatedInstances(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteDocumentError::unhandled(e),
                },
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteDocumentError {
                        kind: crate::error::DeleteDocumentErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteDocumentError::unhandled(e),
                },
                "InvalidDocument" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteDocumentError {
                        kind: crate::error::DeleteDocumentErrorKind::InvalidDocument(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteDocumentError::unhandled(e),
                },
                "InvalidDocumentOperation" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteDocumentError {
                        kind: crate::error::DeleteDocumentErrorKind::InvalidDocumentOperation(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteDocumentError::unhandled(e),
                },
                _ => crate::error::DeleteDocumentError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::delete_document_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteDocument {
    type Output = Result<crate::output::DeleteDocumentOutput, crate::error::DeleteDocumentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Delete a custom inventory type or the data associated with a custom Inventory type. Deleting
/// a custom inventory type is also referred to as deleting a custom inventory schema.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DeleteInventory {
    _private: (),
}
impl DeleteInventory {
    /// Creates a new builder-style object to manufacture [`DeleteInventoryInput`](crate::input::DeleteInventoryInput)
    pub fn builder() -> crate::input::delete_inventory_input::Builder {
        crate::input::delete_inventory_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::DeleteInventoryOutput, crate::error::DeleteInventoryError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteInventoryError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteInventoryError { kind: crate::error::DeleteInventoryErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::DeleteInventoryError::unhandled(e)
                }
                "InvalidDeleteInventoryParametersException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteInventoryError { kind: crate::error::DeleteInventoryErrorKind::InvalidDeleteInventoryParametersError(body), meta: generic },
                    Err(e) => crate::error::DeleteInventoryError::unhandled(e)
                }
                "InvalidInventoryRequestException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteInventoryError { kind: crate::error::DeleteInventoryErrorKind::InvalidInventoryRequestError(body), meta: generic },
                    Err(e) => crate::error::DeleteInventoryError::unhandled(e)
                }
                "InvalidOptionException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteInventoryError { kind: crate::error::DeleteInventoryErrorKind::InvalidOptionError(body), meta: generic },
                    Err(e) => crate::error::DeleteInventoryError::unhandled(e)
                }
                "InvalidTypeNameException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteInventoryError { kind: crate::error::DeleteInventoryErrorKind::InvalidTypeNameError(body), meta: generic },
                    Err(e) => crate::error::DeleteInventoryError::unhandled(e)
                }
                _ => crate::error::DeleteInventoryError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::delete_inventory_output::Builder::default();
        builder =
            crate::json_deser::delete_inventory_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::DeleteInventoryError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteInventory {
    type Output = Result<crate::output::DeleteInventoryOutput, crate::error::DeleteInventoryError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes a maintenance window.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DeleteMaintenanceWindow {
    _private: (),
}
impl DeleteMaintenanceWindow {
    /// Creates a new builder-style object to manufacture [`DeleteMaintenanceWindowInput`](crate::input::DeleteMaintenanceWindowInput)
    pub fn builder() -> crate::input::delete_maintenance_window_input::Builder {
        crate::input::delete_maintenance_window_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DeleteMaintenanceWindowOutput,
        crate::error::DeleteMaintenanceWindowError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DeleteMaintenanceWindowError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteMaintenanceWindowError {
                        kind: crate::error::DeleteMaintenanceWindowErrorKind::InternalServerError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteMaintenanceWindowError::unhandled(e),
                },
                _ => crate::error::DeleteMaintenanceWindowError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::delete_maintenance_window_output::Builder::default();
        builder = crate::json_deser::delete_maintenance_window_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DeleteMaintenanceWindowError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteMaintenanceWindow {
    type Output = Result<
        crate::output::DeleteMaintenanceWindowOutput,
        crate::error::DeleteMaintenanceWindowError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Delete OpsMetadata related to an application.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DeleteOpsMetadata {
    _private: (),
}
impl DeleteOpsMetadata {
    /// Creates a new builder-style object to manufacture [`DeleteOpsMetadataInput`](crate::input::DeleteOpsMetadataInput)
    pub fn builder() -> crate::input::delete_ops_metadata_input::Builder {
        crate::input::delete_ops_metadata_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::DeleteOpsMetadataOutput, crate::error::DeleteOpsMetadataError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteOpsMetadataError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteOpsMetadataError { kind: crate::error::DeleteOpsMetadataErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::DeleteOpsMetadataError::unhandled(e)
                }
                "OpsMetadataInvalidArgumentException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteOpsMetadataError { kind: crate::error::DeleteOpsMetadataErrorKind::OpsMetadataInvalidArgumentError(body), meta: generic },
                    Err(e) => crate::error::DeleteOpsMetadataError::unhandled(e)
                }
                "OpsMetadataNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteOpsMetadataError { kind: crate::error::DeleteOpsMetadataErrorKind::OpsMetadataNotFoundError(body), meta: generic },
                    Err(e) => crate::error::DeleteOpsMetadataError::unhandled(e)
                }
                _ => crate::error::DeleteOpsMetadataError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::delete_ops_metadata_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteOpsMetadata {
    type Output =
        Result<crate::output::DeleteOpsMetadataOutput, crate::error::DeleteOpsMetadataError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Delete a parameter from the system.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DeleteParameter {
    _private: (),
}
impl DeleteParameter {
    /// Creates a new builder-style object to manufacture [`DeleteParameterInput`](crate::input::DeleteParameterInput)
    pub fn builder() -> crate::input::delete_parameter_input::Builder {
        crate::input::delete_parameter_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::DeleteParameterOutput, crate::error::DeleteParameterError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteParameterError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteParameterError {
                        kind: crate::error::DeleteParameterErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteParameterError::unhandled(e),
                },
                "ParameterNotFound" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteParameterError {
                        kind: crate::error::DeleteParameterErrorKind::ParameterNotFound(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteParameterError::unhandled(e),
                },
                _ => crate::error::DeleteParameterError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::delete_parameter_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteParameter {
    type Output = Result<crate::output::DeleteParameterOutput, crate::error::DeleteParameterError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Delete a list of parameters.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DeleteParameters {
    _private: (),
}
impl DeleteParameters {
    /// Creates a new builder-style object to manufacture [`DeleteParametersInput`](crate::input::DeleteParametersInput)
    pub fn builder() -> crate::input::delete_parameters_input::Builder {
        crate::input::delete_parameters_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::DeleteParametersOutput, crate::error::DeleteParametersError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteParametersError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteParametersError {
                        kind: crate::error::DeleteParametersErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteParametersError::unhandled(e),
                },
                _ => crate::error::DeleteParametersError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::delete_parameters_output::Builder::default();
        builder =
            crate::json_deser::delete_parameters_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::DeleteParametersError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteParameters {
    type Output =
        Result<crate::output::DeleteParametersOutput, crate::error::DeleteParametersError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes a patch baseline.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DeletePatchBaseline {
    _private: (),
}
impl DeletePatchBaseline {
    /// Creates a new builder-style object to manufacture [`DeletePatchBaselineInput`](crate::input::DeletePatchBaselineInput)
    pub fn builder() -> crate::input::delete_patch_baseline_input::Builder {
        crate::input::delete_patch_baseline_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::DeletePatchBaselineOutput, crate::error::DeletePatchBaselineError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeletePatchBaselineError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeletePatchBaselineError {
                        kind: crate::error::DeletePatchBaselineErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeletePatchBaselineError::unhandled(e),
                },
                "ResourceInUseException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeletePatchBaselineError {
                        kind: crate::error::DeletePatchBaselineErrorKind::ResourceInUseError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeletePatchBaselineError::unhandled(e),
                },
                _ => crate::error::DeletePatchBaselineError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::delete_patch_baseline_output::Builder::default();
        builder = crate::json_deser::delete_patch_baseline_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DeletePatchBaselineError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeletePatchBaseline {
    type Output =
        Result<crate::output::DeletePatchBaselineOutput, crate::error::DeletePatchBaselineError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes a Resource Data Sync configuration. After the configuration is deleted, changes to
/// data on managed instances are no longer synced to or from the target. Deleting a sync
/// configuration does not delete data.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DeleteResourceDataSync {
    _private: (),
}
impl DeleteResourceDataSync {
    /// Creates a new builder-style object to manufacture [`DeleteResourceDataSyncInput`](crate::input::DeleteResourceDataSyncInput)
    pub fn builder() -> crate::input::delete_resource_data_sync_input::Builder {
        crate::input::delete_resource_data_sync_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DeleteResourceDataSyncOutput,
        crate::error::DeleteResourceDataSyncError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DeleteResourceDataSyncError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteResourceDataSyncError { kind: crate::error::DeleteResourceDataSyncErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::DeleteResourceDataSyncError::unhandled(e)
                }
                "ResourceDataSyncInvalidConfigurationException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteResourceDataSyncError { kind: crate::error::DeleteResourceDataSyncErrorKind::ResourceDataSyncInvalidConfigurationError(body), meta: generic },
                    Err(e) => crate::error::DeleteResourceDataSyncError::unhandled(e)
                }
                "ResourceDataSyncNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteResourceDataSyncError { kind: crate::error::DeleteResourceDataSyncErrorKind::ResourceDataSyncNotFoundError(body), meta: generic },
                    Err(e) => crate::error::DeleteResourceDataSyncError::unhandled(e)
                }
                _ => crate::error::DeleteResourceDataSyncError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::delete_resource_data_sync_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteResourceDataSync {
    type Output = Result<
        crate::output::DeleteResourceDataSyncOutput,
        crate::error::DeleteResourceDataSyncError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Removes the server or virtual machine from the list of registered servers. You can
/// reregister the instance again at any time. If you don't plan to use Run Command on the server, we
/// suggest uninstalling SSM Agent first.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DeregisterManagedInstance {
    _private: (),
}
impl DeregisterManagedInstance {
    /// Creates a new builder-style object to manufacture [`DeregisterManagedInstanceInput`](crate::input::DeregisterManagedInstanceInput)
    pub fn builder() -> crate::input::deregister_managed_instance_input::Builder {
        crate::input::deregister_managed_instance_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DeregisterManagedInstanceOutput,
        crate::error::DeregisterManagedInstanceError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DeregisterManagedInstanceError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeregisterManagedInstanceError {
                        kind: crate::error::DeregisterManagedInstanceErrorKind::InternalServerError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeregisterManagedInstanceError::unhandled(e),
                },
                "InvalidInstanceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeregisterManagedInstanceError {
                        kind: crate::error::DeregisterManagedInstanceErrorKind::InvalidInstanceId(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeregisterManagedInstanceError::unhandled(e),
                },
                _ => crate::error::DeregisterManagedInstanceError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::deregister_managed_instance_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeregisterManagedInstance {
    type Output = Result<
        crate::output::DeregisterManagedInstanceOutput,
        crate::error::DeregisterManagedInstanceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Removes a patch group from a patch baseline.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DeregisterPatchBaselineForPatchGroup {
    _private: (),
}
impl DeregisterPatchBaselineForPatchGroup {
    /// Creates a new builder-style object to manufacture [`DeregisterPatchBaselineForPatchGroupInput`](crate::input::DeregisterPatchBaselineForPatchGroupInput)
    pub fn builder() -> crate::input::deregister_patch_baseline_for_patch_group_input::Builder {
        crate::input::deregister_patch_baseline_for_patch_group_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DeregisterPatchBaselineForPatchGroupOutput,
        crate::error::DeregisterPatchBaselineForPatchGroupError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(
                        crate::error::DeregisterPatchBaselineForPatchGroupError::unhandled(generic),
                    )
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeregisterPatchBaselineForPatchGroupError { kind: crate::error::DeregisterPatchBaselineForPatchGroupErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::DeregisterPatchBaselineForPatchGroupError::unhandled(e)
                }
                "InvalidResourceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeregisterPatchBaselineForPatchGroupError { kind: crate::error::DeregisterPatchBaselineForPatchGroupErrorKind::InvalidResourceId(body), meta: generic },
                    Err(e) => crate::error::DeregisterPatchBaselineForPatchGroupError::unhandled(e)
                }
                _ => crate::error::DeregisterPatchBaselineForPatchGroupError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::deregister_patch_baseline_for_patch_group_output::Builder::default();
        builder = crate::json_deser::deregister_patch_baseline_for_patch_group_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DeregisterPatchBaselineForPatchGroupError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeregisterPatchBaselineForPatchGroup {
    type Output = Result<
        crate::output::DeregisterPatchBaselineForPatchGroupOutput,
        crate::error::DeregisterPatchBaselineForPatchGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Removes a target from a maintenance window.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DeregisterTargetFromMaintenanceWindow {
    _private: (),
}
impl DeregisterTargetFromMaintenanceWindow {
    /// Creates a new builder-style object to manufacture [`DeregisterTargetFromMaintenanceWindowInput`](crate::input::DeregisterTargetFromMaintenanceWindowInput)
    pub fn builder() -> crate::input::deregister_target_from_maintenance_window_input::Builder {
        crate::input::deregister_target_from_maintenance_window_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DeregisterTargetFromMaintenanceWindowOutput,
        crate::error::DeregisterTargetFromMaintenanceWindowError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(
                        crate::error::DeregisterTargetFromMaintenanceWindowError::unhandled(
                            generic,
                        ),
                    )
                }
            };
            return Err(match error_code {
                "DoesNotExistException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeregisterTargetFromMaintenanceWindowError { kind: crate::error::DeregisterTargetFromMaintenanceWindowErrorKind::DoesNotExistError(body), meta: generic },
                    Err(e) => crate::error::DeregisterTargetFromMaintenanceWindowError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeregisterTargetFromMaintenanceWindowError { kind: crate::error::DeregisterTargetFromMaintenanceWindowErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::DeregisterTargetFromMaintenanceWindowError::unhandled(e)
                }
                "TargetInUseException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeregisterTargetFromMaintenanceWindowError { kind: crate::error::DeregisterTargetFromMaintenanceWindowErrorKind::TargetInUseError(body), meta: generic },
                    Err(e) => crate::error::DeregisterTargetFromMaintenanceWindowError::unhandled(e)
                }
                _ => crate::error::DeregisterTargetFromMaintenanceWindowError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::deregister_target_from_maintenance_window_output::Builder::default();
        builder = crate::json_deser::deregister_target_from_maintenance_window_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DeregisterTargetFromMaintenanceWindowError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeregisterTargetFromMaintenanceWindow {
    type Output = Result<
        crate::output::DeregisterTargetFromMaintenanceWindowOutput,
        crate::error::DeregisterTargetFromMaintenanceWindowError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Removes a task from a maintenance window.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DeregisterTaskFromMaintenanceWindow {
    _private: (),
}
impl DeregisterTaskFromMaintenanceWindow {
    /// Creates a new builder-style object to manufacture [`DeregisterTaskFromMaintenanceWindowInput`](crate::input::DeregisterTaskFromMaintenanceWindowInput)
    pub fn builder() -> crate::input::deregister_task_from_maintenance_window_input::Builder {
        crate::input::deregister_task_from_maintenance_window_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DeregisterTaskFromMaintenanceWindowOutput,
        crate::error::DeregisterTaskFromMaintenanceWindowError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(
                        crate::error::DeregisterTaskFromMaintenanceWindowError::unhandled(generic),
                    )
                }
            };
            return Err(match error_code {
                "DoesNotExistException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeregisterTaskFromMaintenanceWindowError { kind: crate::error::DeregisterTaskFromMaintenanceWindowErrorKind::DoesNotExistError(body), meta: generic },
                    Err(e) => crate::error::DeregisterTaskFromMaintenanceWindowError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeregisterTaskFromMaintenanceWindowError { kind: crate::error::DeregisterTaskFromMaintenanceWindowErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::DeregisterTaskFromMaintenanceWindowError::unhandled(e)
                }
                _ => crate::error::DeregisterTaskFromMaintenanceWindowError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::deregister_task_from_maintenance_window_output::Builder::default();
        builder = crate::json_deser::deregister_task_from_maintenance_window_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DeregisterTaskFromMaintenanceWindowError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeregisterTaskFromMaintenanceWindow {
    type Output = Result<
        crate::output::DeregisterTaskFromMaintenanceWindowOutput,
        crate::error::DeregisterTaskFromMaintenanceWindowError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Describes details about the activation, such as the date and time the activation was
/// created, its expiration date, the IAM role assigned to the instances in the activation, and the
/// number of instances registered by using this activation.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeActivations {
    _private: (),
}
impl DescribeActivations {
    /// Creates a new builder-style object to manufacture [`DescribeActivationsInput`](crate::input::DescribeActivationsInput)
    pub fn builder() -> crate::input::describe_activations_input::Builder {
        crate::input::describe_activations_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::DescribeActivationsOutput, crate::error::DescribeActivationsError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DescribeActivationsError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeActivationsError {
                        kind: crate::error::DescribeActivationsErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeActivationsError::unhandled(e),
                },
                "InvalidFilter" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeActivationsError {
                        kind: crate::error::DescribeActivationsErrorKind::InvalidFilter(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeActivationsError::unhandled(e),
                },
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeActivationsError {
                        kind: crate::error::DescribeActivationsErrorKind::InvalidNextToken(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeActivationsError::unhandled(e),
                },
                _ => crate::error::DescribeActivationsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_activations_output::Builder::default();
        builder = crate::json_deser::describe_activations_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeActivationsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeActivations {
    type Output =
        Result<crate::output::DescribeActivationsOutput, crate::error::DescribeActivationsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Describes the association for the specified target or instance. If you created the
/// association by using the <code>Targets</code> parameter, then you must retrieve the association
/// by using the association ID. If you created the association by specifying an instance ID and a
/// Systems Manager document, then you retrieve the association by specifying the document name and the
/// instance ID. </p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeAssociation {
    _private: (),
}
impl DescribeAssociation {
    /// Creates a new builder-style object to manufacture [`DescribeAssociationInput`](crate::input::DescribeAssociationInput)
    pub fn builder() -> crate::input::describe_association_input::Builder {
        crate::input::describe_association_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::DescribeAssociationOutput, crate::error::DescribeAssociationError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DescribeAssociationError::unhandled(generic)),
            };
            return Err(match error_code {
                "AssociationDoesNotExist" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeAssociationError {
                        kind: crate::error::DescribeAssociationErrorKind::AssociationDoesNotExist(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeAssociationError::unhandled(e),
                },
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeAssociationError {
                        kind: crate::error::DescribeAssociationErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeAssociationError::unhandled(e),
                },
                "InvalidAssociationVersion" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeAssociationError {
                        kind: crate::error::DescribeAssociationErrorKind::InvalidAssociationVersion(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeAssociationError::unhandled(e),
                },
                "InvalidDocument" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeAssociationError {
                        kind: crate::error::DescribeAssociationErrorKind::InvalidDocument(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeAssociationError::unhandled(e),
                },
                "InvalidInstanceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeAssociationError {
                        kind: crate::error::DescribeAssociationErrorKind::InvalidInstanceId(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeAssociationError::unhandled(e),
                },
                _ => crate::error::DescribeAssociationError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_association_output::Builder::default();
        builder = crate::json_deser::describe_association_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeAssociationError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeAssociation {
    type Output =
        Result<crate::output::DescribeAssociationOutput, crate::error::DescribeAssociationError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Use this API action to view all executions for a specific association ID. </p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeAssociationExecutions {
    _private: (),
}
impl DescribeAssociationExecutions {
    /// Creates a new builder-style object to manufacture [`DescribeAssociationExecutionsInput`](crate::input::DescribeAssociationExecutionsInput)
    pub fn builder() -> crate::input::describe_association_executions_input::Builder {
        crate::input::describe_association_executions_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribeAssociationExecutionsOutput,
        crate::error::DescribeAssociationExecutionsError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DescribeAssociationExecutionsError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "AssociationDoesNotExist" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeAssociationExecutionsError { kind: crate::error::DescribeAssociationExecutionsErrorKind::AssociationDoesNotExist(body), meta: generic },
                    Err(e) => crate::error::DescribeAssociationExecutionsError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeAssociationExecutionsError { kind: crate::error::DescribeAssociationExecutionsErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::DescribeAssociationExecutionsError::unhandled(e)
                }
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeAssociationExecutionsError { kind: crate::error::DescribeAssociationExecutionsErrorKind::InvalidNextToken(body), meta: generic },
                    Err(e) => crate::error::DescribeAssociationExecutionsError::unhandled(e)
                }
                _ => crate::error::DescribeAssociationExecutionsError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_association_executions_output::Builder::default();
        builder = crate::json_deser::describe_association_executions_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeAssociationExecutionsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeAssociationExecutions {
    type Output = Result<
        crate::output::DescribeAssociationExecutionsOutput,
        crate::error::DescribeAssociationExecutionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Use this API action to view information about a specific execution of a specific
/// association.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeAssociationExecutionTargets {
    _private: (),
}
impl DescribeAssociationExecutionTargets {
    /// Creates a new builder-style object to manufacture [`DescribeAssociationExecutionTargetsInput`](crate::input::DescribeAssociationExecutionTargetsInput)
    pub fn builder() -> crate::input::describe_association_execution_targets_input::Builder {
        crate::input::describe_association_execution_targets_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribeAssociationExecutionTargetsOutput,
        crate::error::DescribeAssociationExecutionTargetsError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(
                        crate::error::DescribeAssociationExecutionTargetsError::unhandled(generic),
                    )
                }
            };
            return Err(match error_code {
                "AssociationDoesNotExist" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeAssociationExecutionTargetsError { kind: crate::error::DescribeAssociationExecutionTargetsErrorKind::AssociationDoesNotExist(body), meta: generic },
                    Err(e) => crate::error::DescribeAssociationExecutionTargetsError::unhandled(e)
                }
                "AssociationExecutionDoesNotExist" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeAssociationExecutionTargetsError { kind: crate::error::DescribeAssociationExecutionTargetsErrorKind::AssociationExecutionDoesNotExist(body), meta: generic },
                    Err(e) => crate::error::DescribeAssociationExecutionTargetsError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeAssociationExecutionTargetsError { kind: crate::error::DescribeAssociationExecutionTargetsErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::DescribeAssociationExecutionTargetsError::unhandled(e)
                }
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeAssociationExecutionTargetsError { kind: crate::error::DescribeAssociationExecutionTargetsErrorKind::InvalidNextToken(body), meta: generic },
                    Err(e) => crate::error::DescribeAssociationExecutionTargetsError::unhandled(e)
                }
                _ => crate::error::DescribeAssociationExecutionTargetsError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::describe_association_execution_targets_output::Builder::default();
        builder = crate::json_deser::describe_association_execution_targets_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeAssociationExecutionTargetsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeAssociationExecutionTargets {
    type Output = Result<
        crate::output::DescribeAssociationExecutionTargetsOutput,
        crate::error::DescribeAssociationExecutionTargetsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Provides details about all active and terminated Automation executions.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeAutomationExecutions {
    _private: (),
}
impl DescribeAutomationExecutions {
    /// Creates a new builder-style object to manufacture [`DescribeAutomationExecutionsInput`](crate::input::DescribeAutomationExecutionsInput)
    pub fn builder() -> crate::input::describe_automation_executions_input::Builder {
        crate::input::describe_automation_executions_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribeAutomationExecutionsOutput,
        crate::error::DescribeAutomationExecutionsError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DescribeAutomationExecutionsError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeAutomationExecutionsError {
                        kind:
                            crate::error::DescribeAutomationExecutionsErrorKind::InternalServerError(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeAutomationExecutionsError::unhandled(e),
                },
                "InvalidFilterKey" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeAutomationExecutionsError {
                        kind: crate::error::DescribeAutomationExecutionsErrorKind::InvalidFilterKey(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeAutomationExecutionsError::unhandled(e),
                },
                "InvalidFilterValue" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeAutomationExecutionsError {
                        kind:
                            crate::error::DescribeAutomationExecutionsErrorKind::InvalidFilterValue(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeAutomationExecutionsError::unhandled(e),
                },
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeAutomationExecutionsError {
                        kind: crate::error::DescribeAutomationExecutionsErrorKind::InvalidNextToken(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeAutomationExecutionsError::unhandled(e),
                },
                _ => crate::error::DescribeAutomationExecutionsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_automation_executions_output::Builder::default();
        builder = crate::json_deser::describe_automation_executions_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeAutomationExecutionsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeAutomationExecutions {
    type Output = Result<
        crate::output::DescribeAutomationExecutionsOutput,
        crate::error::DescribeAutomationExecutionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Information about all active and terminated step executions in an Automation
/// workflow.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeAutomationStepExecutions {
    _private: (),
}
impl DescribeAutomationStepExecutions {
    /// Creates a new builder-style object to manufacture [`DescribeAutomationStepExecutionsInput`](crate::input::DescribeAutomationStepExecutionsInput)
    pub fn builder() -> crate::input::describe_automation_step_executions_input::Builder {
        crate::input::describe_automation_step_executions_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribeAutomationStepExecutionsOutput,
        crate::error::DescribeAutomationStepExecutionsError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(
                        crate::error::DescribeAutomationStepExecutionsError::unhandled(generic),
                    )
                }
            };
            return Err(match error_code {
                "AutomationExecutionNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeAutomationStepExecutionsError { kind: crate::error::DescribeAutomationStepExecutionsErrorKind::AutomationExecutionNotFoundError(body), meta: generic },
                    Err(e) => crate::error::DescribeAutomationStepExecutionsError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeAutomationStepExecutionsError { kind: crate::error::DescribeAutomationStepExecutionsErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::DescribeAutomationStepExecutionsError::unhandled(e)
                }
                "InvalidFilterKey" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeAutomationStepExecutionsError { kind: crate::error::DescribeAutomationStepExecutionsErrorKind::InvalidFilterKey(body), meta: generic },
                    Err(e) => crate::error::DescribeAutomationStepExecutionsError::unhandled(e)
                }
                "InvalidFilterValue" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeAutomationStepExecutionsError { kind: crate::error::DescribeAutomationStepExecutionsErrorKind::InvalidFilterValue(body), meta: generic },
                    Err(e) => crate::error::DescribeAutomationStepExecutionsError::unhandled(e)
                }
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeAutomationStepExecutionsError { kind: crate::error::DescribeAutomationStepExecutionsErrorKind::InvalidNextToken(body), meta: generic },
                    Err(e) => crate::error::DescribeAutomationStepExecutionsError::unhandled(e)
                }
                _ => crate::error::DescribeAutomationStepExecutionsError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::describe_automation_step_executions_output::Builder::default();
        builder = crate::json_deser::describe_automation_step_executions_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeAutomationStepExecutionsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeAutomationStepExecutions {
    type Output = Result<
        crate::output::DescribeAutomationStepExecutionsOutput,
        crate::error::DescribeAutomationStepExecutionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists all patches eligible to be included in a patch baseline.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeAvailablePatches {
    _private: (),
}
impl DescribeAvailablePatches {
    /// Creates a new builder-style object to manufacture [`DescribeAvailablePatchesInput`](crate::input::DescribeAvailablePatchesInput)
    pub fn builder() -> crate::input::describe_available_patches_input::Builder {
        crate::input::describe_available_patches_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribeAvailablePatchesOutput,
        crate::error::DescribeAvailablePatchesError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DescribeAvailablePatchesError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeAvailablePatchesError {
                        kind: crate::error::DescribeAvailablePatchesErrorKind::InternalServerError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeAvailablePatchesError::unhandled(e),
                },
                _ => crate::error::DescribeAvailablePatchesError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_available_patches_output::Builder::default();
        builder = crate::json_deser::describe_available_patches_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeAvailablePatchesError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeAvailablePatches {
    type Output = Result<
        crate::output::DescribeAvailablePatchesOutput,
        crate::error::DescribeAvailablePatchesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Describes the specified Systems Manager document.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeDocument {
    _private: (),
}
impl DescribeDocument {
    /// Creates a new builder-style object to manufacture [`DescribeDocumentInput`](crate::input::DescribeDocumentInput)
    pub fn builder() -> crate::input::describe_document_input::Builder {
        crate::input::describe_document_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::DescribeDocumentOutput, crate::error::DescribeDocumentError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DescribeDocumentError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeDocumentError {
                        kind: crate::error::DescribeDocumentErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeDocumentError::unhandled(e),
                },
                "InvalidDocument" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeDocumentError {
                        kind: crate::error::DescribeDocumentErrorKind::InvalidDocument(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeDocumentError::unhandled(e),
                },
                "InvalidDocumentVersion" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeDocumentError {
                        kind: crate::error::DescribeDocumentErrorKind::InvalidDocumentVersion(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeDocumentError::unhandled(e),
                },
                _ => crate::error::DescribeDocumentError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_document_output::Builder::default();
        builder =
            crate::json_deser::describe_document_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::DescribeDocumentError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeDocument {
    type Output =
        Result<crate::output::DescribeDocumentOutput, crate::error::DescribeDocumentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Describes the permissions for a Systems Manager document. If you created the document, you are the
/// owner. If a document is shared, it can either be shared privately (by specifying a user's AWS
/// account ID) or publicly (<i>All</i>). </p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeDocumentPermission {
    _private: (),
}
impl DescribeDocumentPermission {
    /// Creates a new builder-style object to manufacture [`DescribeDocumentPermissionInput`](crate::input::DescribeDocumentPermissionInput)
    pub fn builder() -> crate::input::describe_document_permission_input::Builder {
        crate::input::describe_document_permission_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribeDocumentPermissionOutput,
        crate::error::DescribeDocumentPermissionError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DescribeDocumentPermissionError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeDocumentPermissionError { kind: crate::error::DescribeDocumentPermissionErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::DescribeDocumentPermissionError::unhandled(e)
                }
                "InvalidDocument" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeDocumentPermissionError { kind: crate::error::DescribeDocumentPermissionErrorKind::InvalidDocument(body), meta: generic },
                    Err(e) => crate::error::DescribeDocumentPermissionError::unhandled(e)
                }
                "InvalidDocumentOperation" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeDocumentPermissionError { kind: crate::error::DescribeDocumentPermissionErrorKind::InvalidDocumentOperation(body), meta: generic },
                    Err(e) => crate::error::DescribeDocumentPermissionError::unhandled(e)
                }
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeDocumentPermissionError { kind: crate::error::DescribeDocumentPermissionErrorKind::InvalidNextToken(body), meta: generic },
                    Err(e) => crate::error::DescribeDocumentPermissionError::unhandled(e)
                }
                "InvalidPermissionType" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeDocumentPermissionError { kind: crate::error::DescribeDocumentPermissionErrorKind::InvalidPermissionType(body), meta: generic },
                    Err(e) => crate::error::DescribeDocumentPermissionError::unhandled(e)
                }
                _ => crate::error::DescribeDocumentPermissionError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_document_permission_output::Builder::default();
        builder = crate::json_deser::describe_document_permission_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeDocumentPermissionError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeDocumentPermission {
    type Output = Result<
        crate::output::DescribeDocumentPermissionOutput,
        crate::error::DescribeDocumentPermissionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>All associations for the instance(s).</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeEffectiveInstanceAssociations {
    _private: (),
}
impl DescribeEffectiveInstanceAssociations {
    /// Creates a new builder-style object to manufacture [`DescribeEffectiveInstanceAssociationsInput`](crate::input::DescribeEffectiveInstanceAssociationsInput)
    pub fn builder() -> crate::input::describe_effective_instance_associations_input::Builder {
        crate::input::describe_effective_instance_associations_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribeEffectiveInstanceAssociationsOutput,
        crate::error::DescribeEffectiveInstanceAssociationsError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(
                        crate::error::DescribeEffectiveInstanceAssociationsError::unhandled(
                            generic,
                        ),
                    )
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeEffectiveInstanceAssociationsError { kind: crate::error::DescribeEffectiveInstanceAssociationsErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::DescribeEffectiveInstanceAssociationsError::unhandled(e)
                }
                "InvalidInstanceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeEffectiveInstanceAssociationsError { kind: crate::error::DescribeEffectiveInstanceAssociationsErrorKind::InvalidInstanceId(body), meta: generic },
                    Err(e) => crate::error::DescribeEffectiveInstanceAssociationsError::unhandled(e)
                }
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeEffectiveInstanceAssociationsError { kind: crate::error::DescribeEffectiveInstanceAssociationsErrorKind::InvalidNextToken(body), meta: generic },
                    Err(e) => crate::error::DescribeEffectiveInstanceAssociationsError::unhandled(e)
                }
                _ => crate::error::DescribeEffectiveInstanceAssociationsError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::describe_effective_instance_associations_output::Builder::default();
        builder = crate::json_deser::describe_effective_instance_associations_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeEffectiveInstanceAssociationsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeEffectiveInstanceAssociations {
    type Output = Result<
        crate::output::DescribeEffectiveInstanceAssociationsOutput,
        crate::error::DescribeEffectiveInstanceAssociationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Retrieves the current effective patches (the patch and the approval state) for the specified
/// patch baseline. Note that this API applies only to Windows patch baselines.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeEffectivePatchesForPatchBaseline {
    _private: (),
}
impl DescribeEffectivePatchesForPatchBaseline {
    /// Creates a new builder-style object to manufacture [`DescribeEffectivePatchesForPatchBaselineInput`](crate::input::DescribeEffectivePatchesForPatchBaselineInput)
    pub fn builder() -> crate::input::describe_effective_patches_for_patch_baseline_input::Builder {
        crate::input::describe_effective_patches_for_patch_baseline_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribeEffectivePatchesForPatchBaselineOutput,
        crate::error::DescribeEffectivePatchesForPatchBaselineError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(
                        crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled(
                            generic,
                        ),
                    )
                }
            };
            return Err(match error_code {
                "DoesNotExistException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeEffectivePatchesForPatchBaselineError { kind: crate::error::DescribeEffectivePatchesForPatchBaselineErrorKind::DoesNotExistError(body), meta: generic },
                    Err(e) => crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeEffectivePatchesForPatchBaselineError { kind: crate::error::DescribeEffectivePatchesForPatchBaselineErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled(e)
                }
                "InvalidResourceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeEffectivePatchesForPatchBaselineError { kind: crate::error::DescribeEffectivePatchesForPatchBaselineErrorKind::InvalidResourceId(body), meta: generic },
                    Err(e) => crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled(e)
                }
                "UnsupportedOperatingSystem" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeEffectivePatchesForPatchBaselineError { kind: crate::error::DescribeEffectivePatchesForPatchBaselineErrorKind::UnsupportedOperatingSystem(body), meta: generic },
                    Err(e) => crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled(e)
                }
                _ => crate::error::DescribeEffectivePatchesForPatchBaselineError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::describe_effective_patches_for_patch_baseline_output::Builder::default();
        builder = crate::json_deser::describe_effective_patches_for_patch_baseline_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeEffectivePatchesForPatchBaselineError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeEffectivePatchesForPatchBaseline {
    type Output = Result<
        crate::output::DescribeEffectivePatchesForPatchBaselineOutput,
        crate::error::DescribeEffectivePatchesForPatchBaselineError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>The status of the associations for the instance(s).</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeInstanceAssociationsStatus {
    _private: (),
}
impl DescribeInstanceAssociationsStatus {
    /// Creates a new builder-style object to manufacture [`DescribeInstanceAssociationsStatusInput`](crate::input::DescribeInstanceAssociationsStatusInput)
    pub fn builder() -> crate::input::describe_instance_associations_status_input::Builder {
        crate::input::describe_instance_associations_status_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribeInstanceAssociationsStatusOutput,
        crate::error::DescribeInstanceAssociationsStatusError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(
                        crate::error::DescribeInstanceAssociationsStatusError::unhandled(generic),
                    )
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeInstanceAssociationsStatusError { kind: crate::error::DescribeInstanceAssociationsStatusErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::DescribeInstanceAssociationsStatusError::unhandled(e)
                }
                "InvalidInstanceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeInstanceAssociationsStatusError { kind: crate::error::DescribeInstanceAssociationsStatusErrorKind::InvalidInstanceId(body), meta: generic },
                    Err(e) => crate::error::DescribeInstanceAssociationsStatusError::unhandled(e)
                }
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeInstanceAssociationsStatusError { kind: crate::error::DescribeInstanceAssociationsStatusErrorKind::InvalidNextToken(body), meta: generic },
                    Err(e) => crate::error::DescribeInstanceAssociationsStatusError::unhandled(e)
                }
                _ => crate::error::DescribeInstanceAssociationsStatusError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::describe_instance_associations_status_output::Builder::default();
        builder = crate::json_deser::describe_instance_associations_status_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeInstanceAssociationsStatusError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeInstanceAssociationsStatus {
    type Output = Result<
        crate::output::DescribeInstanceAssociationsStatusOutput,
        crate::error::DescribeInstanceAssociationsStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Describes one or more of your instances, including information about the operating system
/// platform, the version of SSM Agent installed on the instance, instance status, and so on.</p>
/// <p>If you specify one or more instance IDs, it returns information for those instances. If you
/// do not specify instance IDs, it returns information for all your instances. If you specify an
/// instance ID that is not valid or an instance that you do not own, you receive an error.</p>
/// <note>
/// <p>The IamRole field for this API action is the Amazon Identity and Access Management (IAM)
/// role assigned to on-premises instances. This call does not return the IAM role for EC2
/// instances.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeInstanceInformation {
    _private: (),
}
impl DescribeInstanceInformation {
    /// Creates a new builder-style object to manufacture [`DescribeInstanceInformationInput`](crate::input::DescribeInstanceInformationInput)
    pub fn builder() -> crate::input::describe_instance_information_input::Builder {
        crate::input::describe_instance_information_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribeInstanceInformationOutput,
        crate::error::DescribeInstanceInformationError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DescribeInstanceInformationError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeInstanceInformationError { kind: crate::error::DescribeInstanceInformationErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::DescribeInstanceInformationError::unhandled(e)
                }
                "InvalidFilterKey" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeInstanceInformationError { kind: crate::error::DescribeInstanceInformationErrorKind::InvalidFilterKey(body), meta: generic },
                    Err(e) => crate::error::DescribeInstanceInformationError::unhandled(e)
                }
                "InvalidInstanceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeInstanceInformationError { kind: crate::error::DescribeInstanceInformationErrorKind::InvalidInstanceId(body), meta: generic },
                    Err(e) => crate::error::DescribeInstanceInformationError::unhandled(e)
                }
                "InvalidInstanceInformationFilterValue" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeInstanceInformationError { kind: crate::error::DescribeInstanceInformationErrorKind::InvalidInstanceInformationFilterValue(body), meta: generic },
                    Err(e) => crate::error::DescribeInstanceInformationError::unhandled(e)
                }
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeInstanceInformationError { kind: crate::error::DescribeInstanceInformationErrorKind::InvalidNextToken(body), meta: generic },
                    Err(e) => crate::error::DescribeInstanceInformationError::unhandled(e)
                }
                _ => crate::error::DescribeInstanceInformationError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_instance_information_output::Builder::default();
        builder = crate::json_deser::describe_instance_information_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeInstanceInformationError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeInstanceInformation {
    type Output = Result<
        crate::output::DescribeInstanceInformationOutput,
        crate::error::DescribeInstanceInformationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Retrieves information about the patches on the specified instance and their state relative
/// to the patch baseline being used for the instance.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeInstancePatches {
    _private: (),
}
impl DescribeInstancePatches {
    /// Creates a new builder-style object to manufacture [`DescribeInstancePatchesInput`](crate::input::DescribeInstancePatchesInput)
    pub fn builder() -> crate::input::describe_instance_patches_input::Builder {
        crate::input::describe_instance_patches_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribeInstancePatchesOutput,
        crate::error::DescribeInstancePatchesError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DescribeInstancePatchesError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeInstancePatchesError {
                        kind: crate::error::DescribeInstancePatchesErrorKind::InternalServerError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeInstancePatchesError::unhandled(e),
                },
                "InvalidFilter" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeInstancePatchesError {
                        kind: crate::error::DescribeInstancePatchesErrorKind::InvalidFilter(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeInstancePatchesError::unhandled(e),
                },
                "InvalidInstanceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeInstancePatchesError {
                        kind: crate::error::DescribeInstancePatchesErrorKind::InvalidInstanceId(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeInstancePatchesError::unhandled(e),
                },
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeInstancePatchesError {
                        kind: crate::error::DescribeInstancePatchesErrorKind::InvalidNextToken(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeInstancePatchesError::unhandled(e),
                },
                _ => crate::error::DescribeInstancePatchesError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_instance_patches_output::Builder::default();
        builder = crate::json_deser::describe_instance_patches_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeInstancePatchesError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeInstancePatches {
    type Output = Result<
        crate::output::DescribeInstancePatchesOutput,
        crate::error::DescribeInstancePatchesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Retrieves the high-level patch state of one or more instances.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeInstancePatchStates {
    _private: (),
}
impl DescribeInstancePatchStates {
    /// Creates a new builder-style object to manufacture [`DescribeInstancePatchStatesInput`](crate::input::DescribeInstancePatchStatesInput)
    pub fn builder() -> crate::input::describe_instance_patch_states_input::Builder {
        crate::input::describe_instance_patch_states_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribeInstancePatchStatesOutput,
        crate::error::DescribeInstancePatchStatesError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DescribeInstancePatchStatesError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeInstancePatchStatesError {
                        kind:
                            crate::error::DescribeInstancePatchStatesErrorKind::InternalServerError(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeInstancePatchStatesError::unhandled(e),
                },
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeInstancePatchStatesError {
                        kind: crate::error::DescribeInstancePatchStatesErrorKind::InvalidNextToken(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeInstancePatchStatesError::unhandled(e),
                },
                _ => crate::error::DescribeInstancePatchStatesError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_instance_patch_states_output::Builder::default();
        builder = crate::json_deser::describe_instance_patch_states_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeInstancePatchStatesError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeInstancePatchStates {
    type Output = Result<
        crate::output::DescribeInstancePatchStatesOutput,
        crate::error::DescribeInstancePatchStatesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Retrieves the high-level patch state for the instances in the specified patch group.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeInstancePatchStatesForPatchGroup {
    _private: (),
}
impl DescribeInstancePatchStatesForPatchGroup {
    /// Creates a new builder-style object to manufacture [`DescribeInstancePatchStatesForPatchGroupInput`](crate::input::DescribeInstancePatchStatesForPatchGroupInput)
    pub fn builder() -> crate::input::describe_instance_patch_states_for_patch_group_input::Builder
    {
        crate::input::describe_instance_patch_states_for_patch_group_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribeInstancePatchStatesForPatchGroupOutput,
        crate::error::DescribeInstancePatchStatesForPatchGroupError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(
                        crate::error::DescribeInstancePatchStatesForPatchGroupError::unhandled(
                            generic,
                        ),
                    )
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeInstancePatchStatesForPatchGroupError { kind: crate::error::DescribeInstancePatchStatesForPatchGroupErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::DescribeInstancePatchStatesForPatchGroupError::unhandled(e)
                }
                "InvalidFilter" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeInstancePatchStatesForPatchGroupError { kind: crate::error::DescribeInstancePatchStatesForPatchGroupErrorKind::InvalidFilter(body), meta: generic },
                    Err(e) => crate::error::DescribeInstancePatchStatesForPatchGroupError::unhandled(e)
                }
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeInstancePatchStatesForPatchGroupError { kind: crate::error::DescribeInstancePatchStatesForPatchGroupErrorKind::InvalidNextToken(body), meta: generic },
                    Err(e) => crate::error::DescribeInstancePatchStatesForPatchGroupError::unhandled(e)
                }
                _ => crate::error::DescribeInstancePatchStatesForPatchGroupError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::describe_instance_patch_states_for_patch_group_output::Builder::default(
            );
        builder =
            crate::json_deser::describe_instance_patch_states_for_patch_group_deser_operation(
                response.body().as_ref(),
                builder,
            )
            .map_err(crate::error::DescribeInstancePatchStatesForPatchGroupError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeInstancePatchStatesForPatchGroup {
    type Output = Result<
        crate::output::DescribeInstancePatchStatesForPatchGroupOutput,
        crate::error::DescribeInstancePatchStatesForPatchGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Describes a specific delete inventory operation.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeInventoryDeletions {
    _private: (),
}
impl DescribeInventoryDeletions {
    /// Creates a new builder-style object to manufacture [`DescribeInventoryDeletionsInput`](crate::input::DescribeInventoryDeletionsInput)
    pub fn builder() -> crate::input::describe_inventory_deletions_input::Builder {
        crate::input::describe_inventory_deletions_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribeInventoryDeletionsOutput,
        crate::error::DescribeInventoryDeletionsError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DescribeInventoryDeletionsError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeInventoryDeletionsError { kind: crate::error::DescribeInventoryDeletionsErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::DescribeInventoryDeletionsError::unhandled(e)
                }
                "InvalidDeletionIdException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeInventoryDeletionsError { kind: crate::error::DescribeInventoryDeletionsErrorKind::InvalidDeletionIdError(body), meta: generic },
                    Err(e) => crate::error::DescribeInventoryDeletionsError::unhandled(e)
                }
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeInventoryDeletionsError { kind: crate::error::DescribeInventoryDeletionsErrorKind::InvalidNextToken(body), meta: generic },
                    Err(e) => crate::error::DescribeInventoryDeletionsError::unhandled(e)
                }
                _ => crate::error::DescribeInventoryDeletionsError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_inventory_deletions_output::Builder::default();
        builder = crate::json_deser::describe_inventory_deletions_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeInventoryDeletionsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeInventoryDeletions {
    type Output = Result<
        crate::output::DescribeInventoryDeletionsOutput,
        crate::error::DescribeInventoryDeletionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists the executions of a maintenance window. This includes information about when the
/// maintenance window was scheduled to be active, and information about tasks registered and run
/// with the maintenance window.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeMaintenanceWindowExecutions {
    _private: (),
}
impl DescribeMaintenanceWindowExecutions {
    /// Creates a new builder-style object to manufacture [`DescribeMaintenanceWindowExecutionsInput`](crate::input::DescribeMaintenanceWindowExecutionsInput)
    pub fn builder() -> crate::input::describe_maintenance_window_executions_input::Builder {
        crate::input::describe_maintenance_window_executions_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribeMaintenanceWindowExecutionsOutput,
        crate::error::DescribeMaintenanceWindowExecutionsError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(
                        crate::error::DescribeMaintenanceWindowExecutionsError::unhandled(generic),
                    )
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeMaintenanceWindowExecutionsError { kind: crate::error::DescribeMaintenanceWindowExecutionsErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::DescribeMaintenanceWindowExecutionsError::unhandled(e)
                }
                _ => crate::error::DescribeMaintenanceWindowExecutionsError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::describe_maintenance_window_executions_output::Builder::default();
        builder = crate::json_deser::describe_maintenance_window_executions_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeMaintenanceWindowExecutionsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeMaintenanceWindowExecutions {
    type Output = Result<
        crate::output::DescribeMaintenanceWindowExecutionsOutput,
        crate::error::DescribeMaintenanceWindowExecutionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Retrieves the individual task executions (one per target) for a particular task run as part
/// of a maintenance window execution.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeMaintenanceWindowExecutionTaskInvocations {
    _private: (),
}
impl DescribeMaintenanceWindowExecutionTaskInvocations {
    /// Creates a new builder-style object to manufacture [`DescribeMaintenanceWindowExecutionTaskInvocationsInput`](crate::input::DescribeMaintenanceWindowExecutionTaskInvocationsInput)
    pub fn builder(
    ) -> crate::input::describe_maintenance_window_execution_task_invocations_input::Builder {
        crate::input::describe_maintenance_window_execution_task_invocations_input::Builder::default(
        )
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribeMaintenanceWindowExecutionTaskInvocationsOutput,
        crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(
                    crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::unhandled(
                        generic,
                    ),
                ),
            };
            return Err(match error_code {
                "DoesNotExistException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError { kind: crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsErrorKind::DoesNotExistError(body), meta: generic },
                    Err(e) => crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError { kind: crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::unhandled(e)
                }
                _ => crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::generic(generic)
            });
        }
        #[allow(unused_mut)]let mut builder = crate::output::describe_maintenance_window_execution_task_invocations_output::Builder::default();
        builder = crate::json_deser::describe_maintenance_window_execution_task_invocations_deser_operation(response.body().as_ref(), builder).map_err(crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse
    for DescribeMaintenanceWindowExecutionTaskInvocations
{
    type Output = Result<
        crate::output::DescribeMaintenanceWindowExecutionTaskInvocationsOutput,
        crate::error::DescribeMaintenanceWindowExecutionTaskInvocationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>For a given maintenance window execution, lists the tasks that were run.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeMaintenanceWindowExecutionTasks {
    _private: (),
}
impl DescribeMaintenanceWindowExecutionTasks {
    /// Creates a new builder-style object to manufacture [`DescribeMaintenanceWindowExecutionTasksInput`](crate::input::DescribeMaintenanceWindowExecutionTasksInput)
    pub fn builder() -> crate::input::describe_maintenance_window_execution_tasks_input::Builder {
        crate::input::describe_maintenance_window_execution_tasks_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribeMaintenanceWindowExecutionTasksOutput,
        crate::error::DescribeMaintenanceWindowExecutionTasksError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(
                        crate::error::DescribeMaintenanceWindowExecutionTasksError::unhandled(
                            generic,
                        ),
                    )
                }
            };
            return Err(match error_code {
                "DoesNotExistException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeMaintenanceWindowExecutionTasksError { kind: crate::error::DescribeMaintenanceWindowExecutionTasksErrorKind::DoesNotExistError(body), meta: generic },
                    Err(e) => crate::error::DescribeMaintenanceWindowExecutionTasksError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeMaintenanceWindowExecutionTasksError { kind: crate::error::DescribeMaintenanceWindowExecutionTasksErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::DescribeMaintenanceWindowExecutionTasksError::unhandled(e)
                }
                _ => crate::error::DescribeMaintenanceWindowExecutionTasksError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::describe_maintenance_window_execution_tasks_output::Builder::default();
        builder = crate::json_deser::describe_maintenance_window_execution_tasks_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeMaintenanceWindowExecutionTasksError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeMaintenanceWindowExecutionTasks {
    type Output = Result<
        crate::output::DescribeMaintenanceWindowExecutionTasksOutput,
        crate::error::DescribeMaintenanceWindowExecutionTasksError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Retrieves the maintenance windows in an AWS account.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeMaintenanceWindows {
    _private: (),
}
impl DescribeMaintenanceWindows {
    /// Creates a new builder-style object to manufacture [`DescribeMaintenanceWindowsInput`](crate::input::DescribeMaintenanceWindowsInput)
    pub fn builder() -> crate::input::describe_maintenance_windows_input::Builder {
        crate::input::describe_maintenance_windows_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribeMaintenanceWindowsOutput,
        crate::error::DescribeMaintenanceWindowsError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DescribeMaintenanceWindowsError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeMaintenanceWindowsError {
                        kind:
                            crate::error::DescribeMaintenanceWindowsErrorKind::InternalServerError(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeMaintenanceWindowsError::unhandled(e),
                },
                _ => crate::error::DescribeMaintenanceWindowsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_maintenance_windows_output::Builder::default();
        builder = crate::json_deser::describe_maintenance_windows_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeMaintenanceWindowsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeMaintenanceWindows {
    type Output = Result<
        crate::output::DescribeMaintenanceWindowsOutput,
        crate::error::DescribeMaintenanceWindowsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Retrieves information about upcoming executions of a maintenance window.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeMaintenanceWindowSchedule {
    _private: (),
}
impl DescribeMaintenanceWindowSchedule {
    /// Creates a new builder-style object to manufacture [`DescribeMaintenanceWindowScheduleInput`](crate::input::DescribeMaintenanceWindowScheduleInput)
    pub fn builder() -> crate::input::describe_maintenance_window_schedule_input::Builder {
        crate::input::describe_maintenance_window_schedule_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribeMaintenanceWindowScheduleOutput,
        crate::error::DescribeMaintenanceWindowScheduleError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(
                        crate::error::DescribeMaintenanceWindowScheduleError::unhandled(generic),
                    )
                }
            };
            return Err(match error_code {
                "DoesNotExistException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeMaintenanceWindowScheduleError { kind: crate::error::DescribeMaintenanceWindowScheduleErrorKind::DoesNotExistError(body), meta: generic },
                    Err(e) => crate::error::DescribeMaintenanceWindowScheduleError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeMaintenanceWindowScheduleError { kind: crate::error::DescribeMaintenanceWindowScheduleErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::DescribeMaintenanceWindowScheduleError::unhandled(e)
                }
                _ => crate::error::DescribeMaintenanceWindowScheduleError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::describe_maintenance_window_schedule_output::Builder::default();
        builder = crate::json_deser::describe_maintenance_window_schedule_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeMaintenanceWindowScheduleError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeMaintenanceWindowSchedule {
    type Output = Result<
        crate::output::DescribeMaintenanceWindowScheduleOutput,
        crate::error::DescribeMaintenanceWindowScheduleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Retrieves information about the maintenance window targets or tasks that an instance is
/// associated with.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeMaintenanceWindowsForTarget {
    _private: (),
}
impl DescribeMaintenanceWindowsForTarget {
    /// Creates a new builder-style object to manufacture [`DescribeMaintenanceWindowsForTargetInput`](crate::input::DescribeMaintenanceWindowsForTargetInput)
    pub fn builder() -> crate::input::describe_maintenance_windows_for_target_input::Builder {
        crate::input::describe_maintenance_windows_for_target_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribeMaintenanceWindowsForTargetOutput,
        crate::error::DescribeMaintenanceWindowsForTargetError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(
                        crate::error::DescribeMaintenanceWindowsForTargetError::unhandled(generic),
                    )
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeMaintenanceWindowsForTargetError { kind: crate::error::DescribeMaintenanceWindowsForTargetErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::DescribeMaintenanceWindowsForTargetError::unhandled(e)
                }
                _ => crate::error::DescribeMaintenanceWindowsForTargetError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::describe_maintenance_windows_for_target_output::Builder::default();
        builder = crate::json_deser::describe_maintenance_windows_for_target_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeMaintenanceWindowsForTargetError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeMaintenanceWindowsForTarget {
    type Output = Result<
        crate::output::DescribeMaintenanceWindowsForTargetOutput,
        crate::error::DescribeMaintenanceWindowsForTargetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists the targets registered with the maintenance window.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeMaintenanceWindowTargets {
    _private: (),
}
impl DescribeMaintenanceWindowTargets {
    /// Creates a new builder-style object to manufacture [`DescribeMaintenanceWindowTargetsInput`](crate::input::DescribeMaintenanceWindowTargetsInput)
    pub fn builder() -> crate::input::describe_maintenance_window_targets_input::Builder {
        crate::input::describe_maintenance_window_targets_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribeMaintenanceWindowTargetsOutput,
        crate::error::DescribeMaintenanceWindowTargetsError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(
                        crate::error::DescribeMaintenanceWindowTargetsError::unhandled(generic),
                    )
                }
            };
            return Err(match error_code {
                "DoesNotExistException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeMaintenanceWindowTargetsError { kind: crate::error::DescribeMaintenanceWindowTargetsErrorKind::DoesNotExistError(body), meta: generic },
                    Err(e) => crate::error::DescribeMaintenanceWindowTargetsError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeMaintenanceWindowTargetsError { kind: crate::error::DescribeMaintenanceWindowTargetsErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::DescribeMaintenanceWindowTargetsError::unhandled(e)
                }
                _ => crate::error::DescribeMaintenanceWindowTargetsError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::describe_maintenance_window_targets_output::Builder::default();
        builder = crate::json_deser::describe_maintenance_window_targets_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeMaintenanceWindowTargetsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeMaintenanceWindowTargets {
    type Output = Result<
        crate::output::DescribeMaintenanceWindowTargetsOutput,
        crate::error::DescribeMaintenanceWindowTargetsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists the tasks in a maintenance window.</p>
/// <note>
/// <p>For maintenance window tasks without a specified target, you cannot supply values for
/// <code>--max-errors</code> and <code>--max-concurrency</code>. Instead, the system inserts a
/// placeholder value of <code>1</code>, which may be reported in the response to this command.
/// These values do not affect the running of your task and can be ignored.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeMaintenanceWindowTasks {
    _private: (),
}
impl DescribeMaintenanceWindowTasks {
    /// Creates a new builder-style object to manufacture [`DescribeMaintenanceWindowTasksInput`](crate::input::DescribeMaintenanceWindowTasksInput)
    pub fn builder() -> crate::input::describe_maintenance_window_tasks_input::Builder {
        crate::input::describe_maintenance_window_tasks_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribeMaintenanceWindowTasksOutput,
        crate::error::DescribeMaintenanceWindowTasksError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(
                        crate::error::DescribeMaintenanceWindowTasksError::unhandled(generic),
                    )
                }
            };
            return Err(match error_code {
                "DoesNotExistException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeMaintenanceWindowTasksError { kind: crate::error::DescribeMaintenanceWindowTasksErrorKind::DoesNotExistError(body), meta: generic },
                    Err(e) => crate::error::DescribeMaintenanceWindowTasksError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeMaintenanceWindowTasksError { kind: crate::error::DescribeMaintenanceWindowTasksErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::DescribeMaintenanceWindowTasksError::unhandled(e)
                }
                _ => crate::error::DescribeMaintenanceWindowTasksError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::describe_maintenance_window_tasks_output::Builder::default();
        builder = crate::json_deser::describe_maintenance_window_tasks_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeMaintenanceWindowTasksError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeMaintenanceWindowTasks {
    type Output = Result<
        crate::output::DescribeMaintenanceWindowTasksOutput,
        crate::error::DescribeMaintenanceWindowTasksError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Query a set of OpsItems. You must have permission in AWS Identity and Access Management
/// (IAM) to query a list of OpsItems. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-getting-started.html">Getting started with
/// OpsCenter</a> in the <i>AWS Systems Manager User Guide</i>.</p>
/// <p>Operations engineers and IT professionals use OpsCenter to view, investigate, and remediate
/// operational issues impacting the performance and health of their AWS resources. For more
/// information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter.html">AWS Systems Manager OpsCenter</a> in the
/// <i>AWS Systems Manager User Guide</i>. </p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeOpsItems {
    _private: (),
}
impl DescribeOpsItems {
    /// Creates a new builder-style object to manufacture [`DescribeOpsItemsInput`](crate::input::DescribeOpsItemsInput)
    pub fn builder() -> crate::input::describe_ops_items_input::Builder {
        crate::input::describe_ops_items_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::DescribeOpsItemsOutput, crate::error::DescribeOpsItemsError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DescribeOpsItemsError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeOpsItemsError {
                        kind: crate::error::DescribeOpsItemsErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeOpsItemsError::unhandled(e),
                },
                _ => crate::error::DescribeOpsItemsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_ops_items_output::Builder::default();
        builder = crate::json_deser::describe_ops_items_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeOpsItemsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeOpsItems {
    type Output =
        Result<crate::output::DescribeOpsItemsOutput, crate::error::DescribeOpsItemsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Get information about a parameter.</p>
/// <note>
/// <p>Request results are returned on a best-effort basis. If you specify <code>MaxResults</code>
/// in the request, the response includes information up to the limit specified. The number of items
/// returned, however, can be between zero and the value of <code>MaxResults</code>. If the service
/// reaches an internal limit while processing the results, it stops the operation and returns the
/// matching values up to that point and a <code>NextToken</code>. You can specify the
/// <code>NextToken</code> in a subsequent call to get the next set of results.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeParameters {
    _private: (),
}
impl DescribeParameters {
    /// Creates a new builder-style object to manufacture [`DescribeParametersInput`](crate::input::DescribeParametersInput)
    pub fn builder() -> crate::input::describe_parameters_input::Builder {
        crate::input::describe_parameters_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::DescribeParametersOutput, crate::error::DescribeParametersError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DescribeParametersError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeParametersError {
                        kind: crate::error::DescribeParametersErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeParametersError::unhandled(e),
                },
                "InvalidFilterKey" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeParametersError {
                        kind: crate::error::DescribeParametersErrorKind::InvalidFilterKey(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeParametersError::unhandled(e),
                },
                "InvalidFilterOption" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeParametersError {
                        kind: crate::error::DescribeParametersErrorKind::InvalidFilterOption(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeParametersError::unhandled(e),
                },
                "InvalidFilterValue" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeParametersError {
                        kind: crate::error::DescribeParametersErrorKind::InvalidFilterValue(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeParametersError::unhandled(e),
                },
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeParametersError {
                        kind: crate::error::DescribeParametersErrorKind::InvalidNextToken(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeParametersError::unhandled(e),
                },
                _ => crate::error::DescribeParametersError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_parameters_output::Builder::default();
        builder = crate::json_deser::describe_parameters_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeParametersError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeParameters {
    type Output =
        Result<crate::output::DescribeParametersOutput, crate::error::DescribeParametersError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists the patch baselines in your AWS account.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribePatchBaselines {
    _private: (),
}
impl DescribePatchBaselines {
    /// Creates a new builder-style object to manufacture [`DescribePatchBaselinesInput`](crate::input::DescribePatchBaselinesInput)
    pub fn builder() -> crate::input::describe_patch_baselines_input::Builder {
        crate::input::describe_patch_baselines_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribePatchBaselinesOutput,
        crate::error::DescribePatchBaselinesError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DescribePatchBaselinesError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribePatchBaselinesError {
                        kind: crate::error::DescribePatchBaselinesErrorKind::InternalServerError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribePatchBaselinesError::unhandled(e),
                },
                _ => crate::error::DescribePatchBaselinesError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_patch_baselines_output::Builder::default();
        builder = crate::json_deser::describe_patch_baselines_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribePatchBaselinesError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribePatchBaselines {
    type Output = Result<
        crate::output::DescribePatchBaselinesOutput,
        crate::error::DescribePatchBaselinesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists all patch groups that have been registered with patch baselines.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribePatchGroups {
    _private: (),
}
impl DescribePatchGroups {
    /// Creates a new builder-style object to manufacture [`DescribePatchGroupsInput`](crate::input::DescribePatchGroupsInput)
    pub fn builder() -> crate::input::describe_patch_groups_input::Builder {
        crate::input::describe_patch_groups_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::DescribePatchGroupsOutput, crate::error::DescribePatchGroupsError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DescribePatchGroupsError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribePatchGroupsError {
                        kind: crate::error::DescribePatchGroupsErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribePatchGroupsError::unhandled(e),
                },
                _ => crate::error::DescribePatchGroupsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_patch_groups_output::Builder::default();
        builder = crate::json_deser::describe_patch_groups_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribePatchGroupsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribePatchGroups {
    type Output =
        Result<crate::output::DescribePatchGroupsOutput, crate::error::DescribePatchGroupsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns high-level aggregated patch compliance state for a patch group.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribePatchGroupState {
    _private: (),
}
impl DescribePatchGroupState {
    /// Creates a new builder-style object to manufacture [`DescribePatchGroupStateInput`](crate::input::DescribePatchGroupStateInput)
    pub fn builder() -> crate::input::describe_patch_group_state_input::Builder {
        crate::input::describe_patch_group_state_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribePatchGroupStateOutput,
        crate::error::DescribePatchGroupStateError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DescribePatchGroupStateError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribePatchGroupStateError {
                        kind: crate::error::DescribePatchGroupStateErrorKind::InternalServerError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribePatchGroupStateError::unhandled(e),
                },
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribePatchGroupStateError {
                        kind: crate::error::DescribePatchGroupStateErrorKind::InvalidNextToken(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribePatchGroupStateError::unhandled(e),
                },
                _ => crate::error::DescribePatchGroupStateError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_patch_group_state_output::Builder::default();
        builder = crate::json_deser::describe_patch_group_state_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribePatchGroupStateError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribePatchGroupState {
    type Output = Result<
        crate::output::DescribePatchGroupStateOutput,
        crate::error::DescribePatchGroupStateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists the properties of available patches organized by product, product family,
/// classification, severity, and other properties of available patches. You can use the reported
/// properties in the filters you specify in requests for actions such as <a>CreatePatchBaseline</a>, <a>UpdatePatchBaseline</a>, <a>DescribeAvailablePatches</a>, and <a>DescribePatchBaselines</a>.</p>
/// <p>The following section lists the properties that can be used in filters for each major
/// operating system type:</p>
/// <dl>
/// <dt>AMAZON_LINUX</dt>
/// <dd>
/// <p>Valid properties: PRODUCT, CLASSIFICATION, SEVERITY</p>
/// </dd>
/// <dt>AMAZON_LINUX_2</dt>
/// <dd>
/// <p>Valid properties: PRODUCT, CLASSIFICATION, SEVERITY</p>
/// </dd>
/// <dt>CENTOS</dt>
/// <dd>
/// <p>Valid properties: PRODUCT, CLASSIFICATION, SEVERITY</p>
/// </dd>
/// <dt>DEBIAN</dt>
/// <dd>
/// <p>Valid properties: PRODUCT, PRIORITY</p>
/// </dd>
/// <dt>MACOS</dt>
/// <dd>
/// <p>Valid properties: PRODUCT, CLASSIFICATION</p>
/// </dd>
/// <dt>ORACLE_LINUX</dt>
/// <dd>
/// <p>Valid properties: PRODUCT, CLASSIFICATION, SEVERITY</p>
/// </dd>
/// <dt>REDHAT_ENTERPRISE_LINUX</dt>
/// <dd>
/// <p>Valid properties: PRODUCT, CLASSIFICATION, SEVERITY</p>
/// </dd>
/// <dt>SUSE</dt>
/// <dd>
/// <p>Valid properties: PRODUCT, CLASSIFICATION, SEVERITY</p>
/// </dd>
/// <dt>UBUNTU</dt>
/// <dd>
/// <p>Valid properties: PRODUCT, PRIORITY</p>
/// </dd>
/// <dt>WINDOWS</dt>
/// <dd>
/// <p>Valid properties: PRODUCT, PRODUCT_FAMILY, CLASSIFICATION, MSRC_SEVERITY</p>
/// </dd>
/// </dl>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribePatchProperties {
    _private: (),
}
impl DescribePatchProperties {
    /// Creates a new builder-style object to manufacture [`DescribePatchPropertiesInput`](crate::input::DescribePatchPropertiesInput)
    pub fn builder() -> crate::input::describe_patch_properties_input::Builder {
        crate::input::describe_patch_properties_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribePatchPropertiesOutput,
        crate::error::DescribePatchPropertiesError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DescribePatchPropertiesError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribePatchPropertiesError {
                        kind: crate::error::DescribePatchPropertiesErrorKind::InternalServerError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribePatchPropertiesError::unhandled(e),
                },
                _ => crate::error::DescribePatchPropertiesError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_patch_properties_output::Builder::default();
        builder = crate::json_deser::describe_patch_properties_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribePatchPropertiesError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribePatchProperties {
    type Output = Result<
        crate::output::DescribePatchPropertiesOutput,
        crate::error::DescribePatchPropertiesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Retrieves a list of all active sessions (both connected and disconnected) or terminated
/// sessions from the past 30 days.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DescribeSessions {
    _private: (),
}
impl DescribeSessions {
    /// Creates a new builder-style object to manufacture [`DescribeSessionsInput`](crate::input::DescribeSessionsInput)
    pub fn builder() -> crate::input::describe_sessions_input::Builder {
        crate::input::describe_sessions_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::DescribeSessionsOutput, crate::error::DescribeSessionsError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DescribeSessionsError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeSessionsError {
                        kind: crate::error::DescribeSessionsErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeSessionsError::unhandled(e),
                },
                "InvalidFilterKey" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeSessionsError {
                        kind: crate::error::DescribeSessionsErrorKind::InvalidFilterKey(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeSessionsError::unhandled(e),
                },
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeSessionsError {
                        kind: crate::error::DescribeSessionsErrorKind::InvalidNextToken(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeSessionsError::unhandled(e),
                },
                _ => crate::error::DescribeSessionsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_sessions_output::Builder::default();
        builder =
            crate::json_deser::describe_sessions_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::DescribeSessionsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeSessions {
    type Output =
        Result<crate::output::DescribeSessionsOutput, crate::error::DescribeSessionsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes the association between an OpsItem and a related resource. For example, this API
/// action can delete an Incident Manager incident from an OpsItem. Incident Manager is a capability
/// of AWS Systems Manager.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct DisassociateOpsItemRelatedItem {
    _private: (),
}
impl DisassociateOpsItemRelatedItem {
    /// Creates a new builder-style object to manufacture [`DisassociateOpsItemRelatedItemInput`](crate::input::DisassociateOpsItemRelatedItemInput)
    pub fn builder() -> crate::input::disassociate_ops_item_related_item_input::Builder {
        crate::input::disassociate_ops_item_related_item_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DisassociateOpsItemRelatedItemOutput,
        crate::error::DisassociateOpsItemRelatedItemError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(
                        crate::error::DisassociateOpsItemRelatedItemError::unhandled(generic),
                    )
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DisassociateOpsItemRelatedItemError { kind: crate::error::DisassociateOpsItemRelatedItemErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::DisassociateOpsItemRelatedItemError::unhandled(e)
                }
                "OpsItemInvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DisassociateOpsItemRelatedItemError { kind: crate::error::DisassociateOpsItemRelatedItemErrorKind::OpsItemInvalidParameterError(body), meta: generic },
                    Err(e) => crate::error::DisassociateOpsItemRelatedItemError::unhandled(e)
                }
                "OpsItemNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DisassociateOpsItemRelatedItemError { kind: crate::error::DisassociateOpsItemRelatedItemErrorKind::OpsItemNotFoundError(body), meta: generic },
                    Err(e) => crate::error::DisassociateOpsItemRelatedItemError::unhandled(e)
                }
                "OpsItemRelatedItemAssociationNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DisassociateOpsItemRelatedItemError { kind: crate::error::DisassociateOpsItemRelatedItemErrorKind::OpsItemRelatedItemAssociationNotFoundError(body), meta: generic },
                    Err(e) => crate::error::DisassociateOpsItemRelatedItemError::unhandled(e)
                }
                _ => crate::error::DisassociateOpsItemRelatedItemError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::disassociate_ops_item_related_item_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DisassociateOpsItemRelatedItem {
    type Output = Result<
        crate::output::DisassociateOpsItemRelatedItemOutput,
        crate::error::DisassociateOpsItemRelatedItemError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Get detailed information about a particular Automation execution.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct GetAutomationExecution {
    _private: (),
}
impl GetAutomationExecution {
    /// Creates a new builder-style object to manufacture [`GetAutomationExecutionInput`](crate::input::GetAutomationExecutionInput)
    pub fn builder() -> crate::input::get_automation_execution_input::Builder {
        crate::input::get_automation_execution_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::GetAutomationExecutionOutput,
        crate::error::GetAutomationExecutionError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::GetAutomationExecutionError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "AutomationExecutionNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetAutomationExecutionError { kind: crate::error::GetAutomationExecutionErrorKind::AutomationExecutionNotFoundError(body), meta: generic },
                    Err(e) => crate::error::GetAutomationExecutionError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetAutomationExecutionError { kind: crate::error::GetAutomationExecutionErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::GetAutomationExecutionError::unhandled(e)
                }
                _ => crate::error::GetAutomationExecutionError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::get_automation_execution_output::Builder::default();
        builder = crate::json_deser::get_automation_execution_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::GetAutomationExecutionError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetAutomationExecution {
    type Output = Result<
        crate::output::GetAutomationExecutionOutput,
        crate::error::GetAutomationExecutionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Gets the state of the AWS Systems Manager Change Calendar at an optional, specified time. If you
/// specify a time, <code>GetCalendarState</code> returns the state of the calendar at a specific
/// time, and returns the next time that the Change Calendar state will transition. If you do not
/// specify a time, <code>GetCalendarState</code> assumes the current time. Change Calendar entries
/// have two possible states: <code>OPEN</code> or <code>CLOSED</code>.</p>
/// <p>If you specify more than one calendar in a request, the command returns the status of
/// <code>OPEN</code> only if all calendars in the request are open. If one or more calendars in the
/// request are closed, the status returned is <code>CLOSED</code>.</p>
/// <p>For more information about Systems Manager Change Calendar, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar.html">AWS Systems Manager Change
/// Calendar</a> in the <i>AWS Systems Manager User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct GetCalendarState {
    _private: (),
}
impl GetCalendarState {
    /// Creates a new builder-style object to manufacture [`GetCalendarStateInput`](crate::input::GetCalendarStateInput)
    pub fn builder() -> crate::input::get_calendar_state_input::Builder {
        crate::input::get_calendar_state_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::GetCalendarStateOutput, crate::error::GetCalendarStateError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetCalendarStateError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetCalendarStateError {
                        kind: crate::error::GetCalendarStateErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetCalendarStateError::unhandled(e),
                },
                "InvalidDocument" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetCalendarStateError {
                        kind: crate::error::GetCalendarStateErrorKind::InvalidDocument(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetCalendarStateError::unhandled(e),
                },
                "InvalidDocumentType" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetCalendarStateError {
                        kind: crate::error::GetCalendarStateErrorKind::InvalidDocumentType(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetCalendarStateError::unhandled(e),
                },
                "UnsupportedCalendarException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetCalendarStateError {
                        kind: crate::error::GetCalendarStateErrorKind::UnsupportedCalendarError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetCalendarStateError::unhandled(e),
                },
                _ => crate::error::GetCalendarStateError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::get_calendar_state_output::Builder::default();
        builder = crate::json_deser::get_calendar_state_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::GetCalendarStateError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetCalendarState {
    type Output =
        Result<crate::output::GetCalendarStateOutput, crate::error::GetCalendarStateError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns detailed information about command execution for an invocation or plugin.</p>
/// <p>
/// <code>GetCommandInvocation</code> only gives the execution status of a plugin in a document.
/// To get the command execution status on a specific instance, use <a>ListCommandInvocations</a>. To get the command execution status across instances, use
/// <a>ListCommands</a>.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct GetCommandInvocation {
    _private: (),
}
impl GetCommandInvocation {
    /// Creates a new builder-style object to manufacture [`GetCommandInvocationInput`](crate::input::GetCommandInvocationInput)
    pub fn builder() -> crate::input::get_command_invocation_input::Builder {
        crate::input::get_command_invocation_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::GetCommandInvocationOutput, crate::error::GetCommandInvocationError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetCommandInvocationError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetCommandInvocationError {
                        kind: crate::error::GetCommandInvocationErrorKind::InternalServerError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetCommandInvocationError::unhandled(e),
                },
                "InvalidCommandId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetCommandInvocationError {
                        kind: crate::error::GetCommandInvocationErrorKind::InvalidCommandId(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetCommandInvocationError::unhandled(e),
                },
                "InvalidInstanceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetCommandInvocationError {
                        kind: crate::error::GetCommandInvocationErrorKind::InvalidInstanceId(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetCommandInvocationError::unhandled(e),
                },
                "InvalidPluginName" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetCommandInvocationError {
                        kind: crate::error::GetCommandInvocationErrorKind::InvalidPluginName(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetCommandInvocationError::unhandled(e),
                },
                "InvocationDoesNotExist" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetCommandInvocationError {
                        kind: crate::error::GetCommandInvocationErrorKind::InvocationDoesNotExist(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetCommandInvocationError::unhandled(e),
                },
                _ => crate::error::GetCommandInvocationError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::get_command_invocation_output::Builder::default();
        builder = crate::json_deser::get_command_invocation_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::GetCommandInvocationError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetCommandInvocation {
    type Output =
        Result<crate::output::GetCommandInvocationOutput, crate::error::GetCommandInvocationError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Retrieves the Session Manager connection status for an instance to determine whether it is running and
/// ready to receive Session Manager connections.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct GetConnectionStatus {
    _private: (),
}
impl GetConnectionStatus {
    /// Creates a new builder-style object to manufacture [`GetConnectionStatusInput`](crate::input::GetConnectionStatusInput)
    pub fn builder() -> crate::input::get_connection_status_input::Builder {
        crate::input::get_connection_status_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::GetConnectionStatusOutput, crate::error::GetConnectionStatusError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetConnectionStatusError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetConnectionStatusError {
                        kind: crate::error::GetConnectionStatusErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetConnectionStatusError::unhandled(e),
                },
                _ => crate::error::GetConnectionStatusError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::get_connection_status_output::Builder::default();
        builder = crate::json_deser::get_connection_status_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::GetConnectionStatusError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetConnectionStatus {
    type Output =
        Result<crate::output::GetConnectionStatusOutput, crate::error::GetConnectionStatusError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Retrieves the default patch baseline. Note that Systems Manager supports creating multiple default
/// patch baselines. For example, you can create a default patch baseline for each operating
/// system.</p>
/// <p>If you do not specify an operating system value, the default patch baseline for Windows is
/// returned.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct GetDefaultPatchBaseline {
    _private: (),
}
impl GetDefaultPatchBaseline {
    /// Creates a new builder-style object to manufacture [`GetDefaultPatchBaselineInput`](crate::input::GetDefaultPatchBaselineInput)
    pub fn builder() -> crate::input::get_default_patch_baseline_input::Builder {
        crate::input::get_default_patch_baseline_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::GetDefaultPatchBaselineOutput,
        crate::error::GetDefaultPatchBaselineError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::GetDefaultPatchBaselineError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetDefaultPatchBaselineError {
                        kind: crate::error::GetDefaultPatchBaselineErrorKind::InternalServerError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetDefaultPatchBaselineError::unhandled(e),
                },
                _ => crate::error::GetDefaultPatchBaselineError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::get_default_patch_baseline_output::Builder::default();
        builder = crate::json_deser::get_default_patch_baseline_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::GetDefaultPatchBaselineError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetDefaultPatchBaseline {
    type Output = Result<
        crate::output::GetDefaultPatchBaselineOutput,
        crate::error::GetDefaultPatchBaselineError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Retrieves the current snapshot for the patch baseline the instance uses. This API is
/// primarily used by the AWS-RunPatchBaseline Systems Manager document. </p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct GetDeployablePatchSnapshotForInstance {
    _private: (),
}
impl GetDeployablePatchSnapshotForInstance {
    /// Creates a new builder-style object to manufacture [`GetDeployablePatchSnapshotForInstanceInput`](crate::input::GetDeployablePatchSnapshotForInstanceInput)
    pub fn builder() -> crate::input::get_deployable_patch_snapshot_for_instance_input::Builder {
        crate::input::get_deployable_patch_snapshot_for_instance_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::GetDeployablePatchSnapshotForInstanceOutput,
        crate::error::GetDeployablePatchSnapshotForInstanceError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(
                        crate::error::GetDeployablePatchSnapshotForInstanceError::unhandled(
                            generic,
                        ),
                    )
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetDeployablePatchSnapshotForInstanceError { kind: crate::error::GetDeployablePatchSnapshotForInstanceErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::GetDeployablePatchSnapshotForInstanceError::unhandled(e)
                }
                "UnsupportedFeatureRequiredException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetDeployablePatchSnapshotForInstanceError { kind: crate::error::GetDeployablePatchSnapshotForInstanceErrorKind::UnsupportedFeatureRequiredError(body), meta: generic },
                    Err(e) => crate::error::GetDeployablePatchSnapshotForInstanceError::unhandled(e)
                }
                "UnsupportedOperatingSystem" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetDeployablePatchSnapshotForInstanceError { kind: crate::error::GetDeployablePatchSnapshotForInstanceErrorKind::UnsupportedOperatingSystem(body), meta: generic },
                    Err(e) => crate::error::GetDeployablePatchSnapshotForInstanceError::unhandled(e)
                }
                _ => crate::error::GetDeployablePatchSnapshotForInstanceError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::get_deployable_patch_snapshot_for_instance_output::Builder::default();
        builder = crate::json_deser::get_deployable_patch_snapshot_for_instance_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::GetDeployablePatchSnapshotForInstanceError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetDeployablePatchSnapshotForInstance {
    type Output = Result<
        crate::output::GetDeployablePatchSnapshotForInstanceOutput,
        crate::error::GetDeployablePatchSnapshotForInstanceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Gets the contents of the specified Systems Manager document.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct GetDocument {
    _private: (),
}
impl GetDocument {
    /// Creates a new builder-style object to manufacture [`GetDocumentInput`](crate::input::GetDocumentInput)
    pub fn builder() -> crate::input::get_document_input::Builder {
        crate::input::get_document_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::GetDocumentOutput, crate::error::GetDocumentError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetDocumentError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetDocumentError {
                        kind: crate::error::GetDocumentErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetDocumentError::unhandled(e),
                },
                "InvalidDocument" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetDocumentError {
                        kind: crate::error::GetDocumentErrorKind::InvalidDocument(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetDocumentError::unhandled(e),
                },
                "InvalidDocumentVersion" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetDocumentError {
                        kind: crate::error::GetDocumentErrorKind::InvalidDocumentVersion(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetDocumentError::unhandled(e),
                },
                _ => crate::error::GetDocumentError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::get_document_output::Builder::default();
        builder =
            crate::json_deser::get_document_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::GetDocumentError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetDocument {
    type Output = Result<crate::output::GetDocumentOutput, crate::error::GetDocumentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Query inventory information.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct GetInventory {
    _private: (),
}
impl GetInventory {
    /// Creates a new builder-style object to manufacture [`GetInventoryInput`](crate::input::GetInventoryInput)
    pub fn builder() -> crate::input::get_inventory_input::Builder {
        crate::input::get_inventory_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::GetInventoryOutput, crate::error::GetInventoryError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetInventoryError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetInventoryError {
                        kind: crate::error::GetInventoryErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetInventoryError::unhandled(e),
                },
                "InvalidAggregatorException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetInventoryError {
                        kind: crate::error::GetInventoryErrorKind::InvalidAggregatorError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetInventoryError::unhandled(e),
                },
                "InvalidFilter" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetInventoryError {
                        kind: crate::error::GetInventoryErrorKind::InvalidFilter(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetInventoryError::unhandled(e),
                },
                "InvalidInventoryGroupException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetInventoryError {
                        kind: crate::error::GetInventoryErrorKind::InvalidInventoryGroupError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetInventoryError::unhandled(e),
                },
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetInventoryError {
                        kind: crate::error::GetInventoryErrorKind::InvalidNextToken(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetInventoryError::unhandled(e),
                },
                "InvalidResultAttributeException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetInventoryError {
                        kind: crate::error::GetInventoryErrorKind::InvalidResultAttributeError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetInventoryError::unhandled(e),
                },
                "InvalidTypeNameException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetInventoryError {
                        kind: crate::error::GetInventoryErrorKind::InvalidTypeNameError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetInventoryError::unhandled(e),
                },
                _ => crate::error::GetInventoryError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::get_inventory_output::Builder::default();
        builder =
            crate::json_deser::get_inventory_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::GetInventoryError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetInventory {
    type Output = Result<crate::output::GetInventoryOutput, crate::error::GetInventoryError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Return a list of inventory type names for the account, or return a list of attribute names
/// for a specific Inventory item type.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct GetInventorySchema {
    _private: (),
}
impl GetInventorySchema {
    /// Creates a new builder-style object to manufacture [`GetInventorySchemaInput`](crate::input::GetInventorySchemaInput)
    pub fn builder() -> crate::input::get_inventory_schema_input::Builder {
        crate::input::get_inventory_schema_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::GetInventorySchemaOutput, crate::error::GetInventorySchemaError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetInventorySchemaError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetInventorySchemaError {
                        kind: crate::error::GetInventorySchemaErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetInventorySchemaError::unhandled(e),
                },
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetInventorySchemaError {
                        kind: crate::error::GetInventorySchemaErrorKind::InvalidNextToken(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetInventorySchemaError::unhandled(e),
                },
                "InvalidTypeNameException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetInventorySchemaError {
                        kind: crate::error::GetInventorySchemaErrorKind::InvalidTypeNameError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetInventorySchemaError::unhandled(e),
                },
                _ => crate::error::GetInventorySchemaError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::get_inventory_schema_output::Builder::default();
        builder = crate::json_deser::get_inventory_schema_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::GetInventorySchemaError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetInventorySchema {
    type Output =
        Result<crate::output::GetInventorySchemaOutput, crate::error::GetInventorySchemaError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Retrieves a maintenance window.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct GetMaintenanceWindow {
    _private: (),
}
impl GetMaintenanceWindow {
    /// Creates a new builder-style object to manufacture [`GetMaintenanceWindowInput`](crate::input::GetMaintenanceWindowInput)
    pub fn builder() -> crate::input::get_maintenance_window_input::Builder {
        crate::input::get_maintenance_window_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::GetMaintenanceWindowOutput, crate::error::GetMaintenanceWindowError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetMaintenanceWindowError::unhandled(generic)),
            };
            return Err(match error_code {
                "DoesNotExistException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetMaintenanceWindowError {
                        kind: crate::error::GetMaintenanceWindowErrorKind::DoesNotExistError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetMaintenanceWindowError::unhandled(e),
                },
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetMaintenanceWindowError {
                        kind: crate::error::GetMaintenanceWindowErrorKind::InternalServerError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetMaintenanceWindowError::unhandled(e),
                },
                _ => crate::error::GetMaintenanceWindowError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::get_maintenance_window_output::Builder::default();
        builder = crate::json_deser::get_maintenance_window_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::GetMaintenanceWindowError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetMaintenanceWindow {
    type Output =
        Result<crate::output::GetMaintenanceWindowOutput, crate::error::GetMaintenanceWindowError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Retrieves details about a specific a maintenance window execution.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct GetMaintenanceWindowExecution {
    _private: (),
}
impl GetMaintenanceWindowExecution {
    /// Creates a new builder-style object to manufacture [`GetMaintenanceWindowExecutionInput`](crate::input::GetMaintenanceWindowExecutionInput)
    pub fn builder() -> crate::input::get_maintenance_window_execution_input::Builder {
        crate::input::get_maintenance_window_execution_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::GetMaintenanceWindowExecutionOutput,
        crate::error::GetMaintenanceWindowExecutionError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::GetMaintenanceWindowExecutionError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "DoesNotExistException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetMaintenanceWindowExecutionError { kind: crate::error::GetMaintenanceWindowExecutionErrorKind::DoesNotExistError(body), meta: generic },
                    Err(e) => crate::error::GetMaintenanceWindowExecutionError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetMaintenanceWindowExecutionError { kind: crate::error::GetMaintenanceWindowExecutionErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::GetMaintenanceWindowExecutionError::unhandled(e)
                }
                _ => crate::error::GetMaintenanceWindowExecutionError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::get_maintenance_window_execution_output::Builder::default();
        builder = crate::json_deser::get_maintenance_window_execution_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::GetMaintenanceWindowExecutionError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetMaintenanceWindowExecution {
    type Output = Result<
        crate::output::GetMaintenanceWindowExecutionOutput,
        crate::error::GetMaintenanceWindowExecutionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Retrieves the details about a specific task run as part of a maintenance window
/// execution.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct GetMaintenanceWindowExecutionTask {
    _private: (),
}
impl GetMaintenanceWindowExecutionTask {
    /// Creates a new builder-style object to manufacture [`GetMaintenanceWindowExecutionTaskInput`](crate::input::GetMaintenanceWindowExecutionTaskInput)
    pub fn builder() -> crate::input::get_maintenance_window_execution_task_input::Builder {
        crate::input::get_maintenance_window_execution_task_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::GetMaintenanceWindowExecutionTaskOutput,
        crate::error::GetMaintenanceWindowExecutionTaskError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(
                        crate::error::GetMaintenanceWindowExecutionTaskError::unhandled(generic),
                    )
                }
            };
            return Err(match error_code {
                "DoesNotExistException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetMaintenanceWindowExecutionTaskError { kind: crate::error::GetMaintenanceWindowExecutionTaskErrorKind::DoesNotExistError(body), meta: generic },
                    Err(e) => crate::error::GetMaintenanceWindowExecutionTaskError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetMaintenanceWindowExecutionTaskError { kind: crate::error::GetMaintenanceWindowExecutionTaskErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::GetMaintenanceWindowExecutionTaskError::unhandled(e)
                }
                _ => crate::error::GetMaintenanceWindowExecutionTaskError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::get_maintenance_window_execution_task_output::Builder::default();
        builder = crate::json_deser::get_maintenance_window_execution_task_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::GetMaintenanceWindowExecutionTaskError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetMaintenanceWindowExecutionTask {
    type Output = Result<
        crate::output::GetMaintenanceWindowExecutionTaskOutput,
        crate::error::GetMaintenanceWindowExecutionTaskError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Retrieves information about a specific task running on a specific target.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct GetMaintenanceWindowExecutionTaskInvocation {
    _private: (),
}
impl GetMaintenanceWindowExecutionTaskInvocation {
    /// Creates a new builder-style object to manufacture [`GetMaintenanceWindowExecutionTaskInvocationInput`](crate::input::GetMaintenanceWindowExecutionTaskInvocationInput)
    pub fn builder() -> crate::input::get_maintenance_window_execution_task_invocation_input::Builder
    {
        crate::input::get_maintenance_window_execution_task_invocation_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::GetMaintenanceWindowExecutionTaskInvocationOutput,
        crate::error::GetMaintenanceWindowExecutionTaskInvocationError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code =
                match generic.code() {
                    Some(code) => code,
                    None => return Err(
                        crate::error::GetMaintenanceWindowExecutionTaskInvocationError::unhandled(
                            generic,
                        ),
                    ),
                };
            return Err(match error_code {
                "DoesNotExistException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetMaintenanceWindowExecutionTaskInvocationError { kind: crate::error::GetMaintenanceWindowExecutionTaskInvocationErrorKind::DoesNotExistError(body), meta: generic },
                    Err(e) => crate::error::GetMaintenanceWindowExecutionTaskInvocationError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetMaintenanceWindowExecutionTaskInvocationError { kind: crate::error::GetMaintenanceWindowExecutionTaskInvocationErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::GetMaintenanceWindowExecutionTaskInvocationError::unhandled(e)
                }
                _ => crate::error::GetMaintenanceWindowExecutionTaskInvocationError::generic(generic)
            });
        }
        #[allow(unused_mut)]let mut builder = crate::output::get_maintenance_window_execution_task_invocation_output::Builder::default();
        builder =
            crate::json_deser::get_maintenance_window_execution_task_invocation_deser_operation(
                response.body().as_ref(),
                builder,
            )
            .map_err(crate::error::GetMaintenanceWindowExecutionTaskInvocationError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetMaintenanceWindowExecutionTaskInvocation {
    type Output = Result<
        crate::output::GetMaintenanceWindowExecutionTaskInvocationOutput,
        crate::error::GetMaintenanceWindowExecutionTaskInvocationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists the tasks in a maintenance window.</p>
/// <note>
/// <p>For maintenance window tasks without a specified target, you cannot supply values for
/// <code>--max-errors</code> and <code>--max-concurrency</code>. Instead, the system inserts a
/// placeholder value of <code>1</code>, which may be reported in the response to this command.
/// These values do not affect the running of your task and can be ignored.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone)]
pub struct GetMaintenanceWindowTask {
    _private: (),
}
impl GetMaintenanceWindowTask {
    /// Creates a new builder-style object to manufacture [`GetMaintenanceWindowTaskInput`](crate::input::GetMaintenanceWindowTaskInput)
    pub fn builder() -> crate::input::get_maintenance_window_task_input::Builder {
        crate::input::get_maintenance_window_task_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::GetMaintenanceWindowTaskOutput,
        crate::error::GetMaintenanceWindowTaskError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::GetMaintenanceWindowTaskError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "DoesNotExistException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetMaintenanceWindowTaskError {
                        kind: crate::error::GetMaintenanceWindowTaskErrorKind::DoesNotExistError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetMaintenanceWindowTaskError::unhandled(e),
                },
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetMaintenanceWindowTaskError {
                        kind: crate::error::GetMaintenanceWindowTaskErrorKind::InternalServerError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetMaintenanceWindowTaskError::unhandled(e),
                },
                _ => crate::error::GetMaintenanceWindowTaskError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::get_maintenance_window_task_output::Builder::default();
        builder = crate::json_deser::get_maintenance_window_task_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::GetMaintenanceWindowTaskError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetMaintenanceWindowTask {
    type Output = Result<
        crate::output::GetMaintenanceWindowTaskOutput,
        crate::error::GetMaintenanceWindowTaskError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Get information about an OpsItem by using the ID. You must have permission in AWS Identity
/// and Access Management (IAM) to view information about an OpsItem. For more information, see
/// <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-getting-started.html">Getting started with
/// OpsCenter</a> in the <i>AWS Systems Manager User Guide</i>.</p>
/// <p>Operations engineers and IT professionals use OpsCenter to view, investigate, and remediate
/// operational issues impacting the performance and health of their AWS resources. For more
/// information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter.html">AWS Systems Manager OpsCenter</a> in the
/// <i>AWS Systems Manager User Guide</i>. </p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct GetOpsItem {
    _private: (),
}
impl GetOpsItem {
    /// Creates a new builder-style object to manufacture [`GetOpsItemInput`](crate::input::GetOpsItemInput)
    pub fn builder() -> crate::input::get_ops_item_input::Builder {
        crate::input::get_ops_item_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::GetOpsItemOutput, crate::error::GetOpsItemError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetOpsItemError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetOpsItemError {
                        kind: crate::error::GetOpsItemErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetOpsItemError::unhandled(e),
                },
                "OpsItemNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetOpsItemError {
                        kind: crate::error::GetOpsItemErrorKind::OpsItemNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetOpsItemError::unhandled(e),
                },
                _ => crate::error::GetOpsItemError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::get_ops_item_output::Builder::default();
        builder =
            crate::json_deser::get_ops_item_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::GetOpsItemError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetOpsItem {
    type Output = Result<crate::output::GetOpsItemOutput, crate::error::GetOpsItemError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>View operational metadata related to an application in Application Manager.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct GetOpsMetadata {
    _private: (),
}
impl GetOpsMetadata {
    /// Creates a new builder-style object to manufacture [`GetOpsMetadataInput`](crate::input::GetOpsMetadataInput)
    pub fn builder() -> crate::input::get_ops_metadata_input::Builder {
        crate::input::get_ops_metadata_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::GetOpsMetadataOutput, crate::error::GetOpsMetadataError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetOpsMetadataError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetOpsMetadataError {
                        kind: crate::error::GetOpsMetadataErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetOpsMetadataError::unhandled(e),
                },
                "OpsMetadataInvalidArgumentException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetOpsMetadataError {
                        kind:
                            crate::error::GetOpsMetadataErrorKind::OpsMetadataInvalidArgumentError(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetOpsMetadataError::unhandled(e),
                },
                "OpsMetadataNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetOpsMetadataError {
                        kind: crate::error::GetOpsMetadataErrorKind::OpsMetadataNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetOpsMetadataError::unhandled(e),
                },
                _ => crate::error::GetOpsMetadataError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::get_ops_metadata_output::Builder::default();
        builder =
            crate::json_deser::get_ops_metadata_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::GetOpsMetadataError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetOpsMetadata {
    type Output = Result<crate::output::GetOpsMetadataOutput, crate::error::GetOpsMetadataError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>View a summary of OpsItems based on specified filters and aggregators.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct GetOpsSummary {
    _private: (),
}
impl GetOpsSummary {
    /// Creates a new builder-style object to manufacture [`GetOpsSummaryInput`](crate::input::GetOpsSummaryInput)
    pub fn builder() -> crate::input::get_ops_summary_input::Builder {
        crate::input::get_ops_summary_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::GetOpsSummaryOutput, crate::error::GetOpsSummaryError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetOpsSummaryError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetOpsSummaryError {
                        kind: crate::error::GetOpsSummaryErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetOpsSummaryError::unhandled(e),
                },
                "InvalidAggregatorException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetOpsSummaryError {
                        kind: crate::error::GetOpsSummaryErrorKind::InvalidAggregatorError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetOpsSummaryError::unhandled(e),
                },
                "InvalidFilter" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetOpsSummaryError {
                        kind: crate::error::GetOpsSummaryErrorKind::InvalidFilter(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetOpsSummaryError::unhandled(e),
                },
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetOpsSummaryError {
                        kind: crate::error::GetOpsSummaryErrorKind::InvalidNextToken(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetOpsSummaryError::unhandled(e),
                },
                "InvalidTypeNameException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetOpsSummaryError {
                        kind: crate::error::GetOpsSummaryErrorKind::InvalidTypeNameError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetOpsSummaryError::unhandled(e),
                },
                "ResourceDataSyncNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetOpsSummaryError {
                        kind: crate::error::GetOpsSummaryErrorKind::ResourceDataSyncNotFoundError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetOpsSummaryError::unhandled(e),
                },
                _ => crate::error::GetOpsSummaryError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::get_ops_summary_output::Builder::default();
        builder =
            crate::json_deser::get_ops_summary_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::GetOpsSummaryError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetOpsSummary {
    type Output = Result<crate::output::GetOpsSummaryOutput, crate::error::GetOpsSummaryError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Get information about a parameter by using the parameter name. Don't confuse this API action
/// with the <a>GetParameters</a> API action.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct GetParameter {
    _private: (),
}
impl GetParameter {
    /// Creates a new builder-style object to manufacture [`GetParameterInput`](crate::input::GetParameterInput)
    pub fn builder() -> crate::input::get_parameter_input::Builder {
        crate::input::get_parameter_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::GetParameterOutput, crate::error::GetParameterError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetParameterError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetParameterError {
                        kind: crate::error::GetParameterErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetParameterError::unhandled(e),
                },
                "InvalidKeyId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetParameterError {
                        kind: crate::error::GetParameterErrorKind::InvalidKeyId(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetParameterError::unhandled(e),
                },
                "ParameterNotFound" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetParameterError {
                        kind: crate::error::GetParameterErrorKind::ParameterNotFound(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetParameterError::unhandled(e),
                },
                "ParameterVersionNotFound" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetParameterError {
                        kind: crate::error::GetParameterErrorKind::ParameterVersionNotFound(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetParameterError::unhandled(e),
                },
                _ => crate::error::GetParameterError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::get_parameter_output::Builder::default();
        builder =
            crate::json_deser::get_parameter_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::GetParameterError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetParameter {
    type Output = Result<crate::output::GetParameterOutput, crate::error::GetParameterError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Retrieves the history of all changes to a parameter.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct GetParameterHistory {
    _private: (),
}
impl GetParameterHistory {
    /// Creates a new builder-style object to manufacture [`GetParameterHistoryInput`](crate::input::GetParameterHistoryInput)
    pub fn builder() -> crate::input::get_parameter_history_input::Builder {
        crate::input::get_parameter_history_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::GetParameterHistoryOutput, crate::error::GetParameterHistoryError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetParameterHistoryError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetParameterHistoryError {
                        kind: crate::error::GetParameterHistoryErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetParameterHistoryError::unhandled(e),
                },
                "InvalidKeyId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetParameterHistoryError {
                        kind: crate::error::GetParameterHistoryErrorKind::InvalidKeyId(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetParameterHistoryError::unhandled(e),
                },
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetParameterHistoryError {
                        kind: crate::error::GetParameterHistoryErrorKind::InvalidNextToken(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetParameterHistoryError::unhandled(e),
                },
                "ParameterNotFound" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetParameterHistoryError {
                        kind: crate::error::GetParameterHistoryErrorKind::ParameterNotFound(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetParameterHistoryError::unhandled(e),
                },
                _ => crate::error::GetParameterHistoryError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::get_parameter_history_output::Builder::default();
        builder = crate::json_deser::get_parameter_history_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::GetParameterHistoryError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetParameterHistory {
    type Output =
        Result<crate::output::GetParameterHistoryOutput, crate::error::GetParameterHistoryError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Get details of a parameter. Don't confuse this API action with the <a>GetParameter</a> API action.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct GetParameters {
    _private: (),
}
impl GetParameters {
    /// Creates a new builder-style object to manufacture [`GetParametersInput`](crate::input::GetParametersInput)
    pub fn builder() -> crate::input::get_parameters_input::Builder {
        crate::input::get_parameters_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::GetParametersOutput, crate::error::GetParametersError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetParametersError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetParametersError {
                        kind: crate::error::GetParametersErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetParametersError::unhandled(e),
                },
                "InvalidKeyId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetParametersError {
                        kind: crate::error::GetParametersErrorKind::InvalidKeyId(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetParametersError::unhandled(e),
                },
                _ => crate::error::GetParametersError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::get_parameters_output::Builder::default();
        builder =
            crate::json_deser::get_parameters_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::GetParametersError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetParameters {
    type Output = Result<crate::output::GetParametersOutput, crate::error::GetParametersError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Retrieve information about one or more parameters in a specific hierarchy. </p>
/// <note>
/// <p>Request results are returned on a best-effort basis. If you specify <code>MaxResults</code>
/// in the request, the response includes information up to the limit specified. The number of items
/// returned, however, can be between zero and the value of <code>MaxResults</code>. If the service
/// reaches an internal limit while processing the results, it stops the operation and returns the
/// matching values up to that point and a <code>NextToken</code>. You can specify the
/// <code>NextToken</code> in a subsequent call to get the next set of results.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone)]
pub struct GetParametersByPath {
    _private: (),
}
impl GetParametersByPath {
    /// Creates a new builder-style object to manufacture [`GetParametersByPathInput`](crate::input::GetParametersByPathInput)
    pub fn builder() -> crate::input::get_parameters_by_path_input::Builder {
        crate::input::get_parameters_by_path_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::GetParametersByPathOutput, crate::error::GetParametersByPathError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetParametersByPathError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetParametersByPathError {
                        kind: crate::error::GetParametersByPathErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetParametersByPathError::unhandled(e),
                },
                "InvalidFilterKey" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetParametersByPathError {
                        kind: crate::error::GetParametersByPathErrorKind::InvalidFilterKey(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetParametersByPathError::unhandled(e),
                },
                "InvalidFilterOption" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetParametersByPathError {
                        kind: crate::error::GetParametersByPathErrorKind::InvalidFilterOption(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetParametersByPathError::unhandled(e),
                },
                "InvalidFilterValue" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetParametersByPathError {
                        kind: crate::error::GetParametersByPathErrorKind::InvalidFilterValue(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetParametersByPathError::unhandled(e),
                },
                "InvalidKeyId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetParametersByPathError {
                        kind: crate::error::GetParametersByPathErrorKind::InvalidKeyId(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetParametersByPathError::unhandled(e),
                },
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetParametersByPathError {
                        kind: crate::error::GetParametersByPathErrorKind::InvalidNextToken(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetParametersByPathError::unhandled(e),
                },
                _ => crate::error::GetParametersByPathError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::get_parameters_by_path_output::Builder::default();
        builder = crate::json_deser::get_parameters_by_path_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::GetParametersByPathError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetParametersByPath {
    type Output =
        Result<crate::output::GetParametersByPathOutput, crate::error::GetParametersByPathError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Retrieves information about a patch baseline.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct GetPatchBaseline {
    _private: (),
}
impl GetPatchBaseline {
    /// Creates a new builder-style object to manufacture [`GetPatchBaselineInput`](crate::input::GetPatchBaselineInput)
    pub fn builder() -> crate::input::get_patch_baseline_input::Builder {
        crate::input::get_patch_baseline_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::GetPatchBaselineOutput, crate::error::GetPatchBaselineError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetPatchBaselineError::unhandled(generic)),
            };
            return Err(match error_code {
                "DoesNotExistException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetPatchBaselineError {
                        kind: crate::error::GetPatchBaselineErrorKind::DoesNotExistError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetPatchBaselineError::unhandled(e),
                },
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetPatchBaselineError {
                        kind: crate::error::GetPatchBaselineErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetPatchBaselineError::unhandled(e),
                },
                "InvalidResourceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetPatchBaselineError {
                        kind: crate::error::GetPatchBaselineErrorKind::InvalidResourceId(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetPatchBaselineError::unhandled(e),
                },
                _ => crate::error::GetPatchBaselineError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::get_patch_baseline_output::Builder::default();
        builder = crate::json_deser::get_patch_baseline_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::GetPatchBaselineError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetPatchBaseline {
    type Output =
        Result<crate::output::GetPatchBaselineOutput, crate::error::GetPatchBaselineError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Retrieves the patch baseline that should be used for the specified patch group.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct GetPatchBaselineForPatchGroup {
    _private: (),
}
impl GetPatchBaselineForPatchGroup {
    /// Creates a new builder-style object to manufacture [`GetPatchBaselineForPatchGroupInput`](crate::input::GetPatchBaselineForPatchGroupInput)
    pub fn builder() -> crate::input::get_patch_baseline_for_patch_group_input::Builder {
        crate::input::get_patch_baseline_for_patch_group_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::GetPatchBaselineForPatchGroupOutput,
        crate::error::GetPatchBaselineForPatchGroupError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::GetPatchBaselineForPatchGroupError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetPatchBaselineForPatchGroupError { kind: crate::error::GetPatchBaselineForPatchGroupErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::GetPatchBaselineForPatchGroupError::unhandled(e)
                }
                _ => crate::error::GetPatchBaselineForPatchGroupError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::get_patch_baseline_for_patch_group_output::Builder::default();
        builder = crate::json_deser::get_patch_baseline_for_patch_group_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::GetPatchBaselineForPatchGroupError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetPatchBaselineForPatchGroup {
    type Output = Result<
        crate::output::GetPatchBaselineForPatchGroupOutput,
        crate::error::GetPatchBaselineForPatchGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>
/// <code>ServiceSetting</code> is an account-level setting for an AWS service. This setting
/// defines how a user interacts with or uses a service or a feature of a service. For example, if an
/// AWS service charges money to the account based on feature or service usage, then the AWS service
/// team might create a default setting of "false". This means the user can't use this feature unless
/// they change the setting to "true" and intentionally opt in for a paid feature.</p>
/// <p>Services map a <code>SettingId</code> object to a setting value. AWS services teams define
/// the default value for a <code>SettingId</code>. You can't create a new <code>SettingId</code>,
/// but you can overwrite the default value if you have the <code>ssm:UpdateServiceSetting</code>
/// permission for the setting. Use the <a>UpdateServiceSetting</a> API action to change
/// the default setting. Or use the <a>ResetServiceSetting</a> to change the value back to
/// the original value defined by the AWS service team.</p>
/// <p>Query the current service setting for the account. </p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct GetServiceSetting {
    _private: (),
}
impl GetServiceSetting {
    /// Creates a new builder-style object to manufacture [`GetServiceSettingInput`](crate::input::GetServiceSettingInput)
    pub fn builder() -> crate::input::get_service_setting_input::Builder {
        crate::input::get_service_setting_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::GetServiceSettingOutput, crate::error::GetServiceSettingError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetServiceSettingError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetServiceSettingError {
                        kind: crate::error::GetServiceSettingErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetServiceSettingError::unhandled(e),
                },
                "ServiceSettingNotFound" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetServiceSettingError {
                        kind: crate::error::GetServiceSettingErrorKind::ServiceSettingNotFound(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetServiceSettingError::unhandled(e),
                },
                _ => crate::error::GetServiceSettingError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::get_service_setting_output::Builder::default();
        builder = crate::json_deser::get_service_setting_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::GetServiceSettingError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetServiceSetting {
    type Output =
        Result<crate::output::GetServiceSettingOutput, crate::error::GetServiceSettingError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>A parameter label is a user-defined alias to help you manage different versions of a
/// parameter. When you modify a parameter, Systems Manager automatically saves a new version and increments
/// the version number by one. A label can help you remember the purpose of a parameter when there
/// are multiple versions. </p>
/// <p>Parameter labels have the following requirements and restrictions.</p>
/// <ul>
/// <li>
/// <p>A version of a parameter can have a maximum of 10 labels.</p>
/// </li>
/// <li>
/// <p>You can't attach the same label to different versions of the same parameter. For example,
/// if version 1 has the label Production, then you can't attach Production to version 2.</p>
/// </li>
/// <li>
/// <p>You can move a label from one version of a parameter to another.</p>
/// </li>
/// <li>
/// <p>You can't create a label when you create a new parameter. You must attach a label to a
/// specific version of a parameter.</p>
/// </li>
/// <li>
/// <p>If you no longer want to use a parameter label, then you can either delete it or move it
/// to a different version of a parameter.</p>
/// </li>
/// <li>
/// <p>A label can have a maximum of 100 characters.</p>
/// </li>
/// <li>
/// <p>Labels can contain letters (case sensitive), numbers, periods (.), hyphens (-), or
/// underscores (_).</p>
/// </li>
/// <li>
/// <p>Labels can't begin with a number, "aws," or "ssm" (not case sensitive). If a label fails
/// to meet these requirements, then the label is not associated with a parameter and the system
/// displays it in the list of InvalidLabels.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone)]
pub struct LabelParameterVersion {
    _private: (),
}
impl LabelParameterVersion {
    /// Creates a new builder-style object to manufacture [`LabelParameterVersionInput`](crate::input::LabelParameterVersionInput)
    pub fn builder() -> crate::input::label_parameter_version_input::Builder {
        crate::input::label_parameter_version_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::LabelParameterVersionOutput, crate::error::LabelParameterVersionError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::LabelParameterVersionError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::LabelParameterVersionError { kind: crate::error::LabelParameterVersionErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::LabelParameterVersionError::unhandled(e)
                }
                "ParameterNotFound" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::LabelParameterVersionError { kind: crate::error::LabelParameterVersionErrorKind::ParameterNotFound(body), meta: generic },
                    Err(e) => crate::error::LabelParameterVersionError::unhandled(e)
                }
                "ParameterVersionLabelLimitExceeded" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::LabelParameterVersionError { kind: crate::error::LabelParameterVersionErrorKind::ParameterVersionLabelLimitExceeded(body), meta: generic },
                    Err(e) => crate::error::LabelParameterVersionError::unhandled(e)
                }
                "ParameterVersionNotFound" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::LabelParameterVersionError { kind: crate::error::LabelParameterVersionErrorKind::ParameterVersionNotFound(body), meta: generic },
                    Err(e) => crate::error::LabelParameterVersionError::unhandled(e)
                }
                "TooManyUpdates" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::LabelParameterVersionError { kind: crate::error::LabelParameterVersionErrorKind::TooManyUpdates(body), meta: generic },
                    Err(e) => crate::error::LabelParameterVersionError::unhandled(e)
                }
                _ => crate::error::LabelParameterVersionError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::label_parameter_version_output::Builder::default();
        builder = crate::json_deser::label_parameter_version_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::LabelParameterVersionError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for LabelParameterVersion {
    type Output = Result<
        crate::output::LabelParameterVersionOutput,
        crate::error::LabelParameterVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns all State Manager associations in the current AWS account and Region. You can limit
/// the results to a specific State Manager association document or instance by specifying a
/// filter.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct ListAssociations {
    _private: (),
}
impl ListAssociations {
    /// Creates a new builder-style object to manufacture [`ListAssociationsInput`](crate::input::ListAssociationsInput)
    pub fn builder() -> crate::input::list_associations_input::Builder {
        crate::input::list_associations_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::ListAssociationsOutput, crate::error::ListAssociationsError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::ListAssociationsError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListAssociationsError {
                        kind: crate::error::ListAssociationsErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListAssociationsError::unhandled(e),
                },
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListAssociationsError {
                        kind: crate::error::ListAssociationsErrorKind::InvalidNextToken(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListAssociationsError::unhandled(e),
                },
                _ => crate::error::ListAssociationsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::list_associations_output::Builder::default();
        builder =
            crate::json_deser::list_associations_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::ListAssociationsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ListAssociations {
    type Output =
        Result<crate::output::ListAssociationsOutput, crate::error::ListAssociationsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Retrieves all versions of an association for a specific association ID.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct ListAssociationVersions {
    _private: (),
}
impl ListAssociationVersions {
    /// Creates a new builder-style object to manufacture [`ListAssociationVersionsInput`](crate::input::ListAssociationVersionsInput)
    pub fn builder() -> crate::input::list_association_versions_input::Builder {
        crate::input::list_association_versions_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::ListAssociationVersionsOutput,
        crate::error::ListAssociationVersionsError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::ListAssociationVersionsError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "AssociationDoesNotExist" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListAssociationVersionsError {
                        kind:
                            crate::error::ListAssociationVersionsErrorKind::AssociationDoesNotExist(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListAssociationVersionsError::unhandled(e),
                },
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListAssociationVersionsError {
                        kind: crate::error::ListAssociationVersionsErrorKind::InternalServerError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListAssociationVersionsError::unhandled(e),
                },
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListAssociationVersionsError {
                        kind: crate::error::ListAssociationVersionsErrorKind::InvalidNextToken(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListAssociationVersionsError::unhandled(e),
                },
                _ => crate::error::ListAssociationVersionsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::list_association_versions_output::Builder::default();
        builder = crate::json_deser::list_association_versions_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::ListAssociationVersionsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ListAssociationVersions {
    type Output = Result<
        crate::output::ListAssociationVersionsOutput,
        crate::error::ListAssociationVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>An invocation is copy of a command sent to a specific instance. A command can apply to one
/// or more instances. A command invocation applies to one instance. For example, if a user runs
/// SendCommand against three instances, then a command invocation is created for each requested
/// instance ID. ListCommandInvocations provide status about command execution.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct ListCommandInvocations {
    _private: (),
}
impl ListCommandInvocations {
    /// Creates a new builder-style object to manufacture [`ListCommandInvocationsInput`](crate::input::ListCommandInvocationsInput)
    pub fn builder() -> crate::input::list_command_invocations_input::Builder {
        crate::input::list_command_invocations_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::ListCommandInvocationsOutput,
        crate::error::ListCommandInvocationsError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::ListCommandInvocationsError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListCommandInvocationsError {
                        kind: crate::error::ListCommandInvocationsErrorKind::InternalServerError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListCommandInvocationsError::unhandled(e),
                },
                "InvalidCommandId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListCommandInvocationsError {
                        kind: crate::error::ListCommandInvocationsErrorKind::InvalidCommandId(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListCommandInvocationsError::unhandled(e),
                },
                "InvalidFilterKey" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListCommandInvocationsError {
                        kind: crate::error::ListCommandInvocationsErrorKind::InvalidFilterKey(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListCommandInvocationsError::unhandled(e),
                },
                "InvalidInstanceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListCommandInvocationsError {
                        kind: crate::error::ListCommandInvocationsErrorKind::InvalidInstanceId(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListCommandInvocationsError::unhandled(e),
                },
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListCommandInvocationsError {
                        kind: crate::error::ListCommandInvocationsErrorKind::InvalidNextToken(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListCommandInvocationsError::unhandled(e),
                },
                _ => crate::error::ListCommandInvocationsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::list_command_invocations_output::Builder::default();
        builder = crate::json_deser::list_command_invocations_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::ListCommandInvocationsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ListCommandInvocations {
    type Output = Result<
        crate::output::ListCommandInvocationsOutput,
        crate::error::ListCommandInvocationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists the commands requested by users of the AWS account.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct ListCommands {
    _private: (),
}
impl ListCommands {
    /// Creates a new builder-style object to manufacture [`ListCommandsInput`](crate::input::ListCommandsInput)
    pub fn builder() -> crate::input::list_commands_input::Builder {
        crate::input::list_commands_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::ListCommandsOutput, crate::error::ListCommandsError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::ListCommandsError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListCommandsError {
                        kind: crate::error::ListCommandsErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListCommandsError::unhandled(e),
                },
                "InvalidCommandId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListCommandsError {
                        kind: crate::error::ListCommandsErrorKind::InvalidCommandId(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListCommandsError::unhandled(e),
                },
                "InvalidFilterKey" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListCommandsError {
                        kind: crate::error::ListCommandsErrorKind::InvalidFilterKey(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListCommandsError::unhandled(e),
                },
                "InvalidInstanceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListCommandsError {
                        kind: crate::error::ListCommandsErrorKind::InvalidInstanceId(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListCommandsError::unhandled(e),
                },
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListCommandsError {
                        kind: crate::error::ListCommandsErrorKind::InvalidNextToken(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListCommandsError::unhandled(e),
                },
                _ => crate::error::ListCommandsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::list_commands_output::Builder::default();
        builder =
            crate::json_deser::list_commands_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::ListCommandsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ListCommands {
    type Output = Result<crate::output::ListCommandsOutput, crate::error::ListCommandsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>For a specified resource ID, this API action returns a list of compliance statuses for
/// different resource types. Currently, you can only specify one resource ID per call. List results
/// depend on the criteria specified in the filter.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct ListComplianceItems {
    _private: (),
}
impl ListComplianceItems {
    /// Creates a new builder-style object to manufacture [`ListComplianceItemsInput`](crate::input::ListComplianceItemsInput)
    pub fn builder() -> crate::input::list_compliance_items_input::Builder {
        crate::input::list_compliance_items_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::ListComplianceItemsOutput, crate::error::ListComplianceItemsError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::ListComplianceItemsError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListComplianceItemsError {
                        kind: crate::error::ListComplianceItemsErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListComplianceItemsError::unhandled(e),
                },
                "InvalidFilter" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListComplianceItemsError {
                        kind: crate::error::ListComplianceItemsErrorKind::InvalidFilter(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListComplianceItemsError::unhandled(e),
                },
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListComplianceItemsError {
                        kind: crate::error::ListComplianceItemsErrorKind::InvalidNextToken(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListComplianceItemsError::unhandled(e),
                },
                "InvalidResourceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListComplianceItemsError {
                        kind: crate::error::ListComplianceItemsErrorKind::InvalidResourceId(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListComplianceItemsError::unhandled(e),
                },
                "InvalidResourceType" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListComplianceItemsError {
                        kind: crate::error::ListComplianceItemsErrorKind::InvalidResourceType(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListComplianceItemsError::unhandled(e),
                },
                _ => crate::error::ListComplianceItemsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::list_compliance_items_output::Builder::default();
        builder = crate::json_deser::list_compliance_items_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::ListComplianceItemsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ListComplianceItems {
    type Output =
        Result<crate::output::ListComplianceItemsOutput, crate::error::ListComplianceItemsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns a summary count of compliant and non-compliant resources for a compliance type. For
/// example, this call can return State Manager associations, patches, or custom compliance types
/// according to the filter criteria that you specify.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct ListComplianceSummaries {
    _private: (),
}
impl ListComplianceSummaries {
    /// Creates a new builder-style object to manufacture [`ListComplianceSummariesInput`](crate::input::ListComplianceSummariesInput)
    pub fn builder() -> crate::input::list_compliance_summaries_input::Builder {
        crate::input::list_compliance_summaries_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::ListComplianceSummariesOutput,
        crate::error::ListComplianceSummariesError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::ListComplianceSummariesError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListComplianceSummariesError {
                        kind: crate::error::ListComplianceSummariesErrorKind::InternalServerError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListComplianceSummariesError::unhandled(e),
                },
                "InvalidFilter" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListComplianceSummariesError {
                        kind: crate::error::ListComplianceSummariesErrorKind::InvalidFilter(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListComplianceSummariesError::unhandled(e),
                },
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListComplianceSummariesError {
                        kind: crate::error::ListComplianceSummariesErrorKind::InvalidNextToken(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListComplianceSummariesError::unhandled(e),
                },
                _ => crate::error::ListComplianceSummariesError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::list_compliance_summaries_output::Builder::default();
        builder = crate::json_deser::list_compliance_summaries_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::ListComplianceSummariesError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ListComplianceSummaries {
    type Output = Result<
        crate::output::ListComplianceSummariesOutput,
        crate::error::ListComplianceSummariesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Information about approval reviews for a version of an SSM document.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct ListDocumentMetadataHistory {
    _private: (),
}
impl ListDocumentMetadataHistory {
    /// Creates a new builder-style object to manufacture [`ListDocumentMetadataHistoryInput`](crate::input::ListDocumentMetadataHistoryInput)
    pub fn builder() -> crate::input::list_document_metadata_history_input::Builder {
        crate::input::list_document_metadata_history_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::ListDocumentMetadataHistoryOutput,
        crate::error::ListDocumentMetadataHistoryError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::ListDocumentMetadataHistoryError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListDocumentMetadataHistoryError { kind: crate::error::ListDocumentMetadataHistoryErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::ListDocumentMetadataHistoryError::unhandled(e)
                }
                "InvalidDocument" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListDocumentMetadataHistoryError { kind: crate::error::ListDocumentMetadataHistoryErrorKind::InvalidDocument(body), meta: generic },
                    Err(e) => crate::error::ListDocumentMetadataHistoryError::unhandled(e)
                }
                "InvalidDocumentVersion" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListDocumentMetadataHistoryError { kind: crate::error::ListDocumentMetadataHistoryErrorKind::InvalidDocumentVersion(body), meta: generic },
                    Err(e) => crate::error::ListDocumentMetadataHistoryError::unhandled(e)
                }
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListDocumentMetadataHistoryError { kind: crate::error::ListDocumentMetadataHistoryErrorKind::InvalidNextToken(body), meta: generic },
                    Err(e) => crate::error::ListDocumentMetadataHistoryError::unhandled(e)
                }
                _ => crate::error::ListDocumentMetadataHistoryError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::list_document_metadata_history_output::Builder::default();
        builder = crate::json_deser::list_document_metadata_history_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::ListDocumentMetadataHistoryError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ListDocumentMetadataHistory {
    type Output = Result<
        crate::output::ListDocumentMetadataHistoryOutput,
        crate::error::ListDocumentMetadataHistoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns all Systems Manager (SSM) documents in the current AWS account and Region. You can limit the
/// results of this request by using a filter.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct ListDocuments {
    _private: (),
}
impl ListDocuments {
    /// Creates a new builder-style object to manufacture [`ListDocumentsInput`](crate::input::ListDocumentsInput)
    pub fn builder() -> crate::input::list_documents_input::Builder {
        crate::input::list_documents_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::ListDocumentsOutput, crate::error::ListDocumentsError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::ListDocumentsError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListDocumentsError {
                        kind: crate::error::ListDocumentsErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListDocumentsError::unhandled(e),
                },
                "InvalidFilterKey" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListDocumentsError {
                        kind: crate::error::ListDocumentsErrorKind::InvalidFilterKey(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListDocumentsError::unhandled(e),
                },
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListDocumentsError {
                        kind: crate::error::ListDocumentsErrorKind::InvalidNextToken(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListDocumentsError::unhandled(e),
                },
                _ => crate::error::ListDocumentsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::list_documents_output::Builder::default();
        builder =
            crate::json_deser::list_documents_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::ListDocumentsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ListDocuments {
    type Output = Result<crate::output::ListDocumentsOutput, crate::error::ListDocumentsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>List all versions for a document.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct ListDocumentVersions {
    _private: (),
}
impl ListDocumentVersions {
    /// Creates a new builder-style object to manufacture [`ListDocumentVersionsInput`](crate::input::ListDocumentVersionsInput)
    pub fn builder() -> crate::input::list_document_versions_input::Builder {
        crate::input::list_document_versions_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::ListDocumentVersionsOutput, crate::error::ListDocumentVersionsError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::ListDocumentVersionsError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListDocumentVersionsError {
                        kind: crate::error::ListDocumentVersionsErrorKind::InternalServerError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListDocumentVersionsError::unhandled(e),
                },
                "InvalidDocument" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListDocumentVersionsError {
                        kind: crate::error::ListDocumentVersionsErrorKind::InvalidDocument(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListDocumentVersionsError::unhandled(e),
                },
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListDocumentVersionsError {
                        kind: crate::error::ListDocumentVersionsErrorKind::InvalidNextToken(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListDocumentVersionsError::unhandled(e),
                },
                _ => crate::error::ListDocumentVersionsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::list_document_versions_output::Builder::default();
        builder = crate::json_deser::list_document_versions_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::ListDocumentVersionsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ListDocumentVersions {
    type Output =
        Result<crate::output::ListDocumentVersionsOutput, crate::error::ListDocumentVersionsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>A list of inventory items returned by the request.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct ListInventoryEntries {
    _private: (),
}
impl ListInventoryEntries {
    /// Creates a new builder-style object to manufacture [`ListInventoryEntriesInput`](crate::input::ListInventoryEntriesInput)
    pub fn builder() -> crate::input::list_inventory_entries_input::Builder {
        crate::input::list_inventory_entries_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::ListInventoryEntriesOutput, crate::error::ListInventoryEntriesError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::ListInventoryEntriesError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListInventoryEntriesError {
                        kind: crate::error::ListInventoryEntriesErrorKind::InternalServerError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListInventoryEntriesError::unhandled(e),
                },
                "InvalidFilter" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListInventoryEntriesError {
                        kind: crate::error::ListInventoryEntriesErrorKind::InvalidFilter(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListInventoryEntriesError::unhandled(e),
                },
                "InvalidInstanceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListInventoryEntriesError {
                        kind: crate::error::ListInventoryEntriesErrorKind::InvalidInstanceId(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListInventoryEntriesError::unhandled(e),
                },
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListInventoryEntriesError {
                        kind: crate::error::ListInventoryEntriesErrorKind::InvalidNextToken(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListInventoryEntriesError::unhandled(e),
                },
                "InvalidTypeNameException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListInventoryEntriesError {
                        kind: crate::error::ListInventoryEntriesErrorKind::InvalidTypeNameError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListInventoryEntriesError::unhandled(e),
                },
                _ => crate::error::ListInventoryEntriesError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::list_inventory_entries_output::Builder::default();
        builder = crate::json_deser::list_inventory_entries_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::ListInventoryEntriesError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ListInventoryEntries {
    type Output =
        Result<crate::output::ListInventoryEntriesOutput, crate::error::ListInventoryEntriesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns a list of all OpsItem events in the current AWS account and Region. You can limit
/// the results to events associated with specific OpsItems by specifying a filter.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct ListOpsItemEvents {
    _private: (),
}
impl ListOpsItemEvents {
    /// Creates a new builder-style object to manufacture [`ListOpsItemEventsInput`](crate::input::ListOpsItemEventsInput)
    pub fn builder() -> crate::input::list_ops_item_events_input::Builder {
        crate::input::list_ops_item_events_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::ListOpsItemEventsOutput, crate::error::ListOpsItemEventsError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::ListOpsItemEventsError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListOpsItemEventsError {
                        kind: crate::error::ListOpsItemEventsErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListOpsItemEventsError::unhandled(e),
                },
                "OpsItemInvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListOpsItemEventsError {
                        kind:
                            crate::error::ListOpsItemEventsErrorKind::OpsItemInvalidParameterError(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListOpsItemEventsError::unhandled(e),
                },
                "OpsItemLimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListOpsItemEventsError {
                        kind: crate::error::ListOpsItemEventsErrorKind::OpsItemLimitExceededError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListOpsItemEventsError::unhandled(e),
                },
                "OpsItemNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListOpsItemEventsError {
                        kind: crate::error::ListOpsItemEventsErrorKind::OpsItemNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListOpsItemEventsError::unhandled(e),
                },
                _ => crate::error::ListOpsItemEventsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::list_ops_item_events_output::Builder::default();
        builder = crate::json_deser::list_ops_item_events_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::ListOpsItemEventsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ListOpsItemEvents {
    type Output =
        Result<crate::output::ListOpsItemEventsOutput, crate::error::ListOpsItemEventsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists all related-item resources associated with an OpsItem.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct ListOpsItemRelatedItems {
    _private: (),
}
impl ListOpsItemRelatedItems {
    /// Creates a new builder-style object to manufacture [`ListOpsItemRelatedItemsInput`](crate::input::ListOpsItemRelatedItemsInput)
    pub fn builder() -> crate::input::list_ops_item_related_items_input::Builder {
        crate::input::list_ops_item_related_items_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::ListOpsItemRelatedItemsOutput,
        crate::error::ListOpsItemRelatedItemsError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::ListOpsItemRelatedItemsError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListOpsItemRelatedItemsError { kind: crate::error::ListOpsItemRelatedItemsErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::ListOpsItemRelatedItemsError::unhandled(e)
                }
                "OpsItemInvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListOpsItemRelatedItemsError { kind: crate::error::ListOpsItemRelatedItemsErrorKind::OpsItemInvalidParameterError(body), meta: generic },
                    Err(e) => crate::error::ListOpsItemRelatedItemsError::unhandled(e)
                }
                _ => crate::error::ListOpsItemRelatedItemsError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::list_ops_item_related_items_output::Builder::default();
        builder = crate::json_deser::list_ops_item_related_items_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::ListOpsItemRelatedItemsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ListOpsItemRelatedItems {
    type Output = Result<
        crate::output::ListOpsItemRelatedItemsOutput,
        crate::error::ListOpsItemRelatedItemsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Systems Manager calls this API action when displaying all Application Manager OpsMetadata objects or
/// blobs.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct ListOpsMetadata {
    _private: (),
}
impl ListOpsMetadata {
    /// Creates a new builder-style object to manufacture [`ListOpsMetadataInput`](crate::input::ListOpsMetadataInput)
    pub fn builder() -> crate::input::list_ops_metadata_input::Builder {
        crate::input::list_ops_metadata_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::ListOpsMetadataOutput, crate::error::ListOpsMetadataError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::ListOpsMetadataError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListOpsMetadataError {
                        kind: crate::error::ListOpsMetadataErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListOpsMetadataError::unhandled(e),
                },
                "OpsMetadataInvalidArgumentException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListOpsMetadataError {
                        kind:
                            crate::error::ListOpsMetadataErrorKind::OpsMetadataInvalidArgumentError(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListOpsMetadataError::unhandled(e),
                },
                _ => crate::error::ListOpsMetadataError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::list_ops_metadata_output::Builder::default();
        builder =
            crate::json_deser::list_ops_metadata_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::ListOpsMetadataError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ListOpsMetadata {
    type Output = Result<crate::output::ListOpsMetadataOutput, crate::error::ListOpsMetadataError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns a resource-level summary count. The summary includes information about compliant and
/// non-compliant statuses and detailed compliance-item severity counts, according to the filter
/// criteria you specify.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct ListResourceComplianceSummaries {
    _private: (),
}
impl ListResourceComplianceSummaries {
    /// Creates a new builder-style object to manufacture [`ListResourceComplianceSummariesInput`](crate::input::ListResourceComplianceSummariesInput)
    pub fn builder() -> crate::input::list_resource_compliance_summaries_input::Builder {
        crate::input::list_resource_compliance_summaries_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::ListResourceComplianceSummariesOutput,
        crate::error::ListResourceComplianceSummariesError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(
                        crate::error::ListResourceComplianceSummariesError::unhandled(generic),
                    )
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListResourceComplianceSummariesError { kind: crate::error::ListResourceComplianceSummariesErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::ListResourceComplianceSummariesError::unhandled(e)
                }
                "InvalidFilter" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListResourceComplianceSummariesError { kind: crate::error::ListResourceComplianceSummariesErrorKind::InvalidFilter(body), meta: generic },
                    Err(e) => crate::error::ListResourceComplianceSummariesError::unhandled(e)
                }
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListResourceComplianceSummariesError { kind: crate::error::ListResourceComplianceSummariesErrorKind::InvalidNextToken(body), meta: generic },
                    Err(e) => crate::error::ListResourceComplianceSummariesError::unhandled(e)
                }
                _ => crate::error::ListResourceComplianceSummariesError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::list_resource_compliance_summaries_output::Builder::default();
        builder = crate::json_deser::list_resource_compliance_summaries_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::ListResourceComplianceSummariesError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ListResourceComplianceSummaries {
    type Output = Result<
        crate::output::ListResourceComplianceSummariesOutput,
        crate::error::ListResourceComplianceSummariesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists your resource data sync configurations. Includes information about the last time a
/// sync attempted to start, the last sync status, and the last time a sync successfully
/// completed.</p>
/// <p>The number of sync configurations might be too large to return using a single call to
/// <code>ListResourceDataSync</code>. You can limit the number of sync configurations returned by
/// using the <code>MaxResults</code> parameter. To determine whether there are more sync
/// configurations to list, check the value of <code>NextToken</code> in the output. If there are
/// more sync configurations to list, you can request them by specifying the <code>NextToken</code>
/// returned in the call to the parameter of a subsequent call. </p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct ListResourceDataSync {
    _private: (),
}
impl ListResourceDataSync {
    /// Creates a new builder-style object to manufacture [`ListResourceDataSyncInput`](crate::input::ListResourceDataSyncInput)
    pub fn builder() -> crate::input::list_resource_data_sync_input::Builder {
        crate::input::list_resource_data_sync_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::ListResourceDataSyncOutput, crate::error::ListResourceDataSyncError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::ListResourceDataSyncError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListResourceDataSyncError { kind: crate::error::ListResourceDataSyncErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::ListResourceDataSyncError::unhandled(e)
                }
                "InvalidNextToken" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListResourceDataSyncError { kind: crate::error::ListResourceDataSyncErrorKind::InvalidNextToken(body), meta: generic },
                    Err(e) => crate::error::ListResourceDataSyncError::unhandled(e)
                }
                "ResourceDataSyncInvalidConfigurationException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListResourceDataSyncError { kind: crate::error::ListResourceDataSyncErrorKind::ResourceDataSyncInvalidConfigurationError(body), meta: generic },
                    Err(e) => crate::error::ListResourceDataSyncError::unhandled(e)
                }
                _ => crate::error::ListResourceDataSyncError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::list_resource_data_sync_output::Builder::default();
        builder = crate::json_deser::list_resource_data_sync_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::ListResourceDataSyncError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ListResourceDataSync {
    type Output =
        Result<crate::output::ListResourceDataSyncOutput, crate::error::ListResourceDataSyncError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns a list of the tags assigned to the specified resource.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::ListTagsForResourceOutput, crate::error::ListTagsForResourceError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::ListTagsForResourceError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListTagsForResourceError {
                        kind: crate::error::ListTagsForResourceErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListTagsForResourceError::unhandled(e),
                },
                "InvalidResourceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListTagsForResourceError {
                        kind: crate::error::ListTagsForResourceErrorKind::InvalidResourceId(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListTagsForResourceError::unhandled(e),
                },
                "InvalidResourceType" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListTagsForResourceError {
                        kind: crate::error::ListTagsForResourceErrorKind::InvalidResourceType(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListTagsForResourceError::unhandled(e),
                },
                _ => crate::error::ListTagsForResourceError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::list_tags_for_resource_output::Builder::default();
        builder = crate::json_deser::list_tags_for_resource_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output =
        Result<crate::output::ListTagsForResourceOutput, crate::error::ListTagsForResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Shares a Systems Manager document publicly or privately. If you share a document privately, you must
/// specify the AWS user account IDs for those people who can use the document. If you share a
/// document publicly, you must specify <i>All</i> as the account ID.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct ModifyDocumentPermission {
    _private: (),
}
impl ModifyDocumentPermission {
    /// Creates a new builder-style object to manufacture [`ModifyDocumentPermissionInput`](crate::input::ModifyDocumentPermissionInput)
    pub fn builder() -> crate::input::modify_document_permission_input::Builder {
        crate::input::modify_document_permission_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::ModifyDocumentPermissionOutput,
        crate::error::ModifyDocumentPermissionError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::ModifyDocumentPermissionError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "DocumentLimitExceeded" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ModifyDocumentPermissionError {
                        kind:
                            crate::error::ModifyDocumentPermissionErrorKind::DocumentLimitExceeded(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ModifyDocumentPermissionError::unhandled(e),
                },
                "DocumentPermissionLimit" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ModifyDocumentPermissionError {
                        kind:
                            crate::error::ModifyDocumentPermissionErrorKind::DocumentPermissionLimit(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ModifyDocumentPermissionError::unhandled(e),
                },
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ModifyDocumentPermissionError {
                        kind: crate::error::ModifyDocumentPermissionErrorKind::InternalServerError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ModifyDocumentPermissionError::unhandled(e),
                },
                "InvalidDocument" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ModifyDocumentPermissionError {
                        kind: crate::error::ModifyDocumentPermissionErrorKind::InvalidDocument(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ModifyDocumentPermissionError::unhandled(e),
                },
                "InvalidPermissionType" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ModifyDocumentPermissionError {
                        kind:
                            crate::error::ModifyDocumentPermissionErrorKind::InvalidPermissionType(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ModifyDocumentPermissionError::unhandled(e),
                },
                _ => crate::error::ModifyDocumentPermissionError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::modify_document_permission_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ModifyDocumentPermission {
    type Output = Result<
        crate::output::ModifyDocumentPermissionOutput,
        crate::error::ModifyDocumentPermissionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Registers a compliance type and other compliance details on a designated resource. This
/// action lets you register custom compliance details with a resource. This call overwrites existing
/// compliance information on the resource, so you must provide a full list of compliance items each
/// time that you send the request.</p>
/// <p>ComplianceType can be one of the following:</p>
/// <ul>
/// <li>
/// <p>ExecutionId: The execution ID when the patch, association, or custom compliance item was
/// applied.</p>
/// </li>
/// <li>
/// <p>ExecutionType: Specify patch, association, or Custom:<code>string</code>.</p>
/// </li>
/// <li>
/// <p>ExecutionTime. The time the patch, association, or custom compliance item was applied to
/// the instance.</p>
/// </li>
/// <li>
/// <p>Id: The patch, association, or custom compliance ID.</p>
/// </li>
/// <li>
/// <p>Title: A title.</p>
/// </li>
/// <li>
/// <p>Status: The status of the compliance item. For example, <code>approved</code> for patches,
/// or <code>Failed</code> for associations.</p>
/// </li>
/// <li>
/// <p>Severity: A patch severity. For example, <code>critical</code>.</p>
/// </li>
/// <li>
/// <p>DocumentName: A SSM document name. For example, AWS-RunPatchBaseline.</p>
/// </li>
/// <li>
/// <p>DocumentVersion: An SSM document version number. For example, 4.</p>
/// </li>
/// <li>
/// <p>Classification: A patch classification. For example, <code>security updates</code>.</p>
/// </li>
/// <li>
/// <p>PatchBaselineId: A patch baseline ID.</p>
/// </li>
/// <li>
/// <p>PatchSeverity: A patch severity. For example, <code>Critical</code>.</p>
/// </li>
/// <li>
/// <p>PatchState: A patch state. For example, <code>InstancesWithFailedPatches</code>.</p>
/// </li>
/// <li>
/// <p>PatchGroup: The name of a patch group.</p>
/// </li>
/// <li>
/// <p>InstalledTime: The time the association, patch, or custom compliance item was applied to
/// the resource. Specify the time by using the following format: yyyy-MM-dd'T'HH:mm:ss'Z'</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone)]
pub struct PutComplianceItems {
    _private: (),
}
impl PutComplianceItems {
    /// Creates a new builder-style object to manufacture [`PutComplianceItemsInput`](crate::input::PutComplianceItemsInput)
    pub fn builder() -> crate::input::put_compliance_items_input::Builder {
        crate::input::put_compliance_items_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::PutComplianceItemsOutput, crate::error::PutComplianceItemsError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::PutComplianceItemsError::unhandled(generic)),
            };
            return Err(match error_code {
                "ComplianceTypeCountLimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutComplianceItemsError { kind: crate::error::PutComplianceItemsErrorKind::ComplianceTypeCountLimitExceededError(body), meta: generic },
                    Err(e) => crate::error::PutComplianceItemsError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutComplianceItemsError { kind: crate::error::PutComplianceItemsErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::PutComplianceItemsError::unhandled(e)
                }
                "InvalidItemContentException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutComplianceItemsError { kind: crate::error::PutComplianceItemsErrorKind::InvalidItemContentError(body), meta: generic },
                    Err(e) => crate::error::PutComplianceItemsError::unhandled(e)
                }
                "InvalidResourceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutComplianceItemsError { kind: crate::error::PutComplianceItemsErrorKind::InvalidResourceId(body), meta: generic },
                    Err(e) => crate::error::PutComplianceItemsError::unhandled(e)
                }
                "InvalidResourceType" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutComplianceItemsError { kind: crate::error::PutComplianceItemsErrorKind::InvalidResourceType(body), meta: generic },
                    Err(e) => crate::error::PutComplianceItemsError::unhandled(e)
                }
                "ItemSizeLimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutComplianceItemsError { kind: crate::error::PutComplianceItemsErrorKind::ItemSizeLimitExceededError(body), meta: generic },
                    Err(e) => crate::error::PutComplianceItemsError::unhandled(e)
                }
                "TotalSizeLimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutComplianceItemsError { kind: crate::error::PutComplianceItemsErrorKind::TotalSizeLimitExceededError(body), meta: generic },
                    Err(e) => crate::error::PutComplianceItemsError::unhandled(e)
                }
                _ => crate::error::PutComplianceItemsError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::put_compliance_items_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for PutComplianceItems {
    type Output =
        Result<crate::output::PutComplianceItemsOutput, crate::error::PutComplianceItemsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Bulk update custom inventory items on one more instance. The request adds an inventory item,
/// if it doesn't already exist, or updates an inventory item, if it does exist.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct PutInventory {
    _private: (),
}
impl PutInventory {
    /// Creates a new builder-style object to manufacture [`PutInventoryInput`](crate::input::PutInventoryInput)
    pub fn builder() -> crate::input::put_inventory_input::Builder {
        crate::input::put_inventory_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::PutInventoryOutput, crate::error::PutInventoryError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::PutInventoryError::unhandled(generic)),
            };
            return Err(match error_code {
                "CustomSchemaCountLimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutInventoryError { kind: crate::error::PutInventoryErrorKind::CustomSchemaCountLimitExceededError(body), meta: generic },
                    Err(e) => crate::error::PutInventoryError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutInventoryError { kind: crate::error::PutInventoryErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::PutInventoryError::unhandled(e)
                }
                "InvalidInstanceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutInventoryError { kind: crate::error::PutInventoryErrorKind::InvalidInstanceId(body), meta: generic },
                    Err(e) => crate::error::PutInventoryError::unhandled(e)
                }
                "InvalidInventoryItemContextException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutInventoryError { kind: crate::error::PutInventoryErrorKind::InvalidInventoryItemContextError(body), meta: generic },
                    Err(e) => crate::error::PutInventoryError::unhandled(e)
                }
                "InvalidItemContentException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutInventoryError { kind: crate::error::PutInventoryErrorKind::InvalidItemContentError(body), meta: generic },
                    Err(e) => crate::error::PutInventoryError::unhandled(e)
                }
                "InvalidTypeNameException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutInventoryError { kind: crate::error::PutInventoryErrorKind::InvalidTypeNameError(body), meta: generic },
                    Err(e) => crate::error::PutInventoryError::unhandled(e)
                }
                "ItemContentMismatchException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutInventoryError { kind: crate::error::PutInventoryErrorKind::ItemContentMismatchError(body), meta: generic },
                    Err(e) => crate::error::PutInventoryError::unhandled(e)
                }
                "ItemSizeLimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutInventoryError { kind: crate::error::PutInventoryErrorKind::ItemSizeLimitExceededError(body), meta: generic },
                    Err(e) => crate::error::PutInventoryError::unhandled(e)
                }
                "SubTypeCountLimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutInventoryError { kind: crate::error::PutInventoryErrorKind::SubTypeCountLimitExceededError(body), meta: generic },
                    Err(e) => crate::error::PutInventoryError::unhandled(e)
                }
                "TotalSizeLimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutInventoryError { kind: crate::error::PutInventoryErrorKind::TotalSizeLimitExceededError(body), meta: generic },
                    Err(e) => crate::error::PutInventoryError::unhandled(e)
                }
                "UnsupportedInventoryItemContextException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutInventoryError { kind: crate::error::PutInventoryErrorKind::UnsupportedInventoryItemContextError(body), meta: generic },
                    Err(e) => crate::error::PutInventoryError::unhandled(e)
                }
                "UnsupportedInventorySchemaVersionException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutInventoryError { kind: crate::error::PutInventoryErrorKind::UnsupportedInventorySchemaVersionError(body), meta: generic },
                    Err(e) => crate::error::PutInventoryError::unhandled(e)
                }
                _ => crate::error::PutInventoryError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::put_inventory_output::Builder::default();
        builder =
            crate::json_deser::put_inventory_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::PutInventoryError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for PutInventory {
    type Output = Result<crate::output::PutInventoryOutput, crate::error::PutInventoryError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Add a parameter to the system.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct PutParameter {
    _private: (),
}
impl PutParameter {
    /// Creates a new builder-style object to manufacture [`PutParameterInput`](crate::input::PutParameterInput)
    pub fn builder() -> crate::input::put_parameter_input::Builder {
        crate::input::put_parameter_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::PutParameterOutput, crate::error::PutParameterError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::PutParameterError::unhandled(generic)),
            };
            return Err(match error_code {
                "HierarchyLevelLimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutParameterError {
                        kind: crate::error::PutParameterErrorKind::HierarchyLevelLimitExceededError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutParameterError::unhandled(e),
                },
                "HierarchyTypeMismatchException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutParameterError {
                        kind: crate::error::PutParameterErrorKind::HierarchyTypeMismatchError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutParameterError::unhandled(e),
                },
                "IncompatiblePolicyException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutParameterError {
                        kind: crate::error::PutParameterErrorKind::IncompatiblePolicyError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutParameterError::unhandled(e),
                },
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutParameterError {
                        kind: crate::error::PutParameterErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutParameterError::unhandled(e),
                },
                "InvalidAllowedPatternException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutParameterError {
                        kind: crate::error::PutParameterErrorKind::InvalidAllowedPatternError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutParameterError::unhandled(e),
                },
                "InvalidKeyId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutParameterError {
                        kind: crate::error::PutParameterErrorKind::InvalidKeyId(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutParameterError::unhandled(e),
                },
                "InvalidPolicyAttributeException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutParameterError {
                        kind: crate::error::PutParameterErrorKind::InvalidPolicyAttributeError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutParameterError::unhandled(e),
                },
                "InvalidPolicyTypeException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutParameterError {
                        kind: crate::error::PutParameterErrorKind::InvalidPolicyTypeError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutParameterError::unhandled(e),
                },
                "ParameterAlreadyExists" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutParameterError {
                        kind: crate::error::PutParameterErrorKind::ParameterAlreadyExists(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutParameterError::unhandled(e),
                },
                "ParameterLimitExceeded" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutParameterError {
                        kind: crate::error::PutParameterErrorKind::ParameterLimitExceeded(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutParameterError::unhandled(e),
                },
                "ParameterMaxVersionLimitExceeded" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutParameterError {
                        kind: crate::error::PutParameterErrorKind::ParameterMaxVersionLimitExceeded(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutParameterError::unhandled(e),
                },
                "ParameterPatternMismatchException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutParameterError {
                        kind: crate::error::PutParameterErrorKind::ParameterPatternMismatchError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutParameterError::unhandled(e),
                },
                "PoliciesLimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutParameterError {
                        kind: crate::error::PutParameterErrorKind::PoliciesLimitExceededError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutParameterError::unhandled(e),
                },
                "TooManyUpdates" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutParameterError {
                        kind: crate::error::PutParameterErrorKind::TooManyUpdates(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutParameterError::unhandled(e),
                },
                "UnsupportedParameterType" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutParameterError {
                        kind: crate::error::PutParameterErrorKind::UnsupportedParameterType(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutParameterError::unhandled(e),
                },
                _ => crate::error::PutParameterError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::put_parameter_output::Builder::default();
        builder =
            crate::json_deser::put_parameter_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::PutParameterError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for PutParameter {
    type Output = Result<crate::output::PutParameterOutput, crate::error::PutParameterError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Defines the default patch baseline for the relevant operating system.</p>
/// <p>To reset the AWS predefined patch baseline as the default, specify the full patch baseline
/// ARN as the baseline ID value. For example, for CentOS, specify
/// <code>arn:aws:ssm:us-east-2:733109147000:patchbaseline/pb-0574b43a65ea646ed</code> instead of
/// <code>pb-0574b43a65ea646ed</code>.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct RegisterDefaultPatchBaseline {
    _private: (),
}
impl RegisterDefaultPatchBaseline {
    /// Creates a new builder-style object to manufacture [`RegisterDefaultPatchBaselineInput`](crate::input::RegisterDefaultPatchBaselineInput)
    pub fn builder() -> crate::input::register_default_patch_baseline_input::Builder {
        crate::input::register_default_patch_baseline_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::RegisterDefaultPatchBaselineOutput,
        crate::error::RegisterDefaultPatchBaselineError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::RegisterDefaultPatchBaselineError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "DoesNotExistException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RegisterDefaultPatchBaselineError {
                        kind:
                            crate::error::RegisterDefaultPatchBaselineErrorKind::DoesNotExistError(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::RegisterDefaultPatchBaselineError::unhandled(e),
                },
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RegisterDefaultPatchBaselineError {
                        kind:
                            crate::error::RegisterDefaultPatchBaselineErrorKind::InternalServerError(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::RegisterDefaultPatchBaselineError::unhandled(e),
                },
                "InvalidResourceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RegisterDefaultPatchBaselineError {
                        kind:
                            crate::error::RegisterDefaultPatchBaselineErrorKind::InvalidResourceId(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::RegisterDefaultPatchBaselineError::unhandled(e),
                },
                _ => crate::error::RegisterDefaultPatchBaselineError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::register_default_patch_baseline_output::Builder::default();
        builder = crate::json_deser::register_default_patch_baseline_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::RegisterDefaultPatchBaselineError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for RegisterDefaultPatchBaseline {
    type Output = Result<
        crate::output::RegisterDefaultPatchBaselineOutput,
        crate::error::RegisterDefaultPatchBaselineError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Registers a patch baseline for a patch group.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct RegisterPatchBaselineForPatchGroup {
    _private: (),
}
impl RegisterPatchBaselineForPatchGroup {
    /// Creates a new builder-style object to manufacture [`RegisterPatchBaselineForPatchGroupInput`](crate::input::RegisterPatchBaselineForPatchGroupInput)
    pub fn builder() -> crate::input::register_patch_baseline_for_patch_group_input::Builder {
        crate::input::register_patch_baseline_for_patch_group_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::RegisterPatchBaselineForPatchGroupOutput,
        crate::error::RegisterPatchBaselineForPatchGroupError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(
                        crate::error::RegisterPatchBaselineForPatchGroupError::unhandled(generic),
                    )
                }
            };
            return Err(match error_code {
                "AlreadyExistsException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RegisterPatchBaselineForPatchGroupError { kind: crate::error::RegisterPatchBaselineForPatchGroupErrorKind::AlreadyExistsError(body), meta: generic },
                    Err(e) => crate::error::RegisterPatchBaselineForPatchGroupError::unhandled(e)
                }
                "DoesNotExistException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RegisterPatchBaselineForPatchGroupError { kind: crate::error::RegisterPatchBaselineForPatchGroupErrorKind::DoesNotExistError(body), meta: generic },
                    Err(e) => crate::error::RegisterPatchBaselineForPatchGroupError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RegisterPatchBaselineForPatchGroupError { kind: crate::error::RegisterPatchBaselineForPatchGroupErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::RegisterPatchBaselineForPatchGroupError::unhandled(e)
                }
                "InvalidResourceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RegisterPatchBaselineForPatchGroupError { kind: crate::error::RegisterPatchBaselineForPatchGroupErrorKind::InvalidResourceId(body), meta: generic },
                    Err(e) => crate::error::RegisterPatchBaselineForPatchGroupError::unhandled(e)
                }
                "ResourceLimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RegisterPatchBaselineForPatchGroupError { kind: crate::error::RegisterPatchBaselineForPatchGroupErrorKind::ResourceLimitExceededError(body), meta: generic },
                    Err(e) => crate::error::RegisterPatchBaselineForPatchGroupError::unhandled(e)
                }
                _ => crate::error::RegisterPatchBaselineForPatchGroupError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::register_patch_baseline_for_patch_group_output::Builder::default();
        builder = crate::json_deser::register_patch_baseline_for_patch_group_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::RegisterPatchBaselineForPatchGroupError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for RegisterPatchBaselineForPatchGroup {
    type Output = Result<
        crate::output::RegisterPatchBaselineForPatchGroupOutput,
        crate::error::RegisterPatchBaselineForPatchGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Registers a target with a maintenance window.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct RegisterTargetWithMaintenanceWindow {
    _private: (),
}
impl RegisterTargetWithMaintenanceWindow {
    /// Creates a new builder-style object to manufacture [`RegisterTargetWithMaintenanceWindowInput`](crate::input::RegisterTargetWithMaintenanceWindowInput)
    pub fn builder() -> crate::input::register_target_with_maintenance_window_input::Builder {
        crate::input::register_target_with_maintenance_window_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::RegisterTargetWithMaintenanceWindowOutput,
        crate::error::RegisterTargetWithMaintenanceWindowError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(
                        crate::error::RegisterTargetWithMaintenanceWindowError::unhandled(generic),
                    )
                }
            };
            return Err(match error_code {
                "DoesNotExistException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RegisterTargetWithMaintenanceWindowError { kind: crate::error::RegisterTargetWithMaintenanceWindowErrorKind::DoesNotExistError(body), meta: generic },
                    Err(e) => crate::error::RegisterTargetWithMaintenanceWindowError::unhandled(e)
                }
                "IdempotentParameterMismatch" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RegisterTargetWithMaintenanceWindowError { kind: crate::error::RegisterTargetWithMaintenanceWindowErrorKind::IdempotentParameterMismatch(body), meta: generic },
                    Err(e) => crate::error::RegisterTargetWithMaintenanceWindowError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RegisterTargetWithMaintenanceWindowError { kind: crate::error::RegisterTargetWithMaintenanceWindowErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::RegisterTargetWithMaintenanceWindowError::unhandled(e)
                }
                "ResourceLimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RegisterTargetWithMaintenanceWindowError { kind: crate::error::RegisterTargetWithMaintenanceWindowErrorKind::ResourceLimitExceededError(body), meta: generic },
                    Err(e) => crate::error::RegisterTargetWithMaintenanceWindowError::unhandled(e)
                }
                _ => crate::error::RegisterTargetWithMaintenanceWindowError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::register_target_with_maintenance_window_output::Builder::default();
        builder = crate::json_deser::register_target_with_maintenance_window_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::RegisterTargetWithMaintenanceWindowError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for RegisterTargetWithMaintenanceWindow {
    type Output = Result<
        crate::output::RegisterTargetWithMaintenanceWindowOutput,
        crate::error::RegisterTargetWithMaintenanceWindowError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Adds a new task to a maintenance window.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct RegisterTaskWithMaintenanceWindow {
    _private: (),
}
impl RegisterTaskWithMaintenanceWindow {
    /// Creates a new builder-style object to manufacture [`RegisterTaskWithMaintenanceWindowInput`](crate::input::RegisterTaskWithMaintenanceWindowInput)
    pub fn builder() -> crate::input::register_task_with_maintenance_window_input::Builder {
        crate::input::register_task_with_maintenance_window_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::RegisterTaskWithMaintenanceWindowOutput,
        crate::error::RegisterTaskWithMaintenanceWindowError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(
                        crate::error::RegisterTaskWithMaintenanceWindowError::unhandled(generic),
                    )
                }
            };
            return Err(match error_code {
                "DoesNotExistException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RegisterTaskWithMaintenanceWindowError { kind: crate::error::RegisterTaskWithMaintenanceWindowErrorKind::DoesNotExistError(body), meta: generic },
                    Err(e) => crate::error::RegisterTaskWithMaintenanceWindowError::unhandled(e)
                }
                "FeatureNotAvailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RegisterTaskWithMaintenanceWindowError { kind: crate::error::RegisterTaskWithMaintenanceWindowErrorKind::FeatureNotAvailableError(body), meta: generic },
                    Err(e) => crate::error::RegisterTaskWithMaintenanceWindowError::unhandled(e)
                }
                "IdempotentParameterMismatch" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RegisterTaskWithMaintenanceWindowError { kind: crate::error::RegisterTaskWithMaintenanceWindowErrorKind::IdempotentParameterMismatch(body), meta: generic },
                    Err(e) => crate::error::RegisterTaskWithMaintenanceWindowError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RegisterTaskWithMaintenanceWindowError { kind: crate::error::RegisterTaskWithMaintenanceWindowErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::RegisterTaskWithMaintenanceWindowError::unhandled(e)
                }
                "ResourceLimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RegisterTaskWithMaintenanceWindowError { kind: crate::error::RegisterTaskWithMaintenanceWindowErrorKind::ResourceLimitExceededError(body), meta: generic },
                    Err(e) => crate::error::RegisterTaskWithMaintenanceWindowError::unhandled(e)
                }
                _ => crate::error::RegisterTaskWithMaintenanceWindowError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::register_task_with_maintenance_window_output::Builder::default();
        builder = crate::json_deser::register_task_with_maintenance_window_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::RegisterTaskWithMaintenanceWindowError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for RegisterTaskWithMaintenanceWindow {
    type Output = Result<
        crate::output::RegisterTaskWithMaintenanceWindowOutput,
        crate::error::RegisterTaskWithMaintenanceWindowError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Removes tag keys from the specified resource.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct RemoveTagsFromResource {
    _private: (),
}
impl RemoveTagsFromResource {
    /// Creates a new builder-style object to manufacture [`RemoveTagsFromResourceInput`](crate::input::RemoveTagsFromResourceInput)
    pub fn builder() -> crate::input::remove_tags_from_resource_input::Builder {
        crate::input::remove_tags_from_resource_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::RemoveTagsFromResourceOutput,
        crate::error::RemoveTagsFromResourceError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::RemoveTagsFromResourceError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RemoveTagsFromResourceError {
                        kind: crate::error::RemoveTagsFromResourceErrorKind::InternalServerError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::RemoveTagsFromResourceError::unhandled(e),
                },
                "InvalidResourceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RemoveTagsFromResourceError {
                        kind: crate::error::RemoveTagsFromResourceErrorKind::InvalidResourceId(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::RemoveTagsFromResourceError::unhandled(e),
                },
                "InvalidResourceType" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RemoveTagsFromResourceError {
                        kind: crate::error::RemoveTagsFromResourceErrorKind::InvalidResourceType(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::RemoveTagsFromResourceError::unhandled(e),
                },
                "TooManyUpdates" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RemoveTagsFromResourceError {
                        kind: crate::error::RemoveTagsFromResourceErrorKind::TooManyUpdates(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::RemoveTagsFromResourceError::unhandled(e),
                },
                _ => crate::error::RemoveTagsFromResourceError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::remove_tags_from_resource_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for RemoveTagsFromResource {
    type Output = Result<
        crate::output::RemoveTagsFromResourceOutput,
        crate::error::RemoveTagsFromResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>
/// <code>ServiceSetting</code> is an account-level setting for an AWS service. This setting
/// defines how a user interacts with or uses a service or a feature of a service. For example, if an
/// AWS service charges money to the account based on feature or service usage, then the AWS service
/// team might create a default setting of "false". This means the user can't use this feature unless
/// they change the setting to "true" and intentionally opt in for a paid feature.</p>
/// <p>Services map a <code>SettingId</code> object to a setting value. AWS services teams define
/// the default value for a <code>SettingId</code>. You can't create a new <code>SettingId</code>,
/// but you can overwrite the default value if you have the <code>ssm:UpdateServiceSetting</code>
/// permission for the setting. Use the <a>GetServiceSetting</a> API action to view the
/// current value. Use the <a>UpdateServiceSetting</a> API action to change the default
/// setting. </p>
/// <p>Reset the service setting for the account to the default value as provisioned by the AWS
/// service team. </p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct ResetServiceSetting {
    _private: (),
}
impl ResetServiceSetting {
    /// Creates a new builder-style object to manufacture [`ResetServiceSettingInput`](crate::input::ResetServiceSettingInput)
    pub fn builder() -> crate::input::reset_service_setting_input::Builder {
        crate::input::reset_service_setting_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::ResetServiceSettingOutput, crate::error::ResetServiceSettingError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::ResetServiceSettingError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ResetServiceSettingError {
                        kind: crate::error::ResetServiceSettingErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ResetServiceSettingError::unhandled(e),
                },
                "ServiceSettingNotFound" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ResetServiceSettingError {
                        kind: crate::error::ResetServiceSettingErrorKind::ServiceSettingNotFound(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ResetServiceSettingError::unhandled(e),
                },
                "TooManyUpdates" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ResetServiceSettingError {
                        kind: crate::error::ResetServiceSettingErrorKind::TooManyUpdates(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ResetServiceSettingError::unhandled(e),
                },
                _ => crate::error::ResetServiceSettingError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::reset_service_setting_output::Builder::default();
        builder = crate::json_deser::reset_service_setting_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::ResetServiceSettingError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ResetServiceSetting {
    type Output =
        Result<crate::output::ResetServiceSettingOutput, crate::error::ResetServiceSettingError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Reconnects a session to an instance after it has been disconnected. Connections can be
/// resumed for disconnected sessions, but not terminated sessions.</p>
/// <note>
/// <p>This command is primarily for use by client machines to automatically reconnect during
/// intermittent network issues. It is not intended for any other use.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone)]
pub struct ResumeSession {
    _private: (),
}
impl ResumeSession {
    /// Creates a new builder-style object to manufacture [`ResumeSessionInput`](crate::input::ResumeSessionInput)
    pub fn builder() -> crate::input::resume_session_input::Builder {
        crate::input::resume_session_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::ResumeSessionOutput, crate::error::ResumeSessionError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::ResumeSessionError::unhandled(generic)),
            };
            return Err(match error_code {
                "DoesNotExistException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ResumeSessionError {
                        kind: crate::error::ResumeSessionErrorKind::DoesNotExistError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ResumeSessionError::unhandled(e),
                },
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ResumeSessionError {
                        kind: crate::error::ResumeSessionErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ResumeSessionError::unhandled(e),
                },
                _ => crate::error::ResumeSessionError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::resume_session_output::Builder::default();
        builder =
            crate::json_deser::resume_session_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::ResumeSessionError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ResumeSession {
    type Output = Result<crate::output::ResumeSessionOutput, crate::error::ResumeSessionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Sends a signal to an Automation execution to change the current behavior or status of the
/// execution. </p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct SendAutomationSignal {
    _private: (),
}
impl SendAutomationSignal {
    /// Creates a new builder-style object to manufacture [`SendAutomationSignalInput`](crate::input::SendAutomationSignalInput)
    pub fn builder() -> crate::input::send_automation_signal_input::Builder {
        crate::input::send_automation_signal_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::SendAutomationSignalOutput, crate::error::SendAutomationSignalError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::SendAutomationSignalError::unhandled(generic)),
            };
            return Err(match error_code {
                "AutomationExecutionNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::SendAutomationSignalError { kind: crate::error::SendAutomationSignalErrorKind::AutomationExecutionNotFoundError(body), meta: generic },
                    Err(e) => crate::error::SendAutomationSignalError::unhandled(e)
                }
                "AutomationStepNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::SendAutomationSignalError { kind: crate::error::SendAutomationSignalErrorKind::AutomationStepNotFoundError(body), meta: generic },
                    Err(e) => crate::error::SendAutomationSignalError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::SendAutomationSignalError { kind: crate::error::SendAutomationSignalErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::SendAutomationSignalError::unhandled(e)
                }
                "InvalidAutomationSignalException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::SendAutomationSignalError { kind: crate::error::SendAutomationSignalErrorKind::InvalidAutomationSignalError(body), meta: generic },
                    Err(e) => crate::error::SendAutomationSignalError::unhandled(e)
                }
                _ => crate::error::SendAutomationSignalError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::send_automation_signal_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for SendAutomationSignal {
    type Output =
        Result<crate::output::SendAutomationSignalOutput, crate::error::SendAutomationSignalError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Runs commands on one or more managed instances.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct SendCommand {
    _private: (),
}
impl SendCommand {
    /// Creates a new builder-style object to manufacture [`SendCommandInput`](crate::input::SendCommandInput)
    pub fn builder() -> crate::input::send_command_input::Builder {
        crate::input::send_command_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::SendCommandOutput, crate::error::SendCommandError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::SendCommandError::unhandled(generic)),
            };
            return Err(match error_code {
                "DuplicateInstanceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::SendCommandError {
                        kind: crate::error::SendCommandErrorKind::DuplicateInstanceId(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::SendCommandError::unhandled(e),
                },
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::SendCommandError {
                        kind: crate::error::SendCommandErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::SendCommandError::unhandled(e),
                },
                "InvalidDocument" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::SendCommandError {
                        kind: crate::error::SendCommandErrorKind::InvalidDocument(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::SendCommandError::unhandled(e),
                },
                "InvalidDocumentVersion" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::SendCommandError {
                        kind: crate::error::SendCommandErrorKind::InvalidDocumentVersion(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::SendCommandError::unhandled(e),
                },
                "InvalidInstanceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::SendCommandError {
                        kind: crate::error::SendCommandErrorKind::InvalidInstanceId(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::SendCommandError::unhandled(e),
                },
                "InvalidNotificationConfig" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::SendCommandError {
                        kind: crate::error::SendCommandErrorKind::InvalidNotificationConfig(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::SendCommandError::unhandled(e),
                },
                "InvalidOutputFolder" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::SendCommandError {
                        kind: crate::error::SendCommandErrorKind::InvalidOutputFolder(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::SendCommandError::unhandled(e),
                },
                "InvalidParameters" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::SendCommandError {
                        kind: crate::error::SendCommandErrorKind::InvalidParameters(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::SendCommandError::unhandled(e),
                },
                "InvalidRole" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::SendCommandError {
                        kind: crate::error::SendCommandErrorKind::InvalidRole(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::SendCommandError::unhandled(e),
                },
                "MaxDocumentSizeExceeded" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::SendCommandError {
                        kind: crate::error::SendCommandErrorKind::MaxDocumentSizeExceeded(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::SendCommandError::unhandled(e),
                },
                "UnsupportedPlatformType" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::SendCommandError {
                        kind: crate::error::SendCommandErrorKind::UnsupportedPlatformType(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::SendCommandError::unhandled(e),
                },
                _ => crate::error::SendCommandError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::send_command_output::Builder::default();
        builder =
            crate::json_deser::send_command_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::SendCommandError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for SendCommand {
    type Output = Result<crate::output::SendCommandOutput, crate::error::SendCommandError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Use this API action to run an association immediately and only one time. This action can be
/// helpful when troubleshooting associations.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct StartAssociationsOnce {
    _private: (),
}
impl StartAssociationsOnce {
    /// Creates a new builder-style object to manufacture [`StartAssociationsOnceInput`](crate::input::StartAssociationsOnceInput)
    pub fn builder() -> crate::input::start_associations_once_input::Builder {
        crate::input::start_associations_once_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::StartAssociationsOnceOutput, crate::error::StartAssociationsOnceError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::StartAssociationsOnceError::unhandled(generic)),
            };
            return Err(match error_code {
                "AssociationDoesNotExist" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartAssociationsOnceError {
                        kind: crate::error::StartAssociationsOnceErrorKind::AssociationDoesNotExist(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::StartAssociationsOnceError::unhandled(e),
                },
                "InvalidAssociation" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartAssociationsOnceError {
                        kind: crate::error::StartAssociationsOnceErrorKind::InvalidAssociation(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::StartAssociationsOnceError::unhandled(e),
                },
                _ => crate::error::StartAssociationsOnceError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::start_associations_once_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for StartAssociationsOnce {
    type Output = Result<
        crate::output::StartAssociationsOnceOutput,
        crate::error::StartAssociationsOnceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Initiates execution of an Automation document.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct StartAutomationExecution {
    _private: (),
}
impl StartAutomationExecution {
    /// Creates a new builder-style object to manufacture [`StartAutomationExecutionInput`](crate::input::StartAutomationExecutionInput)
    pub fn builder() -> crate::input::start_automation_execution_input::Builder {
        crate::input::start_automation_execution_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::StartAutomationExecutionOutput,
        crate::error::StartAutomationExecutionError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::StartAutomationExecutionError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "AutomationDefinitionNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartAutomationExecutionError { kind: crate::error::StartAutomationExecutionErrorKind::AutomationDefinitionNotFoundError(body), meta: generic },
                    Err(e) => crate::error::StartAutomationExecutionError::unhandled(e)
                }
                "AutomationDefinitionVersionNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartAutomationExecutionError { kind: crate::error::StartAutomationExecutionErrorKind::AutomationDefinitionVersionNotFoundError(body), meta: generic },
                    Err(e) => crate::error::StartAutomationExecutionError::unhandled(e)
                }
                "AutomationExecutionLimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartAutomationExecutionError { kind: crate::error::StartAutomationExecutionErrorKind::AutomationExecutionLimitExceededError(body), meta: generic },
                    Err(e) => crate::error::StartAutomationExecutionError::unhandled(e)
                }
                "IdempotentParameterMismatch" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartAutomationExecutionError { kind: crate::error::StartAutomationExecutionErrorKind::IdempotentParameterMismatch(body), meta: generic },
                    Err(e) => crate::error::StartAutomationExecutionError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartAutomationExecutionError { kind: crate::error::StartAutomationExecutionErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::StartAutomationExecutionError::unhandled(e)
                }
                "InvalidAutomationExecutionParametersException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartAutomationExecutionError { kind: crate::error::StartAutomationExecutionErrorKind::InvalidAutomationExecutionParametersError(body), meta: generic },
                    Err(e) => crate::error::StartAutomationExecutionError::unhandled(e)
                }
                "InvalidTarget" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartAutomationExecutionError { kind: crate::error::StartAutomationExecutionErrorKind::InvalidTarget(body), meta: generic },
                    Err(e) => crate::error::StartAutomationExecutionError::unhandled(e)
                }
                _ => crate::error::StartAutomationExecutionError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::start_automation_execution_output::Builder::default();
        builder = crate::json_deser::start_automation_execution_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::StartAutomationExecutionError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for StartAutomationExecution {
    type Output = Result<
        crate::output::StartAutomationExecutionOutput,
        crate::error::StartAutomationExecutionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates a change request for Change Manager. The runbooks (Automation documents) specified in the
/// change request run only after all required approvals for the change request have been
/// received.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct StartChangeRequestExecution {
    _private: (),
}
impl StartChangeRequestExecution {
    /// Creates a new builder-style object to manufacture [`StartChangeRequestExecutionInput`](crate::input::StartChangeRequestExecutionInput)
    pub fn builder() -> crate::input::start_change_request_execution_input::Builder {
        crate::input::start_change_request_execution_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::StartChangeRequestExecutionOutput,
        crate::error::StartChangeRequestExecutionError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::StartChangeRequestExecutionError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "AutomationDefinitionNotApprovedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartChangeRequestExecutionError { kind: crate::error::StartChangeRequestExecutionErrorKind::AutomationDefinitionNotApprovedError(body), meta: generic },
                    Err(e) => crate::error::StartChangeRequestExecutionError::unhandled(e)
                }
                "AutomationDefinitionNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartChangeRequestExecutionError { kind: crate::error::StartChangeRequestExecutionErrorKind::AutomationDefinitionNotFoundError(body), meta: generic },
                    Err(e) => crate::error::StartChangeRequestExecutionError::unhandled(e)
                }
                "AutomationDefinitionVersionNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartChangeRequestExecutionError { kind: crate::error::StartChangeRequestExecutionErrorKind::AutomationDefinitionVersionNotFoundError(body), meta: generic },
                    Err(e) => crate::error::StartChangeRequestExecutionError::unhandled(e)
                }
                "AutomationExecutionLimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartChangeRequestExecutionError { kind: crate::error::StartChangeRequestExecutionErrorKind::AutomationExecutionLimitExceededError(body), meta: generic },
                    Err(e) => crate::error::StartChangeRequestExecutionError::unhandled(e)
                }
                "IdempotentParameterMismatch" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartChangeRequestExecutionError { kind: crate::error::StartChangeRequestExecutionErrorKind::IdempotentParameterMismatch(body), meta: generic },
                    Err(e) => crate::error::StartChangeRequestExecutionError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartChangeRequestExecutionError { kind: crate::error::StartChangeRequestExecutionErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::StartChangeRequestExecutionError::unhandled(e)
                }
                "InvalidAutomationExecutionParametersException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartChangeRequestExecutionError { kind: crate::error::StartChangeRequestExecutionErrorKind::InvalidAutomationExecutionParametersError(body), meta: generic },
                    Err(e) => crate::error::StartChangeRequestExecutionError::unhandled(e)
                }
                _ => crate::error::StartChangeRequestExecutionError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::start_change_request_execution_output::Builder::default();
        builder = crate::json_deser::start_change_request_execution_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::StartChangeRequestExecutionError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for StartChangeRequestExecution {
    type Output = Result<
        crate::output::StartChangeRequestExecutionOutput,
        crate::error::StartChangeRequestExecutionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Initiates a connection to a target (for example, an instance) for a Session Manager session. Returns a
/// URL and token that can be used to open a WebSocket connection for sending input and receiving
/// outputs.</p>
/// <note>
/// <p>AWS CLI usage: <code>start-session</code> is an interactive command that requires the Session Manager
/// plugin to be installed on the client machine making the call. For information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager-working-with-install-plugin.html">Install
/// the Session Manager plugin for the AWS CLI</a> in the <i>AWS Systems Manager User Guide</i>.</p>
/// <p>AWS Tools for PowerShell usage: Start-SSMSession is not currently supported by AWS Tools
/// for PowerShell on Windows local machines.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone)]
pub struct StartSession {
    _private: (),
}
impl StartSession {
    /// Creates a new builder-style object to manufacture [`StartSessionInput`](crate::input::StartSessionInput)
    pub fn builder() -> crate::input::start_session_input::Builder {
        crate::input::start_session_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::StartSessionOutput, crate::error::StartSessionError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::StartSessionError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartSessionError {
                        kind: crate::error::StartSessionErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::StartSessionError::unhandled(e),
                },
                "InvalidDocument" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartSessionError {
                        kind: crate::error::StartSessionErrorKind::InvalidDocument(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::StartSessionError::unhandled(e),
                },
                "TargetNotConnected" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartSessionError {
                        kind: crate::error::StartSessionErrorKind::TargetNotConnected(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::StartSessionError::unhandled(e),
                },
                _ => crate::error::StartSessionError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::start_session_output::Builder::default();
        builder =
            crate::json_deser::start_session_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::StartSessionError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for StartSession {
    type Output = Result<crate::output::StartSessionOutput, crate::error::StartSessionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Stop an Automation that is currently running.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct StopAutomationExecution {
    _private: (),
}
impl StopAutomationExecution {
    /// Creates a new builder-style object to manufacture [`StopAutomationExecutionInput`](crate::input::StopAutomationExecutionInput)
    pub fn builder() -> crate::input::stop_automation_execution_input::Builder {
        crate::input::stop_automation_execution_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::StopAutomationExecutionOutput,
        crate::error::StopAutomationExecutionError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::StopAutomationExecutionError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "AutomationExecutionNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StopAutomationExecutionError { kind: crate::error::StopAutomationExecutionErrorKind::AutomationExecutionNotFoundError(body), meta: generic },
                    Err(e) => crate::error::StopAutomationExecutionError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StopAutomationExecutionError { kind: crate::error::StopAutomationExecutionErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::StopAutomationExecutionError::unhandled(e)
                }
                "InvalidAutomationStatusUpdateException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StopAutomationExecutionError { kind: crate::error::StopAutomationExecutionErrorKind::InvalidAutomationStatusUpdateError(body), meta: generic },
                    Err(e) => crate::error::StopAutomationExecutionError::unhandled(e)
                }
                _ => crate::error::StopAutomationExecutionError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::stop_automation_execution_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for StopAutomationExecution {
    type Output = Result<
        crate::output::StopAutomationExecutionOutput,
        crate::error::StopAutomationExecutionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Permanently ends a session and closes the data connection between the Session Manager client and
/// SSM Agent on the instance. A terminated session cannot be resumed.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct TerminateSession {
    _private: (),
}
impl TerminateSession {
    /// Creates a new builder-style object to manufacture [`TerminateSessionInput`](crate::input::TerminateSessionInput)
    pub fn builder() -> crate::input::terminate_session_input::Builder {
        crate::input::terminate_session_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::TerminateSessionOutput, crate::error::TerminateSessionError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::TerminateSessionError::unhandled(generic)),
            };
            return Err(match error_code {
                "DoesNotExistException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::TerminateSessionError {
                        kind: crate::error::TerminateSessionErrorKind::DoesNotExistError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::TerminateSessionError::unhandled(e),
                },
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::TerminateSessionError {
                        kind: crate::error::TerminateSessionErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::TerminateSessionError::unhandled(e),
                },
                _ => crate::error::TerminateSessionError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::terminate_session_output::Builder::default();
        builder =
            crate::json_deser::terminate_session_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::TerminateSessionError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for TerminateSession {
    type Output =
        Result<crate::output::TerminateSessionOutput, crate::error::TerminateSessionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Remove a label or labels from a parameter.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct UnlabelParameterVersion {
    _private: (),
}
impl UnlabelParameterVersion {
    /// Creates a new builder-style object to manufacture [`UnlabelParameterVersionInput`](crate::input::UnlabelParameterVersionInput)
    pub fn builder() -> crate::input::unlabel_parameter_version_input::Builder {
        crate::input::unlabel_parameter_version_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::UnlabelParameterVersionOutput,
        crate::error::UnlabelParameterVersionError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::UnlabelParameterVersionError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UnlabelParameterVersionError {
                        kind: crate::error::UnlabelParameterVersionErrorKind::InternalServerError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UnlabelParameterVersionError::unhandled(e),
                },
                "ParameterNotFound" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UnlabelParameterVersionError {
                        kind: crate::error::UnlabelParameterVersionErrorKind::ParameterNotFound(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UnlabelParameterVersionError::unhandled(e),
                },
                "ParameterVersionNotFound" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UnlabelParameterVersionError {
                        kind:
                            crate::error::UnlabelParameterVersionErrorKind::ParameterVersionNotFound(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UnlabelParameterVersionError::unhandled(e),
                },
                "TooManyUpdates" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UnlabelParameterVersionError {
                        kind: crate::error::UnlabelParameterVersionErrorKind::TooManyUpdates(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UnlabelParameterVersionError::unhandled(e),
                },
                _ => crate::error::UnlabelParameterVersionError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::unlabel_parameter_version_output::Builder::default();
        builder = crate::json_deser::unlabel_parameter_version_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::UnlabelParameterVersionError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UnlabelParameterVersion {
    type Output = Result<
        crate::output::UnlabelParameterVersionOutput,
        crate::error::UnlabelParameterVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Updates an association. You can update the association name and version, the document
/// version, schedule, parameters, and Amazon S3 output. </p>
/// <p>In order to call this API action, your IAM user account, group, or role must be configured
/// with permission to call the <a>DescribeAssociation</a> API action. If you don't have
/// permission to call DescribeAssociation, then you receive the following error: <code>An error
/// occurred (AccessDeniedException) when calling the UpdateAssociation operation: User:
/// <user_arn> is not authorized to perform: ssm:DescribeAssociation on resource:
/// <resource_arn></code>
/// </p>
/// <important>
/// <p>When you update an association, the association immediately runs against the specified
/// targets.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone)]
pub struct UpdateAssociation {
    _private: (),
}
impl UpdateAssociation {
    /// Creates a new builder-style object to manufacture [`UpdateAssociationInput`](crate::input::UpdateAssociationInput)
    pub fn builder() -> crate::input::update_association_input::Builder {
        crate::input::update_association_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::UpdateAssociationOutput, crate::error::UpdateAssociationError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateAssociationError::unhandled(generic)),
            };
            return Err(match error_code {
                "AssociationDoesNotExist" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateAssociationError { kind: crate::error::UpdateAssociationErrorKind::AssociationDoesNotExist(body), meta: generic },
                    Err(e) => crate::error::UpdateAssociationError::unhandled(e)
                }
                "AssociationVersionLimitExceeded" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateAssociationError { kind: crate::error::UpdateAssociationErrorKind::AssociationVersionLimitExceeded(body), meta: generic },
                    Err(e) => crate::error::UpdateAssociationError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateAssociationError { kind: crate::error::UpdateAssociationErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::UpdateAssociationError::unhandled(e)
                }
                "InvalidAssociationVersion" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateAssociationError { kind: crate::error::UpdateAssociationErrorKind::InvalidAssociationVersion(body), meta: generic },
                    Err(e) => crate::error::UpdateAssociationError::unhandled(e)
                }
                "InvalidDocument" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateAssociationError { kind: crate::error::UpdateAssociationErrorKind::InvalidDocument(body), meta: generic },
                    Err(e) => crate::error::UpdateAssociationError::unhandled(e)
                }
                "InvalidDocumentVersion" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateAssociationError { kind: crate::error::UpdateAssociationErrorKind::InvalidDocumentVersion(body), meta: generic },
                    Err(e) => crate::error::UpdateAssociationError::unhandled(e)
                }
                "InvalidOutputLocation" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateAssociationError { kind: crate::error::UpdateAssociationErrorKind::InvalidOutputLocation(body), meta: generic },
                    Err(e) => crate::error::UpdateAssociationError::unhandled(e)
                }
                "InvalidParameters" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateAssociationError { kind: crate::error::UpdateAssociationErrorKind::InvalidParameters(body), meta: generic },
                    Err(e) => crate::error::UpdateAssociationError::unhandled(e)
                }
                "InvalidSchedule" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateAssociationError { kind: crate::error::UpdateAssociationErrorKind::InvalidSchedule(body), meta: generic },
                    Err(e) => crate::error::UpdateAssociationError::unhandled(e)
                }
                "InvalidTarget" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateAssociationError { kind: crate::error::UpdateAssociationErrorKind::InvalidTarget(body), meta: generic },
                    Err(e) => crate::error::UpdateAssociationError::unhandled(e)
                }
                "InvalidUpdate" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateAssociationError { kind: crate::error::UpdateAssociationErrorKind::InvalidUpdate(body), meta: generic },
                    Err(e) => crate::error::UpdateAssociationError::unhandled(e)
                }
                "TooManyUpdates" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateAssociationError { kind: crate::error::UpdateAssociationErrorKind::TooManyUpdates(body), meta: generic },
                    Err(e) => crate::error::UpdateAssociationError::unhandled(e)
                }
                _ => crate::error::UpdateAssociationError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::update_association_output::Builder::default();
        builder = crate::json_deser::update_association_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::UpdateAssociationError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateAssociation {
    type Output =
        Result<crate::output::UpdateAssociationOutput, crate::error::UpdateAssociationError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Updates the status of the Systems Manager document associated with the specified instance.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct UpdateAssociationStatus {
    _private: (),
}
impl UpdateAssociationStatus {
    /// Creates a new builder-style object to manufacture [`UpdateAssociationStatusInput`](crate::input::UpdateAssociationStatusInput)
    pub fn builder() -> crate::input::update_association_status_input::Builder {
        crate::input::update_association_status_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::UpdateAssociationStatusOutput,
        crate::error::UpdateAssociationStatusError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::UpdateAssociationStatusError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "AssociationDoesNotExist" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateAssociationStatusError {
                        kind:
                            crate::error::UpdateAssociationStatusErrorKind::AssociationDoesNotExist(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateAssociationStatusError::unhandled(e),
                },
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateAssociationStatusError {
                        kind: crate::error::UpdateAssociationStatusErrorKind::InternalServerError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateAssociationStatusError::unhandled(e),
                },
                "InvalidDocument" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateAssociationStatusError {
                        kind: crate::error::UpdateAssociationStatusErrorKind::InvalidDocument(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateAssociationStatusError::unhandled(e),
                },
                "InvalidInstanceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateAssociationStatusError {
                        kind: crate::error::UpdateAssociationStatusErrorKind::InvalidInstanceId(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateAssociationStatusError::unhandled(e),
                },
                "StatusUnchanged" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateAssociationStatusError {
                        kind: crate::error::UpdateAssociationStatusErrorKind::StatusUnchanged(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateAssociationStatusError::unhandled(e),
                },
                "TooManyUpdates" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateAssociationStatusError {
                        kind: crate::error::UpdateAssociationStatusErrorKind::TooManyUpdates(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateAssociationStatusError::unhandled(e),
                },
                _ => crate::error::UpdateAssociationStatusError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::update_association_status_output::Builder::default();
        builder = crate::json_deser::update_association_status_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::UpdateAssociationStatusError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateAssociationStatus {
    type Output = Result<
        crate::output::UpdateAssociationStatusOutput,
        crate::error::UpdateAssociationStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Updates one or more values for an SSM document.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct UpdateDocument {
    _private: (),
}
impl UpdateDocument {
    /// Creates a new builder-style object to manufacture [`UpdateDocumentInput`](crate::input::UpdateDocumentInput)
    pub fn builder() -> crate::input::update_document_input::Builder {
        crate::input::update_document_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::UpdateDocumentOutput, crate::error::UpdateDocumentError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateDocumentError::unhandled(generic)),
            };
            return Err(match error_code {
                "DocumentVersionLimitExceeded" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateDocumentError {
                        kind: crate::error::UpdateDocumentErrorKind::DocumentVersionLimitExceeded(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateDocumentError::unhandled(e),
                },
                "DuplicateDocumentContent" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateDocumentError {
                        kind: crate::error::UpdateDocumentErrorKind::DuplicateDocumentContent(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateDocumentError::unhandled(e),
                },
                "DuplicateDocumentVersionName" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateDocumentError {
                        kind: crate::error::UpdateDocumentErrorKind::DuplicateDocumentVersionName(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateDocumentError::unhandled(e),
                },
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateDocumentError {
                        kind: crate::error::UpdateDocumentErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateDocumentError::unhandled(e),
                },
                "InvalidDocument" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateDocumentError {
                        kind: crate::error::UpdateDocumentErrorKind::InvalidDocument(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateDocumentError::unhandled(e),
                },
                "InvalidDocumentContent" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateDocumentError {
                        kind: crate::error::UpdateDocumentErrorKind::InvalidDocumentContent(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateDocumentError::unhandled(e),
                },
                "InvalidDocumentOperation" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateDocumentError {
                        kind: crate::error::UpdateDocumentErrorKind::InvalidDocumentOperation(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateDocumentError::unhandled(e),
                },
                "InvalidDocumentSchemaVersion" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateDocumentError {
                        kind: crate::error::UpdateDocumentErrorKind::InvalidDocumentSchemaVersion(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateDocumentError::unhandled(e),
                },
                "InvalidDocumentVersion" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateDocumentError {
                        kind: crate::error::UpdateDocumentErrorKind::InvalidDocumentVersion(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateDocumentError::unhandled(e),
                },
                "MaxDocumentSizeExceeded" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateDocumentError {
                        kind: crate::error::UpdateDocumentErrorKind::MaxDocumentSizeExceeded(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateDocumentError::unhandled(e),
                },
                _ => crate::error::UpdateDocumentError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::update_document_output::Builder::default();
        builder =
            crate::json_deser::update_document_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::UpdateDocumentError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateDocument {
    type Output = Result<crate::output::UpdateDocumentOutput, crate::error::UpdateDocumentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Set the default version of a document. </p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct UpdateDocumentDefaultVersion {
    _private: (),
}
impl UpdateDocumentDefaultVersion {
    /// Creates a new builder-style object to manufacture [`UpdateDocumentDefaultVersionInput`](crate::input::UpdateDocumentDefaultVersionInput)
    pub fn builder() -> crate::input::update_document_default_version_input::Builder {
        crate::input::update_document_default_version_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::UpdateDocumentDefaultVersionOutput,
        crate::error::UpdateDocumentDefaultVersionError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::UpdateDocumentDefaultVersionError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateDocumentDefaultVersionError { kind: crate::error::UpdateDocumentDefaultVersionErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::UpdateDocumentDefaultVersionError::unhandled(e)
                }
                "InvalidDocument" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateDocumentDefaultVersionError { kind: crate::error::UpdateDocumentDefaultVersionErrorKind::InvalidDocument(body), meta: generic },
                    Err(e) => crate::error::UpdateDocumentDefaultVersionError::unhandled(e)
                }
                "InvalidDocumentSchemaVersion" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateDocumentDefaultVersionError { kind: crate::error::UpdateDocumentDefaultVersionErrorKind::InvalidDocumentSchemaVersion(body), meta: generic },
                    Err(e) => crate::error::UpdateDocumentDefaultVersionError::unhandled(e)
                }
                "InvalidDocumentVersion" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateDocumentDefaultVersionError { kind: crate::error::UpdateDocumentDefaultVersionErrorKind::InvalidDocumentVersion(body), meta: generic },
                    Err(e) => crate::error::UpdateDocumentDefaultVersionError::unhandled(e)
                }
                _ => crate::error::UpdateDocumentDefaultVersionError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::update_document_default_version_output::Builder::default();
        builder = crate::json_deser::update_document_default_version_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::UpdateDocumentDefaultVersionError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateDocumentDefaultVersion {
    type Output = Result<
        crate::output::UpdateDocumentDefaultVersionOutput,
        crate::error::UpdateDocumentDefaultVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Updates information related to approval reviews for a specific version of a document.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct UpdateDocumentMetadata {
    _private: (),
}
impl UpdateDocumentMetadata {
    /// Creates a new builder-style object to manufacture [`UpdateDocumentMetadataInput`](crate::input::UpdateDocumentMetadataInput)
    pub fn builder() -> crate::input::update_document_metadata_input::Builder {
        crate::input::update_document_metadata_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::UpdateDocumentMetadataOutput,
        crate::error::UpdateDocumentMetadataError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::UpdateDocumentMetadataError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateDocumentMetadataError {
                        kind: crate::error::UpdateDocumentMetadataErrorKind::InternalServerError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateDocumentMetadataError::unhandled(e),
                },
                "InvalidDocument" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateDocumentMetadataError {
                        kind: crate::error::UpdateDocumentMetadataErrorKind::InvalidDocument(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateDocumentMetadataError::unhandled(e),
                },
                "InvalidDocumentOperation" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateDocumentMetadataError {
                        kind:
                            crate::error::UpdateDocumentMetadataErrorKind::InvalidDocumentOperation(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateDocumentMetadataError::unhandled(e),
                },
                "InvalidDocumentVersion" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateDocumentMetadataError {
                        kind: crate::error::UpdateDocumentMetadataErrorKind::InvalidDocumentVersion(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateDocumentMetadataError::unhandled(e),
                },
                _ => crate::error::UpdateDocumentMetadataError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::update_document_metadata_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateDocumentMetadata {
    type Output = Result<
        crate::output::UpdateDocumentMetadataOutput,
        crate::error::UpdateDocumentMetadataError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Updates an existing maintenance window. Only specified parameters are modified.</p>
/// <note>
/// <p>The value you specify for <code>Duration</code> determines the specific end time for the
/// maintenance window based on the time it begins. No maintenance window tasks are permitted to
/// start after the resulting endtime minus the number of hours you specify for <code>Cutoff</code>.
/// For example, if the maintenance window starts at 3 PM, the duration is three hours, and the
/// value you specify for <code>Cutoff</code> is one hour, no maintenance window tasks can start
/// after 5 PM.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone)]
pub struct UpdateMaintenanceWindow {
    _private: (),
}
impl UpdateMaintenanceWindow {
    /// Creates a new builder-style object to manufacture [`UpdateMaintenanceWindowInput`](crate::input::UpdateMaintenanceWindowInput)
    pub fn builder() -> crate::input::update_maintenance_window_input::Builder {
        crate::input::update_maintenance_window_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::UpdateMaintenanceWindowOutput,
        crate::error::UpdateMaintenanceWindowError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::UpdateMaintenanceWindowError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "DoesNotExistException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateMaintenanceWindowError {
                        kind: crate::error::UpdateMaintenanceWindowErrorKind::DoesNotExistError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateMaintenanceWindowError::unhandled(e),
                },
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateMaintenanceWindowError {
                        kind: crate::error::UpdateMaintenanceWindowErrorKind::InternalServerError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateMaintenanceWindowError::unhandled(e),
                },
                _ => crate::error::UpdateMaintenanceWindowError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::update_maintenance_window_output::Builder::default();
        builder = crate::json_deser::update_maintenance_window_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::UpdateMaintenanceWindowError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateMaintenanceWindow {
    type Output = Result<
        crate::output::UpdateMaintenanceWindowOutput,
        crate::error::UpdateMaintenanceWindowError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Modifies the target of an existing maintenance window. You
/// can change the following:</p>
/// <ul>
/// <li>
/// <p>Name</p>
/// </li>
/// <li>
/// <p>Description</p>
/// </li>
/// <li>
/// <p>Owner</p>
/// </li>
/// <li>
/// <p>IDs for an ID target</p>
/// </li>
/// <li>
/// <p>Tags for a Tag target</p>
/// </li>
/// <li>
/// <p>From any supported tag type to another. The three supported tag types are ID target, Tag
/// target, and resource group. For more information, see <a>Target</a>.</p>
/// </li>
/// </ul>
/// <note>
/// <p>If a parameter is null, then the corresponding field is not modified.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone)]
pub struct UpdateMaintenanceWindowTarget {
    _private: (),
}
impl UpdateMaintenanceWindowTarget {
    /// Creates a new builder-style object to manufacture [`UpdateMaintenanceWindowTargetInput`](crate::input::UpdateMaintenanceWindowTargetInput)
    pub fn builder() -> crate::input::update_maintenance_window_target_input::Builder {
        crate::input::update_maintenance_window_target_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::UpdateMaintenanceWindowTargetOutput,
        crate::error::UpdateMaintenanceWindowTargetError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::UpdateMaintenanceWindowTargetError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "DoesNotExistException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateMaintenanceWindowTargetError { kind: crate::error::UpdateMaintenanceWindowTargetErrorKind::DoesNotExistError(body), meta: generic },
                    Err(e) => crate::error::UpdateMaintenanceWindowTargetError::unhandled(e)
                }
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateMaintenanceWindowTargetError { kind: crate::error::UpdateMaintenanceWindowTargetErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::UpdateMaintenanceWindowTargetError::unhandled(e)
                }
                _ => crate::error::UpdateMaintenanceWindowTargetError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::update_maintenance_window_target_output::Builder::default();
        builder = crate::json_deser::update_maintenance_window_target_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::UpdateMaintenanceWindowTargetError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateMaintenanceWindowTarget {
    type Output = Result<
        crate::output::UpdateMaintenanceWindowTargetOutput,
        crate::error::UpdateMaintenanceWindowTargetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Modifies a task assigned to a maintenance window. You can't change the task type, but you
/// can change the following values:</p>
/// <ul>
/// <li>
/// <p>TaskARN. For example, you can change a RUN_COMMAND task from AWS-RunPowerShellScript to
/// AWS-RunShellScript.</p>
/// </li>
/// <li>
/// <p>ServiceRoleArn</p>
/// </li>
/// <li>
/// <p>TaskInvocationParameters</p>
/// </li>
/// <li>
/// <p>Priority</p>
/// </li>
/// <li>
/// <p>MaxConcurrency</p>
/// </li>
/// <li>
/// <p>MaxErrors</p>
/// </li>
/// </ul>
/// <note>
/// <p>One or more targets must be specified for maintenance window Run Command-type tasks.
/// Depending on the task, targets are optional for other maintenance window task types (Automation,
/// AWS Lambda, and AWS Step Functions). For more information about running tasks that do not
/// specify targets, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html">Registering
/// maintenance window tasks without targets</a> in the
/// <i>AWS Systems Manager User Guide</i>.</p>
/// </note>
/// <p>If the value for a parameter in <code>UpdateMaintenanceWindowTask</code> is null, then the
/// corresponding field is not modified. If you set <code>Replace</code> to true, then all fields
/// required by the <a>RegisterTaskWithMaintenanceWindow</a> action are required for this
/// request. Optional fields that aren't specified are set to null.</p>
/// <important>
/// <p>When you update a maintenance window task that has options specified in
/// <code>TaskInvocationParameters</code>, you must provide again all the
/// <code>TaskInvocationParameters</code> values that you want to retain. The values you do not
/// specify again are removed. For example, suppose that when you registered a Run Command task, you
/// specified <code>TaskInvocationParameters</code> values for <code>Comment</code>,
/// <code>NotificationConfig</code>, and <code>OutputS3BucketName</code>. If you update the
/// maintenance window task and specify only a different <code>OutputS3BucketName</code> value, the
/// values for <code>Comment</code> and <code>NotificationConfig</code> are removed.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone)]
pub struct UpdateMaintenanceWindowTask {
    _private: (),
}
impl UpdateMaintenanceWindowTask {
    /// Creates a new builder-style object to manufacture [`UpdateMaintenanceWindowTaskInput`](crate::input::UpdateMaintenanceWindowTaskInput)
    pub fn builder() -> crate::input::update_maintenance_window_task_input::Builder {
        crate::input::update_maintenance_window_task_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::UpdateMaintenanceWindowTaskOutput,
        crate::error::UpdateMaintenanceWindowTaskError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::UpdateMaintenanceWindowTaskError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "DoesNotExistException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateMaintenanceWindowTaskError {
                        kind: crate::error::UpdateMaintenanceWindowTaskErrorKind::DoesNotExistError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateMaintenanceWindowTaskError::unhandled(e),
                },
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateMaintenanceWindowTaskError {
                        kind:
                            crate::error::UpdateMaintenanceWindowTaskErrorKind::InternalServerError(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateMaintenanceWindowTaskError::unhandled(e),
                },
                _ => crate::error::UpdateMaintenanceWindowTaskError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::update_maintenance_window_task_output::Builder::default();
        builder = crate::json_deser::update_maintenance_window_task_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::UpdateMaintenanceWindowTaskError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateMaintenanceWindowTask {
    type Output = Result<
        crate::output::UpdateMaintenanceWindowTaskOutput,
        crate::error::UpdateMaintenanceWindowTaskError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Changes the Amazon Identity and Access Management (IAM) role that is assigned to the
/// on-premises instance or virtual machines (VM). IAM roles are first assigned to these hybrid
/// instances during the activation process. For more information, see <a>CreateActivation</a>.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct UpdateManagedInstanceRole {
    _private: (),
}
impl UpdateManagedInstanceRole {
    /// Creates a new builder-style object to manufacture [`UpdateManagedInstanceRoleInput`](crate::input::UpdateManagedInstanceRoleInput)
    pub fn builder() -> crate::input::update_managed_instance_role_input::Builder {
        crate::input::update_managed_instance_role_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::UpdateManagedInstanceRoleOutput,
        crate::error::UpdateManagedInstanceRoleError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::UpdateManagedInstanceRoleError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateManagedInstanceRoleError {
                        kind: crate::error::UpdateManagedInstanceRoleErrorKind::InternalServerError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateManagedInstanceRoleError::unhandled(e),
                },
                "InvalidInstanceId" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateManagedInstanceRoleError {
                        kind: crate::error::UpdateManagedInstanceRoleErrorKind::InvalidInstanceId(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateManagedInstanceRoleError::unhandled(e),
                },
                _ => crate::error::UpdateManagedInstanceRoleError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::update_managed_instance_role_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateManagedInstanceRole {
    type Output = Result<
        crate::output::UpdateManagedInstanceRoleOutput,
        crate::error::UpdateManagedInstanceRoleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Edit or change an OpsItem. You must have permission in AWS Identity and Access Management
/// (IAM) to update an OpsItem. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-getting-started.html">Getting started with
/// OpsCenter</a> in the <i>AWS Systems Manager User Guide</i>.</p>
/// <p>Operations engineers and IT professionals use OpsCenter to view, investigate, and remediate
/// operational issues impacting the performance and health of their AWS resources. For more
/// information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter.html">AWS Systems Manager OpsCenter</a> in the
/// <i>AWS Systems Manager User Guide</i>. </p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct UpdateOpsItem {
    _private: (),
}
impl UpdateOpsItem {
    /// Creates a new builder-style object to manufacture [`UpdateOpsItemInput`](crate::input::UpdateOpsItemInput)
    pub fn builder() -> crate::input::update_ops_item_input::Builder {
        crate::input::update_ops_item_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::UpdateOpsItemOutput, crate::error::UpdateOpsItemError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateOpsItemError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateOpsItemError {
                        kind: crate::error::UpdateOpsItemErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateOpsItemError::unhandled(e),
                },
                "OpsItemAlreadyExistsException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateOpsItemError {
                        kind: crate::error::UpdateOpsItemErrorKind::OpsItemAlreadyExistsError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateOpsItemError::unhandled(e),
                },
                "OpsItemInvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateOpsItemError {
                        kind: crate::error::UpdateOpsItemErrorKind::OpsItemInvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateOpsItemError::unhandled(e),
                },
                "OpsItemLimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateOpsItemError {
                        kind: crate::error::UpdateOpsItemErrorKind::OpsItemLimitExceededError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateOpsItemError::unhandled(e),
                },
                "OpsItemNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateOpsItemError {
                        kind: crate::error::UpdateOpsItemErrorKind::OpsItemNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateOpsItemError::unhandled(e),
                },
                _ => crate::error::UpdateOpsItemError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::update_ops_item_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateOpsItem {
    type Output = Result<crate::output::UpdateOpsItemOutput, crate::error::UpdateOpsItemError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Systems Manager calls this API action when you edit OpsMetadata in Application Manager.</p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct UpdateOpsMetadata {
    _private: (),
}
impl UpdateOpsMetadata {
    /// Creates a new builder-style object to manufacture [`UpdateOpsMetadataInput`](crate::input::UpdateOpsMetadataInput)
    pub fn builder() -> crate::input::update_ops_metadata_input::Builder {
        crate::input::update_ops_metadata_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::UpdateOpsMetadataOutput, crate::error::UpdateOpsMetadataError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateOpsMetadataError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateOpsMetadataError { kind: crate::error::UpdateOpsMetadataErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::UpdateOpsMetadataError::unhandled(e)
                }
                "OpsMetadataInvalidArgumentException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateOpsMetadataError { kind: crate::error::UpdateOpsMetadataErrorKind::OpsMetadataInvalidArgumentError(body), meta: generic },
                    Err(e) => crate::error::UpdateOpsMetadataError::unhandled(e)
                }
                "OpsMetadataKeyLimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateOpsMetadataError { kind: crate::error::UpdateOpsMetadataErrorKind::OpsMetadataKeyLimitExceededError(body), meta: generic },
                    Err(e) => crate::error::UpdateOpsMetadataError::unhandled(e)
                }
                "OpsMetadataNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateOpsMetadataError { kind: crate::error::UpdateOpsMetadataErrorKind::OpsMetadataNotFoundError(body), meta: generic },
                    Err(e) => crate::error::UpdateOpsMetadataError::unhandled(e)
                }
                "OpsMetadataTooManyUpdatesException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateOpsMetadataError { kind: crate::error::UpdateOpsMetadataErrorKind::OpsMetadataTooManyUpdatesError(body), meta: generic },
                    Err(e) => crate::error::UpdateOpsMetadataError::unhandled(e)
                }
                _ => crate::error::UpdateOpsMetadataError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::update_ops_metadata_output::Builder::default();
        builder = crate::json_deser::update_ops_metadata_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::UpdateOpsMetadataError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateOpsMetadata {
    type Output =
        Result<crate::output::UpdateOpsMetadataOutput, crate::error::UpdateOpsMetadataError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Modifies an existing patch baseline. Fields not specified in the request are left
/// unchanged.</p>
/// <note>
/// <p>For information about valid key and value pairs in <code>PatchFilters</code> for each
/// supported operating system type, see <a href="http://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html">PatchFilter</a>.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone)]
pub struct UpdatePatchBaseline {
    _private: (),
}
impl UpdatePatchBaseline {
    /// Creates a new builder-style object to manufacture [`UpdatePatchBaselineInput`](crate::input::UpdatePatchBaselineInput)
    pub fn builder() -> crate::input::update_patch_baseline_input::Builder {
        crate::input::update_patch_baseline_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::UpdatePatchBaselineOutput, crate::error::UpdatePatchBaselineError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdatePatchBaselineError::unhandled(generic)),
            };
            return Err(match error_code {
                "DoesNotExistException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdatePatchBaselineError {
                        kind: crate::error::UpdatePatchBaselineErrorKind::DoesNotExistError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdatePatchBaselineError::unhandled(e),
                },
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdatePatchBaselineError {
                        kind: crate::error::UpdatePatchBaselineErrorKind::InternalServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdatePatchBaselineError::unhandled(e),
                },
                _ => crate::error::UpdatePatchBaselineError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::update_patch_baseline_output::Builder::default();
        builder = crate::json_deser::update_patch_baseline_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::UpdatePatchBaselineError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdatePatchBaseline {
    type Output =
        Result<crate::output::UpdatePatchBaselineOutput, crate::error::UpdatePatchBaselineError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Update a resource data sync. After you create a resource data sync for a Region, you can't
/// change the account options for that sync. For example, if you create a sync in the us-east-2
/// (Ohio) Region and you choose the Include only the current account option, you can't edit that
/// sync later and choose the Include all accounts from my AWS Organizations configuration option. Instead,
/// you must delete the first resource data sync, and create a new one.</p>
/// <note>
/// <p>This API action only supports a resource data sync that was created with a SyncFromSource
/// <code>SyncType</code>.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone)]
pub struct UpdateResourceDataSync {
    _private: (),
}
impl UpdateResourceDataSync {
    /// Creates a new builder-style object to manufacture [`UpdateResourceDataSyncInput`](crate::input::UpdateResourceDataSyncInput)
    pub fn builder() -> crate::input::update_resource_data_sync_input::Builder {
        crate::input::update_resource_data_sync_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::UpdateResourceDataSyncOutput,
        crate::error::UpdateResourceDataSyncError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::UpdateResourceDataSyncError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateResourceDataSyncError { kind: crate::error::UpdateResourceDataSyncErrorKind::InternalServerError(body), meta: generic },
                    Err(e) => crate::error::UpdateResourceDataSyncError::unhandled(e)
                }
                "ResourceDataSyncConflictException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateResourceDataSyncError { kind: crate::error::UpdateResourceDataSyncErrorKind::ResourceDataSyncConflictError(body), meta: generic },
                    Err(e) => crate::error::UpdateResourceDataSyncError::unhandled(e)
                }
                "ResourceDataSyncInvalidConfigurationException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateResourceDataSyncError { kind: crate::error::UpdateResourceDataSyncErrorKind::ResourceDataSyncInvalidConfigurationError(body), meta: generic },
                    Err(e) => crate::error::UpdateResourceDataSyncError::unhandled(e)
                }
                "ResourceDataSyncNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateResourceDataSyncError { kind: crate::error::UpdateResourceDataSyncErrorKind::ResourceDataSyncNotFoundError(body), meta: generic },
                    Err(e) => crate::error::UpdateResourceDataSyncError::unhandled(e)
                }
                _ => crate::error::UpdateResourceDataSyncError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::update_resource_data_sync_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateResourceDataSync {
    type Output = Result<
        crate::output::UpdateResourceDataSyncOutput,
        crate::error::UpdateResourceDataSyncError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>
/// <code>ServiceSetting</code> is an account-level setting for an AWS service. This setting
/// defines how a user interacts with or uses a service or a feature of a service. For example, if an
/// AWS service charges money to the account based on feature or service usage, then the AWS service
/// team might create a default setting of "false". This means the user can't use this feature unless
/// they change the setting to "true" and intentionally opt in for a paid feature.</p>
/// <p>Services map a <code>SettingId</code> object to a setting value. AWS services teams define
/// the default value for a <code>SettingId</code>. You can't create a new <code>SettingId</code>,
/// but you can overwrite the default value if you have the <code>ssm:UpdateServiceSetting</code>
/// permission for the setting. Use the <a>GetServiceSetting</a> API action to view the
/// current value. Or, use the <a>ResetServiceSetting</a> to change the value back to the
/// original value defined by the AWS service team.</p>
/// <p>Update the service setting for the account. </p>
#[derive(std::default::Default, std::clone::Clone)]
pub struct UpdateServiceSetting {
    _private: (),
}
impl UpdateServiceSetting {
    /// Creates a new builder-style object to manufacture [`UpdateServiceSettingInput`](crate::input::UpdateServiceSettingInput)
    pub fn builder() -> crate::input::update_service_setting_input::Builder {
        crate::input::update_service_setting_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::UpdateServiceSettingOutput, crate::error::UpdateServiceSettingError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateServiceSettingError::unhandled(generic)),
            };
            return Err(match error_code {
                "InternalServerError" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateServiceSettingError {
                        kind: crate::error::UpdateServiceSettingErrorKind::InternalServerError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateServiceSettingError::unhandled(e),
                },
                "ServiceSettingNotFound" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateServiceSettingError {
                        kind: crate::error::UpdateServiceSettingErrorKind::ServiceSettingNotFound(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateServiceSettingError::unhandled(e),
                },
                "TooManyUpdates" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateServiceSettingError {
                        kind: crate::error::UpdateServiceSettingErrorKind::TooManyUpdates(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateServiceSettingError::unhandled(e),
                },
                _ => crate::error::UpdateServiceSettingError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::update_service_setting_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateServiceSetting {
    type Output =
        Result<crate::output::UpdateServiceSettingOutput, crate::error::UpdateServiceSettingError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}
