// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub fn associate_ops_item_related_item_deser_operation(
    input: &[u8],
    mut builder: crate::output::associate_ops_item_related_item_output::Builder,
) -> std::result::Result<
    crate::output::associate_ops_item_related_item_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::AssociateOpsItemRelatedItemOutputBody = if input.is_empty()
    {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_association_id(parsed_body.association_id);
    Ok(builder)
}

pub fn cancel_maintenance_window_execution_deser_operation(
    input: &[u8],
    mut builder: crate::output::cancel_maintenance_window_execution_output::Builder,
) -> std::result::Result<
    crate::output::cancel_maintenance_window_execution_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::CancelMaintenanceWindowExecutionOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_window_execution_id(parsed_body.window_execution_id);
    Ok(builder)
}

pub fn create_activation_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_activation_output::Builder,
) -> std::result::Result<crate::output::create_activation_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateActivationOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_activation_id(parsed_body.activation_id);
    builder = builder.set_activation_code(parsed_body.activation_code);
    Ok(builder)
}

pub fn create_association_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_association_output::Builder,
) -> std::result::Result<crate::output::create_association_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateAssociationOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_association_description(parsed_body.association_description);
    Ok(builder)
}

pub fn create_association_batch_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_association_batch_output::Builder,
) -> std::result::Result<crate::output::create_association_batch_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::CreateAssociationBatchOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_successful(parsed_body.successful);
    builder = builder.set_failed(parsed_body.failed);
    Ok(builder)
}

pub fn create_document_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_document_output::Builder,
) -> std::result::Result<crate::output::create_document_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateDocumentOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_document_description(parsed_body.document_description);
    Ok(builder)
}

pub fn create_maintenance_window_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_maintenance_window_output::Builder,
) -> std::result::Result<crate::output::create_maintenance_window_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::CreateMaintenanceWindowOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_window_id(parsed_body.window_id);
    Ok(builder)
}

pub fn create_ops_item_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_ops_item_output::Builder,
) -> std::result::Result<crate::output::create_ops_item_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateOpsItemOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_ops_item_id(parsed_body.ops_item_id);
    Ok(builder)
}

pub fn create_ops_metadata_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_ops_metadata_output::Builder,
) -> std::result::Result<crate::output::create_ops_metadata_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateOpsMetadataOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_ops_metadata_arn(parsed_body.ops_metadata_arn);
    Ok(builder)
}

pub fn create_patch_baseline_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_patch_baseline_output::Builder,
) -> std::result::Result<crate::output::create_patch_baseline_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreatePatchBaselineOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_baseline_id(parsed_body.baseline_id);
    Ok(builder)
}

pub fn delete_inventory_deser_operation(
    input: &[u8],
    mut builder: crate::output::delete_inventory_output::Builder,
) -> std::result::Result<crate::output::delete_inventory_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DeleteInventoryOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_deletion_id(parsed_body.deletion_id);
    builder = builder.set_type_name(parsed_body.type_name);
    builder = builder.set_deletion_summary(parsed_body.deletion_summary);
    Ok(builder)
}

pub fn delete_maintenance_window_deser_operation(
    input: &[u8],
    mut builder: crate::output::delete_maintenance_window_output::Builder,
) -> std::result::Result<crate::output::delete_maintenance_window_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::DeleteMaintenanceWindowOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_window_id(parsed_body.window_id);
    Ok(builder)
}

pub fn delete_parameters_deser_operation(
    input: &[u8],
    mut builder: crate::output::delete_parameters_output::Builder,
) -> std::result::Result<crate::output::delete_parameters_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DeleteParametersOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_deleted_parameters(parsed_body.deleted_parameters);
    builder = builder.set_invalid_parameters(parsed_body.invalid_parameters);
    Ok(builder)
}

pub fn delete_patch_baseline_deser_operation(
    input: &[u8],
    mut builder: crate::output::delete_patch_baseline_output::Builder,
) -> std::result::Result<crate::output::delete_patch_baseline_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DeletePatchBaselineOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_baseline_id(parsed_body.baseline_id);
    Ok(builder)
}

pub fn deregister_patch_baseline_for_patch_group_deser_operation(
    input: &[u8],
    mut builder: crate::output::deregister_patch_baseline_for_patch_group_output::Builder,
) -> std::result::Result<
    crate::output::deregister_patch_baseline_for_patch_group_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DeregisterPatchBaselineForPatchGroupOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_baseline_id(parsed_body.baseline_id);
    builder = builder.set_patch_group(parsed_body.patch_group);
    Ok(builder)
}

pub fn deregister_target_from_maintenance_window_deser_operation(
    input: &[u8],
    mut builder: crate::output::deregister_target_from_maintenance_window_output::Builder,
) -> std::result::Result<
    crate::output::deregister_target_from_maintenance_window_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DeregisterTargetFromMaintenanceWindowOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_window_id(parsed_body.window_id);
    builder = builder.set_window_target_id(parsed_body.window_target_id);
    Ok(builder)
}

pub fn deregister_task_from_maintenance_window_deser_operation(
    input: &[u8],
    mut builder: crate::output::deregister_task_from_maintenance_window_output::Builder,
) -> std::result::Result<
    crate::output::deregister_task_from_maintenance_window_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DeregisterTaskFromMaintenanceWindowOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_window_id(parsed_body.window_id);
    builder = builder.set_window_task_id(parsed_body.window_task_id);
    Ok(builder)
}

pub fn describe_activations_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_activations_output::Builder,
) -> std::result::Result<crate::output::describe_activations_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeActivationsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_activation_list(parsed_body.activation_list);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_association_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_association_output::Builder,
) -> std::result::Result<crate::output::describe_association_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeAssociationOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_association_description(parsed_body.association_description);
    Ok(builder)
}

pub fn describe_association_executions_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_association_executions_output::Builder,
) -> std::result::Result<
    crate::output::describe_association_executions_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeAssociationExecutionsOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_association_executions(parsed_body.association_executions);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_association_execution_targets_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_association_execution_targets_output::Builder,
) -> std::result::Result<
    crate::output::describe_association_execution_targets_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeAssociationExecutionTargetsOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_association_execution_targets(parsed_body.association_execution_targets);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_automation_executions_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_automation_executions_output::Builder,
) -> std::result::Result<
    crate::output::describe_automation_executions_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeAutomationExecutionsOutputBody = if input.is_empty()
    {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder
        .set_automation_execution_metadata_list(parsed_body.automation_execution_metadata_list);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_automation_step_executions_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_automation_step_executions_output::Builder,
) -> std::result::Result<
    crate::output::describe_automation_step_executions_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeAutomationStepExecutionsOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_step_executions(parsed_body.step_executions);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_available_patches_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_available_patches_output::Builder,
) -> std::result::Result<crate::output::describe_available_patches_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::DescribeAvailablePatchesOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_patches(parsed_body.patches);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_document_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_document_output::Builder,
) -> std::result::Result<crate::output::describe_document_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeDocumentOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_document(parsed_body.document);
    Ok(builder)
}

pub fn describe_document_permission_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_document_permission_output::Builder,
) -> std::result::Result<
    crate::output::describe_document_permission_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeDocumentPermissionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_account_ids(parsed_body.account_ids);
    builder = builder.set_account_sharing_info_list(parsed_body.account_sharing_info_list);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_effective_instance_associations_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_effective_instance_associations_output::Builder,
) -> std::result::Result<
    crate::output::describe_effective_instance_associations_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeEffectiveInstanceAssociationsOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_associations(parsed_body.associations);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_effective_patches_for_patch_baseline_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_effective_patches_for_patch_baseline_output::Builder,
) -> std::result::Result<
    crate::output::describe_effective_patches_for_patch_baseline_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeEffectivePatchesForPatchBaselineOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_effective_patches(parsed_body.effective_patches);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_instance_associations_status_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_instance_associations_status_output::Builder,
) -> std::result::Result<
    crate::output::describe_instance_associations_status_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeInstanceAssociationsStatusOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder
        .set_instance_association_status_infos(parsed_body.instance_association_status_infos);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_instance_information_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_instance_information_output::Builder,
) -> std::result::Result<
    crate::output::describe_instance_information_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeInstanceInformationOutputBody = if input.is_empty()
    {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_instance_information_list(parsed_body.instance_information_list);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_instance_patches_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_instance_patches_output::Builder,
) -> std::result::Result<crate::output::describe_instance_patches_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::DescribeInstancePatchesOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_patches(parsed_body.patches);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_instance_patch_states_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_instance_patch_states_output::Builder,
) -> std::result::Result<
    crate::output::describe_instance_patch_states_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeInstancePatchStatesOutputBody = if input.is_empty()
    {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_instance_patch_states(parsed_body.instance_patch_states);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_instance_patch_states_for_patch_group_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_instance_patch_states_for_patch_group_output::Builder,
) -> std::result::Result<
    crate::output::describe_instance_patch_states_for_patch_group_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeInstancePatchStatesForPatchGroupOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_instance_patch_states(parsed_body.instance_patch_states);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_inventory_deletions_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_inventory_deletions_output::Builder,
) -> std::result::Result<
    crate::output::describe_inventory_deletions_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeInventoryDeletionsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_inventory_deletions(parsed_body.inventory_deletions);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_maintenance_window_executions_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_maintenance_window_executions_output::Builder,
) -> std::result::Result<
    crate::output::describe_maintenance_window_executions_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeMaintenanceWindowExecutionsOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_window_executions(parsed_body.window_executions);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_maintenance_window_execution_task_invocations_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_maintenance_window_execution_task_invocations_output::Builder,
) -> std::result::Result<
    crate::output::describe_maintenance_window_execution_task_invocations_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeMaintenanceWindowExecutionTaskInvocationsOutputBody = if input.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase when a required field was missing.
                            serde_json::from_slice(b"{}")?
                        } else {
                            serde_json::from_slice(input)?
                        };
    builder = builder.set_window_execution_task_invocation_identities(
        parsed_body.window_execution_task_invocation_identities,
    );
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_maintenance_window_execution_tasks_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_maintenance_window_execution_tasks_output::Builder,
) -> std::result::Result<
    crate::output::describe_maintenance_window_execution_tasks_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeMaintenanceWindowExecutionTasksOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder =
        builder.set_window_execution_task_identities(parsed_body.window_execution_task_identities);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_maintenance_windows_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_maintenance_windows_output::Builder,
) -> std::result::Result<
    crate::output::describe_maintenance_windows_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeMaintenanceWindowsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_window_identities(parsed_body.window_identities);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_maintenance_window_schedule_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_maintenance_window_schedule_output::Builder,
) -> std::result::Result<
    crate::output::describe_maintenance_window_schedule_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeMaintenanceWindowScheduleOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_scheduled_window_executions(parsed_body.scheduled_window_executions);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_maintenance_windows_for_target_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_maintenance_windows_for_target_output::Builder,
) -> std::result::Result<
    crate::output::describe_maintenance_windows_for_target_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeMaintenanceWindowsForTargetOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_window_identities(parsed_body.window_identities);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_maintenance_window_targets_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_maintenance_window_targets_output::Builder,
) -> std::result::Result<
    crate::output::describe_maintenance_window_targets_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeMaintenanceWindowTargetsOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_targets(parsed_body.targets);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_maintenance_window_tasks_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_maintenance_window_tasks_output::Builder,
) -> std::result::Result<
    crate::output::describe_maintenance_window_tasks_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeMaintenanceWindowTasksOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_tasks(parsed_body.tasks);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_ops_items_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_ops_items_output::Builder,
) -> std::result::Result<crate::output::describe_ops_items_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeOpsItemsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_next_token(parsed_body.next_token);
    builder = builder.set_ops_item_summaries(parsed_body.ops_item_summaries);
    Ok(builder)
}

pub fn describe_parameters_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_parameters_output::Builder,
) -> std::result::Result<crate::output::describe_parameters_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeParametersOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_parameters(parsed_body.parameters);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_patch_baselines_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_patch_baselines_output::Builder,
) -> std::result::Result<crate::output::describe_patch_baselines_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::DescribePatchBaselinesOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_baseline_identities(parsed_body.baseline_identities);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_patch_groups_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_patch_groups_output::Builder,
) -> std::result::Result<crate::output::describe_patch_groups_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribePatchGroupsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_mappings(parsed_body.mappings);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_patch_group_state_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_patch_group_state_output::Builder,
) -> std::result::Result<crate::output::describe_patch_group_state_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::DescribePatchGroupStateOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_instances(Some(parsed_body.instances));
    builder = builder
        .set_instances_with_installed_patches(Some(parsed_body.instances_with_installed_patches));
    builder = builder.set_instances_with_installed_other_patches(Some(
        parsed_body.instances_with_installed_other_patches,
    ));
    builder = builder.set_instances_with_installed_pending_reboot_patches(
        parsed_body.instances_with_installed_pending_reboot_patches,
    );
    builder = builder.set_instances_with_installed_rejected_patches(
        parsed_body.instances_with_installed_rejected_patches,
    );
    builder = builder
        .set_instances_with_missing_patches(Some(parsed_body.instances_with_missing_patches));
    builder =
        builder.set_instances_with_failed_patches(Some(parsed_body.instances_with_failed_patches));
    builder = builder.set_instances_with_not_applicable_patches(Some(
        parsed_body.instances_with_not_applicable_patches,
    ));
    builder = builder.set_instances_with_unreported_not_applicable_patches(
        parsed_body.instances_with_unreported_not_applicable_patches,
    );
    builder = builder.set_instances_with_critical_non_compliant_patches(
        parsed_body.instances_with_critical_non_compliant_patches,
    );
    builder = builder.set_instances_with_security_non_compliant_patches(
        parsed_body.instances_with_security_non_compliant_patches,
    );
    builder = builder.set_instances_with_other_non_compliant_patches(
        parsed_body.instances_with_other_non_compliant_patches,
    );
    Ok(builder)
}

pub fn describe_patch_properties_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_patch_properties_output::Builder,
) -> std::result::Result<crate::output::describe_patch_properties_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::DescribePatchPropertiesOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_properties(parsed_body.properties);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_sessions_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_sessions_output::Builder,
) -> std::result::Result<crate::output::describe_sessions_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeSessionsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_sessions(parsed_body.sessions);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn get_automation_execution_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_automation_execution_output::Builder,
) -> std::result::Result<crate::output::get_automation_execution_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::GetAutomationExecutionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_automation_execution(parsed_body.automation_execution);
    Ok(builder)
}

pub fn get_calendar_state_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_calendar_state_output::Builder,
) -> std::result::Result<crate::output::get_calendar_state_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetCalendarStateOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_state(parsed_body.state);
    builder = builder.set_at_time(parsed_body.at_time);
    builder = builder.set_next_transition_time(parsed_body.next_transition_time);
    Ok(builder)
}

pub fn get_command_invocation_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_command_invocation_output::Builder,
) -> std::result::Result<crate::output::get_command_invocation_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetCommandInvocationOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_command_id(parsed_body.command_id);
    builder = builder.set_instance_id(parsed_body.instance_id);
    builder = builder.set_comment(parsed_body.comment);
    builder = builder.set_document_name(parsed_body.document_name);
    builder = builder.set_document_version(parsed_body.document_version);
    builder = builder.set_plugin_name(parsed_body.plugin_name);
    builder = builder.set_response_code(Some(parsed_body.response_code));
    builder = builder.set_execution_start_date_time(parsed_body.execution_start_date_time);
    builder = builder.set_execution_elapsed_time(parsed_body.execution_elapsed_time);
    builder = builder.set_execution_end_date_time(parsed_body.execution_end_date_time);
    builder = builder.set_status(parsed_body.status);
    builder = builder.set_status_details(parsed_body.status_details);
    builder = builder.set_standard_output_content(parsed_body.standard_output_content);
    builder = builder.set_standard_output_url(parsed_body.standard_output_url);
    builder = builder.set_standard_error_content(parsed_body.standard_error_content);
    builder = builder.set_standard_error_url(parsed_body.standard_error_url);
    builder = builder.set_cloud_watch_output_config(parsed_body.cloud_watch_output_config);
    Ok(builder)
}

pub fn get_connection_status_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_connection_status_output::Builder,
) -> std::result::Result<crate::output::get_connection_status_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetConnectionStatusOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_target(parsed_body.target);
    builder = builder.set_status(parsed_body.status);
    Ok(builder)
}

pub fn get_default_patch_baseline_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_default_patch_baseline_output::Builder,
) -> std::result::Result<crate::output::get_default_patch_baseline_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::GetDefaultPatchBaselineOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_baseline_id(parsed_body.baseline_id);
    builder = builder.set_operating_system(parsed_body.operating_system);
    Ok(builder)
}

pub fn get_deployable_patch_snapshot_for_instance_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_deployable_patch_snapshot_for_instance_output::Builder,
) -> std::result::Result<
    crate::output::get_deployable_patch_snapshot_for_instance_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::GetDeployablePatchSnapshotForInstanceOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_instance_id(parsed_body.instance_id);
    builder = builder.set_snapshot_id(parsed_body.snapshot_id);
    builder = builder.set_snapshot_download_url(parsed_body.snapshot_download_url);
    builder = builder.set_product(parsed_body.product);
    Ok(builder)
}

pub fn get_document_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_document_output::Builder,
) -> std::result::Result<crate::output::get_document_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetDocumentOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_created_date(parsed_body.created_date);
    builder = builder.set_display_name(parsed_body.display_name);
    builder = builder.set_version_name(parsed_body.version_name);
    builder = builder.set_document_version(parsed_body.document_version);
    builder = builder.set_status(parsed_body.status);
    builder = builder.set_status_information(parsed_body.status_information);
    builder = builder.set_content(parsed_body.content);
    builder = builder.set_document_type(parsed_body.document_type);
    builder = builder.set_document_format(parsed_body.document_format);
    builder = builder.set_requires(parsed_body.requires);
    builder = builder.set_attachments_content(parsed_body.attachments_content);
    builder = builder.set_review_status(parsed_body.review_status);
    Ok(builder)
}

pub fn get_inventory_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_inventory_output::Builder,
) -> std::result::Result<crate::output::get_inventory_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetInventoryOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_entities(parsed_body.entities);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn get_inventory_schema_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_inventory_schema_output::Builder,
) -> std::result::Result<crate::output::get_inventory_schema_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetInventorySchemaOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_schemas(parsed_body.schemas);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn get_maintenance_window_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_maintenance_window_output::Builder,
) -> std::result::Result<crate::output::get_maintenance_window_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetMaintenanceWindowOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_window_id(parsed_body.window_id);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_start_date(parsed_body.start_date);
    builder = builder.set_end_date(parsed_body.end_date);
    builder = builder.set_schedule(parsed_body.schedule);
    builder = builder.set_schedule_timezone(parsed_body.schedule_timezone);
    builder = builder.set_schedule_offset(parsed_body.schedule_offset);
    builder = builder.set_next_execution_time(parsed_body.next_execution_time);
    builder = builder.set_duration(Some(parsed_body.duration));
    builder = builder.set_cutoff(Some(parsed_body.cutoff));
    builder = builder.set_allow_unassociated_targets(Some(parsed_body.allow_unassociated_targets));
    builder = builder.set_enabled(Some(parsed_body.enabled));
    builder = builder.set_created_date(parsed_body.created_date);
    builder = builder.set_modified_date(parsed_body.modified_date);
    Ok(builder)
}

pub fn get_maintenance_window_execution_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_maintenance_window_execution_output::Builder,
) -> std::result::Result<
    crate::output::get_maintenance_window_execution_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::GetMaintenanceWindowExecutionOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_window_execution_id(parsed_body.window_execution_id);
    builder = builder.set_task_ids(parsed_body.task_ids);
    builder = builder.set_status(parsed_body.status);
    builder = builder.set_status_details(parsed_body.status_details);
    builder = builder.set_start_time(parsed_body.start_time);
    builder = builder.set_end_time(parsed_body.end_time);
    Ok(builder)
}

pub fn get_maintenance_window_execution_task_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_maintenance_window_execution_task_output::Builder,
) -> std::result::Result<
    crate::output::get_maintenance_window_execution_task_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::GetMaintenanceWindowExecutionTaskOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_window_execution_id(parsed_body.window_execution_id);
    builder = builder.set_task_execution_id(parsed_body.task_execution_id);
    builder = builder.set_task_arn(parsed_body.task_arn);
    builder = builder.set_service_role(parsed_body.service_role);
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_task_parameters(parsed_body.task_parameters);
    builder = builder.set_priority(Some(parsed_body.priority));
    builder = builder.set_max_concurrency(parsed_body.max_concurrency);
    builder = builder.set_max_errors(parsed_body.max_errors);
    builder = builder.set_status(parsed_body.status);
    builder = builder.set_status_details(parsed_body.status_details);
    builder = builder.set_start_time(parsed_body.start_time);
    builder = builder.set_end_time(parsed_body.end_time);
    Ok(builder)
}

pub fn get_maintenance_window_execution_task_invocation_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_maintenance_window_execution_task_invocation_output::Builder,
) -> std::result::Result<
    crate::output::get_maintenance_window_execution_task_invocation_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::GetMaintenanceWindowExecutionTaskInvocationOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_window_execution_id(parsed_body.window_execution_id);
    builder = builder.set_task_execution_id(parsed_body.task_execution_id);
    builder = builder.set_invocation_id(parsed_body.invocation_id);
    builder = builder.set_execution_id(parsed_body.execution_id);
    builder = builder.set_task_type(parsed_body.task_type);
    builder = builder.set_parameters(parsed_body.parameters);
    builder = builder.set_status(parsed_body.status);
    builder = builder.set_status_details(parsed_body.status_details);
    builder = builder.set_start_time(parsed_body.start_time);
    builder = builder.set_end_time(parsed_body.end_time);
    builder = builder.set_owner_information(parsed_body.owner_information);
    builder = builder.set_window_target_id(parsed_body.window_target_id);
    Ok(builder)
}

pub fn get_maintenance_window_task_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_maintenance_window_task_output::Builder,
) -> std::result::Result<
    crate::output::get_maintenance_window_task_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::GetMaintenanceWindowTaskOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_window_id(parsed_body.window_id);
    builder = builder.set_window_task_id(parsed_body.window_task_id);
    builder = builder.set_targets(parsed_body.targets);
    builder = builder.set_task_arn(parsed_body.task_arn);
    builder = builder.set_service_role_arn(parsed_body.service_role_arn);
    builder = builder.set_task_type(parsed_body.task_type);
    builder = builder.set_task_parameters(parsed_body.task_parameters);
    builder = builder.set_task_invocation_parameters(parsed_body.task_invocation_parameters);
    builder = builder.set_priority(Some(parsed_body.priority));
    builder = builder.set_max_concurrency(parsed_body.max_concurrency);
    builder = builder.set_max_errors(parsed_body.max_errors);
    builder = builder.set_logging_info(parsed_body.logging_info);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_description(parsed_body.description);
    Ok(builder)
}

pub fn get_ops_item_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_ops_item_output::Builder,
) -> std::result::Result<crate::output::get_ops_item_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetOpsItemOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_ops_item(parsed_body.ops_item);
    Ok(builder)
}

pub fn get_ops_metadata_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_ops_metadata_output::Builder,
) -> std::result::Result<crate::output::get_ops_metadata_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetOpsMetadataOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_resource_id(parsed_body.resource_id);
    builder = builder.set_metadata(parsed_body.metadata);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn get_ops_summary_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_ops_summary_output::Builder,
) -> std::result::Result<crate::output::get_ops_summary_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetOpsSummaryOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_entities(parsed_body.entities);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn get_parameter_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_parameter_output::Builder,
) -> std::result::Result<crate::output::get_parameter_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetParameterOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_parameter(parsed_body.parameter);
    Ok(builder)
}

pub fn get_parameter_history_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_parameter_history_output::Builder,
) -> std::result::Result<crate::output::get_parameter_history_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetParameterHistoryOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_parameters(parsed_body.parameters);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn get_parameters_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_parameters_output::Builder,
) -> std::result::Result<crate::output::get_parameters_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetParametersOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_parameters(parsed_body.parameters);
    builder = builder.set_invalid_parameters(parsed_body.invalid_parameters);
    Ok(builder)
}

pub fn get_parameters_by_path_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_parameters_by_path_output::Builder,
) -> std::result::Result<crate::output::get_parameters_by_path_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetParametersByPathOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_parameters(parsed_body.parameters);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn get_patch_baseline_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_patch_baseline_output::Builder,
) -> std::result::Result<crate::output::get_patch_baseline_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetPatchBaselineOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_baseline_id(parsed_body.baseline_id);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_operating_system(parsed_body.operating_system);
    builder = builder.set_global_filters(parsed_body.global_filters);
    builder = builder.set_approval_rules(parsed_body.approval_rules);
    builder = builder.set_approved_patches(parsed_body.approved_patches);
    builder = builder
        .set_approved_patches_compliance_level(parsed_body.approved_patches_compliance_level);
    builder = builder
        .set_approved_patches_enable_non_security(parsed_body.approved_patches_enable_non_security);
    builder = builder.set_rejected_patches(parsed_body.rejected_patches);
    builder = builder.set_rejected_patches_action(parsed_body.rejected_patches_action);
    builder = builder.set_patch_groups(parsed_body.patch_groups);
    builder = builder.set_created_date(parsed_body.created_date);
    builder = builder.set_modified_date(parsed_body.modified_date);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_sources(parsed_body.sources);
    Ok(builder)
}

pub fn get_patch_baseline_for_patch_group_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_patch_baseline_for_patch_group_output::Builder,
) -> std::result::Result<
    crate::output::get_patch_baseline_for_patch_group_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::GetPatchBaselineForPatchGroupOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_baseline_id(parsed_body.baseline_id);
    builder = builder.set_patch_group(parsed_body.patch_group);
    builder = builder.set_operating_system(parsed_body.operating_system);
    Ok(builder)
}

pub fn get_service_setting_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_service_setting_output::Builder,
) -> std::result::Result<crate::output::get_service_setting_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetServiceSettingOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_service_setting(parsed_body.service_setting);
    Ok(builder)
}

pub fn label_parameter_version_deser_operation(
    input: &[u8],
    mut builder: crate::output::label_parameter_version_output::Builder,
) -> std::result::Result<crate::output::label_parameter_version_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::LabelParameterVersionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_invalid_labels(parsed_body.invalid_labels);
    builder = builder.set_parameter_version(Some(parsed_body.parameter_version));
    Ok(builder)
}

pub fn list_associations_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_associations_output::Builder,
) -> std::result::Result<crate::output::list_associations_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListAssociationsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_associations(parsed_body.associations);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_association_versions_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_association_versions_output::Builder,
) -> std::result::Result<crate::output::list_association_versions_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::ListAssociationVersionsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_association_versions(parsed_body.association_versions);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_command_invocations_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_command_invocations_output::Builder,
) -> std::result::Result<crate::output::list_command_invocations_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::ListCommandInvocationsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_command_invocations(parsed_body.command_invocations);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_commands_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_commands_output::Builder,
) -> std::result::Result<crate::output::list_commands_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListCommandsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_commands(parsed_body.commands);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_compliance_items_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_compliance_items_output::Builder,
) -> std::result::Result<crate::output::list_compliance_items_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListComplianceItemsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_compliance_items(parsed_body.compliance_items);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_compliance_summaries_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_compliance_summaries_output::Builder,
) -> std::result::Result<crate::output::list_compliance_summaries_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::ListComplianceSummariesOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_compliance_summary_items(parsed_body.compliance_summary_items);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_document_metadata_history_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_document_metadata_history_output::Builder,
) -> std::result::Result<
    crate::output::list_document_metadata_history_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::ListDocumentMetadataHistoryOutputBody = if input.is_empty()
    {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_document_version(parsed_body.document_version);
    builder = builder.set_author(parsed_body.author);
    builder = builder.set_metadata(parsed_body.metadata);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_documents_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_documents_output::Builder,
) -> std::result::Result<crate::output::list_documents_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListDocumentsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_document_identifiers(parsed_body.document_identifiers);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_document_versions_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_document_versions_output::Builder,
) -> std::result::Result<crate::output::list_document_versions_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListDocumentVersionsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_document_versions(parsed_body.document_versions);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_inventory_entries_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_inventory_entries_output::Builder,
) -> std::result::Result<crate::output::list_inventory_entries_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListInventoryEntriesOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type_name(parsed_body.type_name);
    builder = builder.set_instance_id(parsed_body.instance_id);
    builder = builder.set_schema_version(parsed_body.schema_version);
    builder = builder.set_capture_time(parsed_body.capture_time);
    builder = builder.set_entries(parsed_body.entries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_ops_item_events_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_ops_item_events_output::Builder,
) -> std::result::Result<crate::output::list_ops_item_events_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListOpsItemEventsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_next_token(parsed_body.next_token);
    builder = builder.set_summaries(parsed_body.summaries);
    Ok(builder)
}

pub fn list_ops_item_related_items_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_ops_item_related_items_output::Builder,
) -> std::result::Result<
    crate::output::list_ops_item_related_items_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::ListOpsItemRelatedItemsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_next_token(parsed_body.next_token);
    builder = builder.set_summaries(parsed_body.summaries);
    Ok(builder)
}

pub fn list_ops_metadata_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_ops_metadata_output::Builder,
) -> std::result::Result<crate::output::list_ops_metadata_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListOpsMetadataOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_ops_metadata_list(parsed_body.ops_metadata_list);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_resource_compliance_summaries_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_resource_compliance_summaries_output::Builder,
) -> std::result::Result<
    crate::output::list_resource_compliance_summaries_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::ListResourceComplianceSummariesOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder
        .set_resource_compliance_summary_items(parsed_body.resource_compliance_summary_items);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_resource_data_sync_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_resource_data_sync_output::Builder,
) -> std::result::Result<crate::output::list_resource_data_sync_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::ListResourceDataSyncOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_resource_data_sync_items(parsed_body.resource_data_sync_items);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_tags_for_resource_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_tags_for_resource_output::Builder,
) -> std::result::Result<crate::output::list_tags_for_resource_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListTagsForResourceOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_tag_list(parsed_body.tag_list);
    Ok(builder)
}

pub fn put_inventory_deser_operation(
    input: &[u8],
    mut builder: crate::output::put_inventory_output::Builder,
) -> std::result::Result<crate::output::put_inventory_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::PutInventoryOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn put_parameter_deser_operation(
    input: &[u8],
    mut builder: crate::output::put_parameter_output::Builder,
) -> std::result::Result<crate::output::put_parameter_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::PutParameterOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_version(Some(parsed_body.version));
    builder = builder.set_tier(parsed_body.tier);
    Ok(builder)
}

pub fn register_default_patch_baseline_deser_operation(
    input: &[u8],
    mut builder: crate::output::register_default_patch_baseline_output::Builder,
) -> std::result::Result<
    crate::output::register_default_patch_baseline_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::RegisterDefaultPatchBaselineOutputBody = if input.is_empty()
    {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_baseline_id(parsed_body.baseline_id);
    Ok(builder)
}

pub fn register_patch_baseline_for_patch_group_deser_operation(
    input: &[u8],
    mut builder: crate::output::register_patch_baseline_for_patch_group_output::Builder,
) -> std::result::Result<
    crate::output::register_patch_baseline_for_patch_group_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::RegisterPatchBaselineForPatchGroupOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_baseline_id(parsed_body.baseline_id);
    builder = builder.set_patch_group(parsed_body.patch_group);
    Ok(builder)
}

pub fn register_target_with_maintenance_window_deser_operation(
    input: &[u8],
    mut builder: crate::output::register_target_with_maintenance_window_output::Builder,
) -> std::result::Result<
    crate::output::register_target_with_maintenance_window_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::RegisterTargetWithMaintenanceWindowOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_window_target_id(parsed_body.window_target_id);
    Ok(builder)
}

pub fn register_task_with_maintenance_window_deser_operation(
    input: &[u8],
    mut builder: crate::output::register_task_with_maintenance_window_output::Builder,
) -> std::result::Result<
    crate::output::register_task_with_maintenance_window_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::RegisterTaskWithMaintenanceWindowOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_window_task_id(parsed_body.window_task_id);
    Ok(builder)
}

pub fn reset_service_setting_deser_operation(
    input: &[u8],
    mut builder: crate::output::reset_service_setting_output::Builder,
) -> std::result::Result<crate::output::reset_service_setting_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ResetServiceSettingOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_service_setting(parsed_body.service_setting);
    Ok(builder)
}

pub fn resume_session_deser_operation(
    input: &[u8],
    mut builder: crate::output::resume_session_output::Builder,
) -> std::result::Result<crate::output::resume_session_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ResumeSessionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_session_id(parsed_body.session_id);
    builder = builder.set_token_value(parsed_body.token_value);
    builder = builder.set_stream_url(parsed_body.stream_url);
    Ok(builder)
}

pub fn send_command_deser_operation(
    input: &[u8],
    mut builder: crate::output::send_command_output::Builder,
) -> std::result::Result<crate::output::send_command_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::SendCommandOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_command(parsed_body.command);
    Ok(builder)
}

pub fn start_automation_execution_deser_operation(
    input: &[u8],
    mut builder: crate::output::start_automation_execution_output::Builder,
) -> std::result::Result<crate::output::start_automation_execution_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::StartAutomationExecutionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_automation_execution_id(parsed_body.automation_execution_id);
    Ok(builder)
}

pub fn start_change_request_execution_deser_operation(
    input: &[u8],
    mut builder: crate::output::start_change_request_execution_output::Builder,
) -> std::result::Result<
    crate::output::start_change_request_execution_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::StartChangeRequestExecutionOutputBody = if input.is_empty()
    {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_automation_execution_id(parsed_body.automation_execution_id);
    Ok(builder)
}

pub fn start_session_deser_operation(
    input: &[u8],
    mut builder: crate::output::start_session_output::Builder,
) -> std::result::Result<crate::output::start_session_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::StartSessionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_session_id(parsed_body.session_id);
    builder = builder.set_token_value(parsed_body.token_value);
    builder = builder.set_stream_url(parsed_body.stream_url);
    Ok(builder)
}

pub fn terminate_session_deser_operation(
    input: &[u8],
    mut builder: crate::output::terminate_session_output::Builder,
) -> std::result::Result<crate::output::terminate_session_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::TerminateSessionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_session_id(parsed_body.session_id);
    Ok(builder)
}

pub fn unlabel_parameter_version_deser_operation(
    input: &[u8],
    mut builder: crate::output::unlabel_parameter_version_output::Builder,
) -> std::result::Result<crate::output::unlabel_parameter_version_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::UnlabelParameterVersionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_removed_labels(parsed_body.removed_labels);
    builder = builder.set_invalid_labels(parsed_body.invalid_labels);
    Ok(builder)
}

pub fn update_association_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_association_output::Builder,
) -> std::result::Result<crate::output::update_association_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateAssociationOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_association_description(parsed_body.association_description);
    Ok(builder)
}

pub fn update_association_status_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_association_status_output::Builder,
) -> std::result::Result<crate::output::update_association_status_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::UpdateAssociationStatusOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_association_description(parsed_body.association_description);
    Ok(builder)
}

pub fn update_document_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_document_output::Builder,
) -> std::result::Result<crate::output::update_document_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateDocumentOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_document_description(parsed_body.document_description);
    Ok(builder)
}

pub fn update_document_default_version_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_document_default_version_output::Builder,
) -> std::result::Result<
    crate::output::update_document_default_version_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::UpdateDocumentDefaultVersionOutputBody = if input.is_empty()
    {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_description(parsed_body.description);
    Ok(builder)
}

pub fn update_maintenance_window_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_maintenance_window_output::Builder,
) -> std::result::Result<crate::output::update_maintenance_window_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::UpdateMaintenanceWindowOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_window_id(parsed_body.window_id);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_start_date(parsed_body.start_date);
    builder = builder.set_end_date(parsed_body.end_date);
    builder = builder.set_schedule(parsed_body.schedule);
    builder = builder.set_schedule_timezone(parsed_body.schedule_timezone);
    builder = builder.set_schedule_offset(parsed_body.schedule_offset);
    builder = builder.set_duration(Some(parsed_body.duration));
    builder = builder.set_cutoff(Some(parsed_body.cutoff));
    builder = builder.set_allow_unassociated_targets(Some(parsed_body.allow_unassociated_targets));
    builder = builder.set_enabled(Some(parsed_body.enabled));
    Ok(builder)
}

pub fn update_maintenance_window_target_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_maintenance_window_target_output::Builder,
) -> std::result::Result<
    crate::output::update_maintenance_window_target_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::UpdateMaintenanceWindowTargetOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_window_id(parsed_body.window_id);
    builder = builder.set_window_target_id(parsed_body.window_target_id);
    builder = builder.set_targets(parsed_body.targets);
    builder = builder.set_owner_information(parsed_body.owner_information);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_description(parsed_body.description);
    Ok(builder)
}

pub fn update_maintenance_window_task_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_maintenance_window_task_output::Builder,
) -> std::result::Result<
    crate::output::update_maintenance_window_task_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::UpdateMaintenanceWindowTaskOutputBody = if input.is_empty()
    {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_window_id(parsed_body.window_id);
    builder = builder.set_window_task_id(parsed_body.window_task_id);
    builder = builder.set_targets(parsed_body.targets);
    builder = builder.set_task_arn(parsed_body.task_arn);
    builder = builder.set_service_role_arn(parsed_body.service_role_arn);
    builder = builder.set_task_parameters(parsed_body.task_parameters);
    builder = builder.set_task_invocation_parameters(parsed_body.task_invocation_parameters);
    builder = builder.set_priority(Some(parsed_body.priority));
    builder = builder.set_max_concurrency(parsed_body.max_concurrency);
    builder = builder.set_max_errors(parsed_body.max_errors);
    builder = builder.set_logging_info(parsed_body.logging_info);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_description(parsed_body.description);
    Ok(builder)
}

pub fn update_ops_metadata_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_ops_metadata_output::Builder,
) -> std::result::Result<crate::output::update_ops_metadata_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateOpsMetadataOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_ops_metadata_arn(parsed_body.ops_metadata_arn);
    Ok(builder)
}

pub fn update_patch_baseline_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_patch_baseline_output::Builder,
) -> std::result::Result<crate::output::update_patch_baseline_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdatePatchBaselineOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_baseline_id(parsed_body.baseline_id);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_operating_system(parsed_body.operating_system);
    builder = builder.set_global_filters(parsed_body.global_filters);
    builder = builder.set_approval_rules(parsed_body.approval_rules);
    builder = builder.set_approved_patches(parsed_body.approved_patches);
    builder = builder
        .set_approved_patches_compliance_level(parsed_body.approved_patches_compliance_level);
    builder = builder
        .set_approved_patches_enable_non_security(parsed_body.approved_patches_enable_non_security);
    builder = builder.set_rejected_patches(parsed_body.rejected_patches);
    builder = builder.set_rejected_patches_action(parsed_body.rejected_patches_action);
    builder = builder.set_created_date(parsed_body.created_date);
    builder = builder.set_modified_date(parsed_body.modified_date);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_sources(parsed_body.sources);
    Ok(builder)
}
